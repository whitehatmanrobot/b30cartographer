       public void Dispose()
        {
            GC.SuppressFinalize(this);
            Dispose(true);
        }

        #endregion

        private void Dispose(bool disposing)
        {
            if(disposing)
            {
                lock(this)
                {
                    if(_ws != null)
                    {
                        _ws.Close();
                        _ws = null;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CToken.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.framework
{
    /// <summary>
    /// Information about a single voucher.
    /// </summary>
    public struct TokenInfo
    {
        public Guid     _offerId;
        public int      _mediaTypeId;
        public int      _useCount;
        public int      _numTokens;
        public string   _status;
        public byte     _SCG;
        public byte     _consolever;
    }

    /// <summary>
    /// Information about a single usage of a voucher.
    /// </summary>
    public struct TokenUseInfo
    {
        public ulong    _puid;
        public DateTime _whenUsed;
    }

    /// <summary>
    /// This class encapsulates all voucher-related actions against UODB.
    /// </summary>
    public sealed class CToken : IDisposable
    {
        private WSClient _ws;

        //public const ulong CVOUCHER_ALL_OFFERS = 0xFFFFFFFFFFFFFFFF;
        public const string TOKEN_STATUS_ACTIVE = "Active";
        public const string TOKEN_STATUS_DISABLED = "Disabled";

        /// <summary>
        /// constructor
        /// </summary>
        public CToken()
        {
            _ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        }

        /// <summary>
        /// Finalizer.  Cleanup webstore connections.
        /// </summary>
        ~CToken()
        {
            Dispose(false);
        }

        /// <summary>
        /// Adds or updates a token.
        /// </summary>
        /// <param name="hash">Hash of voucher to add.</param>
        /// <param name="offerId">Offer Id this hash is associated to.</param>
        /// <param name="useCount">Maximum number of uses on this token.</param>
        /// <param name="status">0 = Enabled, 1 = Disabled</param>
        /// <param name="SCG">0 = Disabled, 1 = Enabled</param>
        /// <param name="consolever">1 = Xbox, 2 = Xenon</param>
        /// <returns>0 = new token inserted, 1 = existing token updated</returns>
        public uint AddToken(byte [] hash, Guid offerId, int mediaTypeId, int useCount, int status, byte SCG, byte consolever)
        {
            uint hr = 0;
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_add_token";
            _ws.SetHashVal(BitConverter.ToInt64(hash, 0));

            _ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
            _ws.AddParameter("@bin_token_hash", hash);
            _ws.AddParameter("@i_media_type_id", mediaTypeId);
            _ws.AddParameter("@uid_offer_id", offerId);
            _ws.AddParameter("@i_use_count", useCount);
            _ws.AddParameter("@si_hash_bucket", _ws.Partition);
            _ws.AddParameter("@i_token_status_id", status);
            _ws.AddParameter("@f_in_SCG", SCG);
            _ws.AddParameter("@f_consolever", consolever);

            _ws.ExecuteNonQuery();

            hr = (uint)_ws.GetIntParameter("@RETVAL");
            return hr;
        }


        /// <summary>
        /// Adds or updates multiple tokens.
        /// </summary>
        /// <param name="hashList">List of token hashes to add.</param>
        /// <param name="firstIndex">index of first item to flush</param>
        /// <param name="lastIndex">index of last item to flush</param>
        /// <param name="partition">Logical partition for all hashes.</param>
        /// <param name="offerId">Offer Id this hash is associated to.</param>
        /// <param name="mediaTypeId">Media Type Id associated with this offer.</param>
        /// <param name="useCount">Maximum number of uses on this token.</param>
        /// <param name="status">0 = Enabled, 1 = Disabled</param>p
        /// <param name="SCG">0 = Disabled, 1 = Enabled</param>
        /// <param name="consolever">1 = Xbox, 2 = Xenon</param>
        public void AddTokens( ArrayList hashList, int firstIndex, int lastIndex, int partition,
            Guid offerId, int mediaTypeId, int useCount, int status, byte SCG, byte consolever )
        {
            uint hr = 0;
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_add_tokens";
            _ws.Partition = partition;

            _ws.AddParameter( ParamType.RETVAL, "@RETVAL", hr );

            StringBuilder xml = new StringBuilder( 40 * hashList.Count );
            for( int i = firstIndex; i <= lastIndex; ++i ) {
                xml.Append( "<a h=\"" + Convert.ToBase64String( (byte[]) hashList[i] ) + "\"/>" );
            }
            _ws.AddParameter( "@xml_token_hashes", xml.ToString() );
            _ws.AddParameter( "@uid_offer_id", offerId );
            _ws.AddParameter( "@i_media_type_id", mediaTypeId );
            _ws.AddParameter( "@i_use_count", useCount );
            _ws.AddParameter( "@si_hash_bucket", _ws.Partition );
            _ws.AddParameter( "@i_token_status_id", status );
            _ws.AddParameter( "@f_in_SCG", SCG );
            _ws.AddParameter( "@f_consolever", consolever );

            _ws.ExecuteNonQuery();

            hr = (uint) _ws.GetIntParameter( "@RETVAL" );
            }

        /// <summary>
        /// Delete a voucher.  Note that this will only prevent
        /// subsequent use of a voucher, and will not impact
        /// any user's with active subscriptions created using
        /// the voucher being deleted.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="offerId">Specify a specific offer id that the
        /// specified hashes will be disassociated from or null
        /// to disassociate from all offers.</param>
        public void DeleteToken(byte [] hash, string offerId)
        {
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_delete_token";
            _ws.SetHashVal(BitConverter.ToInt64(hash, 0));
            _ws.AddParameter("@bin_token_hash", hash);
            if ( !string.IsNullOrEmpty(offerId) )
            {
                _ws.AddParameter("@uid_offer_id", offerId);
            }
            _ws.ExecuteNonQuery();
        }

        /// <summary>
        /// Return usage summaries for all vouchers, grouped by offer id, use count and status.
        /// </summary>
        public void GetTokensSummary(out ArrayList info)
        {
            info = new ArrayList();

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.StoredProc = "dbo.p_svc_get_token_summary";
                        ws.PhysicalPartition = i;

                        using (WstDataReader rdr = ws.Execute())
                        {
                            while (rdr.Read())
                            {
                                TokenInfo ti = new TokenInfo();

                                ti._offerId = rdr.GetGuid(0);
                                ti._useCount = rdr.GetInt32(1);
                                ti._numTokens = rdr.GetInt32(2);
                                ti._status = rdr.GetString(3);

                                info.Add(ti);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get specific voucher information for the specified voucher.
        /// </summary>
        /// <param name="hash">Token hash</param>
        /// <param name="info">List of voucher infos (more than one if
        /// voucher was associated with multiple offers.</param>
        /// <param name="used">List containing all uses of this voucher.</param>
        public void GetTokenInfo(byte[] hash, out ArrayList info, out ArrayList used)
        {
            uint hr = 0;
            WstDataReader rs = null;
            info = new ArrayList();
            used = new ArrayList();

            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_get_token_info";
            _ws.SetHashVal(BitConverter.ToInt64(hash, 0));

            _ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
            _ws.AddParameter("@bin_token_hash", hash);

            rs = _ws.Execute();

            while (rs.Read())
            {
                TokenInfo ti = new TokenInfo();

                ti._offerId = rs.GetGuid(0);
                ti._useCount = rs.GetInt32(1);
                ti._status = rs.GetString(2);
                ti._SCG = rs.GetByte(3);
                ti._consolever = rs.GetByte(4);
                ti._mediaTypeId = rs.GetInt32(5);
                ti._numTokens = 1;

                info.Add(ti);
            }

            if(rs.NextResult())
            {
                while (rs.Read())
                {
                    TokenUseInfo tui = new TokenUseInfo();

                    tui._puid = (ulong)(rs.GetInt64(0));
                    tui._whenUsed = rs.GetDateTime(1);

                    used.Add(tui);
                }
            }

            rs.Close();
        }

        #region IDisposable Members

        public void Dispose()
        {
            GC.SuppressFinalize(this);
            Dispose(true);
        }

        #endregion

        private void Dispose(bool disposing)
        {
            if(disposing)
            {
                lock(this)
                {
                    if(_ws != null)
                    {
                        _ws.Close();
                        _ws = null;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CStats.cs ===
using System;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Text;
using System.IO;
using System.Threading;
using System.Globalization;

namespace xonline.tools.framework 
{
    /// <summary>
    /// Defines the leaderboard reset intervals supported by the stats v3 "tsunami" stats service
    /// </summary>
    public enum ELBReset
    {
        /// <summary>Minimum legal reset interval value</summary>
        MinValue = 0,
        /// <summary> LB never resets </summary>
        ResetNever = 0,
        /// <summary> LB resets every week</summary>
        ResetEveryWeek= 1,
        /// <summary> LB resets every month</summary>
        ResetEveryMonth = 2,
        /// <summary> LB resets every second months</summary>
        ResetEvery2Months = 3,
        /// <summary> LB resets every third month</summary>
        ResetEvery3Months = 4,
        /// <summary> LB resets every six months</summary>
        ResetEvery6Months = 5,
        /// <summary> LB resets every year</summary>
        ResetEveryYear = 6,
        /// <summary>Maximum legal reset interval value</summary>
        MaxValue = 6
    }

    /// <summary>
    /// A class to hold an ELO max weight rating range
    /// </summary>
    public class CELOMaxWeightRatingRange
    {
        public uint uiStart;
        public uint uiMaxWeight;

        public CELOMaxWeightRatingRange()
        {
            uiStart = 0;
            uiMaxWeight = 0;
        }

        public CELOMaxWeightRatingRange(
            uint _uiStart,
            uint _uiMaxWeight)
        {
            uiStart = _uiStart;
            uiMaxWeight = _uiMaxWeight;
        }

        public override string ToString()
        {
            return "{" + uiStart + "," + uiMaxWeight + "}";
        }

        public string ToStatsDBString()
        {
            return uiStart + ":" + uiMaxWeight;
        }
    }

    /// <summary>
    /// An enum that provides the (two) allowable values for an ELO exponential base
    /// </summary>
    public enum EELOExponentialBase 
    {
        /// <summary> The ELO calculations use base 10</summary>
        ten,
        /// <summary> The ELO calculations use base 'e' </summary>
        e
    }

    /// <summary>
    /// A simple data class that contains a complete ELO configuration
    /// </summary>
    public class  CELOConfig
    {
        public uint uiInitialPlayerRating;
        public uint uiRatingScaleFactor;
        public EELOExponentialBase exponentialBase;
        public CELOMaxWeightRatingRange[] rgMaxWeightRatings;

        public CELOConfig()
        {
            uiInitialPlayerRating = 0;
            uiRatingScaleFactor = 0;
            exponentialBase = EELOExponentialBase.ten;
            rgMaxWeightRatings = new CELOMaxWeightRatingRange[0];
        }

        public CELOConfig(
            uint _uiInitialPlayerRating,
            uint _uiRatingScaleFactor,
            EELOExponentialBase _eExponentialBase,
            CELOMaxWeightRatingRange[] _rgMaxWeightRatings)
        {
            uiInitialPlayerRating = _uiInitialPlayerRating;
            uiRatingScaleFactor = _uiRatingScaleFactor;
            exponentialBase = _eExponentialBase;
            rgMaxWeightRatings = _rgMaxWeightRatings;
        }

        public static CELOConfig Parse(string sELOString)
        {
            // Format of an ELO string:
            // ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10
            // Allowed values for ELO_E are 'E' and '10'

            if (sELOString == null)
            {
                throw new ArgumentNullException(sELOString);
            }

            bool bFoundELO_E = false;
            bool bFoundELO_K = false;
            bool bFoundELO_NEW = false;
            bool bFoundELO_C = false;

            CELOConfig eloConfig = new CELOConfig(0, 0, EELOExponentialBase.e, null);

            string[] rgsSplit = sELOString.Split(';');
            foreach (string sTerm in rgsSplit)
            {
                // sTerm is of the form TERM=value
                string[] sTermSplit = sTerm.Split('=');
                if (sTermSplit.Length != 2)
                {
                    throw new FormatException(
                        "Format error in ELO string, in fragment: "
                        + sTerm);
                }
                string sTag = sTermSplit[0].Trim().ToUpper();
                string sValue = sTermSplit[1].Trim().ToUpper();

                if (sTag == "ELO_E")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_E == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_E tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag must be one of
                    // ELO_E=E
                    // ELO_E=10
                    // anything else is an exception
                    if (sValue == "E")
                    {
                        eloConfig.exponentialBase = EELOExponentialBase.e;
                    }
                    else if (sValue == "10")
                    {
                        eloConfig.exponentialBase = EELOExponentialBase.ten;
                    }
                    else
                    {
                        throw new FormatException(
                            "Unknown exponential base in ELO string, in fragment: "
                            + sTerm);
                    }
                    bFoundELO_E = true;
                }
                else if (sTag == "ELO_K")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_K == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_K tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is simple, just ELO_K=<uint32value>
                    try
                    {
                        eloConfig.uiRatingScaleFactor = UInt32.Parse(sValue);
                    }
                    catch (FormatException formatException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_K term, in fragment: "
                            + sTerm,
                            formatException);
                    }
                    catch (OverflowException overflowException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_K term, in fragment: "
                            + sTerm,
                            overflowException);
                    }
                    bFoundELO_K = true;
                }
                else if (sTag == "ELO_NEW")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_NEW == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_NEW tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is simple, just ELO_NEW=<uint32value>
                    try
                    {
                        eloConfig.uiInitialPlayerRating = UInt32.Parse(sValue);
                    }
                    catch (FormatException formatException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_NEW term, in fragment: "
                            + sTerm,
                            formatException);
                    }
                    catch (OverflowException overflowException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_NEW term, in fragment: "
                            + sTerm,
                            overflowException);
                    }
                    bFoundELO_NEW = true;
                }
                else if (sTag == "ELO_C")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_C == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_C tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is a bit of a pain. It contains one or more ranges
                    // of the form 10:40, separated by commas. For example:
                    // ELO_C=0:40,1000:20,1500:10
                    // So we have to split and iterate on the value here
                    string[] rgsValueSplit = sValue.Split(',');
                    if (rgsValueSplit.Length == 0)
                    {
                        throw new FormatException(
                            "No rating ranges found parsing ELO_C term, in fragment: "
                            + sTerm);
                    }

                    // allocate an array with space for the number of ranges in
                    // the string
                    CELOMaxWeightRatingRange[] rgMaxWeightRatings 
                        = new CELOMaxWeightRatingRange[rgsValueSplit.Length];

                    // now grab each range
                    for (int i = 0; i < rgsValueSplit.Length; ++i)
                    {
                        string sRange = rgsValueSplit[i];

                        // range is of the form 0:40, so we have split, again
                        string[] rgsRangeSplit = sRange.Split(':');
                        if (rgsRangeSplit.Length != 2)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sTerm);
                        }

                        string sStart = rgsRangeSplit[0];
                        string sMaxWeight = rgsRangeSplit[1];

                        // we have the values, now parse them!
                        rgMaxWeightRatings[i] = new CELOMaxWeightRatingRange();
                        try
                        {
                            rgMaxWeightRatings[i].uiStart = UInt32.Parse(sStart);
                        }
                        catch (FormatException formatException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                formatException);
                        }
                        catch (OverflowException overflowException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                overflowException);
                        }

                        // got the start, now get the max weight
                        try
                        {
                            rgMaxWeightRatings[i].uiMaxWeight = UInt32.Parse(sMaxWeight);
                        }
                        catch (FormatException formatException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                formatException);
                        }
                        catch (OverflowException overflowException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                overflowException);
                        }
                    }

                    // if we got here without throwing, then we've successfully 
                    // parsed the max weight rating ranges, save them
                    eloConfig.rgMaxWeightRatings = rgMaxWeightRatings;
                    bFoundELO_C = true;
                }
                else
                {
                    throw new FormatException(
                        "Unknown tag in ELO string, in fragment: "
                        + sTerm);
                }
            }

            // check to make sure that we found everything we were looking for
            if (bFoundELO_E == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_K == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_NEW == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_C == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }

            // we're done! no errors, so return the parse object
            return eloConfig;
        }

        // the Parse method does not check the semantics of
        // the max weight range array, they just verify that the strings
        // are formatted properly in terms of parsing.
        //
        // this method checks if the max weight rating range array is
        // valid
        //
        // to be valid, the first element of the max weight rating range array 
        // must have uiStart = 0, and each successive max weight rating range
        // must have uiStart larger than all previous values.
        public bool IsValid()
        {
            // must have an array, and it must have more than zero elements
            if (rgMaxWeightRatings == null || rgMaxWeightRatings.Length == 0)
            {
                return false;
            }

            // uiStart of the first element must be zero
            if (rgMaxWeightRatings[0].uiStart != 0)
            {
                return false;
            }

            // uiStart of all successive elements must be larger than the previous
            uint uiStartLast = 0;
            for (int i = 1; i < rgMaxWeightRatings.Length; ++i)
            {
                if (rgMaxWeightRatings[i].uiStart <= uiStartLast)
                {
                    return false;
                }
                uiStartLast = rgMaxWeightRatings[i].uiStart;
            }

            // if we get here, all validity tests passed, so return true!
            return true;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            sb.Append(uiInitialPlayerRating.ToString());
            sb.Append(",");
            sb.Append(uiRatingScaleFactor.ToString());
            sb.Append(",");
            sb.Append(exponentialBase.ToString());
            sb.Append(",");
            sb.Append(CLog.CollectionToString(rgMaxWeightRatings));
            sb.Append("}");
            return sb.ToString();
        }

        public string ToStatsDBString()
        {
            // Format of an ELO string:
            // ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10
            // Allowed values for ELO_E are 'E' and '10'

            // build a valid ELO string from the object
            StringBuilder sb = new StringBuilder();

            // canonical ordering is ELO_E, ELO_K, ELO_NEW, ELO_C

            // ELO_E=[E|10]
            if (exponentialBase == EELOExponentialBase.e)
            {
                sb.Append("ELO_E=E");
            }
            else if (exponentialBase == EELOExponentialBase.ten)
            {
                sb.Append("ELO_E=10");
            }
            else
            {
                // this will only happen if we add a new exponential base
                // without updating this function
                throw new Exception(
                    "CELOConfig.ToStatsDBString internal error - this method requires updating");
            }
            sb.Append(";");

            // ELO_K=XXX
            sb.Append("ELO_K=");
            sb.Append(uiRatingScaleFactor.ToString());
            sb.Append(";");

            // ELO_NEW=XXX
            sb.Append("ELO_NEW=");
            sb.Append(uiInitialPlayerRating.ToString());
            sb.Append(";");

            // ELO_C=XX:XX,XX:XX,XX:XX
            if (rgMaxWeightRatings == null || rgMaxWeightRatings.Length < 1)
            {
                throw new Exception(
                    "Invalid rgMaxWeightRatings in CELOConfig.ToStatsDBString()");
            }

            sb.Append("ELO_C=");
            for (int i = 0; i < rgMaxWeightRatings.Length; ++i)
            {
                sb.Append(rgMaxWeightRatings[i].uiStart.ToString());
                sb.Append(":");
                sb.Append(rgMaxWeightRatings[i].uiMaxWeight.ToString());
                if (i + 1 < rgMaxWeightRatings.Length)
                {
                    sb.Append(",");
                }
            }

            // all done, no errors, return the string!
            return sb.ToString();
        }
    }

    /// <summary>
    /// This class encapsulates the management operations that can be performed 
    /// on the version 3 ("tsunami") statistics service. The "statistics service", in this
    /// context means the statistics database servers, and the statistics front door
    /// servers. It does not include webdb, which has it's own management object
    /// </summary>
    public class CStats
    {
        private string[] m_rgsStatsDBConnectionStrings = null;
        private CServer[] m_rgStatsFDServers = null;
        private CLog m_log = null;

        // an array of sqlconnection objects that corresponds to the 
        // sql connection strings above
        private SqlConnection[] m_rgSqlConnections = null;

        // how many competition template partitions are there?
        private const int c_iNumCompPartitions = 4;

        // competition leaderboards encode the template id in the
        // 3rd to 6th highest bits. The template id cannot be zero
        // therefore if any of these four bits are set, the leaderboard
        // is a competition leaderboard
        private const int c_uiCompMask = 0x3C000000;

        public CStats(
            string[] rgsStatsDBConnectionStrings,
            CServer[] rgStatsFDServers,
            CLog log)
        {
            if (log == null)
            {
                // if they didn't give us a logging object, then create one that
                // does nothing
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }
            
            // make sure all non-log parameters are non-null. The last two can be empty arrays,
            // but they can't be null.
            if (rgsStatsDBConnectionStrings == null)
            {
                throw new ArgumentNullException("rgsStatsDBConnectionStrings");
            }

            if (rgStatsFDServers == null)
            {
                throw new ArgumentNullException("rgStatsFDServers");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.ctor(" +
                "{rgsStatsDBConnectionStrings}, " +
                "{rgStatsFDServers})");
            m_log.StackTrace("{rgsStatsDBConnectionStrings}="
                + CLog.CollectionToString(rgsStatsDBConnectionStrings));
            m_log.StackTrace("{rgStatsFDServers}="
                + CLog.CollectionToString(rgStatsFDServers));

            m_rgsStatsDBConnectionStrings = rgsStatsDBConnectionStrings;
            m_rgStatsFDServers = rgStatsFDServers;

            m_rgSqlConnections = new SqlConnection[NumStatsDatabases];

            // loop through every connection string we were provided and
            // create a sql connection. Note, I've decided not to track
            // the opened state of these connections. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            int i = 0;
            try
            {
                for (i = 0; i < NumStatsDatabases; ++i)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.ctor: "
                        + "Opening connection to stats database using connection string '"
                        + m_rgsStatsDBConnectionStrings[i]
                        + "'");
                    m_rgSqlConnections[i] = new SqlConnection(m_rgsStatsDBConnectionStrings[i]);
                    m_rgSqlConnections[i].Open();
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.ctor: "
                    + "Opening a connection to "
                    + m_rgsStatsDBConnectionStrings[i]
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "Xbox.Tools.Framework.CStats.ctor: "
                    + "Opening a connection to "
                    + m_rgsStatsDBConnectionStrings[i]
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, ArgumentException);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.ctor complete");
        }

        // a couple properties as shorthand for "how many servers do I have?"
        public int NumStatsDatabases
        {
            get
            {
                return m_rgsStatsDBConnectionStrings.Length;
            }
        }
        public int NumFrontDoors
        {
            get
            {
                return m_rgStatsFDServers.Length;
            }
        }

        public void Close()
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.Close()");

            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                try
                {
                    if (m_rgSqlConnections[i] != null && m_rgSqlConnections[i].State != ConnectionState.Closed)
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CStats.Close: "
                            + "Closing sql connection "
                            + m_rgSqlConnections[i].ConnectionString);
                        m_rgSqlConnections[i].Close();
                    }
                }
                catch (Exception e)
                {
                    // we want to attempt to close every connection, even if
                    // closing one of them threw an exception, so squash this
                    // but note it in the log
                    m_log.LogFile("Xbox.Tools.Framework.CStats.Close: "
                        + "Exception closing sql connection "
                        + m_rgSqlConnections[i].ConnectionString
                        + " Exception details: "
                        + e.Message);
                }
            }
            
            m_log.StackTrace("Xbox.Tools.Framework.CStats.Close complete");
        }

        // I had this little code block repeated all over the place in this
        // file, so I finally decided to put it in this little helper function
        // It's not always useful, because sometimes I want to check the return
        // code for specific values, but I found that most of the time
        // I just threw the same message if it was non-zero
        private void ExecuteNonQuery(
            SqlCommand sqlCommand,
            string sContext)
        {
            try
            {
                sqlCommand.ExecuteNonQuery();
                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = sContext
                        + ": The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = sContext
                    + ": The stored procedure "
                    + sqlCommand.CommandText 
                    + " caused a SqlException. Details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
        }

        public SortedList TitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap()");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if title config 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for title configs
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                            + "Found title config for "
                            + uiTitleId
                            + " on server "
                            + i);

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found a title config on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap complete");
            return sortedList;
        }

        public void TitleDelete(
            CTitleId tid,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleDelete(" +
                tid.ToString()+ ", "+
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            // loop through all the stats databases and nuke it
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                TitleDelete(tid, i, iSqlTimeoutSeconds, bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleDelete complete");
        }


        public void TitleDelete(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleDelete(" +
                tid.ToString()+ ", "+
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleDelete complete");
        }

        public void TitleConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiMaxWrites,
            uint uiMaxReads,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                uiMaxWrites+ ", " +
                uiMaxReads+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            m_log.LogFile(
                "Xbox.Tools.Framework.CStats.TitleConfigSet: " +
                "Adding or Updating title information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_ConfigureTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_maxWrites", SqlDbType.Int).Value = (int)uiMaxWrites;
            sqlCommand.Parameters.Add("@i_maxReads", SqlDbType.Int).Value = (int)uiMaxReads;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleConfigSet");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigSet complete");
        }

        public void TitleConfigSet(
            CTitleId tid,
            uint uiMaxWrites,
            uint uiMaxReads,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigSet(" +
                tid.ToString()+ ", " +
                uiMaxWrites+ ", " +
                uiMaxReads+ ", " +
                bReportOnly+ ")");

            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CStats.TitleConfigSet: "
                    + "Calling TitleConfigSet for database "
                    + i);
                TitleConfigSet(tid, i, uiMaxWrites, uiMaxReads, bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigSet complete");
        }

        public bool TitleConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            out uint uiMaxWrites,
            out uint uiMaxReads)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            uiMaxWrites = 0;
            uiMaxReads = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_GetTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                        + "found config for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId               int         not null,
                    // i_maxWrites             int         not null,
                    // i_maxReads              int         not null

                    uiMaxWrites = (uint)(int)sqlDataReader["i_maxWrites"];
                    uiMaxReads = (uint)(int)sqlDataReader["i_maxReads"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the title configuration
                    // note that not finding the configuration should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public void TitleConfigDelete(
            CTitleId tid,
            int iStatsDatabase,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete: " +
                "Removing title configuration information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleConfigDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigDelete complete");
        }

        public SortedList LBGetDatabaseMap(
            CTitleId tid,
            bool bIgnoreCompLBs)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap(" +
                tid.ToString()+ ","+
                bIgnoreCompLBs+")");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // I've gone with this slightly contorted construct to enable me to 
            // support the fact that it's possible for a leaderboard to be
            // defined on multiple servers. While that's not allowed, it is possible
            // and since this is the management object, it can't throw a fit 
            // if it happens, otherwise we may not be able to easily detect and 
            // delete the offending leaderboard!
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for leaderboards
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryLeaderBoards";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiLBNum = (uint)(int)sqlDataReader["i_leader_board_type"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                            + "Found leaderboard "
                            + uiLBNum
                            + " on server "
                            + i);

                        if ((uiLBNum & c_uiCompMask) != 0 && bIgnoreCompLBs)
                        {
                            // this is a competition leaderboard, and the caller doesn't
                            // want to know about it, so continue with the next
                            m_log.FullTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                                + "Ignoring competition leaderboard "
                                + uiLBNum
                                + " on server "
                                + i);
                            continue;
                        }

                        if (sortedList[uiLBNum] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiLBNum] = rgbMap;
                        }

                        // we found leaderboard uiLBNum on server i, so set the flag
                        ((bool[])sortedList[uiLBNum])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap complete");
            return sortedList;
        }

        public void LBConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            uint uiMaxRatingCount,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                riLBResetInterval + ", " +
                uiAttachmentCount+ ", " +
                uiMaxAttachmentSize+ ", " +
                uiDecayDays+ ", " +
                uiMaxRatingCount+ ", " +
                bArbitrationRequired+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: LBs that "
                    + "require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // double check to make sure the caller isn't attempting to create
            // this leaderboard when it already exists on a different database
            SortedList sortedListDBMap = LBGetDatabaseMap(tid, false);
            if (sortedListDBMap[uiLBNum] != null)
            {
                // the leaderboard exists, but is it on the wrong server?
                bool[] rgbServerMap = (bool[])sortedListDBMap[uiLBNum];

                for (int i = 0; i < NumStatsDatabases; ++i)
                {
                    if (rgbServerMap[i] == true && i != iStatsDatabase)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                            + "Cannot create leaderboard "
                            + uiLBNum
                            + " on server "
                            + iStatsDatabase
                            + " because it already exists on server "
                            + i;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
            }

            // we rely on the stored proc to return non-zero in the case where the
            // leaderboard already exists on the server, but cannot be updated
            // because the caller tried to change the team status or the top 100 
            // status

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_CreateNewLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (byte)riLBResetInterval;
            sqlCommand.Parameters.Add("@i_att_count", SqlDbType.Int).Value = (int)uiAttachmentCount;
            sqlCommand.Parameters.Add("@i_max_att_size", SqlDbType.Int).Value = (int)uiMaxAttachmentSize;
            sqlCommand.Parameters.Add("@i_decay_days", SqlDbType.Int).Value = (int)uiDecayDays;
            sqlCommand.Parameters.Add("@i_max_rating_count", SqlDbType.Int).Value = (int)uiMaxRatingCount;
            sqlCommand.Parameters.Add("@ti_top_hundred", SqlDbType.TinyInt).Value = (byte)(uiMaxRatingCount == 0 ? 0 : 1);
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null ? "" : eloConfig.ToStatsDBString()); 
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);   
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == -1)
                        {
                            // this is the error code returned when we try to change i_max_rating_count
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change max rating count "
                                + "of an existing leaderboard.";
                        }
                        else if (iRet == -2)
                        {
                            // this is the error code returned when we try to change ti_IsTeam
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change team status "
                                + "of an existing leaderboard.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBConfigSet complete");
        }

        public bool LBConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            out ELBReset leaderboardResetInterval,
            out uint uiAttachmentCount,
            out uint uiMaxAttachmentSize,
            out uint uiDecayDays,
            out uint uiMaxRatingCount,
            out bool bRequireArbitration,
            out bool bIsTeam,
            out CELOConfig eloConfig,
            out Guid guid,
            out long lMinQualifyingRating,
            out DateTime dateTimeCreated,
            out byte bReadOnly,
            out byte bCopying,
            out byte bDelete)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            leaderboardResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bRequireArbitration = false;
            bIsTeam = false;
            eloConfig = null;
            guid = Guid.NewGuid();
            lMinQualifyingRating = 0;
            dateTimeCreated = DateTime.UtcNow;
            bReadOnly = 0;
            bCopying = 0;
            bDelete = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_GetLeaderboardConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();
                
                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.LBConfigGet: "
                        + "found leaderboard "
                        + uiLBNum);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results int the out parameters

                    // from the table definition:
                    // ti_reset_type           tinyint      not null,
                    // dt_created              datetime     not null,
                    // i_att_count             int          not null,
                    // i_max_att_size          int          not null,
                    // i_decay_days            int          not null,
                    // i_max_rating_count      int          not null,
                    // bi_min_qualif_rating    bigint,
                    // vc_params               varchar(256) not null,
                    // ti_IsTeam               tinyint      not null,
                    // ti_ReqArbitration       tinyint      not null,
                    // f_readonly              tinyint      not null default(0),
                    // f_copying               tinyint      not null default(0),
                    // f_delete                tinyint      not null default(0)

                    leaderboardResetInterval = (ELBReset)(byte)sqlDataReader["ti_reset_type"];
                    uiAttachmentCount = (uint)(int)sqlDataReader["i_att_count"];
                    uiMaxAttachmentSize = (uint)(int)sqlDataReader["i_max_att_size"];
                    uiDecayDays = (uint)(int)sqlDataReader["i_decay_days"];
                    uiMaxRatingCount = (uint)(int)sqlDataReader["i_max_rating_count"];
                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeam = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                                + "Could not parse ELO string for leaderboard " 
                                + uiLBNum
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (!eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                                + "ELO string for leaderboard " 
                                + uiLBNum
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                            // note - don't throw, just note the error
                        }
                    }
                    guid = (Guid)sqlDataReader["uid_leader_board_id"];
                    lMinQualifyingRating = (long)(Int64)sqlDataReader["bi_min_qualif_rating"];
                    dateTimeCreated = (DateTime)sqlDataReader["dt_created"];
                    bReadOnly = ((byte)sqlDataReader["f_readonly"]);
                    bCopying = ((byte)sqlDataReader["f_copying"]);
                    bDelete = ((byte)sqlDataReader["f_delete"]);
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the leaderboard definition
                    // note that not finding the leaderboard should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBConfigGet complete, returning: " + bFound);
            return bFound;
        }

        public void LBDelete(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBDelete complete");
        }

        public void LBReset(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBReset(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_ResetLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBReset: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == 1)
                        {
                            // this is the error code returned when we try to reset a leaderboard
                            // that doesn't exist
                            sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                                + "Unable to reset leaderboard "
                                + uiLBNum
                                + ". This probably means it does not exist";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBReset complete");
        }

        // The TimeSpan class does not appear to allow me to specify the
        // format on it's ToString calls, and the DateTimeFormatInfo
        // does not seem to affect it, so I'm formatting timespans
        // manually...
        private static string TimeSpanFormat(TimeSpan timeSpan)
        {
            return timeSpan.Hours.ToString("D2")
                +":"
                +timeSpan.Minutes.ToString("D2")
                +":"
                +timeSpan.Seconds.ToString("D2");
        }

        public void LBMove(
            CTitleId tid,
            uint uiLBNum, 
            int iSourceStatsDatabase,
            int iDestStatsDatabase,
            bool bReset,
            int iFrontDoorTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMove(" +
                tid.ToString()+ ", " +
                uiLBNum + ", " +
                iSourceStatsDatabase + ", " +
                iDestStatsDatabase + ", " +
                bReset + ", " +
                iFrontDoorTimeoutMilliseconds + ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds+ ", " +
                bReportOnly+ ")");

            // how to move a leaderboard from one server to another
            //
            // step 1) call p_Stats_MoveLbInit on both the source and destination servers
            // this sets up the users required to perform the data copy, locks the 
            // leaderboard for updates, and whatever else is required to prepare for
            // the copy
            //
            // step 2) call p_Stats_MoveLbCopy on the source database. You pass it the
            // name of the destination database, and it copies the data over
            //
            // step 3) send the a request to /xstats/xstatsreloaddbmap.ashx to each
            // front door, so they know to start going to the destination database
            // for their data
            //
            // step 4) call p_Stats_MoveLbFinalize on both the source and destination
            // servers. This cleans everything up. This should be called even if
            // p_Stats_MoveLbCopy fails, because the leaderboard needs to get unlocked
            // and the users that were created need to be destroyed.
            //
            // piece of cake!

            // first do our validation homework
            if (iSourceStatsDatabase < 0 || iSourceStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "iSourceStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iSourceStatsDatabase", sErr);
            }
            if (iDestStatsDatabase < 0 || iDestStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + " iDestStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iDestStatsDatabase", sErr);
            }
            if (iDestStatsDatabase == iSourceStatsDatabase)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: " +
                    "iDestStatsDatabase cannot be the same as iSourceStatsDatabase";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iDestStatsDatabase", sErr);
            }

            // if we don't know about any front doors, we can't do this safely so bail
            if (m_rgStatsFDServers == null || NumFrontDoors == 0)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: " +
                    "No stats front door addresses provided to constructor, cannot move leaderboard safely";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // see if the leaderboard is currently defined anywhere
            SortedList sortedListDBMap = LBGetDatabaseMap(tid, false);
            bool[] rgbDatabaseMap = (bool[])sortedListDBMap[uiLBNum];
            if (rgbDatabaseMap == null)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " because it does not exist on any server";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // if it is not defined in the source database, we can't move it
            if (rgbDatabaseMap[iSourceStatsDatabase] == false)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " from server "
                    + iSourceStatsDatabase
                    + " because it does not exist on that server";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // if it is defined on anywhere else but the destination 
            // server, bail - they should clean that up first
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                if (rgbDatabaseMap[i] == true
                    && i != iSourceStatsDatabase
                    && i != iDestStatsDatabase)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                        + "Cannot move leaderboard "
                        + uiLBNum
                        + " from server "
                        + iSourceStatsDatabase
                        + " to server "
                        + iDestStatsDatabase
                        + " because it also defined on server "
                        + i;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }

            // finally, if it is defined in the destination database
            // we should only continue if bReset has been specified
            if (rgbDatabaseMap[iDestStatsDatabase] == true && bReset == false)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " from server "
                    + iSourceStatsDatabase
                    + " to server "
                    + iDestStatsDatabase
                    + " because it is already defined the destination server.";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // note the current time
            DateTime dtMoveStart = DateTime.Now;

            // if we're planning to provide progress reports, we'll need
            // SqlConnections to check row counts while the main
            // connection is busy moving leaderboards
            SqlConnection sqlConnectionSrcProgress = null;
            SqlConnection sqlConnectionDstProgress = null;
            if (iProgressReportIntervalMilliseconds > 0)
            {
                sqlConnectionSrcProgress = new SqlConnection(m_rgSqlConnections[iSourceStatsDatabase].ConnectionString);
                sqlConnectionDstProgress = new SqlConnection(m_rgSqlConnections[iDestStatsDatabase].ConnectionString);

                sqlConnectionSrcProgress.Open();
                sqlConnectionDstProgress.Open();
            }

            // if we made it here, then we're good to try and move it.
            try
            {
                // step 1, call p_Stats_MoveLbInit on source and dest

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Preparing src db (i) to move lb XX
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Preparing src db ("
                    +iSourceStatsDatabase
                    +") to move lb "
                    +uiLBNum);

                CallMoveLbInit(
                    m_rgSqlConnections[iSourceStatsDatabase], 
                    bReset, 
                    iSqlTimeoutSeconds, 
                    sqlConnectionSrcProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Move init on src db (i) complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Move init on src db ("
                    +iSourceStatsDatabase
                    +") complete");

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Preparing dst db (i) to move lb XX
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Preparing dst db ("
                    +iSourceStatsDatabase
                    +") to move lb "
                    +uiLBNum);

                CallMoveLbInit(
                    m_rgSqlConnections[iDestStatsDatabase], 
                    bReset, 
                    iSqlTimeoutSeconds, 
                    sqlConnectionDstProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Move init on dst db (i) complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Move init on dst db ("
                    +iSourceStatsDatabase
                    +") complete");

                // step 2, call p_Stats_MoveLbCopy

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Copying rows for lb XX from src to dst database
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; copying rows for lb "
                    +uiLBNum
                    +" from src to dst database");

                CallMoveLbCopy(
                    tid,
                    m_rgSqlConnections[iSourceStatsDatabase], 
                    m_rgSqlConnections[iDestStatsDatabase], 
                    uiLBNum,
                    iSqlTimeoutSeconds, 
                    sqlConnectionDstProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Row copy from src to dst complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; row copy from src to dst complete");

                // step 3, reload stats front doors

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Refreshing stats front doors
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Refreshing stats front doors");

                FrontDoorReloadAll(iFrontDoorTimeoutMilliseconds,bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Leaderboard XX is now live on dst database
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Leaderboard "
                    +uiLBNum
                    +" is now live on dst database");
            }
            finally
            {
                // step 4, call p_Stats_MoveLbFinalize
                // this should be called no matter what happened above - success, error
                // one step or many. It is supposed to either complete the move process
                // or clean up from an error.

                // Note - some errors above may have closed the connection. If that's the
                // case then we want to try to reopen it
                try
                {
                    if (m_rgSqlConnections[iDestStatsDatabase].State != ConnectionState.Open)
                    {
                        m_rgSqlConnections[iDestStatsDatabase].Open();
                    }

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Finalizing dst database
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Finalizing dst database");

                    // if a non-zero timeout has been specified, we want to give the finalize
                    // call an unusual amount of time to try and clean up. Therefore we 
                    // triple the normal timeout value for these finalize calls.
                    CallMoveLbFinalize(
                        m_rgSqlConnections[iDestStatsDatabase],
                        iSqlTimeoutSeconds*3,
                        sqlConnectionDstProgress,
                        dtMoveStart,
                        iProgressReportIntervalMilliseconds,
                        bReportOnly);

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Dst database finalized
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Dst database finalized");
                }
                finally
                {
                    if (m_rgSqlConnections[iSourceStatsDatabase].State != ConnectionState.Open)
                    {
                        m_rgSqlConnections[iSourceStatsDatabase].Open();
                    }

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Finalizing src database
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Finalizing src database");

                    CallMoveLbFinalize(
                        m_rgSqlConnections[iSourceStatsDatabase], 
                        iSqlTimeoutSeconds*3, 
                        sqlConnectionSrcProgress,
                        dtMoveStart,
                        iProgressReportIntervalMilliseconds,
                        bReportOnly);

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Src database finalized
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Src database finalized");
                }
            }

            // 0        1        2        3        4        5        6        7        8
            // LBSync:HH:MM:SS; lb XX sucessfully moved from db XX to db XX
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; lb "
                +uiLBNum
                +" sucessfully moved from db "
                +iSourceStatsDatabase
                +" to db "
                +iDestStatsDatabase);
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMove complete");
        }

        public void LBMoveFinalize(
            CTitleId tid,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMoveFinalize(" +
                tid.ToString()+ ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds + ", " +
                bReportOnly+ ")");

            // iterate through each known stats database and call
            // LBMoveFinalize for it
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                LBMoveFinalize(
                    tid,
                    i,
                    iSqlTimeoutSeconds,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMoveFinalize complete");
        }

        public void LBMoveFinalize(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMoveFinalize(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds + ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // if we're planning to provide progress reports, we'll need
            // a SqlConnection to check row counts while the main
            // connection is busy moving leaderboards
            SqlConnection sqlConnectionProgress = null;
            if (iProgressReportIntervalMilliseconds > 0)
            {
                sqlConnectionProgress = new SqlConnection(m_rgSqlConnections[iStatsDatabase].ConnectionString);
                sqlConnectionProgress.Open();
            }

            // note the current time
            DateTime dtMoveStart = DateTime.Now;

            // LBSync:HH:MM:SS; Finalizing database XX
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; Finalizing database "
                +iStatsDatabase);

            CallMoveLbFinalize(
                m_rgSqlConnections[iStatsDatabase], 
                iSqlTimeoutSeconds,
                sqlConnectionProgress,
                dtMoveStart,
                iProgressReportIntervalMilliseconds,
                bReportOnly);

            // LBSync:HH:MM:SS; Database XX finalized
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; Database "
                +iStatsDatabase
                +" finalized");

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMoveFinalize complete");
        }

        private void CallMoveLbInit(
            SqlConnection sqlConnection, 
            bool bReset, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                timer = MoveLbInitProgressStart(
                    dtMoveStart,
                    sqlConnectionProgress,
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbInit";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@f_reset", SqlDbType.TinyInt).Value = (bReset ? 0 : 1);
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnection.ConnectionString);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbInitProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        private void CallMoveLbCopy(
            CTitleId tid,
            SqlConnection sqlConnectionSource, 
            SqlConnection sqlConnectionDest,
            uint uiLBNum, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                // get a count of then number of rows in the source
                // database
                LbState lbSrc = new LbState();
                lbSrc.tid = tid;
                lbSrc.uiLeaderboardId = uiLBNum;
                MoveLbGetLbState(
                    sqlConnectionSource, 
                    ref lbSrc);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; xxxxxxxxx rows to copy for xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; "
                    +lbSrc.iTotalRows
                    +" rows to copy for "
                    +uiLBNum
                    +"("
                    +tid.sTitleIdHexNoPrefix
                    +")");

                m_log.FullTrace("Xbox.Tools.Framework.CStats.CallMoveLbCopy: "
                    +"Source leaderboard "
                    +lbSrc.uiLeaderboardId
                    +"; titleid "
                    +lbSrc.tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +lbSrc.bCopying
                    +"; f_delete: "
                    +lbSrc.bDelete
                    +"; i_rating:"
                    +lbSrc.iRating
                    +"; i_attrib:"
                    +lbSrc.iAttrib
                    +"; i_nickname:"
                    +lbSrc.iNickname
                    +"; i_bucket:"
                    +lbSrc.iBucket
                    +"; i_bucket_count:"
                    +lbSrc.iBucketCount);

                timer = MoveLbCopyProgressStart(
                    dtMoveStart,
                    lbSrc,
                    sqlConnectionProgress,
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnectionSource.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbCopy";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@vc_destServer", SqlDbType.VarChar).Value = sqlConnectionDest.DataSource;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("@i_lbId", SqlDbType.Int).Value = uiLBNum;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnectionSource.DataSource);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbCopyProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        private void CallMoveLbFinalize(
            SqlConnection sqlConnection, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                // p_Stats_MoveLbFinalize calls p_Stats_MoveLbInit to
                // do the work of cleaning up leaderboards, therefore
                // the same progress reporting is a appropriate.
                timer = MoveLbInitProgressStart(
                    dtMoveStart,
                    sqlConnectionProgress, 
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbFinalize";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnection.ConnectionString);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbInitProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        // private struct here to hold results from 
        // p_Stats_QueryLeaderboardsInMoveState
        private struct LbState
        {
            public CTitleId tid;
            public uint uiLeaderboardId;
            public bool bCopying;
            public bool bReadOnly;
            public bool bDelete;
            public int iTotalRows;
            public int iRating;
            public int iAttrib;
            public int iNickname;
            public int iBucket;
            public int iBucketCount;
        }

        private struct TimerState
        {
            public SqlConnection sqlConnection;
            public DateTime dtMoveStart;
            public ArrayList alLBStates;
        }

        private Timer MoveLbInitProgressStart(
            DateTime dtMoveStart,
            SqlConnection sqlConnectionProgress,
            int iProgressReportIntervalMilliseconds)
        {
            // The init proc deletes all leaderboards on the server
            // with f_copying or f_deleted flags set. So get all those
            // leaderboards, and report how many rows they have.

            SqlCommand sqlCommand = sqlConnectionProgress.CreateCommand();
            sqlCommand.CommandText = "p_Stats_QueryLeaderboardsInMoveState";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            ArrayList al = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();

                while (sqlDataReader.Read())
                {
                    LbState lb = new LbState();
                    lb.tid = new CTitleId((uint)(int)sqlDataReader["i_title_id"]);
                    lb.uiLeaderboardId = (uint)(int)sqlDataReader["i_leader_board_type"];
                    lb.bReadOnly = (((byte)sqlDataReader["f_readonly"]) != 0) ? true : false;
                    lb.bCopying = (((byte)sqlDataReader["f_copying"]) != 0) ? true : false;
                    lb.bDelete = (((byte)sqlDataReader["f_delete"]) != 0) ? true : false;

                    // only leaderboards in the copying or delete states will
                    // be cleaned up by init
                    if (lb.bCopying || lb.bDelete)
                    {
                        al.Add(lb);
                    }
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                        + "The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // if we get here, we now have a list of leaderboards
            // in al that will be deleted by the init proc.
            for (int i = 0; i < al.Count; ++i)
            {
                // populate the LbState struct with current info
                LbState lb = (LbState)al[i];
                MoveLbGetLbState(sqlConnectionProgress, ref lb);
                al[i] = lb;

                //   0        1        2        3        4        5        6        7        8
                //   LBSync:HH:MM:SS; xxxxxxxx rows to delete from xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; "
                    +((LbState)al[i]).iTotalRows
                    +" rows to delete from "
                    +((LbState)al[i]).uiLeaderboardId
                    +"("
                    +((LbState)al[i]).tid.sTitleIdHexNoPrefix
                    +")");
                m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    +"Cleaning leaderboard "
                    +((LbState)al[i]).uiLeaderboardId
                    +"; titleid "
                    +((LbState)al[i]).tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +((LbState)al[i]).bCopying
                    +"; f_delete: "
                    +((LbState)al[i]).bDelete
                    +"; i_rating:"
                    +((LbState)al[i]).iRating
                    +"; i_attrib:"
                    +((LbState)al[i]).iAttrib
                    +"; i_nickname:"
                    +((LbState)al[i]).iNickname
                    +"; i_bucket:"
                    +((LbState)al[i]).iBucket
                    +"; i_bucket_count:"
                    +((LbState)al[i]).iBucketCount);
            }

            // now we need to setup the periodic progress reports

            // this is the state object that gets passed to the
            // timer delegate
            TimerState timerState = new TimerState();
            timerState.sqlConnection = sqlConnectionProgress;
            timerState.dtMoveStart = dtMoveStart;
            timerState.alLBStates = al;

            Timer timer = new Timer(
                new TimerCallback(MoveLbInitProgressDelegate), 
                timerState, 
                iProgressReportIntervalMilliseconds,
                iProgressReportIntervalMilliseconds);

            return timer;
        }

        public void MoveLbInitProgressDelegate(object oState)
        {
            TimerState timerState = (TimerState)oState;

            foreach (LbState lbStart in timerState.alLBStates)
            {
                LbState lbCur = lbStart;
                MoveLbGetLbState(timerState.sqlConnection, ref lbCur);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; xxxxxxxxx of xxxxxxxxx rows remain in xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(timerState.dtMoveStart))
                    +"; "
                    +lbCur.iTotalRows
                    +" of "
                    +lbStart.iTotalRows
                    + " rows remain in "
                    +lbCur.uiLeaderboardId
                    +"("
                    +lbCur.tid.sTitleIdHexNoPrefix
                    +")");
                m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbInitProgressDelegate: "
                    +"lb:"
                    +lbCur.uiLeaderboardId
                    +"; titleid:"
                    +lbCur.tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +lbCur.bCopying
                    +"; f_delete: "
                    +lbCur.bDelete
                    +"; i_rating:"
                    +lbCur.iRating
                    +"; i_attrib:"
                    +lbCur.iAttrib
                    +"; i_nickname:"
                    +lbCur.iNickname
                    +"; i_bucket:"
                    +lbCur.iBucket
                    +"; i_bucket_count:"
                    +lbCur.iBucketCount);
            }
        }

        private void MoveLbInitProgressEnd(
            Timer timer, 
            int iProgressReportIntervalMilliseconds)
        {
            WaitHandle waitHandle = new AutoResetEvent(false);
            if (!timer.Dispose(waitHandle))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error shutting down move init progress report timer object";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // wait up to twice the progress interval for the 
            // timer to shutdown
            if (!waitHandle.WaitOne(iProgressReportIntervalMilliseconds*2, true))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error waiting for move init progress report timer object to shut down";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }
        }

        private Timer MoveLbCopyProgressStart(
            DateTime dtMoveStart,
            LbState lbSrc,
            SqlConnection sqlConnectionProgress,
            int iProgressReportIntervalMilliseconds)
        {
            // setup the periodic progress reports

            // this is the state object that gets passed to the
            // timer delegate
            TimerState timerState = new TimerState();
            timerState.sqlConnection = sqlConnectionProgress;
            timerState.dtMoveStart = dtMoveStart;

            // just one leaderboard to monitor for copy
            ArrayList al = new ArrayList();
            al.Add(lbSrc);
            timerState.alLBStates = al;

            Timer timer = new Timer(
                new TimerCallback(MoveLbCopyProgressDelegate), 
                timerState, 
                iProgressReportIntervalMilliseconds,
                iProgressReportIntervalMilliseconds);

            return timer;
        }

        public void MoveLbCopyProgressDelegate(object oState)
        {
            TimerState timerState = (TimerState)oState;

            // only one leaderboard to monitor for copy
            LbState lbSrc = (LbState)timerState.alLBStates[0];
            LbState lbCur = lbSrc;
            MoveLbGetLbState(timerState.sqlConnection, ref lbCur);

            // 0        1        2        3        4        5        6        7        8
            // LBCopy:HH:MM:SS; xxxxxxxxx of xxxxxxxxx rows copied for xx(xxxxxxxx)
            m_log.Console(
                "LBCopy:"
                +TimeSpanFormat(DateTime.Now.Subtract(timerState.dtMoveStart))
                +"; "
                +lbCur.iTotalRows
                +" of "
                +lbSrc.iTotalRows
                + " rows copied for "
                +lbSrc.uiLeaderboardId
                +"("
                +lbSrc.tid.sTitleIdHexNoPrefix
                +")");
            m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbProgressDelegate: "
                +"lb:"
                +lbCur.uiLeaderboardId
                +"; titleid:"
                +lbCur.tid.sTitleIdHexNoPrefix
                +"; i_rating:"
                +lbCur.iRating
                +"; i_attrib:"
                +lbCur.iAttrib
                +"; i_nickname:"
                +lbCur.iNickname
                +"; i_bucket:"
                +lbCur.iBucket
                +"; i_bucket_count:"
                +lbCur.iBucketCount);
        }

        private void MoveLbCopyProgressEnd(
            Timer timer, 
            int iProgressReportIntervalMilliseconds)
        {
            WaitHandle waitHandle = new AutoResetEvent(false);
            if (!timer.Dispose(waitHandle))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error shutting down move copy progress report timer object";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // wait up to twice the progress interval for the 
            // timer to shutdown
            if (!waitHandle.WaitOne(iProgressReportIntervalMilliseconds*2, true))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error waiting for move copy progress report timer object to shut down";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }
        }

        private void MoveLbGetLbState(
            SqlConnection sqlConnectionProgress, 
            ref LbState lb)
        {
            SqlCommand sqlCommand = sqlConnectionProgress.CreateCommand();
            sqlCommand.CommandText = "p_Stats_LbCountRows";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)lb.tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)lb.uiLeaderboardId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            SqlDataReader sqlDataReader = null;
            try
            {
                // The Timer class does not serialize calls to the delegate, so
                // we need to make sure only one thread is using this sqlConnection
                // at a time
                lock(sqlConnectionProgress)
                {
                    sqlDataReader = sqlCommand.ExecuteReader();

                    // this stored proc should return exactly one row, containing the 
                    // row counts
                    if (!sqlDataReader.Read())
                    {
                        // the stored proceedure may return no rows if the 
                        // leaderboard delete has completed and the leaderboard
                        // no longer exists. In this case, the stored proc will
                        // return 1. If there are no rows and the stored proce
                        // returned 1, then set all the counts to 0. If the
                        // rc is not 1, then throw, because we don't know what
                        // is going on.

                        // close the sqlDataReader so we can check the return code
                        sqlDataReader.Close();

                        int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                        if (iRet != 1)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned no rows and returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }

                        // zero out all the row counts
                        lb.iTotalRows = 0;
                        lb.iRating = 0;
                        lb.iAttrib= 0;
                        lb.iNickname = 0;
                        lb.iBucket = 0;
                        lb.iBucketCount = 0;
                    }
                    else
                    {
                        lb.iRating = (int)sqlDataReader["i_rating"];
                        lb.iAttrib= (int)sqlDataReader["i_attrib"];
                        lb.iNickname = (int)sqlDataReader["i_nickname"];
                        lb.iBucket = (int)sqlDataReader["i_bucket"];
                        lb.iBucketCount = (int)sqlDataReader["i_bucket_count"];

                        lb.iTotalRows 
                            = lb.iRating
                            + lb.iAttrib
                            + lb.iNickname
                            + lb.iBucket
                            + lb.iBucketCount;

                        if (sqlDataReader.Read())
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned more than one row";
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }

                        // close the sqlDataReader so we can check the return code
                        sqlDataReader.Close();

                        int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                        if (iRet != 0)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }
                    }
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
        }

        public SortedList UnitTitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap()");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if title config 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for title configs
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Units_QueryTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                            + "Found title config for "
                            + uiTitleId
                            + " on server "
                            + i);

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found a title config on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap complete");
            return sortedList;
        }

        public void UnitTitleConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            double dDecayFactor,
            uint uiMaxAvailUnits,
            uint uiSizeUnitCache,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                dDecayFactor+ ", " +
                uiMaxAvailUnits+ ", " +
                uiSizeUnitCache+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (dDecayFactor < 0)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: dDecayFactor must be positive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("dDecayFactor", sErr);
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: " +
                "Adding or Updating unit title information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_ConfigureTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@f_decayFactor", SqlDbType.Float).Value = (double)dDecayFactor;
            sqlCommand.Parameters.Add("@i_maxAvailUnits", SqlDbType.Int).Value = (int)uiMaxAvailUnits;
            sqlCommand.Parameters.Add("@i_sizeUnitCache", SqlDbType.Int).Value = (int)uiSizeUnitCache;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.UnitTitleConfigSet");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleConfigSet complete");
        }

        public bool UnitTitleConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            out double dDecayFactor,
            out uint uiMaxAvailUnits,
            out uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            dDecayFactor = 0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_GetTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                        + "found config for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId        int   not null,
                    // f_decayFactor    float not null,
                    // i_maxAvailUnits  int   not null,
                    // i_sizeUnitCache  int   not null

                    dDecayFactor = (double)sqlDataReader["f_decayFactor"];
                    uiMaxAvailUnits = (uint)(int)sqlDataReader["i_maxAvailUnits"];
                    uiSizeUnitCache = (uint)(int)sqlDataReader["i_sizeUnitCache"];
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the title configuration
                    // note that not finding the configuration should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public bool UnitTitleConfigGet(
            CTitleId tid,
            out int iStatsDatabase,
            out double dDecayFactor,
            out uint uiMaxAvailUnits,
            out uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet("+
                tid.ToString()+ ")");

            // invalid index as output if we don't find anything
            iStatsDatabase = -1; 
            dDecayFactor = 0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;
            bool bFound = false;
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                if (UnitTitleConfigGet(
                    tid,
                    i,
                    out dDecayFactor,
                    out uiMaxAvailUnits,
                    out uiSizeUnitCache))
                {
                    if (bFound == true)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                            + "TitleId "
                            + tid.sTitleIdHex
                            + " has units enabled in multiple databases. "
                            + "This is an error and should be corrected!";
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                    bFound = true;
                    iStatsDatabase = i;
                }
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet complete");
            return bFound;
        }

        public void UnitTitleDelete(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_DeleteTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitTitleDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.UnitTitleDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleDelete complete");
        }


        public SortedList UnitLBGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap("+
                tid.ToString()+ ")");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // Even though all the unit leaderboards are supposed to be on one server
            // I've gone with this construct to be consistent with the LBGetDatabaseMap
            // method, plus, it is possible that the database ends up in a bad state
            // and if this method doesn't provide visibility into that, how will we
            // write a tool to fix it?

            SortedList sortedList = new SortedList();

            // iterate through every server we know about and look for unit leaderboards
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Units_QueryLeaderboards";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                bool bUnitLBsFoundOnThisServer = false;
                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiLBNum = (uint)(int)sqlDataReader["i_unitLbId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                            + "Found unit leaderboard "
                            + uiLBNum
                            + " on server "
                            + i);
                        bUnitLBsFoundOnThisServer = true;

                        if (sortedList[uiLBNum] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiLBNum] = rgbMap;
                        }

                        // we found leaderboard uiLBNum on server i, so set the flag
                        ((bool[])sortedList[uiLBNum])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        if (iRet == 1)
                        {
                            // this is returned when the title is not configured.
                            // it's a benign error, as long as we're returning
                            // no rows.
                            if (bUnitLBsFoundOnThisServer == true)
                            {
                                // shouldn't happen, throw
                                string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                                    + "This title is not enabled for units on server "
                                    + i
                                    + ", but unit leaderboards are defined on this server. This should not happen!";
                                m_log.LogFile(sErr);
                                throw new CStatsException(sErr);
                            }
                            // not a problem, just drop through
                        }
                        else
                        {
                            // for some reason, we were not able to get the title configuration
                            // note that not finding the configuration should not cause this error,
                            // it should just return zero rows
                            string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap complete");
            return sortedList;
        }

        public void UnitLBConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitLBConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString()) + ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // we don't check to make sure they've specified the right
            // server - we rely on the stored proc for that to avoid
            // a round trip. We also rely on the stored proc to tell us
            // if we try to change the IsTeam status of this leaderboard

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_ConfigureLeaderboard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_unitLbId", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null? "" : eloConfig.ToStatsDBString());
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitLBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == 1)
                        {
                            // this is the error code returned if the title hasn't been configued
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "TitleId "
                                + tid.sTitleIdHex
                                + " has not been configured for units on this database.";
                        }
                        else if (iRet == 2)
                        {
                            // this is the error code returned when we tried to change ti_IsTeam
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change team status "
                                + "of an existing leaderboard.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBConfigSet complete");
        }

        public bool UnitLBConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            out bool bRequireArbitration,
            out bool bIsTeamLB,
            out CELOConfig eloConfig)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum);

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            bRequireArbitration = false;
            bIsTeamLB = false;
            eloConfig = null;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_GetLeaderboardConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_unitLbId", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitLBConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                        + "found leaderboard "
                        + uiLBNum);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId           int not null,
                    // i_unitLbId          int not null,
                    // vc_params           varchar(256) not null,
                    // ti_IsTeam           tinyint not null,
                    // ti_ReqArbitration   tinyint      not null

                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeamLB = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                                + " Could not parse ELO string for leaderboard " 
                                + uiLBNum
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                                + " ELO string for leaderboard " 
                                + uiLBNum
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                            // note, don't throw just log. Otherwise how will we fix it?
                        }
                    }
                }

                // close the sqlDataReader, so we can get the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr;
                    if (iRet == 1)
                    {
                        // this is the error code returned if the title hasn't been configued
                        // we should simply return false in this case, but we may as
                        // well write a line to the log
                        sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + "Title has not been configured for units on this database.";
                        m_log.LogFile(sErr);
                        iRowsRead = 0;
                        // drop through and return false
                    }
                    else
                    {
                        // not sure what happened
                        sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public SortedList CompTitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap()");

            SortedList sortedList   = new SortedList();

            // iterate through every server we know about and look for competition partitions
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this title id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found partition uiPartition on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap complete");
            return sortedList;
        }


        public SortedList CompPartitionGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap("+
                tid.ToString()+ ", ");

            SortedList sortedListPartitionMap  = new SortedList();

            // iterate through every server we know about and look for competition partitions
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionPartitions";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiPartition = (uint)(byte)sqlDataReader["ti_partition"];

                        if (sortedListPartitionMap[uiPartition] == null)
                        {
                            // we don't yet have an entry for this partition id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedListPartitionMap[uiPartition] = rgbMap;
                        }

                        // we found partition uiPartition on server i, so set the flag
                        ((bool[])sortedListPartitionMap[uiPartition])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap complete");
            return sortedListPartitionMap;
        }

        // note: once created, a partition cannot be removed. If removed, the front doors
        // don't know where to look for leaderboards in that partition. Therefore, I'm 
        // not writing a CompeitionPartitionDelete API at thie time, because if we ever
        // have to do it, it'll be a huge undertaking and this one call won't be enough.

        public void CompPartitionCreate(
            CTitleId tid,
            int iStatsDatabase,
            uint uiPartition,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiPartition+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiPartition > 3)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                    + "uiPartition must be between 0 and 3";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiPartition", sErr);
            }

            // let's be careful, and make sure that this partition isn't already
            // defined somewhere...
            SortedList sortedListPartitionMap = CompPartitionGetDatabaseMap(tid);

            bool[] rgbMap = (bool[])sortedListPartitionMap[uiPartition];
            if (rgbMap != null)
            {
                // the partition is already defined somewhere.
                // is it in the place the caller wants it to be?
                if (rgbMap[iStatsDatabase] == true)
                {
                    // the partition is already defined, just there is nothing
                    // to do, simply return.
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.CompPartitionCreate: " 
                        + "Partition "
                        + uiPartition
                        + " is already defined in database "
                        + iStatsDatabase
                        + ". No partition update required.");
                    m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionCreate complete");
                    return;
                }
                else
                {
                    // the partition is already defined somewhere, but not where
                    // the caller wants it. This is a problem
                    string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                        + "Partition "
                        + uiPartition
                        + " is already defined on a different server than "
                        + iStatsDatabase;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate: " 
                + "Adding competition partition "
                + uiPartition
                + " to database "
                + iStatsDatabase);

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_CreateCompetitionPartition";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@ti_partition", SqlDbType.TinyInt).Value = (int)uiPartition;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.SetCompPartition");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionCreate complete");     
        }

        public SortedList CompTemplateGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap("+
                tid.ToString()+ ", ");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // It's allowed to have the same competition template on multiple servers,
            // but they are supposed to match exactly.

            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for competition templates
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionTemplates";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTemplateId = (uint)(int)sqlDataReader["i_templateId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                            + "Found competition template "
                            + uiTemplateId
                            + " on server "
                            + i);

                        if (sortedList[uiTemplateId] == null)
                        {
                            // we don't yet have an entry for this template id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTemplateId] = rgbMap;
                        }

                        // we found competition template uiTemplateId on server i, so set the flag
                        ((bool[])sortedList[uiTemplateId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap complete");
            return sortedList;
        }

        public void CompTemplateConfigSet(
            CTitleId tid,
            uint uiTemplateId,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet(" +
                tid.ToString()+ ", " +
                uiTemplateId + ", " +
                uiDecayDays+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "Comp templates that require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // there's no reason to not put competition templates on every server
            // we know about, in case at some future time you create a competition template
            // on that new server. This method is a shortcut that allows you to put a 
            // template on every known database server in one call
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                CompTemplateConfigSet(
                    tid,
                    i,
                    uiTemplateId,
                    riLBResetInterval,
                    uiAttachmentCount,
                    uiMaxAttachmentSize,
                    uiDecayDays,
                    bArbitrationRequired,
                    bIsTeam,
                    eloConfig,
                    bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigSet complete");
        }

        public void CompTemplateConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiTemplateId,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiTemplateId + ", " +
                uiDecayDays+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "Comp templates that require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // a competition template is a template for leaderboards that are 
            // created at a later time. The front doors choose the server to
            // create competition templates on according to how the competition
            // partitions are configured. Thus there is no harm to having the
            // same competition template on multiple servers. Therefore we 
            // don't check for that condition here. 
            //
            // Note however that changing a competition template after it has been 
            // inserted is not allowed. So if the competition template already
            // exists, and the parameters provided do not match exactly,
            // the stored proc call will fail. Which makes it kind of pointless
            // to make the call in the first place, but it would take us a
            // round trip to check for the failure case anyway, so we might
            // as well just make the call and throw if it fails.

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_CreateCompetitionTemplate";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_templateId", SqlDbType.Int).Value = (int)uiTemplateId;
            sqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (byte)riLBResetInterval;
            sqlCommand.Parameters.Add("@i_att_count", SqlDbType.Int).Value = (int)uiAttachmentCount;
            sqlCommand.Parameters.Add("@i_max_att_size", SqlDbType.Int).Value = (int)uiMaxAttachmentSize;
            sqlCommand.Parameters.Add("@i_decay_days", SqlDbType.Int).Value = (int)uiDecayDays;
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null ? "" : eloConfig.ToStatsDBString()); 
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);   
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == -2)
                        {
                            // this is the error code returned when the template exists and we did
                            // not match the definition exactly
                            sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                                + "Changing competition templates is not supported. The parameters "
                                + "provided do not match the existing template.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigSet complete");
        }

        public bool CompTemplateConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiTemplateId, 
            out ELBReset leaderboardResetInterval,
            out uint uiAttachmentCount,
            out uint uiMaxAttachmentSize,
            out uint uiDecayDays,
            out bool bRequireArbitration,
            out bool bIsTeamLB,
            out CELOConfig eloConfig)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigGet(" 
                + tid.ToString()+ ", "
                + iStatsDatabase + ", " 
                + uiTemplateId + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            // set default values, in case we find no rows
            leaderboardResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bRequireArbitration = false;
            bIsTeamLB = false;
            eloConfig = null;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_GetCompetitionTemplate";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_templateId", SqlDbType.Int).Value = (int)uiTemplateId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                        + "found competition template "
                        + uiTemplateId);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId               int          not null,
                    // i_templateId            int          not null,
                    // ti_reset_type           tinyint      not null,
                    // i_att_count             int          not null,
                    // i_max_att_size          int          not null,
                    // i_decay_days            int          not null,
                    // i_max_rating_count      int          not null,
                    // vc_params               varchar(256) not null,
                    // ti_IsTeam               tinyint      not null,
                    // ti_ReqArbitration       tinyint      not null

                    leaderboardResetInterval = (ELBReset)(byte)sqlDataReader["ti_reset_type"];
                    uiAttachmentCount = (uint)(int)sqlDataReader["i_att_count"];
                    uiMaxAttachmentSize = (uint)(int)sqlDataReader["i_max_att_size"];
                    uiDecayDays = (uint)(int)sqlDataReader["i_decay_days"];
                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeamLB = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                                + " Could not parse ELO string for competition template " 
                                + uiTemplateId
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                                + " ELO string for competition template " 
                                + uiTemplateId
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                        }
                    }
                }

                // close the sqlDataReader so we can get the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the competition template definition
                    // note that not finding the leaderboard should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public bool FrontDoorReloadAll(
            int iTimeoutMilliseconds,
            bool bReportOnly)
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.FrontDoorReload(" +
                iTimeoutMilliseconds + ", " +
                bReportOnly + ")");

            // I don't want consider the degernate case of zero front
            // doors to be success, which the logic below would produce,
            // therefore I check for this explicitly
            if (NumFrontDoors == 0)
            {
                m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReloadAll:"
                    + "No front doors to reload, returning false");
                return false;
            }

            bool bSuccess = true;
            for (int i = 0; i < NumFrontDoors; ++i)
            {
                if (!FrontDoorReload(i, iTimeoutMilliseconds, bReportOnly))
                {
                    // one front door failed to reload, so we'll return failure
                    bSuccess = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigGet complete, returning:" 
                + bSuccess);
            return bSuccess;
        }

        public bool FrontDoorReload(
            int iStatsFrontDoor,
            int iTimeoutMilliseconds,
            bool bReportOnly)
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.FrontDoorReload(" +
                iStatsFrontDoor + ", " +
                iTimeoutMilliseconds + ", " +
                bReportOnly + ")");

            if (iStatsFrontDoor < 0 || iStatsFrontDoor >= NumFrontDoors)
            {
                string sErr = "Xbox.Tools.Framework.CStats.FrontDoorReload: iStatsFrontDoor " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsFrontDoor", sErr);
            }

            // try each IPAddress we have for the server until one works
            CServer server = m_rgStatsFDServers[iStatsFrontDoor];
            foreach (IPAddress ipAddress in server.rgipAddresses)
            {
                if (SendReloadUrl(ipAddress, iTimeoutMilliseconds))
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.FrontDoorReload"
                        + "Reload operation successful on server "
                        + iStatsFrontDoor);
                    m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReload complete, returning true");
                    return true;
                }
            }

            // if we get here, we were not able to sucessfully send the url to the server
            m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload"
                + "Reload operation not successful on server "
                + iStatsFrontDoor);
            m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReload complete, returning false");
            return true;
        }

        private bool SendReloadUrl(IPAddress ipAddress, int iTimeoutMilliseconds)
        {
            string sHttpRequest = "http://" + ipAddress.ToString() + "/xstats/xstatsreloaddbmap.ashx";
            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.FrontDoorReload: "
                + "Sending: " 
                + sHttpRequest);

            HttpWebRequest httpWebRequest = 
                (HttpWebRequest)WebRequest.Create(sHttpRequest);

            // Turn off connection keep-alives.
            httpWebRequest.KeepAlive = false;

            // set the requested timeout
            httpWebRequest.Timeout = iTimeoutMilliseconds;

            HttpWebResponse httpWebResponse = null;
            try
            {
                httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
                string sResponse;
                try
                {
                    Stream stream = httpWebResponse.GetResponseStream();
                    StreamReader streamReader = new StreamReader(stream);
                    sResponse = streamReader.ReadToEnd();
                }
                catch (ProtocolViolationException)
                {
                    // no content to be had
                    sResponse = String.Empty;
                }

                if (httpWebResponse.StatusCode == HttpStatusCode.OK)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + sHttpRequest 
                        + " reports OK");
                    return true;
                }
                else
                {
                    m_log.WriteLine("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + "Error: " 
                        + sHttpRequest 
                        + " reports " 
                        + httpWebResponse.StatusCode.ToString());
                    return false;
                }
            }
            catch (WebException webException)
            {
                if (webException.Status == WebExceptionStatus.Timeout)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + "Error: " 
                        + sHttpRequest 
                        + " timed out");
                    return false;
                }
                m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                    + "Error: exception sending " 
                    + sHttpRequest);
                m_log.LogFile(webException.Message);
                return false;
            }
            finally
            {
                if (httpWebResponse != null)
                {
                    httpWebResponse.Close();
                }
            }
        }
    }

     public class CStatsException : ApplicationException
    {
        public CStatsException() : base() {}
        public CStatsException(string s) : base(s) {}
        protected CStatsException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CStatsException(string s, Exception e) : base(s, e) {}
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CRepository.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Globalization;
using System.Net;

namespace xonline.tools.framework 
{
    /// <summary>
    ///
    /// The purpose of this class is to encapsulate the complexity of the 
    /// repository. This class contains the knowledge of the directory structure,
    /// file names, and internal file formats for all the information in the
    /// repository. (At least, all the information that I've integrated into
    /// this framework so far).
    ///
    /// Sometimes the methods on this class are simple wrappers that do
    /// some simple parsing, etc. for the caller and not much more
    /// e.g. TitleDefaultLocaleGet(). This is useful because it still hides
    /// the internals of the repository from the caller, and factors out
    /// some repetitive parsing and checking code into one place, instead
    /// of having it scattered all over the place.
    /// 
    /// Sometimes the methods on this class are quite complex wrappers that
    /// have to figure out where information is being stored in the repository
    /// and parse different file formats to get at it. e.g. TitleLBGet().
    /// In these cases, this class is priceless. For example, the code that
    /// syncs the stats service with the repository is completely unaware that
    /// there are four different ways that stats information is stored in the
    /// repository.
    /// 
    /// This file also contains a set of internal linkage helper classes that
    /// encapsulate the details of particular file format, for example the
    /// new title.xml where we're storing title information moving forward.
    ///
    /// </summary>
    public class CRepository
    {
        private CLog m_log;

        // an object for working with source depot
        private CSourceDepot m_sd;

        // the xml file that contains service wide configuration data
        private CServiceXml m_serviceXml;

        // the legacy ini file that stored service wide configuration
        private CIni m_iniServers;

        // title xml files that we've opened on behalf of the caller
        // the key of the hash table is the titleid as an unsigned int
        // the value of the hash table is a CTitleXml object for that titleid
        private Hashtable m_htTitleXmls;

        // legacy stats.xml files that we've opened on behalf of the caller
        // these are simply xsc files that have been renamed and put into the
        // repository
        private Hashtable m_htStatsXmls;

        // legacy stats.ini files that we've opened on behalf of the caller
        // the key of the hash table is the titleid as an unsigned int
        // the value of the hash table is a CIni object for that titleid
        private Hashtable m_htStatsInis;

        // compile time default values to use when upgrading a stats
        // configuration to the latest repository format.
        private const uint c_uiEntriesPerCacheLineDefault = 50;
        private const uint c_uiExpirationSecondsDefault = 900;

        // compile time default values to use when upgrading a stats configuration
        // or when asked for these values for a title that's still using stats.xml
        private const uint c_uiMaxAvailUnitsDefault = 100;
        private const uint c_uiSizeUnitCacheDefault = 100;

        public CRepository(string sSdPort, string sSdClient, CLog log)
        {
            if (log == null)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ctor("
                + (sSdPort == null ? "null" : sSdPort) + ", "
                + (sSdClient == null ? "null" : sSdClient) + ", "
                + "{log})");

            m_sd = new CSourceDepot(sSdPort, sSdClient, m_log);

            m_serviceXml = null;
            m_iniServers = null;
            m_htTitleXmls = new Hashtable();
            m_htStatsXmls = new Hashtable();
            m_htStatsInis = new Hashtable();

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ctor complete");
        }

        // This class opens files, reads them into memory, and then closes them.
        // it does not actively check to see if those files have been changed.
        // This method tell the class to abandon all it's cached data, so that
        // the next request for a piece of data is sure to come from the 
        // relevant file.
        public void DiscardCachedFiles()
        {
            m_serviceXml = null;
            m_iniServers = null;
            m_htTitleXmls = new Hashtable();
            m_htStatsXmls = new Hashtable();
            m_htStatsInis = new Hashtable();
        }

        public string RepositoryRoot
        {
            get
            {
                return m_sd.ClientRoot;
            }
        }

        private string ServicePath
        {
            get
            {
                // the service configuration files live in the /service
                // subdirectory off the root of the repository
                return CPathUtil.AddPathTerminator(m_sd.ClientRoot)
                    + "service";
            }
        }

        private string PublicMasterKeyFileName = "masterkey.pub";

        private string PublicMasterKeyPathAndFileName
        {
            get 
            { 
                return CPathUtil.AddPathTerminator(ServicePath)
                    + PublicMasterKeyFileName;
            }
        }

        private bool PublicMasterKeyExists()
        {
            return File.Exists(PublicMasterKeyPathAndFileName);
        }

        public string PublicMasterKeyFileGet()
        {
            if (!PublicMasterKeyExists())
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.PublicMasterKeyFileGet: "
                    + "Public master key file does not exist in repository.  This needs to be present for site creation." );
            }

            return PublicMasterKeyPathAndFileName;
        }

        private string ServiceXmlName = "service.xml";

        private string ServiceXmlPathAndFileName
        {
            get 
            { 
                return CPathUtil.AddPathTerminator(ServicePath)
                    + ServiceXmlName;
            }
        }

        private bool ServiceXmlExists()
        {
            return File.Exists(ServiceXmlPathAndFileName);
        }

        private void ServiceXmlCreate()
        {
            // This creates and checks in a service xml file that contains 
            // no settings. It will attempt to create the directory where the 
            // xml file lives.
            if (ServiceXmlExists())
            {
                string sErr = "Xbox.Tools.Framework.CRepository.ServiceXmlCreate: "
                    + "Service Xml configuration file already exists in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            XmlDocument xmlDoc = CServiceXml.Create(m_log);

            if (!Directory.Exists(ServicePath))
            {
                m_log.DataMod("Xbox.Tools.Framework.CRepository.ServiceXmlCreate: "
                        + "Creating directory "
                        + ServicePath);
                Directory.CreateDirectory(ServicePath);
            }

            string sServiceXmlPathAndFileName = ServiceXmlPathAndFileName;
            m_log.DataMod("Xbox.Tools.Framework.CRepository.ServiceXmlCreate: "
                    + "Saving service Xml configuration file to "
                    + sServiceXmlPathAndFileName);

            FileStream fileStream = new FileStream(
                sServiceXmlPathAndFileName, 
                FileMode.Create, 
                FileAccess.Write, 
                FileShare.None);
            xmlDoc.Save(fileStream);
            fileStream.Close();

            m_log.DataMod("Xbox.Tools.Framework.CRepository.ServiceXmlCreate: "
                    + "Checking new service Xml configuration file into repository.");
            m_sd.Add(sServiceXmlPathAndFileName);
            string sComment = "Adding new service xml configuration file";
            m_sd.Submit(sServiceXmlPathAndFileName, sComment);
            return;
        }


        private CServiceXml ServiceXmlGet()
        {
            if (!ServiceXmlExists())
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceXmlGet: "
                    + "Service Xml configuration file does not exist in repository. "
                    + "Creating new service xml file.");
                ServiceXmlCreate();
            }

            // the xml file exists now, one way or another.

            // see if we already have the service xmlDoc open
            if (m_serviceXml != null)
            {
                // we already have the service xml open, so return it.
                return m_serviceXml;
            }

            string sServiceXmlPathAndFileName = ServiceXmlPathAndFileName;
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServiceXmlGet: "
                    + "Opening Xml configuration file: "
                    + sServiceXmlPathAndFileName);
            FileStream fileStream = File.OpenRead(sServiceXmlPathAndFileName);
            XmlDocument xmlDoc = new XmlDocument();
            try
            {
                xmlDoc.Load(sServiceXmlPathAndFileName);
            }
            catch (XmlException e)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.ServiceXmlGet: "
                    + "Xml file "
                    + sServiceXmlPathAndFileName
                    + " does not contain well formed xml data. Exception details: "
                    + e.Message;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
            finally
            {
                fileStream.Close();
            }

            m_serviceXml = new CServiceXml(xmlDoc, m_log);
            return m_serviceXml;
        }

        private void ServiceXmlSubmit(string sComment)
        {
            if (sComment == null)
            {
                throw new ArgumentNullException("sComment");
            }

            // if the service xml is not open then just return, there's
            // nothing to do.
            if (m_serviceXml == null)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServiceXmlSubmit: "
                        + "Service Xml configuration file has not been opened. Nothing to submit");
                return;
            }

            // check to see if we've modified the xml data in any way
            if (!m_serviceXml.Changed)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServiceXmlSubmit: "
                        + "Service Xml configuration file has not been modified. Nothing to submit");
                return;
            }

            m_log.DataMod("Xbox.Tools.Framework.CRepository.ServiceXmlSubmit: "
                    + "Updating service xml configuration file in the repository");

            string sServiceXmlPathAndFileName = ServiceXmlPathAndFileName;

            // sd edit the xml file
            m_sd.Edit(sServiceXmlPathAndFileName);

            // open and truncate the file, save the data, and close it
            FileStream fileStream = new FileStream(
                sServiceXmlPathAndFileName, 
                FileMode.Create, 
                FileAccess.Write, 
                FileShare.None);
            m_serviceXml.Save(fileStream);
            fileStream.Close();

            // sd submit the file
            m_sd.Submit(sServiceXmlPathAndFileName, sComment);

            // note, no need to null out m_serviceXml. The caller may not
            // be done making changes

            return;
        }

        public void ServiceSubmit(string sComment)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSubmit("
                + sComment + ")");

            // is the service xml open?
            if (m_serviceXml != null)
            {
                // submit it
                ServiceXmlSubmit(sComment);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSubmit complete");
        }

        private const string ServersIniName = "servers.ini";

        private string ServersIniPathAndFileName
        {
            get
            {
                return CPathUtil.AddPathTerminator(m_sd.ClientRoot)
                    + ServersIniName;
            }
        }
        private bool ServersIniExists()
        {
            return File.Exists(ServersIniPathAndFileName);
        }

        private CIni ServersIniGet()
        {
            if (!ServersIniExists())
            {
                // we don't want to create new legacy
                // repository files, so just return null
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServersIniGet: "
                    + "Legacy servers.ini file does not exist in repository.");
                return null;
            }

            // see if we already have a CIni open for servers.ini
            if (m_iniServers != null)
            {
                // we already have a CIni open, so return it.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServersIniGet: "
                        + "Legacy servers.ini configuration file already open.");
                return m_iniServers;
            }

            string sServersIniPathAndFileName = ServersIniPathAndFileName;
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServersIniGet: "
                    + "Opening legacy servers.ini configuration file: "
                    + sServersIniPathAndFileName);
            try
            {
                m_iniServers = new CIni(sServersIniPathAndFileName);
            }
            catch (ApplicationException e)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.ServersIniGet: "
                    + "Ini file "
                    + sServersIniPathAndFileName
                    + " could not be parsed. Exception details: "
                    + e.Message;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
            return m_iniServers;
        }

        public bool ServiceFrontDoorTimeoutGet(
            ref int iTimeoutMilliseconds)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceFrontDoorTimeoutGet("
                + iTimeoutMilliseconds + ")");

            bool bFound = true;

            CServiceXml serviceXml = ServiceXmlGet();

            string sValue = null;
            if (!serviceXml.PerformanceGet(CServiceXml.FrontDoorTimeoutAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    iTimeoutMilliseconds = Int32.Parse(sValue);
                }
                catch (Exception e)
                {
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceFrontDoorTimeoutGet: "
                        + "Could not parse service setting "
                        + CServiceXml.FrontDoorTimeoutAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceAttachPolicyGet complete, returning: "
                + bFound);
            return bFound;
        }


        public bool ServiceXmgmtTimeoutGet(
            ref int iTimeoutMilliseconds)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceXmgmtTimeoutGet("
                + iTimeoutMilliseconds + ")");

            bool bFound = true;

            CServiceXml serviceXml = ServiceXmlGet();

            string sValue = null;
            if (!serviceXml.PerformanceGet(CServiceXml.XmgmtTimeoutAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    iTimeoutMilliseconds = Int32.Parse(sValue);
                }
                catch (Exception e)
                {
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceXmgmtTimeoutGet: "
                        + "Could not parse service setting "
                        + CServiceXml.XmgmtTimeoutAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceAttachPolicyGet complete, returning: "
                + bFound);
            return bFound;
        }


        public SortedList ServiceHealthUrlGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList()");

            SortedList sl = new SortedList();

            CIni iniServers = ServersIniGet();
            if (iniServers == null)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList: "
                    + "servers.ini does not exist, unable to retrieve health urls.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList complete");
                // return the empty sorted list
                return sl;
            }

            // get the Health section
            SortedList slHealthSection = iniServers.GetSection(CServersIni.HealthSectionName);
            if (slHealthSection == null)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList: "
                    + "servers.ini does not contain a "
                    + CServersIni.HealthSectionName
                    + " section. No health urls found.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList complete");
                // return the empty sorted list
                return sl;
            }


            // While it was elegant, the solution commented out below unfortunately 
            // didn't work. The server IP address used by xmgmt is not always the same 
            // as the IP address the front door uses. I can't redefine the existing
            // server IPs in servers.ini, so I'll just add full URLs to the health
            // section instead. Crude but flexible, and very easy to code because
            // we simply return the sorted list we get from CIni
            // 
            // iterate through each server named in the health section, and
            // assemble the health urls by getting the servers IPs and appending
            // the specified url
            /*
            foreach (DictionaryEntry de in slHealthSection)
            {
                string sServerName = (string)de.Key;
                string sUrlEnding = (string)de.Value;

                // get the list of server IPs
                CServer[] rgServers = ServiceServerGetList(sServerName);
                for (int i = 0; i < rgServers.Length; ++i)
                {
                    // make the friendly name the server name from
                    // the ini file, plus an ordinal suffix
                    string sFriendlyName = sServerName+" "+i.ToString();
                    string sUrl = "http://"
                        + rgServers[i].rgipAddresses[0].ToString()
                        + sUrlEnding;
                    sl.Add(sFriendlyName, sUrl);
                }
            }
            */

            // see comment block above for why this is correct...
            sl = slHealthSection;

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList: "
                + " Found " 
                + sl.Count
                + " health urls");

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceHealthUrlGetList complete");
            return sl;
        }

        public string[] ServiceDownloadUNCPathGetList(uint uiSiteId)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDownloadUNCPathGetList()");

            CIni iniServers = ServersIniGet();
            if (iniServers == null)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceDownloadUNCPathGetList: "
                    + "servers.ini does not exist, unable to retrieve download points.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDownloadUNCPathGetList complete");

                // return an empty array
                return new string[0];
            }

            string sSiteSectionName = CServersIni.SiteSectionPrefix + uiSiteId.ToString();
            string sDownloadUNCs = iniServers.GetSetting(
                sSiteSectionName,
                CServersIni.DownloadUNCPathSettingName);
            if (sDownloadUNCs == null)
            {
                // return a zero length array
                return new string[0];
            }

            // split the string
            string[] rgsDownloadUNCs = sDownloadUNCs.Split(';');

            // that's the final answer...
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDownloadUNCPathGetList complete");
            return rgsDownloadUNCs;
        }

        public string[] ServiceSecurityGatewayUNCPathGetList(uint uiSiteId)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList()");

            CIni iniServers = ServersIniGet();
            if (iniServers == null)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList: "
                    + "servers.ini does not exist, unable to retrieve security gateway info.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList complete");

                // return an empty array
                return new string[0];
            }

            // first get the SGCFG path - this tells us where on the SG the ini files
            // are kept
            string sSGConfigPath = iniServers.GetSetting(
                CServersIni.ServersSectionName,
                CServersIni.SGConfigSettingName);
            if (sSGConfigPath == null)
            {
                // return a zero length array
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList: "
                    + "Setting "
                    + CServersIni.SGConfigSettingName
                    + " not found.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList complete");
                return new string[0];
            }

            // make sure the path is formatted correctly
            // it should be like D:\sgcfg
            if (sSGConfigPath.IndexOf(":") != 1)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList: "
                    + "Setting "
                    + CServersIni.SGConfigSettingName
                    + " with value "
                    + sSGConfigPath
                    + " is invalid.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList complete");
                return new string[0];
            }

            // replace the ":" with "$" so we can use it in the 
            // unc path as an admin share
            sSGConfigPath = sSGConfigPath.Substring(0,1) + "$" + sSGConfigPath.Substring(2);

            string sSiteSectionName = CServersIni.SiteSectionPrefix + uiSiteId.ToString();
            string sSGServers = iniServers.GetSetting(
                sSiteSectionName,
                CServersIni.SGServerSettingName);
            if (sSGServers == null)
            {
                // return a zero length array
                return new string[0];
            }


            // split the server string
            string[] rgsSGServers = sSGServers.Split(';');
            ArrayList al = new ArrayList();
            foreach (string sSGServer in rgsSGServers)
            {
                // assemble the unc path
                string sUNCPath = @"\\" + sSGServer+ @"\" + sSGConfigPath;
                al.Add(sUNCPath);
            }

            string[] rgsUNCPaths = new string[al.Count];
            al.CopyTo(rgsUNCPaths);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSecurityGatewayUNCPathGetList complete");
            return rgsUNCPaths;
        }

        public void ServiceLBPolicySet(
            uint uiMaxSingleAttachSize,
            uint uiMaxTotalAttachSize,
            uint uiMaxLeaderboardCount)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicySet("
                + uiMaxSingleAttachSize + ", "
                + uiMaxTotalAttachSize + ", "
                + uiMaxLeaderboardCount + ")");

            // save the setting to the service xml file
            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.PolicySet(CServiceXml.MaxSingleAttachSizeAttrName, uiMaxSingleAttachSize.ToString());
            serviceXml.PolicySet(CServiceXml.MaxTotalAttachSizeAttrName, uiMaxTotalAttachSize.ToString());
            serviceXml.PolicySet(CServiceXml.MaxLeaderboardCount, uiMaxLeaderboardCount.ToString());

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicySet complete");
        }

        public bool ServiceLBPolicyGet(
            ref uint uiMaxSingleAttachSize,
            ref uint uiMaxTotalAttachSize,
            ref uint uiMaxLeaderboardCount)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicyGet("
                + uiMaxSingleAttachSize + ", "
                + uiMaxTotalAttachSize + ", "
                + uiMaxLeaderboardCount + ")");

            bool bFound = true;

            CServiceXml serviceXml = ServiceXmlGet();

            string sValue = null;
            if (!serviceXml.PolicyGet(CServiceXml.MaxSingleAttachSizeAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    uiMaxSingleAttachSize = UInt32.Parse(sValue);
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceLBPolicyGet: "
                        + "Could not parse service setting "
                        + CServiceXml.MaxSingleAttachSizeAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            sValue = null;
            if (!serviceXml.PolicyGet(CServiceXml.MaxTotalAttachSizeAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    uiMaxTotalAttachSize = UInt32.Parse(sValue);
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceLBPolicyGet: "
                        + "Could not parse service setting "
                        + CServiceXml.MaxTotalAttachSizeAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            sValue = null;
            if (!serviceXml.PolicyGet(CServiceXml.MaxLeaderboardCount, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    uiMaxLeaderboardCount= UInt32.Parse(sValue);
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceLBPolicyGet: "
                        + "Could not parse service setting "
                        + CServiceXml.MaxLeaderboardCount
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicyGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void ServiceLBPolicyDelete()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicyDelete()");

            // delete the setting from service xml
            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.PolicyDelete(CServiceXml.MaxSingleAttachSizeAttrName);
            serviceXml.PolicyDelete(CServiceXml.MaxTotalAttachSizeAttrName);
            serviceXml.PolicyDelete(CServiceXml.MaxLeaderboardCount);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLBPolicyDelete complete");
        }

        public void ServiceDefaultStatsLimitsSet(
            uint uiMaxWrites,
            uint uiMaxReads)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsSet("
                + uiMaxWrites + ", "
                + uiMaxReads + ")");

            // save the setting to the service xml file
            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.PerformanceSet(CServiceXml.DefaultStatsMaxWritesAttrName, uiMaxWrites.ToString());
            serviceXml.PerformanceSet(CServiceXml.DefaultStatsMaxReadsAttrName, uiMaxReads.ToString());

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsSet complete");
        }

        public bool ServiceDefaultStatsLimitsGet(
            ref uint uiMaxWrites,
            ref uint uiMaxReads)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsGet("
                + uiMaxWrites + ", "
                + uiMaxReads + ")");

            bool bFound = true;

            CServiceXml serviceXml = ServiceXmlGet();

            string sValue = null;
            if (!serviceXml.PerformanceGet(CServiceXml.DefaultStatsMaxWritesAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    uiMaxWrites= UInt32.Parse(sValue);
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsGet: "
                        + "Could not parse service setting "
                        + CServiceXml.DefaultStatsMaxWritesAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            sValue = null;
            if (!serviceXml.PerformanceGet(CServiceXml.DefaultStatsMaxReadsAttrName, ref sValue))
            {
                bFound = false;
            }
            else
            {
                try
                {
                    uiMaxReads= UInt32.Parse(sValue);
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsGet: "
                        + "Could not parse service setting "
                        + CServiceXml.DefaultStatsMaxReadsAttrName
                        + " as an integer. String value is "
                        + sValue
                        + ". Exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void ServiceDefaultStatsLimitsDelete()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsDelete()");

            // delete the setting from service xml
            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.PerformanceDelete(CServiceXml.DefaultStatsMaxWritesAttrName);
            serviceXml.PerformanceDelete(CServiceXml.DefaultStatsMaxReadsAttrName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultStatsLimitsDelete complete");
        }

        public void ServiceQueryTypeSet(string sQueryTypeName)
        {
            if (sQueryTypeName == null)
            {
                throw new ArgumentNullException("sQueryTypeName");
            }
            if (sQueryTypeName == String.Empty)
            {
                throw new ArgumentException(
                    "String.Empty is not a valid query type name", 
                    "sQueryTypeName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeSet("
                +sQueryTypeName+")");

            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.QueryTypeSet(sQueryTypeName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeSet complete");
        }

        public string[] ServiceQueryTypeGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeGetList()");

            CServiceXml serviceXml = ServiceXmlGet();
            string[] rgsQueryTypeNames = serviceXml.QueryTypeGetList();

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeGetList complete");
            return rgsQueryTypeNames;
        }

        public void ServiceQueryTypeDelete(string sQueryTypeName)
        {
            if (sQueryTypeName == null)
            {
                throw new ArgumentNullException("sQueryTypeName");
            }
            if (sQueryTypeName == String.Empty)
            {
                throw new ArgumentException(
                    "String.Empty is not a valid query type name", 
                    "sQueryTypeName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeDelete("
                +sQueryTypeName+")");

            CServiceXml serviceXml = ServiceXmlGet();
            serviceXml.QueryTypeDelete(sQueryTypeName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryTypeDelete complete");
        }

        public bool ServiceLockfileGet(
            ref string sLockFilePathAndName)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLockfileGet("
                + ((sLockFilePathAndName == null) ? "null" : sLockFilePathAndName) + ")");

            // This is the legacy "lockfile" that I hope to replace with a 
            // more sophisticated locking method through source depot.
            // Therefore I'm just grabbing it out of servers.ini, and offering
            // no override in service.xml, or any way to set or delete this
            // setting.

            bool bFound = false;
            CIni iniServers = ServersIniGet();
            string sValue = iniServers.GetSetting(
                CServersIni.ServersSectionName,
                CServersIni.LockfileSettingName);
            if (sValue == null)
            {
                bFound = false;
            }
            else
            {
                sLockFilePathAndName = sValue;
                bFound = true;
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceLockfileGet complete, returning: "
                + bFound);
            return bFound;
        }

        public uint[] ServiceSitesGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSitesGetList()");

            // still using servers.ini for this

            CIni iniServers = ServersIniGet();
            SortedList slSections = iniServers.GetSections();
            ArrayList alSites = new ArrayList();

            foreach (DictionaryEntry de in slSections)
            {
                // do the first characters of the section name match "SITE."?
                if (((string)de.Key).Trim().ToUpper().IndexOf(CServersIni.SiteSectionPrefix) == 0)
                {
                    string sSiteNum 
                        = ((string)de.Key).Trim().Substring(CServersIni.SiteSectionPrefix.Length);
                    if (sSiteNum.Length > 0)
                    {
                        // try to parse the string after "SITE." as an integer
                        try
                        {
                            uint ui = UInt32.Parse(sSiteNum);
                            alSites.Add(ui);
                        }
                        catch (Exception e)
                        {
                            string sErr = "Xbox.Tools.Framework.CRepository.ServiceSitesGetList: "
                                + "Could not extract site number from section name "
                                + (string)de.Key
                                + ". Exception details: "
                                + e.Message;
                            m_log.LogFile(sErr);
                        }
                    }
                }
            }

            uint[] rgui = new uint[alSites.Count];
            alSites.Sort();
            alSites.CopyTo(rgui);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceSitesGetList complete");
            return rgui;
        }

        public CServer[] ServiceStatsDBGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceStatsDBGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.StatsDBSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceStatsDBGetList complete");
            return rgServers;
        }

        public CServer[] ServiceStatsFDGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceStatsDBGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.StatsFDSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceStatsDBGetList complete");
            return rgServers;
        }

        public CServer[] ServiceMatchDBGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceMatchDBGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.MatchDBSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceMatchDBGetList complete");
            return rgServers;
        }

        public CServer[] ServiceMatchFDGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceMatchFDGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.MatchFDSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceMatchFDGetList complete");
            return rgServers;
        }

        public CServer ServiceWebDBGet()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWebDBGet()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WebDBSettingName);

            CServer server;
            if (rgServers.Length > 1)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceWebDBGet: "
                    + "Warning: Multiple addresses specified for WebDB in servers.ini, "
                    + "using first address.");
            }

            if (rgServers.Length == 0)
            {
                server = null;
            }
            else
            {
                server = rgServers[0];
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWebDBGet complete");
            return server;
        }

        public CServer[] ServiceWCAlertsGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCAlertsGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCAlertsSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCAlertsGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCGeneralGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCGeneralGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCGeneralSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCGeneralGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCMessagingGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCMessagingGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCMessagingSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCMessagingGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCPresenceGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCPresenceGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCPresenceSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCPresenceGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCQueryGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCQueryGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCQuerySettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCQueryGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCSignatureGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCSignatureGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCSignatureSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCSignatureGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCStatsGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCStatsGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCStatsSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCStatsGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCStorageGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCStorageGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCStorageSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCStorageGetList complete");
            return rgServers;
        }
        public CServer[] ServiceWCUsersGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCUsersGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.WCUsersSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceWCUsersGetList complete");
            return rgServers;
        }

        public CServer ServiceNPDBGet()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceNPDBGet()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.NPDBSettingName);

            CServer server;
            if (rgServers.Length > 1)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceNPDBGet: "
                    + "Warning: Multiple addresses specified for NPDB in servers.ini, "
                    + "using first address.");
            }

            if (rgServers.Length == 0)
            {
                server = null;
            }
            else
            {
                server = rgServers[0];
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceNPDBGet complete");
            return server;
        }

        public CServer[] ServicePresNotiFDGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServicePresNotiFDGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.PresNotiFDSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServicePresNotiFDGetList complete");
            return rgServers;
        }

        public CServer[] ServiceXKDCGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceXKDCGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.XKDCSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceXKDCGetList complete");
            return rgServers;
        }

        public CServer[] ServiceXBOSGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceXBOSGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.XBOSSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceXBOSGetList complete");
            return rgServers;
        }

        public CServer[] ServiceFeedbackFDGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceFeedbackFDGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.FeedbackFDSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceFeedbackFDGetList complete");
            return rgServers;
        }

        public CServer[] ServiceUACSGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceUACSGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.UACSSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceUACSGetList complete");
            return rgServers;
        }

        public CServer[] ServiceQueryDBGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryDBGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.QueryDBSettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryDBGetList complete");
            return rgServers;
        }

        public CServer ServiceAlertsDBGet()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceAlertsDBGet()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.AlertsDBSettingName);

            CServer server;
            if (rgServers.Length > 1)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceAlertsDBGet: "
                    + "Warning: Multiple addresses specified for ALERTSDB in servers.ini, "
                    + "using first address.");
            }

            if (rgServers.Length == 0)
            {
                server = null;
            }
            else
            {
                server = rgServers[0];
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceAlertsDBGet complete");
            return server;
        }

        public CServer[] ServiceQueryFDGetList()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryFDGetList()");

            CServer[] rgServers = ServiceServerGetList(CServersIni.XqrySettingName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceQueryFDGetList complete");
            return rgServers;
        }

        public CServer ServiceTitlesDBGet()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceTitlesDBGet()");

            // still using servers.ini for this
            // the setting is a semicolon delimited list of IP addresses

            CIni iniServers = ServersIniGet();
            string sServer = iniServers.GetSetting(
                CServersIni.ServersSectionName,
                CServersIni.TitlesDBSettingName);
            if (sServer == null)
            {
                // no setting, return null
                return null;
            }

            IPAddress[] rgIPAddress = new IPAddress[1];
            try
            {
                rgIPAddress[0] = IPAddress.Parse(sServer);
            }
            catch (Exception e)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceTitlesDBGet: "
                    + "Error parsing IP Address for "
                    + CServersIni.TitlesDBSettingName
                    + " of: "
                    + sServer
                    + "This setting will be ignored. Exception details: "
                    + e.Message);
                return null;
            }

            CServer server = new CServer(null, rgIPAddress);
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceTitlesDBGet complete");
            return server;
        }

        private CServer[] ServiceServerGetList(string sSettingName)
        {
            // still using servers.ini for this
            // the setting is a semicolon delimited list of IP addresses

            CIni iniServers = ServersIniGet();
            string sServers = iniServers.GetSetting(
                CServersIni.ServersSectionName,
                sSettingName);
            if (sServers == null)
            {
                // return a zero length array
                return new CServer[0];
            }

            // split the string
            string[] rgsServers = sServers.Split(';');

            ArrayList alServers = new ArrayList();
            for (int i = 0; i < rgsServers.Length; ++i)
            {
                IPAddress[] rgIPAddress = new IPAddress[1];
                try
                {
                    rgIPAddress[0] = IPAddress.Parse(rgsServers[i]);
                    alServers.Add(new CServer(null, rgIPAddress));
                }
                catch (Exception e)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.ServiceStatsDBGetList: "
                        + "Error parsing IP Address for "
                        + sSettingName
                        + " of: "
                        + rgsServers[i]
                        + "This server will be ignored. Exception details: "
                        + e.Message);
                }
            }

            CServer[] rgServers = new CServer[alServers.Count];
            alServers.CopyTo(rgServers);
            return rgServers;
        }


        // the semantics on this call are a little different than usual
        // we've compiled reasonable default values for these settings into
        // this file, so if they are not found in servers.ini, the compile
        // time defaults are returned. Therefore the return code still tells
        // you if the setting was found in servers.ini, but you will always
        // get usable values in the out parameters.
        public bool ServiceDefaultWebCacheSettingsGet(
            out uint uiEntriesPerCacheLine,
            out uint uiExpirationSeconds)
        {
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultWebCacheSettingsGet("
                +"{out uiEntriesPerCacheLine}, "
                +"{out uiExpirationSeconds})");

            // set the compile tiem defaults first. we'll overwrite
            // these if we find something in servers.ini
            uiEntriesPerCacheLine = c_uiEntriesPerCacheLineDefault;
            uiExpirationSeconds = c_uiExpirationSecondsDefault;
            
            // get expiration seconds and entries per cache line 
            // from servers.ini
            CIni iniServers = ServersIniGet();
            if (iniServers == null)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Could not open servers.ini");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultWebCacheSettingsGet complete");
                return false;
            }

            bool bFound = false;

            string sEntriesPerCacheLine =  iniServers.GetSetting(
                CServersIni.DefaultSectionName,
                CServersIni.EntriesPerCacheLineSettingName);
            try
            {
                uiEntriesPerCacheLine= UInt32.Parse(sEntriesPerCacheLine);
                bFound = true;
            }
            catch (Exception e)
            {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                        + "Could not parse "
                        + CServersIni.EntriesPerCacheLineSettingName
                        + " setting with value "
                        + sEntriesPerCacheLine
                        + " from servers.ini. Exception details: "
                        + e.Message);
            }

            string sExpirationSeconds =  iniServers.GetSetting(
                CServersIni.DefaultSectionName,
                CServersIni.ExpirationSecondsSettingName);
            try
            {
                uiExpirationSeconds = UInt32.Parse(sExpirationSeconds);
                bFound = true;
            }
            catch (Exception e)
            {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                        + "Could not parse "
                        + CServersIni.ExpirationSecondsSettingName
                        + " setting with value "
                        + sExpirationSeconds
                        + " from servers.ini. Exception details: "
                        + e.Message);
            }
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.ServiceDefaultWebCacheSettingsGet complete");
            return bFound;
        }

        public bool TitleExists(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleExists("
                + tid.sTitleIdHexNoPrefix + ")");

            bool bExists = Directory.Exists(TitlePath(tid));

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleExists complete, returing "
                + bExists);
            return bExists;
        }

        public void TitleCreate(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCreate("
                + tid.sTitleIdHexNoPrefix + ")");

            if (TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleCreate: "
                    + "Title "
                    + tid.sTitleIdHexNoPrefix
                    + " already exists in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
            Directory.CreateDirectory(TitlePath(tid));

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCreate complete");
        }

        public void TitleDelete(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDelete("
                + tid.sTitleIdHexNoPrefix + ")");

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleDelete: "
                    + "Title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // first, sd revert anything in that title, so things are either in
            // or out
            string sDeletePath = CPathUtil.AddPathTerminator(TitlePath(tid)) + "...";
            m_sd.Revert(sDeletePath);

            // now use sd files to see if there's anything we need to sd delete
            string[] rgsFiles = m_sd.Files(sDeletePath, true);
            foreach (string sFile in rgsFiles)
            {
                m_sd.Delete(sFile);
                string sComment = "Removing title " + tid.sTitleIdHexNoPrefix + " from repository";
                m_sd.Submit(sFile, sComment);
            }

            // anything that was in source depot should be gone now, 
            // so now clean up any leftovers and remove the directory
            // completely, or the title will still be considered to exist
            if (Directory.Exists(TitlePath(tid)))
            {
                CPathUtil.RemovePath(TitlePath(tid));
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDelete complete");
        }

        public void TitleSubmit(CTitleId tid, string sComment)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleSubmit("
                + tid.sTitleIdHexNoPrefix + ", "
                + sComment + ")");

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleSubmit: "
                    + "Title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // is there a title xml open for this title?
            if (m_htTitleXmls.ContainsKey(tid.uiTitleId))
            {
                // submit it
                TitleXmlSubmit(tid, sComment);
            }

            // the only legacy file we modify is stats.ini (for esrb, default locale
            // and cluster id)
            if (m_htStatsInis.ContainsKey(tid.uiTitleId))
            {
                // submit it
                TitleStatsIniSubmit(tid, sComment);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleSubmit complete");
        }

        private string TitleArchivePath(CTitleId tid)
        {
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + "submission";
        }

        public void TitleArchiveFile(
            CTitleId tid, 
            string sPathAndFileName,
            string sComment)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sPathAndFileName == null)
            {
                throw new ArgumentNullException("sPathAndFileName");
            }
            if (sComment == null)
            {
                throw new ArgumentNullException("sComment");
            }

            // make sure the source file exists
            if (!File.Exists(sPathAndFileName))
            {
                throw new ArgumentException(
                    sPathAndFileName+" does not exist",
                    "sPathAndFileName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile("
                + tid.sTitleIdHexNoPrefix + ", "
                + sPathAndFileName+", "
                + sComment + ")");

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                    + "Title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // build the destination path
            string sDestinationPathAndFileName
                = CPathUtil.AddPathTerminator(TitleArchivePath(tid))
                + Path.GetFileName(sPathAndFileName);
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                    + "File will be archived to "
                    + sDestinationPathAndFileName);

            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                    + "Archiving file "
                    + sPathAndFileName
                    + " for title id "
                    + tid.sTitleIdHexNoPrefix
                    + " to "
                    + sDestinationPathAndFileName);

            // does this file already exist in source depot?
            bool bSdEdit = false;
            string [] rgsFiles = m_sd.Files(sDestinationPathAndFileName, true);
            if (rgsFiles.Length > 0)
            {
                // the file exists in source depot, so 'sd edit' it
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                        + "executing 'sd edit' on "
                        + sDestinationPathAndFileName);
                m_sd.Edit(sDestinationPathAndFileName);
                bSdEdit = true;
            }

            // make sure the file on disk (if any) is read/write
            if (File.Exists(sDestinationPathAndFileName))
            {
                if ((File.GetAttributes(sDestinationPathAndFileName) & FileAttributes.ReadOnly) != 0)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                            + "clearing read only attribute on "
                            + sDestinationPathAndFileName);
                    File.SetAttributes(sDestinationPathAndFileName, FileAttributes.Normal);
                }
            }

            // create the directory if it doesn't already exist
            if (!Directory.Exists(Path.GetDirectoryName(sDestinationPathAndFileName)))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                        + "Creating destination directory "
                        + Path.GetDirectoryName(sDestinationPathAndFileName));
                Directory.CreateDirectory(
                    Path.GetDirectoryName(sDestinationPathAndFileName));
            }

            // copy the file to the destination path
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                    + "Copying from "
                    + sPathAndFileName
                    + " to "
                    + sDestinationPathAndFileName);
            File.Copy(sPathAndFileName, sDestinationPathAndFileName, true);

            // if we didn't 'sd edit' the file above, that means we need
            // to 'sd add' it now
            if (!bSdEdit)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                        + "executing 'sd add' on "
                        + sDestinationPathAndFileName);
                m_sd.Add(sDestinationPathAndFileName);
            }

            // now 'sd submit' the file
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile: "
                    + "executing 'sd submit' on "
                    + sDestinationPathAndFileName);
            m_sd.Submit(sDestinationPathAndFileName, sComment);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleArchiveFile complete");
        }

        private string TitleGameConfigName(CTitleId tid)
        {
            // The title's game configuration file is named:
            // gameconfig_<titleid>.xml
            // where titlid is in hex notation with no 0x prefix
            return "gameconfig_" + tid.sTitleIdHexNoPrefix + ".xml";
        }

        private string TitleGameConfigPath(CTitleId tid)
        {
            // put it in the config directory, so it's not 
            // in the middle of all those offers...
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + "config";
        }

        private string TitleGameConfigPathAndFileName(CTitleId tid)
        {
            return CPathUtil.AddPathTerminator(TitleGameConfigPath(tid))
                + TitleGameConfigName(tid);
        }

        public bool TitleGameConfigExists(CTitleId tid)
        {
            return File.Exists(TitleGameConfigPathAndFileName(tid));
        }

        public void TitleGameConfigSet(
            CTitleId tid,
            string gameConfigFile)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (gameConfigFile == null)
            {
                throw new ArgumentNullException("gameConfigFile");
            }

            // make sure the source file exists
            if (!File.Exists(gameConfigFile))
            {
                throw new ArgumentException(
                    gameConfigFile+" does not exist",
                    "gameConfigFile");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + gameConfigFile + ")");

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                    + "Title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // build the destination path
            string destFile = TitleGameConfigPathAndFileName(tid);

            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                    + "Saving game config file to "
                    + destFile
                    + " for title id "
                    + tid.sTitleIdHexNoPrefix);

            // does the game config file already exist in source depot?
            bool bSdEdit = false;
            string [] rgsFiles = m_sd.Files(destFile, true);
            if (rgsFiles.Length > 0)
            {
                // the file exists in source depot, so 'sd edit' it
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                        + "executing 'sd edit' on "
                        + destFile);
                m_sd.Edit(destFile);
                bSdEdit = true;
            }

            // make sure the file on disk (if any) is read/write
            if (File.Exists(destFile))
            {
                if ((File.GetAttributes(destFile) & FileAttributes.ReadOnly) != 0)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                            + "clearing read only attribute on "
                            + destFile);
                    File.SetAttributes(destFile, FileAttributes.Normal);
                }
            }

            // create the directory if it doesn't already exist
            if (!Directory.Exists(Path.GetDirectoryName(destFile)))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                        + "Creating destination directory "
                        + Path.GetDirectoryName(destFile));
                Directory.CreateDirectory(
                    Path.GetDirectoryName(destFile));
            }

            // copy the file to the destination path
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                    + "Copying from "
                    + gameConfigFile
                    + " to "
                    + destFile);
            File.Copy(gameConfigFile, destFile, true);

            // if we didn't 'sd edit' the file above, that means we need
            // to 'sd add' it now
            if (!bSdEdit)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                        + "executing 'sd add' on "
                        + destFile);
                m_sd.Add(destFile);
            }

            // now 'sd submit' the file
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet: "
                    + "executing 'sd submit' on "
                    + destFile);
            m_sd.Submit(destFile, "submitting game config file for titleid "+tid.sTitleIdHexNoPrefix);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigSet complete");
        }

        public FileStream TitleGameConfigGet(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigGet("
                + tid.sTitleIdHexNoPrefix + ")");

            if (!TitleGameConfigExists(tid))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigGet: "
                        + "game config file not present in repository, returning null");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigGet complete, returning null");
                return null;
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigGet: "
                    + "opening game config file (FileMode.Open, FileAccess.Read, FileShare.Read)");
            FileStream gameConfig = new FileStream(
                TitleGameConfigPathAndFileName(tid),
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleGameConfigGet complete, returning FileStream object");
            return gameConfig;
        }

        public bool TitleContainsStatsInfo(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleContainsStatsInfo("
                + tid.sTitleIdHexNoPrefix + ")");

            // A title is deemed to contain stats information if it has at least
            // one leaderboard, or one unit leaderboard, or one competition template
            // defined somewhere. To avoid repeating the logic that determines where
            // to find this information, we simply retrieve the list of ids for each
            // type of leaderboard element, and see if there are any defined.
            uint[] rguiLBs = TitleLBGetList(tid);
            uint[] rguiUnits = TitleUnitGetList(tid);
            uint[] rguiComps = TitleCompGetList(tid);

            if (rguiLBs.Length + rguiUnits.Length + rguiComps.Length == 0)
            {
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleContainsStatsInfo complete, returning false");
                return false;
            }
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleContainsStatsInfo complete, returning true");
            return true;
        }

        public void TitleDefaultLocaleSet(CTitleId tid, CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + locale.ToString() + ")");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // for now, consider this an error, soon (once I remove
                // the legacy code that uses this setting) this will
                // write to the title xml...
                string sErr = "Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                    + "stats.ini missing for titleid "
                    + tid.sTitleIdHexNoPrefix;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            m_log.DataMod2("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                + "Setting "
                + CStatsIni.DefaultLocaleSettingName
                + "="
                + locale.ToString()
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);
            iniStats.SetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.DefaultLocaleSettingName, 
                locale.ToString());

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet complete");
        }

        public bool TitleDefaultLocaleGet(CTitleId tid, ref CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{ref locale})");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // no stats ini, no setting
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                    + "stats.ini not found for titleid "
                    + tid.sTitleIdHexNoPrefix
                    + ". Unable to get setting.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet complete");
                return false;
            }

            string sLocale = iniStats.GetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.DefaultLocaleSettingName);

            if (sLocale == null || sLocale == String.Empty)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                    + CStatsIni.DefaultLocaleSettingName
                    + " setting not found in stats.ini for titleid "
                    + tid.sTitleIdHexNoPrefix);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet complete");
                return false;
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                + "Found setting of "
                + sLocale
                + " for "
                + CStatsIni.DefaultLocaleSettingName
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);

            bool bFound = false;
            try
            {
                locale = new CLocale(sLocale);
                bFound = true;
            }
            catch (Exception)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet "
                    + "Setting of "
                    + sLocale
                    + " is not a valid locale. This setting will be ignored.");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDefaultLocaleSet complete");
            return bFound;
        }

        public void TitleESRBSet(CTitleId tid, EESRBRating esrbRating)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + esrbRating + ")");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // for now, consider this an error, soon (once I remove
                // the legacy code that uses this setting) this will
                // write to the title xml...
                string sErr = "Xbox.Tools.Framework.CRepository.TitleESRBSet "
                    + "stats.ini missing for titleid "
                    + tid.sTitleIdHexNoPrefix;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            int i = (int)esrbRating;

            m_log.DataMod2("Xbox.Tools.Framework.CRepository.TitleESRBSet "
                + "Setting "
                + CStatsIni.ESRBSettingName
                + "="
                + i
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);
            iniStats.SetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.DefaultLocaleSettingName, 
                i.ToString());

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBSet complete");
        }

        public bool TitleESRBGet(CTitleId tid, ref EESRBRating esrbRating)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + esrbRating +")");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // no stats ini, no setting
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleESRBGet "
                    + "stats.ini not found for titleid "
                    + tid.sTitleIdHexNoPrefix
                    + ". Unable to get setting.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBGet complete");
                return false;
            }

            string sESRB = iniStats.GetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.ESRBSettingName);

            if (sESRB == null || sESRB == String.Empty)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleESRBGet "
                    + CStatsIni.ESRBSettingName
                    + " setting not found in stats.ini for titleid "
                    + tid.sTitleIdHexNoPrefix);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBGet complete");
                return false;
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleESRBGet "
                + "Found setting of "
                + sESRB
                + " for "
                + CStatsIni.ESRBSettingName
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);

            bool bFound = false;
            try
            {
                esrbRating = (EESRBRating)UInt32.Parse(sESRB);
                bFound = true;
            }
            catch (Exception)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleESRBGet "
                    + "Setting of "
                    + sESRB
                    + " is not an integer. This setting will be ignored.");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleESRBGet complete");
            return bFound;
        }

        public void TitleWebClusterIdSet(CTitleId tid, uint uiClusterId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiClusterId + ")");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // for now, consider this an error, soon (once I remove
                // the legacy code that uses this setting) this will
                // write to the title xml...
                string sErr = "Xbox.Tools.Framework.CRepository.TitleWebClusterIdSet "
                    + "stats.ini missing for titleid "
                    + tid.sTitleIdHexNoPrefix;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdSet "
                + "Setting "
                + CStatsIni.ClusterIdSettingName
                + "="
                + uiClusterId
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);
            iniStats.SetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.DefaultLocaleSettingName, 
                uiClusterId.ToString());

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdSet complete");
        }

        public bool TitleWebClusterIdGet(CTitleId tid, ref uint uiClusterId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // this setting is still managed partially by legacy code,
            // so for now it remains in stats.ini

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiClusterId+")");

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // no stats ini, no setting
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet "
                    + "stats.ini not found for titleid "
                    + tid.sTitleIdHexNoPrefix
                    + ". Unable to get setting.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet complete");
                return false;
            }

            string sClusterId = iniStats.GetSetting(
                CStatsIni.TitleSectionName,
                CStatsIni.ClusterIdSettingName);

            if (sClusterId == null || sClusterId == String.Empty)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet "
                    + CStatsIni.ClusterIdSettingName
                    + " setting not found in stats.ini for titleid "
                    + tid.sTitleIdHexNoPrefix);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet complete");
                return false;
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet "
                + "Found setting of "
                + sClusterId
                + " for "
                + CStatsIni.ClusterIdSettingName
                + "in stats.ini for titleid "
                + tid.sTitleIdHexNoPrefix);

            bool bFound = false;
            try
            {
                uiClusterId = UInt32.Parse(sClusterId);
                bFound = true;
            }
            catch (Exception)
            {
                m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet "
                    + "Setting of "
                    + sClusterId
                    + " is not an integer. This setting will be ignored.");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleWebClusterIdGet complete");
            return bFound;
        }

        public SortedList TitleDescGetListByLocale(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale("
                + tid.sTitleIdHexNoPrefix + ")");

            // get the list of descriptions by languagae
            SortedList slByLang = TitleDescGetListByLang(tid);

            SortedList slByLocale = new SortedList();

            // iterate through the known locale types and get title description for that locale
            // according to the mapping defined by LocaleToLang below. If we don't have the
            // matching language description, we don't add it to the list.
            foreach (CLocale locale in CLocale.SupportedList())
            {
                ELanguageName langName = ELanguageName.english;
                if (LocaleToLang(locale, ref langName))
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale: "
                        + "Using "
                        + langName.ToString()
                        + " for locale "
                        + locale.ToString());
                    string sDesc;
                    if (slByLang.ContainsKey(langName))
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale: "
                            + "Using "
                            + langName.ToString()
                            + " description for locale "
                            + locale.ToString());
                        sDesc = (string)slByLang[langName];
                        slByLocale.Add(locale.ToString(), sDesc);
                    }
                    else
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale: "
                            + "No description available for language "
                            + langName.ToString());
                    }
                }
                else
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale: "
                        + "No language supported for locale "
                        + locale.ToString());
                }
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale: "
                + "Returning "
                + slByLocale.Count
                + " descriptions by locale");

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLocale complete");
            return slByLocale;
        }

        public static bool LocaleToLang(CLocale locale, ref ELanguageName langName)
        {
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            // get the first two chars of the locale, that's what tells us
            // which language the locale uses
            string sLang = locale.ToString().Substring(0, 2);

            if (sLang == "en")
            {
                langName = ELanguageName.english;
                return true;
            }
            if (sLang == "ja")
            {
                langName = ELanguageName.japanese;
                return true;
            }
            if (sLang == "de")
            {
                langName = ELanguageName.german;
                return true;
            }
            if (sLang == "fr")
            {
                langName = ELanguageName.french;
                return true;
            }
            if (sLang == "es")
            {
                langName = ELanguageName.spanish;
                return true;
            }
            if (sLang == "it")
            {
                langName = ELanguageName.italian;
                return true;
            }
            if (sLang == "ko")
            {
                langName = ELanguageName.korean;
                return true;
            }
            if (sLang == "zh")
            {
                langName = ELanguageName.chinese;
                return true;
            }
            if (sLang == "pt")
            {
                langName = ELanguageName.portuguese;
                return true;
            }

            return false;
        }

        public SortedList TitleDescGetListByLang(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang("
                + tid.sTitleIdHexNoPrefix + ")");

            SortedList sl = new SortedList();

            // iterate through the known language types and get title descriptions
            foreach (ELanguageName langName in Enum.GetValues((new ELanguageName()).GetType()))
            {
                // get the path and filename for this language
                string sPathAndFilename = TitleMessageXmlPathAndFileName(tid, langName);

                if (File.Exists(sPathAndFilename))
                {
                    // the file exists, try to extract the title description for this language
                    try
                    {
                        string sDesc = CMessageXml.ExtractMessage(sPathAndFilename, tid, langName);
                        if (sDesc != null)
                        {
                            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang: "
                                + "Found title description '"
                                + sDesc
                                + "' for language "
                                + langName.ToString());
                            sl.Add(langName, sDesc);
                        }
                        else
                        {
                            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang: "
                                + "No title description found in "
                                + sPathAndFilename
                                + ". This language will be ignored.");
                        }
                    }
                    catch (CRepositoryException e)
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang: "
                            + "Unable to extract title description from "
                            + sPathAndFilename
                            + ". This language will be ignored. Exception details: "
                            + e.Message);
                    }
                }
                else
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang: "
                        + "File "
                        + sPathAndFilename
                        + "does not exist. Unable to extract title description. This language will be ignored.");
                }
            }

            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang: "
                + sl.Count
                + " title descriptions found");

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleDescGetListByLang complete");
            return sl;
        }

        public void TitleLBDefaultDBSet(CTitleId tid, int iStatsDB)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + iStatsDB + ")");

            // save the setting to the title's xml file
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.DefaultSet(CTitleXml.StatsDBAttrName, iStatsDB.ToString());

            // We don't need to save the setting to any legacy files. Now that it is 
            // in the title xml, that's the value that will be used.

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBSet complete");
        }

        public bool TitleLBDefaultDBGet(CTitleId tid, ref int iStatsDB)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + iStatsDB + ")");

            // check first to see if the setting exists in the title xml
            CTitleXml titleXml = TitleXmlGet(tid);
            string sValue = null;
            if (!titleXml.DefaultGet(CTitleXml.StatsDBAttrName, ref sValue))
            {
                // setting does not exist in the title xml, see if it's in the legacy stats ini file
                if (TitleStatsIniExists(tid))
                {
                    // stats.ini exists, see if we can get the STATSDB setting
                    CIni iniStats = TitleStatsIniGet(tid);
                    sValue = iniStats.GetSetting(
                        CStatsIni.SettingsSectionName,
                        CStatsIni.StatsDBSettingName);
                }
            }

            bool bFound;
            if (sValue == null)
            {
                // we didn't find the setting
                bFound = false;
            }
            else
            {
                try
                {
                    iStatsDB = Int32.Parse(sValue);
                    bFound = true;
                }
                catch (Exception e)
                {
                    // we don't want a bad value in a file that could be modified
                    // by hand to cause a fatal error, so we'll treat this like
                    // the setting was not present, and simply log the error
                    string sErr = "Xbox.Tools.Framework.CRepository.TitleLBDefaultDBGet: "
                        + "Could not parse setting for title."
                        + tid.sTitleIdHexNoPrefix
                        + " as an integer. String value is "
                        + sValue
                        + " exception details: "
                        + e.Message;
                    m_log.LogFile(sErr);
                    bFound = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleLBDefaultDBDelete(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBDelete("
                + tid.sTitleIdHexNoPrefix + ")");

            // delete the setting from title xml
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.DefaultDelete(CTitleXml.StatsDBAttrName);

            // note that we don't delete from any legacy files, this method only 
            // deals with the title xml

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDefaultDBDelete complete");
        }

        public void TitleLBLimitsSet(
            CTitleId tid,
            uint uiMaxWrites,
            uint uiMaxReads)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiMaxWrites+ ", "
                + uiMaxReads+")");

            // Leaderboard limits are a feature of v3 stats.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            // save the settings
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBLimitsSet(
                tid, 
                uiMaxWrites,
                uiMaxReads);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsSet complete");
        }

        public bool TitleLBLimitsGet(
            CTitleId tid, 
            ref uint uiMaxWrites,
            ref uint uiMaxReads)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiMaxWrites+ ", "
                + uiMaxReads+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.LBLimitsGet(
                tid, 
                ref uiMaxWrites,
                ref uiMaxReads);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleLBLimitsDelete(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{xmlDoc})");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBLimitsDelete(tid);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBLimitsDelete complete");
        }

        public void TitleUnitConfigSet(
            CTitleId tid,
            int iUnitDatabase,
            double dDecayFactor,
            uint uiMaxAvailUnits,
            uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + iUnitDatabase+ ", "
                + dDecayFactor+ ", "
                + uiMaxAvailUnits+ ", "
                + uiSizeUnitCache+")");

            // can only set this if repository is in up to date format
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            // save the settings
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitConfigSet(
                iUnitDatabase,
                dDecayFactor,
                uiMaxAvailUnits,
                uiSizeUnitCache);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigSet complete");
        }

        public bool TitleUnitConfigGet(
            CTitleId tid, 
            ref int iUnitDatabase,
            ref double dDecayFactor,
            ref uint uiMaxAvailUnits,
            ref uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + iUnitDatabase+ ", "
                + dDecayFactor+ ", "
                + uiMaxAvailUnits+ ", "
                + uiSizeUnitCache+ ")");

            bool bFound = false;

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bFound = titleXml.UnitConfigGet(
                    ref iUnitDatabase,
                    ref dDecayFactor,
                    ref uiMaxAvailUnits,
                    ref uiSizeUnitCache);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet complete, returning: "
                    + bFound);
                return bFound;
            }

            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet "
                    + "Getting leaderboard list from stats.xml");

                double dDecayFactorInXsc;
                if (!xsc.UnitDecayFactorGet(out dDecayFactorInXsc))
                {
                    m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet complete, returning: false");
                    return false;
                }

                // all that's in the old xsc file is the decay factor, so use the
                // title's default stats server, and default values for uiMaxAvailUnits
                // and uiSizeUnitCache.
                if (!TitleLBDefaultDBGet(tid, ref iUnitDatabase))
                {
                    // this should be in stats.ini, so just return false.
                    m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet complete, returning: false");
                    return false;
                }

                dDecayFactor = dDecayFactorInXsc;
                uiMaxAvailUnits = c_uiMaxAvailUnitsDefault;
                uiSizeUnitCache = c_uiSizeUnitCacheDefault;

                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet complete, returning: true");
                return true;
            }


            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitConfigGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleUnitDeleteAll(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDeleteAll("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitDeleteAll();

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDeleteAll complete");
        }

        public void TitleCompPartitionSet(
            CTitleId tid,
            uint uiPartitionId,
            int iStatsDB)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (uiPartitionId > 3)
            {
                throw new ArgumentOutOfRangeException("uiPartitionId");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiPartitionId + ", "
                + iStatsDB +")");

            // can only set this if repository is in up to date format
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            // save the settings
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompPartitionSet(
                uiPartitionId,
                iStatsDB);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionSet complete");
        }

        public bool TitleCompPartitionGet(
            CTitleId tid,
            uint uiPartitionId,
            ref int iStatsDB)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (uiPartitionId > 3)
            {
                throw new ArgumentOutOfRangeException("uiPartitionId");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiPartitionId + ", "
                + iStatsDB + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.CompPartitionGet(
                uiPartitionId,
                ref iStatsDB);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleCompPartitionDelete(
            CTitleId tid,
            uint uiPartitionId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (uiPartitionId > 3)
            {
                throw new ArgumentOutOfRangeException("uiPartitionId");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiPartitionId +")");

            // can only set this if repository is in up to date format
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            // save the settings
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompPartitionDelete(
                uiPartitionId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompPartitionDelete complete");
        }

        public uint[] TitleLBGetList(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            uint[] rgui;
            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // since there is stats information in title xml, any leaderboard info in 
                // stats.xml or stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList "
                    + "Getting leaderboard list from title xml");
                rgui = titleXml.LBGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList complete");
                return rgui;
            }

            // if we get here, then there was no stats information in the title xml

            // see if there's a stats.xml in the config directory
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we have an xsc file, return the list of leaderboards from 
                // the xsc. anything in stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList "
                    + "Getting leaderboard list from stats.xml");
                rgui = xsc.LBGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList complete");
                return rgui;
            }

            // there were no leaderboards in the title.xml (or no title xml)
            // there was no stats.xml file, so our last resort for leaderboard
            // information is stats.ini
            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats == null)
            {
                // no stats.ini, no leaderboards
                rgui = new uint[0];
            }
            else
            {
                // we have a stats ini, get the LEADERBOARDS section and 
                // add each key value to the array.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList "
                    + "Getting leaderboard list from stats.ini");
                SortedList slLBs = iniStats.GetSection(CStatsIni.LeaderboardsSectionName);
                if (slLBs == null)
                {
                    // no leaderboards section, no leaderboards
                    rgui = new uint[0];
                }
                else
                {
                    ArrayList al = new ArrayList();
                    foreach (DictionaryEntry de in slLBs)
                    {
                        uint ui;
                        try
                        {
                            ui = UInt32.Parse((string)de.Key);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGetList: "
                                + "Could not parse leaderboard number "
                                + de.Key
                                + " in stats.ini as an integer. This leaderboard will be ignored. "
                                + "Exception details: "
                                + e.Message;
                            m_log.LogFile(sErr);
                        }
                    }
                    // Sort the array list. the sortedlist from the CIni was sorted
                    // in alphabetical order, so "10" comes before "2". We want 
                    // numerical order.
                    al.Sort();
                    rgui = new uint[al.Count];
                    al.CopyTo(rgui);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGetList complete");
            return rgui;
        }

        public void TitleLBSet(
            CTitleId tid,
            uint uiLBNum,
            int iStatsDatabase,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            uint uiMaxRatingCount,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds,
            bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // We can only add or update a leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + iStatsDatabase+ ", "
                + riLBResetInterval+ ", "
                + uiAttachmentCount+ ", "
                + uiMaxAttachmentSize+ ", "
                + uiDecayDays+ ", "
                + uiMaxRatingCount+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine + ","
                + uiExpirationSeconds + ", "
                + bDontList +")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBSet(
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBSet complete");
        }

        public bool TitleLBGet(
            CTitleId tid,
            uint uiLBNum, 
            ref int iStatsDatabase,
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + iStatsDatabase+ ", "
                + riLBResetInterval+ ", "
                + uiAttachmentCount+ ", "
                + uiMaxAttachmentSize+ ", "
                + uiDecayDays+ ", "
                + uiMaxRatingCount+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine+ ", "
                + uiExpirationSeconds+ ", "
                + bDontList+ ")");

            bool bFound = false;

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                uint[] rgui = titleXml.LBGetList();
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bFound = TitleLBGetV3(
                    titleXml,
                    uiLBNum, 
                    ref iStatsDatabase,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bFound = TitleLBGetV2(
                    tid,
                    xsc,
                    uiLBNum,
                    ref iStatsDatabase,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // last chance is the old stats.ini file
            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats != null)
            {
                // found a stats ini, see if the leaderboard is in there
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Note: Title is using version 1 stats repository format.");
                bFound = TitleLBGetV1(
                    tid,
                    iniStats,
                    uiLBNum,
                    ref iStatsDatabase,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);

                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // didn't find it in any of the three possible places so just return false
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                + "Note: Title has no stats information in the repository.");
            bFound = false;
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                + bFound);
            return bFound;
        }

        private bool TitleLBGetV3(
            CTitleXml titleXml,
            uint uiLBNum, 
            ref int iStatsDatabase,
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            return titleXml.LBGet(
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
        }

        private bool TitleLBGetV2(
            CTitleId tid,
            CXsc xsc,
            uint uiLBNum, 
            ref int iStatsDatabase,
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            // if we find any info on the leaderboard, return true
            bool bFound = false;

            bFound = xsc.LBConfigGet(
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig);

            if (bFound)
            {
                // the xsc doesn't have a stats db setting, so use the title's default
                TitleLBDefaultDBGet(tid, ref iStatsDatabase);

                ServiceDefaultWebCacheSettingsGet(
                    out uiEntriesPerCacheLine,
                    out uiExpirationSeconds);

                bDontList = false;
            }

            return bFound;
        }

        private bool TitleLBGetV1(
            CTitleId tid,
            CIni iniStats,
            uint uiLBNum,
            ref int iStatsDatabase,
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            // if we find any info on the leaderboard, return true
            bool bFound = false;

            // the old stats ini file only contains reset type
            string sValue = iniStats.GetSetting(CStatsIni.LeaderboardsSectionName, uiLBNum.ToString());
            if (sValue != null)
            {
                // leaderboard exists
                try
                {
                    riLBResetInterval = (ELBReset)Int32.Parse(sValue);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                        + "Could not parse reset type value for leaderboard ."
                        + uiLBNum
                        + " of "
                        + sValue
                        + " from stats.ini. Exception details: "
                        + e.Message);
                }
            }

            if (bFound)
            {
                // use the title's default stats db
                TitleLBDefaultDBGet(tid, ref iStatsDatabase);

                ServiceDefaultWebCacheSettingsGet(
                    out uiEntriesPerCacheLine,
                    out uiExpirationSeconds);

                // the rest of these are defaults
                uiAttachmentCount = 0;
                uiMaxAttachmentSize = 0;
                uiDecayDays = 0;
                uiMaxRatingCount = 0;
                bArbitrationRequired = false;
                bIsTeam = false;
                eloConfig = null;
                bDontList = false;
            }

            return bFound;
        }

        public void TitleLBDelete(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBDelete(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDelete complete");
        }


        public uint[] TitleUnitGetList(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            uint[] rgui;
            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // since there is stats information in title xml, any leaderboard info in 
                // stats.xml or stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList "
                    + "Getting unit leaderboard list from title xml");
                rgui = titleXml.UnitGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList complete");
                return rgui;
            }

            // if we get here, then there was no stats information in the title xml

            // see if there's a stats.xml in the config directory
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we have an xsc file, return the list of unit leaderboards from 
                // the xsc. anything in stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList "
                    + "Getting leaderboard list from stats.xml");
                rgui = xsc.UnitGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList complete");
                return rgui;
            }

            // if there's no title xml and no xsc, there are no unit leaderboards...
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList "
                + "Title is using stats.ini for leaderboard info - no unit leaderboards defined");
            rgui = new uint[0];
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGetList complete");
            return rgui;
        }

        public void TitleUnitSet(
            CTitleId tid,
            uint uiLBNum,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds,
            bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // We can only add or update a unit leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine + ","
                + uiExpirationSeconds + ", "
                + bDontList +")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitSet(
                uiLBNum,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitSet complete");
        }

        public bool TitleUnitGet(
            CTitleId tid,
            uint uiLBNum, 
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine+ ", "
                + uiExpirationSeconds+ ", "
                + bDontList+ ")");

            bool bFound = false;

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                uint[] rgui = titleXml.LBGetList();
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bFound = TitleUnitGetV3(
                    titleXml,
                    uiLBNum, 
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bFound = TitleUnitGetV2(
                    tid,
                    xsc,
                    uiLBNum,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // last chance is the old stats.ini file
            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats != null)
            {
                // found a stats ini, see if the leaderboard is in there
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet: "
                    + "Note: Title is using version 1 stats repository format.");

                // units were not supported by stats.ini, so just return false.
                bFound = false;
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // didn't find it in any of the three possible places so just return false
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet: "
                + "Note: Title has no stats information in the repository.");
            bFound = false;
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitGet complete, returning: "
                + bFound);
            return bFound;
        }

        private bool TitleUnitGetV3(
            CTitleXml titleXml,
            uint uiLBNum, 
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            return titleXml.UnitGet(
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
        }

        private bool TitleUnitGetV2(
            CTitleId tid,
            CXsc xsc,
            uint uiLBNum, 
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            // if we find any info on the leaderboard, return true
            bool bFound = false;

            bFound = xsc.UnitConfigGet(
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig);

            if (bFound)
            {
                ServiceDefaultWebCacheSettingsGet(
                    out uiEntriesPerCacheLine,
                    out uiExpirationSeconds);

                bDontList = false;
            }

            return bFound;
        }

        public void TitleUnitDelete(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a unit leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitDelete(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDelete complete");
        }

        public uint[] TitleCompGetList(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            uint[] rgui;
            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // since there is stats information in title xml, any leaderboard info in 
                // stats.xml or stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList "
                    + "Getting template list from title xml");
                rgui = titleXml.CompGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList complete");
                return rgui;
            }

            // if we get here, then there was no stats information in the title xml

            // see if there's a stats.xml in the config directory
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we have an xsc file, return the list of leaderboards from 
                // the xsc. anything in stats.ini is ignored.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList "
                    + "Getting template list from stats.xml");
                rgui = xsc.CompGetList();
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList complete");
                return rgui;
            }

            // stats.ini does not contain any competition template info...
            rgui = new uint[0];
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompGetList complete");
            return rgui;
        }

        public void TitleCompSet(
            CTitleId tid,
            uint uiLBNum,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds,
            bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            // We can only add or update a leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + riLBResetInterval+ ", "
                + uiAttachmentCount+ ", "
                + uiMaxAttachmentSize+ ", "
                + uiDecayDays+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine + ","
                + uiExpirationSeconds + ", "
                + bDontList +")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompSet(
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBSet complete");
        }

        public bool TitleCompGet(
            CTitleId tid,
            uint uiLBNum, 
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + riLBResetInterval+ ", "
                + uiAttachmentCount+ ", "
                + uiMaxAttachmentSize+ ", "
                + uiDecayDays+ ", "
                + bArbitrationRequired+ ", "
                + bIsTeam+ ", "
                + (eloConfig == null ? "null" : eloConfig.ToStatsDBString())+", "
                + uiEntriesPerCacheLine+ ", "
                + uiExpirationSeconds+ ", "
                + bDontList+ ")");

            bool bFound = false;

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                uint[] rgui = titleXml.LBGetList();
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bFound = TitleCompGetV3(
                    titleXml,
                    uiLBNum, 
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authoritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bFound = TitleCompGetV2(
                    tid,
                    xsc,
                    uiLBNum,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                    + bFound);
                return bFound;
            }

            // stats.ini doesn't have any template info
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBGet: "
                + "Note: Title has no stats information in the repository.");
            bFound = false;
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBGet complete, returning: "
                + bFound);
            return bFound;
        }

        private bool TitleCompGetV3(
            CTitleXml titleXml,
            uint uiLBNum, 
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            return titleXml.CompGet(
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
        }

        private bool TitleCompGetV2(
            CTitleId tid,
            CXsc xsc,
            uint uiLBNum, 
            ref ELBReset riLBResetInterval,
            ref uint uiAttachmentCount,
            ref uint uiMaxAttachmentSize,
            ref uint uiDecayDays,
            ref bool bArbitrationRequired,
            ref bool bIsTeam,
            ref CELOConfig eloConfig,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bDontList)
        {
            // if we find any info on the leaderboard, return true
            bool bFound = false;

            bFound = xsc.CompConfigGet(
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig);

            if (bFound)
            {
                ServiceDefaultWebCacheSettingsGet(
                    out uiEntriesPerCacheLine,
                    out uiExpirationSeconds);

                bDontList = false;
            }

            return bFound;
        }

        public void TitleCompDelete(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a template definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompDelete(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDelete complete");
        }

        /*
        public bool TitleLBHasWebInfo(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBHasWebInfo("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bHasWebInfo = titleXml.LBHasWebInfo(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBHasWebInfo complete, returning: "
                + bHasWebInfo);
            return bHasWebInfo;
        }
        */

        public void TitleLBDescSet(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sDesc == null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBDescSet(
                uiLBNum,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescSet complete");
        }

        public void TitleUnitDescSet(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sDesc == null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a leaderboard definition if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitDescSet(
                uiLBNum,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescSet complete");
        }

        public void TitleCompDescSet(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sDesc == null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a competition tempate description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompDescSet(
                uiLBNum,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescSet complete");
        }

        public SortedList TitleLBDescGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.LBDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.LBDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList complete");
                return sl;
            }

            // the only stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList: "
                + "Note: Title does not have any leaderboard description information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescGetList complete");
            return new SortedList();
        }

        public SortedList TitleUnitDescGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.UnitDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.UnitDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList complete");
                return sl;
            }

            // stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList: "
                + "Note: Title does not have any unit leaderboard description information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescGetList complete");
            return new SortedList();
        }

        public SortedList TitleCompDescGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.CompDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.CompDescGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList complete");
                return sl;
            }

            // stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList: "
                + "Note: Title does not have any competition template description information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescGetList complete");
            return new SortedList();
        }

        public void TitleLBDescDelete(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + locale + ")");

            // We can only remove a leaderboard description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBDescDelete(uiLBNum, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescDelete complete");
        }

        public void TitleUnitDescDelete(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + locale + ")");

            // We can only remove a unit leaderboard description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitDescDelete(uiLBNum, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescDelete complete");
        }

        public void TitleCompDescDelete(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + locale + ")");

            // We can only remove a competition template description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompDescDelete(uiLBNum, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescDelete complete");
        }

        public void TitleLBDescDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBDescDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBDescDelete complete");
        }

        public void TitleUnitDescDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove unit leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitDescDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitDescDeleteAll complete");
        }

        public void TitleCompDescDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove competition template descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompDescDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompDescDeleteAll complete");
        }

        public void TitleLBAttrSet(
            CTitleId tid,
            uint uiLBNum,
            uint uiId,
            bool bIsPuid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + uiId + ", "
                + bIsPuid+ ")");

            // We can only add or update a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBAttrSet(
                uiLBNum,
                uiId,
                bIsPuid);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrSet complete");
        }

        public void TitleUnitAttrSet(
            CTitleId tid,
            uint uiLBNum,
            uint uiId,
            bool bIsPuid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + uiId + ", "
                + bIsPuid+ ")");

            // We can only add or update a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitAttrSet(
                uiLBNum,
                uiId,
                bIsPuid);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrSet complete");
        }

        public void TitleCompAttrSet(
            CTitleId tid,
            uint uiLBNum,
            uint uiId,
            bool bIsPuid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + uiId + ", "
                + bIsPuid+ ")");

            // We can only add or update a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompAttrSet(
                uiLBNum,
                uiId,
                bIsPuid);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrSet complete");
        }

        public SortedList TitleLBAttrGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.LBAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.LBAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList complete");
                return sl;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList: "
                + "Note: Title does not have any leaderboard attribute information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrGetList complete");
            return new SortedList();
        }

        public SortedList TitleUnitAttrGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.UnitAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.UnitAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList complete");
                return sl;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList: "
                + "Note: Title does not have any leaderboard attribute information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrGetList complete");
            return new SortedList();
        }

        public SortedList TitleCompAttrGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.CompAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.CompAttrGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList complete");
                return sl;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList: "
                + "Note: Title does not have any leaderboard attribute information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrGetList complete");
            return new SortedList();
        }

        public void TitleLBAttrDelete(
            CTitleId tid,
            uint uiLBNum,
            uint uiId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBAttrDelete(uiLBNum, uiId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrDelete complete");
        }

        public void TitleUnitAttrDelete(
            CTitleId tid,
            uint uiLBNum,
            uint uiId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitAttrDelete(uiLBNum, uiId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrDelete complete");
        }

        public void TitleCompAttrDelete(
            CTitleId tid,
            uint uiLBNum,
            uint uiId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard attribute if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompAttrDelete(uiLBNum, uiId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrDelete complete");
        }

        public void TitleLBAttrDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBAttrDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBAttrDeleteAll complete");
        }

        public void TitleUnitAttrDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitAttrDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitAttrDeleteAll complete");
        }

        public void TitleCompAttrDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompAttrDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompAttrDeleteAll complete");
        }

        public void TitleLBValueSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            EWebValueReturnType returnType,
            string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sFormula == null)
            {
                throw new ArgumentNullException("sFormula");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName + ", "
                + returnType + ", "
                + sFormula+ ")");

            // We can only add or update a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBValueSet(
                uiLBNum,
                sName,
                returnType,
                sFormula);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueSet complete");
        }

        public void TitleUnitValueSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            EWebValueReturnType returnType,
            string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sFormula == null)
            {
                throw new ArgumentNullException("sFormula");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName + ", "
                + returnType + ", "
                + sFormula+ ")");

            // We can only add or update a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitValueSet(
                uiLBNum,
                sName,
                returnType,
                sFormula);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueSet complete");
        }

        public void TitleCompValueSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            EWebValueReturnType returnType,
            string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sFormula == null)
            {
                throw new ArgumentNullException("sFormula");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName + ", "
                + returnType + ", "
                + sFormula+ ")");

            // We can only add or update a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompValueSet(
                uiLBNum,
                sName,
                returnType,
                sFormula);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueSet complete");
        }

        public string[] TitleLBValueGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                string[] rgs = titleXml.LBValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList complete");
                return rgs;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                string[] rgs = xsc.LBValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList complete");
                return rgs;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList: "
                + "Note: Title does not have any leaderboard formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList complete");
            return new string[0];
        }

        public string[] TitleUnitValueGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                string[] rgs = titleXml.UnitValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList complete");
                return rgs;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                string[] rgs = xsc.UnitValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList complete");
                return rgs;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList: "
                + "Note: Title does not have any unit leaderboard formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGetList complete");
            return new string[0];
        }

        public string[] TitleCompValueGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                string[] rgs = titleXml.CompValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList complete");
                return rgs;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                string[] rgs = xsc.CompValueGetList(uiLBNum);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList complete");
                return rgs;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList: "
                + "Note: Title does not have any competition template formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGetList complete");
            return new string[0];
        }

        public bool TitleLBValueGet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bool bFound = titleXml.LBValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet complete");
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bool bFound = xsc.LBValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet complete");
                return bFound;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return false.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet: "
                + "Note: Title does not have any leaderboard formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueGet complete");
            return false;
        }

        public bool TitleUnitValueGet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bool bFound = titleXml.UnitValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet complete");
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bool bFound = xsc.UnitValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet complete");
                return bFound;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return false.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet: "
                + "Note: Title does not have any unit leaderboard formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueGet complete");
            return false;
        }

        public bool TitleCompValueGet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet: "
                    + "Note: Title is using version 3 stats repository format.");
                bool bFound = titleXml.CompValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet complete");
                return bFound;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet: "
                    + "Note: Title is using version 2 stats repository format.");
                bool bFound = xsc.CompValueGet(uiLBNum, sName, ref returnType, ref sFormula);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet complete");
                return bFound;
            }

            // the stats.ini file doesn't contain any web leaderboard info,
            // so if we get here, just return false.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet: "
                + "Note: Title does not have any leaderboard formatted value information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueGet complete");
            return false;
        }

        public void TitleLBValueDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBValueDelete(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDelete complete");
        }

        public void TitleUnitValueDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitValueDelete(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDelete complete");
        }

        public void TitleCompValueDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove a leaderboard value if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompValueDelete(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDelete complete");
        }

        public void TitleLBValueDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBValueDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDeleteAll complete");
        }

        public void TitleUnitValueDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitValueDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDeleteAll complete");
        }

        public void TitleCompValueDeleteAll(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompValueDeleteAll(uiLBNum);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDeleteAll complete");
        }

        public void TitleLBValueDescSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sDesc== null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LBValueDescSet(
                uiLBNum,
                sName,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescSet complete");
        }

        public void TitleUnitValueDescSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sDesc== null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.UnitValueDescSet(
                uiLBNum,
                sName,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescSet complete");
        }

        public void TitleCompValueDescSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale,
            string sDesc)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (sDesc== null)
            {
                throw new ArgumentNullException("sDesc");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ", "
                + sName+ ", "
                + locale.ToString() + ", "
                + sDesc + ")");

            // We can only add or update a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.CompValueDescSet(
                uiLBNum,
                sName,
                locale,
                sDesc);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescSet complete");
        }

        public SortedList TitleLBValueDescGetList(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + sName + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.LBValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.LBValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList complete");
                return sl;
            }

            // the only stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList: "
                + "Note: Title does not have any web information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescGetList complete");
            return new SortedList();
        }

        public SortedList TitleUnitValueDescGetList(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + sName + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.UnitValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.UnitValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList complete");
                return sl;
            }

            // the only stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList: "
                + "Note: Title does not have any web information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescGetList complete");
            return new SortedList();
        }

        public SortedList TitleCompValueDescGetList(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList("
                + tid.sTitleIdHexNoPrefix + ", "
                + sName + ", "
                + uiLBNum+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            if (titleXml.ContainsStatsInfo())
            {
                // there's a title xml, and it's the authoritative source of 
                // stats info
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList: "
                    + "Note: Title is using version 3 stats repository format.");
                SortedList sl = titleXml.CompValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList complete");
                return sl;
            }

            // there was either no title xml, or it contained no stats info.
            // next, we see if there's a stats.xml with leaderboard data
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we got an xsc, so use it as our authritative reference
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList: "
                    + "Note: Title is using version 2 stats repository format.");
                SortedList sl = xsc.CompValueDescGetList(uiLBNum, sName);
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList complete");
                return sl;
            }

            // the only stats.ini file doesn't contain any leaderboard description info,
            // so if we get here, just return an empty list.
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList: "
                + "Note: Title does not have any web information in repository");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescGetList complete");
            return new SortedList();
        }

        public void TitleLBValueDescDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + sName + ", "
                + locale.ToString()+ ")");

            // We can only remove a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBValueDescDelete(uiLBNum, sName, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescDelete complete");
        }

        public void TitleUnitValueDescDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + sName + ", "
                + locale.ToString()+ ")");

            // We can only remove a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitValueDescDelete(uiLBNum, sName, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescDelete complete");
        }

        public void TitleCompValueDescDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }
            if (locale == null)
            {
                throw new ArgumentNullException("locale");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescDelete("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum + ", "
                + sName + ", "
                + locale.ToString()+ ")");

            // We can only remove a formatted value description if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompValueDescDelete(uiLBNum, sName, locale);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescDelete complete");
        }

        public void TitleLBValueDescDeleteAll(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.LBValueDescDeleteAll(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLBValueDescDeleteAll complete");
        }

        public void TitleUnitValueDescDeleteAll(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.UnitValueDescDeleteAll(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleUnitValueDescDeleteAll complete");
        }

        public void TitleCompValueDescDeleteAll(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sName == null)
            {
                throw new ArgumentNullException("sName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescDeleteAll("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiLBNum+ ")");

            // We can only remove leaderboard descriptions if the repository
            // is storing stats information for this title in it's latest format.
            // See if we need to upgrade the stats configuration for this title
            // in the repository.
            if (TitleStatsUpgradeRequired(tid))
            {
                TitleStatsUpgrade(tid);
            }

            CTitleXml titleXml = TitleXmlGet(tid);

            titleXml.CompValueDescDeleteAll(uiLBNum, sName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleCompValueDescDeleteAll complete");
        }

        public bool TitleStatsUpgradeRequired(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);

            if (titleXml.ContainsStatsInfo())
            {
                // the title xml already has stats info, so we don't need to
                // upgrade
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired complete, returning false");
                return false;
            }

            // an upgrade is only required if there's some legacy information there
            CXsc xsc = TitleStatsXmlGet(tid);
            if (xsc != null)
            {
                // we have data to upgrade, so return true
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired: "
                    + "stats.xml found, upgrade required.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired complete, returning true");
                return true;
            }

            CIni iniStats = TitleStatsIniGet(tid);
            if (iniStats != null)
            {
                // only return true if there are LEADERBOARDS specified
                SortedList sl = iniStats.GetSection(CStatsIni.LeaderboardsSectionName);
                if (sl == null || sl.Count == 0)
                {
                    // nothing to upgrade, since there are no leaderboards defined
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired: "
                        + "stats.ini contains no leaderboards, nothing to upgrade.");
                    m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired complete, returning false");
                    return false;
                }
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired: "
                    + "stats.ini contains leaderboards, upgrade required.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired complete, returning true");
                return true;
            }
            
            // no data to upgrade, return false
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired: "
                + "No stats.xml or stats.ini files found, nothing to upgrade.");
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgradeRequired complete, returning false");
            return false;
        }

        public void TitleStatsUpgrade(CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade("
                + tid.sTitleIdHexNoPrefix + ",");

            if (!TitleStatsUpgradeRequired(tid))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " No stats upgrade is required.");
                m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade complete");
                return;
            }

            try
            {
                // figure out what kind of upgrade is required...
                CXsc xsc = TitleStatsXmlGet(tid);
                if (xsc != null)
                {
                    // we are going to upgrade to the current format from stats.xml
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                        + " Upgrading from existing stats.xml.");
                    TitleStatsUpgradeFromXsc(tid, xsc);
                    m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade complete");
                    return;
                }


                CIni iniStats = TitleStatsIniGet(tid);
                if (iniStats != null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                        + " Upgrading from existing stats.ini.");
                    TitleStatsUpgradeFromIni(tid, iniStats);
                    m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade complete");
                    return;
                }
            }
            catch (Exception)
            {
                // if an exception was thrown during the upgrade, we want
                // to flush the partially upgraded title xml, if any, then
                // rethrow
                if (m_htTitleXmls.ContainsKey(tid.uiTitleId))
                {
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade: "
                        + "Exception thrown during title upgrade process, "
                        + "discarding partially upgraded title xml data.");
                    m_htTitleXmls.Remove(tid.uiTitleId);
                }
                throw;
            }

            // shouldn't get here!
            string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade: "
                + "CRepository.TitleStatsUpgradeRequired returned true but no stats.xml or stats.ini could be found "
                + "for titleid "
                + tid.sTitleIdHexNoPrefix;
            m_log.LogFile(sErr);
            throw new CRepositoryException(sErr);
        }

        private void TitleStatsUpgradeFromXsc(CTitleId tid, CXsc xsc)
        {
            // get the title xml we're going to add leaderboard information to
            CTitleXml titleXml = TitleXmlGet(tid);

            // see if we have a default stats db setting we can use,
            // otherwise default to zero...
            int iStatsDB = 0;
            TitleLBDefaultDBGet(tid, ref iStatsDB);

            uint uiEntriesPerCacheLine;
            uint uiExpirationSeconds;
            ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds);

            // copy leaderboards
            uint[] rguiLBsInXsc = xsc.LBGetList();
            foreach (uint uiLBNum in rguiLBsInXsc)
            {
                TitleStatsUpgradeLBFromXsc(
                    tid, 
                    titleXml,
                    xsc, 
                    uiLBNum, 
                    iStatsDB,
                    uiEntriesPerCacheLine, 
                    uiExpirationSeconds);
            }

            // copy unit leaderboards 
            uint[] rguiUnitsInXsc = xsc.UnitGetList();

            // if there's one or more unit leaderboards,
            // set the unit configuration.
            if (rguiUnitsInXsc.Length > 0)
            {
                double dDecayFactor;
                if (!xsc.UnitDecayFactorGet(out dDecayFactor))
                {
                    // can't upgrade without this, throw
                    string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade: "
                    + "Unable to get unit leaderboard decay factor from xsc file, but unit leaderboards "
                    + "are present.";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                // use the default values for these
                uint uiMaxAvailUnits = c_uiMaxAvailUnitsDefault;
                uint uiSizeUnitCache = c_uiSizeUnitCacheDefault;

                titleXml.UnitConfigSet(
                    iStatsDB,
                    dDecayFactor,
                    uiMaxAvailUnits,
                    uiSizeUnitCache);
            }

            foreach (uint uiLBNum in rguiUnitsInXsc)
            {
                TitleStatsUpgradeUnitFromXsc(
                    tid, 
                    titleXml,
                    xsc, 
                    uiLBNum, 
                    uiEntriesPerCacheLine, 
                    uiExpirationSeconds);
            }

            // copy competition templates
            uint[] rguiCompsInXsc = xsc.CompGetList();
            foreach (uint uiLBNum in rguiCompsInXsc)
            {
                TitleStatsUpgradeCompFromXsc(
                    tid, 
                    titleXml,
                    xsc, 
                    uiLBNum, 
                    uiEntriesPerCacheLine, 
                    uiExpirationSeconds);
            }

            // if there were any competition templates in
            // the xsc, then set competition partition 0
            // on the default stats database - that's what
            // StatsSync has been doing for this title, so 
            // it should match what's in the stats db.
            titleXml.CompPartitionSet(
                0u,
                iStatsDB);

            return;
        }

        private void TitleStatsUpgradeLBFromXsc(
            CTitleId tid, 
            CTitleXml titleXml,
            CXsc xsc, 
            uint uiLBNum,
            int iStatsDB,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds)
        {
            // defaults for any parameters not provided in the xsc
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            bool bDontList = false;

            // get the information from the xsc and then save it into titleXml
            if (xsc.LBConfigGet(
                uiLBNum, 
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Upgrading leaderboard "
                    + uiLBNum);

                titleXml.LBSet(
                    uiLBNum, 
                    iStatsDB, 
                    lbReset, 
                    uiAttachCount, 
                    uiMaxAttachSize, 
                    uiDecayDays, 
                    uiMaxRatingCount, 
                    bRequireArbitration, 
                    bIsTeam, 
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);

                // copy leaderboard descriptions
                SortedList slDesc = xsc.LBDescGetList(uiLBNum);
                foreach (DictionaryEntry de in slDesc)
                {
                    string sLocale = (string)de.Key;
                    string sDesc = (string)de.Value;
                    titleXml.LBDescSet(uiLBNum, new CLocale(sLocale), sDesc);
                }

                // copy attributes
                SortedList slAttr = xsc.LBAttrGetList(uiLBNum);
                foreach (DictionaryEntry de in slAttr)
                {
                    uint uiId = (uint)de.Key;
                    bool bIsPuid = (bool)de.Value;
                    titleXml.LBAttrSet(uiLBNum, uiId, bIsPuid);
                }

                // copy formatted values
                string[] rgs = xsc.LBValueGetList(uiLBNum);
                foreach(string sName in rgs)
                {
                    EWebValueReturnType returnType = EWebValueReturnType.String;
                    string sFormula = null;
                    if (xsc.LBValueGet(uiLBNum, sName, ref returnType, ref sFormula))
                    {
                        titleXml.LBValueSet(uiLBNum, sName, returnType, sFormula);
                    }
                    else
                    {
                        // strangeness while upgrading is dangerous.
                        // throw so we don't commit these changes and get the
                        // users attention
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                            + " Unable to upgrade leaderboard value name "
                            + sName
                            + " on leaderboard number "
                            + uiLBNum;
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    // now copy the descriptions for this formatted value
                    SortedList slValueDescs = xsc.LBValueDescGetList(uiLBNum, sName);
                    foreach (DictionaryEntry de in slValueDescs)
                    {
                        CLocale locale = new CLocale((string)de.Key);
                        string sDesc = (string)de.Value;
                        titleXml.LBValueDescSet(uiLBNum, sName, locale, sDesc);
                    }
                }
            }
            else
            {
                // strangeness while upgrading is dangerous.
                // throw so we don't commit these changes and get the
                // users attention
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Unable to upgrade leaderboard number "
                    + uiLBNum;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
        }

        private void TitleStatsUpgradeUnitFromXsc(
            CTitleId tid, 
            CTitleXml titleXml,
            CXsc xsc, 
            uint uiLBNum,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds)
        {
            // defaults for any parameters not provided in the xsc
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            bool bDontList = false;

            // get the information from the xsc and then save it into titleXml
            if (xsc.UnitConfigGet(
                uiLBNum, 
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Upgrading unit leaderboard "
                    + uiLBNum);

                titleXml.UnitSet(
                    uiLBNum, 
                    bRequireArbitration, 
                    bIsTeam, 
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);

                // copy leaderboard descriptions
                SortedList slDesc = xsc.UnitDescGetList(uiLBNum);
                foreach (DictionaryEntry de in slDesc)
                {
                    string sLocale = (string)de.Key;
                    string sDesc = (string)de.Value;
                    titleXml.UnitDescSet(uiLBNum, new CLocale(sLocale), sDesc);
                }

                // copy attributes
                SortedList slAttr = xsc.UnitAttrGetList(uiLBNum);
                foreach (DictionaryEntry de in slAttr)
                {
                    uint uiId = (uint)de.Key;
                    bool bIsPuid = (bool)de.Value;
                    titleXml.UnitAttrSet(uiLBNum, uiId, bIsPuid);
                }

                // copy formatted values
                string[] rgs = xsc.UnitValueGetList(uiLBNum);
                foreach(string sName in rgs)
                {
                    EWebValueReturnType returnType = EWebValueReturnType.String;
                    string sFormula = null;
                    if (xsc.UnitValueGet(uiLBNum, sName, ref returnType, ref sFormula))
                    {
                        titleXml.UnitValueSet(uiLBNum, sName, returnType, sFormula);
                    }
                    else
                    {
                        // strangeness while upgrading is dangerous.
                        // throw so we don't commit these changes and get the
                        // users attention
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                            + " Unable to upgrade leaderboard value name "
                            + sName
                            + " on leaderboard number "
                            + uiLBNum;
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    // now copy the descriptions for this formatted value
                    SortedList slValueDescs = xsc.UnitValueDescGetList(uiLBNum, sName);
                    foreach (DictionaryEntry de in slValueDescs)
                    {
                        CLocale locale = new CLocale((string)de.Key);
                        string sDesc = (string)de.Value;
                        titleXml.UnitValueDescSet(uiLBNum, sName, locale, sDesc);
                    }
                }
            }
            else
            {
                // strangeness while upgrading is dangerous.
                // throw so we don't commit these changes and get the
                // users attention
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Unable to upgrade leaderboard number "
                    + uiLBNum;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
        }

        private void TitleStatsUpgradeCompFromXsc(
            CTitleId tid, 
            CTitleXml titleXml,
            CXsc xsc, 
            uint uiLBNum,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds)
        {
            // defaults for any parameters not provided in the xsc
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            bool bDontList = false;

            // get the information from the xsc and then save it into titleXml
            if (xsc.CompConfigGet(
                uiLBNum, 
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Upgrading competition template "
                    + uiLBNum);

                titleXml.CompSet(
                    uiLBNum, 
                    lbReset, 
                    uiAttachCount, 
                    uiMaxAttachSize, 
                    uiDecayDays, 
                    bRequireArbitration, 
                    bIsTeam, 
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);

                // copy leaderboard descriptions
                SortedList slDesc = xsc.CompDescGetList(uiLBNum);
                foreach (DictionaryEntry de in slDesc)
                {
                    string sLocale = (string)de.Key;
                    string sDesc = (string)de.Value;
                    titleXml.CompDescSet(uiLBNum, new CLocale(sLocale), sDesc);
                }

                // copy attributes
                SortedList slAttr = xsc.CompAttrGetList(uiLBNum);
                foreach (DictionaryEntry de in slAttr)
                {
                    uint uiId = (uint)de.Key;
                    bool bIsPuid = (bool)de.Value;
                    titleXml.CompAttrSet(uiLBNum, uiId, bIsPuid);
                }

                // copy formatted values
                string[] rgs = xsc.CompValueGetList(uiLBNum);
                foreach(string sName in rgs)
                {
                    EWebValueReturnType returnType = EWebValueReturnType.String;
                    string sFormula = null;
                    if (xsc.CompValueGet(uiLBNum, sName, ref returnType, ref sFormula))
                    {
                        titleXml.CompValueSet(uiLBNum, sName, returnType, sFormula);
                    }
                    else
                    {
                        // strangeness while upgrading is dangerous.
                        // throw so we don't commit these changes and get the
                        // users attention
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                            + " Unable to upgrade leaderboard value name "
                            + sName
                            + " on competition template number "
                            + uiLBNum;
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    // now copy the descriptions for this formatted value
                    SortedList slValueDescs = xsc.CompValueDescGetList(uiLBNum, sName);
                    foreach (DictionaryEntry de in slValueDescs)
                    {
                        CLocale locale = new CLocale((string)de.Key);
                        string sDesc = (string)de.Value;
                        titleXml.CompValueDescSet(uiLBNum, sName, locale, sDesc);
                    }
                }
            }
            else
            {
                // strangeness while upgrading is dangerous.
                // throw so we don't commit these changes and get the
                // users attention
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Unable to upgrade competition template number "
                    + uiLBNum;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
        }

        private void TitleStatsUpgradeFromIni(CTitleId tid, CIni iniStats)
        {
            // get the title xml we're going to add leaderboard information to
            CTitleXml titleXml = TitleXmlGet(tid);

            // see if we have a default stats db setting we can use,
            // otherwise default to zero...
            int iStatsDB = 0;
            TitleLBDefaultDBGet(tid, ref iStatsDB);

            uint uiEntriesPerCacheLine;
            uint uiExpirationSeconds;
            ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds);

            // copy leaderboards
            SortedList sl = iniStats.GetSection(CStatsIni.LeaderboardsSectionName);
            if (sl == null)
            {
                // stats.ini is there, but doesn't contain any leaderboard
                // info, so just bail
                return;
            }
            foreach (DictionaryEntry de in sl)
            {
                // all we get from the ini is the leaderboard number 
                // and the reset type
                uint uiLBNum;
                try
                {
                    uiLBNum = UInt32.Parse((string)de.Key);
                }
                catch
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                        + " Error parsing leaderboard number of "
                        + de.Key
                        + " from stats.ini file. This leaderboard will be ignored.");
                    continue;
                }

                ELBReset lbReset;
                try
                {
                    lbReset = (ELBReset)UInt32.Parse((string)de.Value);
                }
                catch
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                        + " Error parsing reset type value of "
                        + de.Value
                        + " from stats.ini file for leaderboard number "
                        + de.Key
                        + ". This leaderboard will be ignored.");
                    continue;
                }

                // the rest of the settings are set to the defaults below
                uint uiAttachCount = 0;
                uint uiMaxAttachSize = 0;
                uint uiDecayDays = 0;
                uint uiMaxRatingCount = 0;
                bool bRequireArbitration = false;
                bool bIsTeam = false;
                CELOConfig eloConfig = null;
                bool bDontList = false;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsUpgrade:"
                    + " Upgrading leaderboard "
                    + uiLBNum);

                titleXml.LBSet(
                    uiLBNum, 
                    iStatsDB, 
                    lbReset, 
                    uiAttachCount, 
                    uiMaxAttachSize, 
                    uiDecayDays, 
                    uiMaxRatingCount, 
                    bRequireArbitration, 
                    bIsTeam, 
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);
            }

            // there were no unit leaderboards, competition templates, or
            // web information for version 1 (stats.ini) titles
            return;
        }

        public void TitleQueryPartitionSet(
            CTitleId tid,
            uint uiPartitionId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiPartitionId +")");

            // save the settings
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.QueryPartitionSet(
                uiPartitionId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionSet complete");
        }

        public bool TitleQueryPartitionGet(
            CTitleId tid,
            ref uint uiPartitionId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + uiPartitionId+ ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.QueryPartitionGet(
                ref uiPartitionId);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleQueryPartitionDelete(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionDelete("
                + tid.sTitleIdHexNoPrefix + ")");

            // save the setting
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.QueryPartitionDelete();

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryPartitionDelete complete");
        }

        public void TitleQueryConfigXmlSet(
            CTitleId tid,
            XmlDocument xmlDocQueryConfig,
            string sQueryTypeName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (xmlDocQueryConfig == null)
            {
                throw new ArgumentNullException("xmlDocQueryConfig");
            }
            if (sQueryTypeName == null)
            {
                throw new ArgumentNullException("sQueryTypeName");
            }

            // don't dump the config xml to the log, it has a tendency to be very large,
            // given that it's the contents of an entire file
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlSet("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{xmlDocQueryConfig}, "
                + sQueryTypeName+")");

            // make sure the query type is valid
            ArrayList alQueryTypes = new ArrayList(ServiceQueryTypeGetList());
            if (!alQueryTypes.Contains(sQueryTypeName))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlSet:"
                    + "Query type "
                    + sQueryTypeName
                    + " is not valid";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // save the settings in title xml
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.QueryConfigXmlSet(xmlDocQueryConfig, sQueryTypeName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlSet complete");
        }

        public bool TitleQueryConfigXmlGet(
            CTitleId tid,
            ref XmlDocument xmlDocQueryConfig,
            string sQueryTypeName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sQueryTypeName == null)
            {
                throw new ArgumentNullException("sQueryTypeName");
            }

            // don't dump the config xml to the log, it has a tendency to be very large,
            // given that it's the contents of an entire file
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlGet("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{xmlDocQueryConfig},"
                + sQueryTypeName+")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.QueryConfigXmlGet(ref xmlDocQueryConfig, sQueryTypeName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlGet complete, returning: "
                + bFound);
            return bFound;
        }

        public void TitleQueryConfigXmlDelete(
            CTitleId tid,
            string sQueryTypeName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sQueryTypeName == null)
            {
                throw new ArgumentNullException("sQueryTypeName");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlDelete("
                + tid.sTitleIdHexNoPrefix + ","
                + sQueryTypeName+")");

            // save the setting
            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.QueryConfigXmlDelete(sQueryTypeName);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleQueryConfigXmlDelete complete");
        }

        public bool TitleAlternateTitleIdGetList(
            CTitleId tid,
            ref uint [] aAlternateTitleIds)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.AlternateTitleIdsGetList(ref aAlternateTitleIds);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdGetList complete returning: "
                + bFound);

            return bFound;
        }

        public void TitleAlternateTitleIdSet(
            CTitleId tid,
            CTitleId tidAlt)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (tidAlt == null)
            {
                throw new ArgumentNullException("tidAlt");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdSet("
                + tid.sTitleIdHexNoPrefix + ", " + tidAlt.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.AlternateTitleIdSet(tidAlt);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdSet complete");
        }

        public void TitleAlternateTitleIdDelete(
            CTitleId tid,
            CTitleId tidAlt)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (tidAlt == null)
            {
                throw new ArgumentNullException("tidAlt");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdDelete("
                + tid.sTitleIdHexNoPrefix + ", " + tidAlt.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.AlternateTitleIdDelete(tidAlt);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdDelete complete");
        }

        public void TitleAlternateTitleIdDeleteAll(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdDeleteAll("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.AlternateTitleIdDeleteAll();
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleAlternateTitleIdDeleteAll complete");
        }

        public bool TitleLSPSiteGetList(
            CTitleId tid,
            ref CSite[] sites)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.LSPSiteGetList(ref sites);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteGetList complete returning: "
                + bFound);

            return bFound;
        }

        public void TitleLSPSiteSet(
            CTitleId tid,
            CSite site)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (site == null)
            {
                throw new ArgumentNullException("site");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteSet("
                + tid.sTitleIdHexNoPrefix + ", " + site.SiteId + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPSiteSet(site);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteSet complete");
        }

        public void TitleLSPSiteDelete(
            CTitleId tid,
            CSite site)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (site == null)
            {
                throw new ArgumentNullException("site");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteDelete("
                + tid.sTitleIdHexNoPrefix + ", " + site.SiteId + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPSiteDelete(site);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteDelete complete");
        }

        public void TitleLSPSiteDeleteAll(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteDeleteAll("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPSiteDeleteAll();
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPSiteDeleteAll complete");
        }

        public bool TitleLSPServiceGetList(
            CTitleId tid,
            ref CService [] services)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceGetList("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            bool bFound = titleXml.LSPServiceGetList(ref services);

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceGetList complete returning: "
                + bFound);

            return bFound;
        }

        public void TitleLSPServiceSet(
            CTitleId tid,
            CService service)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (service == null)
            {
                throw new ArgumentNullException("service");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceSet("
                + tid.sTitleIdHexNoPrefix + ", " + service.ServiceId + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPServiceSet(service);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceSet complete");
        }

        public void TitleLSPServiceDelete(
            CTitleId tid,
            CService service)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (service == null)
            {
                throw new ArgumentNullException("service");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceDelete("
                + tid.sTitleIdHexNoPrefix + ", " + service.ServiceId + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPServiceDelete(service);
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceDelete complete");
        }

        public void TitleLSPServiceDeleteAll(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceDeleteAll("
                + tid.sTitleIdHexNoPrefix + ")");

            CTitleXml titleXml = TitleXmlGet(tid);
            titleXml.LSPServiceDeleteAll();
        
            m_log.StackTrace("Xbox.Tools.Framework.CRepository.TitleLSPServiceDeleteAll complete");
        }



        private string TitlePath(CTitleId tid)
        {
            // a title's information is stored in the repository
            // at //root/<titleid> where the titleid is in hex
            // with no prefix
            return CPathUtil.AddPathTerminator(m_sd.ClientRoot)
                + tid.sTitleIdHexNoPrefix;
        }

        public static string TitleMessageXmlFilename(ELanguageName langName)
        {
            return "titles."+langName.ToString()+".xml";
        }


        private string TitleMessagePath(CTitleId tid)
        {
            // "message" xml files are stored in the \message directory
            // off the title's root
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + "message";
        }

        private string TitleMessageXmlPathAndFileName(
            CTitleId tid, 
            ELanguageName langName)
        {
            return CPathUtil.AddPathTerminator(TitleMessagePath(tid))
                + TitleMessageXmlFilename(langName);
        }

        private string TitleXmlName(CTitleId tid)
        {
            // The title's xml configuration file is named:
            // title_<titleid>.xml
            // where titlid is in hex notation with no 0x prefix
            return "title_" + tid.sTitleIdHexNoPrefix + ".xml";
        }

        private string TitleXmlPath(CTitleId tid)
        {
            // put it in the config directory, so it's not 
            // in the middle of all those offers...
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + "config";
        }

        private string TitleXmlPathAndFileName(CTitleId tid)
        {
            // the title's xml configuration file is located in the root of the
            // title's repository directory, and is named 
            // title_<titleid>.xml
            return CPathUtil.AddPathTerminator(TitleXmlPath(tid))
                + TitleXmlName(tid);
        }

        private bool TitleXmlExists(CTitleId tid)
        {
            return File.Exists(TitleXmlPathAndFileName(tid));
        }

        private void TitleXmlCreate(CTitleId tid)
        {
            // This creates and checks in a title's xml file that contains 
            // no settings. The title's repository directory must already exist,
            // and the title's xml file must NOT exist
            if (TitleXmlExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleXmlCreate: "
                    + "Xml configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " already exists in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleXmlCreate: "
                    + "TitleId "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in the repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            XmlDocument xmlDoc = CTitleXml.Create(tid, m_log);

            string sTitleXmlPathAndFileName = TitleXmlPathAndFileName(tid);
            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleXmlCreate: "
                    + "Saving Xml configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " to "
                    + sTitleXmlPathAndFileName);

            if (!Directory.Exists(TitleXmlPath(tid)))
            {
                Directory.CreateDirectory(TitleXmlPath(tid));
            }

            FileStream fileStream = new FileStream(
                sTitleXmlPathAndFileName, 
                FileMode.Create, 
                FileAccess.Write, 
                FileShare.None);
            xmlDoc.Save(fileStream);
            fileStream.Close();

            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleXmlCreate: "
                    + "Checking new Xml configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " into repository.");
            m_sd.Add(sTitleXmlPathAndFileName);
            string sComment = "Adding new xml configuration file for title "
                + tid.sTitleIdHexNoPrefix;
            m_sd.Submit(sTitleXmlPathAndFileName, sComment);
            return;
        }

        private CTitleXml TitleXmlGet(CTitleId tid)
        {
            if (!TitleXmlExists(tid))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlGet: "
                    + "Xml configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository. Creating new title xml file.");
                TitleXmlCreate(tid);
            }

            // the xml file exists now, one way or another.

            // see if we already have an xmlDoc open for this title
            if (m_htTitleXmls.ContainsKey(tid.uiTitleId))
            {
                // we already have an XmlDocument for this title, so return it.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                        + "Title xml configuration file for "
                        + tid.sTitleIdHexNoPrefix
                        + " already open.");
                return (CTitleXml)m_htTitleXmls[tid.uiTitleId];
            }

            string sTitleXmlPathAndFileName = TitleXmlPathAndFileName(tid);
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlGet: "
                    + "Opening Xml configuration file: "
                    + sTitleXmlPathAndFileName);
            FileStream fileStream = File.OpenRead(sTitleXmlPathAndFileName);
            XmlDocument xmlDoc = new XmlDocument();
            try
            {
                xmlDoc.Load(sTitleXmlPathAndFileName);
            }
            catch (XmlException e)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleXmlGet: "
                    + "Xml file "
                    + sTitleXmlPathAndFileName
                    + " does not contain well formed xml data. Exception details: "
                    + e.Message;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }
            finally
            {
                fileStream.Close();
            }

            CTitleXml titleXml = new CTitleXml(xmlDoc, tid, m_log);
            if (!titleXml.VerifyTitleId())
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleXmlGet: "
                    + "Xml file "
                    + sTitleXmlPathAndFileName
                    + " does not contain a title node that matches titleid "
                    + tid.sTitleIdHexNoPrefix;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // add this CTitleXml object to the hashtable
            m_htTitleXmls.Add(tid.uiTitleId, titleXml);
            return titleXml;
        }

        private void TitleXmlSubmit(CTitleId tid, string sComment)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sComment == null)
            {
                throw new ArgumentNullException("sComment");
            }

            // get the CTitleXml object from the hashtable. if it's not there, 
            // there's nothing to do, so simply return
            CTitleXml titleXml = (CTitleXml)m_htTitleXmls[tid.uiTitleId];
            if (titleXml == null)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                        + "Xml configuration file for titleid "
                        + tid.sTitleIdHexNoPrefix
                        + " has not been opened. Nothing to submit");
                return;
            }

            // check to see if we've modified the xml data in any way
            if (!titleXml.Changed)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                        + "Xml configuration for titleid "
                        + tid.sTitleIdHexNoPrefix
                        + " has not been modified. Nothing to submit");
                return;
            }

            string sTitleXmlPathAndFileName = TitleXmlPathAndFileName(tid);
            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                    + "Updating Xml configuration file "
                    + sTitleXmlPathAndFileName
                    + " for title id "
                    + tid.sTitleIdHexNoPrefix
                    + " in the repository");

            // sd edit the xml file
            m_sd.Edit(sTitleXmlPathAndFileName);

            // open and truncate the file, save the data, and close it
            FileStream fileStream = new FileStream(
                sTitleXmlPathAndFileName, 
                FileMode.Create, 
                FileAccess.Write, 
                FileShare.None);
            titleXml.Save(fileStream);
            fileStream.Close();

            // sd submit the file
            m_sd.Submit(sTitleXmlPathAndFileName, sComment);

            // note, no need to remove the xml document from the hashtable - the
            // caller may not be done getting information from it. calling this method
            // simply means they wanted to commit any changes they've made

            return;
        }

        private string TitleStatsIniName
        {
            // The legacy stats ini file is simply called "stats.ini"
            get { return "stats.ini"; }
        }

        private string TitleStatsIniPath(CTitleId tid)
        {
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + "config";
        }

        private string TitleStatsIniPathAndFileName(CTitleId tid)
        {
            return CPathUtil.AddPathTerminator(TitleStatsIniPath(tid))
                + TitleStatsIniName;
        }

        private bool TitleStatsIniExists(CTitleId tid)
        {
            return File.Exists(TitleStatsIniPathAndFileName(tid));
        }

        private CIni TitleStatsIniGet(CTitleId tid)
        {
            if (!TitleStatsIniExists(tid))
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlGet: "
                    + "stats.ini configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository. Creating new stats.ini file.");
                TitleStatsIniCreate(tid);
            }

            // see if we already have a CIni open for this title
            if (m_htStatsInis.ContainsKey(tid.uiTitleId))
            {
                // we already have a CIni for this title, so return it.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                        + "Legacy stats ini configuration file for "
                        + tid.sTitleIdHexNoPrefix
                        + " already open.");
                return (CIni)m_htStatsInis[tid.uiTitleId];
            }

            CIni iniStats;
            string sTitleStatsIniPathAndFileName = TitleStatsIniPathAndFileName(tid);
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsIniGet: "
                    + "Opening legacy stats ini configuration file: "
                    + sTitleStatsIniPathAndFileName);
            try
            {
                iniStats = new CIni(sTitleStatsIniPathAndFileName);
            }
            catch (ApplicationException e)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsIniGet: "
                    + "Ini file "
                    + sTitleStatsIniPathAndFileName
                    + " could not be parsed. Exception details: "
                    + e.Message;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // add this CIni object to the hashtable
            m_htStatsInis.Add(tid.uiTitleId, iniStats);
            return iniStats;
        }

        private string TitleStatsXmlName
        {
            // The version 2 stats xml file is called "stats.xml"
            get { return "stats.xml"; }
        }

        private void TitleStatsIniCreate(CTitleId tid)
        {
            // This creates and checks in a title's stats ini file that contains 
            // no settings. The title's repository directory must already exist,
            // and the title's xml file must NOT exist
            if (TitleStatsIniExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsIniCreate: "
                    + "stats.ini configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " already exists in repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            if (!TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsIniCreate: "
                    + "TitleId "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in the repository.";
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // create the directory for the file, if required
            if (!Directory.Exists(TitleStatsIniPath(tid)))
            {
                Directory.CreateDirectory(TitleStatsIniPath(tid));
            }

            // create an empty file
            StreamWriter streamWriter = File.CreateText(TitleStatsIniPathAndFileName(tid));

            // write some whitespace to the file so source depot can figure out that it's
            // a text file...
            streamWriter.Write("   ");
            streamWriter.Close();

            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleStatsIniCreate: "
                    + "Checking new stats.ini configuration file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " into repository.");
            m_sd.Add(TitleStatsIniPathAndFileName(tid));
            string sComment = "Adding new stats.ini configuration file for title "
                + tid.sTitleIdHexNoPrefix;
            m_sd.Submit(TitleStatsIniPathAndFileName(tid), sComment);
            return;
        }

        private void TitleStatsIniSubmit(CTitleId tid, string sComment)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (sComment == null)
            {
                throw new ArgumentNullException("sComment");
            }

            // get the CIni object from the hashtable. if it's not there, 
            // there's nothing to do, so simply return
            CIni iniStats = (CIni)m_htStatsInis[tid.uiTitleId];
            if (iniStats == null)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                        + "stats.ini file for titleid "
                        + tid.sTitleIdHexNoPrefix
                        + " has not been opened. Nothing to submit");
                return;
            }

            // check to see if we've modified the xml data in any way
            if (!iniStats.Changed)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                        + "stats.ini file for titleid "
                        + tid.sTitleIdHexNoPrefix
                        + " has not been modified. Nothing to submit");
                return;
            }

            string sStatsIniPathAndFileName = TitleStatsIniPathAndFileName(tid);
            m_log.DataMod("Xbox.Tools.Framework.CRepository.TitleXmlSubmit: "
                    + "Updating stats.ini file "
                    + sStatsIniPathAndFileName
                    + " for title id "
                    + tid.sTitleIdHexNoPrefix
                    + " in the repository");

            // sd edit the xml file
            m_sd.Edit(sStatsIniPathAndFileName);

            // open and truncate the file, save the data, and close it
            iniStats.Save(sStatsIniPathAndFileName);

            // sd submit the file
            m_sd.Submit(sStatsIniPathAndFileName, sComment);

            // note, no need to remove the ini file from the hashtable - the
            // caller may not be done getting information from it. calling this method
            // simply means they wanted to commit any changes they've made

            return;
        }


        private string TitleStatsXmlPathAndFileName(CTitleId tid)
        {
            return CPathUtil.AddPathTerminator(TitlePath(tid))
                + CPathUtil.AddPathTerminator("config")
                + TitleStatsXmlName;
        }

        private bool TitleStatsXmlExists(CTitleId tid)
        {
            return File.Exists(TitleStatsXmlPathAndFileName(tid));
        }

        private CXsc TitleStatsXmlGet(CTitleId tid)
        {
            if (!TitleStatsXmlExists(tid))
            {
                // we don't want to create new legacy
                // repository files, so just return null
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                    + "legacy stats xml file for title "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository.");
                return null;
            }

            // see if we already have a CXsc open for this title
            if (m_htStatsXmls.ContainsKey(tid.uiTitleId))
            {
                // we already have a CXsc for this title, so return it.
                m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                        + "Legacy stats xml configuration file for "
                        + tid.sTitleIdHexNoPrefix
                        + " already open.");
                return (CXsc)m_htStatsXmls[tid.uiTitleId];
            }

            CXsc xsc;
            string sTitleStatsXmlPathAndFileName = TitleStatsXmlPathAndFileName(tid);
            m_log.FullTrace("Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                    + "Opening legacy stats xml configuration file: "
                    + sTitleStatsXmlPathAndFileName);
            try
            {
                xsc = new CXsc(sTitleStatsXmlPathAndFileName, m_log);
            }
            catch (ApplicationException e)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.TitleStatsXmlGet: "
                    + "Ini file "
                    + sTitleStatsXmlPathAndFileName
                    + " could not be parsed. Exception details: "
                    + e.Message;
                m_log.LogFile(sErr);
                throw new CRepositoryException(sErr);
            }

            // add this CXsc object to the hashtable
            m_htStatsXmls.Add(tid.uiTitleId, xsc);
            return xsc;
        }

        // this helper class encapsulates the structure of the title xml file
        // note the format of this file is chosen in a way that will hopefully
        // make it very human-readable and easy to hand modify in a pinch.
        private class CTitleXml
        {
            private CLog m_log;
            private XmlDocument m_xmlDoc;
            private CTitleId m_tid;
            private bool m_bChanged;

            // title element
            private const string TitleElemName = "Title";
            private const string TitleIdAttrName = "titleid";
            private const string VersionAttrName = "version";
            // using version 3 to match the build number of tsunami
            private const string VersionAttrValue = "3.0";

            private string TitleElemXpath
            {
                get
                {
                    return "/"+TitleElemName+"[@" + TitleIdAttrName+"='"+m_tid.sTitleIdHexNoPrefix+"']";
                }
            }

            // title wide default settings are kept as attributes in a child of the Title element
            // called Default as attributes
            public const string DefaultElemName = "Default";

            // the currently valid attributes in the default element
            public const string StatsDBAttrName = "StatsDB";

            private string TitleDefaultElemXpath
            {
                get
                {
                    return TitleElemXpath+"/"+DefaultElemName;
                }
            }
            private string TitleDefaultSettingAttrXpath(string sDefaultSettingAttrName)
            {
                return TitleDefaultElemXpath+"/@"+sDefaultSettingAttrName;
            }

            // All leaderboards are grouped under a single Leaderboards element
            // for readability. Each leaderboard is represented by a Leaderboard
            // element. Simple Leaderboard settings are stored as attributes in 
            // the Leaderboard element. Complex settings, such as descriptions
            // are stored as child elements, usually grouped together using
            // another element for legibility.

            // Leaderboards element name and xpath
            private const string LBsElemName = "Leaderboards";
            private string LBsElemXpath
            {
                get { return TitleElemXpath+"/"+LBsElemName; }
            }
            
            // Attributes we store on the Leaderboards element
            public const string LBMaxWritesAttrName = "MaxWrites";
            public const string LBMaxReadsAttrName = "MaxReads";

            // All units are grouped under a signle UnitLeaderboards element
            // for readability. Each Unit leaderboard is represented in the 
            // same way as individual leaderboards. Title wide unit configuration
            // parameters are stored in attributes of the UnitLeaderboards element

            // UnitLeaderboards element name and xpath
            private const string UnitsElemName = "UnitLeaderboards";
            private string UnitsElemXpath
            {
                get { return TitleElemXpath+"/"+UnitsElemName; }
            }

            // Attributes we store on the UnitLeaderboards element
            public const string UnitDBAttrName = "UnitDB";
            public const string UnitDecayFactorAttrName = "DecayFactor";
            public const string UnitMaxAvailAttrName = "MaxAvail";
            public const string UnitSizeCacheAttrName = "SizeCache";

            // All competition templates are grouped under a signle CompetitionTemplates
            // element for readability. Competition partition information is also
            // stored under this element.

            // CompetitionTemplates element name and xpath
            private const string CompsElemName = "CompetitionTemplates";
            private string CompsElemXpath
            {
                get { return TitleElemXpath+"/"+CompsElemName; }
            }

            // Alternate title ids name and xpath
            private const string AlternateTitleIdsElemName = "AlternateTitleIds";
            private string AlternateTitleIdsElemXpath
            {
                get { return TitleElemXpath+"/"+AlternateTitleIdsElemName; }
            }

            private const string AlternateTitleIdElemName = "AlternateTitleId";
            private string AlternateTitleIdElemXpath
            {
                get { return AlternateTitleIdsElemXpath+"/"+AlternateTitleIdElemName; }
            }

            public const string AlternateTitleIdAttrName = "titleid";
            private string AlternateTitleIdAttrElemXpath(CTitleId tid)
            {
                return AlternateTitleIdElemXpath+"[@"+AlternateTitleIdAttrName+"='"+tid.sTitleIdHexNoPrefix+"']";
            }

            // LSP Sites name and xpath
            private const string LSPSitesElemName = "LSPSites";
            private string LSPSitesElemXpath
            {
                get { return TitleElemXpath + "/" + LSPSitesElemName; }
            }

            private const string LSPSiteElemName = "site";
            private string LSPSiteElemXpath
            {
                get { return LSPSitesElemXpath + "/" + LSPSiteElemName; }
            }

            // LSP Services name and XPath
            private const string LSPServicesElemName = "LSPServices";
            private string LSPServicesElemXpath
            {
                get { return TitleElemXpath + "/" + LSPServicesElemName; }
            }

            private const string LSPServiceElemName = "service";
            private string LSPServiceElemXpath
            {
                get { return LSPServicesElemXpath + "/" + LSPServiceElemName; }
            }

            // Competition partition information is stored in attributes of 
            // to the CompetitionTemplates element
            private const string CompPart0AttrName = "Partition0";
            private const string CompPart1AttrName = "Partition1";
            private const string CompPart2AttrName = "Partition2";
            private const string CompPart3AttrName = "Partition3";

            // Leaderboard element name and xpaths
            private const string LBElemName = "Leaderboard";
            private string LBListXpath
            {
                get { return LBsElemXpath+"/"+LBElemName; }
            }
            private string LBXpath(uint uiLBNum)
            {
                return LBListXpath+"[@"+LBNumAttrName+"='"+uiLBNum.ToString()+"']";
            }
            private string UnitListXpath
            {
                get { return UnitsElemXpath+"/"+LBElemName; }
            }
            private string UnitXpath(uint uiLBNum)
            {
                return UnitListXpath+"[@"+LBNumAttrName+"='"+uiLBNum.ToString()+"']";
            }
            private string CompListXpath
            {
                get { return CompsElemXpath+"/"+LBElemName; }
            }
            private string CompXpath(uint uiLBNum)
            {
                return CompListXpath+"[@"+LBNumAttrName+"='"+uiLBNum.ToString()+"']";
            }

            // simple leaderboard settings are stored as attributes
            private string LBSettingXpath(uint uiLBNum, string sSettingElemName)
            {
                return LBXpath(uiLBNum)+"/@"+sSettingElemName;
            }
            private string UnitSettingXpath(uint uiLBNum, string sSettingElemName)
            {
                return UnitXpath(uiLBNum)+"/@"+sSettingElemName;
            }
            private string CompSettingXpath(uint uiLBNum, string sSettingElemName)
            {
                return CompXpath(uiLBNum)+"/@"+sSettingElemName;
            }

            // simple leaderboard settings
            private const string LBNumAttrName = "id";
            public const string LBStatsDBAttrName = "DB";
            public const string LBResetAttrName = "Reset";
            public const string LBMaxAttachCountAttrName = "MaxAttachCount";
            public const string LBMaxAttachSizeAttrName = "MaxAttachSize";
            public const string LBDecayDaysAttrName = "DecayDays";
            public const string LBMaxRatingCountAttrName = "MaxRatingCount";
            public const string LBArbReqAttrName = "Arbitration";
            public const string LBIsTeamAttrName = "Team";
            public const string LBELOAttrName = "ELO";
            public const string LBEntriesPerCacheLineAttrName = "EntriesPerCacheLine";
            public const string LBExpirationSecondsAttrName = "ExpirationSeconds";
            public const string LBDontListAttrName = "DontList";

            // leaderboard descriptions are grouped together in a child
            // element of the leaderboard (or units, or competitions) 
            // element called Descrptions.
            // The children of the Descriptoins element are Description
            // elements, each of which has a locale and description 
            // attribute.
            private const string DescsElemName = "Descriptions";
            private string LBDescsElemXpath(uint uiLBNum)
            {
                return LBXpath(uiLBNum)+"/"+DescsElemName;
            }
            private string UnitDescsElemXpath(uint uiLBNum)
            {
                return UnitXpath(uiLBNum)+"/"+DescsElemName;
            }
            private string CompDescsElemXpath(uint uiLBNum)
            {
                return CompXpath(uiLBNum)+"/"+DescsElemName;
            }

            private const string DescElemName = "Description";
            private const string DescLocaleAttrName = "locale";
            private const string DescDescAttrName = "desc";
            private string LBDescListXpath(uint uiLBNum)
            {
                return LBDescsElemXpath(uiLBNum)+"/"+DescElemName;
            }
            private string LBDescElemXpath(uint uiLBNum, CLocale locale)
            {
                return LBDescListXpath(uiLBNum)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }
            private string UnitDescListXpath(uint uiLBNum)
            {
                return UnitDescsElemXpath(uiLBNum)+"/"+DescElemName;
            }
            private string UnitDescElemXpath(uint uiLBNum, CLocale locale)
            {
                return UnitDescListXpath(uiLBNum)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }
            private string CompDescListXpath(uint uiLBNum)
            {
                return CompDescsElemXpath(uiLBNum)+"/"+DescElemName;
            }
            private string CompDescElemXpath(uint uiLBNum, CLocale locale)
            {
                return CompDescListXpath(uiLBNum)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }

            // leaderboard web "raw" attributes are grouped together in a child element
            // of the Leaderboard (or units, or competitions) element called Attributes
            // The children of the Attributes element are Attribute elements, each of which
            // has 'id' and 'IsPuid' attributes.
            private const string AttrsElemName = "RawAttributes";
            private string LBAttrsElemXpath(uint uiLBNum)
            {
                return LBXpath(uiLBNum)+"/"+AttrsElemName;
            }
            private string UnitAttrsElemXpath(uint uiLBNum)
            {
                return UnitXpath(uiLBNum)+"/"+AttrsElemName;
            }
            private string CompAttrsElemXpath(uint uiLBNum)
            {
                return CompXpath(uiLBNum)+"/"+AttrsElemName;
            }

            private const string AttrElemName = "RawAttribute";
            private const string AttrIdAttrName = "id";
            private const string AttrIsPuidAttrName = "IsPuid";
            private string LBAttrListXpath(uint uiLBNum)
            {
                return LBAttrsElemXpath(uiLBNum)+"/"+AttrElemName;
            }
            private string LBAttrElemXpath(uint uiLBNum, uint uiId)
            {
                return LBAttrListXpath(uiLBNum)+"[@"+AttrIdAttrName+"='"+uiId.ToString()+"']";
            }
            private string UnitAttrListXpath(uint uiLBNum)
            {
                return UnitAttrsElemXpath(uiLBNum)+"/"+AttrElemName;
            }
            private string UnitAttrElemXpath(uint uiLBNum, uint uiId)
            {
                return UnitAttrListXpath(uiLBNum)+"[@"+AttrIdAttrName+"='"+uiId.ToString()+"']";
            }
            private string CompAttrListXpath(uint uiLBNum)
            {
                return CompAttrsElemXpath(uiLBNum)+"/"+AttrElemName;
            }
            private string CompAttrElemXpath(uint uiLBNum, uint uiId)
            {
                return CompAttrListXpath(uiLBNum)+"[@"+AttrIdAttrName+"='"+uiId.ToString()+"']";
            }

            // Leaderboard formatted values are stored in FormattedValue elements which are
            // children of the FormattedValues element, which is a child of a leaderboard element.
            // All the attributes of a formatted value are stored at attributes, except
            // for the formula, which must be stored as a CDATA section, and therefore gets
            // its own Formula element that's a child of the FormattedValue element.
            // The descriptions for each formatted value are stored in a Descriptions
            // element that is structured the same way as the leaderboard Descriptions.
            private const string ValuesElemName = "FormattedValues";
            private string LBValuesElemXpath(uint uiLBNum)
            {
                return LBXpath(uiLBNum)+"/"+ValuesElemName;
            }
            private string UnitValuesElemXpath(uint uiLBNum)
            {
                return UnitXpath(uiLBNum)+"/"+ValuesElemName;
            }
            private string CompValuesElemXpath(uint uiLBNum)
            {
                return CompXpath(uiLBNum)+"/"+ValuesElemName;
            }

            private const string ValueElemName = "FormattedValue";
            private const string ValueNameAttrName = "Name";
            private const string ValueRetAttrName = "Return";
            private string LBValueListXpath(uint uiLBNum)
            {
                return LBValuesElemXpath(uiLBNum)+"/"+ValueElemName;
            }
            private string LBValueElemXpath(uint uiLBNum, string sName)
            {
                return LBValueListXpath(uiLBNum)+"[@"+ValueNameAttrName+"='"+sName+"']";
            }
            private string UnitValueListXpath(uint uiLBNum)
            {
                return UnitValuesElemXpath(uiLBNum)+"/"+ValueElemName;
            }
            private string UnitValueElemXpath(uint uiLBNum, string sName)
            {
                return UnitValueListXpath(uiLBNum)+"[@"+ValueNameAttrName+"='"+sName+"']";
            }
            private string CompValueListXpath(uint uiLBNum)
            {
                return CompValuesElemXpath(uiLBNum)+"/"+ValueElemName;
            }
            private string CompValueElemXpath(uint uiLBNum, string sName)
            {
                return CompValueListXpath(uiLBNum)+"[@"+ValueNameAttrName+"='"+sName+"']";
            }

            private const string ValueFormulaElemName = "Formula";
            private string LBValueFormulaCDataXpath(uint uiLBNum, string sName)
            {
                return LBValueElemXpath(uiLBNum, sName)+"/"+ValueFormulaElemName+"/text()";
            }
            private string UnitValueFormulaCDataXpath(uint uiLBNum, string sName)
            {
                return UnitValueElemXpath(uiLBNum, sName)+"/"+ValueFormulaElemName+"/text()";
            }
            private string CompValueFormulaCDataXpath(uint uiLBNum, string sName)
            {
                return CompValueElemXpath(uiLBNum, sName)+"/"+ValueFormulaElemName+"/text()";
            }

            private string LBValueDescsElemXpath(uint uiLBNum, string sName)
            {
                return LBValueElemXpath(uiLBNum, sName)+"/"+DescsElemName;
            }
            private string LBValueDescListXpath(uint uiLBNum, string sName)
            {
                return LBValueDescsElemXpath(uiLBNum, sName)+"/"+DescElemName;
            }
            private string LBValueDescElemXpath(uint uiLBNum, string sName, CLocale locale)
            {
                return LBValueDescListXpath(uiLBNum, sName)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }
            private string UnitValueDescsElemXpath(uint uiLBNum, string sName)
            {
                return UnitValueElemXpath(uiLBNum, sName)+"/"+DescsElemName;
            }
            private string UnitValueDescListXpath(uint uiLBNum, string sName)
            {
                return UnitValueDescsElemXpath(uiLBNum, sName)+"/"+DescElemName;
            }
            private string UnitValueDescElemXpath(uint uiLBNum, string sName, CLocale locale)
            {
                return UnitValueDescListXpath(uiLBNum, sName)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }
            private string CompValueDescsElemXpath(uint uiLBNum, string sName)
            {
                return CompValueElemXpath(uiLBNum, sName)+"/"+DescsElemName;
            }
            private string CompValueDescListXpath(uint uiLBNum, string sName)
            {
                return CompValueDescsElemXpath(uiLBNum, sName)+"/"+DescElemName;
            }
            private string CompValueDescElemXpath(uint uiLBNum, string sName, CLocale locale)
            {
                return CompValueDescListXpath(uiLBNum, sName)+"[@"+DescLocaleAttrName+"='"+locale.ToString()+"']";
            }

            // Query service element
            private const string QueryElemName = "QueryService";

            // the attributes on QueryService element
            private const string QueryPartitionAttrName = "PartitionId";

            // Prior to the production tools 2004-04 release, the querysim element
            // from the xqs file was stored as a child of the QueryServer node.
            // However, with the production tools 2004-04 release, we now support
            // multiple "types" of xqs files. e.g. one for competitions, one for
            // lsp, one for competition manager, etc. The set of allowed xqs file
            // types is defined by the results of the ServiceQueryTypeGetList method.
            // 
            // We need to support title.xml files in the old format, and the new
            // format. A querysim node that is a child of the QueryService node
            // is implicity of QueryType "comp", and performing a QueryConfigXmlTypeSet
            // operation will convert the xml to the new format.

            // The QueryType node is the new parent of the querysim nodes
            private const string QueryTypeElemName = "QueryType";

            // this attribute determines the name of this QueryType
            private const string QueryTypeAttrName = "name";

            // the type name to which legacy querysim nodes are mapped
            private const string QueryServiceLegacyTypeName = "comp";

            private string QueryElemXpath
            {
                get { return TitleElemXpath+"/"+QueryElemName; }
            }

            private string QueryTypeElemXpath(string sQueryTypeName)
            {
                return QueryElemXpath
                    +"/"
                    +QueryTypeElemName
                    +"[@"+QueryTypeAttrName
                    +"=\""
                    +sQueryTypeName
                    +"\"]";
            }
            

            private const string QuerySimElemName = "querysim";

            // this is the path within the xqs file, not title xml
            private const string XqsQuerySimElemXpath = "/"+QuerySimElemName;

            // this is the xpath where a pre-production tools 2004-04
            // release of titlemgr would store the one and only querysim
            // element. If this Xpath returns a hit, then we know we're
            // dealing with a legacy file.
            private string QuerySimLegacyXpath 
            {
                get { return QueryElemXpath+"/"+QuerySimElemName; }
            }

            private string QuerySimElemXpath(string sQueryTypeName)
            {
                return QueryTypeElemXpath(sQueryTypeName)+"/"+QuerySimElemName;
            }

            public CTitleXml(XmlDocument xmlDoc, CTitleId tid, CLog log)
            {
                m_log = log;
                if (m_log == null)
                {
                    m_log = new CLogNull();
                }
                m_xmlDoc = xmlDoc;
                m_tid = tid;
                m_bChanged = false;
            }

            public bool Changed
            {
                get { return m_bChanged; }
            }

            public static XmlDocument Create(CTitleId tid, CLog log)
            {
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Creating new xml document");
                XmlDocument xmlDoc = new XmlDocument();
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Adding xml declaration");
                XmlDeclaration xmlDecl = xmlDoc.CreateXmlDeclaration("1.0", "utf-8", "");
                xmlDoc.PrependChild(xmlDecl);
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Creating "
                    + TitleElemName
                    + " element");
                XmlElement xmlTitleElem = xmlDoc.CreateElement(TitleElemName);
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + TitleIdAttrName
                    + " attribute to "
                    + tid.sTitleIdHexNoPrefix
                    + " on "
                    + TitleElemName
                    + " element.");
                xmlTitleElem.SetAttribute(TitleIdAttrName, tid.sTitleIdHexNoPrefix);
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + VersionAttrName
                    + " attribute to "
                    + VersionAttrValue
                    + " on "
                    + TitleElemName
                    + " element.");
                xmlTitleElem.SetAttribute(VersionAttrName, VersionAttrValue);
                xmlDoc.AppendChild(xmlTitleElem);
                return xmlDoc;
            }

            public void Save(FileStream fileStream)
            {
                m_xmlDoc.Save(fileStream);
                m_bChanged = false;
            }

            public bool VerifyTitleId()
            {
                // verify the titleid by looking for an xml node that matches
                // the correct element name with the correct titleid attribute
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(TitleElemXpath);
                if (xmlNode == null)
                {
                    return false;
                }
                return true;
            }

            public bool DefaultGet(
                string sSettingName, 
                ref string sValue)
            {
                string sXpath = TitleDefaultSettingAttrXpath(sSettingName);

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not find node matching "
                        + sXpath);
                    return false;
                }

                sValue = xmlNode.Value;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found value of "
                    + sValue
                    + " in node matching "
                    + sXpath);
                return true;
            }

            public void DefaultSet(
                string sSettingName, 
                string sValue)
            {
                // get the existing default setting element if it exists
                string sXpath = TitleDefaultElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this setting does not exist,
                    // create a new one
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Creating new Default element"
                        + sSettingName);

                    // create the new element
                    XmlElement xmlElem = m_xmlDoc.CreateElement(DefaultElemName);

                    // get the title element
                    sXpath = TitleElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting title node matching "
                        + sXpath);
                    XmlNode xmlNodeTitle = m_xmlDoc.SelectSingleNode(sXpath);
                    if (xmlNodeTitle == null)
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository: "
                            + "Unable to find title node for titleid "
                            + m_tid.sTitleIdHexNoPrefix;
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Prepending new "
                        + DefaultElemName
                        + " element to "
                        + TitleElemName
                        + " element.");
                    xmlNodeTitle.PrependChild(xmlElem);
                    xmlNode = xmlElem;
                }

                // the xmlNode now points to the default
                // element, one way or the other
                XmlElement xmlElemDefault = (XmlElement)xmlNode;
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting attribute "
                    + sSettingName
                    + " to value "
                    + sValue
                    + " in "
                    + DefaultElemName
                    + " element."
                    + sXpath);
                xmlElemDefault.SetAttribute(sSettingName, sValue);
                m_bChanged = true;
                return;
            }

            public void DefaultDelete(
                string sSettingName)
            {
                // get the existing setting node if it exists
                string sXpath = TitleDefaultElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this setting does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Node does not exist, nothing to delete.");
                }
                else
                {
                    // the xml node containing this setting exists.
                    // it is a Default element, and the setting is an 
                    // attribute named for sSettingName
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Deleting "
                        + sSettingName
                        + " attribute.");
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    xmlElem.RemoveAttribute(sSettingName);
                    m_bChanged = true;
                }
                return;
            }

            public bool ContainsStatsInfo()
            {
                // see if there is a Leaderboards element...
                string sXpath = LBsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    return true;
                }

                // see if there is a UnitLeaderboards element...
                sXpath = UnitsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    return true;
                }

                // see if there is a CompetitionTemplates element...
                sXpath = CompsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    return true;
                }

                return false;
            }

            public void LBLimitsSet(
                CTitleId tid,
                uint uiMaxWrites,
                uint uiMaxReads)
            {
                // these settings, if present, are stored as attributes
                // on the leaderboards element
                string sXpath = LBsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    xmlNode = TitleChildElemCreate(LBsElemName);
                }

                // one way or the other xmlNode now points to the
                // Leaderboards element
                XmlElement xmlElem = (XmlElement)xmlNode;

                // set the attributes
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + LBMaxWritesAttrName
                    + " attribute to "
                    + uiMaxWrites
                    + " on "
                    + LBsElemName
                    + " element.");
                xmlElem.SetAttribute(LBMaxWritesAttrName, uiMaxWrites.ToString());

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + LBMaxReadsAttrName
                    + " attribute to "
                    + uiMaxReads
                    + " on "
                    + LBsElemName
                    + " element.");
                xmlElem.SetAttribute(LBMaxReadsAttrName, uiMaxReads.ToString());
                m_bChanged = true;
                return;
            }

            public bool LBLimitsGet(
                CTitleId tid,
                ref uint uiMaxWrites,
                ref uint uiMaxReads)
            {
                // these settings, if present, are stored as attributes
                // on the leaderboards element
                string sXpath = LBsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no node, no settings.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBsElemName
                        + " element not found, no settings to get.");
                    return false;
                }

                bool bFound = false;
                XmlElement xmlElem = (XmlElement)xmlNode;

                // get the attributes
                string sMaxWrites = xmlElem.GetAttribute(LBMaxWritesAttrName);
                if (sMaxWrites == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBsElemName
                        + " does not have a "
                        + LBMaxWritesAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        uiMaxWrites = UInt32.Parse(sMaxWrites);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + LBMaxWritesAttrName
                            + " attribute on "
                            + LBsElemName
                            + " element has a value of "
                            + sMaxWrites
                            + " which could not be parsed as an integer."
                            + " This attribute will be ignored");
                    }
                }

                string sMaxReads = xmlElem.GetAttribute(LBMaxReadsAttrName);
                if (sMaxReads == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBsElemName
                        + " does not have a "
                        + LBMaxReadsAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        uiMaxReads = UInt32.Parse(sMaxReads);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + LBMaxReadsAttrName
                            + " attribute on "
                            + LBsElemName
                            + " element has a value of "
                            + sMaxReads
                            + " which could not be parsed as an integer."
                            + " This attribute will be ignored");
                    }
                }

                return bFound;
            }

            public void LBLimitsDelete(
                CTitleId tid)
            {
                // these settings, if present, are stored as attributes
                // on the leaderboards element
                string sXpath = LBsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no leaderboards node, nothing to delete
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBsElemName
                        + " element not found, no settings to delete.");
                    return;
                }

                XmlElement xmlElem = (XmlElement)xmlNode;

                // set the attributes
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + LBMaxWritesAttrName
                    + " attribute on "
                    + LBsElemName
                    + " element.");
                xmlElem.RemoveAttribute(LBMaxWritesAttrName);

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Removing "
                    + LBMaxReadsAttrName
                    + " attribute on "
                    + LBsElemName
                    + " element.");
                xmlElem.RemoveAttribute(LBMaxReadsAttrName);
                m_bChanged = true;
                return;
            }

            public void UnitConfigSet(
                int iUnitDatabase,
                double dDecayFactor,
                uint uiMaxAvailUnits,
                uint uiSizeUnitCache)
            {
                // these settings, if present, are stored as attributes
                // on the units element
                string sXpath = UnitsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    xmlNode = TitleChildElemCreate(UnitsElemName);
                }

                // one way or the other xmlNode now points to the
                // Units element
                XmlElement xmlElem = (XmlElement)xmlNode;

                // set the attributes
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + UnitDBAttrName
                    + " attribute to "
                    + iUnitDatabase
                    + " on "
                    + UnitsElemName
                    + " element.");
                xmlElem.SetAttribute(UnitDBAttrName, iUnitDatabase.ToString());

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + UnitDecayFactorAttrName
                    + " attribute to "
                    + dDecayFactor
                    + " on "
                    + UnitsElemName
                    + " element.");
                xmlElem.SetAttribute(UnitDecayFactorAttrName, dDecayFactor.ToString());

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + UnitMaxAvailAttrName
                    + " attribute to "
                    + uiMaxAvailUnits
                    + " on "
                    + UnitsElemName
                    + " element.");
                xmlElem.SetAttribute(UnitMaxAvailAttrName, uiMaxAvailUnits.ToString());

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + UnitSizeCacheAttrName
                    + " attribute to "
                    + uiSizeUnitCache
                    + " on "
                    + UnitsElemName
                    + " element.");
                xmlElem.SetAttribute(UnitSizeCacheAttrName, uiSizeUnitCache.ToString());

                m_bChanged = true;
                return;
            }

            public bool UnitConfigGet(
                ref int iUnitDatabase,
                ref double dDecayFactor,
                ref uint uiMaxAvailUnits,
                ref uint uiSizeUnitCache)
            {
                // these settings, if present, are stored as attributes
                // on the unit leaderboards element
                string sXpath = UnitsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no node, no settings.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + UnitsElemName
                        + " element not found, no settings to get.");
                    return false;
                }

                bool bFound = false;
                XmlElement xmlElem = (XmlElement)xmlNode;

                // get the attributes
                string sUnitDatabase = xmlElem.GetAttribute(UnitDBAttrName);
                if (sUnitDatabase == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + UnitsElemName
                        + " does not have a "
                        + UnitDBAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        iUnitDatabase = Int32.Parse(sUnitDatabase);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + UnitDBAttrName
                            + " attribute on "
                            + UnitsElemName
                            + " element has a value of "
                            + sUnitDatabase
                            + " which could not be parsed as an integer."
                            + " This attribute will be ignored");
                    }
                }

                string sDecayFactor = xmlElem.GetAttribute(UnitDecayFactorAttrName);
                if (sDecayFactor == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + UnitsElemName
                        + " does not have a "
                        + UnitDecayFactorAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        dDecayFactor = Double.Parse(sDecayFactor);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + UnitDecayFactorAttrName
                            + " attribute on "
                            + UnitsElemName
                            + " element has a value of "
                            + sDecayFactor
                            + " which could not be parsed as a floating point value."
                            + " This attribute will be ignored");
                    }
                }

                string sMaxAvailUnits = xmlElem.GetAttribute(UnitMaxAvailAttrName);
                if (sMaxAvailUnits == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + UnitsElemName
                        + " does not have a "
                        + UnitMaxAvailAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        uiMaxAvailUnits = UInt32.Parse(sMaxAvailUnits);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + UnitMaxAvailAttrName
                            + " attribute on "
                            + UnitsElemName
                            + " element has a value of "
                            + uiMaxAvailUnits
                            + " which could not be parsed as an integer."
                            + " This attribute will be ignored");
                    }
                }

                string sSizeUnitCache = xmlElem.GetAttribute(UnitSizeCacheAttrName);
                if (sSizeUnitCache == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + UnitsElemName
                        + " does not have a "
                        + UnitSizeCacheAttrName
                        + " attribute.");
                }
                else
                {
                    try
                    {
                        uiSizeUnitCache = UInt32.Parse(sSizeUnitCache);
                        bFound = true;
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + UnitSizeCacheAttrName
                            + " attribute on "
                            + UnitsElemName
                            + " element has a value of "
                            + sUnitDatabase
                            + " which could not be parsed as an integer."
                            + " This attribute will be ignored");
                    }
                }

                return bFound;
            }

            public void UnitDeleteAll()
            {
                // you can't delete a unit configuration without disabling
                // units completely. So this method removes the unit leaderboard
                // attribute completely.
                string sXpath = UnitsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no unit leaderboards node, nothing to delete
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBsElemName
                        + " element not found, no settings to delete.");
                    return;
                }

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + UnitsElemName
                    + " element.");
                xmlNode.ParentNode.RemoveChild(xmlNode);

                m_bChanged = true;
                return;
            }

            public void CompPartitionSet(
                uint uiPartitionId,
                int iStatsDB)
            {
                // these settings, if present, are stored as attributes
                // on the units element
                string sXpath = CompsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    xmlNode = TitleChildElemCreate(CompsElemName);
                }

                // one way or the other xmlNode now points to the
                // ComptitionTemplates element
                XmlElement xmlElem = (XmlElement)xmlNode;

                switch (uiPartitionId)
                {
                case 0:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + CompPart0AttrName
                        + " attribute to "
                        + iStatsDB
                        + " on "
                        + CompsElemName
                        + " element.");
                    xmlElem.SetAttribute(CompPart0AttrName, iStatsDB.ToString());
                    break;

                case 1:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + CompPart1AttrName
                        + " attribute to "
                        + iStatsDB
                        + " on "
                        + CompsElemName
                        + " element.");
                    xmlElem.SetAttribute(CompPart1AttrName, iStatsDB.ToString());
                    break;

                case 2:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + CompPart2AttrName
                        + " attribute to "
                        + iStatsDB
                        + " on "
                        + CompsElemName
                        + " element.");
                    xmlElem.SetAttribute(CompPart2AttrName, iStatsDB.ToString());
                    break;

                case 3:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + CompPart3AttrName
                        + " attribute to "
                        + iStatsDB
                        + " on "
                        + CompsElemName
                        + " element.");
                    xmlElem.SetAttribute(CompPart3AttrName, iStatsDB.ToString());
                    break;

                default:
                    throw new ArgumentOutOfRangeException("uiPartitionId");
                }

                m_bChanged = true;
                return;
            }

            public bool CompPartitionGet(
                uint uiPartitionId,
                ref int iStatsDB)
            {
                // these settings, if present, are stored as attributes
                // on the competition templates element
                string sXpath = CompsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no node, no settings.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + CompsElemName
                        + " element not found, no settings to get.");
                    return false;
                }

                bool bFound = false;
                XmlElement xmlElem = (XmlElement)xmlNode;

                // get the attribute we're looking for
                string sStatsDB = null;
                switch (uiPartitionId)
                {
                case 0:
                    sStatsDB = xmlElem.GetAttribute(CompPart0AttrName);
                    break;

                case 1:
                    sStatsDB = xmlElem.GetAttribute(CompPart1AttrName);
                    break;

                case 2:
                    sStatsDB = xmlElem.GetAttribute(CompPart2AttrName);
                    break;

                case 3:
                    sStatsDB = xmlElem.GetAttribute(CompPart3AttrName);
                    break;

                default:
                    throw new ArgumentOutOfRangeException("uiPartitionId");
                }

                if (sStatsDB == null || sStatsDB == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + CompsElemName
                        + " does not have a setting for competition partition id "
                        + uiPartitionId);
                    return false;
                }

                try
                {
                    iStatsDB = Int32.Parse(sStatsDB);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                        + "Unable to parse database number of "
                        + sStatsDB
                        + " for competition partition id "
                        + uiPartitionId
                        + " as an integer. This attribute will be ignored.");
                    bFound = false;
                }
                return bFound;
            }

            public void CompPartitionDelete(
                uint uiPartitionId)
            {
                // these settings, if present, are stored as attributes
                // on the units element
                string sXpath = CompsElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no element, nothing to delete
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found, nothing to delete.");
                    return;
                }

                XmlElement xmlElem = (XmlElement)xmlNode;

                switch (uiPartitionId)
                {
                case 0:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Removing "
                        + CompPart0AttrName
                        + " attribute on "
                        + CompsElemName
                        + " element.");
                    xmlElem.RemoveAttribute(CompPart0AttrName);
                    break;

                case 1:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Removing "
                        + CompPart1AttrName
                        + " attribute on "
                        + CompsElemName
                        + " element.");
                    xmlElem.RemoveAttribute(CompPart1AttrName);
                    break;

                case 2:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Removing "
                        + CompPart2AttrName
                        + " attribute on "
                        + CompsElemName
                        + " element.");
                    xmlElem.RemoveAttribute(CompPart2AttrName);
                    break;

                case 3:
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Removing "
                        + CompPart3AttrName
                        + " attribute on "
                        + CompsElemName
                        + " element.");
                    xmlElem.RemoveAttribute(CompPart3AttrName);
                    break;

                default:
                    throw new ArgumentOutOfRangeException("uiPartitionId");
                }

                m_bChanged = true;
                return;
            }




            /*
            public bool LBHasWebInfo(uint uiLBNum)
            {
                // if there are leaderboard descriptions for this
                // leaderboard, then it is considered to have 
                // web info. No descriptions, no web info, even if other
                // web stuff is there.
                string sXpath = LBDescListXpath(uiLBNum);
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);
                if (xmlNodeList.Count == 0)
                {
                    return false;
                }
                return true;
            }
            */

            public uint[] LBGetList()
            {
                return LBGetList(LBListXpath);
            }

            public uint[] UnitGetList()
            {
                return LBGetList(UnitListXpath);
            }

            public uint[] CompGetList()
            {
                return LBGetList(CompListXpath);
            }

            public uint[] LBGetList(string sXpath)
            {
                SortedList sl = new SortedList();

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    // each node in the list should be a leaderboard element.
                    // grab the value of the id attribute, and add it to the array list
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    XmlAttribute xmlAttr = xmlElem.Attributes[LBNumAttrName];
                    if (xmlAttr == null)
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + LBElemName
                            + " element with no "
                            + LBNumAttrName
                            + " attribute.");
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found leaderboard number "
                        + xmlAttr.Value);

                    uint uiLBNum;
                    try
                    {
                        uiLBNum = UInt32.Parse(xmlAttr.Value);
                    }
                    catch (Exception e)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "Error parsing leaderboard number "
                            + xmlAttr.Value
                            + " as an integer. This "
                            + LBElemName
                            + " element will be ignored. Exception details: "
                            + e.Message);
                        continue;
                    }

                    // if we get here, we have the leaderboard number in uiLBNum

                    if (sl.ContainsKey(uiLBNum))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "Leaderboard number "
                            + uiLBNum
                            + " is already in the leaderboard list, this element will be ignored.");
                        continue;
                    }

                    sl.Add(uiLBNum, uiLBNum);
                }

                // copy any leaderboards found to an array and return it
                uint[] rgui = new uint[sl.Count];
                for (int i = 0; i < sl.Count; ++i)
                {
                    rgui[i] = (uint)sl.GetByIndex(i);
                }

                return rgui;
            }

            public void LBSet(
                uint uiLBNum,
                int iStatsDatabase,
                ELBReset riLBResetInterval,
                uint uiAttachmentCount,
                uint uiMaxAttachmentSize,
                uint uiDecayDays,
                uint uiMaxRatingCount,
                bool bArbitrationRequired,
                bool bIsTeam,
                CELOConfig eloConfig,
                uint uiEntriesPerCacheLine,
                uint uiExpirationSeconds,
                bool bDontList)
            {
                LBSettingSet(uiLBNum, CTitleXml.LBStatsDBAttrName, iStatsDatabase.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBResetAttrName, ((int)riLBResetInterval).ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBMaxAttachCountAttrName, uiAttachmentCount.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBMaxAttachSizeAttrName, uiMaxAttachmentSize.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBDecayDaysAttrName, uiDecayDays.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBMaxRatingCountAttrName, uiMaxRatingCount.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBArbReqAttrName, bArbitrationRequired ? "true" : "false");
                LBSettingSet(uiLBNum, CTitleXml.LBIsTeamAttrName, bIsTeam ? "true" : "false");

                // Save the ELO in database string format, since we already have a routine to 
                // convert to and from a string. This is cheating a little, because technically we're now
                // putting a peculiarity of the stats service into the repository format definition,
                // and they should really be independant formats, just like the repostitory should be
                // independant from the submission file format so we can change any one of the three
                // without worrying about the other two. However I'm running pretty late, and the ELO DB string
                // conversion routines are already written and tested, so I'm going to cheat this once.
                if (eloConfig == null)
                {
                    LBSettingDelete(uiLBNum, CTitleXml.LBELOAttrName);
                }
                else
                {
                    LBSettingSet(uiLBNum, CTitleXml.LBELOAttrName, eloConfig.ToStatsDBString());
                }

                LBSettingSet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, uiEntriesPerCacheLine.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, uiExpirationSeconds.ToString());
                LBSettingSet(uiLBNum, CTitleXml.LBDontListAttrName, bDontList ? "true" : "false");
            }

            public void UnitSet(
                uint uiLBNum,
                bool bArbitrationRequired,
                bool bIsTeam,
                CELOConfig eloConfig,
                uint uiEntriesPerCacheLine,
                uint uiExpirationSeconds,
                bool bDontList)
            {
                UnitSettingSet(uiLBNum, CTitleXml.LBArbReqAttrName, bArbitrationRequired ? "true" : "false");
                UnitSettingSet(uiLBNum, CTitleXml.LBIsTeamAttrName, bIsTeam ? "true" : "false");

                // Save the ELO in database string format, since we already have a routine to 
                // convert to and from a string. This is cheating a little, because technically we're now
                // putting a peculiarity of the stats service into the repository format definition,
                // and they should really be independant formats, just like the repostitory should be
                // independant from the submission file format so we can change any one of the three
                // without worrying about the other two. However I'm running pretty late, and the ELO DB string
                // conversion routines are already written and tested, so I'm going to cheat this once.
                if (eloConfig == null)
                {
                    UnitSettingDelete(uiLBNum, CTitleXml.LBELOAttrName);
                }
                else
                {
                    UnitSettingSet(uiLBNum, CTitleXml.LBELOAttrName, eloConfig.ToStatsDBString());
                }

                UnitSettingSet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, uiEntriesPerCacheLine.ToString());
                UnitSettingSet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, uiExpirationSeconds.ToString());
                UnitSettingSet(uiLBNum, CTitleXml.LBDontListAttrName, bDontList ? "true" : "false");
            }

            public void CompSet(
                uint uiLBNum,
                ELBReset riLBResetInterval,
                uint uiAttachmentCount,
                uint uiMaxAttachmentSize,
                uint uiDecayDays,
                bool bArbitrationRequired,
                bool bIsTeam,
                CELOConfig eloConfig,
                uint uiEntriesPerCacheLine,
                uint uiExpirationSeconds,
                bool bDontList)
            {
                CompSettingSet(uiLBNum, CTitleXml.LBResetAttrName, ((int)riLBResetInterval).ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBMaxAttachCountAttrName, uiAttachmentCount.ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBMaxAttachSizeAttrName, uiMaxAttachmentSize.ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBDecayDaysAttrName, uiDecayDays.ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBArbReqAttrName, bArbitrationRequired ? "true" : "false");
                CompSettingSet(uiLBNum, CTitleXml.LBIsTeamAttrName, bIsTeam ? "true" : "false");

                // Save the ELO in database string format, since we already have a routine to 
                // convert to and from a string. This is cheating a little, because technically we're now
                // putting a peculiarity of the stats service into the repository format definition,
                // and they should really be independant formats, just like the repostitory should be
                // independant from the submission file format so we can change any one of the three
                // without worrying about the other two. However I'm running pretty late, and the ELO DB string
                // conversion routines are already written and tested, so I'm going to cheat this once.
                if (eloConfig == null)
                {
                    CompSettingDelete(uiLBNum, CTitleXml.LBELOAttrName);
                }
                else
                {
                    CompSettingSet(uiLBNum, CTitleXml.LBELOAttrName, eloConfig.ToStatsDBString());
                }

                CompSettingSet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, uiEntriesPerCacheLine.ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, uiExpirationSeconds.ToString());
                CompSettingSet(uiLBNum, CTitleXml.LBDontListAttrName, bDontList ? "true" : "false");
            }

            public bool LBGet(
                uint uiLBNum, 
                ref int iStatsDatabase,
                ref ELBReset riLBResetInterval,
                ref uint uiAttachmentCount,
                ref uint uiMaxAttachmentSize,
                ref uint uiDecayDays,
                ref uint uiMaxRatingCount,
                ref bool bArbitrationRequired,
                ref bool bIsTeam,
                ref CELOConfig eloConfig,
                ref uint uiEntriesPerCacheLine,
                ref uint uiExpirationSeconds,
                ref bool bDontList)
            {
                string sValue = null;
                bool bFound = false;
                if (LBSettingGet(uiLBNum, CTitleXml.LBStatsDBAttrName, ref sValue))
                {
                    try
                    {
                        iStatsDatabase = Int32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBStatsDBAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBResetAttrName, ref sValue))
                {
                    try
                    {
                        riLBResetInterval = (ELBReset)Int32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBResetAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer valid for a leaderboard reset interval. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBMaxAttachCountAttrName, ref sValue))
                {
                    try
                    {
                        uiAttachmentCount = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBMaxAttachCountAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBMaxAttachSizeAttrName, ref sValue))
                {
                    try
                    {
                        uiMaxAttachmentSize = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBMaxAttachSizeAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBDecayDaysAttrName, ref sValue))
                {
                    try
                    {
                        uiDecayDays = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBDecayDaysAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBMaxRatingCountAttrName, ref sValue))
                {
                    try
                    {
                        uiMaxRatingCount = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBMaxRatingCountAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBArbReqAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bArbitrationRequired = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bArbitrationRequired = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBArbReqAttrName
                            + " for leaderboard "
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBIsTeamAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bIsTeam = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bIsTeam = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBIsTeamAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                // see note about ELO setting in LBGet
                if (LBSettingGet(uiLBNum, CTitleXml.LBELOAttrName, ref sValue))
                {
                    try
                    {
                        eloConfig = CELOConfig.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBELOAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an ELO configuration. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, ref sValue))
                {
                    try
                    {
                        uiEntriesPerCacheLine = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBEntriesPerCacheLineAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, ref sValue))
                {
                    try
                    {
                        uiExpirationSeconds = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBExpirationSecondsAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (LBSettingGet(uiLBNum, CTitleXml.LBDontListAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bDontList = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bDontList = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBDontListAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }

                return bFound;
            }

            public bool UnitGet(
                uint uiLBNum, 
                ref bool bArbitrationRequired,
                ref bool bIsTeam,
                ref CELOConfig eloConfig,
                ref uint uiEntriesPerCacheLine,
                ref uint uiExpirationSeconds,
                ref bool bDontList)
            {
                string sValue = null;
                bool bFound = false;
                if (UnitSettingGet(uiLBNum, CTitleXml.LBArbReqAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bArbitrationRequired = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bArbitrationRequired = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBArbReqAttrName
                            + " for unit leaderboard "
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                if (UnitSettingGet(uiLBNum, CTitleXml.LBIsTeamAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bIsTeam = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bIsTeam = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBIsTeamAttrName
                            + " for unit leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                // see note about ELO setting in LBGet
                if (UnitSettingGet(uiLBNum, CTitleXml.LBELOAttrName, ref sValue))
                {
                    try
                    {
                        eloConfig = CELOConfig.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBELOAttrName
                            + " for unit leaderboard ."
                            + uiLBNum
                            + " as an ELO configuration. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (UnitSettingGet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, ref sValue))
                {
                    try
                    {
                        uiEntriesPerCacheLine = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBEntriesPerCacheLineAttrName
                            + " for unit leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (UnitSettingGet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, ref sValue))
                {
                    try
                    {
                        uiExpirationSeconds = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBExpirationSecondsAttrName
                            + " for unit leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (UnitSettingGet(uiLBNum, CTitleXml.LBDontListAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bDontList = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bDontList = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBDontListAttrName
                            + " for unit leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }

                return bFound;
            }

            public bool CompGet(
                uint uiLBNum, 
                ref ELBReset riLBResetInterval,
                ref uint uiAttachmentCount,
                ref uint uiMaxAttachmentSize,
                ref uint uiDecayDays,
                ref bool bArbitrationRequired,
                ref bool bIsTeam,
                ref CELOConfig eloConfig,
                ref uint uiEntriesPerCacheLine,
                ref uint uiExpirationSeconds,
                ref bool bDontList)
            {
                string sValue = null;
                bool bFound = false;
                if (CompSettingGet(uiLBNum, CTitleXml.LBResetAttrName, ref sValue))
                {
                    try
                    {
                        riLBResetInterval = (ELBReset)Int32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBResetAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer valid for a leaderboard reset interval. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBMaxAttachCountAttrName, ref sValue))
                {
                    try
                    {
                        uiAttachmentCount = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBMaxAttachCountAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBMaxAttachSizeAttrName, ref sValue))
                {
                    try
                    {
                        uiMaxAttachmentSize = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBMaxAttachSizeAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBDecayDaysAttrName, ref sValue))
                {
                    try
                    {
                        uiDecayDays = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBDecayDaysAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBArbReqAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bArbitrationRequired = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bArbitrationRequired = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBArbReqAttrName
                            + " for leaderboard "
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBIsTeamAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bIsTeam = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bIsTeam = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBIsTeamAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }
                // see note about ELO setting in LBGet
                if (CompSettingGet(uiLBNum, CTitleXml.LBELOAttrName, ref sValue))
                {
                    try
                    {
                        eloConfig = CELOConfig.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBELOAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an ELO configuration. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBEntriesPerCacheLineAttrName, ref sValue))
                {
                    try
                    {
                        uiEntriesPerCacheLine = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBEntriesPerCacheLineAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBExpirationSecondsAttrName, ref sValue))
                {
                    try
                    {
                        uiExpirationSeconds = UInt32.Parse(sValue);
                        bFound = true;
                    }
                    catch (Exception e)
                    {
                        // we don't want a bad value in a file that could be modified
                        // by hand to cause a fatal error, so we'll treat this like
                        // the setting was not present, and simply log the error
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBExpirationSecondsAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as an integer. String value is "
                            + sValue
                            + " exception details: "
                            + e.Message;
                        m_log.LogFile(sErr);
                    }
                }
                if (CompSettingGet(uiLBNum, CTitleXml.LBDontListAttrName, ref sValue))
                {
                    sValue = sValue.Trim().ToLower();
                    if (sValue == "true")
                    {
                        bDontList = true;
                        bFound = true;
                    }
                    else if (sValue == "false")
                    {
                        bDontList = false;
                        bFound = true;
                    }
                    else
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository.TitleLBGet: "
                            + "Could not parse value of setting "
                            + CTitleXml.LBDontListAttrName
                            + " for leaderboard ."
                            + uiLBNum
                            + " as 'true' or 'false'. String value is "
                            + sValue;
                        m_log.LogFile(sErr);
                    }
                }

                return bFound;
            }

            public void LBDelete(uint uiLBNum)
            {
                LBDelete(LBXpath(uiLBNum));
                return;
            }

            public void UnitDelete(uint uiLBNum)
            {
                LBDelete(UnitXpath(uiLBNum));
                return;
            }

            public void CompDelete(uint uiLBNum)
            {
                LBDelete(CompXpath(uiLBNum));
                return;
            }

            public void LBDelete(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this leaderboard does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Node does not exist, no need to delete it.");
                }
                else
                {
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Deleting leaderboard node matching "
                        + sXpath);
                    xmlNode.ParentNode.RemoveChild(xmlNode);
                    m_bChanged = true;
                }
                return;
            }

            private bool LBSettingGet(
                uint uiLBNum,
                string sSettingName, 
                ref string sValue)
            {
                return LBSettingGet(LBSettingXpath(uiLBNum, sSettingName), ref sValue);
            }

            private bool UnitSettingGet(
                uint uiLBNum,
                string sSettingName, 
                ref string sValue)
            {
                return LBSettingGet(UnitSettingXpath(uiLBNum, sSettingName), ref sValue);
            }

            private bool CompSettingGet(
                uint uiLBNum,
                string sSettingName, 
                ref string sValue)
            {
                return LBSettingGet(CompSettingXpath(uiLBNum, sSettingName), ref sValue);
            }

            private bool LBSettingGet(
                string sXpath, 
                ref string sValue)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not find node matching "
                        + sXpath);
                    return false;
                }

                sValue = xmlNode.Value;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found value of "
                    + sValue
                    + " in node matching "
                    + sXpath);
                return true;
            }

            private void LBSettingSet(
                uint uiLBNum,
                string sSettingName, 
                string sValue)
            {
                // get the parent leaderboards element ...
                string sXpath = LBsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeLBs = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeLBs == null)
                {
                    // create it
                    xmlNodeLBs = TitleChildElemCreate(LBsElemName);
                }

                LBSettingSet(xmlNodeLBs, LBXpath(uiLBNum), uiLBNum, sSettingName, sValue);
                return;
            }

            private void UnitSettingSet(
                uint uiLBNum,
                string sSettingName, 
                string sValue)
            {
                // get the parent unit leaderboards  element ...
                string sXpath = UnitsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeUnits = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeUnits == null)
                {
                    // create it
                    xmlNodeUnits = TitleChildElemCreate(UnitsElemName);
                }

                LBSettingSet(xmlNodeUnits, UnitXpath(uiLBNum), uiLBNum, sSettingName, sValue);
                return;
            }

            private void CompSettingSet(
                uint uiLBNum,
                string sSettingName, 
                string sValue)
            {
                // get the parent competition template element ...
                string sXpath = CompsElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeComps = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeComps == null)
                {
                    // create it
                    xmlNodeComps = TitleChildElemCreate(CompsElemName);
                }

                LBSettingSet(xmlNodeComps, CompXpath(uiLBNum), uiLBNum, sSettingName, sValue);
                return;
            }

            private void LBSettingSet(
                XmlNode xmlNodeParent,
                string sXpath,
                uint uiLBNum,
                string sSettingName,
                string sValue)
            {
                // get the existing leaderboard element if it exists
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // leaderboard element doesn't exist, create it
                    xmlNode = LBElemCreate(xmlNodeParent, uiLBNum);
                }

                // when we get here, xmlNode is pointing to the
                // leaderboard node. All we have to do is set the attribute
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting attribute "
                    + sSettingName
                    + " to "
                    + sValue
                    + " on "
                    + LBElemName
                    + " element for leaderboard id "
                    + uiLBNum);
                XmlElement xmlElem = (XmlElement)xmlNode;
                xmlElem.SetAttribute(sSettingName, sValue);
                m_bChanged = true;
                return;
            }

            private void LBSettingDelete(
                uint uiLBNum,
                string sSettingName)
            {
                LBSettingDelete(LBXpath(uiLBNum), sSettingName);
                return;
            }

            private void UnitSettingDelete(
                uint uiLBNum,
                string sSettingName)
            {
                LBSettingDelete(UnitXpath(uiLBNum), sSettingName);
                return;
            }

            private void CompSettingDelete(
                uint uiLBNum,
                string sSettingName)
            {
                LBSettingDelete(CompXpath(uiLBNum), sSettingName);
                return;
            }

            private void LBSettingDelete(
                string sXpath,
                string sSettingName)
            {
                // get the existing setting node if it exists
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the leaderboard element does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + LBElemName
                        + " element matching "
                        + sXpath
                        + " does not exist. Nothing to delete.");
                    return;
                }

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Removing "
                    + sSettingName 
                    + " attribute from "
                    + LBElemName
                    + " for element matching "
                    + sXpath);
                XmlElement xmlElem = (XmlElement)xmlNode;
                xmlElem.RemoveAttribute(sSettingName);
                m_bChanged = true;
                return;
            }

            private XmlElement LBElemCreate(
                XmlNode xmlNodeParent,
                uint uiLBNum)
            {
                // create the new element
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Creating "
                    + LBElemName
                    + " element");
                XmlElement xmlElem = m_xmlDoc.CreateElement(LBElemName);

                // set the number attribute
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + LBNumAttrName
                    + " to "
                    + uiLBNum
                    + " on "
                    + LBElemName
                    + " element");
                xmlElem.SetAttribute(LBNumAttrName, uiLBNum.ToString());

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending new "
                    + LBElemName
                    + " to "
                    + xmlNodeParent.Name
                    + " element.");
                xmlNodeParent.AppendChild(xmlElem);
                return xmlElem;
            }

            private XmlElement TitleChildElemCreate(string sElemName)
            {
                // get the title element
                string sXpath = TitleElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting parent node matching "
                    + sXpath);
                XmlNode xmlNodeTitle = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeTitle == null)
                {
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "Unable to find title node for titleid "
                        + m_tid.sTitleIdHexNoPrefix;
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                // create the new element
                XmlElement xmlElem = m_xmlDoc.CreateElement(sElemName);

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending "
                    + sElemName
                    + " child node to node matching "
                    + sXpath);
                xmlNodeTitle.AppendChild(xmlElem);
                return xmlElem;
            }

            public SortedList LBDescGetList(uint uiLBNum)
            {
                return LBDescGetList(LBDescListXpath(uiLBNum));
            }
            public SortedList UnitDescGetList(uint uiLBNum)
            {
                return LBDescGetList(UnitDescListXpath(uiLBNum));
            }
            public SortedList CompDescGetList(uint uiLBNum)
            {
                return LBDescGetList(CompDescListXpath(uiLBNum));
            }
            public SortedList LBDescGetList(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);

                return DescListToSortedList(xmlNodeList);
            }

            public void LBDescSet(
                uint uiLBNum,
                CLocale locale,
                string sDesc)
            {
                LBDescSet(
                    LBXpath(uiLBNum),
                    LBDescElemXpath(uiLBNum, locale),
                    locale,
                    sDesc);
                return;
            }
            public void UnitDescSet(
                uint uiLBNum,
                CLocale locale,
                string sDesc)
            {
                LBDescSet(
                    UnitXpath(uiLBNum),
                    UnitDescElemXpath(uiLBNum, locale),
                    locale,
                    sDesc);
                return;
            }
            public void CompDescSet(
                uint uiLBNum,
                CLocale locale,
                string sDesc)
            {
                LBDescSet(
                    CompXpath(uiLBNum),
                    CompDescElemXpath(uiLBNum, locale),
                    locale,
                    sDesc);
                return;
            }
            public void LBDescSet(
                string sXpathParent,
                string sXpathDesc,
                CLocale locale,
                string sDesc)
            {
                // does the description already exist?
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpathDesc);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpathDesc);
                if (xmlNode != null)
                {
                    // update the existing description
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting  "
                        + DescDescAttrName
                        + " attribute to "
                        + sDesc
                        + " on "
                        + xmlElem.Name
                        + " element");
                    xmlElem.SetAttribute(DescDescAttrName, sDesc);
                    return;
                }

                // the element for this locale doesn't yet exist

                // get the parent element
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpathParent);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpathParent);
                if (xmlNode == null)
                {
                    // leaderboard node does not exist, should be 
                    // created using LBSet before adding descriptions
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "Cannot add a leaderboard description because the parent node "
                        + " does not exist in title xml.";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                DescAdd(xmlNode, locale, sDesc);
                m_bChanged = true;
                return;
            }

            public void LBDescDelete(
                uint uiLBNum,
                CLocale locale)
            {
                LBDescDelete(LBDescElemXpath(uiLBNum, locale));
                return;
            }
            public void UnitDescDelete(
                uint uiLBNum,
                CLocale locale)
            {
                LBDescDelete(UnitDescElemXpath(uiLBNum, locale));
                return;
            }
            public void CompDescDelete(
                uint uiLBNum,
                CLocale locale)
            {
                LBDescDelete(CompDescElemXpath(uiLBNum, locale));
                return;
            }
            public void LBDescDelete(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No description found matching "
                        + sXpath
                        + ". Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting descriptoin matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }


            public void LBDescDeleteAll(
                uint uiLBNum)
            {
                LBDescDeleteAll(LBDescsElemXpath(uiLBNum));
                return;
            }
            public void UnitDescDeleteAll(
                uint uiLBNum)
            {
                LBDescDeleteAll(UnitDescsElemXpath(uiLBNum));
                return;
            }
            public void CompDescDeleteAll(
                uint uiLBNum)
            {
                LBDescDeleteAll(CompDescsElemXpath(uiLBNum));
                return;
            }
            public void LBDescDeleteAll(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found. Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting descriptions matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            private void DescAdd(
                XmlNode xmlNode, 
                CLocale locale, 
                string sDesc)
            {
                // does this node have a child descriptions node?
                string sXpath = DescsElemName;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeDescs = xmlNode.SelectSingleNode(sXpath);
                if (xmlNodeDescs == null)
                {
                    // need to add the descriptions element to the document
                    XmlElement xmlElemDescs = m_xmlDoc.CreateElement(DescsElemName);
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Appending new "
                        + DescsElemName
                        + " element to "
                        + xmlNode.Name
                        + " element.");
                    xmlNode.AppendChild(xmlElemDescs);
                    xmlNodeDescs = xmlElemDescs;
                }

                // xmlNodeDescs now points to the Descriptions element,
                // add a new Description child element
                XmlElement xmlElemDesc = m_xmlDoc.CreateElement(DescElemName);
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + DescLocaleAttrName
                    + " attribute to "
                    + locale.ToString()
                    + " on "
                    + DescElemName
                    + " element.");
                xmlElemDesc.SetAttribute(DescLocaleAttrName, locale.ToString());
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + DescDescAttrName
                    + " attribute to "
                    + sDesc
                    + " on "
                    + DescElemName
                    + " element.");
                xmlElemDesc.SetAttribute(DescDescAttrName, sDesc);
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending new "
                    + DescElemName
                    + " element to "
                    + xmlNodeDescs.Name
                    + " element.");
                xmlNodeDescs.AppendChild(xmlElemDesc);
            }

            private SortedList DescListToSortedList(XmlNodeList xmlNodeList)
            {
                SortedList sl = new SortedList();
                // each node in the xmlNodeList should be an description element
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    XmlElement xmlElement = (XmlElement)xmlNode;
                    if (xmlElement.Name != DescElemName)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A node in thie xml node list is not a "
                            + DescElemName
                            + " element. This element will be ignored.");
                        continue;
                    }

                    string sLocale = xmlElement.GetAttribute(DescLocaleAttrName);
                    if (sLocale == null || sLocale == String.Empty)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + DescElemName
                            + " element did not have a "
                            + DescLocaleAttrName
                            + " attribute. This element will be ignored.");
                        continue;
                    }

                    // make sure the locale is valid
                    try
                    {
                        CLocale locale = new CLocale(sLocale);
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + DescElemName
                            + " element contained a "
                            + DescLocaleAttrName
                            + " attribute with invalid locale of "
                            + sLocale
                            + ". This element will be ignored.");
                        continue;
                    }

                    if (sl.ContainsKey(sLocale))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + DescElemName
                            + " element contained a "
                            + DescLocaleAttrName
                            + " attribute with a duplicate locale of "
                            + sLocale
                            + ". This element will be ignored.");
                        continue;
                    }

                    string sDesc = xmlElement.GetAttribute(DescDescAttrName);
                    if (sDesc == null || sDesc == String.Empty)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + DescElemName
                            + " element did not have a "
                            + DescDescAttrName
                            + " attribute. This element will be ignored.");
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found description "
                        + sDesc
                        + " for locale "
                        + sLocale);

                    sl.Add(sLocale, sDesc);
                }
                return sl;
            }

            public SortedList LBAttrGetList(uint uiLBNum)
            {
                return LBAttrGetList(LBAttrListXpath(uiLBNum));
            }
            public SortedList UnitAttrGetList(uint uiLBNum)
            {
                return LBAttrGetList(UnitAttrListXpath(uiLBNum));
            }
            public SortedList CompAttrGetList(uint uiLBNum)
            {
                return LBAttrGetList(CompAttrListXpath(uiLBNum));
            }
            public SortedList LBAttrGetList(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);

                return AttrListToSortedList(xmlNodeList);
            }

            public void LBAttrSet(
                uint uiLBNum,
                uint uiId,
                bool bIsPuid)
            {
                LBAttrSet(
                    LBXpath(uiLBNum),
                    LBAttrElemXpath(uiLBNum, uiId),
                    uiId,
                    bIsPuid);
                return;
            }
            public void UnitAttrSet(
                uint uiLBNum,
                uint uiId,
                bool bIsPuid)
            {
                LBAttrSet(
                    UnitXpath(uiLBNum),
                    UnitAttrElemXpath(uiLBNum, uiId),
                    uiId,
                    bIsPuid);
                return;
            }
            public void CompAttrSet(
                uint uiLBNum,
                uint uiId,
                bool bIsPuid)
            {
                LBAttrSet(
                    CompXpath(uiLBNum),
                    CompAttrElemXpath(uiLBNum, uiId),
                    uiId,
                    bIsPuid);
                return;
            }
            public void LBAttrSet(
                string sXpathParent,
                string sXpath,
                uint uiId,
                bool bIsPuid)
            {
                // does the attribute already exist?
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    // update the existing attribute
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting attribute "
                        + AttrIsPuidAttrName
                        + " to "
                        + bIsPuid
                        + " on "
                        + AttrElemName
                        + " element");
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    xmlElem.SetAttribute(AttrIsPuidAttrName, bIsPuid.ToString());
                    return;
                }

                // the element for this id doesn't yet exist

                // get the leaderboard element
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpathParent);
                if (xmlNode == null)
                {
                    // leaderboard node does not exist, should be 
                    // created using LBSet before adding attributes
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "Cannot add a web attribute because leaderboard"
                        + " does not exist in title xml.";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                AttrAdd(xmlNode, uiId, bIsPuid);
                m_bChanged = true;
                return;
            }

            public void LBAttrDelete(
                uint uiLBNum,
                uint uiId)
            {
                LBAttrDelete(LBAttrElemXpath(uiLBNum, uiId));
                return;
            }
            public void UnitAttrDelete(
                uint uiLBNum,
                uint uiId)
            {
                LBAttrDelete(UnitAttrElemXpath(uiLBNum, uiId));
                return;
            }
            public void CompAttrDelete(
                uint uiLBNum,
                uint uiId)
            {
                LBAttrDelete(CompAttrElemXpath(uiLBNum, uiId));
                return;
            }
            public void LBAttrDelete(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No attribute found matching "
                        + sXpath
                        + ". Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public void LBAttrDeleteAll(
                uint uiLBNum)
            {
                LBAttrDeleteAll(LBAttrsElemXpath(uiLBNum));
                return;
            }
            public void UnitAttrDeleteAll(
                uint uiLBNum)
            {
                LBAttrDeleteAll(UnitAttrsElemXpath(uiLBNum));
                return;
            }
            public void CompAttrDeleteAll(
                uint uiLBNum)
            {
                LBAttrDeleteAll(CompAttrsElemXpath(uiLBNum));
                return;
            }
            public void LBAttrDeleteAll(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found. Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public bool AlternateTitleIdsGetList(ref uint[] aAlternateTitleIds)
            {
                SortedList sl = new SortedList();
                aAlternateTitleIds = null;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository.AlternateTitleIdsGetList: "
                    + "Getting nodes matching "
                    + AlternateTitleIdElemXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(AlternateTitleIdElemXpath);
                if(xmlNodeList.Count == 0)
                    return false;

                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    // each node in the list should be an alternate title id element.
                    // grab the value of the titleid attribute, and add it to the array list
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    XmlAttribute xmlAttr = xmlElem.Attributes[AlternateTitleIdAttrName];
                    if (xmlAttr == null)
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + AlternateTitleIdElemName
                            + " element with no "
                            + AlternateTitleIdAttrName
                            + " attribute.");
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found alternate title id "
                        + xmlAttr.Value);

                    uint uiAlternateTitleId;
                    try
                    {
                        uiAlternateTitleId = UInt32.Parse(xmlAttr.Value, NumberStyles.HexNumber);
                    }
                    catch (Exception e)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "Error parsing alternate title id "
                            + xmlAttr.Value
                            + " as an integer. This "
                            + AlternateTitleIdElemName
                            + " element will be ignored. Exception details: "
                            + e.Message);
                        continue;
                    }

                    // if we get here, we have the alternate title id in uiAlternateTitleId

                    if (sl.ContainsKey(uiAlternateTitleId))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "Alternate title id "
                            + uiAlternateTitleId
                            + " is already in the list, this element will be ignored.");
                        continue;
                    }

                    sl.Add(uiAlternateTitleId, uiAlternateTitleId);
                }

                if(sl.Count == 0)
                    return false;

                // copy any alternate title ids found to an array and return it
                aAlternateTitleIds = new uint[sl.Count];
                for (int i = 0; i < sl.Count; ++i)
                {
                    aAlternateTitleIds[i] = (uint)sl.GetByIndex(i);
                }

                return true;
            }

            public void AlternateTitleIdSet(CTitleId tidAlternate)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Adding alternate title id "
                    + tidAlternate.sTitleIdHexNoPrefix);

                //  If we don't yet have an AlternateTitleIds node, create it
                XmlNode xmlIdsNode = m_xmlDoc.SelectSingleNode(AlternateTitleIdsElemXpath);
                if (xmlIdsNode == null)
                {
                    XmlNode xmlTitleNode = m_xmlDoc.SelectSingleNode(TitleElemXpath);
                    if(xmlTitleNode == null)
                        throw new CRepositoryException();

                    xmlIdsNode = m_xmlDoc.CreateElement(AlternateTitleIdsElemName);
                    xmlTitleNode.AppendChild(xmlIdsNode);

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Created node " + AlternateTitleIdsElemName);
                }
                else
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found node " + AlternateTitleIdsElemName);

                //  Verify that the specific alt title id doesn't exist yet.
                XmlNode xmlIdNode = m_xmlDoc.SelectSingleNode(AlternateTitleIdAttrElemXpath(tidAlternate));
                if (xmlIdNode != null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Alternate title id " + tidAlternate.sTitleIdHexNoPrefix 
                        + " already exists.");

                    return;
                }

                //  Create and add new alt title id element
                xmlIdNode = m_xmlDoc.CreateElement(AlternateTitleIdElemName);
                ((XmlElement)xmlIdNode).SetAttribute(AlternateTitleIdAttrName, tidAlternate.sTitleIdHexNoPrefix);
                xmlIdsNode.AppendChild(xmlIdNode);

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Created and added node "
                    + AlternateTitleIdElemName
                    + " with titleid = "
                    + tidAlternate.sTitleIdHexNoPrefix);

                m_bChanged = true;
                return;
            }

            public void AlternateTitleIdDelete(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No attribute found matching "
                        + sXpath
                        + ". Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }
            
            public void AlternateTitleIdDelete(CTitleId tidAlternate)
            {
                AlternateTitleIdDelete(AlternateTitleIdAttrElemXpath(tidAlternate));
                return;
            }

            public void AlternateTitleIdDeleteAll()
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node "
                    + AlternateTitleIdsElemXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(AlternateTitleIdsElemXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No alternate title ids to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + AlternateTitleIdsElemXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public bool LSPSiteGetList(ref CSite[] sites)
            {
                SortedList sl = new SortedList();
                sites = null;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository.LSPSiteGetList: "
                    + "Getting nodes matching "
                    + LSPSiteElemXpath);

                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPSiteElemXpath);
                if(xmlNodeList.Count == 0)
                    return false;

                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    CSite newsite = null;
                    //each node contains site information
                    try
                    {
                        newsite = new CSite( xmlNode );
                    }
                    catch ( Exception e )
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + LSPSiteElemName
                            + "; element has incorrect XML format.  ERROR:  " + e.Message );
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found Site: "
                        + newsite.SiteId );

                    // if we get here, we have the alternate title id in uiLSPSite
                    if (sl.ContainsKey(newsite.SiteId))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "LSP Site "
                            + newsite.SiteId
                            + " is already in the list, this element will be ignored.");
                        continue;
                    }

                    sl.Add(newsite.SiteId, newsite);
                }

                if(sl.Count == 0)
                    return false;

                // copy any alternate title ids found to an array and return it
                sites = new CSite[sl.Count];
                for (int i = 0; i < sl.Count; ++i)
                {
                    sites[i] = (CSite)sl.GetByIndex(i);
                }

                return true;
            }

            public void LSPSiteSet(CSite site)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Adding site "
                    + site.SiteId );

                //  If we don't yet have an LSPSite node, create it
                XmlNode xmlIdsNode = m_xmlDoc.SelectSingleNode(LSPSitesElemXpath);
                if (xmlIdsNode == null)
                {
                    XmlNode xmlTitleNode = m_xmlDoc.SelectSingleNode(TitleElemXpath);
                    if(xmlTitleNode == null)
                    {
                        throw new CRepositoryException();
                    }

                    xmlIdsNode = m_xmlDoc.CreateElement(LSPSitesElemName);
                    xmlTitleNode.AppendChild(xmlIdsNode);

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Created node " + LSPSitesElemName);
                }
                else
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found node " + LSPSitesElemName);
                }

                //  Verify that the specific site doesn't exist yet.
                bool siteExists = false;
                XmlNode existingSiteNode = null;
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPSiteElemXpath);

                if(xmlNodeList.Count == 0)
                {
                    siteExists = false;
                }
                else
                {
                    // scan the Site nodes for the entry.
                    foreach (XmlNode xmlNode in xmlNodeList)
                    {
                        CSite newsite = null;
                        //each node contains site information
                        try
                        {
                            newsite = new CSite( xmlNode );
                        
                            // these sites are the same but may have different information.
                            //   check the id as ooppsed to the entire object.
                            if ( site.SiteId == newsite.SiteId )
                            {
                                siteExists = true;
                                existingSiteNode = xmlNode;
                                break;
                            }
                        }
                        catch ( Exception e )
                        {
                            m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                                + "Ignoring "
                                + LSPSiteElemName
                                + "; element has incorrect XML format.  ERROR:  " + e.Message );
                            continue;
                        }
                    }
                }

                // if we found the site... remove it
                if ( siteExists )
                {
                    existingSiteNode.ParentNode.RemoveChild(existingSiteNode);                    
                }

                //  Create and add new alt title id element
                xmlIdsNode.AppendChild( site.ToXml( m_xmlDoc ) );

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Created and added node "
                    + LSPSiteElemName
                    + " with siteid = "
                    + site.SiteId.ToString() );

                m_bChanged = true;
                return;
            }

            public void LSPSiteDelete(CSite site)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching Site Id"
                    + site.SiteId);

                //  Verify that the specific site doesn't exist yet.
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPSiteElemXpath);
                if ( xmlNodeList.Count == 0 )
                {
                    return;
                }

                // scan the Site nodes for the entry.
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    CSite newsite = null;
                    //each node contains site information
                    try
                    {
                        newsite = new CSite( xmlNode );
                        
                        // these sites are the same but may have different information.
                        //   check the id as ooppsed to the entire object.
                        if ( site.SiteId == newsite.SiteId )
                        {
                            xmlNode.ParentNode.RemoveChild(xmlNode);
                            break;
                        }
                    }
                    catch ( Exception e )
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + LSPSiteElemName
                            + "; element has incorrect XML format.  ERROR:  " + e.Message );
                        continue;
                    }
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting site node with id = "
                    + site.SiteId );
                m_bChanged = true;
                return;
            }            

            public void LSPSiteDeleteAll()
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node "
                    + LSPSitesElemXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(LSPSitesElemXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No LSP Sites to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + LSPSitesElemXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public bool LSPServiceGetList(ref CService[] services)
            {
                SortedList sl = new SortedList();
                services = null;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository.LSPServiceGetList: "
                    + "Getting nodes matching "
                    + LSPServiceElemXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPServiceElemXpath);
                if(xmlNodeList.Count == 0)
                    return false;

                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    CService newservice = null;
                    //each node contains site information
                    try
                    {
                        newservice = new CService( xmlNode );
                    }
                    catch ( Exception e )
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + LSPServiceElemName
                            + "; element has incorrect XML format.  ERROR:  " + e.Message );
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found Service: "
                        + newservice.ServiceId );

                    // if we get here, we have the alternate title id in uiLSPService
                    if (sl.ContainsKey(newservice.ServiceId))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "LSP Service "
                            + newservice.ServiceId
                            + " is already in the list, this element will be ignored.");
                        continue;
                    }

                    sl.Add(newservice.ServiceId, newservice);
                }

                if(sl.Count == 0)
                    return false;

                // copy any alternate title ids found to an array and return it
                services = new CService[sl.Count];
                for (int i = 0; i < sl.Count; ++i)
                {
                    services[i] = (CService)sl.GetByIndex(i);
                }

                return true;
            }

            public void LSPServiceSet(CService service)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Adding service "
                    + service.ServiceId );

                //  If we don't yet have an LSPService node, create it
                XmlNode xmlIdsNode = m_xmlDoc.SelectSingleNode(LSPServicesElemXpath);
                if (xmlIdsNode == null)
                {
                    XmlNode xmlTitleNode = m_xmlDoc.SelectSingleNode(TitleElemXpath);
                    if(xmlTitleNode == null)
                    {
                        throw new CRepositoryException();
                    }

                    xmlIdsNode = m_xmlDoc.CreateElement(LSPServicesElemName);
                    xmlTitleNode.AppendChild(xmlIdsNode);

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Created node " + LSPServicesElemName);
                }
                else
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found node " + LSPServicesElemName);
                }

                //  Verify that the specific service doesn't exist yet.
                bool serviceExists = false;
                XmlNode existingServiceNode = null;
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPServicesElemXpath);

                if(xmlNodeList.Count == 0)
                {
                    serviceExists = false;
                }
                else
                {
                    // scan the Site nodes for the entry.
                    foreach (XmlNode xmlNode in xmlNodeList)
                    {
                        CService newservice = null;
                        //each node contains site information
                        try
                        {
                            newservice = new CService( xmlNode );
                        
                            // these sites are the same but may have different information.
                            //   check the id as ooppsed to the entire object.
                            if ( service.ServiceId == newservice.ServiceId )
                            {
                                serviceExists = true;
                                existingServiceNode = xmlNode;
                                break;
                            }
                        }
                        catch ( Exception e )
                        {
                            m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                                + "Ignoring "
                                + LSPServiceElemName
                                + "; element has incorrect XML format.  ERROR:  " + e.Message );
                            continue;
                        }
                    }
                }

                // if we found the site... remove it
                if ( serviceExists )
                {
                    existingServiceNode.ParentNode.RemoveChild(existingServiceNode);                    
                }

                //  Create and add new alt title id element
                xmlIdsNode.AppendChild( service.ToXml( m_xmlDoc ) );

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Created and added node "
                    + LSPServiceElemName
                    + " with serviceid = "
                    + service.ServiceId.ToString() );

                    m_bChanged = true;
                return;
            }

            public void LSPServiceDelete(CService service)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching Service Id "
                    + service.ServiceId );

                //  Verify that the specific site doesn't exist yet.
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(LSPServiceElemXpath);
                if ( xmlNodeList.Count == 0 )
                {
                    return;
                }

                // scan the service nodes for the entry.
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    CService newservice = null;
                    //each node contains site information
                    try
                    {
                        newservice = new CService( xmlNode );
                        
                        // these services are the same but may have different information.
                        //   check the id as ooppsed to the entire object.
                        if ( service.ServiceId == newservice.ServiceId )
                        {
                            xmlNode.ParentNode.RemoveChild(xmlNode);
                            break;
                        }
                    }
                    catch ( Exception e )
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Ignoring "
                            + LSPServiceElemName
                            + "; element has incorrect XML format.  ERROR:  " + e.Message );
                        continue;
                    }
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting service node with id = "
                    + service.ServiceId );
                m_bChanged = true;
                return;
            }           

            public void LSPServiceDeleteAll()
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node "
                    + LSPServicesElemXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(LSPServicesElemXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No LSP Sites to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting node matching "
                    + LSPServicesElemXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            private SortedList AttrListToSortedList(XmlNodeList xmlNodeList)
            {
                SortedList sl = new SortedList();
                // each node in the xmlNodeList should be an Attribute element
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    XmlElement xmlElement = (XmlElement)xmlNode;
                    if (xmlElement.Name != AttrElemName)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A node in thie xml node list is not a "
                            + AttrElemName
                            + " element. This element will be ignored.");
                        continue;
                    }

                    string sId = xmlElement.GetAttribute(AttrIdAttrName);
                    if (sId == null || sId == String.Empty)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + AttrElemName
                            + " element did not have a "
                            + AttrIdAttrName
                            + " attribute. This element will be ignored.");
                        continue;
                    }

                    // make sure the id is valid
                    uint uiId;
                    try
                    {
                        uiId = UInt32.Parse(sId);
                    }
                    catch (Exception)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + AttrElemName
                            + " element contained a "
                            + AttrIdAttrName
                            + " attribute with invalid locale of "
                            + sId
                            + ". This element will be ignored.");
                        continue;
                    }

                    if (sl.ContainsKey(uiId))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + AttrElemName
                            + " element contained a "
                            + AttrIdAttrName
                            + " attribute with a duplicate id of "
                            + sId
                            + ". This element will be ignored.");
                        continue;
                    }

                    string sIsPuid = xmlElement.GetAttribute(AttrIsPuidAttrName);
                    if (sIsPuid == null || sIsPuid == String.Empty)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + AttrElemName
                            + " element did not have a "
                            + AttrIsPuidAttrName
                            + " attribute. This element will be ignored.");
                        continue;
                    }

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found IsPuid equal to "
                        + sIsPuid
                        + " for id "
                        + sId);

                    bool bIsPuid;
                    if (sIsPuid.Trim().ToLower() == "false")
                    {
                        bIsPuid = false;
                    }
                    else if (sIsPuid.Trim().ToLower() == "true")
                    {
                        bIsPuid = true;
                    }
                    else
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "The value for the "
                            + AttrIsPuidAttrName
                            + " of "
                            + sIsPuid
                            + " was not 'true' or 'false'. This element will be ignored.");
                        continue;
                    }

                    sl.Add(uiId, bIsPuid);
                }
                return sl;
            }

            private void AttrAdd(
                XmlNode xmlNode, 
                uint uiId, 
                bool bIsPuid)
            {
                // does this node have a child descriptions node?
                string sXpath = AttrsElemName;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeAttrs = xmlNode.SelectSingleNode(sXpath);
                if (xmlNodeAttrs == null)
                {
                    // need to add the attributes element to the document
                    XmlElement xmlElemAttrs = m_xmlDoc.CreateElement(AttrsElemName);
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Appending new "
                        + AttrsElemName
                        + " element to "
                        + xmlNode.Name
                        + " element.");
                    xmlNode.AppendChild(xmlElemAttrs);
                    xmlNodeAttrs = xmlElemAttrs;
                }

                // xmlNodeAttrs now points to the Attributes element,
                // add a new Attribute child element
                XmlElement xmlElemAttr = m_xmlDoc.CreateElement(AttrElemName);
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + AttrIdAttrName
                    + " attribute to "
                    + uiId.ToString()
                    + " on "
                    + AttrElemName
                    + " element.");
                xmlElemAttr.SetAttribute(AttrIdAttrName, uiId.ToString());
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + AttrIsPuidAttrName
                    + " attribute to "
                    + bIsPuid.ToString()
                    + " on "
                    + AttrElemName
                    + " element.");
                xmlElemAttr.SetAttribute(AttrIsPuidAttrName, bIsPuid.ToString());
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending new "
                    + AttrElemName
                    + " element to "
                    + xmlNodeAttrs.Name
                    + " element.");
                xmlNodeAttrs.AppendChild(xmlElemAttr);
            }

            public string[] LBValueGetList(uint uiLBNum)
            {
                return LBValueGetList(LBValueListXpath(uiLBNum));
            }
            public string[] UnitValueGetList(uint uiLBNum)
            {
                return LBValueGetList(UnitValueListXpath(uiLBNum));
            }
            public string[] CompValueGetList(uint uiLBNum)
            {
                return LBValueGetList(CompValueListXpath(uiLBNum));
            }
            public string[] LBValueGetList(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);

                return ValueListToStringArray(xmlNodeList);
            }

            public bool LBValueGet(
                uint uiLBNum, 
                string sName, 
                ref EWebValueReturnType returnType,
                ref string sFormula)
            {
                return LBValueGet(
                    LBValueElemXpath(uiLBNum, sName),
                    LBValueFormulaCDataXpath(uiLBNum, sName),
                    ref returnType,
                    ref sFormula);
            }
            public bool UnitValueGet(
                uint uiLBNum, 
                string sName, 
                ref EWebValueReturnType returnType,
                ref string sFormula)
            {
                return LBValueGet(
                    UnitValueElemXpath(uiLBNum, sName),
                    UnitValueFormulaCDataXpath(uiLBNum, sName),
                    ref returnType,
                    ref sFormula);
            }
            public bool CompValueGet(
                uint uiLBNum, 
                string sName, 
                ref EWebValueReturnType returnType,
                ref string sFormula)
            {
                return LBValueGet(
                    CompValueElemXpath(uiLBNum, sName),
                    CompValueFormulaCDataXpath(uiLBNum, sName),
                    ref returnType,
                    ref sFormula);
            }
            public bool LBValueGet(
                string sXpath,
                string sXpathCDATA,
                ref EWebValueReturnType returnType,
                ref string sFormula)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // this value doesn't exist
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching node found.");
                    return false;
                }

                XmlElement xmlElem = (XmlElement)xmlNode;
                string sVal = xmlElem.GetAttribute(ValueRetAttrName);
                if (sVal == null || sVal == String.Empty)
                {
                    // this value doesn't exist
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No return type specified in "
                        + ValueElemName
                        + " element. This element will be ignored.");
                    return false;
                }

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpathCDATA);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpathCDATA);
                if (xmlNode == null)
                {
                    // this value doesn't exist
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not find "
                        + ValueFormulaElemName
                        + " element matching  "
                        + sXpathCDATA
                        + ". This "
                        + ValueElemName
                        + " element will be ignored.");
                    return false;
                }

                try
                {
                    returnType 
                        = (EWebValueReturnType)Enum.Parse(
                        typeof(EWebValueReturnType),
                        sVal,
                        true);
                }
                catch (Exception)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not parse return type of "
                        + sVal
                        + " specified in "
                        + ValueRetAttrName
                        + " attribute in "
                        + ValueElemName
                        + " element matching "
                        + sXpath
                        + ". This element will be ignored.");
                    return false;
                }

                sFormula = xmlNode.Value;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found return type "
                    + returnType
                    + " and formula: "
                    + sFormula);
                return true;
            }

            public void LBValueSet(
                uint uiLBNum, 
                string sName, 
                EWebValueReturnType returnType,
                string sFormula)
            {
                LBValueSet(
                    LBXpath(uiLBNum),
                    LBValueElemXpath(uiLBNum, sName),
                    LBValueFormulaCDataXpath(uiLBNum, sName),
                    sName,
                    returnType,
                    sFormula);
                return;
            }
            public void UnitValueSet(
                uint uiLBNum, 
                string sName, 
                EWebValueReturnType returnType,
                string sFormula)
            {
                LBValueSet(
                    UnitXpath(uiLBNum),
                    UnitValueElemXpath(uiLBNum, sName),
                    UnitValueFormulaCDataXpath(uiLBNum, sName),
                    sName,
                    returnType,
                    sFormula);
                return;
            }
            public void CompValueSet(
                uint uiLBNum, 
                string sName, 
                EWebValueReturnType returnType,
                string sFormula)
            {
                LBValueSet(
                    CompXpath(uiLBNum),
                    CompValueElemXpath(uiLBNum, sName),
                    CompValueFormulaCDataXpath(uiLBNum, sName),
                    sName,
                    returnType,
                    sFormula);
                return;
            }
            public void LBValueSet(
                string sXpathParent,
                string sXpath,
                string sXpathCDATA,
                string sName,
                EWebValueReturnType returnType,
                string sFormula)
            {
                // does the attribute already exist?
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    // update the existing stuff
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + ValueRetAttrName
                        + " attribute to "
                        + returnType.ToString()
                        + " on "
                        + ValueElemName);
                    xmlElem.SetAttribute(ValueRetAttrName, returnType.ToString());

                    // get the formula cdata
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting node matching "
                        + sXpathCDATA);
                    XmlNode xmlNodeFormula = m_xmlDoc.SelectSingleNode(sXpathCDATA);
                    if (xmlNodeFormula == null)
                    {
                        m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                            + ValueElemName
                            + " missing "
                            + ValueFormulaElemName
                            + " child element. Appending new child element with CDATA section containing "
                            + sFormula);
                        // this shouldn't happen, but we can recover...
                        XmlElement xmlElemFormula = m_xmlDoc.CreateElement(ValueFormulaElemName);
                        XmlCDataSection xmlCData = m_xmlDoc.CreateCDataSection(sFormula);
                        xmlElemFormula.AppendChild(xmlCData);
                        xmlElem.AppendChild(xmlElemFormula);
                        xmlNodeFormula = xmlCData;
                    }

                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + ValueFormulaElemName
                        + " CDATA to "
                        + sFormula
                        + " on "
                        + ValueElemName);
                    xmlNodeFormula.Value = sFormula;
                    return;
                }

                // the element for this id doesn't yet exist

                // get the leaderboard element
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpathParent);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpathParent);
                if (xmlNode == null)
                {
                    // leaderboard node does not exist, should be 
                    // created using LBSet before adding values
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "Cannot add a web value because leaderboard"
                        + " does not exist in title xml.";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                ValueAdd(xmlNode, sName, returnType, sFormula);
                m_bChanged = true;
                return;
            }

            public void LBValueDelete(
                uint uiLBNum,
                string sName)
            {
                LBValueDelete(LBValueElemXpath(uiLBNum, sName));
                return;
            }
            public void UnitValueDelete(
                uint uiLBNum,
                string sName)
            {
                LBValueDelete(UnitValueElemXpath(uiLBNum, sName));
                return;
            }
            public void CompValueDelete(
                uint uiLBNum,
                string sName)
            {
                LBValueDelete(CompValueElemXpath(uiLBNum, sName));
                return;
            }
            public void LBValueDelete(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No element found - nothing to delete.");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + ValueElemName
                    + " element matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public void LBValueDeleteAll(
                uint uiLBNum)
            {
                LBValueDeleteAll(LBValuesElemXpath(uiLBNum));
                return;
            }
            public void UnitValueDeleteAll(
                uint uiLBNum)
            {
                LBValueDeleteAll(UnitValuesElemXpath(uiLBNum));
                return;
            }
            public void CompValueDeleteAll(
                uint uiLBNum)
            {
                LBValueDeleteAll(CompValuesElemXpath(uiLBNum));
                return;
            }
            public void LBValueDeleteAll(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found. Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + ValuesElemName
                    + " element matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            private void ValueAdd(
                XmlNode xmlNode, 
                string sName,
                EWebValueReturnType returnType, 
                string sFormula)
            {
                // does this node have a child values node?
                string sXpath = ValuesElemName;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeValues = xmlNode.SelectSingleNode(sXpath);
                if (xmlNodeValues == null)
                {
                    // need to add the Values element to the document
                    XmlElement xmlElemValues = m_xmlDoc.CreateElement(ValuesElemName);
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Appending new "
                        + ValuesElemName
                        + " element to "
                        + xmlNode.Name
                        + " element.");
                    xmlNode.AppendChild(xmlElemValues);
                    xmlNodeValues = xmlElemValues;
                }

                // xmlNodeValues now points to the Values element,
                // add a new Value child element
                XmlElement xmlElemValue = m_xmlDoc.CreateElement(ValueElemName);

                // add a new Formula child element
                XmlElement xmlElemFormula = m_xmlDoc.CreateElement(ValueFormulaElemName);

                // create a CDATA section to put in the Formula element
                XmlCDataSection xmlCData = m_xmlDoc.CreateCDataSection(sFormula);

                // append the CDATA section as a child of the Formula element
                xmlElemFormula.AppendChild(xmlCData);

                // then append the Formula element to the Value element
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending new "
                    + ValueFormulaElemName
                    + " element to "
                    + ValueElemName
                    + " element with CDATA section containing "
                    + sFormula);
                xmlElemValue.AppendChild(xmlElemFormula);

                // and finally, append the Value node to the Values node
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + ValueRetAttrName
                    + " attribute to "
                    + returnType.ToString()
                    + " on "
                    + ValueElemName);
                xmlElemValue.SetAttribute(ValueRetAttrName, returnType.ToString());
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + ValueNameAttrName
                    + " attribute to "
                    + sName
                    + " on "
                    + ValueElemName);
                xmlElemValue.SetAttribute(ValueNameAttrName, sName);
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Appending new "
                    + ValueElemName
                    + " element to "
                    + xmlNodeValues.Name
                    + " element.");
                xmlNodeValues.AppendChild(xmlElemValue);
            }

            private string[] ValueListToStringArray(XmlNodeList xmlNodeList)
            {
                SortedList sl = new SortedList();
                // each node in the xmlNodeList should be a Value element
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    XmlElement xmlElement = (XmlElement)xmlNode;
                    if (xmlElement.Name != ValueElemName)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A node in thie xml node list is not a "
                            + ValueElemName
                            + " element. This element will be ignored.");
                        continue;
                    }

                    string sName = xmlElement.GetAttribute(ValueNameAttrName);
                    if (sName == null || sName == String.Empty)
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + ValueElemName
                            + " element did not have a "
                            + ValueNameAttrName
                            + " attribute. This element will be ignored.");
                        continue;
                    }

                    if (sl.ContainsKey(sName))
                    {
                        m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                            + "A "
                            + ValueElemName
                            + " element contained a "
                            + ValueNameAttrName
                            + " attribute with a duplicate id of "
                            + sName
                            + ". This element will be ignored.");
                        continue;
                    }
                    sl.Add(sName, sName);
                }

                string[] rgs = new string[sl.Count];
                for (int i = 0; i < rgs.Length; ++i)
                {
                    rgs[i] = (string)sl.GetByIndex(i);
                }
                return rgs;
            }

            public SortedList LBValueDescGetList(uint uiLBNum, string sName)
            {
                return LBValueDescGetList(LBValueDescListXpath(uiLBNum, sName));
            }
            public SortedList UnitValueDescGetList(uint uiLBNum, string sName)
            {
                return LBValueDescGetList(UnitValueDescListXpath(uiLBNum, sName));
            }
            public SortedList CompValueDescGetList(uint uiLBNum, string sName)
            {
                return LBValueDescGetList(CompValueDescListXpath(uiLBNum, sName));
            }
            public SortedList LBValueDescGetList(string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting nodes matching "
                    + sXpath);
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);

                return DescListToSortedList(xmlNodeList);
            }

            public void LBValueDescSet(
                uint uiLBNum,
                string sName,
                CLocale locale,
                string sDesc)
            {
                // does the description already exist?
                LBValueDescSet(
                    LBValueElemXpath(uiLBNum, sName),
                    LBValueDescElemXpath(uiLBNum, sName, locale),
                    locale,
                    sDesc);
                return;
            }
            public void UnitValueDescSet(
                uint uiLBNum,
                string sName,
                CLocale locale,
                string sDesc)
            {
                // does the description already exist?
                LBValueDescSet(
                    UnitValueElemXpath(uiLBNum, sName),
                    UnitValueDescElemXpath(uiLBNum, sName, locale),
                    locale,
                    sDesc);
                return;
            }
            public void CompValueDescSet(
                uint uiLBNum,
                string sName,
                CLocale locale,
                string sDesc)
            {
                // does the description already exist?
                LBValueDescSet(
                    CompValueElemXpath(uiLBNum, sName),
                    CompValueDescElemXpath(uiLBNum, sName, locale),
                    locale,
                    sDesc);
                return;
            }
            public void LBValueDescSet(
                string sXpathParent,
                string sXpath,
                CLocale locale,
                string sDesc)
            {
                // does the description already exist?
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode != null)
                {
                    // update the existing description
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Setting "
                        + DescDescAttrName
                        + " attribute to "
                        + sDesc
                        + " on "
                        + xmlElem.Name
                        + " element");
                    xmlElem.SetAttribute(DescDescAttrName, sDesc);
                    return;
                }

                // the element for this locale doesn't yet exist

                // get the value element
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpathParent);
                xmlNode = m_xmlDoc.SelectSingleNode(sXpathParent);
                if (xmlNode == null)
                {
                    // value node does not exist, should be 
                    // created before adding descriptions
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "Cannot add a formatted value description because formatted value"
                        + " does not exist in title xml.";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                DescAdd(xmlNode, locale, sDesc);
                m_bChanged = true;
                return;
            }

            public void LBValueDescDelete(
                uint uiLBNum,
                string sName,
                CLocale locale)
            {
                LBValueDescDelete(LBValueDescElemXpath(uiLBNum, sName, locale));
                return;
            }
            public void UnitValueDescDelete(
                uint uiLBNum,
                string sName,
                CLocale locale)
            {
                LBValueDescDelete(UnitValueDescElemXpath(uiLBNum, sName, locale));
                return;
            }
            public void CompValueDescDelete(
                uint uiLBNum,
                string sName,
                CLocale locale)
            {
                LBValueDescDelete(CompValueDescElemXpath(uiLBNum, sName, locale));
                return;
            }
            public void LBValueDescDelete(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No description matching "
                        + sXpath
                        + ". Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + ValuesElemName
                    + " element matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public void LBValueDescDeleteAll(
                uint uiLBNum, 
                string sName)
            {
                LBValueDescDeleteAll(LBValueDescsElemXpath(uiLBNum, sName));
                return;
            }
            public void UnitValueDescDeleteAll(
                uint uiLBNum, 
                string sName)
            {
                LBValueDescDeleteAll(UnitValueDescsElemXpath(uiLBNum, sName));
                return;
            }
            public void CompValueDescDeleteAll(
                uint uiLBNum, 
                string sName)
            {
                LBValueDescDeleteAll(CompValueDescsElemXpath(uiLBNum, sName));
                return;
            }
            public void LBValueDescDeleteAll(
                string sXpath)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // node doesn't exist, nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found. Nothing to delete");
                    return;
                }

                // delete the node we found
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Deleting "
                    + ValuesElemName
                    + " element matching "
                    + sXpath);
                xmlNode.ParentNode.RemoveChild(xmlNode);
                m_bChanged = true;
                return;
            }

            public void QueryPartitionSet(
                uint uiPartitionId)
            {
                // this settings, if present, are stored as attributes
                // on the QueryService element
                string sXpath = QueryElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // QueryService element doesn't exist, create it
                    xmlNode = TitleChildElemCreate(QueryElemName);
                }

                // one way or the other xmlNode now points to the
                // QueryService element
                XmlElement xmlElem = (XmlElement)xmlNode;

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + QueryPartitionAttrName
                    + " attribute to "
                    + uiPartitionId
                    + " on "
                    + QueryElemName
                    + " element.");
                xmlElem.SetAttribute(QueryPartitionAttrName, uiPartitionId.ToString());

                m_bChanged = true;
                return;
            }

            public bool QueryPartitionGet(
                ref uint uiPartitionId)
            {
                // these settings, if present, are stored as attributes
                // on the QueryService element
                string sXpath = QueryElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no node, no settings.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + QueryElemName
                        + " element not found, no settings to get.");
                    return false;
                }

                bool bFound = false;
                XmlElement xmlElem = (XmlElement)xmlNode;

                string sPartitionId = null;
                sPartitionId = xmlElem.GetAttribute(QueryPartitionAttrName);

                if (sPartitionId == null || sPartitionId == String.Empty)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + QueryElemName
                        + " does not have an "
                        + QueryPartitionAttrName
                        + " attribute.");
                    return false;
                }

                try
                {
                    uiPartitionId = UInt32.Parse(sPartitionId);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CRepository: "
                        + "Unable to parse partition number of "
                        + sPartitionId
                        + " as an integer. This attribute will be ignored.");
                    bFound = false;
                }
                return bFound;
            }

            public void QueryPartitionDelete()
            {
                // these settings, if present, are stored as attributes
                // on the QueryService element
                string sXpath = QueryElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);

                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // no element, nothing to delete
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No matching element found, nothing to delete.");
                    return;
                }

                XmlElement xmlElem = (XmlElement)xmlNode;

                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Removing "
                    + QueryPartitionAttrName
                    + " attribute on "
                    + QueryElemName
                    + " element.");
                xmlElem.RemoveAttribute(QueryPartitionAttrName);

                m_bChanged = true;
                return;
            }

            public void QueryConfigXmlSet(
                XmlDocument xmlDocQueryConfig,
                string sQueryTypeName)
            {
                // quick and dirty solution -- since I don't have the time for
                // tsunami to port the current xqs parser over to the same architecture
                // as the xsc (stats) parser and repository, I'm simply going to store
                // the querysim element from the xqs file in the title xml file.

                // for the production tools 2004-04 release, we're adding the 
                // concept of the QueryType, by which the operator can store
                // multiple xqs files in the repository at once.

                // first find the querysim node in the provided XmlDocument
                string sXpath = XqsQuerySimElemXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath
                    + " in supplied query config XmlDocument");
                XmlNode xmlNodeQuerySim = xmlDocQueryConfig.SelectSingleNode(sXpath);
                if (xmlNodeQuerySim == null)
                {
                    // this should've been caught before this method was called
                    string sErr = "Xbox.Tools.Framework.CRepository: "
                        + "No node matching "
                        + sXpath
                        + " found in supplied query config XmlDocument";
                    m_log.LogFile(sErr);
                    throw new CRepositoryException(sErr);
                }

                // see if there is a legacy querysim node hanging around...
                sXpath = QuerySimLegacyXpath;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath
                    + " in title xml");
                XmlNode xmlNodeLegacyQuerySim = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeLegacyQuerySim != null)
                {
                    // we have a hit! put this legacy querysim data into its new home
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "legacy QueryService format detected, upgrading...");

                    // create the new parent node
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Creating "
                        + QueryTypeElemName
                        + " element");
                    XmlElement xmlElem = m_xmlDoc.CreateElement(QueryTypeElemName);

                    // set the name attribute
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "setting "
                        + QueryTypeAttrName
                        + "="
                        + QueryServiceLegacyTypeName);
                    xmlElem.SetAttribute(QueryTypeAttrName, QueryServiceLegacyTypeName);

                    // get the QueryService node that will be the parent
                    sXpath = QueryElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting node matching "
                        + sXpath
                        + " in title xml");
                    XmlNode xmlNodeQueryService = m_xmlDoc.SelectSingleNode(sXpath);

                    // the parent node should be there, since it was the 
                    // parent node to the legacy querysim data, so if it's missing
                    // just throw
                    if (xmlNodeQueryService == null)
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository: "
                            + "No node matching "
                            + sXpath
                            + " found in title xml document";
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    // append the new QueryType element
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Appending "
                        + QueryTypeElemName
                        + " element to "
                        + QueryElemName);
                    xmlNodeQueryService.AppendChild(xmlElem);

                    // now clone the querysim node, and append it to the new element
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Copying querysim data to new location");
                    xmlElem.AppendChild(xmlNodeLegacyQuerySim.Clone());

                    // finally, remove the original querysim node
                    xmlNodeLegacyQuerySim.ParentNode.RemoveChild(xmlNodeLegacyQuerySim);

                    // mark the xml as changed, and we're done the format upgrade
                    m_bChanged = true;
                }

                // by the time we get here, there will be no legacy querysim
                // stuff hanging around in odd places.

                // get the correct QueryType element, if it exists
                sXpath = QueryTypeElemXpath(sQueryTypeName);
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNodeQueryType = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNodeQueryType == null)
                {
                    // QueryType element doesn't exist, create it
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Node matching "
                        + sXpath
                        + " does not exist, creating new "
                        + QueryTypeElemName
                        + " element");
                    XmlElement xmlElemQueryType = m_xmlDoc.CreateElement(QueryTypeElemName);

                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Settting "
                        + QueryTypeAttrName
                        + "="
                        + sQueryTypeName);
                    xmlElemQueryType.SetAttribute(QueryTypeAttrName, sQueryTypeName);

                    // get the QueryService node...
                    sXpath = QueryElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting node matching "
                        + sXpath);
                    XmlNode xmlNodeQueryService = m_xmlDoc.SelectSingleNode(sXpath);
                    if (xmlNodeQueryService == null)
                    {
                        // QueryService element doesn't exist, create it
                        xmlNodeQueryService = TitleChildElemCreate(QueryElemName);
                    }

                    // apppend the QueryType node to the QueryService node
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Appending new "
                        + QueryTypeElemName
                        + " element to "
                        + QueryElemName
                        + " element");
                    xmlNodeQueryService.AppendChild(xmlElemQueryType);

                    xmlNodeQueryType = xmlElemQueryType;
                }

                // one way or the other, we now have a properly named
                // QueryType node in xmlNodeQueryType, ready to accept
                // querysim data
                xmlNodeQueryType.InnerXml = xmlNodeQuerySim.OuterXml;
                m_bChanged = true;
                return;
            }

            public bool QueryConfigXmlGet(
                ref XmlDocument xmlDocQueryConfig,
                string sQueryTypeName)
            {
                XmlNode xmlNode = QueryConfigNodeGet(sQueryTypeName);

                if (xmlNode == null)
                {
                    // no node, no settings.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No query data found.");
                    return false;
                }

                // if we get here, then xmlNode is pointing to the querysim element
                // that the caller wants
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found matching node, create new xml document");

                // Create an xml document containing just this querysim element
                xmlDocQueryConfig = new XmlDocument();
                xmlDocQueryConfig.InnerXml = xmlNode.OuterXml;
                XmlDeclaration xmlDecl = xmlDocQueryConfig.CreateXmlDeclaration("1.0","UTF-8","no");
                xmlDocQueryConfig.InsertBefore(xmlDecl, xmlDocQueryConfig.DocumentElement);
                return true;
            }

            public void QueryConfigXmlDelete(string sQueryTypeName)
            {
                XmlNode xmlNode = QueryConfigNodeGet(sQueryTypeName);

                if (xmlNode == null)
                {
                    // no node, nothing to delete.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "No node matching "
                        + QueryElemXpath
                        + " found, no query config to delete.");
                    return;
                }

                // if we get here, then xmlNode is pointing to the querysim element
                // that the caller wants us to delete. We should actually delete the
                // parent of this xmlNode
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found matching node, deleting");
                xmlNode.ParentNode.ParentNode.RemoveChild(xmlNode.ParentNode);
                m_bChanged = true;
                return;
            }

            private XmlNode QueryConfigNodeGet(string sQueryTypeName)
            {
                string sXpath = null;
                XmlNode xmlNode = null;
                if (sQueryTypeName == QueryServiceLegacyTypeName)
                {
                    // the caller is asking for the type of query config
                    // that may have been stored directly under the
                    // QueryService node in a previous version of titlemgr,
                    // so check to see if the data is there...

                    sXpath = QuerySimLegacyXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Looking for legacy query data at "
                        + sXpath);
                    xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                }

                if (xmlNode == null)
                {
                    // we did not get a legacy xmlNode above, so 
                    // see if we can find a non legacy hit
                    sXpath = QuerySimElemXpath(sQueryTypeName);
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Looking for query data at "
                        + sXpath);
                    xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                }
                return xmlNode;
            }
        }


        // this helper class encapsulates the structure of the service xml file
        private class CServiceXml
        {
            CLog m_log;
            XmlDocument m_xmlDoc;
            bool m_bChanged;

            public const string ServiceElemName = "Service";
            private const string ServiceElemXpath = "/"+ServiceElemName;
            private const string VersionAttrName = "version";
            // use 3.0 to match the tsunami build number
            private const string VersionAttrValue = "3.0";

            // this element stores service wide policy settings as attributes
            public const string PolicyElemName = "Policy";
            public const string PolicyElemXpath = ServiceElemXpath+"/"+PolicyElemName;
            public const string MaxSingleAttachSizeAttrName = "MaxSingleAttachSize";
            public const string MaxTotalAttachSizeAttrName = "MaxTotalAttachSize";
            public const string MaxLeaderboardCount = "MaxLeaderboardCount";
            private static string PolicyAttrXpath(string sSettingName)
            {
                return PolicyElemXpath+"/@"+sSettingName;
            }

            // this element stores tool performance tuning parameters
            public const string PerformanceElemName = "Performance";
            public const string PerformanceElemXpath = ServiceElemXpath+"/"+PerformanceElemName;
            public const string FrontDoorTimeoutAttrName = "FrontDoorTimeout";
            public const string XmgmtTimeoutAttrName = "XmgmtTimeout";
            public const string DefaultStatsMaxWritesAttrName = "DefaultStatsMaxWrites";
            public const string DefaultStatsMaxReadsAttrName = "DefaultStatsMaxReads";
            private static string PerformanceAttrXpath(string sSettingName)
            {
                return PerformanceElemXpath+"/@"+sSettingName;
            }

            // this element stores the allowed list of xqs file types
            // that may added to the repository (/querytype parameter
            // in titlemgr).
            private const string QueryTypesElemName = "QueryTypes";
            private const string QueryTypesElemXpath = ServiceElemXpath+"/"+QueryTypesElemName;
            private const string QueryTypeElemName = "QueryType";
            private const string QueryTypeNameAttrName = "name";
            private const string QueryTypeElemListXpath = QueryTypesElemXpath+"/"+QueryTypeElemName;
            private static string QueryTypeElemXpath(string sQueryTypeName)
            {
                return QueryTypeElemListXpath+"[@"+QueryTypeNameAttrName+"=\""+sQueryTypeName+"\"]";
            }

            public CServiceXml(XmlDocument xmlDoc, CLog log)
            {
                m_log = log;
                if (m_log == null)
                {
                    m_log = new CLogNull();
                }
                m_xmlDoc = xmlDoc;
                m_bChanged = false;
            }

            public bool Changed
            {
                get { return m_bChanged; }
            }

            public static XmlDocument Create(CLog log)
            {
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Creating new xml document");
                XmlDocument xmlDoc = new XmlDocument();
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Adding xml declaration");
                XmlDeclaration xmlDecl = xmlDoc.CreateXmlDeclaration("1.0", "utf-8", "");
                xmlDoc.PrependChild(xmlDecl);
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Creating "
                    + ServiceElemName
                    + " element");
                XmlElement xmlServiceElem = xmlDoc.CreateElement(ServiceElemName);
                log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + VersionAttrName
                    + " attribute to "
                    + VersionAttrValue
                    + " on "
                    + ServiceElemName
                    + " element.");
                xmlServiceElem.SetAttribute(VersionAttrName, VersionAttrValue);
                xmlDoc.AppendChild(xmlServiceElem);
                return xmlDoc;
            }

            public void Save(FileStream fileStream)
            {
                m_xmlDoc.Save(fileStream);
                m_bChanged = false;
            }

            public bool PolicyGet(
                string sSettingName, 
                ref string sValue)
            {
                string sXpath = PolicyAttrXpath(sSettingName);
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not find node matching "
                        + sXpath);
                    return false;
                }

                sValue = xmlNode.Value;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found value of "
                    + sValue
                    + " in node matching "
                    + sXpath);
                return true;
            }

            public void PolicySet(
                string sSettingName, 
                string sValue)
            {
                // get the existing setting node if it exists
                string sXpath = PolicyElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the Policy element does not exist, create it
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Creating new "
                        + PolicyElemName
                        + " element");

                    // create the new element
                    XmlElement xmlElem = m_xmlDoc.CreateElement(PolicyElemName);

                    // get the service element
                    sXpath = ServiceElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting "
                        + ServiceElemName
                        + " element matching "
                        + sXpath);
                    XmlNode xmlNodeService = m_xmlDoc.SelectSingleNode(sXpath);
                    if (xmlNodeService == null)
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository: "
                            + "Unable to find "
                            + ServiceElemName
                            + " element";
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Prepending "
                        + PolicyElemName
                        + " element to "
                        + ServiceElemName
                        + " element.");
                    xmlNodeService.PrependChild(xmlElem);
                    xmlNode = xmlElem;
                }

                // xmlNode now points to the Policy element, one way
                // or another - set the attribute
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + sSettingName
                    + " attribute to "
                    + sValue
                    + " in "
                    + PolicyElemName
                    + " element.");
                XmlElement xmlElemPolicy = (XmlElement)xmlNode;
                xmlElemPolicy.SetAttribute(sSettingName, sValue);
                m_bChanged = true;
                return;
            }

            public void PolicyDelete(
                string sSettingName)
            {
                // get the existing policy element if it exists
                string sXpath = PolicyElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this setting does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + PolicyElemName
                        + " element does not exist, nothing to delete.");
                }
                else
                {
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Deleting attribute "
                        + sSettingName
                        + " from "
                        + PolicyElemName
                        + " element.");
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    xmlElem.RemoveAttribute(sSettingName);
                    m_bChanged = true;
                }
                return;
            }

            public bool PerformanceGet(
                string sSettingName, 
                ref string sValue)
            {
                string sXpath = PerformanceAttrXpath(sSettingName);
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Could not find node matching "
                        + sXpath);
                    return false;
                }

                sValue = xmlNode.Value;
                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Found value of "
                    + sValue
                    + " in node matching "
                    + sXpath);
                return true;
            }

            public void PerformanceSet(
                string sSettingName, 
                string sValue)
            {
                // get the existing setting node if it exists
                string sXpath = PerformanceElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the Performance element does not exist, create it
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Creating new "
                        + PerformanceElemName
                        + " element");

                    // create the new element
                    XmlElement xmlElem = m_xmlDoc.CreateElement(PerformanceElemName);

                    // get the service element
                    sXpath = ServiceElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting "
                        + ServiceElemName
                        + " element matching "
                        + sXpath);
                    XmlNode xmlNodeService = m_xmlDoc.SelectSingleNode(sXpath);
                    if (xmlNodeService == null)
                    {
                        string sErr = "Xbox.Tools.Framework.CRepository: "
                            + "Unable to find "
                            + ServiceElemName
                            + " element";
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Prepending "
                        + PerformanceElemName
                        + " element to "
                        + ServiceElemName
                        + " element.");
                    xmlNodeService.PrependChild(xmlElem);
                    xmlNode = xmlElem;
                }

                // xmlNode now points to the Performance element, one way
                // or another - set the attribute
                m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                    + "Setting "
                    + sSettingName
                    + " attribute to "
                    + sValue
                    + " in "
                    + PerformanceElemName
                    + " element.");
                XmlElement xmlElemPerformance = (XmlElement)xmlNode;
                xmlElemPerformance.SetAttribute(sSettingName, sValue);
                m_bChanged = true;
                return;
            }

            public void PerformanceDelete(
                string sSettingName)
            {
                // get the existing performance element if it exists
                string sXpath = PerformanceElemXpath;

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this setting does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + PerformanceElemName
                        + " element does not exist, nothing to delete.");
                }
                else
                {
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Deleting attribute "
                        + sSettingName
                        + " from "
                        + PerformanceElemName
                        + " element.");
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    xmlElem.RemoveAttribute(sSettingName);
                    m_bChanged = true;
                }
                return;
            }

            public void QueryTypeSet(string sQueryTypeName)
            {
                // query names are case insensitive
                sQueryTypeName = sQueryTypeName.ToLower();

                // get the existing QueryType node if it exists
                string sXpath = QueryTypeElemXpath(sQueryTypeName);

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // there is no QueryType element matching this
                    // query type name, so create it
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Creating new "
                        + QueryTypeElemName
                        + " element");

                    // create the new element
                    XmlElement xmlElemQueryType = m_xmlDoc.CreateElement(QueryTypeElemName);

                    // set the name attribute
                    xmlElemQueryType.SetAttribute(QueryTypeNameAttrName, sQueryTypeName);

                    // get the QueryTypes element
                    sXpath = QueryTypesElemXpath;
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Getting "
                        + QueryTypesElemName
                        + " element matching "
                        + sXpath);
                    XmlNode xmlNodeQueryTypes = m_xmlDoc.SelectSingleNode(sXpath);
                    if (xmlNodeQueryTypes == null)
                    {
                        // there is no QueryTypes element, so create it
                        m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                            + "Creating new "
                            + QueryTypesElemName
                            + " element");

                        // create the new element
                        XmlElement xmlElemQueryTypes = m_xmlDoc.CreateElement(QueryTypesElemName);

                        // get the service element
                        sXpath = ServiceElemXpath;
                        m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                            + "Getting "
                            + ServiceElemName
                            + " element matching "
                            + sXpath);
                        XmlNode xmlNodeService = m_xmlDoc.SelectSingleNode(sXpath);
                        if (xmlNodeService == null)
                        {
                            string sErr = "Xbox.Tools.Framework.CRepository: "
                                + "Unable to find "
                                + ServiceElemName
                                + " element";
                            m_log.LogFile(sErr);
                            throw new CRepositoryException(sErr);
                        }

                        m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                            + "Prepending "
                            + QueryTypesElemName
                            + " element to "
                            + ServiceElemName
                            + " element.");
                        xmlNodeService.PrependChild(xmlElemQueryTypes);
                        xmlNodeQueryTypes = xmlElemQueryTypes;
                    }

                    // one way or the other, xmlNodeQueryTypes now
                    // points to the QueryTypes element.
                    // now prepend the new QueryType element to it
                    xmlNodeQueryTypes.PrependChild(xmlElemQueryType);
                    m_bChanged = true;
                }

                // one way or the other, there is now a QueryType
                // element with a name attribute matching sQueryTypeName
                // so we're done.
                return;
            }

            public string[] QueryTypeGetList()
            {
                // get a node list of all the QueryType nodes
                string sXpath = QueryTypeElemListXpath;
                XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath);
                if (xmlNodeList == null)
                {
                    // no node list, return an empty array
                    // to signal that there are no allowed query
                    // types
                    return new string[0];
                }

                // use a sorted list so the names come out in a
                // repeatable order
                ArrayList al = new ArrayList();
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    XmlElement xmlElem = (XmlElement)xmlNode;
                    string sQueryTypeName = xmlElem.GetAttribute(QueryTypeNameAttrName);
                    if (sQueryTypeName == String.Empty)
                    {
                        // this element is missing the name attribute, so throw
                        string sErr = "Xbox.Tools.Framework.CRepository: "
                            + QueryTypeElemName
                            + " element found with no "
                            + QueryTypeNameAttrName
                            + " attribute.";
                        m_log.LogFile(sErr);
                        throw new CRepositoryException(sErr);
                    }

                    // query names are case insensitive
                    sQueryTypeName = sQueryTypeName.ToLower();

                    // add this query type name to the sortedlist of 
                    // allowed names. Note if the same name is 
                    // configured twice, it will be added to the 
                    // list twice.
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "Found query type name "
                        + sQueryTypeName);
                    al.Add(sQueryTypeName);
                }

                // sort the arraylist, then convert it into an array to return
                al.Sort();
                string[] rgsQueryTypeNames = new string[al.Count];
                al.CopyTo(rgsQueryTypeNames);
                return rgsQueryTypeNames;
            }

            public void QueryTypeDelete(string sQueryTypeName)
            {
                // query names are case insensitive
                sQueryTypeName = sQueryTypeName.ToLower();

                // get the existing QueryType element if it exists
                string sXpath = QueryTypeElemXpath(sQueryTypeName);

                m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                    + "Getting node matching "
                    + sXpath);
                XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    // the xml node containing this setting does not exist,
                    // so there's nothing to do
                    m_log.FullTrace("Xbox.Tools.Framework.CRepository: "
                        + "node matching "
                        + sXpath
                        + " does not exist, nothing to delete.");
                }
                else
                {
                    m_log.DataMod2("Xbox.Tools.Framework.CRepository: "
                        + "Deleting element matching "
                        + sXpath);
                    xmlNode.ParentNode.RemoveChild(xmlNode);
                    m_bChanged = true;
                }
                return;
            }
        }

        private class CServersIni
        {
            public const string ServersSectionName = "SERVERS";

            public const string LockfileSettingName = "LOCKFILE";
            public const string StatsDBSettingName = "STATSDB";
            public const string StatsFDSettingName = "STATSFD";
            public const string MatchDBSettingName = "MATCHDB";
            public const string MatchFDSettingName = "MATCHFD";
            public const string TitlesDBSettingName = "TITLESDB";
            public const string WebDBSettingName = "WEBDB";
            public const string QueryDBSettingName = "QUERYDB";
            public const string AlertsDBSettingName = "ALERTSDB";
            public const string XKDCSettingName = "XKDC";
            public const string NPDBSettingName = "NPDB";
            public const string CronSettingName = "CRON";
            public const string FeedbackFDSettingName = "FDBKFD";
            public const string MessSettingName = "MESS";
            public const string PresNotiFDSettingName = "PNFD";
            public const string StfdSettingName = "STFD";
            public const string UACSSettingName = "UACS";
            public const string XBOSSettingName = "XBOS";
            public const string XqrySettingName = "XQRY";
            public const string XsigSettingName = "XSIG";
            public const string SGConfigSettingName = "SGCFG";
            public const string WCAlertsSettingName = "WCALERTS";
            public const string WCGeneralSettingName = "WCGENERAL";
            public const string WCMessagingSettingName = "WCMESSAGING";
            public const string WCPresenceSettingName = "WCPRESENCE";
            public const string WCQuerySettingName = "WCQUERY";
            public const string WCSignatureSettingName = "WCSIGNATURE";
            public const string WCStatsSettingName = "WCSTATS";
            public const string WCStorageSettingName = "WCSTORAGE";
            public const string WCUsersSettingName = "WCUSERS";

            public const string SiteSectionPrefix = "SITE.";
            public const string DownloadUNCPathSettingName = "DOWNLOADSERVERS";
            public const string SGServerSettingName = "SG";

            public const string HealthSectionName = "HEALTH";

            public const string DefaultSectionName = "DEFAULT";
            public const string EntriesPerCacheLineSettingName = "ENTRIES_PER_CACHE_LINE";
            public const string ExpirationSecondsSettingName = "EXPIRATION_SECONDS";
        }

        private class CStatsIni
        {
            public const string SettingsSectionName = "SETTINGS";
            public const string StatsDBSettingName = "STATSDB";
            
            public const string TitleSectionName = "TITLE";
            public const string ESRBSettingName = "ESRB";
            public const string DefaultLocaleSettingName = "DefaultLocale";
            public const string ClusterIdSettingName = "Cluster";
            
            public const string LeaderboardsSectionName = "LEADERBOARDS";
        }

        // the repository stores title names in a set of xml files in
        //
        // <root>\<titleid>\message\titles.<language>.xml
        //
        // Example:
        //
        // D:\TMR.pnewson\ffff4006\message\titles.english.xml
        //
        // the content of these files looks like:
        //
        //    <?xml version="1.0" encoding="utf-8" ?>
        //      <msgstrings type="1" language="1">
        //        <msgmapping id="4294918150">0xFFFF4006</msgmapping>
        //    </msgstrings>
        //
        // The ELanguageName enum defined in ELanguageName.cs defines 
        // the correpsondance between a language name as found in the file 
        // name, and the language code used in the xml file and in NPDB
        //
        private class CMessageXml
        {
            private static string MessageXpath(
                ELanguageName langName,
                CTitleId tid)
            {
                int i = (int)langName;
                return "/msgstrings[@language='"+i.ToString()+"']"
                    +"/msgmapping[@id='"+tid.uiTitleId+"']"
                    +"/text()";
            }

            public static string ExtractMessage(
                string sMessageXmlPathAndFilename, 
                CTitleId tid,
                ELanguageName langName)
            {
                if (sMessageXmlPathAndFilename == null)
                {
                    throw new ArgumentNullException("sMessageXmlPathAndFilename");
                }

                if (tid == null)
                {
                    throw new ArgumentNullException("tid");
                }

                if (!File.Exists(sMessageXmlPathAndFilename))
                {
                    throw new CRepositoryException("Xbox.Tools.Framework.CRepository: "
                        + "Could not open message xml file: "
                        + sMessageXmlPathAndFilename);
                }

                XmlDocument xmlDocument = new XmlDocument();

                try
                {
                    xmlDocument.Load(sMessageXmlPathAndFilename);
                }
                catch (XmlException e)
                {
                    throw new CRepositoryException("Xbox.Tools.Framework.CRepository: "
                        + "Exception loading xml document "
                        + sMessageXmlPathAndFilename
                        + ", details: "
                        + e.Message,
                        e);
                }

                string sXpath = MessageXpath(langName, tid);
                XmlNode xmlNode = xmlDocument.SelectSingleNode(sXpath);
                if (xmlNode == null)
                {
                    return null;
                }
                return xmlNode.Value;
            }
        }
    }


    public class CRepositoryException : ApplicationException
    {
        public CRepositoryException() : base() {}
        public CRepositoryException(string s) : base(s) {}
        protected CRepositoryException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CRepositoryException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CXscSubmit.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.framework 
{
    /// <summary>
    /// This class syncronizes the contents of an xsc file with the contents of the service repository.
    /// An invalid stats configuration will not be submitted, and the method will return false.
    /// If the stats configuration violates a policy, it will not be submitted unless bIgnorePolicy
    /// is specified. Note that once a stats configuration is in the title repository, policy is not
    /// checked again during a sync operation, so it need only be overriden on this method.
    /// </summary>
    public class CXscSubmit
    {
        // The current max attachment and max leaderboard polices are compiled into this class.
        // This is what will be used if the settings are not present in the service repository.
        private const uint c_uiCompileTimeDefaultMaxSingleAttachSize = 2*1024*1024; // 2 meg
        private const uint c_uiCompileTimeDefaultMaxTotalAttachSize = 1*1024*1024*1024; // 1 gig
        private const uint c_uiCompileTimeDefaultMaxLeaderboardCount = 100;

        // The default values we'll use when creating a unit config for the first time
        private const uint c_uiMaxAvailUnitsDefault = 100;
        private const uint c_uiSizeUnitCacheDefault = 100;

        // The default values we'll use for limits when first adding stats to a title
        // can be overridden in the repository.
        private const uint c_uiCompileTimeDefaultMaxWrites = 5;
        private const uint c_uiCompileTimeDefaultMaxReads = 5;

        public static bool Submit(
            CTitleId tid, 
            CXsc xsc, 
            CRepository repository, 
            bool bIgnorePolicy,
            out int iLBCount,
            CLog log)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (xsc == null)
            {
                throw new ArgumentNullException("xsc");
            }
            if (repository == null)
            {
                throw new ArgumentNullException("repository");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CXscSubmit.Submit("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{xsc}, "
                + "{repository}, "
                + "{log})");

            //  we haven't processed anything yet.
            iLBCount = 0;

            // first make sure we have a title to apply to
            if (!repository.TitleExists(tid))
            {
                string sErr = "Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "TitleId "
                    + tid.sTitleIdHexNoPrefix
                    + " does not exist in repository. Unable to apply xsc file to repository.";
                log.LogFile(sErr);
                throw new CXscSubmitException(sErr);
            }

            // make sure the xsc is valid
            if (!CXscValidate.Validate(xsc, tid, log))
            {
                // xsc is not valid, complain and return false
                log.Console("Error: "
                    + "xsc file is not a valid stats configuration. Not applying to repository.");
                log.StackTrace("Xbox.Tools.Framework.CXscSubmit.Submit complete, returning false");
                return false;
            }

            // check policy
            // get the policy from the repository (if present)
            uint uiMaxSingleAttachSize = c_uiCompileTimeDefaultMaxSingleAttachSize;
            uint uiMaxTotalAttachSize = c_uiCompileTimeDefaultMaxTotalAttachSize;
            uint uiMaxLeaderboardCount = c_uiCompileTimeDefaultMaxLeaderboardCount;

            repository.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize, 
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount);
            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                + "Using MaxSingleAttachSize value of: "
                + uiMaxSingleAttachSize);
            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                + "Using MaxTotalAttachSize value of: "
                + uiMaxTotalAttachSize);
            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                + "Using MaxLeaderboardCount value of: "
                + uiMaxLeaderboardCount);

            if (!CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log))
            {
                if (bIgnorePolicy)
                {
                    log.Console("Warning: Ignoring policy violations");
                }
                else
                {
                    // xsc violates policy, complain and return false
                    log.Console("Error: "
                        + "stats configuration does not confirm to current policy. Not applying to repository.");
                    log.StackTrace("Xbox.Tools.Framework.CXscSubmit.Submit complete, returning false");
                    return false;
                }
            }

            // xsc is valid, and either passes policy, or we're ignoring policy
            // so sync the xsc with the repository

            // is this the first time we're submitting stats for this title?
            if (!repository.TitleContainsStatsInfo(tid))
            {
                // since this is the first time we're submitting stats for
                // this title, set maxreads and maxwrites
                SetStatsLimits(tid, repository, log);
            }

            // first, sync the default locale, if present
            CLocale locDefault;
            if (xsc.DefaultLocaleGet(out locDefault))
            {
                repository.TitleDefaultLocaleSet(tid, locDefault);
            }

            // then do all the leaderboard stuff
            ApplyLeaderboards(tid, xsc, repository, ref iLBCount, log);
            ApplyUnits(tid, xsc, repository, ref iLBCount, log);
            ApplyComps(tid, xsc, repository, ref iLBCount, log);

            // submit the updated information to the repository
            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                + "Submitting updated xml configuration file to repository for titleid "
                + tid.sTitleIdHexNoPrefix);
            string sComment = "Xbox.Tools.Framework.CXscSubmit.Submit: applied xsc submission to repository";
            repository.TitleSubmit(tid, sComment);

            log.StackTrace("Xbox.Tools.Framework.CXscSubmit.Submit complete, returning true");
            return true;
        }

        public static void ApplyLeaderboards(
            CTitleId tid, 
            CXsc xsc, 
            CRepository repository, 
            ref int iLBCount,
            CLog log)
        {
            // get the default db for any new leaderboards we create
            int iDefaultStatsDB = 0;
            if (!repository.TitleLBDefaultDBGet(tid, ref iDefaultStatsDB))
            {
                // no default is currently specified
                log.LogFile("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "No default stats db setting was found for title "
                    + tid.sTitleIdHexNoPrefix
                    + " in respository.");
                log.LogFile("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Setting default stats db for "
                    + tid.sTitleIdHexNoPrefix
                    + " to 0 in respository.");
                iDefaultStatsDB = 0;
                repository.TitleLBDefaultDBSet(tid, iDefaultStatsDB);
            }

            // get the default values for entries per cache line
            // and expiration seconds
            uint uiEntriesPerCacheLine;
            uint uiExpirationSeconds;
            repository.ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds);

            // get the list of leaderboards in the xsc file
            uint[] rguiLBsInXsc = xsc.LBGetList();

            // get the list of leaderboards in the repository
            uint[] rguiLBsInRepository = repository.TitleLBGetList(tid);

            // to make our lives easy, we'll want these as array lists
            ArrayList alLBsInXsc = new ArrayList(rguiLBsInXsc);
            ArrayList alLBsInRepository = new ArrayList(rguiLBsInRepository);

            // for each leaderboard in the repository, check to see if 
            // it exists in the xsc. If it is not in the xsc then delete it from the
            // repository.
            foreach (uint uiLBNumInRepository in alLBsInRepository)
            {
                if (!alLBsInXsc.Contains(uiLBNumInRepository))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Removing leaderboard number "
                        + uiLBNumInRepository
                        + " from the repository for title id "
                        + tid.sTitleIdHexNoPrefix);
                    repository.TitleLBDelete(tid, uiLBNumInRepository);
                }
            }

            // now for each leaderboard in the xsc file, update the 
            // repository to match the defintion in the xsc file
            foreach (uint uiLBNumInXsc in alLBsInXsc)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating definition of leaderboard number "
                    + uiLBNumInXsc
                    + " in the repository for title id "
                    + tid.sTitleIdHexNoPrefix);
                ApplyLeaderboard(
                    tid, 
                    xsc, 
                    repository, 
                    iDefaultStatsDB, 
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    uiLBNumInXsc, 
                    log);
                ++iLBCount;
            }
        }

        public static void ApplyLeaderboard(
            CTitleId tid,
            CXsc xsc,
            CRepository repository,
            int iDefaultStatsDB,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            uint uiLBNumInXsc,
            CLog log)
        {
            // these are the default values that we use if 
            // nothing is specified in the xsc file for a
            // particular parameter and nothing is currently
            // in the repository
            int iStatsDB = iDefaultStatsDB;
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            // see if there's anything already in the repository
            // these become our new defaults. This will preserve values not
            // specified in the xsc file through the sync, like bDontList
            // or iDefaultStatsDB
            repository.TitleLBGet(
                tid,
                uiLBNumInXsc,
                ref iDefaultStatsDB,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);

            // We've now collected from the respository the current configuration,
            // including all the stuff that's not specified in the xsc file.
            // However, things that are usually specified in the xsc file we want
            // to reset to defaults if they are now missing. We set these defaults
            // here.
            lbReset = ELBReset.ResetNever;
            uiAttachCount = 0;
            uiMaxAttachSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bRequireArbitration = false;
            bIsTeam = false;
            eloConfig = null;

            // get the data from the xsc file
            if (!xsc.LBConfigGet(
                uiLBNumInXsc, 
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen, the list said the leaderboard
                // was in the xsc file. This must be a bug, so throw
                throw new CXscSubmitException("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "CXsc.LBGetList retunred leaderboard id "
                    + uiLBNumInXsc
                    + " but CXsc.LBConfigGet returned false for the same leaderboard id");
            }

            repository.TitleLBSet(
                tid,
                uiLBNumInXsc,
                iDefaultStatsDB,
                lbReset,
                uiAttachCount,
                uiMaxAttachSize,
                uiDecayDays,
                uiMaxRatingCount,
                bRequireArbitration,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // are there any leaderboard descriptions in the xsc?
            SortedList slLBDescsInXsc = xsc.LBDescGetList(uiLBNumInXsc);
            if (slLBDescsInXsc.Count == 0)
            {
                // if there are no leaderboard descriptions, then we want
                // to make sure there is no web information at all in the
                // repository for this leaderboard
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "No leaderboard descriptions specified for leaderboard number "
                    + uiLBNumInXsc
                    + ". All web information will be removed from the repository for this leaderboard.");
                LBRemoveWebInfo(repository, tid, uiLBNumInXsc);
                return;
            }

            // iterate through the leaderboard descriptions in the repository, and
            // delete any that do not appear in the xsc
            SortedList slLBDescsInRepository = repository.TitleLBDescGetList(tid, uiLBNumInXsc);
            foreach (DictionaryEntry de in slLBDescsInRepository)
            {
                string sLocale = (string)de.Key;
                if (!slLBDescsInXsc.ContainsKey(sLocale))
                {
                    // this description is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting leaderboard description for leaderboard "
                        + uiLBNumInXsc
                        + " for locale "
                        + sLocale
                        + " from repository.");
                    CLocale locale = new CLocale(sLocale);
                    repository.TitleLBDescDelete(tid, uiLBNumInXsc, locale);
                }
            }

            // Any descriptions that needed deleting have been deleted.
            // Now update or add the descriptions from the xsc.
            foreach (DictionaryEntry de in slLBDescsInXsc)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating leaderboard description for leaderboard "
                    + uiLBNumInXsc
                    + " for locale "
                    + sLocale
                    + " in repository.");
                CLocale locale = new CLocale(sLocale);
                repository.TitleLBDescSet(tid, uiLBNumInXsc, locale, sDesc);
            }
            // leaderboard descriptions are now up to date

            // now sync the leaderboard attributes
            SortedList slLBAttrsInXsc = xsc.LBAttrGetList(uiLBNumInXsc);
            SortedList slLBAttrsInRepository = repository.TitleLBAttrGetList(tid, uiLBNumInXsc);

            // iterate through the leaderboard attributes in the repository, and
            // delete any that do not appear in the xsc
            foreach (DictionaryEntry de in slLBAttrsInRepository)
            {
                uint uiId = (uint)de.Key;
                if (!slLBAttrsInXsc.ContainsKey(uiId))
                {
                    // this attribute is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting attribute for leaderboard "
                        + uiLBNumInXsc
                        + " with id "
                        + uiId
                        + " from repository.");
                    repository.TitleLBAttrDelete(tid, uiLBNumInXsc, uiId);
                }
            }

            // Any attributes that needed deleting have been deleted.
            // Now update or add the attributes from the xsc.
            foreach (DictionaryEntry de in slLBAttrsInXsc)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating attribute for leaderboard "
                    + uiLBNumInXsc
                    + " with id "
                    + uiId
                    + " in repository.");
                repository.TitleLBAttrSet(tid, uiLBNumInXsc, uiId, bIsPuid);
            }

            // finally, sync the leaderboard formatted values
            string[] rgsLBValuesInXsc = xsc.LBValueGetList(uiLBNumInXsc);
            ArrayList alLBValuesInXsc = new ArrayList(rgsLBValuesInXsc);
            string[] rgsLBValuesInRepository = repository.TitleLBValueGetList(tid, uiLBNumInXsc);

            // iterate through the leaderboard values in the repository, and
            // delete any that do not appear in the xsc
            foreach (string sName in rgsLBValuesInRepository)
            {
                if (!alLBValuesInXsc.Contains(sName))
                {
                    // this formatted value is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting formatted value for leaderboard "
                        + uiLBNumInXsc
                        + " with name "
                        + sName
                        + " from repository.");
                    repository.TitleLBValueDelete(tid, uiLBNumInXsc, sName);
                }
            }

            // Any formatted values that needed deleting have been deleted.
            // Now update or add the formatted values from the xsc.
            foreach (string sName in rgsLBValuesInXsc)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (xsc.LBValueGet(uiLBNumInXsc, sName, ref returnType, ref sFormula))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Adding/Updating formatted value for leaderboard "
                        + uiLBNumInXsc
                        + " with name "
                        + sName 
                        + " in repository.");
                    repository.TitleLBValueSet(tid, uiLBNumInXsc, sName, returnType, sFormula);

                    // and sync the formatted value descriptions for this value too..
                    SortedList slLBValueDescsInXsc = xsc.LBValueDescGetList(uiLBNumInXsc, sName);
                    SortedList slLBValueDescsInRepository 
                        = repository.TitleLBValueDescGetList(tid, uiLBNumInXsc, sName);
                    foreach (DictionaryEntry de in slLBValueDescsInRepository)
                    {
                        string sLocale = (string)de.Key;
                        if (!slLBValueDescsInXsc.ContainsKey(sLocale))
                        {
                            // this description is not found in the xsc, so remove it
                            // from the repository
                            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                                + "Deleting formatted value description for leaderboard "
                                + uiLBNumInXsc
                                + " formatted value name "
                                + sName
                                + " for locale "
                                + sLocale
                                + " from repository.");
                            CLocale locale = new CLocale(sLocale);
                            repository.TitleLBValueDescDelete(tid, uiLBNumInXsc, sName, locale);
                        }
                    }

                    // Any formatted value descriptions that needed deleting have been deleted.
                    // Now update or add the descriptions from the xsc.
                    foreach (DictionaryEntry de in slLBValueDescsInXsc)
                    {
                        string sLocale = (string)de.Key;
                        string sDesc = (string)de.Value;
                        log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                            + "Adding/Updating formatted value description for leaderboard "
                            + uiLBNumInXsc
                            + " formatted value name "
                            + sName
                            + " for locale "
                            + sLocale
                            + " in repository.");
                        CLocale locale = new CLocale(sLocale);
                        repository.TitleLBValueDescSet(tid, uiLBNumInXsc, sName, locale, sDesc);
                    }
                }
                else
                {
                    // this name was in the list, but then we couldn't get it... strange
                    log.LogFile("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Unable to get formatted value details for leaderboard "
                        + uiLBNumInXsc
                        + " formatted value name "
                        + sName
                        + " from xsc file. This formatted value will not be added to the repository.");
                }
            }
        }

        private static void LBRemoveWebInfo(
            CRepository repository, 
            CTitleId tid, 
            uint uiLBNumInXsc)
        {
            repository.TitleLBDescDeleteAll(tid, uiLBNumInXsc);
            repository.TitleLBAttrDeleteAll(tid, uiLBNumInXsc);
            repository.TitleLBValueDeleteAll(tid, uiLBNumInXsc);
        }

        public static void ApplyUnits(
            CTitleId tid, 
            CXsc xsc, 
            CRepository repository, 
            ref int iLBCount,
            CLog log)
        {
            // get the default values for entries per cache line
            // and expiration seconds
            uint uiEntriesPerCacheLine;
            uint uiExpirationSeconds;
            repository.ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds);

            // get the list of unit leaderboards in the xsc file
            uint[] rguiUnitsInXsc = xsc.UnitGetList();

            // if there is one or more unit leaderboards, we need
            // to grab the decay factor out of the xsc file and apply
            // it to this title's unit config.
            if (rguiUnitsInXsc.Length > 0)
            {
                // get the decay factor from the xsc file...
                double dDecayFactorInXsc = 0.0;
                if (!xsc.UnitDecayFactorGet(out dDecayFactorInXsc))
                {
                    // no decay factor ?!? this shouldn't have gotten past
                    // the xsc validator, so throw.
                    string sErr = "Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Unit leaderboards are provided in the xsc file but no "
                        + "unit leaderboard decay fator is present in xsc.";
                    log.LogFile(sErr);
                    throw new CXscSubmitException(sErr);
                }

                // xlast asks for this value in days, but statsdb interprets
                // it in minutes, so multiply by the appropriate factor
                // 60 minutes per hour, 24 hours per day
                dDecayFactorInXsc = dDecayFactorInXsc*60*24;

                // get the default stats database, in case we're
                // setting this title up from scratch...
                int iUnitDatabase = 0;
                repository.TitleLBDefaultDBGet(tid, ref iUnitDatabase);

                uint uiMaxAvailUnits = c_uiMaxAvailUnitsDefault;
                uint uiSizeUnitCache = c_uiSizeUnitCacheDefault;

                // we now have the default values, see if there's anything
                // already in the repository - these override the defaults
                // above (but not the decay factor from the xsc)
                double dDecayFactor = 0.0;
                repository.TitleUnitConfigGet(
                    tid, 
                    ref iUnitDatabase,
                    ref dDecayFactor,
                    ref uiMaxAvailUnits,
                    ref uiSizeUnitCache);

                // set it
                repository.TitleUnitConfigSet(
                    tid,
                    iUnitDatabase,
                    dDecayFactorInXsc,
                    uiMaxAvailUnits,
                    uiSizeUnitCache);
            }

            // get the list of unit leaderboards in the repository
            uint[] rguiUnitsInRepository = repository.TitleUnitGetList(tid);

            // to make our lives easy, we'll want these as array lists
            ArrayList alUnitsInXsc = new ArrayList(rguiUnitsInXsc);
            ArrayList alUnitsInRepository = new ArrayList(rguiUnitsInRepository);

            // for each unit leaderboard in the repository, check to see if 
            // it exists in the xsc. If it is not in the xsc then delete it from the
            // repository.
            foreach (uint uiUnitInRepository in alUnitsInRepository)
            {
                if (!alUnitsInXsc.Contains(uiUnitInRepository))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Removing unit leaderboard number "
                        + uiUnitInRepository
                        + " from the repository for title id "
                        + tid.sTitleIdHexNoPrefix);
                    repository.TitleUnitDelete(tid, uiUnitInRepository);
                }
            }

            // now for each unit leaderboard in the xsc file, update the 
            // repository to match the defintion in the xsc file
            foreach (uint uiUnitInXsc in alUnitsInXsc)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating definition of unit leaderboard number "
                    + uiUnitInXsc
                    + " in the repository for title id "
                    + tid.sTitleIdHexNoPrefix);
                ApplyUnit(
                    tid, 
                    xsc, 
                    repository, 
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    uiUnitInXsc, 
                    log);
                ++iLBCount;
            }
        }

        public static void ApplyUnit(
            CTitleId tid,
            CXsc xsc,
            CRepository repository,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            uint uiUnitInXsc,
            CLog log)
        {
            // these are the default values that we use if 
            // nothing is specified in the xsc file for a
            // particular parameter and nothing is currently
            // in the repository
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            // see if there's anything already in the repository
            // these become our new defaults. This will preserve values not
            // specified in the xsc file through the sync, like bDontList
            repository.TitleUnitGet(
                tid,
                uiUnitInXsc,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);

            // We've now collected from the respository the current configuration,
            // including all the stuff that's not specified in the xsc file.
            // However, things that are usually specified in the xsc file we want
            // to reset to defaults if they are now missing. We set these defaults
            // here.
            bRequireArbitration = true;
            bIsTeam = false;
            eloConfig = null;

            // get the data from the xsc file
            if (!xsc.UnitConfigGet(
                uiUnitInXsc, 
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen, the list said the leaderboard
                // was in the xsc file. This must be a bug, so throw
                throw new CXscSubmitException("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "CXsc.UnitGetList retunred unit leaderboard id "
                    + uiUnitInXsc
                    + " but CXsc.UnitConfigGet returned false for the same id");
            }

            repository.TitleUnitSet(
                tid,
                uiUnitInXsc,
                bRequireArbitration,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // are there any leaderboard descriptions in the xsc?
            SortedList slUnitDescsInXsc = xsc.UnitDescGetList(uiUnitInXsc);
            if (slUnitDescsInXsc.Count == 0)
            {
                // if there are no unit leaderboard descriptions, then we want
                // to make sure there is no web information at all in the
                // repository for this leaderboard
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "No unit leaderboard descriptions specified for unit leaderboard number "
                    + uiUnitInXsc
                    + ". All web information will be removed from the repository for this unit leaderboard.");
                UnitRemoveWebInfo(repository, tid, uiUnitInXsc);
                return;
            }

            // iterate through the leaderboard descriptions in the repository, and
            // delete any that do not appear in the xsc
            SortedList slUnitDescsInRepository = repository.TitleUnitDescGetList(tid, uiUnitInXsc);
            foreach (DictionaryEntry de in slUnitDescsInRepository)
            {
                string sLocale = (string)de.Key;
                if (!slUnitDescsInXsc.ContainsKey(sLocale))
                {
                    // this description is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting unit leaderboard description for unit leaderboard "
                        + uiUnitInXsc
                        + " for locale "
                        + sLocale
                        + " from repository.");
                    CLocale locale = new CLocale(sLocale);
                    repository.TitleUnitDescDelete(tid, uiUnitInXsc, locale);
                }
            }

            // Any descriptions that needed deleting have been deleted.
            // Now update or add the descriptions from the xsc.
            foreach (DictionaryEntry de in slUnitDescsInXsc)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating unit leaderboard description for unit leaderboard "
                    + uiUnitInXsc
                    + " for locale "
                    + sLocale
                    + " in repository.");
                CLocale locale = new CLocale(sLocale);
                repository.TitleUnitDescSet(tid, uiUnitInXsc, locale, sDesc);
            }
            // leaderboard descriptions are now up to date

            // now sync the leaderboard attributes
            SortedList slUnitAttrsInXsc = xsc.UnitAttrGetList(uiUnitInXsc);
            SortedList slUnitAttrsInRepository = repository.TitleUnitAttrGetList(tid, uiUnitInXsc);

            // iterate through the leaderboard attributes in the repository, and
            // delete any that do not appear in the xsc
            foreach (DictionaryEntry de in slUnitAttrsInRepository)
            {
                uint uiId = (uint)de.Key;
                if (!slUnitAttrsInXsc.ContainsKey(uiId))
                {
                    // this attribute is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting attribute for unit leaderboard "
                        + uiUnitInXsc
                        + " with id "
                        + uiId
                        + " from repository.");
                    repository.TitleUnitAttrDelete(tid, uiUnitInXsc, uiId);
                }
            }

            // Any attributes that needed deleting have been deleted.
            // Now update or add the attributes from the xsc.
            foreach (DictionaryEntry de in slUnitAttrsInXsc)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating attribute for unit leaderboard "
                    + uiUnitInXsc
                    + " with id "
                    + uiId
                    + " in repository.");
                repository.TitleUnitAttrSet(tid, uiUnitInXsc, uiId, bIsPuid);
            }

            // finally, sync the leaderboard formatted values
            string[] rgsUnitValuesInXsc = xsc.UnitValueGetList(uiUnitInXsc);
            ArrayList alUnitValuesInXsc = new ArrayList(rgsUnitValuesInXsc);
            string[] rgsUnitValuesInRepository = repository.TitleUnitValueGetList(tid, uiUnitInXsc);

            // iterate through the leaderboard values in the repository, and
            // delete any that do not appear in the xsc
            foreach (string sName in rgsUnitValuesInRepository)
            {
                if (!alUnitValuesInXsc.Contains(sName))
                {
                    // this formatted value is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting formatted value for unit leaderboard "
                        + uiUnitInXsc
                        + " with name "
                        + sName
                        + " from repository.");
                    repository.TitleUnitValueDelete(tid, uiUnitInXsc, sName);
                }
            }

            // Any formatted values that needed deleting have been deleted.
            // Now update or add the formatted values from the xsc.
            foreach (string sName in rgsUnitValuesInXsc)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (xsc.UnitValueGet(uiUnitInXsc, sName, ref returnType, ref sFormula))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Adding/Updating formatted value for unit leaderboard "
                        + uiUnitInXsc
                        + " with name "
                        + sName 
                        + " in repository.");
                    repository.TitleUnitValueSet(tid, uiUnitInXsc, sName, returnType, sFormula);

                    // and sync the formatted value descriptions for this value too..
                    SortedList slUnitValueDescsInXsc = xsc.UnitValueDescGetList(uiUnitInXsc, sName);
                    SortedList slUnitValueDescsInRepository 
                        = repository.TitleUnitValueDescGetList(tid, uiUnitInXsc, sName);
                    foreach (DictionaryEntry de in slUnitValueDescsInRepository)
                    {
                        string sLocale = (string)de.Key;
                        if (!slUnitValueDescsInXsc.ContainsKey(sLocale))
                        {
                            // this description is not found in the xsc, so remove it
                            // from the repository
                            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                                + "Deleting formatted value description for unit leaderboard "
                                + uiUnitInXsc
                                + " formatted value name "
                                + sName
                                + " for locale "
                                + sLocale
                                + " from repository.");
                            CLocale locale = new CLocale(sLocale);
                            repository.TitleUnitValueDescDelete(tid, uiUnitInXsc, sName, locale);
                        }
                    }

                    // Any formatted value descriptions that needed deleting have been deleted.
                    // Now update or add the descriptions from the xsc.
                    foreach (DictionaryEntry de in slUnitValueDescsInXsc)
                    {
                        string sLocale = (string)de.Key;
                        string sDesc = (string)de.Value;
                        log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                            + "Adding/Updating formatted value description for unit leaderboard "
                            + uiUnitInXsc
                            + " formatted value name "
                            + sName
                            + " for locale "
                            + sLocale
                            + " in repository.");
                        CLocale locale = new CLocale(sLocale);
                        repository.TitleUnitValueDescSet(tid, uiUnitInXsc, sName, locale, sDesc);
                    }
                }
                else
                {
                    // this name was in the list, but then we couldn't get it... strange
                    log.LogFile("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Unable to get formatted value details for unit leaderboard "
                        + uiUnitInXsc
                        + " formatted value name "
                        + sName
                        + " from xsc file. This formatted value will not be added to the repository.");
                }
            }
        }

        private static void UnitRemoveWebInfo(
            CRepository repository, 
            CTitleId tid, 
            uint uiUnitInXsc)
        {
            repository.TitleUnitDescDeleteAll(tid, uiUnitInXsc);
            repository.TitleUnitAttrDeleteAll(tid, uiUnitInXsc);
            repository.TitleUnitValueDeleteAll(tid, uiUnitInXsc);
        }


        public static void ApplyComps(
            CTitleId tid, 
            CXsc xsc, 
            CRepository repository, 
            ref int iLBCount,
            CLog log)
        {
            // get the default values for entries per cache line
            // and expiration seconds
            uint uiEntriesPerCacheLine;
            uint uiExpirationSeconds;
            repository.ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds);

            // get the list of comp templates in the xsc file
            uint[] rguiCompsInXsc = xsc.CompGetList();

            // get the list of comp templates in the repository
            uint[] rguiCompsInRepository = repository.TitleCompGetList(tid);

            // to make our lives easy, we'll want these as array lists
            ArrayList alCompsInXsc = new ArrayList(rguiCompsInXsc);
            ArrayList alCompsInRepository = new ArrayList(rguiCompsInRepository);

            // for each template in the repository, check to see if 
            // it exists in the xsc. If it is not in the xsc then delete it from the
            // repository.
            foreach (uint uiCompInRepository in alCompsInRepository)
            {
                if (!alCompsInXsc.Contains(uiCompInRepository))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Removing competition template id "
                        + uiCompInRepository
                        + " from the repository for title id "
                        + tid.sTitleIdHexNoPrefix);
                    repository.TitleCompDelete(tid, uiCompInRepository);
                }
            }

            // now for each template in the xsc file, update the 
            // repository to match the defintion in the xsc file
            foreach (uint uiCompInXsc in alCompsInXsc)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating definition of competition template id "
                    + uiCompInXsc
                    + " in the repository for title id "
                    + tid.sTitleIdHexNoPrefix);
                ApplyComp(
                    tid, 
                    xsc, 
                    repository, 
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    uiCompInXsc, 
                    log);
                ++iLBCount;
            }
        }

        public static void ApplyComp(
            CTitleId tid,
            CXsc xsc,
            CRepository repository,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            uint uiCompInXsc,
            CLog log)
        {
            // these are the default values that we use if 
            // nothing is specified in the xsc file for a
            // particular parameter and nothing is currently
            // in the repository
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            // see if there's anything already in the repository
            // these become our new defaults. This will preserve values not
            // specified in the xsc file through the sync, like bDontList
            // or iDefaultStatsDB
            repository.TitleCompGet(
                tid,
                uiCompInXsc,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);

            // We've now collected from the respository the current configuration,
            // including all the stuff that's not specified in the xsc file.
            // However, things that are usually specified in the xsc file we want
            // to reset to defaults if they are now missing. We set these defaults
            // here.
            lbReset = ELBReset.ResetNever;
            uiAttachCount = 0;
            uiMaxAttachSize = 0;
            uiDecayDays = 0;
            bRequireArbitration = true;
            bIsTeam = false;
            eloConfig = null;

            // get the data from the xsc file
            if (!xsc.CompConfigGet(
                uiCompInXsc, 
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen, the list said the leaderboard
                // was in the xsc file. This must be a bug, so throw
                throw new CXscSubmitException("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "CXsc.CompGetList retunred competition template id "
                    + uiCompInXsc
                    + " but CXsc.CompConfigGet returned false for the same competition template id");
            }

            repository.TitleCompSet(
                tid,
                uiCompInXsc,
                lbReset,
                uiAttachCount,
                uiMaxAttachSize,
                uiDecayDays,
                bRequireArbitration,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // are there any leaderboard descriptions in the xsc?
            SortedList slCompDescsInXsc = xsc.CompDescGetList(uiCompInXsc);
            if (slCompDescsInXsc.Count == 0)
            {
                // if there are no template descriptions, then we want
                // to make sure there is no web information at all in the
                // repository for this template
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "No competition template descriptions specified for competition template id "
                    + uiCompInXsc
                    + ". All web information will be removed from the repository for this competition template.");
                CompRemoveWebInfo(repository, tid, uiCompInXsc);
                return;
            }

            // iterate through the competition template descriptions in the repository, and
            // delete any that do not appear in the xsc
            SortedList slCompDescsInRepository = repository.TitleCompDescGetList(tid, uiCompInXsc);
            foreach (DictionaryEntry de in slCompDescsInRepository)
            {
                string sLocale = (string)de.Key;
                if (!slCompDescsInXsc.ContainsKey(sLocale))
                {
                    // this description is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting competition template description for template id "
                        + uiCompInXsc
                        + " for locale "
                        + sLocale
                        + " from repository.");
                    CLocale locale = new CLocale(sLocale);
                    repository.TitleCompDescDelete(tid, uiCompInXsc, locale);
                }
            }

            // Any descriptions that needed deleting have been deleted.
            // Now update or add the descriptions from the xsc.
            foreach (DictionaryEntry de in slCompDescsInXsc)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating competition template description for template id "
                    + uiCompInXsc
                    + " for locale "
                    + sLocale
                    + " in repository.");
                CLocale locale = new CLocale(sLocale);
                repository.TitleCompDescSet(tid, uiCompInXsc, locale, sDesc);
            }
            // template descriptions are now up to date

            // now sync the template attributes
            SortedList slCompAttrsInXsc = xsc.CompAttrGetList(uiCompInXsc);
            SortedList slCompAttrsInRepository = repository.TitleCompAttrGetList(tid, uiCompInXsc);

            // iterate through the template attributes in the repository, and
            // delete any that do not appear in the xsc
            foreach (DictionaryEntry de in slCompAttrsInRepository)
            {
                uint uiId = (uint)de.Key;
                if (!slCompAttrsInXsc.ContainsKey(uiId))
                {
                    // this attribute is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting attribute for competition template id "
                        + uiCompInXsc
                        + " with id "
                        + uiId
                        + " from repository.");
                    repository.TitleCompAttrDelete(tid, uiCompInXsc, uiId);
                }
            }

            // Any attributes that needed deleting have been deleted.
            // Now update or add the attributes from the xsc.
            foreach (DictionaryEntry de in slCompAttrsInXsc)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                    + "Adding/Updating attribute for competition template id "
                    + uiCompInXsc
                    + " with id "
                    + uiId
                    + " in repository.");
                repository.TitleCompAttrSet(tid, uiCompInXsc, uiId, bIsPuid);
            }

            // finally, sync the leaderboard formatted values
            string[] rgsCompValuesInXsc = xsc.CompValueGetList(uiCompInXsc);
            ArrayList alCompValuesInXsc = new ArrayList(rgsCompValuesInXsc);
            string[] rgsCompValuesInRepository = repository.TitleCompValueGetList(tid, uiCompInXsc);

            // iterate through the leaderboard values in the repository, and
            // delete any that do not appear in the xsc
            foreach (string sName in rgsCompValuesInRepository)
            {
                if (!alCompValuesInXsc.Contains(sName))
                {
                    // this formatted value is not found in the xsc, so remove it
                    // from the repository
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Deleting formatted value for competition template id "
                        + uiCompInXsc
                        + " with name "
                        + sName
                        + " from repository.");
                    repository.TitleCompValueDelete(tid, uiCompInXsc, sName);
                }
            }

            // Any formatted values that needed deleting have been deleted.
            // Now update or add the formatted values from the xsc.
            foreach (string sName in rgsCompValuesInXsc)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (xsc.CompValueGet(uiCompInXsc, sName, ref returnType, ref sFormula))
                {
                    log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Adding/Updating formatted value for competition template id "
                        + uiCompInXsc
                        + " with name "
                        + sName 
                        + " in repository.");
                    repository.TitleCompValueSet(tid, uiCompInXsc, sName, returnType, sFormula);

                    // and sync the formatted value descriptions for this value too..
                    SortedList slCompValueDescsInXsc = xsc.CompValueDescGetList(uiCompInXsc, sName);
                    SortedList slCompValueDescsInRepository 
                        = repository.TitleCompValueDescGetList(tid, uiCompInXsc, sName);
                    foreach (DictionaryEntry de in slCompValueDescsInRepository)
                    {
                        string sLocale = (string)de.Key;
                        if (!slCompValueDescsInXsc.ContainsKey(sLocale))
                        {
                            // this description is not found in the xsc, so remove it
                            // from the repository
                            log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                                + "Deleting formatted value description for competition template "
                                + uiCompInXsc
                                + " formatted value name "
                                + sName
                                + " for locale "
                                + sLocale
                                + " from repository.");
                            CLocale locale = new CLocale(sLocale);
                            repository.TitleCompValueDescDelete(tid, uiCompInXsc, sName, locale);
                        }
                    }

                    // Any formatted value descriptions that needed deleting have been deleted.
                    // Now update or add the descriptions from the xsc.
                    foreach (DictionaryEntry de in slCompValueDescsInXsc)
                    {
                        string sLocale = (string)de.Key;
                        string sDesc = (string)de.Value;
                        log.FullTrace("Xbox.Tools.Framework.CXscSubmit.Submit: "
                            + "Adding/Updating formatted value description for competition template id "
                            + uiCompInXsc
                            + " formatted value name "
                            + sName
                            + " for locale "
                            + sLocale
                            + " in repository.");
                        CLocale locale = new CLocale(sLocale);
                        repository.TitleCompValueDescSet(tid, uiCompInXsc, sName, locale, sDesc);
                    }
                }
                else
                {
                    // this name was in the list, but then we couldn't get it... strange
                    log.LogFile("Xbox.Tools.Framework.CXscSubmit.Submit: "
                        + "Unable to get formatted value details for competition template id "
                        + uiCompInXsc
                        + " formatted value name "
                        + sName
                        + " from xsc file. This formatted value will not be added to the repository.");
                }
            }
        }

        private static void CompRemoveWebInfo(
            CRepository repository, 
            CTitleId tid, 
            uint uiCompInXsc)
        {
            repository.TitleCompDescDeleteAll(tid, uiCompInXsc);
            repository.TitleCompAttrDeleteAll(tid, uiCompInXsc);
            repository.TitleCompValueDeleteAll(tid, uiCompInXsc);
        }

        private static void SetStatsLimits(CTitleId tid, CRepository repository, CLog log)
        {
            uint uiMaxWrites = c_uiCompileTimeDefaultMaxWrites;
            uint uiMaxReads = c_uiCompileTimeDefaultMaxReads;

            // get override values from the repository, if they exist
            repository.ServiceDefaultStatsLimitsGet(ref uiMaxWrites, ref uiMaxReads);

            log.Console("Note: Setting statsdb maxwrites to "+uiMaxWrites+" in repository.");
            log.Console("Note: Setting statsdb maxreads to "+uiMaxReads+" in repository.");
            repository.TitleLBLimitsSet(
                tid,
                uiMaxWrites,
                uiMaxReads);
        }
    }

     public class CXscSubmitException : ApplicationException
    {
        public CXscSubmitException() : base() {}
        public CXscSubmitException(string s) : base(s) {}
        protected CXscSubmitException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CXscSubmitException(string s, Exception e) : base(s, e) {}
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CXscValidate.cs ===
using System;
using System.Collections;
using System.CodeDom.Compiler;
using Microsoft.CSharp;

namespace xonline.tools.framework
{
    /// <summary>
    /// This class encapsulates the logic that validiates an Xsc file and checks to see if
    /// it conforms to policy. This class depends on CXsc to parse the xsc file.
    /// </summary>
    public class CXscValidate
    {
        public static bool Validate(CXsc xsc, CTitleId tid, CLog log)
        {
            if (xsc == null)
            {
                throw new ArgumentNullException("xsc");
            }
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CXscValidate.Validate("
                + "{xsc}, "
                + tid.sTitleIdHexNoPrefix + ", "
                + "{log})");

            // get the default locale
            CLocale locDefault = null;
            if (!xsc.DefaultLocaleGet(out locDefault))
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "No default locale specified in xsc file.");
                locDefault = null;
            }

            bool bValid = true;
            if (!ValidateTid(xsc, tid, log))
            {
                bValid = false;
            }
            if (!ValidateLeaderboards(xsc, locDefault, log))
            {
                bValid = false;
            }
            if (!ValidateTemplates(xsc, locDefault, log))
            {
                bValid = false;
            }

            log.StackTrace("Xbox.Tools.Framework.CXscValidate.Validate complete, returning: "
                + bValid);
            return bValid;
        }

        public static bool Policy(
            CXsc xsc,
            uint uiMaxSingleAttachSize,
            uint uiMaxTotalAttachSize,
            uint uiMaxLeaderboardCount,
            CLog log)
        {
            if (xsc == null)
            {
                throw new ArgumentNullException("xsc");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CXscValidate.Policy("
                + "{xsc}, "
                + uiMaxSingleAttachSize+ ", "
                + uiMaxTotalAttachSize+ ", "
                + uiMaxLeaderboardCount+ ", "
                + "{log})");

            bool bValid = true;
            if (!PolicyLeaderboards(
                xsc,
                uiMaxSingleAttachSize,
                uiMaxTotalAttachSize,
                uiMaxLeaderboardCount,
                log))
            {
                bValid = false;
            }
            if (!PolicyTempates(xsc, log))
            {
                bValid = false;
            }

            log.StackTrace("Xbox.Tools.Framework.CXscValidate.Policy complete, returning: "
                + bValid);
            return bValid;
        }

        // checks that the tid in the xsc file matches the tid provided
        private static bool ValidateTid(CXsc xsc, CTitleId tid, CLog log)
        {
            CTitleId tidXsc;
            if (!xsc.TitleIdGet(out tidXsc))
            {
                log.Console("Error: TitleId is missing from XSC file.");
                return false;
            }
            if (tidXsc.uiTitleId != tid.uiTitleId)
            {
                log.Console(
                    "Error: TitleId in XSC file is "
                    + tidXsc.sTitleIdHexNoPrefix
                    + " which does not match expected titleid of "
                    + tid.sTitleIdHexNoPrefix);
                return false;
            }
            log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                + "TitleId in XSC file matches expected TitleId.");
            return true;
        }

        // checks individual and unit leaderboards
        //      checks that each individual or unit leaderboard has a unique leaderboard number
        //      checks that any formatted value formulas are valid
        //      checks that any ELO parameters are valid
        //      checks that a unit leaderboard decay constant was provided, if any
        //          unit leaderboards are present
        //      note: does not check to ensure that there's a default locale
        //          the default locale in the xsc is treated as a suggestion
        //          the authoritative default locale is provided with the title descriptions
        //      This function does attempt to get each piece of data about
        //          each leaderboard, so the log will show any parsing errors. Parsing
        //          errors are not considered invalid, because reasonable defaults are
        //          expected to be used in this case.
        private static bool ValidateLeaderboards(CXsc xsc, CLocale locDefault, CLog log)
        {
            bool bValid = true;

            // keep track of the leaderboard ids to check for duplicates
            Hashtable ht = new Hashtable();

            // get a list of individual leaderboards
            uint[] rguiLBs = xsc.LBGetList();

            foreach (uint uiLB in rguiLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Examining Leaderboard Number "
                    + uiLB);

                // check to see if this is a duplicate leaderboard
                if (ht.ContainsKey(uiLB))
                {
                    log.Console("Error: "
                        + "Leaderboard Number "
                        + uiLB
                        + " is present more than once in XSC file");
                    bValid = false;
                    continue;
                }

                // check to make sure the leaderboard id is not zero
                if (uiLB < 1)
                {
                    log.Console("Error: "
                        + "Leaderboard Number "
                        + uiLB
                        + " is smaller than the minimum allowed value of 1");
                    bValid = false;
                    continue;
                }

                // check to make sure the leaderboard id fits in a 16 bit word
                if (uiLB > UInt16.MaxValue)
                {
                    log.Console("Error: "
                        + "Leaderboard Number "
                        + uiLB
                        + " is larger than maximum allowed value of "
                        + UInt16.MaxValue);
                    bValid = false;
                    continue;
                }

                ht.Add(uiLB, uiLB);

                // run the rest of the validity checks on this leaderboard
                if (!ValidateLeaderboard(xsc, uiLB, locDefault, log))
                {
                    bValid = false;
                }
            }

            // get a list of unit leaderboards
            uint[] rguiUnitLBs = xsc.UnitGetList();

            if (rguiUnitLBs.Length != 0)
            {
                double dDecayFactor;
                if (!xsc.UnitDecayFactorGet(out dDecayFactor))
                {
                    log.Console("Error: "
                        + "No unit leaderboard decay constant was provided, but "
                        + "unit leaderboards were provided.");
                    bValid = false;
                }
            }

            foreach (uint uiUnitLB in rguiUnitLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Examining Unit Leaderboard Number "
                    + uiUnitLB);

                // check to see if this is a duplicate leaderboard
                if (ht.ContainsKey(uiUnitLB))
                {
                    log.Console("Error: "
                        + "Unit Leaderboard Number "
                        + uiUnitLB
                        + " is present more than once in XSC file");
                    bValid = false;
                    continue;
                }

                // check to make sure the leaderboard id is not zero
                if (uiUnitLB < 1)
                {
                    log.Console("Error: "
                        + "Unit Leaderboard Number "
                        + uiUnitLB
                        + " is smaller than minimum allowed value of 1");
                    bValid = false;
                    continue;
                }

                // check to make sure the leaderboard id fits in a 16 bit word
                if (uiUnitLB > UInt16.MaxValue)
                {
                    log.Console("Error: "
                        + "Unit Leaderboard Number "
                        + uiUnitLB
                        + " is larger than maximum allowed value of "
                        + UInt16.MaxValue);
                    bValid = false;
                    continue;
                }

                ht.Add(uiUnitLB, uiUnitLB);

                // run the rest of the validity checks on this unit leaderboard
                if (!ValidateUnitLeaderboard(xsc, uiUnitLB, locDefault, log))
                {
                    bValid = false;
                }
            }

            return bValid;
        }

        private static bool ValidateLeaderboard(
            CXsc xsc,
            uint uiLBNum,
            CLocale locDefault,
            CLog log)
        {
            bool bValid = true;

            // do a LBConfigGet so we have log output from touching every node
            // this will log any errors, but since we have defaults for all this
            // stuff, we don't treat them as a validity problem.
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.LBConfigGet(
                uiLBNum,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the leaderboard was in the list
                // then LBConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of leaderboard number "
                    + uiLBNum);
                bValid = false;
            }

            // make sure the reset type is a valid value
            if (!Enum.IsDefined(lbReset.GetType(), lbReset))
            {
                log.Console("Error: "
                    + "Reset type of "
                    + (int)lbReset
                    + " for leaderboard number "
                    + uiLBNum
                    + " is not valid.");
                bValid = false;
            }

            // if there is an elo config, validate it
            if (eloConfig != null)
            {
                if (!eloConfig.IsValid())
                {
                    log.Console("Error: "
                        + "ELO config for leaderboard number "
                        + uiLBNum
                        + " is not valid. ELO config: "
                        + eloConfig.ToStatsDBString());
                    bValid = false;
                }
            }

            // if arbitration is required, attachments can't be specified
            if (bRequireArbitration)
            {
                if (uiAttachCount != 0 || uiMaxAttachSize != 0)
                {
                    log.Console("Error: "
                        + "Cannot have attachments if arbitration is required on leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
            }

            // get the leaderboard descriptions, if any
            SortedList sl = xsc.LBDescGetList(uiLBNum);

            // if there are descriptions, make sure we have a description for the default locale
            int iDescCount = sl.Count;
            if (iDescCount > 0)
            {
                if (locDefault == null)
                {
                    log.Console("Error: "
                        + "No default locale provided, but descriptions are present on leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No leaderboard description provided for default locale on leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
            }

            // get any raw attributes
            sl = xsc.LBAttrGetList(uiLBNum);

            // invalid to specify attributes without leaderboard descriptions
            if (iDescCount == 0 && sl.Count > 0)
            {
                log.Console("Error: "
                    + "Cannot specify raw attributes for leaderboard "
                    + uiLBNum
                    + " because no leaderboard descriptions are present.");
                bValid = false;
            }

            // warn if any attribute indexes are outside 1 to 64
            foreach (DictionaryEntry de in sl)
            {
                if ((uint)de.Key < 1 || (uint)de.Key > 64)
                {
                    log.Console("Warning: "
                        + "leaderboard "
                        + uiLBNum
                        + " has a raw attribute with index "
                        + (uint)de.Key
                        + " which is not in the range of 1 to 64 inclusive.");
                }
            }

            // get a list of formatted attributes
            string[] rgsNames = xsc.LBValueGetList(uiLBNum);

            // cannot specify formatted attributes if there are no leaderboard descriptions
            if (iDescCount == 0 && rgsNames.Length > 0)
            {
                log.Console("Error: "
                    + "Cannot specify formatted values for leaderboard "
                    + uiLBNum
                    + " because no leaderboard descriptions are present.");
                bValid = false;
            }

            foreach (string sName in rgsNames)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;

                if (!xsc.LBValueGet(
                    uiLBNum,
                    sName,
                    ref returnType,
                    ref sFormula))
                {
                    // shouldn't happen! if it was in the list, then we should be
                    // able to get it
                    log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                        + "Error attempting to get formatted value named "
                        + sName
                        + " for leaderboard number "
                        + uiLBNum);
                    bValid = false;
                }
                else
                {
                    // check the validity of the formula
                    if (!ValidateFormula(sFormula, log))
                    {
                        log.Console("Error: "
                            + "Invalid formula in leaderboard number "
                            + uiLBNum
                            + " for formatted value name "
                            + sName);
                        bValid = false;
                    }
                }

                // get the formatted value descriptions
                sl = xsc.LBValueDescGetList(uiLBNum, sName);

                // a description for the default locale must be provided
                if (sl.Count == 0)
                {
                    log.Console("Error: "
                        + "No formatted value descriptions provided for value "
                        + sName
                        + " on leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
                else if (locDefault == null)
                {
                    log.Console("Error: "
                        + "Formatted value descriptions provided for value "
                        + sName
                        + " on leaderboard "
                        + uiLBNum
                        + " but no default locale specified.");
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No formatted value description provided for value "
                        + sName
                        + " for default locale on leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
            }

            return bValid;
        }

        private static bool ValidateUnitLeaderboard(
            CXsc xsc,
            uint uiLBNum,
            CLocale locDefault,
            CLog log)
        {
            bool bValid = true;

            // do a LBConfigGet so we have log output from touching every node
            // this will log any errors, but since we have defaults for all this
            // stuff, we don't treat them as a validity problem.
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.UnitConfigGet(
                uiLBNum,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the leaderboard was in the list
                // then LBConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of unit leaderboard number "
                    + uiLBNum);
                bValid = false;
            }

            // if there is an elo config, validate it
            if (eloConfig != null)
            {
                if (!eloConfig.IsValid())
                {
                    log.Console("Error: "
                        + "ELO config for unit leaderboard number "
                        + uiLBNum
                        + " is not valid. ELO config: "
                        + eloConfig.ToStatsDBString());
                    bValid = false;
                }
            }

            // get the leaderboard descriptions, if any
            SortedList sl = xsc.UnitDescGetList(uiLBNum);

            // if there are descriptions, make sure we have a description for the default locale
            int iDescCount = sl.Count;
            if (iDescCount > 0)
            {
                if (locDefault == null)
                {
                    log.Console("Error: "
                        + "No default locale provided, but descriptions are present on unit leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No leaderboard description provided for default locale on unit leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
            }

            // get any raw attributes
            sl = xsc.UnitAttrGetList(uiLBNum);

            // invalid to specify attributes without leaderboard descriptions
            if (iDescCount == 0 && sl.Count > 0)
            {
                log.Console("Error: "
                    + "Cannot specify raw attributes for unit leaderboard "
                    + uiLBNum
                    + " because no leaderboard descriptions are present.");
                bValid = false;
            }

            // warn if any attribute indexes are outside 1 to 64
            foreach (DictionaryEntry de in sl)
            {
                if ((uint)de.Key < 1 || (uint)de.Key > 64)
                {
                    log.Console("Warning: "
                        + "Unit leaderboard "
                        + uiLBNum
                        + " has a raw attribute with index "
                        + (uint)de.Key
                        + " which is not in the range of 1 to 64 inclusive.");
                }
            }

            // get a list of formatted attributes
            string[] rgsNames = xsc.UnitValueGetList(uiLBNum);

            // cannot specify formatted attributes if there are no leaderboard descriptions
            if (iDescCount == 0 && rgsNames.Length > 0)
            {
                log.Console("Error: "
                    + "Cannot specify formatted values for unit leaderboard "
                    + uiLBNum
                    + " because no leaderboard descriptions are present.");
                bValid = false;
            }

            foreach (string sName in rgsNames)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;

                if (!xsc.UnitValueGet(
                    uiLBNum,
                    sName,
                    ref returnType,
                    ref sFormula))
                {
                    // shouldn't happen! if it was in the list, then we should be
                    // able to get it
                    log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                        + "Error attempting to get formatted value named "
                        + sName
                        + " for unit leaderboard number "
                        + uiLBNum);
                    bValid = false;
                }
                else
                {
                    // check the validity of the formula
                    if (!ValidateFormula(sFormula, log))
                    {
                        // the ValidateFormula already output to the log
                        bValid = false;
                    }
                }

                // get the formatted value descriptions
                sl = xsc.UnitValueDescGetList(uiLBNum, sName);

                // a description for the default locale must be provided
                if (sl.Count == 0)
                {
                    log.Console("Error: "
                        + "No formatted value descriptions provided for value "
                        + sName
                        + " on unit leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
                else if (locDefault == null)
                {
                    log.Console("Error: "
                        + "Formatted value descriptions provided for value "
                        + sName
                        + " on unit leaderboard "
                        + uiLBNum
                        + " but no default locale specified.");
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No formatted value description provided for value "
                        + sName
                        + " for default locale on unit leaderboard "
                        + uiLBNum);
                    bValid = false;
                }
            }

            return bValid;
        }

        // checks competition leaderboard templates
        //      checks that each template has a unique template id
        //      checks that template ids are in the range 1 to 16 inclusive
        //      checks that any formatted value formulas are valid
        //      checks that any ELO parameters are valid
        //      note: does not check to ensure that there's a default locale
        //          the default locale in the xsc is treated as a suggestion
        //          the authoritative default locale is provided with the title descriptions
        //      This function does attempt to get each piece of data about
        //          each template, so the log will show any parsing errors. Parsing
        //          errors are not considered invalid, because reasonable defaults are
        //          expected to be used in this case.
        private static bool ValidateTemplates(CXsc xsc, CLocale locDefault, CLog log)
        {
            bool bValid = true;

            // keep track of the leaderboard ids to check for duplicates
            Hashtable ht = new Hashtable();

            // get a list of individual leaderboards
            uint[] rguiLBs = xsc.CompGetList();

            foreach (uint uiLB in rguiLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Examining Competition template id "
                    + uiLB);

                // check to see if this is a duplicate template
                if (ht.ContainsKey(uiLB))
                {
                    log.Console("Error: "
                        + "Competition tempalate id "
                        + uiLB
                        + " is present more than once in XSC file");
                    bValid = false;
                    continue;
                }

                ht.Add(uiLB, uiLB);

                if (uiLB < 1 || uiLB > 15)
                {
                    log.Console("Error: "
                        + "Competition template id "
                        + uiLB
                        + " is not in the range of 1 to 15 inclusive");
                    bValid = false;
                }

                // run the rest of the validity checks on this leaderboard
                if (!ValidateTemplate(xsc, uiLB, locDefault, log))
                {
                    bValid = false;
                }
            }

            return bValid;
        }

        private static bool ValidateTemplate(
            CXsc xsc,
            uint uiLBNum,
            CLocale locDefault,
            CLog log)
        {
            bool bValid = true;

            // do a CompConfigGet so we have log output from touching every node
            // this will log any errors, but since we have defaults for all this
            // stuff, we don't treat them as a validity problem.
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.CompConfigGet(
                uiLBNum,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the template was in the list
                // then CompConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of competition template id "
                    + uiLBNum);
                bValid = false;
            }

            // make sure the reset type is a valid value
            if (!Enum.IsDefined(lbReset.GetType(), lbReset))
            {
                log.Console("Error: "
                    + "Reset type of "
                    + (int)lbReset
                    + " for competition template id "
                    + uiLBNum
                    + " is not valid.");
                bValid = false;
            }

            // if there is an elo config, validate it
            if (eloConfig != null)
            {
                if (!eloConfig.IsValid())
                {
                    log.Console("Error: "
                        + "ELO config for competition template id "
                        + uiLBNum
                        + " is not valid. ELO config: "
                        + eloConfig.ToStatsDBString());
                    bValid = false;
                }
            }

            // if arbitration is required, attachments can't be specified
            if (bRequireArbitration)
            {
                if (uiAttachCount != 0 || uiMaxAttachSize != 0)
                {
                    log.Console("Error: "
                        + "Cannot have attachments if arbitration is required on competition template id "
                        + uiLBNum);
                    bValid = false;
                }
            }

            // get the template descriptions, if any
            SortedList sl = xsc.CompDescGetList(uiLBNum);

            // if there are descriptions, make sure we have a description for the default locale
            int iDescCount = sl.Count;
            if (iDescCount > 0)
            {
                if (locDefault == null)
                {
                    log.Console("Error: "
                        + "No default locale provided, but descriptions are present on competition template "
                        + uiLBNum);
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No leaderboard description provided for default locale on competition template "
                        + uiLBNum);
                    bValid = false;
                }
            }

            // get any raw attributes
            sl = xsc.CompAttrGetList(uiLBNum);

            // invalid to specify attributes without leaderboard descriptions
            if (iDescCount == 0 && sl.Count > 0)
            {
                log.Console("Error: "
                    + "Cannot specify raw attributes for competition template "
                    + uiLBNum
                    + " because no competition templates descriptions are present.");
                bValid = false;
            }

            // warn if any attribute indexes are outside 1 to 64
            foreach (DictionaryEntry de in sl)
            {
                if ((uint)de.Key < 1 || (uint)de.Key > 64)
                {
                    log.Console("Warning: "
                        + "Competition template "
                        + uiLBNum
                        + " has a raw attribute with index "
                        + (uint)de.Key
                        + " which is not in the range of 1 to 64 inclusive.");
                }
            }

            // get a list of formatted attributes
            string[] rgsNames = xsc.CompValueGetList(uiLBNum);

            // cannot specify formatted attributes if there are no leaderboard descriptions
            if (iDescCount == 0 && rgsNames.Length > 0)
            {
                log.Console("Error: "
                    + "Cannot specify formatted values for competition template  "
                    + uiLBNum
                    + " because no competition template descriptions are present.");
                bValid = false;
            }

            foreach (string sName in rgsNames)
            {
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;

                if (!xsc.CompValueGet(
                    uiLBNum,
                    sName,
                    ref returnType,
                    ref sFormula))
                {
                    // shouldn't happen! if it was in the list, then we should be
                    // able to get it
                    log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                        + "Error attempting to get formatted value named "
                        + sName
                        + " for competition template id "
                        + uiLBNum);
                    bValid = false;
                }
                else
                {
                    // check the validity of the formula
                    if (!ValidateFormula(sFormula, log))
                    {
                        log.Console("Error: "
                            + "Invalid formula in competition template "
                            + uiLBNum
                            + " for formatted value name "
                            + sName);
                        bValid = false;
                    }
                }

                // get the formatted value descriptions
                sl = xsc.CompValueDescGetList(uiLBNum, sName);
                if (sl.Count == 0)
                {
                    log.Console("Error: "
                        + "No formatted value descriptions provided for value "
                        + sName
                        + " on competition template "
                        + uiLBNum);
                    bValid = false;
                }
                else if (locDefault == null)
                {
                    log.Console("Error: "
                        + "Formatted value descriptions provided for value "
                        + sName
                        + " on competition template "
                        + uiLBNum
                        + " but no default locale specified.");
                    bValid = false;
                }
                else if (!sl.ContainsKey(locDefault.ToString()))
                {
                    log.Console("Error: "
                        + "No formatted value description provided for value "
                        + sName
                        + " for default locale on competition template "
                        + uiLBNum);
                    bValid = false;
                }
            }

            return bValid;
        }

        private static string FormulaSourcePrefix()
        {
            return "using System;\n"
            + "namespace XStatsCompileCode {\n"
            + "    public class XStats {\n"
            + "        XStats() {} \n"
            + "        public object GetDisplayString(object []attr) {\n"
            + "            return ( ";
        }

        private static string FormulaSourceSuffix()
        {
            return "            ); "
            + "        }\n" //end function
            + "        protected string GamerTag(object puid) {return \"TestGamer\";}\n"
            + "        protected string FormatTime(object AttributeId, string FormatString) { return \"\"; }\n"
            + "        protected long AddLong(object Val1, object Val2) { return 0; }"
            + "        protected long SubtractLong(object Val1, object Val2) { return 0; }\n"
            + "        protected long MultiplyLong(object Val1, object Val2) { return 0; }\n"
            + "        protected long DivideLong(object Val1, object Val2) { return 0; }\n"
            + "        protected double AddDouble(object Val1, object Val2) { return 0.0; }\n"
            + "        protected double SubtractDouble(object Val1, object Val2) { return 0.0; }\n"
            + "        protected double MultiplyDouble(object Val1, object Val2) { return 0.0; }\n"
            + "        protected double DivideDouble(object Val1, object Val2) { return 0.0; }\n"
            + "        protected int SubInt(object obj, int StartBit, int NumOfBytes) { return 0; }\n"
            + "    };\n" //end class
            + "}"; //end namespace
        }

        private static bool ValidateFormula(string sFormula, CLog log)
        {
            CompilerResults compilerResults = null;

            // the caller will output any errors to the console in an end user
            // friendly way (stating leaderboard number and formatted value name)
            // we want to output the specific problem we hit to the log only

             // the formula is not allowed to be empty
            if (sFormula.Trim() == "")
            {
                log.LogFile("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "The Formula for a FormattedValue cannot be empty");
                return false;
            }

            // the formula is not allowed to have { or }
            if (sFormula.IndexOf("{") > -1 || sFormula.IndexOf("}") > -1)
            {
                log.LogFile("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "The Formula for a FormattedValue cannot contain '{' or '}' characters");
                return false;
            }

            // put the developer supplied formula in context
            string sSource = FormulaSourcePrefix()
                + sFormula + FormulaSourceSuffix();
            log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                + "Attempting to compile the following C# code:");
            log.FullTrace(sSource);

            // Create the C# compiler
            CSharpCodeProvider csharpCodeProvider = new CSharpCodeProvider();

            // input params for the compiler
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams.ReferencedAssemblies.Add("system.dll");

            // generate a DLL not an exe
            compilerParams.GenerateExecutable = false;

            // Run the compiler and build the assembly
            compilerResults = csharpCodeProvider.CompileAssemblyFromSource(
                compilerParams,
                sSource);

            if (compilerResults.Errors.Count != 0)
            {
                log.LogFile("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Compiler Errors and/or Warnings detected. Errors/Warnings:");
                log.LogFile(CLog.CollectionToString(compilerResults.Errors));
                return false;
            }
            log.FullTrace("Xbox.Tools.Framework.CXscValidate.Validate: "
                +"No Compiler Errors or Warnings detected - Formula is valid");
            return true;
        }

        // checks policy on individual and unit leaderboards
        //      no one leaderboard may have max attachments larger than uiMaxSingleAttachSize
        //      in total, the title must not be able to exceed uiMaxTotalAttachSize
        private static bool PolicyLeaderboards(
            CXsc xsc,
            uint uiMaxSingleAttachSize,
            uint uiMaxTotalAttachSize,
            uint uiMaxLeaderboardCount,
            CLog log)
        {
            bool bValid = true;

            uint uiCumulativeAttachSize = 0;

            // get a list of individual leaderboards
            uint[] rguiLBs = xsc.LBGetList();

            // get a list of unit leaderboards
            uint[] rguiUnitLBs = xsc.UnitGetList();

            if (rguiLBs.Length + rguiUnitLBs.Length > uiMaxLeaderboardCount)
            {
                log.Console("Error: "
                    + rguiLBs.Length
                    + " individual leaderboards are defined and "
                    + rguiUnitLBs.Length
                    + " unit leaderboards are defined, which exceeds the maximum total allowed number of leaderboards of "
                    + uiMaxLeaderboardCount);
                bValid = false;
            }

            foreach (uint uiLB in rguiLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Policy: "
                    + "Examining Leaderboard Number "
                    + uiLB);

                if (!PolicyLeaderboard(
                    xsc,
                    uiLB,
                    uiMaxSingleAttachSize,
                    ref uiCumulativeAttachSize,
                    log))
                {
                    bValid = false;
                }
            }

            if (uiCumulativeAttachSize > uiMaxTotalAttachSize)
            {
                log.Console("Error: "
                    + "Total attachment size for this title could reach "
                    + uiCumulativeAttachSize
                    + " which exceeds the maximum allowed value of "
                    + uiMaxTotalAttachSize);
                bValid = false;
            }

            foreach (uint uiLB in rguiUnitLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Policy: "
                    + "Examining Unit Leaderboard Number "
                    + uiLB);

                if (!PolicyUnitLeaderboard(
                    xsc,
                    uiLB,
                    log))
                {
                    bValid = false;
                }
            }

            return bValid;
        }

        private static bool PolicyLeaderboard(
            CXsc xsc,
            uint uiLBNum,
            uint uiMaxSingleAttachSize,
            ref uint uiCumulativeAttachSize,
            CLog log)
        {
            bool bValid = true;

            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.LBConfigGet(
                uiLBNum,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the leaderboard was in the list
                // then LBConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of leaderboard number "
                    + uiLBNum);
                bValid = false;
            }

            // check to see that we haven't exceeded the max single attachment size policy
            if (uiMaxAttachSize > uiMaxSingleAttachSize)
            {
                log.Console("Error: "
                    + "Max attachment size for leaderboard number "
                    + uiLBNum
                    + " exceeds the maximum allowed value of "
                    + uiMaxSingleAttachSize);
                bValid = false;
            }

            // add this leaderboard's theoretical max storage requirements to the
            // running total
            uiCumulativeAttachSize += uiAttachCount*uiMaxAttachSize;

            return bValid;
        }

        private static bool PolicyUnitLeaderboard(
            CXsc xsc,
            uint uiLBNum,
            CLog log)
        {
            bool bValid = true;

            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.UnitConfigGet(
                uiLBNum,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the leaderboard was in the list
                // then LBConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of unit leaderboard number "
                    + uiLBNum);
                bValid = false;
            }

            // our policy is to require arbitration for unit leaderboards
            if (!bRequireArbitration)
            {
                log.Console("Error: "
                    + "Unit leaderboard number "
                    + uiLBNum
                    + " does not require arbitration. This violates our policy for unit leaderboards.");
                bValid = false;
            }

            return bValid;
        }

        // checks policy on competition templates leaderboards
        //      competition templates must specify arbitration
        private static bool PolicyTempates(
            CXsc xsc,
            CLog log)
        {
            bool bValid = true;

            // get a list of competition templates
            uint[] rguiLBs = xsc.CompGetList();

            foreach (uint uiLB in rguiLBs)
            {
                log.FullTrace("Xbox.Tools.Framework.CXscValidate.Policy: "
                    + "Examining competition template Number "
                    + uiLB);

                if (!PolicyTemplate(
                    xsc,
                    uiLB,
                    log))
                {
                    bValid = false;
                }
            }

            return bValid;
        }

        private static bool PolicyTemplate(
            CXsc xsc,
            uint uiLBNum,
            CLog log)
        {
            bool bValid = true;

            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachCount = 0;
            uint uiMaxAttachSize = 0;
            uint uiDecayDays = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            if (!xsc.CompConfigGet(
                uiLBNum,
                ref lbReset,
                ref uiAttachCount,
                ref uiMaxAttachSize,
                ref uiDecayDays,
                ref bRequireArbitration,
                ref bIsTeam,
                ref eloConfig))
            {
                // this shouldn't happen! if the leaderboard was in the list
                // then LBConfigGet should return true!
                log.Console("Xbox.Tools.Framework.CXscValidate.Validate: "
                    + "Error attempting to get config of leaderboard number "
                    + uiLBNum);
                bValid = false;
            }

            // reset type must be never
            if (lbReset != ELBReset.ResetNever)
            {
                log.Console("Error: "
                    + "Template id "
                    + uiLBNum
                    + " specifies a reset type of "
                    + lbReset
                    + ". Our policy requires competition templates to never reset");
                bValid = false;
            }

            // must use arbitration
            if (!bRequireArbitration)
            {
                log.Console("Error: "
                    + "Template id "
                    + uiLBNum
                    + " does not require arbitration. Our policy is for competition templates "
                    + "to always require arbitration.");
                bValid = false;
            }

            // can't have attachments
            if (uiMaxAttachSize > 0 || uiAttachCount > 0)
            {
                log.Console("Error: "
                    + "Template id "
                    + uiLBNum
                    + " allows attachments. Our policy is for competition templates "
                    + "to not allow attachments.");
                bValid = false;
            }

            return bValid;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\Eesrb.cs ===
namespace xonline.tools.framework 
{
    public enum EESRBRating
    {
        // note these values are defined in private\webcache\common\utilities.cs
        All = 0,
        Adult,
        Mature,
        Teen,
        Everyone,
        KidsToAdults,
        EarlyChildhood,
        Unspecified,
        MinValue = All,
        MaxValue = Unspecified
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\ELanguageName.cs ===
namespace xonline.tools.framework 
{
    public enum ELanguageName
    {
        english = 1,
        japanese = 2,
        german = 3,
        french = 4,
        spanish = 5,
        italian = 6,
        korean = 7,
        chinese = 8,
        portuguese = 9
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CTitleMgr.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.Collections;
using System.Xml;
using System.Globalization;
using xonline.common.service;
using xonline.tools.framework;
using xonline.common.mgmt;

namespace xonline.tools.framework 
{
    public class CTitleMgr
    {
        // the sql username and password that this class should use
        // to access databases. Defaults to null, in which case integrated
        // (windows) security is used.
        private string m_sSqlUser;
        private string m_sSqlPwd;

        // the repository we're using
        private CRepository m_repository;

        // the log the caller wants us to send output to
        private CLog m_log;

        // do we currently have titlemgr locked?
        private bool m_bLocked;
        // what file are we using for the lock?
        private string m_sLockFile;

        // A reasonable, compiled in default for how long to wait
        // for the stats front door to respond - 30 seconds.
        private const int c_iFDTimeoutDefault = 30*1000;

        // A reasonable, compiled in default for how long to wait
        // for an xmgmt command to respond - 10 seconds.
        private const int c_iXmgmtTimeoutDefault = 10*1000;

        // the default query service partition to use during a sync,
        // if none is specified in the repository
        private const int c_uiDefaultQueryPartitionId = 1;

        // the default timeout for UODB queries.  IN SECONDS
        public  const int c_iDefaultUODBTimeout = 30;

        // the database names this object uses
        private const string c_sStatsDBName = "xstats";
        private const string c_sMatchDBName = "xmatch";
        private const string c_sWebDBName = "webdb";
        private const string c_sNPDBName = "npdb";
        private const string c_sQueryDBName = "querydb";
        private const string c_sAlertsDBName = "xboxAlerts";
        public  const string c_sUODBDBName = "UODB";

        // xmgmt component names
        private const string c_sXmgmtMatchFDComponentName = "xmatchfd";
        private const string c_sXmgmtStatsFDComponentName = "xstatsfd";
        private const string c_sXmgmtPresNotiFDComponentName = "xpnfd";
        private const string c_sXmgmtXKDCComponentName = "Xkdc";
        private const string c_sXmgmtXBOSComponentName = "xbos";
        private const string c_sXmgmtFeedbackFDComponentName = "fbserver";
        private const string c_sXmgmtUACSComponentName = "xuacs";
        private const string c_sXmgmtQueryComponentName = "querylib";
        private const string c_sXmgmtWCAlertsComponentName = "wcalerts";
        private const string c_sXmgmtWCGeneralComponentName = "wcgeneral";
        private const string c_sXmgmtWCMessagingComponentName = "wcmessaging";
        private const string c_sXmgmtWCPresenceComponentName = "wcpresence";
        private const string c_sXmgmtWCQueryComponentName = "wcquery";
        private const string c_sXmgmtWCSignatureComponentName = "wcsignature";
        private const string c_sXmgmtWCStatsComponentName = "wcstats";
        private const string c_sXmgmtWCStorageComponentName = "wcstorage";
        private const string c_sXmgmtWCUsersComponentName = "wcusers";

        // the name of the root element in xqs files, and it's attributes
        // <querysim ver="1.0" hexver="0x1000000000000">
        private const string c_sXqsRootElemName = "querysim";
        private const string c_sXqsRootElemVerAttrName = "ver";
        private const string c_sXqsRootElemHexVerAttrName = "hexver";

        public CTitleMgr(
            CRepository repository,
            string sSqlUser,
            string sSqlPwd,
            CLog log)
        {
            if (repository == null)
            {
                throw new ArgumentNullException("repository");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            m_log = log;

            // CTitleMgrApp checks for this, but the intent is for this
            // class to be called by more than just CTitleMgrApp in the
            // future!
            if (sSqlUser == null && sSqlPwd != null)
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.ctor: "
                    + "sSqlUser cannot be null if sSqlPwd is not null";
                m_log.LogFile(sErr);
                throw new ArgumentException(sErr, "sSqlUser");
            }
            if (sSqlPwd == null && sSqlUser != null)
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.ctor: "
                    + "sSqlPwd cannot be null if sSqlUser is not null";
                m_log.LogFile(sErr);
                throw new ArgumentException(sErr, "sSqlPwd");
            }

            m_log.StackTrace(
                "Xbox.Tools.CTitleMgr.ctor(" 
                + "{repository},"
                + (sSqlUser == null ? "null" : sSqlUser) + ","
                + (sSqlPwd == null ? "null" : sSqlPwd) + ")");

            m_repository = repository;
            m_sSqlUser = sSqlUser;
            m_sSqlPwd = sSqlPwd;
            m_bLocked = false;

            m_log.StackTrace("Xbox.Tools.Framework.CTitleMgr.ctor complete");
        }

        // it's a good idea to have only one copy of this class managing
        // a particuar title at a time, across all callers (command line,
        // gui, web widget, etc) across all machines.

        // Right now, we're still using the old "lockfile" method from
        // titlemgr, which completely locks everyone else out of titlemgr,
        // regardless of title.

        // In the future, I intend to use a file checked into the title's
        // directory in source depot for this purpose, so the lock is 
        // only for one title, and so source depot can handle all the 
        // hard concurrency problems across instances and machines.
        public bool Lock(bool bRemove, out string sLockInfo)
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.Lock(" 
                + bRemove.ToString() + ")");
            sLockInfo = null;

            // if we already have the title locked, don't do anything
            if (m_bLocked)
            {
                m_log.LogFile(
                    "TitleMgr is already locked");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.Lock complete");
                return true;
            }

            m_sLockFile = null;
            m_repository.ServiceLockfileGet(ref m_sLockFile);
            if (m_sLockFile == null || m_sLockFile.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                string sErr =
                    "Error: No LOCKFILE entry was found in ini file, unable to lock titlemgr";
                m_log.LogFile(sErr);
                throw new ApplicationException(sErr);
            }

            if (File.Exists(m_sLockFile))
            {
                if (bRemove)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.LogFile(
                        "Breaking existing TitleMgr lock");
                    File.Delete(m_sLockFile);
                }
                else
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.LogFile(
                        "TitleMgr is already locked. Lock details:");
                    StreamReader streamReader = File.OpenText(m_sLockFile);
                    sLockInfo = streamReader.ReadToEnd();
                    m_log.LogFile(sLockInfo);
                    streamReader.Close();
                    m_log.StackTrace(
                        "Xbox.Tools.Framework.CTitleMgr.Lock complete");
                    return false;
                }
            }

            m_log.LogFile("Locking TitleMgr");
            try
            {
                StreamWriter streamWriter = File.CreateText(m_sLockFile);
                streamWriter.WriteLine(Environment.UserName);
                streamWriter.WriteLine(DateTime.Now.ToString());
                streamWriter.Close();
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.LogFile(
                    "Error: exception writing creating lockfile, details:");
                m_log.LogFile(
                    e.Message);

                // we don't want the caller to continue without a lock, so rethrow the 
                // exception
                throw e;
            }
            m_bLocked = true;

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.Lock complete");
            return true;
        }

        public void Unlock()
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.Unlock()");

            if (m_bLocked)
            {
                if (m_sLockFile == null)
                {
                    // this doesn't make sense - if we have the title locked,
                    // we should know the name of the file we used to lock it
                    throw new ApplicationException("Unknown lock file - cannot remove title lock");
                }

                if (File.Exists(m_sLockFile))
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.LogFile(
                        "unlocking TitleMgr");
                    File.Delete(m_sLockFile);
                }
                else
                {
                    // someone must've broken our lock...
                    //   0        1        2        3        4        5        6        7        8
                    m_log.LogFile(
                        "Lock file no longer exists. Someone may have removed your TitleMgr lock");
                }
                m_bLocked = false;
            }
            else
            {
                m_log.LogFile(
                    "Unlock called when title is not locked");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.Unlock complete");
            return;
        }

        // Right now, this simply returns the m_bLocked member. When I rewrite this to
        // properly use source depot, I want this method to actually re-confirm
        // that it's lock has not been broken by another instance of this class.
        public bool Locked
        {
            get
            {
                return m_bLocked;
            }
        }

        public void RunDiagnostics()
        {
            //   0        1        2        3        4        5        6        7        8
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.RunDiagnostics beginning.");

            // check service level settings
            CheckServiceSettings();

            // check connectivity to the non-webstore databases
            CheckDatabaseConnectivity();

            // validate the titlesdb ini setting
            CheckTitlesDBSetting();

            // run health checks on all the servers that support it. This has the 
            /// added benefit of forcing front doors to load, so we'll be able to send
            // xmgmt commands to them later...
            CheckHealth();

            // check that we can communicate with the management service (xmgmtsrv) 
            // on each server we expect to send management commands to, and check
            // if the component we expect is loaded on that server.
            CheckXmgmtConnectivity();

            // now validate each site's configuration...
            uint[] rguiSites = m_repository.ServiceSitesGetList();
            foreach (uint uiSite in rguiSites)
            {
                CheckSite(uiSite);
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.RunDiagnostics complete.");
            return;
        }

        public void StatsSubmitXsc(
            CTitleId tid, 
            string sXscPathAndFileName, 
            bool bIgnorePolicy)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (sXscPathAndFileName == null)
            {
                throw new ArgumentNullException("sXscPathAndFileName");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.StatsSubmitXsc(" 
                + tid.sTitleIdHexNoPrefix + ","
                + sXscPathAndFileName + ","
                + bIgnorePolicy + ")");

            // make sure the xsc file exists
            if (!File.Exists(sXscPathAndFileName))
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.StatsSubmitXsc: "
                    + "xsc file "
                    + sXscPathAndFileName
                    + " does not exist.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // open it
            CXsc xsc = new CXsc(sXscPathAndFileName, m_log);

            // Submit will validate and check policy - no need to
            // do it again here.
            m_log.Console("Submitting XSC file "
                + sXscPathAndFileName
                + " to the repository for titleid "
                + tid.sTitleIdHexNoPrefix);
            if (bIgnorePolicy)
            {
                m_log.Console("Note: policy will not be enforced.");
            }

            bool bSubmitted = false;
            try
            {
                int iLBCount;
                bSubmitted = CXscSubmit.Submit(
                    tid, 
                    xsc, 
                    m_repository, 
                    bIgnorePolicy,
                    out iLBCount,
                    m_log);
                if (bSubmitted == true)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        "XSC file submitted to repository.");
                    m_log.Console(
                        iLBCount+" leaderboards added or updated");

                    // since the submission was successful, archive the submitted file
                    m_repository.TitleArchiveFile(
                        tid, 
                        sXscPathAndFileName, 
                        "archiving submitted xsc file");
                }
                // output for policy violations and validity violations is performed by CXscSubmit
            }
            catch (ApplicationException e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error Exception submitting XSC file. Exception details: "
                    + e.Message);
                m_log.Console("Check log file for more details.");
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.StatsSubmitXsc complete.");
            return;
        }

        public void StatsSync(
            CTitleId tid, 
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bAllowDelete,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.StatsSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + iSqlTimeoutSeconds+ ","
                + iProgressReportIntervalMilliseconds+ ","
                + bAllowDelete + ","
                + bReportOnly + ")");

            // get CServer objects for the Stats database servers
            CServer[] rgServersStatsDB = m_repository.ServiceStatsDBGetList();
            if (rgServersStatsDB.Length < 1)
            {
                // can't sync without a database...
                string sErr = "Xbox.Tools.Framework.CTitleMgr.StatsSync: "
                    + "No stats database servers configured in repository, "
                    + "unable to sync stats.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // convert the CServer objects to connection strings
            string[] rgsStatsDBConnectionStrings = new string[rgServersStatsDB.Length];
            for (int i = 0; i < rgsStatsDBConnectionStrings.Length; ++i)
            {
                rgsStatsDBConnectionStrings[i] = StatsDBConnectionString(rgServersStatsDB[i]);
            }

            // get CServer objects for the Stats front doors
            CServer[] rgServersStatsFD = m_repository.ServiceStatsFDGetList();
            if (rgServersStatsFD.Length < 1)
            {
                // Usually we can sync stats without a front door, but in the
                // case of a leaderboard move, we need to be able to tell the
                // front doors to refresh during the move, so we require one
                // to be configured.
                string sErr = "Xbox.Tools.Framework.CTitleMgr.StatsSync: "
                    + "No stats front doors servers configured in repository, "
                    + "unable to sync stats.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // Get the front the timeout value from the repository. 
            // Use the default compiled into this file if not specified
            int iFrontDoorTimeoutMilliseconds = c_iFDTimeoutDefault;
            m_repository.ServiceFrontDoorTimeoutGet(ref iFrontDoorTimeoutMilliseconds);

            // open a stats object to manage the stats service
            CStats stats = new CStats(
                rgsStatsDBConnectionStrings,
                rgServersStatsFD,
                m_log);

            // StatsSubmitXsc will validate and check policy - we do not want to 
            // do it again here. This way we can hand edit the repository
            // to get around policy, or if the xsc was /force'd in, it
            // will stick

            // sync the stats service with the repository
            CStatsSync.StatsSync(
                tid, 
                m_repository, 
                stats,
                iFrontDoorTimeoutMilliseconds,
                iSqlTimeoutSeconds,
                iProgressReportIntervalMilliseconds,
                bAllowDelete,
                bReportOnly,
                m_log);

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.StatsSync complete.");
            return;
        }

        public void WebDBSync(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.WebDBSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bReportOnly + ")");

            // Get a CServer object for WebDB
            CServer serverWebDB = m_repository.ServiceWebDBGet();
            if (serverWebDB == null)
            {
                // can't sync without a database...
                string sErr = "Xbox.Tools.Framework.CTitleMgr.WebDBSync: "
                    + "No webdb database server configured in repository, "
                    + "unable to sync stats.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // convert the server object into a connection string to webdb
            string sWebDBConnectionString = WebDBConnectionString(serverWebDB);

            // open a web object to manage webdb
            CWebDB webdb = new CWebDB(
                sWebDBConnectionString,
                m_log);

            // sync the stats part of webdb with the repository
            CWebDBSync.WebDBSync(
                tid, 
                m_repository, 
                webdb, 
                bReportOnly, 
                m_log);

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.WebDBSync complete.");
            return;
        }

        public void QuerySubmitXqs(
            CTitleId tid, 
            string sXqsPathAndFileName,
            string sQueryTypeName,
            uint uiPartition)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (sXqsPathAndFileName == null)
            {
                throw new ArgumentNullException("sXqsPathAndFileName");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs(" 
                + tid.sTitleIdHexNoPrefix + ","
                + sXqsPathAndFileName + ")");

            // make sure the xsc file exists
            if (!File.Exists(sXqsPathAndFileName))
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                    + "xqs file "
                    + sXqsPathAndFileName
                    + " does not exist.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // check that the query type provided by the caller is legal
            string[] rgsQueryTypes = m_repository.ServiceQueryTypeGetList();
            if (rgsQueryTypes.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: No query types configured in service.xml.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            ArrayList al = new ArrayList(rgsQueryTypes);
            if (!al.Contains(sQueryTypeName))
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Invalid query type '"+sQueryTypeName+"' specified.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Attempting to parse XQS file "+sXqsPathAndFileName);

            // load the xqs file into an XmlDocument
            XmlDocument xmlDocXqs = new XmlDocument();
            try
            {
                xmlDocXqs.Load(sXqsPathAndFileName);
            }
            catch (XmlException e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception loading XQS file as an XmlDocument.");
                m_log.Console("Exception details: "+e.Message);
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            // create a collection containing all the xqs files currently in the repository
            // replacing the one matching sQueryTypeName with the new xqs file
            m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                +"Collecting xqs data from repository.");
            ArrayList alAllXqsData = new ArrayList();
            foreach (string sValidQueryTypeName in rgsQueryTypes)
            {
                if (sValidQueryTypeName == sQueryTypeName)
                {
                    // use the xqs document that was passed in for this type
                    m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                        +"Using xqs data passed for query type "
                        +sQueryTypeName);
                    alAllXqsData.Add(xmlDocXqs);
                }
                else
                {
                    // use the xml document from the repository, if any
                    XmlDocument xmlDoc = null;
                    if (m_repository.TitleQueryConfigXmlGet(
                        tid,
                        ref xmlDoc,
                        sValidQueryTypeName))
                    {
                        // there was something in the repository, so add it
                        // to the array list
                        m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                            +"Found xqs data in the repository for query type "
                            +sValidQueryTypeName);
                        alAllXqsData.Add(xmlDoc);
                    }
                }
            }

            // create a composite xmldocument containing the combined xqs data
            // from all xqs data types. If this method encounters an error in the
            // data, it will throw a CTitleMgrException
            XmlDocument xmlDocCombined = null;
            try
            {
                xmlDocCombined = QueryCombineXmlDocs(alAllXqsData);
            }
            catch (CTitleMgrException e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception combining XQS data. Exception details: "+e.Message);
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            // try to parse the combined xqs file, if there are no exceptions thrown,
            // then add the contents of the file to the repository
            string[] rgsQueryDBSql;
            string[] rgsNPDBSql;
            try
            {
                CXqsParse.XqsParse(xmlDocCombined.OuterXml, tid.uiTitleId, false, uiPartition, out rgsQueryDBSql, out rgsNPDBSql);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception parsing XQS file. Exception details: "+e.Message);
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("XQS data combined and parsed successfully, saving to repository");

            // if we get here, there were no errors parsing the xqs file along with the information 
            // in the repository, so check it into the repository.
            // Also remember the xqs partition. Partition is just the index into the array of query servers 
            // stored in the repository, like "statsdb".
            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Note: This title will use partition id "+uiPartition);
            m_repository.TitleQueryPartitionSet(tid, uiPartition);
            m_repository.TitleQueryConfigXmlSet(tid, xmlDocXqs, sQueryTypeName);
            m_repository.TitleSubmit(tid, "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: new xqs file");

            // the xqs file was accepted, so archive the submitted xqs file
            m_repository.TitleArchiveFile(
                tid, 
                sXqsPathAndFileName, 
                "archiving submitted xqs file");

            m_log.Console("Success: XQS file submitted to repository.");

            //   0        1        2        3        4        5        6        7        8
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
            return;
        }

        public void QuerySync(
            CTitleId tid,
            bool bDropTables,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.QuerySync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bDropTables + ","
                + bReportOnly + ")");

            // create a collection containing all the xqs files currently in the repository
            m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                +"Collecting xqs data from repository.");
            ArrayList alAllXqsData = new ArrayList();
            string[] rgsQueryTypes = m_repository.ServiceQueryTypeGetList();
            foreach (string sValidQueryTypeName in rgsQueryTypes)
            {
                XmlDocument xmlDoc = null;
                if (m_repository.TitleQueryConfigXmlGet(
                    tid,
                    ref xmlDoc,
                    sValidQueryTypeName))
                {
                    // there was something in the repository, so add it
                    // to the array list
                    m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs: "
                        +"Found xqs data in the repository for query type "
                        +sValidQueryTypeName);
                    alAllXqsData.Add(xmlDoc);
                }
            }

            if (alAllXqsData.Count == 0)
            {
                // this title doesn't have any query service xml configuration
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Title has no query service config, skipping query sync.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySync complete.");
                return;
            }

            // create a composite xmldocument containing the combined xqs data
            // from all xqs data types. If this method encounters an error in the
            // data, it will throw a CTitleMgrException
            XmlDocument xmlDocCombined = null;
            try
            {
                xmlDocCombined = QueryCombineXmlDocs(alAllXqsData);
            }
            catch (CTitleMgrException e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception combining XQS data. Exception details: "+e.Message);
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySubmitXqs complete.");
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Beginning query service sync");

            // get the partitionid to pass to CXqsParse, default to compiled in value if not
            // specified in the repository.
            uint uiPartitionId = c_uiDefaultQueryPartitionId;
            m_repository.TitleQueryPartitionGet(tid, ref uiPartitionId);
            m_log.LogFile("Xbox.Tools.Framework.CTitleMgr.QuerySync: "
                +"Using query partition "+uiPartitionId);
            if (bDropTables)
            {
                m_log.Console("Note: Existing tables will be dropped.");
            }
            else
            {
                m_log.Console("Note: Existing tables will not be dropped.");
            }

            // generate the sql - this shouldn't fail, since we parsed it when it was submitted
            string[] rgsQueryDBSql;
            string[] rgsNPDBSql;
            try
            {
                CXqsParse.XqsParse(
                    xmlDocCombined.OuterXml, 
                    tid.uiTitleId, 
                    bDropTables, 
                    uiPartitionId, 
                    out rgsQueryDBSql, 
                    out rgsNPDBSql);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception parsing XQS file. Exception details: "+e.Message);
                m_log.Console("Note: Query service NOT syncronized due to error.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.QuerySync complete.");
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Query service configuration retrieved from repository.");

            // get the querydb and npdb servers from the repository
            CServer[] rgServersQueryDB = m_repository.ServiceQueryDBGetList();
            CServer serverNPDB = m_repository.ServiceNPDBGet();

            // run the generated sql on each querydb server
            foreach (CServer server in rgServersQueryDB)
            {
                RunSqlCommands(QueryDBConnectionString(server), rgsQueryDBSql, bReportOnly);
            }

            // run the generated sql on npdb
            RunSqlCommands(NPDBConnectionString(serverNPDB), rgsNPDBSql, bReportOnly);
            SaveXqsInNPDB(NPDBConnectionString(serverNPDB), tid.uiTitleId, xmlDocCombined, bReportOnly);

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Success: Query service sync complete.");

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.QuerySync complete.");
            return;
        }

        // for help purposes, we want to be able to ask CTitleMgr for the list of
        // supported query types
        public string[] QueryTypeGetList()
        {
            return m_repository.ServiceQueryTypeGetList();
        }

        private XmlDocument QueryCombineXmlDocs(ArrayList alAllXqsData)
        {
            // we need to create a combined xqs xml document that contains 
            // one querysim element that has as children all the child nodes 
            // of each querysim element in each of the input documents

            // there should be at least one document in the array list
            if (alAllXqsData == null)
            {
                throw new ArgumentNullException("alAllXqsData");
            }
            if (alAllXqsData.Count == 0)
            {
                throw new ArgumentException("ArrayList cannot have Count = 0", "alAllXqsData");
            }

            // create the combined document and add the xml header
            XmlDocument xmlDocCombined = new XmlDocument();
            XmlDeclaration xmlDecl = xmlDocCombined.CreateXmlDeclaration("1.0","UTF-8","no");
            xmlDocCombined.InsertBefore(xmlDecl, xmlDocCombined.DocumentElement);

            // walk through the querysim nodes on all the documents, and make sure that
            // the version and hexver attributes all match
            string sFirstVer = null;
            string sFirstHexVer = null;
            string sCurVer = null;
            string sCurHexVer = null;
            foreach (XmlDocument xmlDoc in alAllXqsData)
            {
                // grab the versions off the querysim node
                XmlNode xmlNode = xmlDoc.SelectSingleNode("/"+c_sXqsRootElemName+"/@"+c_sXqsRootElemVerAttrName);
                if (xmlNode == null)
                {
                    string sErr = "Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                        + "Error parsing Xqs data -unable to locate "
                        + c_sXqsRootElemVerAttrName
                        + " attribute on "
                        + c_sXqsRootElemName
                        + " element";
                    m_log.LogFile(sErr);
                    throw new CTitleMgrException(sErr);
                }
                sCurVer = xmlNode.Value;

                xmlNode = xmlDoc.SelectSingleNode("/"+c_sXqsRootElemName+"/@"+c_sXqsRootElemHexVerAttrName);
                if (xmlNode == null)
                {
                    string sErr = "Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                        + "Error parsing Xqs data -unable to locate "
                        + c_sXqsRootElemHexVerAttrName
                        + " attribute on "
                        + c_sXqsRootElemName
                        + " element";
                    m_log.LogFile(sErr);
                    throw new CTitleMgrException(sErr);
                }
                sCurHexVer = xmlNode.Value;

                // make sure the versions match (or save them if these are the first ones we've looked at)
                if (sFirstVer == null)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                        +"First "
                        + c_sXqsRootElemName
                        +" element has "
                        + c_sXqsRootElemVerAttrName
                        + "="
                        + sCurVer
                        + ", "
                        + c_sXqsRootElemHexVerAttrName
                        + "="
                        + sCurHexVer);
                    sFirstVer = sCurVer;
                    sFirstHexVer = sCurHexVer;
                }
                else
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                        +"Additional "
                        + c_sXqsRootElemName
                        +" element has "
                        + c_sXqsRootElemVerAttrName
                        + "="
                        + sCurVer
                        + ", "
                        + c_sXqsRootElemHexVerAttrName
                        + "="
                        + sCurHexVer);
                    if (sFirstVer != sCurVer)
                    {
                        string sErr = "Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                            + "Error combining xqs data - "
                            + c_sXqsRootElemVerAttrName
                            + " attribute on "
                            + c_sXqsRootElemName
                            + " element must match on all documents";
                        m_log.LogFile(sErr);
                        throw new CTitleMgrException(sErr);
                    }
                    if (sFirstHexVer != sCurHexVer)
                    {
                        string sErr = "Xbox.Tools.Framework.CTitleMgr.QueryCombineXmlDocs: "
                            + "Error combining xqs data - "
                            + c_sXqsRootElemHexVerAttrName
                            + " attribute on "
                            + c_sXqsRootElemName
                            + " element must match on all documents";
                        m_log.LogFile(sErr);
                        throw new CTitleMgrException(sErr);
                    }
                }
            }

            // if we make it to here, then we know the ver and hexver attributes
            // on all the querysim nodes match, so we can safely combine them into
            // one larger querysim node to feed to the parser.

            // create the new querysim node, set the version attributes, and add it to the 
            // combined document
            XmlElement xmlElemQuerySim = xmlDocCombined.CreateElement(c_sXqsRootElemName);
            xmlElemQuerySim.SetAttribute(c_sXqsRootElemVerAttrName, sFirstVer);
            xmlElemQuerySim.SetAttribute(c_sXqsRootElemHexVerAttrName, sFirstHexVer);
            xmlDocCombined.AppendChild(xmlElemQuerySim);

            // now, iterate through each input xml document, and insert the children
            // of the querysim node into the new combined xml document
            foreach (XmlDocument xmlDoc in alAllXqsData)
            {
                // get the querysim node...
                XmlNode xmlNode = xmlDoc.SelectSingleNode("/"+c_sXqsRootElemName);

                // copy each child of the querysim node over to the new document
                foreach (XmlNode xmlNodeChild in xmlNode.ChildNodes)
                {
                    // copy this child
                    XmlDocumentFragment xmlDocFrag = xmlDocCombined.CreateDocumentFragment();
                    xmlDocFrag.InnerXml = xmlNodeChild.OuterXml;
                    xmlElemQuerySim.AppendChild(xmlDocFrag);
                }
            }

            // we now have a combined document, return it.
            return xmlDocCombined;
        }

        private void RunSqlCommands(string sConnectionString, string[] rgsSql, bool bReportOnly)
        {
            SqlConnection sqlConnection = new SqlConnection(sConnectionString);

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Syncronizing query service config in "+sqlConnection.Database+" on "+sqlConnection.DataSource);
            try
            {
                sqlConnection.Open();
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception opening connection to "+sqlConnection.Database+" on "+sqlConnection.DataSource);
                m_log.Console("Error: Aborting query service sync.");
                throw new CTitleMgrException("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                    + "Error: Exception opening connection to "
                    + sqlConnection.Database
                    + " on "
                    + sqlConnection.DataSource,
                    e);
            }
            try
            {
                foreach (string sSql in rgsSql)
                {
                    SqlCommand sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandType = CommandType.Text;
                    sqlCommand.CommandText = sSql;
                    m_log.DataMod("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                        + "Executing SqlCommand on "
                        + sqlConnection.Database
                        + " on "
                        + sqlConnection.DataSource);
                    m_log.DataMod(sSql);
                    if (!bReportOnly)
                    {
                        sqlCommand.ExecuteNonQuery();
                    }
                }
            }
            finally
            {
                if (sqlConnection != null)
                {
                    sqlConnection.Close();
                }
            }
        }

        private void SaveXqsInNPDB(
            string sConnectionString, 
            uint uiTitleId, 
            XmlDocument xmlDocXqs, 
            bool bReportOnly)
        {
            // extract the hexver attribute from the xqs data
            XmlAttribute xmlAttr = (XmlAttribute)xmlDocXqs.SelectSingleNode("/querysim/@hexver");
            if (xmlAttr == null || xmlAttr.Value == String.Empty)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Cannot extract 'hexver' from query service config");
                m_log.Console("Error: Aborting query service sync.");
                throw new CTitleMgrException("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                    + "Error: Cannot extract 'hexver' from query service config");
            }
            m_log.FullTrace("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                + "Found hexver attribute containing "
                + xmlAttr.Value);

            // pick off the leading 0x, if it's there
            string sHexVer = xmlAttr.Value.Trim().ToLower();
            if (sHexVer.Length >= 2)
            {
                if (sHexVer.Substring(0, 2) == "0x")
                {
                    sHexVer = sHexVer.Substring(2);
                }
            }

            Int64 biVersion;
            try
            {
                biVersion = Int64.Parse(sHexVer, NumberStyles.HexNumber);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Unable to parse 'hexver' from query service config");
                m_log.Console("Error: Aborting query service sync.");
                throw new CTitleMgrException("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                    + "Error: Unable to parse 'hexver' from query service config",
                    e);
            }

            SqlConnection sqlConnection = new SqlConnection(sConnectionString);

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Saving raw query service config in "+sqlConnection.Database+" on "+sqlConnection.DataSource);
            try
            {
                sqlConnection.Open();
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Error: Exception opening connection to "+sqlConnection.Database+" on "+sqlConnection.DataSource);
                m_log.Console("Error: Aborting query service sync.");
                throw new CTitleMgrException("Xbox.Tools.Framekwork.CTitleMgr.QuerySync: "
                    + "Error: Exception opening connection to "
                    + sqlConnection.Database
                    + " on "
                    + sqlConnection.DataSource,
                    e);
            }
            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_query_save_config";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)uiTitleId;
                sqlCommand.Parameters.Add("@bi_version", SqlDbType.BigInt).Value = (Int64)biVersion;
                sqlCommand.Parameters.Add("@xqs", SqlDbType.Text).Value = (string)xmlDocXqs.OuterXml;
                if (!bReportOnly)
                {
                    sqlCommand.ExecuteNonQuery();
                }
            }
            finally
            {
                if (sqlConnection != null)
                {
                    sqlConnection.Close();
                }
            }
        }

        public void GameConfigSubmit(
            CTitleId tid,
            string gameConfigPathAndFileName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            if (gameConfigPathAndFileName == null)
            {
                throw new ArgumentNullException("gameConfigPathAndFileName");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit(" 
                + tid.sTitleIdHexNoPrefix + ","
                + gameConfigPathAndFileName + ")");

            // make sure the game config file exists
            if (!File.Exists(gameConfigPathAndFileName))
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit: "
                    + "game config file "
                    + gameConfigPathAndFileName
                    + " does not exist.";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Saving game config to repository");
            m_repository.TitleGameConfigSet(tid, gameConfigPathAndFileName);

            // the game config file was accepted, so archive the submitted file
            m_repository.TitleArchiveFile(
                tid, 
                gameConfigPathAndFileName, 
                "archiving submitted game config file");

            m_log.Console("Success: game config file submitted to repository.");

            //   0        1        2        3        4        5        6        7        8
            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit complete.");
            return;
        }

        public void GameConfigSync(
            CTitleId tid,
            bool reportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.GameConfigSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + reportOnly + ")");

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Beginning game config sync");

            // see if there's a game config to sync
            if (!m_repository.TitleGameConfigExists(tid))
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("No game config data in repository, skipping game config sync.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.GameConfigSync complete.");
                return;
            }

            // there is a game config, so get it
            FileStream gameConfig = m_repository.TitleGameConfigGet(tid);
            if (gameConfig == null)
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit: "
                    + "CRepository.TitleGameConfigGet returned null unexpectedly";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // read the file into one big string, so we can pass it to the stored proc.
            StreamReader reader = new StreamReader(gameConfig);
            if (reader == null)
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit: "
                    + "Unable to create StreamReader object";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            string gameConfigText = reader.ReadToEnd();
            if (gameConfigText == null)
            {
                string sErr = "Xbox.Tools.Framework.CTitleMgr.GameConfigSubmit: "
                    + "StreamReader.ReadToEnd() returned null";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Game config retrieved from repository.");

            // get the npdb server from the repository
            CServer serverNPDB = m_repository.ServiceNPDBGet();

            using (SqlConnection sqlConnection = new SqlConnection(NPDBConnectionString(serverNPDB)))
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("Saving game config in "+sqlConnection.Database+" on "+sqlConnection.DataSource);
                try
                {
                    sqlConnection.Open();
                }
                catch (Exception e)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console("Error: Exception opening connection to "+sqlConnection.Database+" on "+sqlConnection.DataSource);
                    m_log.Console("Error: Aborting game config sync.");
                    throw new CTitleMgrException("Xbox.Tools.Framekwork.CTitleMgr.TitleGameConfigGet: "
                        + "Error: Exception opening connection to "
                        + sqlConnection.Database
                        + " on "
                        + sqlConnection.DataSource,
                        e);
                }

                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_game_save_config";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("@xml_config", SqlDbType.NText).Value = (string)gameConfigText;
		//this will soon be gone.
                sqlCommand.Parameters.Add("@vc_xdk_version", SqlDbType.VarChar).Value = "DEFAULT";
                if (!reportOnly)
                {
                    sqlCommand.ExecuteNonQuery();
                }
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Success: Query service sync complete.");
        }

        public void AlertsSync(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.AlertsSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bReportOnly + ")");

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Sending title descriptions to alerts service");

            // get the ip of the alerts server from the repository
            CServer server = m_repository.ServiceAlertsDBGet();
            if (server == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("No ALERTSDB entry found in servers.ini, unable to sync alerts.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.AlertsSync complete.");
                return;
            }
            string sAlertsServer = server.rgipAddresses[0].ToString();

            CAlertsMgr alertsMgr = new CAlertsMgr(sAlertsServer, null);

            CAlertsSync.AlertsSync(
                tid, 
                m_repository, 
                alertsMgr,
                bReportOnly,
                m_log);

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Success: Alerts service sync complete.");

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.AlertsSync complete.");
            return;
        }


        public void NPDBSync(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.NPDBSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bReportOnly + ")");

            // get the ip of the NPDB server from the repository
            CServer server = m_repository.ServiceNPDBGet();
            if (server == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console("No NPDB entry found in servers.ini, unable to sync NPDB.");
                m_log.StackTrace(
                    "Xbox.Tools.Framework.CTitleMgr.NPDBSync complete.");
                return;
            }

            string sNPDBConnectionString = NPDBConnectionString(server);

            CNPDB npdb = new CNPDB(
                sNPDBConnectionString,
                m_log);
            try
            {
                CNPDBSync.NPDBSync(
                    tid, 
                    m_repository, 
                    npdb,
                    bReportOnly,
                    m_log);
            }
            finally
            {
                if (npdb != null)
                {
                    npdb.Close();
                }
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.NPDBSync complete.");
            return;
        }

        private string BuildConnectionString(CServer server, string sDBName)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("Address=");
            sb.Append(server.rgipAddresses[0].ToString());
            sb.Append(";Database=");
            sb.Append(sDBName);
            if (m_sSqlUser != null && m_sSqlPwd != null)
            {
                sb.Append(";User ID=");
                sb.Append(m_sSqlUser);
                sb.Append(";Password=");
                sb.Append(m_sSqlPwd);
            }
            else
            {
                sb.Append(";Integrated Security=true");
            }
            return sb.ToString();
        }

        private string StatsDBConnectionString(CServer server)
        {
            return BuildConnectionString(server, c_sStatsDBName);
        }
        private string WebDBConnectionString(CServer server)
        {
            return BuildConnectionString(server, c_sWebDBName);
        }
        private string QueryDBConnectionString(CServer server)
        {
            return BuildConnectionString(server, c_sQueryDBName);
        }
        private string NPDBConnectionString(CServer server)
        {
            return BuildConnectionString(server, c_sNPDBName);
        }

        private string GetSdInfoValue(string sSdInfoLinePrefix)
        {
            // run sd info and capture the results in a string
            string sSdInfo = sdinfo();

            // find the location of the line prefix in the sd info output
            int iSdInfoLinePrefix = sSdInfo.IndexOf(sSdInfoLinePrefix);
            if (iSdInfoLinePrefix == -1)
            {
                string sErr = "Unable to find '"
                    + sSdInfoLinePrefix
                    + "' in output from sd info command";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // make sure we not going to go past the end of the string...
            if (iSdInfoLinePrefix + sSdInfoLinePrefix.Length > sSdInfo.Length-1)
            {
                string sErr = "No data follows '"
                    + sSdInfoLinePrefix
                    + "' in output from sd info command";
                m_log.LogFile(sErr);
                throw new CTitleMgrException(sErr);
            }

            // this should be in range, since we've checked the length of the string above
            string sSdInfoValue = sSdInfo.Substring(iSdInfoLinePrefix + sSdInfoLinePrefix.Length);

            // the value we need is before the first newline
            // if there is no newline between the start of our value and the end of the
            // sd info output, then Split[0] will still get us the string we want
            sSdInfoValue = sSdInfoValue.Split('\n')[0];

            // trim any whitespace, and return the value
            return sSdInfoValue.Trim();
        }

        private string GetSdClientName()
        {
            return GetSdInfoValue("Client name:");
        }

        private string GetSdClientRoot()
        {
            return GetSdInfoValue("Client root:");
        }

        private static string sdinfo()
        {
            Process p = new Process();
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.FileName = "sd";
            p.StartInfo.Arguments = "info";
            p.Start();
            string output = p.StandardOutput.ReadToEnd();
            p.WaitForExit();
            return output.Trim();
        }

        private void CheckServiceSettings()
        {
            // check to make sure at least one query type is configured in the repository
            string[] rgsQueryTypeNames = m_repository.ServiceQueryTypeGetList();
            if (rgsQueryTypeNames.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No query service types configured in service.xml");
            }
            else
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Query service types in service.xml OK");
                //   0        1        2        3        4        5        6        7        8
                m_log.LogFile(
                    "Configured Query service types: "+CLog.CollectionToString(rgsQueryTypeNames));
            }
        }

        private void CheckDatabaseConnectivity()
        {
            // Note - the error messages here break the encapsulation of the
            // repository object by identifying problems in particular files,
            // e.g. servers.ini. If we reorg the repository, these messages
            // will no longer be accurate. However, in order to be at all useful
            // the error message must be detailed and specific.

            // check connectivity to the non webstore databases titlemgr touches

            CServer[] rgServers;

            // match
            rgServers = m_repository.ServiceMatchDBGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No MATCHDB servers configured in servers.ini");
            }
            else
            {
                foreach (CServer server in rgServers)
                {
                    AttemptDatabaseConnection(server, c_sMatchDBName);
                }
            }

            // webdb
            CServer serverWebDB = m_repository.ServiceWebDBGet();
            if (serverWebDB == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No WEBDB server configured in servers.ini");
            }
            else
            {
                AttemptDatabaseConnection(serverWebDB, c_sWebDBName);
            }

            // npdb
            CServer serverNPDB = m_repository.ServiceNPDBGet();
            if (serverNPDB == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No NPDB server configured in servers.ini");
            }
            else
            {
                AttemptDatabaseConnection(serverNPDB, c_sNPDBName);
            }

            // query service dbs
            rgServers = m_repository.ServiceQueryDBGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No QUERYDB servers configured in servers.ini");
            }
            else
            {
                foreach (CServer server in rgServers)
                {
                    AttemptDatabaseConnection(server, c_sQueryDBName);
                }
            }

            // alertsdb
            CServer serverAlertsDB = m_repository.ServiceAlertsDBGet();
            if (serverAlertsDB == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: No ALERTSDB server configured in servers.ini");
            }
            else
            {
                AttemptDatabaseConnection(serverAlertsDB, c_sAlertsDBName);
            }

        }

        private void AttemptDatabaseConnection(
            CServer server, 
            string sDBName)
        {
            string sIP = server.rgipAddresses[0].ToString();
            string sConnectionString 
                = "Server=" 
                + sIP
                + ";Database=" 
                + sDBName;

            // if we have a sql username and password, then use them, otherwise
            // use integrated security
            if(m_sSqlUser != null && m_sSqlPwd != null)
            {
                sConnectionString += ";User ID=" + m_sSqlUser + ";Pwd=" + m_sSqlPwd;
            }
            else
            {
                sConnectionString += ";Integrated Security=true";
            }

            // turn pooling off to ensure we really try to connect
            sConnectionString += ";Pooling=false";

            //   0        1        2        3        4        5        6        7        8
            m_log.FullTrace(
                "Connecting to database using SQL connection string:");
            m_log.FullTrace(
                sConnectionString);

            bool bThrown = false;
            SqlConnection sqlConnection = new SqlConnection(sConnectionString);

            try
            {
                sqlConnection.Open();
            }
            catch (Exception e)
            {
                bThrown = true;
                //   0        1        2        3        4        5        6        7        8
                m_log.LogFile(
                    "Exception connecting to " + sDBName + " on " + sIP + ". Details:");
                m_log.LogFile(
                    e.Message);
            }

            if (!bThrown 
                && ((sqlConnection.State & ConnectionState.Open) == ConnectionState.Open))
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Connection to " + sDBName + " on " + sIP + " OK");
                sqlConnection.Close();
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            m_log.Console(
                "Error: Unable to connect to " + sDBName + " on " + sIP);
            return;
        }

        private void CheckTitlesDBSetting()
        {
            //   0        1        2        3        4        5        6        7        8
            m_log.StackTrace(
                "Checking TITLESDB setting");

            CServer serverTitle = m_repository.ServiceTitlesDBGet();
            if(serverTitle == null)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: TITLESDB setting is either missing or invalid");
                return;
            }

            CServer[] rgServers = m_repository.ServiceMatchDBGetList();
            foreach (CServer server in rgServers)
            {
                if (server.rgipAddresses[0].ToString()
                    == serverTitle.rgipAddresses[0].ToString())
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.FullTrace(
                        "Found a MATCHDB setting that matches the TITLESDB setting.");
                    m_log.Console(
                        "TITLESDB entry OK");
                    return;
                }
            }

            // if we get here, there was no matching MATCHDB entry
            //   0        1        2        3        4        5        6        7        8
            m_log.Console(
                "Error: TITLESDB setting must match one of the MATCHDB settings");
            return;
        }

        private void CheckXmgmtConnectivity()
        {
            // the timeout to use when communicating with the front doors
            // default to the value compiled into this file, unless
            // it has been specified in the repository
            int iTimeout = c_iXmgmtTimeoutDefault;
            m_repository.ServiceXmgmtTimeoutGet(ref iTimeout);

            CServer[] rgServers = m_repository.ServiceStatsFDGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: STATSFD missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtStatsFDComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceMatchFDGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: MATCHFD missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtMatchFDComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServicePresNotiFDGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: PNFD missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtPresNotiFDComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceXKDCGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: XKDC missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtXKDCComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceXBOSGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: XBOS missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtXBOSComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceFeedbackFDGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: FDBKFD missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtFeedbackFDComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceUACSGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: UACS missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtUACSComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceQueryFDGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: XQRY missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtQueryComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCAlertsGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCALERTS missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCAlertsComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCGeneralGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCGENERAL missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCGeneralComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCMessagingGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCMESSAGING missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCMessagingComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCPresenceGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCPRESENCE missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCPresenceComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCQueryGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCQUERY missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCQueryComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCSignatureGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCSIGNATURE missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCSignatureComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCStatsGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCSTATS missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCStatsComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCStorageGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCSTORAGE missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCStorageComponentName,
                    iTimeout);
            }

            rgServers = m_repository.ServiceWCUsersGetList();
            if (rgServers.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: WCUSERS missing from servers.ini");
            }
            foreach (CServer server in rgServers)
            {
                AttemptXmgmtConnection(
                    server, 
                    c_sXmgmtWCUsersComponentName,
                    iTimeout);
            }
        }

        private void AttemptXmgmtConnection(
            CServer server, 
            string sComponent,
            int iTimeoutMilliseconds)
        {
            //int iXmgmtTimeout = 10 * 1000;

            IPAddress ipAddr = server.rgipAddresses[0];

            //   0        1        2        3        4        5        6        7        8
            m_log.FullTrace(
                "Connecting to xmgmtsrv on " + ipAddr.ToString());

            XomAdminSession xomAdminSession;
            try
            {
                xomAdminSession = new XomAdminSession(ipAddr);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.LogFile(
                    "Exception connecting to xmgmtsrv on " + ipAddr.ToString() + ". Details:");
                m_log.LogFile(
                    e.Message);
                m_log.Console(
                    "Error: Unable to connect to xmgmtsrv on " + ipAddr.ToString());
                return;
            }

            // send a 'list' request and see if the component we're looking for is listed
            bool bComponentFound = false;
            try
            {
                string[] rgsResponses;
                int hrResultCode;
                xomAdminSession.SendRequest(
                    "list", 
                    iTimeoutMilliseconds, 
                    out rgsResponses, 
                    out hrResultCode);
                if (hrResultCode != 0)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        "Error: 'list' returned " + hrResultCode.ToString("x") + " on " + ipAddr.ToString());
                }
                else
                {
                    // look in the responses for the component name we're looking for
                    //   0        1        2        3        4        5        6        7        8
                    m_log.FullTrace(
                        "list results:");
                    foreach (string sResponse in rgsResponses)
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.FullTrace(
                            sResponse);

                        // look for the component name at the end of the string
                        // with leading space, otherwise we could match on a 
                        // substring!
                        string sResponseTrim = sResponse.Trim();
                        if (sResponseTrim.EndsWith(" " + sComponent))
                        {
                            bComponentFound = true;
                        }
                    }
                }
                
                if (!bComponentFound)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        "Error: Component " + sComponent + " not found on server " + ipAddr.ToString());
                }
                else
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.FullTrace(
                        "Found component " + sComponent + " on server " + ipAddr.ToString());

                    // we found it, see if we can get help for it
                    xomAdminSession.SendCommand(
                        null, 
                        sComponent,
                        "help",
                        iTimeoutMilliseconds, 
                        out rgsResponses, 
                        out hrResultCode);
                    if (hrResultCode != 0)
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Error: " + sComponent + " returned " + hrResultCode.ToString("x") + " to help on " + ipAddr.ToString());
                    }
                    else
                    {
                        // dump the help to the log file
                        //   0        1        2        3        4        5        6        7        8
                        m_log.FullTrace(
                            "help results for " + sComponent + ":");
                        foreach (string sResponse in rgsResponses)
                        {
                            //   0        1        2        3        4        5        6        7        8
                            m_log.FullTrace(
                                sResponse);
                        }

                        // if we get to here, then we were able to connect, the component was found
                        // and the component has help, that means "OK".
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Xmgmt to " + sComponent + " on " + ipAddr.ToString() + " OK");
                    }
                }
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: Exception sending to xmgmtsrv on " + ipAddr.ToString()  + ". Exception details:");
                m_log.Console(
                    e.Message);
            }
            finally
            {
                xomAdminSession.Close();
            }

            return;
        }

        private void CheckHealth()
        {
            // the amount of time we'll wait for a front door to respond to the
            // health check. Use the default compiled into this file if one
            // is not specified in the respository.
            int iTimeout = c_iFDTimeoutDefault;
            m_repository.ServiceFrontDoorTimeoutGet(ref iTimeout);

            // get the urls we want to hit
            SortedList slHealthUrls = m_repository.ServiceHealthUrlGetList();

            if (slHealthUrls.Count == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Warning: No health urls provided in service.xml");
                return;
            }

            foreach (DictionaryEntry de in slHealthUrls)
            {
                // the key of the sorted list is a string containing the friendly name of the server
                // the value of the sorted list a string containing the health url to hit
                string sFriendlyName = (string)de.Key;
                string sUrl = (string)de.Value;

                AttemptHealthCheck(sFriendlyName, sUrl, iTimeout);
            }
        }

        private void AttemptHealthCheck(
            string sFriendlyName,
            string sHealthUrl,
            int iTimeout)
        {
            string [] sUrlParts = sHealthUrl.Split(';');

            if(sUrlParts.Length != 2)
                throw new ArgumentException("Health URL must be in the form <method>;<url>");

            string sMethod = sUrlParts[0];
            string sUrl = sUrlParts[1];

            //   0        1        2        3        4        5        6        7        8
            m_log.FullTrace(
                "Sending " + sUrl + " using HTTP " + sMethod);

            if(sMethod.ToUpper() != "GET" && sMethod.ToUpper() != "POST")
                throw new ArgumentException("Invalid HTTP method: " + sMethod);

            HttpWebRequest httpWebRequest = 
                (HttpWebRequest)WebRequest.Create(sUrl);

            // Turn off connection keep-alives.
            httpWebRequest.KeepAlive = false;

            // set the requested timeout
            httpWebRequest.Timeout = iTimeout;

            // set method, and Content-Length
            httpWebRequest.Method = sMethod;
            if(sMethod == "POST")
                httpWebRequest.ContentLength = 0;
            
            HttpWebResponse httpWebResponse = null;
            try
            {
                httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
                string sResponse;
                try
                {
                    Stream stream = httpWebResponse.GetResponseStream();
                    StreamReader streamReader = new StreamReader(stream);
                    sResponse = streamReader.ReadToEnd();
                }
                catch (ProtocolViolationException)
                {
                    // no content to be had
                    sResponse = String.Empty;
                }

                if (httpWebResponse.StatusCode == HttpStatusCode.OK)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        sFriendlyName + " (" + sMethod + " " + sUrl + ") reports OK");
                }
                else
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        "Error: " 
                        + sFriendlyName 
                        + " (" 
                        + sMethod + " " + sUrl 
                        + ") reports " 
                        + httpWebResponse.StatusCode.ToString());
                }
                m_log.FullTrace(
                    "Response body:");
                m_log.FullTrace(
                    sResponse);
                return;
            }
            catch (WebException webException)
            {
                if (webException.Status == WebExceptionStatus.Timeout)
                {
                    //   0        1        2        3        4        5        6        7        8
                    m_log.Console(
                        "Error: " + sFriendlyName + " (" + sMethod + " " + sUrl + ") timed out");
                    return;
                }
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Error: " 
                    + sFriendlyName 
                    + " (" 
                    + sMethod + " " + sUrl 
                    + ") threw exception.");
                m_log.Console(webException.Message);
                return;
            }
            finally
            {
                if (httpWebResponse != null)
                {
                    httpWebResponse.Close();
                }
            }
        }

        private void CheckSite(uint uiSiteId)
        {
            string[] rgsUNCPaths = m_repository.ServiceDownloadUNCPathGetList(uiSiteId);
            if (rgsUNCPaths.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Note: No Download server UNC paths specified for site " + uiSiteId.ToString());
            }
            else
            {
                foreach (string sUNCPath in rgsUNCPaths)
                {
                    if (Directory.Exists(sUNCPath))
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Site " + uiSiteId.ToString() + " Download server UNC path " + sUNCPath + " OK");
                    }
                    else
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Error: Site " + uiSiteId.ToString() + " Download server UNC path " + sUNCPath + " not reachable");
                    }
                }
            }

            rgsUNCPaths = m_repository.ServiceSecurityGatewayUNCPathGetList(uiSiteId);
            if (rgsUNCPaths.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                m_log.Console(
                    "Note: No Security Gateway UNC paths specified for site " + uiSiteId.ToString());
            }
            else
            {
                foreach (string sUNCPath in rgsUNCPaths)
                {
                    if (Directory.Exists(sUNCPath))
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Site " + uiSiteId.ToString() + " Security Gateway UNC path " + sUNCPath + " OK");
                    }
                    else
                    {
                        //   0        1        2        3        4        5        6        7        8
                        m_log.Console(
                            "Error: Site " + uiSiteId.ToString() + " Security Gateway UNC path " + sUNCPath + " not reachable");
                    }
                }
            }
        }

        public void LSPSitesSet(
            CTitleId tid,
            CSite[] sites )
        {
            //
            //  Parameter checks
            //

            if(tid == null)
                throw new ArgumentNullException("tid");
            if(sites == null)
                throw new ArgumentNullException("sites");

            //
            //  Add this new site to the repositiory.
            //    If it already exists then update the data.
            //
            m_repository.TitleLSPSiteDeleteAll( tid );

            foreach( CSite siteEntry in sites )
            {
                // set the site.
                m_repository.TitleLSPSiteSet( tid, siteEntry );
            }

            // submit.
            m_repository.TitleSubmit(tid, "Xbox.Tools.Framework.CTitleMgr.LSPSitesSet: updating");
        }

        public void LSPServicesSet(
            CTitleId tid,
            CService[] services )
        {
            //
            //  Parameter checks
            //
            if(tid == null)
                throw new ArgumentNullException("tid");
            if(services == null)
                throw new ArgumentNullException("services");
             
            //
            //  Add this new service to the repositiory.
            //    If it already exists, delete and add the data.
            //
            m_repository.TitleLSPServiceDeleteAll( tid );

            foreach( CService serviceEntry in services )
            {
                // set the service.
                m_repository.TitleLSPServiceSet( tid, serviceEntry );
                continue;
            }

            m_repository.TitleSubmit(tid, "Xbox.Tools.Framework.CTitleMgr.LSPServiceSet: updating");
        }

        public void LSPArchiveSSC(
            CTitleId tid,
            string filename )
        {
            //
            //  Parameter checks
            //
            if(tid == null)
                throw new ArgumentNullException("tid");
            if(filename == null || filename == string.Empty )
                throw new ArgumentNullException("filename");
             

            // since the submission was successful, archive the submitted file
            m_repository.TitleArchiveFile(
                tid, 
                filename, 
                "archiving submitted ssc file");

        }

        public void AlternateTitleIdSet(
            CTitleId tid,
            CTitleId [] rgAlternateTids)
        {
            //
            //  Parameter checks
            //

            if(tid == null)
                throw new ArgumentNullException("tid");
            if(rgAlternateTids == null)
                throw new ArgumentNullException("rgAlternateTids");
            if(rgAlternateTids.Length > 4)
                throw new ArgumentException("Cannot specify more than four alternate title ids.", "rgAlternateTids");

            //
            //  Now we just blow away the existing alternate title ids and apply the new.
            //
             
            m_repository.TitleAlternateTitleIdDeleteAll(tid);

            foreach(CTitleId tidAlt in rgAlternateTids)
            {
                if(tidAlt.uiTitleId == 0)
                    continue;

                m_repository.TitleAlternateTitleIdSet(tid, tidAlt);
            }

            m_repository.TitleSubmit(tid, "Xbox.Tools.Framework.CTitleMgr.AlternateTitleIdSet: updating");
        }

        public void AlternateTitleIdSync(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.AlternateTitleIdSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bReportOnly + ")");

            // get the list of alternate title ids from the repository
            uint [] aAlternateTitleIds = null;
            if (!m_repository.TitleAlternateTitleIdGetList(tid, ref aAlternateTitleIds))
            {
                aAlternateTitleIds = new uint[0];
            }

            // If TitleAlternateTitleIdGetList returned true, and null for
            // aAlternateTitleIds then throw and exception, this is a bug
            // and should never happen!!!
            if(aAlternateTitleIds == null)
                throw new CTitleMgrException("CRepository::TitleAlternateTitleIdGetList returned null list on success!");

            // if we got back too many alternate title ids throw and exception
            // this is a bug and should never happen!!!
            if(aAlternateTitleIds.Length > 4)
                throw new CTitleMgrException("Too many alternate title ids returned from repository!");

            // convert to array of exactly 4 elements
            if(aAlternateTitleIds.Length < 4)
            {
                uint [] aAlternateTitleIdsNew = new uint[4] { 0, 0, 0, 0 };

                aAlternateTitleIds.CopyTo(aAlternateTitleIdsNew, 0);
                aAlternateTitleIds = aAlternateTitleIdsNew;
            }

            //   0        1        2        3        4        5        6        7        8
            CAlternateTitleIds.SetAlternateTitleIds(tid, aAlternateTitleIds, m_log, bReportOnly);

            //   0        1        2        3        4        5        6        7        8
            m_log.Console("Success: Alternate title ids sync complete.");

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.AlternateTitleIdSync complete.");
            return;
        }

        public void LspSiteSync(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.LspSiteSync(" 
                + tid.sTitleIdHexNoPrefix + ","
                + bReportOnly + ")");

            // get the filename of the public master key file.
            string masterKeyFile = m_repository.PublicMasterKeyFileGet();

            // create the site manager.
            CSiteMgr siteMgr = new CSiteMgr( c_sUODBDBName, c_iDefaultUODBTimeout, masterKeyFile, m_log );

            // create the service manager.
            CServiceMgr serviceMgr = new CServiceMgr( c_sUODBDBName, c_iDefaultUODBTimeout, m_log );

            CSiteSync.SiteSync( tid, m_repository, siteMgr, bReportOnly, m_log );

            CServiceSync.ServiceSync( tid, m_repository, serviceMgr, bReportOnly, m_log );

            m_log.StackTrace(
                "Xbox.Tools.Framework.CTitleMgr.LspSiteSync complete.");
            return;
        }
    }

    public class CTitleMgrException : ApplicationException
    {
        public CTitleMgrException() : base() {}
        public CTitleMgrException(string s) : base(s) {}
        protected CTitleMgrException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CTitleMgrException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CXqsParse.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using xonline.common.service;
using System.Text;
using xonline.common.plugins;
using xonline.common.config;
using System.Reflection;

namespace xonline.tools.framework
{
    /// <summary>
    ///
    /// </summary>
    public class CXqsParse
    {
        public class Column
        {
            public string name;
            public int id;
            public string type;
            public string sqltype;
            public bool isNullable;
            public string idx = "";
            public int maxlen;
            public string defaultVal;
            public bool hidden;
        }

        public class Index
        {
            public string name;
            public bool isClustered = false;
            public bool isUnique = false;
            public ArrayList cols = new ArrayList();
        }


        public struct Param
        {
            public int id;
            public string type;
            public string sqltype;
            public string name;
            public string defaultVal;
        }

        public struct Update
        {
            public int id;
            public int param;
        }

        public struct Filter
        {
            public int lval;
            public string op;
            public int rval;
        }

        public struct Sort
        {
            public string dir;
            public int id;
        }

        public struct Return
        {
            public string name;
            public int id;
        }

        public class Query
        {
            public int id;
            public string op;
            public string name;
            public string custom;

            public ArrayList parameters = new ArrayList();
            public Hashtable parammap = new Hashtable();
            public ArrayList filters = new ArrayList();
            public ArrayList sorts = new ArrayList();
            public ArrayList returns = new ArrayList();
            public ArrayList updates = new ArrayList();
        }


        public class Plugin
        {
            public int order;
            public string assembly;
            public string clazz;

            public Hashtable context = new Hashtable();
        }


        public class Dataset
        {
            public string name;
            public int id;
            public int quota;
            public uint titleId;
            public string version;

            public ArrayList columns = new ArrayList();
            public Hashtable colmap = new Hashtable();
            public Hashtable indexes = new Hashtable();
            public Hashtable constants = new Hashtable();
            public ArrayList queries = new ArrayList();
            public ArrayList plugins = new ArrayList();
        }


        //
        // sXqsData:
        //      the text loaded from the XQS file
        // titleId
        //      the id of the current title.  if the XQS file specifies a title,
        //      the parameter is non-zero, and these ids don't match, an error is thrown.
        //      If the xqs doesn't specify a title, this id is used.
        // dropTables
        //      true if commands to drop tables should be generated
        //      false if the tables shoudl be left as-is (good for production)
        // npartition
        //      the specific partition to use for this xqs.
        // rgsQueryDBSqlCommands
        //      list of commands that should be run against querydb
        // rgsNPDBSqlCommands
        //      list of commands to run against npdb
        //
        public static uint XqsParse(string sXqsData, uint titleId, bool dropTables, uint partitionId, out string [] rgsQueryDBSqlCommands, out string [] rgsNPDBSqlCommands)
        {
            ulong ver = 0;
            return XqsParse(sXqsData, titleId, dropTables, partitionId, out rgsQueryDBSqlCommands, out  rgsNPDBSqlCommands, out ver);
        }

        public static uint XqsParse(string sXqsData, uint titleId, bool dropTables, uint partitionId, out string [] rgsQueryDBSqlCommands, out string [] rgsNPDBSqlCommands, out ulong ulver)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(sXqsData);
            XPathNavigator root = doc.CreateNavigator();


            StringCollection qdbCmds = new StringCollection();
            StringCollection npdbCmds = new StringCollection();


            XPathNodeIterator qsIterator = root.Select("/querysim");
            if (qsIterator.Count == 0)
            {
                throw new Exception("No querysim node!!");
            }

            qsIterator.MoveNext();

            string version = qsIterator.Current.GetAttribute("ver", "");
            if (version == "")
                version = "0.0";

            ulver = 0;
            string hexver = qsIterator.Current.GetAttribute("hexver", "").Trim();
            if (hexver != "")
            {
                if (hexver.Substring(0, 2) == "0x")
                {
                    hexver = hexver.Substring(2);
                }

                try
                {
                    ulver = Convert.ToUInt64(hexver);
                }
                catch(Exception e)
                {
                    throw new Exception("Unable to parse /querysim/@hexver attribute!", e);
                }

            }


            XPathNodeIterator titleIterator = root.Select("/querysim/title");

            if (titleIterator.Count == 0)
            {
                throw new Exception("No querysim/title nodes found in sXqsData!");
            }


            // loop through all title nodes, make sure they're the same and/or match what's
            // passed in
            while (titleIterator.MoveNext())
            {
                uint xqsTitleId = (uint)SafeConvert.ToInt32(titleIterator.Current.GetAttribute("id", ""));
                if (xqsTitleId == 0)
                {
                    xqsTitleId = titleId;
                }
                else if (titleId != 0 && titleId != xqsTitleId)
                {
                    throw new Exception("Title id does not match one or more of the titleids in the xqs file!! xqs title id: "
                                    + xqsTitleId.ToString("x") + "  specified titleId: " + titleId.ToString("x"));
                }

                titleId = xqsTitleId;
            }



            if (titleId == 0)
            {
                throw new Exception("No titleId specified!");
            }


            //
            // fix post-ship bugs. XLAST generated XQS files in 1.0 contain some unfortunate bugs that require
            //  the XQS file to be modified before it is processed. We do this server side to minimize the impace
            //  to the title developer
            //
            if (version == "1.0")
            {
                Updatev1XQS(doc, root);
            }


            //
            // add global entites table for this title
            //
            qdbCmds.Add(buildTitleEntitiesTable(titleId));

            //
            // parse datasets for this title
            //
            XPathNodeIterator dsIterator = root.Select("/querysim/title/dataset");

            if (dsIterator.Count == 0)
            {
                throw new Exception("No datasets specified for title id 0x" + titleId.ToString("x8"));
            }

            Hashtable datasets = new Hashtable();
            while (dsIterator.MoveNext())
            {
                int id = SafeConvert.ToInt32(dsIterator.Current.GetAttribute("id", ""));
                if (datasets.Contains(id))
                {
                    // already parsed, skip it
                    continue;
                }

                Dataset ds = parseDataset(root, id);
                ds.titleId = titleId;
                ds.version = version;

                datasets.Add(id, ds);
            }


            // turn each of the discovered datasets into sql
            //
            foreach (object o in datasets.Values)
            {
                Dataset ds = (Dataset)o;

                qdbCmds.AddRange(buildQueryDbCmds(ds, dropTables));
                npdbCmds.AddRange(buildNpdbCmds(ds, partitionId, dropTables));
            }


            rgsQueryDBSqlCommands = new string[qdbCmds.Count];
            qdbCmds.CopyTo(rgsQueryDBSqlCommands, 0);

            rgsNPDBSqlCommands = new string[npdbCmds.Count];
            npdbCmds.CopyTo(rgsNPDBSqlCommands, 0);

            return titleId;
        }


        public static bool Updatev1XQS(XmlDocument doc, XPathNavigator root)
        {
            bool            fUpdated = false;
            XPathNodeIterator nav = null;
            XmlNodeList     nodes = null;


            //
            // Is this a competitions XQS?
            //

            //
            // parse datasets for this title
            //
            nav = root.Select("/querysim/title/dataset");

            if (nav.Count < 3)   // Not a competitions XQS
            {
                goto lbExit;
            }


            // Fix bug 36423:
            // Find the exact returns element of the Select Round query and update the attribute value
            nodes = doc.SelectNodes("/querysim/title/dataset/queries/query[@hexid='0x10002'][@op='search'][@name='Select Round']/returns/return[@name='start']");

            foreach (XmlNode node in nodes)
            {
                XmlAttributeCollection attrs = node.Attributes;
                XmlAttribute attr = (XmlAttribute)attrs.GetNamedItem("hexid");

                if (attr.Value == "0x80030003")
                {
                    attr.Value = "0x80030007";
                    fUpdated = true;
                }
            }

            // Fix bug 37067:
            // Find the dataset whose first three attribute values in the schema are att_comp_id, att_comp_status, att_puid
            //  in that order, and whose attribute elements do not have any index attributes already defined.
            nodes = doc.SelectNodes("/querysim/title/dataset[contains(@name,'entrants')]"
                                    + "[schema"
                                    + "[attribute[1]/@name='att_comp_id'][attribute[1]/@hexid='0x80010000'][not(attribute[1]/@index)]"
                                    + "[attribute[2]/@name='att_comp_status'][attribute[2]/@hexid='0x8001001D'][not(attribute[1]/@index)]"
                                    + "[attribute[3]/@name='att_puid'][attribute[3]/@hexid='0x80020000'][not(attribute[1]/@index)]"
                                    + "]"
                                    + "[not(indexes)]"
                                    );

            foreach (XmlNode node in nodes)   //  node = dataset node
            {
                XmlNode schema = node.SelectSingleNode("./schema");
                XmlNodeList childNodes = null;
                XmlAttribute attr = null;

                // Get the ordered list of child attributes;
                childNodes = schema.SelectNodes("./attribute");

                // Swap positions of attributes 2 and 3 to make the indexes form in the correct order
                schema.InsertBefore(childNodes[2], childNodes[1]);

                // Get the ordered list of child attributes again, since we just modified the order;
                childNodes = schema.SelectNodes("./attribute");

                // Add index attributes to the first 3 nodes.
                attr = doc.CreateAttribute("index");  // index="unique_entrants"
                attr.Value = "unique_entrants";
                childNodes[0].Attributes.Append(attr);

                attr = doc.CreateAttribute("index");  // index="unique_entrants,my_comps"
                attr.Value = "unique_entrants,my_comps";
                childNodes[1].Attributes.Append(attr);

                attr = doc.CreateAttribute("index");  // index="my_comps"
                attr.Value = "my_comps";
                childNodes[2].Attributes.Append(attr);

                // Create Indexes element and children
                XmlElement indexes = doc.CreateElement("indexes");
                XmlElement index = null;

                index = doc.CreateElement("index");
                indexes.AppendChild(index);

                attr = doc.CreateAttribute("name");
                attr.Value = "unique_entrants";
                index.Attributes.Append(attr);

                attr = doc.CreateAttribute("unique");
                attr.Value = "true";
                index.Attributes.Append(attr);

                index = doc.CreateElement("index");
                indexes.AppendChild(index);

                attr = doc.CreateAttribute("name");
                attr.Value = "my_comps";
                index.Attributes.Append(attr);

                node.InsertAfter(indexes, schema);
                fUpdated = true;
            }

lbExit:
            return fUpdated;
        }


        public static string GetXPathDataset(int id, string subquery)
        {
            if (subquery != "" && subquery != null && !subquery.StartsWith("/"))
            {
                subquery = "/" + subquery;
            }

            return  "/querysim/title/dataset[@id='0x" + id.ToString("x") + "']" + subquery + "|" +
                    "/querysim/title/dataset[@id='0x" + id.ToString("X") + "']" + subquery + "|" +
                    "/querysim/title/dataset[@id='" + id + "']" + subquery;
        }

        public static Dataset parseDataset(XPathNavigator root, int id)
        {

            Dataset ds = new Dataset();

            if (id == 0)
            {
                throw new Exception("Missing or invalid dataset id!");
            }

            ds.id = id;
            XPathNodeIterator nav = root.Select(GetXPathDataset(id, ""));
            if (nav.Count == 0)
            {
                throw new Exception("No datasets found with id " + id);
            }

            while (nav.MoveNext())
            {
                if (ds.name == null)
                {
                    ds.name = GetStringAttribute(nav.Current, "name");
                    ds.quota = SafeConvert.ToInt32(nav.Current.GetAttribute("quota", ""), -1);
                }
                else
                {
                    if (ds.name != GetStringAttribute(nav.Current, "name"))
                    {
                        throw new Exception("Mismatched name between datasets with id " + id);
                    }
                    if (ds.quota != SafeConvert.ToInt32(nav.Current.GetAttribute("quota", ""), -1))
                    {
                        throw new Exception("Mismatched quota between datasets with id " + id);
                    }
                }
            }




            parseSchema(root, ds);
            parseIndexes(root, ds);
            parseConstants(root, ds);
            parseQueries(root, ds);
            parsePlugins(root, ds);


            return ds;
        }

        private static string GetStringAttribute(XPathNavigator node, string name)
        {
            string val = node.GetAttribute(name, "");
            val = (val == null ? "" : val = val.Replace("'", "''"));
            return val;
        }


        private static void parseSchema(XPathNavigator nav, Dataset ds)
        {

            XPathNodeIterator schemaIterator = nav.Select(GetXPathDataset(ds.id, "/schema/attribute"));

            if (schemaIterator.Count == 0)
            {
                throw new Exception("No attributes specified in the schema! Dataset: " + ds.id);
            }

            Column col;
            int pos;

            // build the default columns first
            col = new Column();
            col.name = "bi_entity_id";
            col.id = unchecked((int)0x80000000);
            col.type = "int";
            col.sqltype = "bigint";
            col.defaultVal = null;
            col.hidden = true;

            pos = ds.columns.Add(col);
            ds.colmap.Add(col.id, pos);


            col = new Column();
            col.name = "bi_owner_id";
            col.id = unchecked((int)0x80000001);
            col.type = "int";
            col.sqltype = "bigint";
            col.defaultVal = null;
            col.hidden = true;

            pos = ds.columns.Add(col);
            ds.colmap.Add(col.id, pos);


            col = new Column();
            col.name = "dt_change_datetime";
            col.id = unchecked((int)0x80000002);
            col.type = "int";
            col.sqltype = "bigint";
            col.defaultVal = null;
            col.hidden = true;

            pos = ds.columns.Add(col);
            ds.colmap.Add(col.id, pos);


            while (schemaIterator.MoveNext())
            {
                col = new Column();

                col.id = SafeConvert.ToInt32(schemaIterator.Current.GetAttribute("hexid", ""), -1);
                if (col.id == -1)
                {
                    throw new Exception("Missing invalid attribute hexid! Dataset: " + ds.id);
                }

                col.name = GetStringAttribute(schemaIterator.Current, "name");
                col.isNullable = SafeConvert.ToBoolean(schemaIterator.Current.GetAttribute("nullok", ""));
                col.maxlen = SafeConvert.ToInt32(schemaIterator.Current.GetAttribute("maxlen", ""));
                col.defaultVal = null;
                col.hidden = (schemaIterator.Current.GetAttribute("hidden", "").ToLower() == "true") || (schemaIterator.Current.GetAttribute("hidden", "").ToLower() == "1");
                if (schemaIterator.Current.MoveToAttribute("default", ""))
                {
                    schemaIterator.Current.MoveToParent();
                    col.defaultVal = GetStringAttribute(schemaIterator.Current, "default");
                }
                col.type = GetStringAttribute(schemaIterator.Current, "kind").ToLower();

                string indexname = GetStringAttribute(schemaIterator.Current, "index").ToLower();
                if (indexname != "")
                {
                    string [] split = null;

                    split = indexname.Split(",".ToCharArray());

                    foreach (string s in split)
                    {
                        Index indx = (Index)ds.indexes[s];
                        if (indx == null)
                        {
                            indx = new Index();
                            indx.name = s;
                        }

                        indx.cols.Add(col.id);
                        ds.indexes[s] = indx;
                    }

                    col.idx = indexname;
                }


                if (col.maxlen == 0)
                    col.maxlen = 30;

                switch(col.type)
                {
                case "string":
                    col.sqltype = "nvarchar(" + col.maxlen + ")";
                    if (col.defaultVal != null)
                    {
                        col.defaultVal = "'" + col.defaultVal + "'";
                    }
                    break;

                case "int":
                    col.sqltype = "bigint";
                    break;

                case "blob":
                    col.sqltype = "varbinary(" + col.maxlen + ")";
                    break;

                default:
                    throw new Exception("Unknown attribute type specified!  Dataset: " + ds.id);

                }

                pos = ds.columns.Add(col);
                ds.colmap.Add(col.id, pos);
            }
        }

        private static void parseIndexes(XPathNavigator nav, Dataset ds)
        {
            XPathNodeIterator iterator = nav.Select(GetXPathDataset(ds.id, "/indexes/index"));

            while (iterator.MoveNext())
            {
                string indexname = GetStringAttribute(iterator.Current, "name").ToLower();

                Index idx = (Index)ds.indexes[indexname];
                if (idx == null)
                {
                    throw new Exception("Index found with name " + indexname + " that does not have a reference in any schema attributes!  dataset: " + ds.id);
                }

                idx.isClustered = SafeConvert.ToBoolean(iterator.Current.GetAttribute("clustered", ""));
                idx.isUnique    = SafeConvert.ToBoolean(iterator.Current.GetAttribute("unique", ""));
            }

        }

        private static void parseConstants(XPathNavigator nav, Dataset ds)
        {
            XPathNodeIterator iterator = nav.Select(GetXPathDataset(ds.id, "/constants/constant"));

            while (iterator.MoveNext())
            {
                int constId = SafeConvert.ToInt32(iterator.Current.GetAttribute("hexid", ""));
                string type = GetStringAttribute(iterator.Current, "kind");


                // convert type to sql-usable type
                try
                {
                    switch (type.ToLower())
                    {
                    case "string":
                        ds.constants.Add(constId, "'" + GetStringAttribute(iterator.Current, "value") + "'");
                        break;

                    case "blob":
                        ds.constants.Add(constId, GetStringAttribute(iterator.Current, "value"));
                        break;

                    case "int":
                        ds.constants.Add(constId, SafeConvert.ToUInt64(iterator.Current.GetAttribute("value", "")));
                        break;

                    default:
                        throw new Exception("Unknown type specified for constant id=" + constId + " in dataset " + ds.id);
                    }
                }
                catch (Exception e2)
                {
                    throw new Exception("Failed to parse value for constant id=" + constId, e2);
                }
            }
        }

        private static void parseQueries(XPathNavigator nav, Dataset ds)
        {
            XPathNodeIterator queryIterator = nav.Select(GetXPathDataset(ds.id, "/queries/query"));
            int i;
            Hashtable queryIds = new Hashtable();


            while (queryIterator.MoveNext())
            {
                Query q = new Query();

                q.id = SafeConvert.ToInt32(queryIterator.Current.GetAttribute("hexid", ""), -1);
                if (q.id == -1)
                {
                    throw new Exception("Missing or invalid query hexid! Dataset: " + ds.id);
                }

                q.name = queryIterator.Current.GetAttribute("name", "");
                q.op = queryIterator.Current.GetAttribute("op", "");
                if (q.op != "search" &&
                    q.op != "update" &&
                    q.op != "updateid" &&
                    q.op != "remove" &&
                    q.op != "removeid" &&
                    q.op != "findids" &&
                    q.op != "custom")
                {
                    throw new Exception("Invalid query op '" + q.op + "'  dataset:" + ds.id);
                }

                if (queryIds.Contains(q.op + "_" + q.id.ToString("x")))
                {
                    throw new Exception("Multiple queries found with the id of " + q.id.ToString("x") + " and the operation " + q.op + "!!");
                }

                queryIds.Add(q.op + "_" + q.id.ToString("x"), "");




                // parameters
                //
                XPathNodeIterator paramIterator = queryIterator.Current.Select("params/param");
                while (paramIterator.MoveNext())
                {
                    Param p = new Param();
                    p.id = SafeConvert.ToInt32(paramIterator.Current.GetAttribute("hexid", ""));
                    p.name = paramIterator.Current.GetAttribute("name", "");
                    p.type = paramIterator.Current.GetAttribute("kind", "");

                    if ((p.id & XOn.X_ATTRIBUTE_DATAFLAG_PARAM) != XOn.X_ATTRIBUTE_DATAFLAG_PARAM)
                    {
                        throw new Exception("Parameter " + p.id.ToString("x8") + " doesn't specifiy param bit (" + XOn.X_ATTRIBUTE_DATAFLAG_PARAM.ToString("x8") + ")!  op '" + q.op + "'  dataset:" + ds.id);
                    }

                    int maxlen = 0;
                    if (ds.colmap.ContainsKey(p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK))
                    {
                        maxlen = GetColumn(ds, p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK).maxlen;
                    }

                    // note: 1 is added to maxlen to force 'attribute too long' error instead of silent truncation by sql.
                    switch(p.type)
                    {
                    case "string":
                        if (maxlen == 0)
                            maxlen = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;

                        p.sqltype = "nvarchar(" + (maxlen+1) + ")";
                        break;

                    case "int":
                        p.sqltype = "bigint";
                        break;

                    case "blob":
                        if (maxlen == 0)
                            maxlen = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;

                        p.sqltype = "varbinary(" + (maxlen+1) + ")";
                        break;

                    default:
                        throw new Exception("Unknown parameter type specified!  Dataset: " + ds.id.ToString("x") + " query: " + q.id.ToString("x") + " op: " + q.op);

                    }

                    p.defaultVal = null;
                    if (paramIterator.Current.MoveToAttribute("default", ""))
                    {
                        paramIterator.Current.MoveToParent();
                        p.defaultVal = paramIterator.Current.GetAttribute("default", "");
                    }

                    if (p.defaultVal == null)
                    {
                        if (ds.colmap.ContainsKey((p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK)))
                        {
                            // use the default from the column
                            p.defaultVal = GetColumn(ds, (p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK)).defaultVal;
                        }
                    }
                    else if (p.type == "string")
                    {
                        p.defaultVal = "'" + p.defaultVal + "'";
                    }

                    if (p.name == "" && ds.colmap.ContainsKey((p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK)))
                    {
                        p.name = GetColumn(ds, p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK).name;
                    }


                    i = q.parameters.Add(p);
                    q.parammap.Add(p.id, i);

                }


                // filters
                //
                XPathNodeIterator filterIterator = queryIterator.Current.Select("filters/filter");
                while (filterIterator.MoveNext())
                {
                    Filter f = new Filter();
                    f.lval = SafeConvert.ToInt32(filterIterator.Current.GetAttribute("left", ""));
                    f.rval = SafeConvert.ToInt32(filterIterator.Current.GetAttribute("right", ""));
                    f.op = filterIterator.Current.GetAttribute("op", "");

                    if (!ds.colmap.ContainsKey(f.lval) && !ds.constants.ContainsKey(f.lval) && !q.parammap.ContainsKey(f.lval))
                    {
                        throw new Exception("The left filter value " + f.lval.ToString("x8") + " doesn't exist in the schema, parameters or contants lists!" +
                                            "  Dataset: " + ds.id + " query: " + q.id + " op: " + q.op);
                    }

                    if (!ds.colmap.ContainsKey(f.rval) && !ds.constants.ContainsKey(f.rval) && !q.parammap.ContainsKey(f.rval))
                    {
                        throw new Exception("The right filter value " + f.rval.ToString("x8") + " doesn't exist in the schema, parameters or contants lists!" +
                                            "  Dataset: " + ds.id + " query: " + q.id + " op: " + q.op);
                    }

                    if (f.op != "==" &&
                        f.op != "<"  &&
                        f.op != ">"  &&
                        f.op != "<=" &&
                        f.op != ">=" &&
                        f.op != "<>")
                    {
                        throw new Exception("Unrecgonized filter op '" + f.op + "'! Dataset: " + ds.id.ToString("x") + " query: " + q.id.ToString("x") + " op: " + q.op);
                    }

                    if (f.op == "==")
                        f.op = "=";

                    q.filters.Add(f);
                }

                // updates
                //
                XPathNodeIterator updateIterator = queryIterator.Current.Select("updates/update");

                if (updateIterator.Count > 0 && q.op != "update" && q.op != "updateid")
                {
                    throw new Exception("Unexpected update node found within non-update query!  Dataset: " + ds.id.ToString("x"));
                }

                while (updateIterator.MoveNext())
                {
                    Update u = new Update();
                    u.id = SafeConvert.ToInt32(updateIterator.Current.GetAttribute("hexid", ""));
                    u.param = SafeConvert.ToInt32(updateIterator.Current.GetAttribute("param", ""));

                    if (!ds.colmap.ContainsKey(u.id))
                    {
                        throw new Exception("Column '" + updateIterator.Current.GetAttribute("hexid", "") +
                                            "' doesn't exist in dataset schema!  Dataset: " + ds.id.ToString("x") +
                                            " query: " + q.id.ToString("x") + " op: " + q.op);
                    }

                    if (!q.parammap.ContainsKey(u.param))
                    {
                        throw new Exception("Parameter '" + updateIterator.Current.GetAttribute("param", "") +
                                            "' doesn't exist in query param list! Dataset: " + ds.id.ToString("x") +
                                            " query: " + q.id.ToString("x") + " op: " + q.op);
                    }

                    q.updates.Add(u);
                }


                // sortops
                //
                XPathNodeIterator sortIterator = queryIterator.Current.Select("sortops/sortop");
                while (sortIterator.MoveNext())
                {
                    Sort s = new Sort();
                    s.id = SafeConvert.ToInt32(sortIterator.Current.GetAttribute("hexid", ""));
                    s.dir = sortIterator.Current.GetAttribute("dir", "");

                    if (!ds.colmap.ContainsKey(s.id))
                    {
                        throw new Exception("sortop specifies column 0x" + s.id.ToString("X8") + " not found in the dataset schema!  Dataset: " + ds.id + " query: " + q.id + " op: " + q.op);
                    }

                    switch (s.dir)
                    {
                    case "ascending":
                        s.dir = "asc";
                        break;

                    case "descending":
                        s.dir = "desc";
                        break;


                    default:
                        throw new Exception("sortop for hexid 0x" + s.id.ToString("X8") + " specifies an unrecgonized value '" + s.dir + "'.  Dataset: " + ds.id + " query: " + q.id + " op: " + q.op);
                    }

                    q.sorts.Add(s);
                }


                // returns
                //
                XPathNodeIterator retIterator = queryIterator.Current.Select("returns/return");
                while (retIterator.MoveNext())
                {
                    Return r = new Return();

                    r.id = SafeConvert.ToInt32(retIterator.Current.GetAttribute("hexid", ""));
                    r.name = retIterator.Current.GetAttribute("name", "");

                    // Internally, we don't care about the mapping so we mask it off.
                    r.id &=~ XOn.X_ATTRIBUTE_DATAFLAG_MAPPED;

                    if (!ds.colmap.ContainsKey(r.id))
                    {
                        throw new Exception("return node specifies column 0x" + r.id.ToString("X8") + " not found in the dataset schema!  Dataset: " + ds.id + " query: " + q.id + " op: " + q.op);
                    }

                    q.returns.Add(r);
                }

                if (q.op =="search" && q.returns.Count == 0)
                {
                    throw new Exception("Search queries cannot have 0 return attributes!  Dataset: " + ds.id.ToString("x8") + " query: " + q.id + " op: " + q.op);
                }

                // custom
                //
                XPathNodeIterator custIterator = queryIterator.Current.Select("custom");
                if (q.op == "custom" && custIterator.Count == 0)
                {
                    throw new Exception("No custom code for custom query!  Dataset: " + ds.id.ToString("x8") + " query: " + q.id + " op: " + q.op);
                }
                if (q.op != "custom" && custIterator.Count != 0)
                {
                    throw new Exception("Custom code found for non-custom query!   Dataset: " + ds.id.ToString("x8") + " query: " + q.id + " op: " + q.op);
                }
                if (custIterator.Count > 1)
                {
                    throw new Exception("More than one custom node found for custom query!  Only one is allowed.  Dataset: " + ds.id.ToString("x8") + " query: " + q.id + " op: " + q.op);
                }

                custIterator.MoveNext();
                q.custom = custIterator.Current.Value;
                ds.queries.Add(q);
            }
        }


        // bug 36274: since we allow custom procs, we need to make sure the text by these procs
        // is something generated directly by XLAST, unmodifed.
        //
        public static void validateCustom(string custom, Dataset ds)
        {
            string titleDataset = ds.titleId.ToString("x8") + "_" + ds.id.ToString("x");

            custom = custom.ToLower();

            if (custom !=
"update t_query_dataset_" + titleDataset + "\r\n" +
"set att_80010018 = att_80010018 + @att_82010018,\r\n" +
"att_80010019 = att_80010019 + @att_82010019\r\n" +
"where bi_entity_id = @bi_entity_id\r\n" +
"    and (att_80010018 + @att_82010018) <= att_80010012     -- xonline_comp_attr_public_entrants <= xonline_comp_attr_max_public_slots\r\n" +
"    and (att_80010019 + @att_82010019) <= att_80010013     -- xonline_comp_attr_private_entrants <= xonline_comp_attr_max_private_slots\r\n" +
"    and att_80010002 >= @att_82010002                      -- xonline_comp_attr_reg_close >= current time\r\n" +
"    and (att_80010001-1799062968) <= @att_82010002         -- xonline_comp_attr_reg_open - (3 minutes) <= current time\r\n" +
"    and att_8001001d =  0                                  -- xonline_comp_attr_status == xonline_comp_status_pre_init\r\n" +
"    and att_80010010 = @att_82010010                       -- xonline_comp_attr_is_team_comp == @xonline_comp_attr_is_team_comp\r\n" +
"if (@@rowcount <> 1)\r\n" +
"begin\r\n" +
"  -- update failed, figure out why\r\n" +
"  --\r\n" +
"  if not exists (select * from t_query_dataset_" + titleDataset + " where @bi_entity_id = @bi_entity_id)\r\n" +
"      return 0x80156102                               -- xonline_e_query_entity_not_found\r\n" +
"  if not exists (select * from t_query_dataset_" + titleDataset + "\r\n" +
"      where bi_entity_id = @bi_entity_id\r\n" +
"          and att_8001001d <> 0xffffffff)               -- xonline_comp_attr_status == xonline_comp_status_active\r\n" +
"      return 0x80156206                               -- xonline_e_comp_cancelled\r\n" +
"  if not exists (select * from t_query_dataset_" + titleDataset + "\r\n" +
"      where bi_entity_id = @bi_entity_id\r\n" +
"          and att_80010010 = @att_82010010)             -- xonline_comp_attr_is_team_comp == @xonline_comp_attr_is_team_comp\r\n" +
"      return 0x8015621a                               -- xonline_e_comp_invalid_entrant_type\r\n" +
"  if not exists (select * from t_query_dataset_" + titleDataset + "\r\n" +
"      where bi_entity_id = @bi_entity_id\r\n" +
"          and att_80010002 >= @att_82010002             -- xonline_comp_attr_reg_close >= current time\r\n" +
"          and (att_80010001-1799062968) <= @att_82010002 -- xonline_comp_attr_reg_open - (3 minutes) <= current time\r\n" +
"          and att_8001001d =  0)                        -- xonline_comp_attr_status == xonline_comp_status_pre_init\r\n" +
"      return 0x80156203                               -- xonline_e_comp_registration_closed\r\n" +
"  return 0x80156204                                   -- xonline_e_comp_full\r\n" +
"end\r\n" +
"return 0x0\r\n"

                && custom !=
"update t_query_dataset_" + titleDataset + "\r\n" +
"set att_80010001 = att_80010001 + @att_82010023,        -- xonline_comp_attr_reg_open\r\n" +
"    att_80010002 = att_80010002 + @att_82010023,        -- xonline_comp_attr_reg_close\r\n" +
"    att_80010003 = att_80010003 + @att_82010023,        -- xonline_comp_attr_comp_start\r\n" +
"    att_8001000a = att_8001000a + @att_82010023,        -- xonline_comp_attr_current_round_start\r\n" +
"    att_8001000b = att_8001000b + @att_82010023,        -- xonline_comp_attr_current_round_end\r\n" +
"    att_8001000c = att_8001000c + @att_82010023,        -- xonline_comp_attr_round_one_start\r\n" +
"    att_8001000d = att_8001000d + @att_82010023         -- xonline_comp_attr_round_one_end\r\n" +
"where bi_entity_id = @bi_entity_id\r\n" +
"if (@@rowcount <> 1)\r\n" +
"begin\r\n" +
"    -- update failed, figure out why\r\n" +
"    --\r\n" +
"    if not exists (select * from t_query_dataset_" + titleDataset + " where @bi_entity_id = @bi_entity_id)\r\n" +
"        return 0x80156102                               -- xonline_e_query_entity_not_found\r\n" +
"end\r\n" +
"return 0x0\r\n"

                && custom !=
"update t_query_dataset_" + titleDataset + "\r\n" +
"set att_80020008 = att_80020008 + @att_82010023        -- xonline_comp_attr_entrant_current_start\r\n" +
"where att_80010000 = @att_82010000\r\n" +
"return 0x0\r\n"

                && custom !=
"update t_query_dataset_" + titleDataset + "\r\n" +
"set att_80030003 = att_80030003 + @att_82010023,        -- xonline_comp_attr_event_start\r\n" +
"    att_80030007 = att_80030007 + @att_82010023         -- xonline_comp_attr_event_next_start\r\n" +
"where att_80010000 = @att_82010000\r\n" +
"return 0x0\r\n"
            )

            {
                throw new Exception("Invalid custom text found! Dataset: " + ds.id.ToString("x8") + " text:" + custom);
            }
        }

        private static void parsePlugins(XPathNavigator nav, Dataset ds)
        {
            XPathNodeIterator iterator = nav.Select(GetXPathDataset(ds.id, "/plugins/plugin"));

            while (iterator.MoveNext())
            {
                Plugin p = new Plugin();
                p.assembly = GetStringAttribute(iterator.Current, "assembly");
                p.clazz = GetStringAttribute(iterator.Current, "class");
                p.order = SafeConvert.ToInt32(iterator.Current.GetAttribute("order", ""));

                // context
                //
                XPathNodeIterator ctxIterator = iterator.Current.Select("contextlist/context");
                while (ctxIterator.MoveNext())
                {
                    string name = ctxIterator.Current.GetAttribute("name", "");
                    string kind = ctxIterator.Current.GetAttribute("kind", "");
                    string value = ctxIterator.Current.Value;

                    try
                    {
                        switch (kind)
                        {
                        case "int":
                            p.context.Add(name, Convert.ToInt64(value));
                            break;

                        case "blob":
                            p.context.Add(name, ByteConvert.FromString(value));
                            break;

                        case "string":
                            p.context.Add(name, value);
                            break;

                        default:
                            throw new Exception("Unrecgonized value '" + kind + "' for kind in plugin context!");
                        }
                    }
                    catch(Exception e)
                    {
                        throw new Exception("Error parsing context node " + name + " for plugin " + p.clazz + ", dataset: " + ds.id.ToString("x8"), e);
                    }

                }

                ds.plugins.Add(p);
            }
        }

        private static string[] buildQueryDbCmds(Dataset ds, bool dropTables)
        {
            StringCollection cmds = new StringCollection();

            string table = "t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x");
            bool isPkClustered;
            StringBuilder cmdBldr;
            StringBuilder idxBldr;
            string str;
            string sp;


            // we index agressively -- any column not already indexed gets a non-clustered one
            //
            foreach (Query q in ds.queries)
            {
                foreach (Filter f in q.filters)
                {
                    if (ds.colmap.ContainsKey(f.lval))
                    {
                        Column c = GetColumn(ds, f.lval);
                        if (c.idx == "" && !ds.indexes.Contains("att_" + f.lval.ToString("x8")))
                        {
                            Index idx = new Index();
                            idx.name = "att_" + f.lval.ToString("x8");
                            idx.isClustered = false;
                            idx.isUnique = false;
                            idx.cols.Add(c.id);

                            ds.indexes.Add(idx.name, idx);

                            c.idx = idx.name;
                        }
                    }

                    if (ds.colmap.ContainsKey(f.rval))
                    {
                        Column c = GetColumn(ds, f.rval);
                        if (c.idx == "" && !ds.indexes.Contains("att_" + f.rval.ToString("x8")))
                        {
                            Index idx = new Index();
                            idx.name = "att_" + f.rval.ToString("x8");
                            idx.isClustered = false;
                            idx.isUnique = false;
                            idx.cols.Add(c.id);

                            ds.indexes.Add(idx.name, idx);

                            c.idx = idx.name;
                        }
                    }
                }
            }

            // check for any clustered indexes
            isPkClustered = true;
            foreach (Index idx in ds.indexes.Values)
            {
                if (idx.isClustered)
                {
                    isPkClustered = false;
                    break;
                }
            }


            cmdBldr = new StringBuilder();
            idxBldr = new StringBuilder();

            // create table
            //
            cmdBldr.Append("if exists (select * from dbo.sysobjects where id = object_id('" + table + "') and type = 'u')\r\n");
            cmdBldr.Append("begin\r\n");
            if (dropTables == true)
            {
                cmdBldr.Append("    drop table " + table + "\r\n");
                cmdBldr.Append("end\r\n");
                cmdBldr.Append("\r\n");
                cmdBldr.Append("begin\r\n");
            }
            else
            {
                cmdBldr.Append("    print '**Note: table " + table + " already exists and is current.'\r\n");
                cmdBldr.Append("end\r\n");
                cmdBldr.Append("else\r\n");
                cmdBldr.Append("begin\r\n");
            }

            cmdBldr.Append("    print 'creating table " + table + ".'\r\n");

            cmdBldr.Append(buildHeaderComments(table, ds));

            cmdBldr.Append(
                  "    create table " + table + "\r\n" +
                  "    (\r\n" +
                  "        -- universal columns\r\n" +
                  "        bi_entity_id bigint not null\r\n" +
                  "       ,bi_owner_id  bigint not null\r\n" +
                  "       ,dt_change_datetime datetime not null default(getutcdate())\r\n" +
                  "\r\n" +
                  "        -- dataset attributes\r\n");

            isPkClustered = false;
            for (int i = 0; i < ds.columns.Count; i++)
            {
                Column c = (Column)ds.columns[i];

                if (IsDefaultColumn(c.id))
                {
                    continue;
                }

                str = "       ,att_" + c.id.ToString("x8") + " ";

                if (c.maxlen == 0)
                    c.maxlen = 30;

                switch(c.type)
                {
                case "string":
                    str += "nvarchar(" + c.maxlen + ")";
                    break;

                case "int":
                    str += "bigint";
                    break;

                case "blob":
                    str += "varbinary(" + c.maxlen + ")";
                    break;
                }

                str += (c.isNullable ? " null" : " not null");

                if ((c.defaultVal != null) && (c.defaultVal != ""))
                {
                    str += " default(" + c.defaultVal + ")";
                }


                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append("-- " + c.name + "\r\n");
            }

            cmdBldr.Append("       ,primary key " + (isPkClustered ? " clustered " : " nonclustered ") + "(bi_entity_id)\r\n");
            cmdBldr.Append("    )\r\n\r\n");

            // create indexes
            //
            foreach (Index idx in ds.indexes.Values)
            {
                cmdBldr.Append("    create ");
                if (idx.isUnique)    cmdBldr.Append("unique ");
                if (idx.isClustered) cmdBldr.Append("clustered ");
                cmdBldr.Append("index idx_");
                cmdBldr.Append(idx.name);
                cmdBldr.Append(" on ");
                cmdBldr.Append(table);
                cmdBldr.Append("(");
                for (int i = 0; i < idx.cols.Count; i++)
                {
                    if ((int)idx.cols[i] == unchecked((int)0x80000000))        cmdBldr.Append("bi_entity_id");
                    else if ((int)idx.cols[i] == unchecked((int)0x80000001))   cmdBldr.Append("bi_owner_id");
                    else                                                       cmdBldr.Append("att_" + ((int)idx.cols[i]).ToString("x8"));

                    if (i != idx.cols.Count - 1)
                    {
                        cmdBldr.Append(",");
                    }
                }
                cmdBldr.Append(")\r\n");
            }

            cmdBldr.Append("end\r\n");

            cmds.Add(cmdBldr.ToString());

            //
            // entity table
            //

            cmds.Add(buildEntityInsertCmd(ds));


            //
            // add standard queries
            //
            sp = "p_query_add_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x");


            cmds.Add(buildStockSpCheck(sp));
            cmds.Add(buildAddQuery(ds, sp));
            cmds.Add(buildGrantCmd(sp));


            sp = "p_query_removeid_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x");
            cmds.Add(buildStockSpCheck(sp));
            cmds.Add(buildRemoveIdQuery(ds, sp));
            cmds.Add(buildGrantCmd(sp));


            //
            // custom query creation
            //
            for (int i = 0; i < ds.queries.Count; i++)
            {
                Query q = (Query)ds.queries[i];

                sp = "p_query_" + (q.op == "findids" ? "find_ids" : q.op) + "_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + "_" + q.id.ToString("x");

                cmds.Add(buildStockSpCheck(sp));

                switch (q.op)
                {
                case "search":
                    cmds.Add(buildSearchQuery(ds, q, sp));
                    break;

                case "update":
                case "updateid":
                    cmds.Add(buildUpdateQuery(ds, q, sp));
                    break;

                case "remove":
                    cmds.Add(buildRemoveQuery(ds, q, sp));
                    break;


                case "findids":
                    cmds.Add(buildFindIdsQuery(ds, q, sp));
                    break;

                case "custom":
                    cmds.Add(buildCustomQuery(ds, q, sp));
                    break;

                default:
                    throw new Exception("Unkown operation " + q.op + "!! dataset: " + ds.id.ToString("x"));
                }

                cmds.Add(buildGrantCmd(sp));
            }


            // copy to a string array to be returned.
            //
            string[] ret = new string[cmds.Count];
            cmds.CopyTo(ret, 0);

            return ret;
        }

        private static string buildHeaderComments(string ob, Dataset ds)
        {
            FileVersionInfo myFileVersionInfo = FileVersionInfo.GetVersionInfo( Assembly.GetExecutingAssembly().Location );

            return "\r\n" +
                   "    -- Do not modify. Build Info - !!Version=" + myFileVersionInfo.ProductVersion + "\r\n" +
                   "    -- " + ob + " generated on " + DateTime.Now.ToString() + "\r\n" +
                   "    -- XQS version: " + ds.version + "\r\n\r\n";
        }


        private static string buildStockSpCheck(string sp)
        {
            return "if not exists (select name from sysobjects where type = 'p' and name = '" + sp + "')\r\n" +
                    "begin \r\n" +
                    "    exec('create procedure " + sp + " as raiserror(''Empty Stored Procedure!'', 16, 1) with seterror')\r\n" +
                    "    if (@@error = 0)\r\n" +
                    "        print 'Successfully created empty stored procedure " + sp + ".'\r\n" +
                    "    else\r\n" +
                    "        print 'FAILED to create stored procedure " + sp + ".'\r\n" +
                    "end  \r\n";

        }


        private static string buildGrantCmd(string sp)
        {
            return "grant exec on " + sp + " to ClientLib";
        }

        private static string buildTitleEntitiesTable(uint titleId)
        {
            string table = "t_query_entities_" + titleId.ToString("x8");
            return "if exists (select * from dbo.sysobjects where id = object_id(N'" + table + "') and OBJECTPROPERTY(id, N'IsUserTable') = 1)\r\n" +
                "begin\r\n" +
                "    print '**Note: table " + table + " already exists and is current.'\r\n" +
                "end\r\n" +
                "else\r\n" +
                "begin\r\n" +
                "    create table " + table + "\r\n" +
                "    (\r\n" +
                "        i_dataset_id int not null primary key,\r\n" +
                "        i_entry_id int not null,        \r\n" +
                "        dt_change_datetime datetime not null default(getutcdate())        \r\n" +
                "        \r\n" +
                "    )\r\n" +
                "end\r\n";
        }

        private static string buildEntityInsertCmd(Dataset ds)
        {
            return "insert into t_query_entities_" + ds.titleId.ToString("x8") + "(i_entry_id, i_dataset_id)\r\n" +
                   "select 0, " + ds.id + " where not exists \r\n" +
                   " (select * from t_query_entities_" + ds.titleId.ToString("x8") + " where i_dataset_id = "+ ds.id + ")\r\n";
        }


        private static string buildSearchQuery(Dataset ds, Query q, string sp)
        {
            string str = "";
            string where = "";
            StringBuilder cmdBldr = new StringBuilder();

            cmdBldr.Append("alter procedure " + sp + " (\r\n");

            cmdBldr.Append(buildHeaderComments(sp, ds));

            // parameters
            //
            cmdBldr.Append("    @i_max_results int = 0\r\n");
            for (int j = 0; j < q.parameters.Count; j++)
            {
                Param p = (Param)q.parameters[j];

                str = "    ,@att_" + p.id.ToString("x8") + " " + p.sqltype;
                if ((p.defaultVal != null) && (p.defaultVal != ""))
                {
                    str += " = " + p.defaultVal;
                }

                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append(" -- " + p.name + "\r\n");
            }
            cmdBldr.Append("    )\r\n");
            cmdBldr.Append("as\r\n");

            // get the count
            //
            cmdBldr.Append("    set nocount on\r\n");
            cmdBldr.Append("    set xact_abort on\r\n\r\n");
            cmdBldr.Append("    declare @i_rows int\r\n\r\n");

            cmdBldr.Append("    select count(bi_entity_id) from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock)\r\n");

            for (int j = 0; j < q.filters.Count; j++)
            {
                Filter f = (Filter)q.filters[j];
                string comment = "";

                str = (j == 0 ? "        where " :  "        and ");

                if (ds.constants.ContainsKey(f.lval))
                {
                    str += ds.constants[f.lval];
                    comment += ds.constants[f.lval];
                }
                else if (ds.colmap.ContainsKey(f.lval))
                {
                    Column c = GetColumn(ds, f.lval);

                    if (IsDefaultColumn(c.id))
                    {
                        str += c.name;
                    }
                    else
                    {
                        str += "att_" + f.lval.ToString("x8");
                    }

                    comment += c.name;
                }
                else // parameter
                {
                    str += "@att_" + f.lval.ToString("x8");
                    comment += GetParameter(q, f.lval).name;
                }

                str += " " + f.op + " ";
                comment +=  " " + f.op + " ";

                if (ds.constants.ContainsKey(f.rval))
                {
                    str += ds.constants[f.rval];
                    comment += ds.constants[f.rval];
                }
                else if (ds.colmap.ContainsKey(f.rval))
                {
                    Column c = GetColumn(ds, f.rval);

                    if (IsDefaultColumn(c.id))
                    {
                        str += c.name;
                    }
                    else
                    {
                        str += "att_" + f.rval.ToString("x8");
                    }

                    comment += c.name;
                }
                else // parameter
                {
                    str += "@att_" + f.rval.ToString("x8");
                    comment += GetParameter(q, f.rval).name;
                }

                str = str.PadRight(45);

                where += str;
                where += "-- " + comment + "\r\n";
            }

            cmdBldr.Append(where);
            cmdBldr.Append("\r\n");
            cmdBldr.Append("    set rowcount @i_max_results\r\n");


            // return list
            //
            cmdBldr.Append("    select bi_entity_id\r\n");
            for (int j = 0; j < q.returns.Count; j++)
            {
                Return r = ((Return)q.returns[j]);

                if (IsDefaultColumn(r.id))
                {
                    cmdBldr.Append("        ," + GetColumn(ds, r.id).name);
                }
                else
                {
                    cmdBldr.Append("        ,att_" + r.id.ToString("x8"));
                }

                cmdBldr.Append("    -- " + r.name);
                cmdBldr.Append("\r\n");
            }

            cmdBldr.Append("    from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock)\r\n");
            cmdBldr.Append(where);

            for (int j = 0; j < q.sorts.Count; j++)
            {
                Sort s = (Sort)q.sorts[j];

                if (j == 0)
                {
                    str = "    order by ";
                }
                else
                {
                    str = "       , ";
                }

                str += "att_" + s.id.ToString("x8");
                str += " " + s.dir;
                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append("    -- " + GetColumn(ds, s.id).name + "\r\n");
            }

            cmdBldr.Append("\r\n");
            cmdBldr.Append("    set rowcount 0\r\n");

            return cmdBldr.ToString();
        }

        private static string buildUpdateQuery(Dataset ds, Query q, string sp)
        {
            StringBuilder cmdBldr = new StringBuilder();
            StringBuilder whereBldr = new StringBuilder();
            int i;
            string str;

            cmdBldr.Append("alter procedure " + sp + " (\r\n");
            cmdBldr.Append(buildHeaderComments(sp, ds));


            if (q.op == "updateid")
            {
                cmdBldr.Append("        @bi_entity_id bigint,\r\n");
            }

            cmdBldr.Append("        @bi_owner_id bigint\r\n");

            for (i = 0; i < q.parameters.Count; i++)
            {
                Param p = (Param)q.parameters[i];

                str = "    ,@att_" + p.id.ToString("x8") + " " + p.sqltype;
                if ((p.defaultVal != null) && (p.defaultVal != ""))
                {
                    str += " = " + p.defaultVal;
                }

                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append(" -- " + p.name + "\r\n");
            }

            cmdBldr.Append("    )\r\n");
            cmdBldr.Append("as\r\n");
            cmdBldr.Append("    set nocount on\r\n");
            cmdBldr.Append("    set xact_abort on\r\n");
            cmdBldr.Append("\r\n");
            cmdBldr.Append("    declare @bi_actual_owner bigint\r\n");
            cmdBldr.Append("\r\n");

            cmdBldr.Append("    update t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " set\r\n");
            cmdBldr.Append("        dt_change_datetime = getutcdate()\r\n");

            if (q.op == "updateid" && q.updates.Count == 0)
            {
                // for updateid, we'll assume the parameters correspond to the columns
                // to be updated
                for (i = 0; i < q.parameters.Count; i++)
                {
                    Param p = (Param)q.parameters[i];

                    cmdBldr.Append("       ,att_" + (p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_PARAM).ToString("x8"));
                    cmdBldr.Append(" = @att_" + p.id.ToString("x8"));
                    cmdBldr.Append("    -- " + GetParameter(q, p.id).name);
                    cmdBldr.Append("\r\n");
                }
            }
            else
            {
                for (i = 0; i < q.updates.Count; i++)
                {
                    Update u = (Update)q.updates[i];
                    cmdBldr.Append("       ,att_" + u.id.ToString("x8"));
                    cmdBldr.Append(" = @att_" + u.param.ToString("x8"));
                    cmdBldr.Append("    -- " + GetColumn(ds, u.id).name);
                    cmdBldr.Append("\r\n");
                }
            }

            cmdBldr.Append("    where bi_owner_id = @bi_owner_id\r\n");

            if ((q.op == "updateid") || (q.filters.Count > 0))
            {
                cmdBldr.Append("        and");
            }

            if (q.op == "updateid")
            {
                cmdBldr.Append(" bi_entity_id = @bi_entity_id\r\n");
            }
            else
            {
                for (i = 0; i < q.filters.Count; i++)
                {
                    Filter f = (Filter)q.filters[i];

                    string comment = "";

                    if (i == 0)
                    {
                        str = " ";
                    }
                    else
                    {
                        str = "        and ";
                    }

                    if (ds.constants.ContainsKey(f.lval))
                    {
                        str += ds.constants[f.lval];
                        comment += ds.constants[f.lval];
                    }
                    else if (ds.colmap.ContainsKey(f.lval))
                    {
                        Column c = GetColumn(ds, f.lval);

                        if (IsDefaultColumn(c.id))
                        {
                            str += c.name;
                        }
                        else
                        {
                            str += "att_" + f.lval.ToString("x8");
                        }

                        comment += c.name;
                    }
                    else // parameter
                    {
                        str += "@att_" + f.lval.ToString("x8");
                        comment += GetParameter(q, f.lval).name;
                    }



                    str += " " + f.op + " ";
                    comment +=  " " + f.op + " ";

                    if (ds.constants.ContainsKey(f.rval))
                    {
                        str += ds.constants[f.rval];
                        comment += ds.constants[f.lval];
                    }
                    else if (ds.colmap.ContainsKey(f.rval))
                    {
                        Column c = GetColumn(ds, f.rval);

                        if (IsDefaultColumn(c.id))
                        {
                            str += c.name;
                        }
                        else
                        {
                            str += "att_" + f.rval.ToString("x8");
                        }

                        comment += c.name;
                    }
                    else // parameter
                    {
                        str += "@att_" + f.rval.ToString("x8");
                        comment += GetParameter(q, f.rval).name;
                    }

                    str = str.PadRight(45);

                    whereBldr.Append(str);
                    whereBldr.Append(" -- " + comment + "\r\n");
                }

                cmdBldr.Append(whereBldr.ToString());

            }

            if ((q.filters.Count == 0) && (q.op == "update"))
            {
                cmdBldr.Append("\r\n");
                cmdBldr.Append("    if (@@rowcount = 0)\r\n" +
                               "    begin\r\n" +
                               "            return 0x80156102                           -- XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                               "    end\r\n" +
                               "\r\n" +
                               "return 0x0\r\n");
            }
            else
            {
                cmdBldr.Append("\r\n");
                cmdBldr.Append("    if (@@rowcount = 0)\r\n" +
                               "    begin\r\n" +
                               "        if exists (select *\r\n" +
                               "        from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock)\r\n");

                if (q.op == "updateid")
                {
                    cmdBldr.Append("        where bi_entity_id = @bi_entity_id\r\n");
                }
                else if (q.filters.Count > 0)
                {
                    cmdBldr.Append("        where");
                    cmdBldr.Append(whereBldr.ToString());
                }

                cmdBldr.Append("        )\r\n" +
                               "            return 0x80156103                           --XONLINE_E_QUERY_PERMISSION_DENIED\r\n" +
                               "        else\r\n" +
                               "            return 0x80156102                           -- XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                               "    \r\n" +
                               "    end\r\n" +
                               "\r\n" +
                               "return 0x0\r\n");
            }

            return cmdBldr.ToString();
        }


        private static string buildRemoveQuery(Dataset ds, Query q, string sp)
        {
            string str = "";
            StringBuilder cmdBldr = new StringBuilder();
            StringBuilder fltrBlr = new StringBuilder();
            int i;

            cmdBldr.Append("alter procedure " + sp + " (\r\n");
            cmdBldr.Append(buildHeaderComments(sp, ds));

            cmdBldr.Append("        @bi_owner_id bigint\r\n");

            // parameters
            //
            for (i = 0; i < q.parameters.Count; i++)
            {
                Param p = (Param)q.parameters[i];

                cmdBldr.Append("       ,");

                str = "@att_" + p.id.ToString("x8") + " " + p.sqltype;
                if ((p.defaultVal != null) && (p.defaultVal != ""))
                {
                    str += " = " + p.defaultVal;
                }

                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append(" -- " + p.name + "\r\n");
            }

            cmdBldr.Append("    )\r\n");
            cmdBldr.Append("as\r\n");

            cmdBldr.Append("    set nocount on\r\n");
            cmdBldr.Append("    set xact_abort on\r\n");
            cmdBldr.Append("\r\n");
            cmdBldr.Append("    delete from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + "\r\n");
            cmdBldr.Append("    where bi_owner_id = @bi_owner_id\r\n");

            for (i = 0; i < q.filters.Count; i++)
            {
                Filter f = (Filter)q.filters[i];

                string comment = "";
                str = "        ";
                if (i > 0) str += "and ";


                if (ds.constants.ContainsKey(f.lval))
                {
                    str += ds.constants[f.lval];
                    comment += ds.constants[f.lval];
                }
                else if (ds.colmap.ContainsKey(f.lval))
                {
                    Column c = GetColumn(ds, f.lval);

                    if (IsDefaultColumn(c.id))
                    {
                        str += c.name;
                    }
                    else
                    {
                        str += "att_" + f.lval.ToString("x8");
                    }

                    comment += c.name;
                }
                else // parameter
                {
                    str += "@att_" + f.lval.ToString("x8");
                    comment += GetParameter(q, f.lval).name;
                }



                str += " " + f.op + " ";
                comment +=  " " + f.op + " ";

                if (ds.constants.ContainsKey(f.rval))
                {
                    str += ds.constants[f.rval];
                    comment += ds.constants[f.lval];
                }
                else if (ds.colmap.ContainsKey(f.rval))
                {
                    Column c = GetColumn(ds, f.rval);

                    if (IsDefaultColumn(c.id))
                    {
                        str += c.name;
                    }
                    else
                    {
                        str += "att_" + f.rval.ToString("x8");
                    }

                    comment += c.name;
                }
                else // parameter
                {
                    str += "@att_" + f.rval.ToString("x8");
                    comment += GetParameter(q, f.rval).name;
                }

                str = str.PadRight(45);

                fltrBlr.Append(str);
                fltrBlr.Append(" -- " + comment + "\r\n");
            }

            if (q.filters.Count > 0)
            {
                cmdBldr.Append("    and ");
                cmdBldr.Append(fltrBlr.ToString());
            }

            cmdBldr.Append("\r\n");
            cmdBldr.Append("    if (@@rowcount = 0)\r\n" +
                           "    begin\r\n");

            cmdBldr.Append("         if exists (select * from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock)\r\n");
            if (q.filters.Count > 0)
            {
                cmdBldr.Append("                    where ");
                cmdBldr.Append(fltrBlr.ToString());
            }
            cmdBldr.Append("             )\r\n" +
                          "         begin\r\n" +
                          "             return 0x80156103                   -- XONLINE_E_QUERY_PERMISSION_DENIED\r\n" +
                          "         end\r\n" +
                          "         else\r\n" +
                          "         begin\r\n" +
                          "             return 0x80156102                   -- XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                          "         end\r\n" +
                          "     end\r\n" +
                          "     return 0x0");

            return cmdBldr.ToString();
        }


        private static string buildRemoveIdQuery(Dataset ds, string sp)
        {
            return  "alter procedure " + sp + "(@bi_owner_id bigint, @bi_entity_id bigint)\r\n" +
                    "as  \r\n" +  buildHeaderComments(sp, ds) +
                    "    set nocount on  \r\n" +
                    "    set xact_abort on  \r\n" +
                    "    \r\n" +
                    "    declare @cnt int\r\n" +
                    "    declare @bi_actual_owner bigint\r\n" +
                    "      \r\n" +
                    "    delete from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + "\r\n" +
                    "    where bi_entity_id = @bi_entity_id\r\n" +
                    "    and bi_owner_id = @bi_owner_id\r\n" +
                    "    \r\n" +
                    "    if (@@rowcount = 0)\r\n" +
                    "    begin\r\n" +
                    "        -- something was wrong.  figure out what\r\n" +
                    "        select @bi_actual_owner = bi_owner_id\r\n" +
                    "        from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock)\r\n" +
                    "        where bi_entity_id = @bi_entity_id\r\n" +
                    "        \r\n" +
                    "        if (@bi_actual_owner is null)\r\n" +
                    "            return 0x80156102                           --XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                    "        else\r\n" +
                    "            return 0x80156103                           --XONLINE_E_QUERY_PERMISSION_DENIED\r\n" +
                    "    end\r\n" +
                    "  \r\n" +
                    "    return 0\r\n";
        }

        private static string buildFindIdsQuery(Dataset ds, Query q, string sp)
        {
            StringBuilder cmdBldr = new StringBuilder();
            StringBuilder selBldr = new StringBuilder();
            int i;

            cmdBldr.Append("alter procedure " + sp + " (\r\n" +
                           "        @i_num_ids int\r\n");

            for (i = 0; i < 10; i++)
            {
                cmdBldr.Append("        ,@id" + i + " bigint = null\r\n");
            }

            cmdBldr.Append( "        )\r\n" +
                            "as\r\n" + buildHeaderComments(sp, ds) +
                            "    set nocount on\r\n" +
                            "    set xact_abort on\r\n" +
                            "    declare @n int\r\n" +
                            "\r\n");

            // build select part
            selBldr.Append("        select bi_entity_id\r\n");
            for (i = 0; i < q.returns.Count; i++)
            {
                Return r = (Return)q.returns[i];

                if (IsDefaultColumn(r.id))
                {
                    selBldr.Append("            ," + GetColumn(ds, r.id).name);
                }
                else
                {
                    selBldr.Append("            ,att_" + r.id.ToString("x8"));
                }

                selBldr.Append("        -- " + r.name + "\r\n");
            }
            selBldr.Append("        from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock) where bi_entity_id = @id");


            // single id shortcut
            //
            cmdBldr.Append("    if (@i_num_ids = 1)\r\n" +
                           "    begin\r\n" +
                           "        if not exists (select * from t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x") + " with (nolock) where bi_entity_id = @id0)\r\n" +
                           "        begin\r\n" +
                           "            select -2146082558                          -- XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                           "            return\r\n" +
                           "        end\r\n" +
                           "        select 0                                        -- S_OK\r\n"
                           );

            cmdBldr.Append(selBldr.ToString() + "0\r\n" +
                           "        return\r\n" +
                           "    end\r\n" +
                           "\r\n");


            cmdBldr.Append("    create table #res\r\n" +
                           "    (\r\n" +
                           "        bi_entity_id bigint\r\n");

            for (i = 0; i < q.returns.Count; i++)
            {
                Return r = ((Return)q.returns[i]);

                if (IsDefaultColumn(r.id))
                {
                    cmdBldr.Append("        ," + r.name + "_" + i + " " + GetColumn(ds, r.id).sqltype + "\r\n");
                }
                else
                {
                    cmdBldr.Append("        ,att_" + r.id.ToString("x8") + "_" + i + " " + GetColumn(ds, r.id).sqltype + "\r\n");
                }
            }

            cmdBldr.Append("    )\r\n");
            cmdBldr.Append("\r\n");

            for (i = 0; i < 10; i++)
            {
                cmdBldr.Append("    if (@i_num_ids > " + i + ")\r\n" +
                               "    begin\r\n" +
                               "        insert into #res\r\n");
                cmdBldr.Append(selBldr.ToString());
                cmdBldr.Append(i.ToString() + "\r\n\r\n");
                cmdBldr.Append("        if (@@rowcount = 0)\r\n" +
                               "        begin\r\n" +
                               "            select -2146082558                          -- XONLINE_E_QUERY_ENTITY_NOT_FOUND\r\n" +
                               "            return\r\n" +
                               "        end\r\n" +
                               "    end\r\n");
            }

            cmdBldr.Append("    select 0                                            -- S_OK\r\n");
            cmdBldr.Append("    select bi_entity_id\r\n");
            for (i = 0; i < q.returns.Count; i++)
            {
                Return r = ((Return)q.returns[i]);

                if (IsDefaultColumn(r.id))
                {
                    cmdBldr.Append("        ," + r.name);
                }
                else
                {
                    cmdBldr.Append("        ,att_" + r.id.ToString("x8") + "_" + i);
                }

                cmdBldr.Append("        -- " + r.name + "\r\n");
            }
            cmdBldr.Append("    from #res\r\n" +
                           "    return 0\r\n");

            return cmdBldr.ToString();
        }

        private static string buildCustomQuery(Dataset ds, Query q, string sp)
        {
            string str = "";
            StringBuilder cmdBldr = new StringBuilder();
            int i;


            validateCustom(q.custom, ds);



            cmdBldr.Append("alter procedure " + sp + " (\r\n");

            cmdBldr.Append("        @bi_entity_id bigint\r\n");
            cmdBldr.Append("       ,@bi_owner_id bigint\r\n");

            // parameters
            //
            for (i = 0; i < q.parameters.Count; i++)
            {
                Param p = (Param)q.parameters[i];

                cmdBldr.Append("        ,");

                str = "@att_" + p.id.ToString("x8") + " " + p.sqltype;
                if ((p.defaultVal != null) && (p.defaultVal != ""))
                {
                    str += " = " + p.defaultVal;
                }

                str = str.PadRight(45);
                cmdBldr.Append(str);
                cmdBldr.Append(" -- " + p.name + "\r\n");
            }

            cmdBldr.Append("    )\r\n");
            cmdBldr.Append("as\r\n");

            cmdBldr.Append(buildHeaderComments(sp, ds));

            cmdBldr.Append("    set nocount on\r\n");
            cmdBldr.Append("    set xact_abort on\r\n");
            cmdBldr.Append("\r\n");

            cmdBldr.Append(q.custom);

            return cmdBldr.ToString();
        }

        private static string buildAddQuery(Dataset ds, string sp)
        {
            string str = "";
            StringBuilder cmdBldr = new StringBuilder();
            int i;
            string table = "t_query_dataset_" + ds.titleId.ToString("x8") + "_" + ds.id.ToString("x");

            cmdBldr.Append("alter procedure " + sp + " (\r\n");

            cmdBldr.Append("        @bi_owner_id bigint\r\n");
            cmdBldr.Append("       ,@i_owner_quota int\r\n");

            for (i = 0; i < ds.columns.Count; i++)
            {
                Column c = (Column)ds.columns[i];

                if (IsDefaultColumn(c.id))
                {
                    continue;
                }

                str = "       ,@att_" + (c.id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM).ToString("x8") + " ";

                // note: 1 is added to maxlen to force 'attribute too long' error instead of silent truncation by sql.
                switch(c.type)
                {
                case "string":
                    str += "nvarchar(" + (c.maxlen+1) + ")";
                    break;

                case "int":
                    str += "bigint";
                    break;

                case "blob":
                    str += "varbinary(" + (c.maxlen+1) + ")";
                    break;
                }


                if ((c.defaultVal != null) && (c.defaultVal != ""))
                {
                    str += " = " + c.defaultVal;
                }

                str = str.PadRight(45);

                cmdBldr.Append(str);
                cmdBldr.Append("-- ");
                cmdBldr.Append(c.name);
                cmdBldr.Append("\r\n");
            }

            cmdBldr.Append( "       ,@bi_entity_id bigint output\r\n" +
                            "        )\r\n" +
                            "as\r\n" + buildHeaderComments(sp, ds) +
                            "    set nocount on\r\n" +
                            "    set xact_abort on\r\n" +
                            "\r\n" +
                            "    declare @cur_count int\r\n" +
                            "    declare @i_entry_id int\r\n" +
                            "\r\n" +
                            "    select @bi_entity_id = 0  \r\n" +
                            "\r\n" +
                            "    if (@i_owner_quota <> -1)\r\n" +
                            "    begin\r\n" +
                            "       -- make sure the given owner_id is under the given owner_quota   \r\n" +
                            "       select @cur_count = count(bi_owner_id)  \r\n" +
                            "       from " + table + "\r\n" +
                            "       where bi_owner_id = @bi_owner_id  \r\n" +
                            "\r\n" +
                            "       if (@cur_count >= @i_owner_quota)  \r\n" +
                            "           return 0x80156101                       -- XONLINE_E_QUERY_QUOTA_FULL        \r\n" +
                            "    end\r\n" +
                            "\r\n" +
                            "    begin tran  \r\n" +
                            "\r\n" +
                            "\r\n" +
                            "    -- add the entry to the global entry list, to obtain a unique entity id  \r\n" +
                            "    --  \r\n" +
                            "    update  t_query_entities_" + ds.titleId.ToString("x8") + "\r\n" +
                            "    set \r\n" +
                            "       @i_entry_id = i_entry_id = i_entry_id + 1,\r\n" +
                            "       dt_change_datetime = getutcdate()\r\n" +
                            "    where \r\n" +
                            "       i_dataset_id = " + ds.id + "\r\n" +
                            "\r\n" +
                            "    select @bi_entity_id = convert(bigint, 0x" + ((ulong)(ds.titleId) << 32).ToString("x16") + ") + @i_entry_id     -- (titleid << 32) + @i_entry_id  \r\n" +
                            "\r\n" +
                            "\r\n" +
                            "    -- add the new entry to the dataset list  \r\n" +
                            "    --  \r\n" +
                            "    insert into "+ table + " (  \r\n" +
                            "        bi_entity_id\r\n" +
                            "       ,bi_owner_id\r\n" +
                            "       ,dt_change_datetime\r\n");


            for (i = 0; i < ds.columns.Count; i++)
            {
                Column c = (Column)ds.columns[i];

                if (IsDefaultColumn(c.id))
                {
                    continue;
                }

                cmdBldr.Append("       ,att_");
                cmdBldr.Append(c.id.ToString("x8"));
                cmdBldr.Append("                -- ");
                cmdBldr.Append(c.name);
                cmdBldr.Append("\r\n");
            }

            cmdBldr.Append("    ) values (\r\n" +
                           "        @bi_entity_id\r\n" +
                           "       ,@bi_owner_id\r\n" +
                           "       ,getutcdate()\r\n");

            for (i = 0; i < ds.columns.Count; i++)
            {
                Column c = (Column)ds.columns[i];

                if (IsDefaultColumn(c.id))
                {
                    continue;
                }

                cmdBldr.Append("       ,@att_");
                cmdBldr.Append((c.id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM).ToString("x8"));
                cmdBldr.Append("                -- ");
                cmdBldr.Append(c.name);
                cmdBldr.Append("\r\n");
            }

            cmdBldr.Append("    )\r\n" +
                           "    commit tran\r\n" +
                           "\r\n" +
                           "    return 0x0\r\n");

            return cmdBldr.ToString();
        }

        private static bool IsDefaultColumn(int id)
        {
            bool    fResult = false;

            if ((id == unchecked((int)0x80000000)) || (id == unchecked((int)0x80000001)) || (id == unchecked((int)0x80000002)))
            {
                fResult = true;
            }

            return fResult;
        }

        public static Column GetColumn(Dataset ds, int id)
        {
            if (!ds.colmap.ContainsKey(id))
            {
                throw new Exception("Column with id " + id.ToString("x8") + " doesn't exist! (You should never see this error!)");
            }

            return (Column)(ds.columns[(int)ds.colmap[id]]);
        }

        private static Param GetParameter(Query q, int id)
        {
            if (!q.parammap.ContainsKey(id))
            {
                throw new Exception("Parameter with id " + id.ToString("x8") + " doesn't exist! (You should never see this error!)");
            }

            return (Param)(q.parameters[(int)q.parammap[id]]);
        }


        private static string[] buildNpdbCmds(Dataset ds, uint partition, bool dropTables)
        {
            StringCollection cmds = new StringCollection();
            StringBuilder cmd = new StringBuilder();



            //
            // t_interface_buckets
            //

            string env = Config.Environment;
            string[] qdbservers = Config.GetServerListByInterface(Interface.querydb);

            if (partition > qdbservers.Length)
            {
                throw new Exception("Partition is greater than the number of available partitions! (" + qdbservers.Length + ")");
            }

            string querydbServer = qdbservers[partition-1];

            cmd.Append( "declare @i_partition int\r\n" +
                        "if not exists (select * from t_interface_buckets " +
                        " where vc_environment = '" + env + "' " +
                        " and vc_interface = 'querydb' " +
                        " and i_title_id=0x" + ds.titleId.ToString("x8") + " and i_bucket=0x" + ds.id.ToString("x") + ")\r\n" +
                        "begin\r\n");

            cmd.Append("    insert into t_interface_buckets (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4)\r\n" +
                       "    values('" + env + "', 'querydb', 0x" + ds.titleId.ToString("x8") + ", " + ds.id + ", '" + querydbServer + "', '" + querydbServer + "', '" + DateTime.MaxValue.ToString() + "', '" + ds.quota +"', '', '', '')\r\n" +
                       "end\r\n" +
                       "else\r\n" +
                       "begin\r\n" +
                       "    update t_interface_buckets\r\n" +
                       "    set vc_info1 = '" + ds.quota + "'\r\n");
            if (dropTables == true)
            {
                cmd.Append("    , vc_server = '" + querydbServer + "', vc_next_server = '" + querydbServer + "'\r\n");
            }

            cmd.Append("    where i_title_id = 0x" + ds.titleId.ToString("x8") + " and i_bucket = 0x" + ds.id.ToString("x") + "\r\n" +
                       "        and vc_environment = '" + env + "' and vc_interface = 'querydb' " +
                       "end\r\n");


            cmds.Add(cmd.ToString());


            //
            // t_query_plugins
            //
            cmds.Add("delete from t_query_plugins where i_title_id = 0x" + ds.titleId.ToString("x8") + " and i_dataset_id = 0x" + ds.id.ToString("x8"));
            for(int i = 0; i < ds.plugins.Count; i++)
            {
                Plugin p = (Plugin)ds.plugins[i];


                cmds.Add("insert into t_query_plugins(i_title_id, i_dataset_id, i_order, vc_assembly, vc_class, txt_context)\r\n" +
                         "values(0x" + ds.titleId.ToString("x8") + ", " + ds.id + "," + p.order + ", '" +
                                 p.assembly + "', '" + p.clazz + "', '" + PluginUtil.HashtableToXml(p.context) + "')\r\n");
            }

            string[] ret = new string[cmds.Count];
            cmds.CopyTo(ret, 0);

            return ret;
        }



    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\cwebdb.cs ===
using System;
using System.Net;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.framework 
{
    public enum EWebLBType
    {
        Regular                 = 0,
        RegularTeam             = 1,
        Unit                    = 2,
        UnitTeam                = 3,
        CompetitionTemplate     = 4,
        CompetitionTemplateTeam = 5
    }

    public class CWebDB
    {
        private CLog m_log;
        private string m_sWebDBConnectionString;

        // an array of sqlconnection objects that corresponds to the 
        // sql connection strings above
        private SqlConnection m_sqlConnection = null;

        public CWebDB(
            string sWebDBConnectionString,
            CLog log)
        {
            if (log == null)
            {
                // if they didn't give us a logging object, then create one that
                // does nothing
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            // make sure all non-log parameters are non-null. An empty array is ok, just not null.
            if (sWebDBConnectionString == null)
            {
                throw new ArgumentNullException("sWebDBConnectionString");
            }

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.ctor(" +
                sWebDBConnectionString + ")");

            m_sWebDBConnectionString = sWebDBConnectionString;

            // Create a sql connection. Note, I've decided not to track
            // the opened state of this connection. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            try
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.ctor: "
                    + "Opening connection to stats database using connection string '"
                    + m_sWebDBConnectionString
                    + "'");
                m_sqlConnection = new SqlConnection(m_sWebDBConnectionString);
                m_sqlConnection.Open();
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.ctor: "
                    + "Opening a connection to "
                    + m_sWebDBConnectionString
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "Xbox.Tools.Framework.CWebDB.ctor: "
                    + "Opening a connection to "
                    + m_sWebDBConnectionString
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, ArgumentException);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.ctor complete");
        }

        public void Close()
        {
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.Close()");

            if (m_sqlConnection != null && m_sqlConnection.State != ConnectionState.Closed)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.Close: "
                    + "Closing sql connection "
                    + m_sqlConnection.ConnectionString);
                m_sqlConnection.Close();
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.Close complete");
        }

        // I had this little code block repeated all over the place in this
        // file, so I finally decided to put it in this little helper function
        // It's not always useful, because sometimes I want to check the return
        // code for specific values, but I found that most of the time
        // I just threw the same message if it was non-zero
        private void ExecuteNonQuery(
            SqlCommand sqlCommand,
            string sContext)
        {
            try
            {
                sqlCommand.ExecuteNonQuery();
                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = sContext
                        + ": The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = sContext
                    + ": The stored procedure "
                    + sqlCommand.CommandText 
                    + " caused a SqlException. Details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
        }

        public CTitleId[] TitleGetList()
        {
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleGetList()");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // vc_locale_id            nvarchar(8)         not null,
                    // vc_display_name         nvarchar(128)       not null,
                    // dt_Change_datetime      datetime            not null default(getutcdate()),

                    uint uiTitleId = (uint)(int)sqlDataReader["i_title_id"];

                    // add this data to our list
                    arrayList.Add(new CTitleId(uiTitleId));
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.TitleGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.TitleGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the arraylist to a normal array
            CTitleId[] rgTid = new CTitleId[arrayList.Count];
            arrayList.CopyTo(rgTid);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleGetList complete");
            return rgTid;
        }

        public void TitleDelete(
            CTitleId tid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDelete(" +
                tid.ToString() + ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_title";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.TitleDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleDelete complete");
        }

        public void TitleConfigSet(
            CTitleId tid,
            EESRBRating ESRBRating,
            CLocale locDefault,
            uint uiClusterId,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleConfigSet(" +
                tid.ToString() + ", " +
                ESRBRating+ ", " +
                locDefault+ ", " +
                uiClusterId+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_title_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@ti_esrb_rating", SqlDbType.SmallInt).Value = (Int16)ESRBRating;
            sqlCommand.Parameters.Add("@i_cluster_id", SqlDbType.Int).Value = (int)uiClusterId;
            sqlCommand.Parameters.Add("@vc_default_locale", SqlDbType.NVarChar).Value = (string)locDefault.ToString();
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.TitleConfigSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleConfigSet complete");
        }

        public bool TitleConfigGet(
            CTitleId tid,
            out EESRBRating ESRBRating,
            out CLocale locDefault,
            out uint uiClusterId)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleConfigGet(" +
                tid.ToString() + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            bool bFound = false;
            ESRBRating = EESRBRating.Unspecified;
            locDefault = null;
            uiClusterId = 0;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.TitleConfigGet: "
                        + "found config for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.TitleConfigGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // ti_esrb_rating          tinyint             not null,
                    // i_cluster_id            int                 not null,
                    // vc_default_locale       nvarchar(8)         not null,
                    // dt_Change_datetime      datetime            not null default(getutcdate()),

                    ESRBRating = (EESRBRating)(byte)sqlDataReader["ti_esrb_rating"];
                    uiClusterId = (uint)(int)sqlDataReader["i_cluster_id"];
                    locDefault = new CLocale((string)sqlDataReader["vc_default_locale"]);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.TitleConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.TitleConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleConfigGet complete, returning: "+bFound);
            return bFound;
        }

        public void TitleDescSet(
            CTitleId tid,
            CLocale locale,
            string sDesc,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescSet(" +
                tid.ToString() + ", " +
                locale+ ", " +
                sDesc+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_title_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = locale.ToString();
            sqlCommand.Parameters.Add("@vc_display_name", SqlDbType.NVarChar).Value = sDesc;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.TitleDescSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleDescSet complete");
        }

        public SortedList TitleDescGetList(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescGetList(" +
                tid.ToString() + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList sortedList = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.TitleDescGetList: "
                        + "found description for titleid "
                        + tid.sTitleIdHex);

                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // vc_locale_id            nvarchar(8)         not null,
                    // vc_display_name         nvarchar(128)       not null,
                    // dt_Change_datetime      datetime            not null default(getutcdate()),

                    // note - we don't want to check the locale for validity at this point
                    // invalid locales have crept into the database before, if we try to check
                    // for validity here, we'll get an exception and not be able to clean it up
                    // so just return accurately what we found.
                    string sLocale = (string)sqlDataReader["vc_locale_id"];
                    string sDesc = (string)sqlDataReader["vc_display_name"];

                    // add this data to our list
                    sortedList[sLocale] = sDesc;
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.TitleDescGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.TitleDescGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleDescGetList complete");
            return sortedList;
        }

        public void TitleDescDelete(
            CTitleId tid,
            string sLocale,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescDelete(" +
                tid.ToString() + ", " +
                sLocale+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_title_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = sLocale;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.TitleDescDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.TitleDescDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.TitleDescDelete complete");
        }

        public uint[] WebLBGetList(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBGetList(" +
                tid.ToString() + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_lb_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    uint uiLBNum = (uint)(int)sqlDataReader["i_lb_id"];

                    // add this data to our list
                    arrayList.Add(uiLBNum);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            uint [] rgui = new uint[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBGetList complete");
            return rgui;
        }

        public void WebLBDelete(
            CTitleId tid,
            uint uiLBNum,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDelete(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_lb";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebDBDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBDelete complete");
        }

        public void WebLBConfigSet(
            CTitleId tid,
            uint uiLBNum,
            ELBReset resetInterval,
            uint uiEntriesPerCacheLine,
            uint uiExpirationSeconds,
            EWebLBType webLBType,
            bool bDontList,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigSet(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                resetInterval+ ", " +
                uiEntriesPerCacheLine+ ", " +
                uiExpirationSeconds+ ", " +
                webLBType+ ", " +
                bDontList+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_lb_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (byte)resetInterval;
            sqlCommand.Parameters.Add("@i_entries_per_cache_line", SqlDbType.Int).Value = (int)uiEntriesPerCacheLine;
            sqlCommand.Parameters.Add("@i_expiration_seconds", SqlDbType.Int).Value = (int)uiExpirationSeconds;
            sqlCommand.Parameters.Add("@i_lb_type", SqlDbType.Int).Value = (int)webLBType;
            sqlCommand.Parameters.Add("@ti_dont_list", SqlDbType.TinyInt).Value = (byte)(bDontList ? 1 : 0);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBConfigSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBConfigSet complete");
        }

        public bool WebLBConfigGet(
            CTitleId tid,
            uint uiLBNum,
            out ELBReset resetInterval,
            out uint uiEntriesPerCacheLine,
            out uint uiExpirationSeconds,
            out EWebLBType webLBType,
            out bool bDontList)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigGet(" +
                tid.ToString() + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_lb_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            resetInterval = ELBReset.ResetNever;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            webLBType = EWebLBType.Regular;
            bDontList = false;

            bool bFound = false;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.WebLBConfigGet: "
                        + "found web leaderboard "
                        + uiLBNum
                        + " for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.WebLBConfigGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // i_lb_id                 int                 not null,
                    // ti_reset_type           tinyint             not null,
                    // i_entries_per_cache_line int                not null,
                    // i_expiration_seconds    int                 not null,
                    // dt_Change_datetime      datetime            not null default(getutcdate()),
                    // i_lb_type               int                 not null default(0),
                    // ti_dont_list            tinyint             not null default(0)

                    resetInterval = (ELBReset)(byte)sqlDataReader["ti_reset_type"];
                    uiEntriesPerCacheLine = (uint)(int)sqlDataReader["i_entries_per_cache_line"];
                    uiExpirationSeconds = (uint)(int)sqlDataReader["i_expiration_seconds"];
                    webLBType = (EWebLBType)(int)sqlDataReader["i_lb_type"];
                    bDontList = ((byte)sqlDataReader["ti_dont_list"] != 0);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBConfigGet complete, returning: "+bFound);
            return bFound;
        }

        public SortedList WebLBDescGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescGetList(" +
                tid.ToString() + ","+
                uiLBNum + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_lb_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList sortedList = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // i_lb_id                 int                 not null,
                    // vc_locale_id            nvarchar(8)         not null,
                    // vc_display_name         nvarchar(128)       not null,

                    string sLocale = (string)sqlDataReader["vc_locale_id"];
                    string sDesc = (string)sqlDataReader["vc_display_name"];

                    // add this data to our list
                    sortedList[sLocale] = sDesc;
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBDescGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBDescGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBDescGetList complete");
            return sortedList;
        }


        public void WebLBDescSet(
            CTitleId tid,
            uint uiLBNum,
            CLocale locale,
            string sDesc,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescSet(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                locale+ ", " +
                sDesc+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_lb_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = locale.ToString();
            sqlCommand.Parameters.Add("@vc_display_name", SqlDbType.NVarChar).Value = sDesc;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBDescSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBDescSet complete");
        }

        public void WebLBDescDelete(
            CTitleId tid,
            uint uiLBNum,
            string sLocale,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescDelete(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                sLocale+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_lb_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = sLocale;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBDescDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBDescDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBDescDelete complete");
        }

        public SortedList WebLBAttrGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrGetList(" +
                tid.ToString() + ","+
                uiLBNum + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_raw_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList sortedList = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // i_lb_id                 int                 not null,
                    // i_raw_attribute_id      int                 not null,
                    // ti_puid_attribute       tinyint             not null,

                    uint uiAttrId = (uint)(int)sqlDataReader["i_raw_attribute_id"];
                    bool bIsPuid = ((byte)sqlDataReader["ti_puid_attribute"] != 0 ? true : false);

                    // add this data to our list
                    sortedList[uiAttrId] = bIsPuid;
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBAttrGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBAttrGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBAttrGetList complete");
            return sortedList;
        }

        public void WebLBAttrSet(
            CTitleId tid,
            uint uiLBNum,
            uint uiAttrId,
            bool bIsPuid,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrSet(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                uiAttrId+ ", " +
                bIsPuid+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_raw_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@i_raw_attribute_id", SqlDbType.Int).Value = (int)uiAttrId;
            sqlCommand.Parameters.Add("@ti_puid_attribute", SqlDbType.TinyInt).Value = (bIsPuid ? 1 : 0);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBAttrSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBAttrSet complete");
        }

        public void WebLBAttrDelete(
            CTitleId tid,
            uint uiLBNum,
            uint uiAttrId,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrDelete(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                uiAttrId+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_raw_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@i_raw_attribute_id", SqlDbType.Int).Value = (int)uiAttrId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBAttrDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBAttrDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBAttrDelete complete");
        }


        public string[] WebLBValueGetList(
            CTitleId tid,
            uint uiLBNum)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueGetList(" +
                tid.ToString() + ", " +
                uiLBNum + "}");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_attribute_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    string sName = (string)sqlDataReader["vc_name"];

                    // add this data to our list
                    arrayList.Add(sName);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            string[] rgs = new string[arrayList.Count];
            arrayList.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueGetList complete");
            return rgs;
        }

        public void WebLBValueDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDelete(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                sName+ ", "+
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBValueDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueDelete complete");
        }

        public void WebLBValueSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            EWebValueReturnType returnType,
            string sFormula,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigSet(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                sName+ ", " +
                returnType+ ", " +
                sFormula+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("@i_type", SqlDbType.Int).Value = (int)returnType;
            sqlCommand.Parameters.Add("@vc_formula", SqlDbType.NVarChar).Value = sFormula;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBConfigSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBConfigSet complete");
        }

        public bool WebLBValueGet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            out EWebValueReturnType returnType,
            out string sFormula)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueGet(" +
                tid.ToString() + "," +
                uiLBNum + "," +
                sName+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_attribute_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            returnType = EWebValueReturnType.String;
            sFormula = null;

            bool bFound = false;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.WebLBValueGet: "
                        + "found formatted value"
                        + sName
                        + " for web leaderboard "
                        + uiLBNum
                        + " for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // i_lb_id                 int                 not null,
                    // vc_name                 nvarchar(16)        not null,
                    // i_type                  int                 not null,
                    // vc_formula              TEXT                not null,

                    returnType = (EWebValueReturnType)(int)sqlDataReader["i_type"];
                    sFormula = (string)sqlDataReader["vc_formula"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueGet complete, returning: "+bFound);
            return bFound;
        }

        public SortedList WebLBValueDescGetList(
            CTitleId tid,
            uint uiLBNum,
            string sName)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescGetList(" +
                tid.ToString() + ","+
                uiLBNum + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_attribute_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList sortedList = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id              int                 not null,
                    // i_lb_id                 int                 not null,
                    // vc_locale_id            nvarchar(8)         not null,
                    // vc_display_name         nvarchar(128)       not null,

                    string sLocale = (string)sqlDataReader["vc_locale_id"];
                    string sDesc = (string)sqlDataReader["vc_display_name"];

                    // add this data to our list
                    sortedList[sLocale] = sDesc;
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueDescGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.WebLBValueDescGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueDescGetList complete");
            return sortedList;
        }

        public void WebLBValueDescSet(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            CLocale locale,
            string sDesc,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescSet(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                sName+ "," +
                locale+ ", " +
                sDesc+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_insert_attribute_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = locale.ToString();
            sqlCommand.Parameters.Add("@vc_display_name", SqlDbType.NVarChar).Value = sDesc;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBValueDescSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueDescSet complete");
        }

        public void WebLBValueDescDelete(
            CTitleId tid,
            uint uiLBNum,
            string sName,
            string sLocale,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescDelete(" +
                tid.ToString() + ", " +
                uiLBNum+ ", " +
                sName+ ", "+
                sLocale+ ", " +
                bReportOnly+ ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_delete_attribute_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar).Value = sName;
            sqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.NVarChar).Value = sLocale;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.WebLBValueDescDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.WebLBValueDescDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.WebLBValueDescDelete complete");
        }

      public uint[] PartnerGroupGetList()
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_group_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGroupGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    uint uiGroupId = (uint)(int)sqlDataReader["i_partner_group_id"];

                    // add this data to our list
                    arrayList.Add(uiGroupId);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGroupGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGroupGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            uint [] rgui = new uint[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGroupGetList complete");
            return rgui;
    }

public bool PartnerGroupGet(
            uint uiGroupId,
            out string sDescription)
        {

            sDescription = String.Empty;

            if (uiGroupId == 0)
            {
                throw new ArgumentNullException("uiGroupId");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGroupGet(" +
                uiGroupId.ToString() + ")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_group";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_group_id", SqlDbType.Int).Value = (int)uiGroupId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGroupGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            bool bFound = false;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.PartnerGroupGet: "
                        + "found Group Id "
                        + uiGroupId.ToString()
                        + ".");

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGroupGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_partner_group_id              int,
                    // vc_description              nvarchar (256)                not null,

                    sDescription = (string)sqlDataReader["vc_description"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGroupGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGroupGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGroupGet complete, returning: "+bFound);
            return bFound;
        }

      public uint[] PartnerGetList()
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    uint uiPartnerId = (uint)(int)sqlDataReader["i_partner_id"];

                    // add this data to our list
                    arrayList.Add(uiPartnerId);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            uint [] rgui = new uint[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetList complete");
            return rgui;
    }

public bool PartnerGet(
            uint uiPartnerId,
            out uint uiGroupId,
            out string sSubjectName,
            out uint uiCredType,
            out string sDescription)
        {

            uiGroupId = 0;
            sSubjectName = String.Empty;
            uiCredType = 0;
            sDescription = String.Empty;

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (int)uiPartnerId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            bool bFound = false;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.PartnerGet: "
                        + "found Group Id "
                        + uiGroupId.ToString()
                        + ".");

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    //    i_partner_id    int
                    //    i_partner_group_id    int
                    //    vc_subject_name    nvarchar (128)
                    //    i_cred_type    int
                    //    vc_description    nvarchar (256)

                    uiGroupId = (uint)(int)sqlDataReader["i_partner_group_id"];
                    sSubjectName = (string)sqlDataReader["vc_subject_name"];
                    uiCredType = (uint)(int)sqlDataReader["i_cred_type"];
                    sDescription = (string)sqlDataReader["vc_description"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGroupGet complete, returning: "+bFound);
            return bFound;
        }

      public Hashtable PartnerGetAllowedTitles(uint uiPartnerId)
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_allowed_titles";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (int)uiPartnerId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedTitles: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            Hashtable rgTitles = new Hashtable();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    int uiTitleId = (int)sqlDataReader["i_title_id"];
                    int uiTitlePrivelege = (int)sqlDataReader["i_title_privilege"];
                    // add this data to our list
                    rgTitles.Add(uiTitleId,uiTitlePrivelege);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedTitles: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedTitles: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetAllowedTitles complete");
            return rgTitles;
    }

      public string [] PartnerGetAllowedAPIs(uint uiPartnerId)
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_allowed_apis";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (int)uiPartnerId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    string sAPI = (string)sqlDataReader["vc_api_name"];

                    // add this data to our list
                    arrayList.Add(sAPI);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            string [] rgui = new string[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs complete");
            return rgui;
    }

      public string [] PartnerGetIPs(uint uiPartnerId)
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_partner_ips";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (int)uiPartnerId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetIPs: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    string sIP = ((int)sqlDataReader["i_ip"]).ToString() + "."
                        + ((int)sqlDataReader["i_mask"]).ToString();

                    // add this data to our list
                    arrayList.Add(sIP);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetIPs: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetIPs: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            string [] rgui = new string[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetIPs complete");
            return rgui;
    }

        public string [] PartnerGetAllAPIs()
        {       

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_apis";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    string sAPI = (string)sqlDataReader["vc_api_name"] + "." +(int)sqlDataReader["i_widget_id"];
                    // add this data to our list
                    arrayList.Add(sAPI);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            string [] rgui = new string[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetAllowedAPIs complete");
            return rgui;
        }

        public Hashtable PartnerGetAllWidgets()
        {       

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_widgets";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetAllWidgets: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            Hashtable widgets = new Hashtable();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    int WidgetId = (int)sqlDataReader["i_widget_id"];
                    string sDescription = (string)sqlDataReader["vc_description"];

                    // add this data to our list
                    widgets.Add(WidgetId, sDescription);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllWidgets: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAllWidgets: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetAllWidgets complete");
            return widgets;
        }

        public int [] PartnerGetTitleIDList()
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_list";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetTitleList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    int uiTitleID = (int)sqlDataReader["i_title_id"];
                    // add this data to our list
                    arrayList.Add(uiTitleID);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetTitleIDList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetTitleIDList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            int [] rgui = new int[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetTitleIDList complete");
            return rgui;
            }

            public bool PartnerGetTitleInfo(
                int iTitleId,
                out byte iRating,
                out int iClusterID,
                out string sLocale)
            {

            iRating = 0;
            iClusterID = 0;
            sLocale = String.Empty;

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)iTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetTitleInfo: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            bool bFound = false;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.PartnerGet: "
                        + "found Group Id "
                        + iTitleId.ToString()
                        + ".");

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetTitleInfo: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.WriteLineV(sErr);
                        throw new CWebDBException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    //    i_title_id    int
                    //    ti_esrb_rating    tinyint
                    //    i_cluster_id    int
                    //    vc_default_locale    nvarchar (8)

                    iRating = (byte)sqlDataReader["ti_esrb_rating"];
                    iClusterID = (int)sqlDataReader["i_cluster_id"];
                    sLocale = (string)sqlDataReader["vc_default_locale"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetTitleInfo: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetTitleInfo complete, returning: "+bFound);
            return bFound;
        }

        public string [] PartnerGetTitleNames(int iTitleId)
        {

            string sTitleName = String.Empty;
            ArrayList arrayList = new ArrayList();

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_tmr_get_title_name_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = iTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetTitleInfo: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    m_log.WriteLineV(
                        "Xbox.Tools.Framework.CWebDB.PartnerGetAvailableTitleNames: "
                        + "found TitleId Id "
                        + iTitleId.ToString()
                        + ".");

                    sTitleName = (string)sqlDataReader["vc_locale_id"] + "." +
                        (string)sqlDataReader["vc_display_name"];
                    arrayList.Add(sTitleName);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAvailableTitleNames: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetAvailableTitleNames: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            
            // copy the array list to the output array
            string [] rgui = new string[arrayList.Count];
            arrayList.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetTitleIDList complete");
            return rgui;

        }

        public SortedList PartnerGetCredentialTypes()
        {       

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_get_credential_types";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGetCredentialTypes: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList  CredTypes = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();
                // get the results
                while (sqlDataReader.Read())
                {
                    int CredId = (int)sqlDataReader["i_cred_type"];
                    string sDescription = (string)sqlDataReader["vc_description"];
                    // add this data to our list
                    CredTypes.Add(CredId,sDescription);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetCredentialTypes: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CWebDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.PartnerGetCredentialTypes: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CWebDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // copy the array list to the output array
            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGetCredentialTypes complete");
            return CredTypes;
        }

        public void PartnerSetInfo(
            int GroupId,
            int PartnerId,
            string CertName,
            int CredType,
            string Description,
            byte [] Ips,
            string APIs,
            byte [] Titles,
            bool ReportOnly)
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_set_partner_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_group_id", SqlDbType.Int).Value=GroupId;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value=PartnerId;
            sqlCommand.Parameters.Add("@vc_subject_name", SqlDbType.NVarChar, 128).Value=CertName;
            sqlCommand.Parameters.Add("@i_cred_type", SqlDbType.Int).Value=CredType;
            sqlCommand.Parameters.Add("@vc_description", SqlDbType.NVarChar, 256).Value = Description;
            sqlCommand.Parameters.Add("@b_partner_ips", SqlDbType.VarBinary, Ips.Length).Value = Ips;
            sqlCommand.Parameters.Add("@vc_partner_allowed_apis", SqlDbType.NVarChar, APIs.Length).Value = APIs;
            sqlCommand.Parameters.Add("@b_partner_allowed_titles", SqlDbType.VarBinary, Titles.Length).Value = Titles;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerSetInfo: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!ReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.PartnerSetInfo");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerSetInfo complete");
            
        }


        public void PartnerGroupSetInfo(
            int GroupId,
            string Description,
            bool ReportOnly)
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_set_partner_group";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_group_id", SqlDbType.Int).Value=GroupId;
            sqlCommand.Parameters.Add("@vc_description", SqlDbType.NVarChar, 256).Value = Description;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerGroupSetInfo: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!ReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.PartnerGroupSetInfo");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerGroupSetInfo complete");
            
        }

        public void PartnerDeleteInfo(int PartnerId, bool ReportOnly)
        {
        
            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_webdb_pmr_delete_partner_info";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_partner_id", SqlDbType.Int).Value=PartnerId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CWebDB.PartnerDeleteInfo: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!ReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CWebDB.PartnerDeleteInfo");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CWebDB.PartnerDeleteInfo complete");

        }
    }
    
    public class CWebDBException: ApplicationException
    {
        public CWebDBException() : base() {}
        public CWebDBException(string s) : base(s) {}
        protected CWebDBException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CWebDBException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__framework_4_none_12.4.56.0_none_a64f6fade77bdd46
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_framework_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.manifest
XP_MANIFEST_PATH=manifests\x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.cat
XP_CATALOG_PATH=manifests\x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.cat
XP_PAYLOAD_PATH=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_framework_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\EWebValueReturnType.cs ===
namespace xonline.tools.framework 
{
    /// <summary>
    /// An Enum that can be used to specify the return type of a formatted attribute.
    /// </summary>
    public enum EWebValueReturnType
    {
        // reference private\webcache\stats\dll\stats.cs enum AttributeUnit for the ordering
        // on this enum
        Integer = 0,
        Float = 1,
        Percent = 2,
        Gamertag = 3,
        Timestamp = 4,
        Millisecond = 5, // xlast "legacy stats" does not use plural
        Milliseconds = 5, // but xlast "v3 stats" does <sigh>
        TenMillisecond = 6,
        TenMilliseconds = 6,
        HundredMillisecond = 7,
        HundredMilliseconds = 7,
        Second = 8,
        Seconds = 8,
        Minute = 9,
        Minutes = 9,
        Hours= 10,
        Days = 11,
        String = 12,
        Team = 13
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__framework_4_none_12.4.56.0_none_a64f6fade77bdd46
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_framework_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.manifest
XP_MANIFEST_PATH=manifests\x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.cat
XP_CATALOG_PATH=manifests\x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca.cat
XP_PAYLOAD_PATH=x86__framework_4_no-public-key_12.4.56.0_x-ww_ac2398ca
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_framework_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CXsc.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Collections;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;

namespace xonline.tools.framework 
{
    /// <summary>
    /// This class encapsulates the logic that reads in a title's stats configuration in xml format
    /// and applies that configuration to the stats cluster.
    /// </summary>
    public class CXsc
    {
        private CLog m_log = null;

        private XmlDocument m_xmlDoc = null;
        private int m_iXscVersion = 0;

        private XmlNamespaceManager m_xmlnsm = null;

        public CXsc(MemoryStream dataStream, CLog log)
        {
            if (dataStream == null)
            {
                throw new ArgumentNullException("dataStream");
            }
            if (log == null)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_xmlDoc = new XmlDocument();
            try
            {
                m_xmlDoc.Load(dataStream);
            }
            catch (XmlException xmlException)
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + " does not contain well formed xml data";
                m_log.WriteLineV(sErr);
                m_log.WriteLineV("XmlException.LineNumber: " + xmlException.LineNumber);
                m_log.WriteLineV("XmlException.LinePosition: " + xmlException.LinePosition);
                m_log.WriteLineV("XmlException.Message: " + xmlException.Message);
                throw new CXscException(sErr, xmlException);
            }
            

            ValidateXmlDocument ();

        }

        public CXsc(string sPathAndFileName, CLog log)
        {
            if (sPathAndFileName == null)
            {
                throw new ArgumentNullException("sPathAndFileName");
            }
            if (log == null)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor("
                + sPathAndFileName + ", "
                + "{log})");

            m_xmlDoc = new XmlDocument();

            if (!File.Exists(sPathAndFileName))
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + sPathAndFileName
                    + " does not exist";
                m_log.WriteLineV(sErr);
                throw new CXscException(sErr);
            }

            FileStream fileStream = File.OpenRead(sPathAndFileName);
            try
            {
                m_xmlDoc.Load(fileStream);
            }
            catch (XmlException xmlException)
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + sPathAndFileName
                    + " does not contain well formed xml data";
                m_log.WriteLineV(sErr);
                m_log.WriteLineV("XmlException.LineNumber: " + xmlException.LineNumber);
                m_log.WriteLineV("XmlException.LinePosition: " + xmlException.LinePosition);
                m_log.WriteLineV("XmlException.Message: " + xmlException.Message);
                throw new CXscException(sErr, xmlException);
            }
            finally
            {
                fileStream.Close();
            }

            ValidateXmlDocument ();
        }

        public int Version
        {
            get
            {
                return m_iXscVersion;
            }
        }

        private void ValidateXmlDocument ()
        {
            // use the name table from the now-loaded document to initialize
            // a namespace manager - we need this to make the Select statements
            // below work properly
            m_xmlnsm = new XmlNamespaceManager(m_xmlDoc.NameTable);

            // add the xboxlive URI to the namespace manager
            m_xmlnsm.AddNamespace(ns, "http://www.xboxlive.com");

            // version 1 xsc files used 'version' attribute on Title element
            // version 3 xsc files used 'Version' attribute on Title element, whoops.
            string sV1Xpath = "/"+nsPfx("Title")+"/@version";
            string sV3Xpath = "/"+nsPfx("Title")+"/@Version";

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                + "Selecting node that matches: "
                + sV3Xpath);
            XmlAttribute xmlAttrVersion = 
                (XmlAttribute)m_xmlDoc.SelectSingleNode(sV3Xpath, m_xmlnsm);
            if (xmlAttrVersion == null)
            {
                // we only look for the old style version attribute if the
                // new style one is missing
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "Selecting node that matches: "
                    + sV1Xpath);
                xmlAttrVersion= 
                    (XmlAttribute)m_xmlDoc.SelectSingleNode(sV1Xpath, m_xmlnsm);
            }
            string sVersion = null;
            if (xmlAttrVersion != null)
            {
                sVersion = xmlAttrVersion.Value;
            }

            if (sVersion != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "found version attribute of "
                    + sVersion);

                // we only look at the major version, so grab everything
                // before the first '.', if there is one
                if (sVersion.IndexOf('.') != -1)
                {
                    sVersion = sVersion.Substring(0, sVersion.IndexOf('.'));
                }
                try
                {
                    m_iXscVersion = Int32.Parse(sVersion);
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                        + "Using version "
                        + m_iXscVersion
                        + " format.");
                }
                catch (Exception e)
                {
                    string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                        + "unable to parse major version of "
                        + sVersion
                        + " into an integer ";
                    m_log.WriteLineV(sErr);
                    throw new CXscException(sErr, e);
                }
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "No version specfied in xsc file, defaulting to version 1 format");
                m_iXscVersion = 1;
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor complete");
        }
        private string nsPfx(string sElemName)
        {
            return ns + ":" + sElemName;
        }

        private string ns
        {
            get { return "xbl"; }
        }

        private string TitleXpath
        {
            get {return "/"+ ns + ":Title";}
        }

        private string TitleIDXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath+"/@titleid";
                }
                return TitleXpath+"/@TitleID";
            }
        }

        private string UnitDecayXpath 
        {
            get { return TitleXpath+"/@UnitLeaderboardDecayConstant"; }
        }

        private string DefaultLocaleXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath+"/@default_locale";
                }
                return TitleXpath+"/@Default_Locale";
            }
        }

        private string IndLBListXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath
                        +"/"+ns+":Leaderboard";
                    
                }
                return TitleXpath
                    +"/"+ns+":LeaderboardContainer[@type='individual']"
                    +"/"+ns+":Leaderboard";
            }
        }

        private string UnitLBListXpath 
        {
            get
            {
                return TitleXpath
                    +"/"+nsPfx("LeaderboardContainer[@type='units']")
                    +"/"+nsPfx("Leaderboard");
            }
        }

        private string CompLBListXpath 
        {
            get
            {
                return TitleXpath
                    +"/"+nsPfx("LeaderboardContainer[@type='competitions']")
                    +"/"+nsPfx("LeaderboardTemplate");
            }
        }

        private string LBIDAttr
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return "id";
                }
                return "ID";
            }
        }

        private string IndLBXpath(uint uiLBNum)
        {
                return IndLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        private string UnitLBXpath(uint uiLBNum)
        {
                return UnitLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        private string CompLBXpath(uint uiLBNum)
        {
                return CompLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ResetXpath
        {
            get { return ns+":Reset/text()"; }
        }

        private string Top100Xpath 
        {
            get { return ns+":TopOneHundred/text()"; }
        }

        private string DecayDaysXpath 
        {
            get { return ns+":DecayDays/text()"; }
        }

        private string TeamsXpath
        {
            get { return ns+":TeamsLeaderboard/text()"; }
        }

        private string ArbitrateXpath
        {
            get { return ns+":Arbitrate/text()"; }
        }

        private string AttachCountXpath
        {
            get { return ns+":Attachments/"+ns+":Uploads/text()"; }
        }

        private string MaxAttachSizeXpath 
        {
            get { return ns+":Attachments/"+ns+":Size/text()"; }
        }

        private string ELOInitXpath 
        {
            get { return ns+":ELO/"+ns+":InitialPlayerRating/text()"; }
        }

        private string ELOScaleXpath 
        {
            get { return ns+":ELO/"+ns+":RatingScaleFactor/text()"; }
        }

        private string ELOExpXpath 
        {
            get { return ns+":ELO/"+ns+":ExponentialBase/text()"; }
        }

        private string ELORangeListXpath 
        {
            get
            {
                return ns+":ELO/"
                    +ns+":MaxWeightRatingRangeArray/"
                    +ns+":MaxWeightRatingRange";
            }
        }

        // relative to ELORangeListXpath
        private string ELORangeStartXpath
        {
            get { return "@start"; }
        }

        private string ELORangeWeightXpath
        {
            get { return "@maxweight"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string DescListXpath
        {
            get { return ns+":Names/"+ns+":LocalizedName"; }
        }

        // relative to DescListXpath
        private string LBDescNameXpath
        {
            get { return ns+":Name/text()"; }
        }

        private string LBDescLocaleXpath
        {
            get { return ns+":Locale/text()"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string AttrListXpath
        {
            get { return ns+":RawAttributes/"+ns+":Attribute"; }
        }

        // relative to LBAttrListXpath
        private string LBAttrIndexXpath
        {
            get { return ns+":Index/text()"; }
        }

        private string LBAttrIsPuidXpath
        {
            get 
            {
                if (m_iXscVersion < 3)
                {
                    return ns+":Puid/text()";
                }
                return ns+":PUID/text()";
            }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueListXpath
        {
            get { return ns+":FormattedValues/"+ns+":FormattedValue"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueXpath(string sName)
        {
            return ValueListXpath+"[xbl:NameID/text()="+sName+"]";
        }

        // relative to LBValueXpath or LBValueListXpath
        private string LBValueNameXpath 
        {
            get { return ns+":NameID/text()"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueTypeXpath(string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Type/text()";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueFormulaXpath (string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Formula/text()";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueDescListXpath(string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Names/"+ns+":LocalizedName";
        }

        // relative to LBValueDescListXpath
        private string LBValueDescNameXpath 
        {
            get { return ns+":Name/text()"; }
        }

        private string LBValueDescLocaleXpath
        {
            get { return ns+":Locale/text()"; }
        }

        public bool TitleIdGet(out CTitleId tid)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet("
                + "{out tid})");

            tid = null;
            bool bFound = false;

            string sXpath = TitleIDXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                    + "Unable to find titleid");
                bFound = false;
                tid = null;
            }
            else
            {
                string sTitleId = xmlAttr.Value;
                try
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                        + "Found titleid of "
                        + sTitleId);
                    // titleid is specified in the xsc file in hex but without the
                    // "0x" prefix. Prepend the prefix and try to parse it
                    tid = new CTitleId("0x" + sTitleId);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                        + "titleid in of '" 
                        + sTitleId 
                        + "' is not in the correct format");
                    bFound = false;
                    tid = null;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet complete, returning: " + bFound);
            return bFound;
        }

        public bool UnitDecayFactorGet(out double dUnitLBDecayFactor)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet("
                + "{out dUnitLBDecayFactor})");

            dUnitLBDecayFactor = 0.0;
            bool bFound = false;

            string sXpath = UnitDecayXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                    + "Unit decay factor not found");
                bFound = false;
                dUnitLBDecayFactor = 0.0;
            }
            else
            {
                string sDecayFactor = xmlAttr.Value;
                try
                {
                    // try to parse it
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                        + "Found UnitLeaderboardDecayConstant attribute in Title element with value "
                        + sDecayFactor);
                    dUnitLBDecayFactor = Double.Parse(sDecayFactor);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                        + "Could not parse unit decay factor of '" 
                        + sDecayFactor
                        + " as a double.");
                    bFound = false;
                    dUnitLBDecayFactor = 0.0;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet complete, returning: " + bFound);
            return bFound;
        }

        public bool DefaultLocaleGet(out CLocale locDefault)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet("
                + "{out dUnitLBDecayFactor})");

            locDefault = null;
            bool bFound = false;

            string sXpath = DefaultLocaleXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                    + "Default locale not found");
                bFound = false;
                locDefault = null;
            }
            else
            {
                string sDefaultLocale = xmlAttr.Value;
                try
                {
                    // try to parse it
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                        + "Found default locale of "
                        + sDefaultLocale);
                    locDefault = new CLocale(sDefaultLocale);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                        + sDefaultLocale 
                        + " is not a valid locale string ");
                    bFound = false;
                    locDefault = null;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet complete, returning: " + bFound);
            return bFound;
        }

        public uint[] LBGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList()");

            ArrayList al = new ArrayList();

            string sXpath = IndLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the leaderboard id is in the id attribute on the leaderboard element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                                + "found individual leaderboard id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                                + "Could not parse leaderboard id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                            + " Leaderboard element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + al.Count
                + " individual leaderboards found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList complete");
            return rgui;
        }

        public uint[] UnitGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList()");

            ArrayList al = new ArrayList();

            string sXpath = UnitLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the leaderboard id is in the id attribute on the leaderboard element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                                + "found unit leaderboard id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                                + "Could not parse unit id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                            + " Leaderboard element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                + al.Count
                + " unit leaderboards found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList complete");
            return rgui;
        }

        public uint[] CompGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList()");

            ArrayList al = new ArrayList();

            string sXpath = CompLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the comp template id is in the id attribute on the 
                // leaderboard template element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                                + "found competition template id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                                + "Could not parse competition template id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                            + " LeaderboardTemplate element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                + al.Count
                + " competition templates found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList complete");
            return rgui;
        }

        public bool LBConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "found leaderboard id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                MaxRatingCountGet(xmlNode, ref uiMaxRatingCount);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet complete");
            return bFound;
        }

        public bool LBConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref int  itopEntries,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "found leaderboard id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                MaxRatingCountGet(xmlNode, ref uiMaxRatingCount);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);
                TopOneHundredGet(xmlNode, ref itopEntries);
                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet complete");
            return bFound;
        }



        public bool UnitConfigGet(
            uint uiLBNum, 
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                    + "unit leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                    + "found unit leaderboard id "
                    + uiLBNum);

                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet complete");
            return bFound;
        }

        public bool CompConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet("
                +uiLBNum+")");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                    + "competition template id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                    + "found competition template id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet complete");
            return bFound;
        }

        public SortedList LBDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList("
                +uiLBNum+")");

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList complete");
            return sl;
        }

        public SortedList UnitDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList("
                +uiLBNum+")");

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList complete");
            return sl;
        }


        public SortedList CompDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList("
                +uiLBNum+")");

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList complete");
            return sl;
        }

        public SortedList LBAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList: "
                + sl.Count
                + " raw attributes found for leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList complete");
            return sl;
        }

        public SortedList UnitAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList: "
                + sl.Count
                + " raw attributes found for unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList complete");
            return sl;
        }

        public SortedList CompAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList: "
                + sl.Count
                + " raw attributes found for competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList complete");
            return sl;
        }

        public string[] LBValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList: "
                + al.Count
                + " formatted values found for leaderboard id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList complete");
            return rgs;
        }

        public string[] UnitValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList: "
                + al.Count
                + " formatted values found for unit leaderboard id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList complete");
            return rgs;
        }


        public string[] CompValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList: "
                + al.Count
                + " formatted values found for competition template id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList complete");
            return rgs;
        }

        public bool LBValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public bool UnitValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public bool CompValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public SortedList LBValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList complete");
            return sl;
        }

        public SortedList UnitValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList complete");
            return sl;
        }

        public SortedList CompValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList complete");
            return sl;
        }

        private bool ExtractFormula(XmlNode xmlNode, ref string sFormula)
        {
            bool bFound = false;
            if (xmlNode.NodeType == XmlNodeType.CDATA)
            {
                sFormula = xmlNode.Value;
                bFound = true;
            }
            else
            {
                // v3 stats xlast released in November 2003 mistakenly 
                // generated formula elements that look like this:
                //
                // <Formula>&lt;![CDATA[attr[2]]]&gt;</Formula>
                //
                // This is not actually a CDATA section. When the xml parser reads 
                // it in, it does expand the entitiy reference but it treats the node 
                // as TEXT not CDATA. Thus it is not protected from the xml parser like 
                // you would expect a CDATA section to be, and the formula may have
                // been mangled
                //
                // Because it's not a real CDATA section, the parser doesn't rip
                // out the prefix and suffix for us. 
                //
                // The false CDATA prefix is 8 characters in length
                // The false CDATA suffix is 3 characters in length
                //
                // <![CDATA[attr[2]]]>
                // 0123456789012345678
                // ---------^-----^---
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Warning: Non-CDATA node detected for formula node! "
                    + "This xsc file may have been generated by the November "
                    + "2003 version of Xlast. The formula may be corrupt.");
                string sFormulaTemp = xmlNode.Value.Trim();
                if (sFormulaTemp.Length > 12 && 
                    sFormulaTemp.Substring(0, 9) == "<![CDATA[" &&
                    sFormulaTemp.Substring(sFormulaTemp.Length - 3, 3) == "]]>")
                {
                    sFormula = sFormulaTemp.Substring(9, sFormulaTemp.Length - 12);
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet: "
                        + "Extracted formula: "
                        + sFormula);
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Unable to extract formula, this node will be ingored");
                    bFound = false;
                }
            }
            return bFound;
        }

        private bool ResetGet(XmlNode xmlNodeLB, ref ELBReset lbReset)
        {
            bool bFound = false;
            string sXpath = ResetXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "reset element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found reset element with value "
                    + xmlNode.Value);
                try
                {
                    lbReset = (ELBReset)Int32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool AttachCountGet(XmlNode xmlNodeLB, ref uint uiAttachCount)
        {
            bool bFound = false;
            string sXpath = AttachCountXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "attachment count element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found attachment count element with value "
                    + xmlNode.Value);
                try
                {
                    uiAttachCount = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }


        private bool MaxAttachSizeGet(XmlNode xmlNodeLB, ref uint uiMaxAttachSize)
        {
            bool bFound = false;
            string sXpath = MaxAttachSizeXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "max attachment size element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found max attachment size element with value "
                    + xmlNode.Value);
                try
                {
                    uiMaxAttachSize = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool DecayDaysGet(XmlNode xmlNodeLB, ref uint uiDecayDays)
        {
            bool bFound = false;
            string sXpath = DecayDaysXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "decay days element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found decay days element with value "
                    + xmlNode.Value);
                try
                {
                    uiDecayDays = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool MaxRatingCountGet(XmlNode xmlNodeLB, ref uint uiMaxRatingCount)
        {
            bool bFound = false;
            string sXpath = Top100Xpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "top 100 element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found top 100 element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    uiMaxRatingCount = 100;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    uiMaxRatingCount = 0;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "top 100 value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool ArbitrationGet(XmlNode xmlNodeLB, ref bool bRequireArbitration)
        {
            bool bFound = false;
            string sXpath = ArbitrateXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "arbitration element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found arbitration element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    bRequireArbitration = true;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    bRequireArbitration = false;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "arbitration value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool TopOneHundredGet(XmlNode xmlNodeLB, ref int itopEntries)
        {

            bool bFound = false;
            string sXpath = Top100Xpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Top100 element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found Top100 element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    itopEntries = 100;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    itopEntries = -1;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Top100 value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;

        }

        private bool TeamGet(XmlNode xmlNodeLB, ref bool bIsTeam)
        {
            bool bFound = false;
            string sXpath = TeamsXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "team element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found team element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    bIsTeam = true;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    bIsTeam = false;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "team value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool ELOGet(XmlNode xmlNodeLB, ref CELOConfig eloConfig)
        {
            // keep our findings here until we're sure we
            // got everything
            CELOConfig eloConfigWork = new CELOConfig();

            // first get the ELO Init value
            string sXpath = ELOInitXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Initial Player Rating not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Initial Player Rating element with value "
                + xmlNode.Value);

            try
            {
                eloConfigWork.uiInitialPlayerRating = UInt32.Parse(xmlNode.Value);
            }
            catch (Exception e)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + xmlNode.Value
                    + " could not be parsed as an integer value. "
                    + "Any other ELO information for this leaderboard "
                    + "will be ignored, exception details:"
                    + e.Message);
                return false;
            }

            // next get the ELO scale factor 
            sXpath = ELOScaleXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Rating Scale Factor not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Rating Scale Factor element with value "
                + xmlNode.Value);

            try
            {
                eloConfigWork.uiRatingScaleFactor = UInt32.Parse(xmlNode.Value);
            }
            catch (Exception e)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + xmlNode.Value
                    + " could not be parsed as an integer value. "
                    + "Any other ELO information for this leaderboard "
                    + "will be ignored, exception details:"
                    + e.Message);
                return false;
            }

            // next get the ELO exponential base
            sXpath = ELOExpXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Exponential Base not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Exponential Base element with value "
                + xmlNode.Value);

            string sValue = xmlNode.Value.Trim().ToLower();
            if (sValue == "10")
            {
                eloConfigWork.exponentialBase = EELOExponentialBase.ten;
            }
            else if (sValue == "e")
            {
                eloConfigWork.exponentialBase = EELOExponentialBase.e;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Exponential Base value "
                    + xmlNode.Value
                    + " not recognized. Any other ELO information for "
                    + "this leaderboard will be ignored");
                return false;
            }

            // finally we have to run through the max weight rating ranges
            ArrayList alRatings = new ArrayList();
            sXpath = ELORangeListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNodeRating in xmlNodeList)
            {
                uint uiStart;
                uint uiMaxWeight;

                // get the start value
                sXpath = ELORangeStartXpath;
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Selecting node that matches: "
                    + sXpath);
                XmlNode xmlNodeStart = xmlNodeRating.SelectSingleNode(sXpath, m_xmlnsm);
                if (xmlNodeStart == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "ELO Rating Range Start not found. "
                        + "Any other ELO information for this "
                        + "leaderboard will be ignored");
                    return false;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found ELO Rating Range Start with value "
                    + xmlNodeStart.Value);

                try
                {
                    uiStart = UInt32.Parse(xmlNodeStart.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNodeStart.Value
                        + " could not be parsed as an integer value. "
                        + "Any other ELO information for this leaderboard "
                        + "will be ignored, exception details:"
                        + e.Message);
                    return false;
                }

                // get the max weight value
                sXpath = ELORangeWeightXpath;
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Selecting node that matches: "
                    + sXpath);
                XmlNode xmlNodeWeight = xmlNodeRating.SelectSingleNode(sXpath, m_xmlnsm);
                if (xmlNodeWeight == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "ELO Rating Range Start not found. "
                        + "Any other ELO information for this "
                        + "leaderboard will be ignored");
                    return false;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found ELO Rating Range Start with value "
                    + xmlNodeWeight.Value);

                try
                {
                    uiMaxWeight = UInt32.Parse(xmlNodeWeight.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNodeWeight.Value
                        + " could not be parsed as an integer value. "
                        + "Any other ELO information for this leaderboard "
                        + "will be ignored, exception details:"
                        + e.Message);
                    return false;
                }

                alRatings.Add(new CELOMaxWeightRatingRange(uiStart, uiMaxWeight));
            }

            if (alRatings.Count == 0)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "No ELO Max Weight Rating Ranges found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            // copy the array list to the elo object
            eloConfigWork.rgMaxWeightRatings
                = new CELOMaxWeightRatingRange[alRatings.Count];
            alRatings.CopyTo(eloConfigWork.rgMaxWeightRatings);

            // set the ref var
            eloConfig = eloConfigWork;
            return true;
        }

        public SortedList DescGetList(XmlNode xmlNodeLB)
        {
            SortedList sl = new SortedList();

            string sXpath = DescListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBDescNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName missing Name element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                XmlNode xmlNodeLocale = xmlNode.SelectSingleNode(
                    LBDescLocaleXpath, m_xmlnsm);
                if (xmlNodeLocale == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName missing Locale element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                // check to make sure the locale is valid
                CLocale locale;
                try
                {
                    locale = new CLocale(xmlNodeLocale.Value);
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName Locale element contains "
                        + xmlNodeLocale.Value
                        + " which is not a valid locale. "
                        + "This LocalizedName element will be ignored.");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                    + "Found description '"
                    + xmlNodeName.Value
                    + "' for locale "
                    + locale.ToString());
                sl[locale.ToString()] = xmlNodeName.Value;
            }
            return sl;
        }

        public SortedList AttrGetList(XmlNode xmlNodeLB)
        {
            SortedList sl = new SortedList();

            string sXpath = AttrListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeIndex = xmlNode.SelectSingleNode(
                    LBAttrIndexXpath, m_xmlnsm);
                if (xmlNodeIndex == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute missing Index element. "
                        + "This Attribute element will be ignored");
                    continue;
                }

                XmlNode xmlNodeIsPuid = xmlNode.SelectSingleNode(
                    LBAttrIsPuidXpath, m_xmlnsm);
                if (xmlNodeIsPuid == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute missing PUID element. "
                        + "This Attribute will be ignored");
                    continue;
                }

                // check to make sure puid is true or false
                string sIsPuid = xmlNodeIsPuid.Value.Trim().ToLower();
                bool bIsPuid;
                if (sIsPuid == "true")
                {
                    bIsPuid = true;
                }
                else if (sIsPuid == "false")
                {
                    bIsPuid = false;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute PUID element contains "
                        + xmlNodeIsPuid.Value
                        + " which is not a valid. It must be 'true' or 'false'. "
                        + "This Attribute element will be ignored.");
                    continue;
                }

                // try to parse the index
                uint uiIndex;
                try
                {
                    uiIndex = UInt32.Parse(xmlNodeIndex.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute Index element contains "
                        + xmlNodeIsPuid.Value
                        + " which could not be parsed as a positive integer. "
                        + "This Attribute element will be ignored. Exception details: "
                        + e.Message);
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found Attribute index "
                    + uiIndex
                    + " with puid value of "
                    + bIsPuid);
                sl[uiIndex] = bIsPuid;
            }

            return sl;
        }

        public ArrayList ValueGetList(XmlNode xmlNodeLB)
        {
            ArrayList al = new ArrayList();

            string sXpath = ValueListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBValueNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValues FormattedValue Attribute missing NameID element. "
                        + "This FormattedValue element will be ignored");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found FormattedValue named "
                    + xmlNodeName.Value);
                al.Add(xmlNodeName.Value);
            }

            return al;
        }

        public bool ValueGet(
            XmlNode xmlNodeLB,
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            bool bFoundFormula = false;
            bool bFoundRetType = false;

            string sXpath = ValueTypeXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found return type node with value "
                    + xmlNode.Value);
                string sReturnType = xmlNode.Value;
                try
                {
                    returnType = 
                        (EWebValueReturnType)Enum.Parse(
                        typeof(EWebValueReturnType), 
                        sReturnType, 
                        true);
                    bFoundRetType = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Invalid return type of "
                        + sReturnType
                        + ", Exception details: "
                        + e.Message);
                }
            }

            sXpath = ValueFormulaXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found formula node with value "
                    + xmlNode.Value);
                bFoundFormula = ExtractFormula(xmlNode, ref sFormula);
            }

            return bFoundRetType && bFoundFormula;
        }

        public SortedList ValueDescGetList(XmlNode xmlNodeLB, string sName)
        {
            SortedList sl = new SortedList();

            string sXpath = ValueDescListXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBValueDescNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue Localized Name missing Name element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                XmlNode xmlNodeLocale = xmlNode.SelectSingleNode(
                    LBDescLocaleXpath, m_xmlnsm);
                if (xmlNodeLocale == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue LocalizedName missing Locale element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                // check to make sure the locale is valid
                CLocale locale;
                try
                {
                    locale = new CLocale(xmlNodeLocale.Value);
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue LocalizedName Locale element contains "
                        + xmlNodeLocale.Value
                        + " which is not a valid locale. "
                        + "This LocalizedName element will be ignored.");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found description '"
                    + xmlNodeName.Value
                    + "' for locale "
                    + locale.ToString()
                    + " for formatted value named "
                    + sName);
                sl[locale.ToString()] = xmlNodeName.Value;
            }

            return sl;
        }


        private void DumpXmlNode(XmlNode xmlNode)
        {
            DumpXmlNode(xmlNode, 0);
        }

        // debugging routine
        private void DumpXmlNode(XmlNode xmlNode, int iDepth)
        {
            m_log.WriteLineV(iDepth + ":xmlNode.NodeType: " + xmlNode.NodeType);
            m_log.WriteLineV(iDepth + ":xmlNode.Name: " + xmlNode.Name);
            m_log.WriteLineV(iDepth + ":xmlNode.LocalName: " + xmlNode.LocalName);
            m_log.WriteLineV(iDepth + ":xmlNode.Prefix: " + xmlNode.Prefix);
            m_log.WriteLineV(iDepth + ":xmlNode.NamespaceURI: " + xmlNode.NamespaceURI);
            m_log.WriteLineV(iDepth + ":xmlNode.Value: " + (xmlNode.Value == null ? "null" : xmlNode.Value));

            if (xmlNode.Attributes != null)
            {
                m_log.WriteLineV(iDepth + ":xmlNode.Attributes");
                foreach (XmlAttribute xmlAttribute in xmlNode.Attributes)
                {
                    m_log.WriteLineV(iDepth + ":xmlAttribute.NodeType: " + xmlAttribute.NodeType);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Name: " + xmlAttribute.Name);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.LocalName: " + xmlAttribute.LocalName);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Prefix: " + xmlAttribute.Prefix);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.NamespaceURI: " + xmlAttribute.NamespaceURI);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Value: " + (xmlAttribute.Value == null ? "null" : xmlAttribute.Value));
                }
            }

            if (--iDepth >= 0)
            {
                foreach (XmlNode xmlNodeChild in xmlNode.ChildNodes)
                {
                    DumpXmlNode(xmlNodeChild, iDepth);
                }
            }
        }

            
    }

    /// <summary>
    /// Thrown when the xml passed is well formed, but does not contain
    /// the structure or content expected in a stats submission xml file.
    /// </summary>
    public class CXscException: ApplicationException
    {
        public CXscException() : base() {}
        public CXscException(string s) : base(s) {}
        protected CXscException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CXscException(string s, Exception e) : base(s, e) {}
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CLocaleTest.cs ===
using System;
using NUnit.Framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CLocaleTest
    {
        [Test]
        public void LocaleTest()
        {
            CLocale[] rgLocales = CLocale.SupportedList();
            Assert.AreEqual(25, rgLocales.Length);
            Assert.AreEqual("da-DK", rgLocales[0].ToString());
            Assert.AreEqual("de-AT", rgLocales[1].ToString());
            Assert.AreEqual("de-CH", rgLocales[2].ToString());
            Assert.AreEqual("de-DE", rgLocales[3].ToString());
            Assert.AreEqual("en-AU", rgLocales[4].ToString());
            Assert.AreEqual("en-CA", rgLocales[5].ToString());
            Assert.AreEqual("en-IE", rgLocales[6].ToString());
            Assert.AreEqual("en-GB", rgLocales[7].ToString());
            Assert.AreEqual("en-SG", rgLocales[8].ToString());
            Assert.AreEqual("en-US", rgLocales[9].ToString());
            Assert.AreEqual("es-ES", rgLocales[10].ToString());
            Assert.AreEqual("fi-FI", rgLocales[11].ToString());
            Assert.AreEqual("fr-BE", rgLocales[12].ToString());
            Assert.AreEqual("fr-CA", rgLocales[13].ToString());
            Assert.AreEqual("fr-CH", rgLocales[14].ToString());
            Assert.AreEqual("fr-FR", rgLocales[15].ToString());
            Assert.AreEqual("it-IT", rgLocales[16].ToString());
            Assert.AreEqual("ja-JP", rgLocales[17].ToString());
            Assert.AreEqual("ko-KR", rgLocales[18].ToString());
            Assert.AreEqual("nb-NO", rgLocales[19].ToString());
            Assert.AreEqual("nl-BE", rgLocales[20].ToString());
            Assert.AreEqual("nl-NL", rgLocales[21].ToString());
            Assert.AreEqual("sv-SE", rgLocales[22].ToString());
            Assert.AreEqual("zh-HK", rgLocales[23].ToString());
            Assert.AreEqual("zh-TW", rgLocales[24].ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CCreateNPDB.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.framework.test.dvt 
{
    public class CCreateNPDB
    {
        public static void CreateNPDB(CLog log)
        {
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB starting");

            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Preparing test database");
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Opening SQL Connection");
            SqlConnection sqlConnection = new SqlConnection("Server=localhost;Trusted_Connection=sspi;Pooling=false");
            sqlConnection.Open();

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Dropping database npdb from localhost, if exists");
                sqlCommand.CommandText = 
                    "if (select count(name) from master..sysdatabases where name = 'npdb') = 1 " +
                    "begin " +
                    "drop database npdb " +
                    "end";
                sqlCommand.ExecuteNonQuery();

                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Creating database npdb on localhost");
                sqlCommand.CommandText = "create database npdb";
                sqlCommand.ExecuteNonQuery();

                // reopen the sql connection, this time using webdb for the database
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Connecting to database npdb on localhost");
                sqlConnection.Close();
                sqlConnection.ConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=npdb";
                sqlConnection.Open();

                // create the ClientLib account
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: "
                    + "Creating ClientLib account");
                sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText 
                    = "USE npdb "
                    + "EXEC sp_addrole 'ClientLib' "
                    + "USE master "
                    + "if not exists(select uid from sysusers where name = 'ClientLib') "
                    + "exec sp_addrole 'ClientLib'";
                sqlCommand.ExecuteNonQuery();

                string sSqlFilePath = Directory.GetCurrentDirectory() + @"\npdb";
                ArrayList alSqlCommandFiles = new ArrayList();
                alSqlCommandFiles.Add("t_stringsvr_strings.sql");
                alSqlCommandFiles.Add("p_stringsvr_string_add_by_id.sql");
                alSqlCommandFiles.Add("p_stringsvr_strings_get_by_title_and_id.sql");
                alSqlCommandFiles.Add("p_stringsvr_string_delete.sql");
                alSqlCommandFiles.Add("t_svc_downtime.sql");
                alSqlCommandFiles.Add("p_svc_get_all_downtimes.sql");
                alSqlCommandFiles.Add("p_svc_set_downtime.sql");
                alSqlCommandFiles.Add("p_svc_del_downtime.sql");

                foreach (string sSqlCommandFile in alSqlCommandFiles)
                {
                    // reset to using webdb, just in case another command set the database
                    // to something else (like the one above did!)
                    sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = "USE npdb";
                    sqlCommand.ExecuteNonQuery();

                    string sFileName = sSqlFilePath + @"\" + sSqlCommandFile;
                    log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: "
                        + "Executing sql command file '" + sFileName + "'");
                    CSqlUtils.RunSqlCommandScript(sFileName, sqlConnection, log);
                }

            }
            finally
            {
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB: Closing SQL Connections");
                if (sqlConnection != null && sqlConnection.State != ConnectionState.Closed)
                {
                    sqlConnection.Close();
                }
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateNPDB.CreateNPDB complete");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CAlertsTest.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using NUnit.Framework;
using xonline.tools.framework;
using xonline.common.service;


namespace xonline.tools.framework.test.dvt
{
    [TestFixture]
    public class CAlertsTest
    {
        const string    C_ALERTS_SERVER = "phansen1";
        const ulong     C_WEBID = 0x0002010002EEE066; // phansen@msn-ppe.com


        [Test]
        public void TestAlertsManager()
        {
            CAlertsMgr              alertsMgr = new CAlertsMgr(C_ALERTS_SERVER, "TestDevice");
            LiveSubscription[]      liveSubscriptions = null;
            ContentSubscription[]   contentSubscriptions = null;
            ulong                   subscriptionID;
            uint                    hr;


            // Enumerate current subscriptions and clean them up
            hr = alertsMgr.EnumerateLiveSubscriptions(C_WEBID, C_WEBID, out liveSubscriptions);
            Assert.IsTrue(HResult.Succeeded(hr));

            if (null != liveSubscriptions)
            {
                foreach(LiveSubscription ls in liveSubscriptions)
                {
                    hr = alertsMgr.DeleteLiveSubscription(C_WEBID, ls.subscriptionID);
                    Assert.IsTrue(hr == HResult.S_OK);
                }
            }

            hr = alertsMgr.EnumerateContentSubscriptions(C_WEBID, C_WEBID, out contentSubscriptions);
            Assert.IsTrue(HResult.Succeeded(hr));

            if (null != contentSubscriptions)
            {
                foreach(ContentSubscription cs in contentSubscriptions)
                {
                    hr = alertsMgr.DeleteContentSubscription(C_WEBID, cs.subscriptionID);
                    Assert.IsTrue(hr == HResult.S_OK);
                }
            }


            // Cleanup previous subscriber entry if any
            alertsMgr.DeleteSubscriber(C_WEBID, 0);


            // Create a new subscriber entry
            alertsMgr.AddSubscriber(C_WEBID, 0);


            // Add new subscriptions
            hr = alertsMgr.AddLiveSubscription(C_WEBID, "en-US", 1 /* type */, 0 /* XUID */, "gamertag", out subscriptionID);
            Assert.IsTrue(hr == HResult.S_OK);
            hr = alertsMgr.AddLiveSubscription(C_WEBID, "en-US", 256 /* type */, 0 /* XUID */, "gamertag", out subscriptionID);
            Assert.IsTrue(hr == HResult.S_OK);

            hr = alertsMgr.AddContentSubscription(C_WEBID, "en-US", 1 /* type */, out subscriptionID);
            Assert.IsTrue(hr == HResult.S_OK);
            hr = alertsMgr.AddContentSubscription(C_WEBID, "en-US", 2 /* type */, out subscriptionID);
            Assert.IsTrue(hr == HResult.S_OK);


            // Update Titles
            hr = alertsMgr.AddTitle(1 /* titleID */, "Alerts Test Title", "en-US");
            Assert.IsTrue(hr == HResult.S_OK);
            hr = alertsMgr.AddTitle(2 /* titleID */, "Alerts Test Title #2", "en-US");
            Assert.IsTrue(hr == HResult.S_OK);


            // Source Events
#if false
// commented out because this test does not currently compile
            hr = alertsMgr.AddLiveEvent(1 /* titleID */, 256 /* type */, C_WEBID, "Sender");
            Assert.IsTrue(hr == HResult.S_OK);
#endif

            hr = alertsMgr.AddContentEvent(1 /* type */, "en-US", "Your mother dresses you funny", DateTime.UtcNow);
            Assert.IsTrue(hr == HResult.S_OK);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CAlternateTitleIdsTest.cs ===
using Microsoft.Webstore.WstClient;
using NUnit.Framework;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CAlternateTitleIdsTest
    {
        private const uint uiTestTitle     = 0xFFEDDA00;
        private const uint uiTestTitleAlt1 = 0xFFEDDA01;
        private const uint uiTestTitleAlt2 = 0xFFEDDA02;
        private const uint uiTestTitleAlt3 = 0xFFEDDA03;
        private const uint uiTestTitleAlt4 = 0xFFEDDA04;

        private static bool ArrayCompare(uint [] a1, uint [] a2)
        {
            if(a1 == null && a2 == null) return true;
            if(a1 == null || a2 == null) return false;
            if(a1.Length != a2.Length) return false;

            for(int i = 0; i < a1.Length; ++i)
            {
                if(a1[i] != a2[i]) return false;
            }

            return true;
        }

        [TestFixtureSetUp]
        public void TestFixtureSetUp()
        {
        }

        [Test]
        [ExpectedException(typeof(System.ArgumentNullException))]
        public void NullArrayTest()
        {
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), null, null, false);
        }

        [Test]
        [ExpectedException(typeof(System.ArgumentException))]
        public void BadArgTests1()
        {
            uint [] a = new uint[0];

            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), a, null, false);            
        }

        [Test]
        [ExpectedException(typeof(System.ArgumentException))]
        public void BadArgTests2()
        {
            uint [] a = new uint[1] { (uint)uiTestTitleAlt1 };

            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), a, null, false);            
        }

        [Test]
        [ExpectedException(typeof(System.ArgumentException))]
        public void BadArgTests3()
        {
            uint [] a = new uint[5] { uiTestTitleAlt1, uiTestTitleAlt1, uiTestTitleAlt1, uiTestTitleAlt1, uiTestTitleAlt1 };

            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), a, null, false);            
        }

        [Test]
        public void ReportOnlyTest()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds1 = new uint[4] { uiTestTitleAlt1, uiTestTitleAlt2, 0, 0 };
            uint [] aAltIds2 = new uint[4] { uiTestTitleAlt3, uiTestTitleAlt4, 0, 0 };

            //
            //  First set the alternate title ids to a known state
            //

            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds1, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds1[0] + ", " + aAltIds1[1] + ", " + aAltIds1[2] + ", " + aAltIds1[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds1, aAltIdsRetrieved));

            //
            //  Now do a report only set and verify that they didn't change
            //

            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds2, log, true);

            aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds2[0] + ", " + aAltIds2[1] + ", " + aAltIds2[2] + ", " + aAltIds2[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds1, aAltIdsRetrieved));
        }
         
        [Test]
        public void SetAltIds0()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, 0, 0, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds1()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, 0, 0, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds2()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, uiTestTitleAlt2, 0, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds3()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, uiTestTitleAlt2, 0, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds4()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, 0, uiTestTitleAlt3, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds5()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, 0, uiTestTitleAlt3, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds6()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, uiTestTitleAlt2, uiTestTitleAlt3, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds7()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, uiTestTitleAlt2, uiTestTitleAlt3, 0 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds8()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, 0, 0, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds9()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, 0, 0, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds10()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, uiTestTitleAlt2, 0, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds11()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, uiTestTitleAlt2, 0, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds12()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, 0, uiTestTitleAlt3, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds13()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, 0, uiTestTitleAlt3, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds14()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { 0, uiTestTitleAlt2, uiTestTitleAlt3, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            Console.WriteLine("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }

        [Test]
        public void SetAltIds15()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            uint [] aAltIds = new uint[4] { uiTestTitleAlt1, uiTestTitleAlt2, uiTestTitleAlt3, uiTestTitleAlt4 };
            CAlternateTitleIds.SetAlternateTitleIds(new CTitleId(uiTestTitle), aAltIds, log, false);

            uint [] aAltIdsRetrieved = CAlternateTitleIds.GetAlternateTitleIds(new CTitleId(uiTestTitle), log);

            log.FullTrace("Set = { " 
                + aAltIds[0] + ", " + aAltIds[1] + ", " + aAltIds[2] + ", " + aAltIds[3] 
                + " }, Received = " 
                + aAltIdsRetrieved[0] + ", " + aAltIdsRetrieved[1] + ", " + aAltIdsRetrieved[2] + ", " + aAltIdsRetrieved[3]
                + " }"
                );

            Assert.IsTrue(ArrayCompare(aAltIds, aAltIdsRetrieved));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CLogTest.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CLogTest
    {
        [Test]
        public void SqlCommandToStringTest()
        {
            // parameter validation
            bool bThrown = false;
            try
            {
                CLog.SqlCommandToString(null);
            }
            catch (ArgumentNullException e)
            {
                bThrown = true;
                Assert.AreEqual("sqlCommand", e.ParamName);
            }
            Assert.IsTrue(bThrown);

            // see what it does with a default constructed SqlCommand
            SqlCommand sqlCommand = new SqlCommand();
            string sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual("SqlCommand.CommandText is empty", sToString);

            // text commands should be returned verbatim
            sqlCommand.CommandType = CommandType.Text;
            string sCommand = "return me verbatim";
            sqlCommand.CommandText = sCommand;
            sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual(sCommand, sToString);

            // stored proceedure commands should have their parameters printed out
            // plus the command timeout at the end
            // try one with no parameters
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sCommand = "stored_proc_name";
            sqlCommand.CommandText = sCommand;
            sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual(sCommand+" CommandTimeout=30", sToString);

            // one parameter
            sqlCommand.Parameters.Add("@param1", SqlDbType.Int).Value = 1;
            sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual(sCommand + " @param1=1 CommandTimeout=30", sToString);

            // two parameters
            sqlCommand.Parameters.Add("@param2", SqlDbType.VarChar).Value = "string param 2";
            sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual(sCommand + " @param1=1 @param2=string param 2 CommandTimeout=30", sToString);

            // can't test unsupported command type, because the sqlCommand class won't 
            // let me assign a TableDirect command type -- it doesn't suppport it.
            /*
            sqlCommand.CommandType = CommandType.TableDirect;
            sCommand = "command text";
            sqlCommand.CommandText = sCommand;
            sToString = CLog.SqlCommandToString(sqlCommand);
            Assert.AreEqual("Unknown SqlCommand.CommandType. SqlCommand.CommandText is: " + sCommand, sToString);
            */
        }

        [Test]
        public void CollectionToStringTest()
        {
            string[] rgStr = new string[3];
            rgStr[0] = "one";
            rgStr[1] = null;
            rgStr[2] = "three";

            Assert.AreEqual("{one,null,three}", CLog.CollectionToString(rgStr));
        }

        [Test]
        public void LogLevelTest()
        {
            // the default implementation of WriteLine writes to stdout if the
            // current log level is >= the requested log level
            CLog log = new CLog();

            log.Console("ok");
            log.LogFile("ERROR");
            log.DataMod("ERROR");
            log.DataMod2("ERROR");
            log.StackTrace("ERROR");
            log.FullTrace("ERROR");

            log.Level = CLog.LOGFILE;
            log.Console("ok");
            log.LogFile("ok");
            log.DataMod("ERROR");
            log.DataMod2("ERROR");
            log.StackTrace("ERROR");
            log.FullTrace("ERROR");

            log.Level = CLog.DATAMOD;
            log.Console("ok");
            log.LogFile("ok");
            log.DataMod("ok");
            log.DataMod2("ERROR");
            log.StackTrace("ERROR");
            log.FullTrace("ERROR");

            log.Level = CLog.DATAMOD2;
            log.Console("ok");
            log.LogFile("ok");
            log.DataMod("ok");
            log.DataMod2("ok");
            log.StackTrace("ERROR");
            log.FullTrace("ERROR");

            log.Level = CLog.STACKTRACE;
            log.Console("ok");
            log.LogFile("ok");
            log.DataMod("ok");
            log.DataMod2("ok");
            log.StackTrace("ok");
            log.FullTrace("ERROR");

            log.Level = CLog.FULLTRACE;
            log.Console("ok");
            log.LogFile("ok");
            log.DataMod("ok");
            log.DataMod2("ok");
            log.StackTrace("ok");
            log.FullTrace("ok");

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CNPDBSyncTest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.IO;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CNPDBSyncTest
    {
        private static readonly CTitleId c_tid1 = new CTitleId(0xffff4006);

        [SetUp]
        public void SetUp()
        {
            CreateNPDBOnLocalhost();
            CleanupRepository();
        }
        
        private void CreateNPDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBSyncTest.CreateNPDBOnLocalhost starting");
            CCreateNPDB.CreateNPDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBSyncTest.CreateNPDBOnLocalhost complete");
        }

        private void CleanupRepository()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBSyncTest.CleanupRepository starting");
            CRepository repository = new CRepository(null, null, log);
            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBSyncTest.CleanupRepository complete");
        }

        [Test]
        public void NPDBSyncTest()
        {
            CLog log = new CLog();
            log.Level = CLog.CONSOLE;

            CRepository repository = new CRepository(null, null, log);
            repository.TitleCreate(c_tid1);

            // add some title description xmls to the repository
            CSourceDepot sd = new CSourceDepot(null, null, log);
            string sRoot = CPathUtil.AddPathTerminator(repository.RepositoryRoot);
            Directory.CreateDirectory(sRoot+@"ffff4006\message");
            File.Copy(@".\message\titles.english.xml", sRoot+@"ffff4006\message\titles.english.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.english.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.english.xml", "TitleDescTest");

            File.Copy(@".\message\titles.french.xml", sRoot+@"ffff4006\message\titles.french.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.french.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.french.xml", "TitleDescTest");

            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=npdb";

            CNPDB npdb = new CNPDB(sConnectionString, log);
            try
            {
                // try a sync
                CNPDBSync.NPDBSync(
                    c_tid1, 
                    repository, 
                    npdb,
                    false,
                    log);

                // there should now be three string in NPDB
                // 0 (default) english and french
                SortedList sl = npdb.StringGetList(c_tid1, 0);
                Assert.AreEqual(3, sl.Count);
                Assert.AreEqual("English Title Description", (string)sl[0]);
                Assert.AreEqual("English Title Description", (string)sl[(int)ELanguageName.english]);
                Assert.AreEqual("French Title Description", (string)sl[(int)ELanguageName.french]);

                // now remove the message files, and resync
                sd.Delete(sRoot+@"ffff4006\message\titles.english.xml");
                sd.Submit(sRoot+@"ffff4006\message\titles.english.xml", "TitleDescTest");
                sd.Delete(sRoot+@"ffff4006\message\titles.french.xml");
                sd.Submit(sRoot+@"ffff4006\message\titles.french.xml", "TitleDescTest");

                CNPDBSync.NPDBSync(
                    c_tid1, 
                    repository, 
                    npdb,
                    false,
                    log);

                // everything should be gone
                sl = npdb.StringGetList(c_tid1, 0);
                Assert.AreEqual(0, sl.Count);

            }
            finally
            {
                npdb.Close();
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CCreateWebDB.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.framework.test.dvt 
{
    public class CCreateWebDB
    {
        public static void CreateWebDB(CLog log)
        {
            log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB starting");

            log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Preparing test database");
            log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Opening SQL Connection");
            SqlConnection sqlConnection = new SqlConnection("Server=localhost;Trusted_Connection=sspi;Pooling=false");
            sqlConnection.Open();

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Dropping database webdb from localhost, if exists");
                sqlCommand.CommandText = 
                    "if (select count(name) from master..sysdatabases where name = 'webdb') = 1 " +
                    "begin " +
                    "drop database webdb " +
                    "end";
                sqlCommand.ExecuteNonQuery();

                log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Creating database webdb on localhost");
                sqlCommand.CommandText = "create database webdb";
                sqlCommand.ExecuteNonQuery();

                // reopen the sql connection, this time using webdb for the database
                log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Connecting to database webdb on localhost");
                sqlConnection.Close();
                sqlConnection.ConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=webdb";
                sqlConnection.Open();

                // create the ClientLib account
                log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: "
                    + "Creating ClientLib account");
                sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText 
                    = "USE webdb "
                    + "EXEC sp_addrole 'ClientLib' "
                    + "USE master "
                    + "if not exists(select uid from sysusers where name = 'ClientLib') "
                    + "exec sp_addrole 'ClientLib'";
                sqlCommand.ExecuteNonQuery();

                string sSqlFilePath = Directory.GetCurrentDirectory() + @"\WebServicesTest\WebDBSetup";
                ArrayList alSqlCommandFiles = new ArrayList();
                alSqlCommandFiles.Add("t_title_info.sql");
                alSqlCommandFiles.Add("t_title_name_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_name_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_raw_attribute_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_formatted_attribute_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_formatted_attribute_name_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_aggregate_attribute_info.sql");
                alSqlCommandFiles.Add("t_leaderboard_aggregate_attribute_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_title.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_title_list.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_title_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_title_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_title_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_title_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_title_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_title_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_lb_list.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_lb.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_lb_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_lb_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_lb_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_lb_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_lb_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_raw_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_raw_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_raw_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_attribute_list.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_attribute_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_get_attribute_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_insert_attribute_name_info.sql");
                alSqlCommandFiles.Add("p_webdb_tmr_delete_attribute_name_info.sql");

                foreach (string sSqlCommandFile in alSqlCommandFiles)
                {
                    // reset to using webdb, just in case another command set the database
                    // to something else (like the one above did!)
                    sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = "USE webdb";
                    sqlCommand.ExecuteNonQuery();

                    string sFileName = sSqlFilePath + @"\" + sSqlCommandFile;
                    log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: "
                        + "Executing sql command file '" + sFileName + "'");
                    CSqlUtils.RunSqlCommandScript(sFileName, sqlConnection, log);
                }

            }
            finally
            {
                log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB: Closing SQL Connections");
                if (sqlConnection != null && sqlConnection.State != ConnectionState.Closed)
                {
                    sqlConnection.Close();
                }
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CreateWebDB.CreateWebDB complete");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CCreateStatsDB.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.framework.test.dvt 
{
    public class CCreateStatsDB
    {
        public static void CreateStatsDB(CLog log)
        {
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB starting");

            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Preparing test database");
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: "
                + "NOTE: xsmt.dll is required for these tests. If you receive an exception that indicates xsmt.dll "
                + "could not be found, then you need to build this dll in the xstats project and copy it to "
                + "/Program Files/Microsoft SQL Server/MSSQL/Binn");
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Opening SQL Connection");
            SqlConnection sqlConnection = new SqlConnection("Server=localhost;Trusted_Connection=sspi;Pooling=false");
            sqlConnection.Open();

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Dropping database xstats from localhost, if exists");
                sqlCommand.CommandText = 
                    "if (select count(name) from master..sysdatabases where name = 'xstats') = 1 " +
                    "begin " +
                    "drop database xstats " +
                    "end";
                sqlCommand.ExecuteNonQuery();

                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Creating database xstats on localhost");
                sqlCommand.CommandText = "create database xstats";
                sqlCommand.ExecuteNonQuery();

                // reopen the sql connection, this time using xstats for the database
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Connecting to database xstats on localhost");
                sqlConnection.Close();
                sqlConnection.ConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
                sqlConnection.Open();

                // create the db_anonymous account
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: "
                    + "Creating db_anonymous account");
                sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText 
                    = "USE xstats "
                    + "EXEC sp_addrole 'db_anonymous' "
                    + "USE master "
                    + "if not exists(select uid from sysusers where name = 'db_anonymous') "
                    + "exec sp_addrole 'db_anonymous'";
                sqlCommand.ExecuteNonQuery();

                // To test the leaderboard and units stuff, through trial and error
                // only the scripts below actually need to be run.
                //
                // For this setup to work, xsmt.dll has to be built and copied to 
                // /Program Files/Microsoft SQL Server/MSSQL/Binn
                // this dll implements the extended stored proceedures used by xstats
                // I recommend taking an xsmt.dll from the official build

                string sSqlFilePath = Directory.GetCurrentDirectory() + @"\StatsV3Test\XStatsSetup";
                ArrayList alSqlCommandFiles = new ArrayList();
                alSqlCommandFiles.Add("stats_setup.sql");
                alSqlCommandFiles.Add("stats_tb.sql");
                alSqlCommandFiles.Add("stats_xsmt.sql");
                alSqlCommandFiles.Add("stats_procs.sql");
                //alSqlCommandFiles.Add("stats_init.sql");
                alSqlCommandFiles.Add("stats_leaderboards.sql");
                alSqlCommandFiles.Add("stats_config.sql");
                //alSqlCommandFiles.Add("stats_p_units.sql");

                foreach (string sSqlCommandFile in alSqlCommandFiles)
                {
                    // reset to using xstats, just in case another command set the database
                    // to something else (like the one above did!)
                    sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandText = "USE xstats";
                    sqlCommand.ExecuteNonQuery();

                    string sFileName = sSqlFilePath + @"\" + sSqlCommandFile;
                    log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: "
                        + "Executing sql command file '" + sFileName + "'");
                    CSqlUtils.RunSqlCommandScript(sFileName, sqlConnection, log);
                }

            }
            finally
            {
                log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB: Closing SQL Connections");
                if (sqlConnection != null && sqlConnection.State != ConnectionState.Closed)
                {
                    sqlConnection.Close();
                }
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.CreateStatsDB complete");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CStatsSyncTest.cs ===
using System;
using System.Collections;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CStatsSyncTest
    {
        private readonly CTitleId c_tid1 = new CTitleId(0xffff4006);
        private const string c_sSdPort = "localhost:1666";
        private const string c_sSdClient = "tmr_unittest";
        private const string c_sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
        private readonly CServer[] c_rgStatsFDServers = new CServer[0];
        private const int c_iSqlTimeoutSeconds = 0;
        private const int c_iProgressReportIntervalMilliseconds = 10;

        [SetUp]
        public void SetUp()
        {
            CreateStatsDBOnLocalhost();
            CleanupRepository();
        }
        
        private void CreateStatsDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsSyncTest.CreateStatsDBOnLocalhost starting");
            CCreateStatsDB.CreateStatsDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsSyncTest.CreateStatsDBOnLocalhost complete");
        }

        private void CleanupRepository()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsSyncTest.CleanupRepository starting");
            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);
            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsSyncTest.CleanupRepository complete");
        }

        [Test]
        public void StatsSyncTest()
        {
            CLog log = new CLog();
            log.Level = CLog.LOGFILE;
            bool bThrown = false;

            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);

            repository.TitleCreate(c_tid1);

            string[] rgsConnectionStrings = new string[1];
            rgsConnectionStrings[0] = c_sConnectionString;
            CStats stats = new CStats(
                rgsConnectionStrings,
                c_rgStatsFDServers,
                log);

            // this should be a no-op - the database is empty, the repository is empty
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            SortedList slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(0, slLBDatabaseMap.Count);

            // now add a leaderboard to the repository, then sync
            uint uiLBNum = 1;
            int iStatsDatabase = 0;
            ELBReset riLBResetInterval = ELBReset.ResetEveryYear;
            uint uiAttachmentCount = 1;
            uint uiMaxAttachmentSize = 2;
            uint uiDecayDays = 3;
            uint uiMaxRatingCount = 100;
            bool bArbitrationRequired = false;
            bool bIsTeam = true;
            CELOConfig eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uint uiEntriesPerCacheLine = 51;
            uint uiExpirationSeconds = 901;
            bool bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(1, slLBDatabaseMap.Count);

            // retrieve the leaderboard, make sure it is correct
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            Guid guid;
            long lMinQualifyingRating;
            DateTime dateTimeCreated;
            byte bReadOnly;
            byte bCopying;
            byte bDelete;
            stats.LBConfigGet(
                c_tid1,
                iStatsDatabase,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out uiMaxRatingCount,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig,
                out guid,
                out lMinQualifyingRating,
                out dateTimeCreated,
                out bReadOnly,
                out bCopying,
                out bDelete);
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(1, uiAttachmentCount);
            Assert.AreEqual(2, uiMaxAttachmentSize);
            Assert.AreEqual(3, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // try updating the leaderboard, changing uiMaxRatingCount
            // do not set bAllowDelete to true - which means the leaderboard should not be updated
            uiLBNum = 1;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 1;
            uiMaxAttachmentSize = 2;
            uiDecayDays = 3;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(1, slLBDatabaseMap.Count);

            // retrieve the leaderboard, make sure it has not changed
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            stats.LBConfigGet(
                c_tid1,
                iStatsDatabase,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out uiMaxRatingCount,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig,
                out guid,
                out lMinQualifyingRating,
                out dateTimeCreated,
                out bReadOnly,
                out bCopying,
                out bDelete);
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(1, uiAttachmentCount);
            Assert.AreEqual(2, uiMaxAttachmentSize);
            Assert.AreEqual(3, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // add four competition leaderboards to statsdb
            // these should be ingored by the sync below
            uint uiLBComp1 = 0x20000001;
            uint uiLBComp2 = 0x10000001;
            uint uiLBComp3 = 0x08000001;
            uint uiLBComp4 = 0x04000001;
            stats.LBConfigSet(
                c_tid1,
                iStatsDatabase,
                uiLBComp1, 
                ELBReset.ResetNever,
                0,
                0,
                0,
                0,
                true,
                false,
                null,
                false);
            stats.LBConfigSet(
                c_tid1,
                iStatsDatabase,
                uiLBComp2, 
                ELBReset.ResetNever,
                0,
                0,
                0,
                0,
                true,
                false,
                null,
                false);
            stats.LBConfigSet(
                c_tid1,
                iStatsDatabase,
                uiLBComp3, 
                ELBReset.ResetNever,
                0,
                0,
                0,
                0,
                true,
                false,
                null,
                false);
            stats.LBConfigSet(
                c_tid1,
                iStatsDatabase,
                uiLBComp4, 
                ELBReset.ResetNever,
                0,
                0,
                0,
                0,
                true,
                false,
                null,
                false);

            // now do the same thing, but set bAllowDelete to true
            uiLBNum = 1;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 1;
            uiMaxAttachmentSize = 2;
            uiDecayDays = 3;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(1, slLBDatabaseMap.Count);

            // retrieve the leaderboard, make sure it changed this time
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            stats.LBConfigGet(
                c_tid1,
                iStatsDatabase,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out uiMaxRatingCount,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig,
                out guid,
                out lMinQualifyingRating,
                out dateTimeCreated,
                out bReadOnly,
                out bCopying,
                out bDelete);
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(1, uiAttachmentCount);
            Assert.AreEqual(2, uiMaxAttachmentSize);
            Assert.AreEqual(3, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // make sure that the four competition leaderboards have not been deleted
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, false);
            Assert.AreEqual(5, slLBDatabaseMap.Count);

            // now another leaderboard to the repository, then sync
            uiLBNum = 4;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 5;
            uiMaxRatingCount = 100;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(2, slLBDatabaseMap.Count);
            Assert.IsTrue(slLBDatabaseMap.ContainsKey((uint)1));
            Assert.IsTrue(slLBDatabaseMap.ContainsKey((uint)4));

            // retrieve the new leaderboard, make sure it is correct
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 1;
            uiMaxAttachmentSize = 2;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            stats.LBConfigGet(
                c_tid1,
                iStatsDatabase,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out uiMaxRatingCount,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig,
                out guid,
                out lMinQualifyingRating,
                out dateTimeCreated,
                out bReadOnly,
                out bCopying,
                out bDelete);
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(5, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(null, eloConfig);
            Assert.IsTrue(bArbitrationRequired);
            Assert.IsFalse(bIsTeam);

            // now add leaderboard id 0 to the repository, then sync
            // this id is not allowed, and sync should throw
            uiLBNum = 0;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 5;
            uiMaxRatingCount = 100;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            bThrown = false;
            try
            {
                CStatsSync.StatsSync(
                    c_tid1, 
                    repository, 
                    stats,
                    30 * 1000,
                    c_iSqlTimeoutSeconds,
                    c_iProgressReportIntervalMilliseconds,
                    true,
                    false,
                    log);
            }
            catch (CStatsSyncException e)
            {
                Assert.IsFalse(e.Message.IndexOf("is smaller than the minimum allowed value of 1") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // remove the invalid leaderboard from the repository
            repository.TitleLBDelete(
                c_tid1,
                0);

            // now add leaderboard id 65536 to the repository, then sync
            // this id is not allowed, and sync should throw
            uiLBNum = 65536;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 5;
            uiMaxRatingCount = 100;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            bThrown = false;
            try
            {
                CStatsSync.StatsSync(
                    c_tid1, 
                    repository, 
                    stats,
                    30 * 1000,
                    c_iSqlTimeoutSeconds,
                    c_iProgressReportIntervalMilliseconds,
                    true,
                    false,
                    log);
            }
            catch (CStatsSyncException e)
            {
                Assert.IsFalse(e.Message.IndexOf("is larger than the maximum allowed value of") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // remove the invalid leaderboard from the repository
            repository.TitleLBDelete(
                c_tid1,
                65536);

            // remove the first leaderboard from the repository, and sync
            // without the allow delete flag
            uiLBNum = 1;
            repository.TitleLBDelete(
                c_tid1,
                uiLBNum);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(2, slLBDatabaseMap.Count);
            Assert.IsTrue(slLBDatabaseMap.ContainsKey((uint)1));
            Assert.IsTrue(slLBDatabaseMap.ContainsKey((uint)4));

            // now sync with the allow delete flag
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slLBDatabaseMap = stats.LBGetDatabaseMap(c_tid1, true);
            Assert.AreEqual(1, slLBDatabaseMap.Count);
            Assert.IsTrue(slLBDatabaseMap.ContainsKey((uint)4));

            // add a unit leaderboard to the repository, then sync
            // this should complain that there's no unit config for the title
            uiLBNum = 6;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = false;
            repository.TitleUnitSet(
                c_tid1,
                uiLBNum,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            // make sure there's no unit config for this title
            SortedList slUnitTitleDBMap = stats.UnitTitleGetDatabaseMap();
            Assert.AreEqual(0, slUnitTitleDBMap.Count);
            // and make sure there no unit leaderboards
            SortedList slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(0, slUnitDatabaseMap.Count);

            // set a unit config in the repository, then sync, 
            // this should create the unit leaderboard
            int iUnitDatabase = 0;
            double dDecayFactor = 60.0;
            uint uiMaxAvailUnits = 90;
            uint uiSizeUnitCache = 91;
            double dDecayFactorExpected = -Math.Log(2) / dDecayFactor;
            repository.TitleUnitConfigSet(
                c_tid1,
                iUnitDatabase,
                dDecayFactor,
                uiMaxAvailUnits,
                uiSizeUnitCache);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            // check the unit config for this title
            slUnitTitleDBMap = stats.UnitTitleGetDatabaseMap();
            Assert.AreEqual(1, slUnitTitleDBMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitTitleDBMap[c_tid1.uiTitleId])[0]);
            stats.UnitTitleConfigGet(
                c_tid1,
                out iUnitDatabase,
                out dDecayFactor,
                out uiMaxAvailUnits,
                out uiSizeUnitCache);
            Assert.AreEqual(0, iUnitDatabase);
            Assert.AreEqual(dDecayFactorExpected, dDecayFactor);
            Assert.AreEqual(90, uiMaxAvailUnits);
            Assert.AreEqual(91, uiSizeUnitCache);
            // check the unit leaderboard definition
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slUnitDatabaseMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[6u])[0]);
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                6, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());

            // add unit leaderboard 0 to the repository and sync - this 
            // should throw because 0 is not valid
            repository.TitleUnitSet(
                c_tid1,
                0,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            bThrown = false;
            try
            {
                CStatsSync.StatsSync(
                    c_tid1, 
                    repository, 
                    stats,
                    30 * 1000,
                    c_iSqlTimeoutSeconds,
                    c_iProgressReportIntervalMilliseconds,
                    false,
                    false,
                    log);
            }
            catch (CStatsSyncException e)
            {
                Assert.IsFalse(e.Message.IndexOf("is smaller than the minimum allowed value of 1") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // remove the invalid unit leaderboard
            repository.TitleUnitDelete(
                c_tid1,
                0);

            // add unit leaderboard 65536 to the repository and sync - this 
            // should throw because 65536 is not valid
            repository.TitleUnitSet(
                c_tid1,
                UInt16.MaxValue+1,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            bThrown = false;
            try
            {
                CStatsSync.StatsSync(
                    c_tid1, 
                    repository, 
                    stats,
                    30 * 1000,
                    c_iSqlTimeoutSeconds,
                    c_iProgressReportIntervalMilliseconds,
                    false,
                    false,
                    log);
            }
            catch (CStatsSyncException e)
            {
                Assert.IsFalse(e.Message.IndexOf("is larger than the maximum allowed value of") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // remove the invalid unit leaderboard
            repository.TitleUnitDelete(
                c_tid1,
                UInt16.MaxValue+1);

            // add another unit leaderboard to the repository, then sync
            uiLBNum = 7;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            repository.TitleUnitSet(
                c_tid1,
                uiLBNum,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slUnitDatabaseMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[6u])[0]);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[7u])[0]);
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                6, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                7, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);

            // now remove a unit leaderboard from the repository and sync
            // without specifying allow delete. the unit leaderboard
            // shouldn't be deleted.
            uiLBNum = 7;
            repository.TitleUnitDelete(
                c_tid1,
                uiLBNum);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slUnitDatabaseMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[6u])[0]);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[7u])[0]);
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                6, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                7, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);

            // now sync with allow delete, and confirm that
            // the unit leaderboard is gone
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slUnitDatabaseMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[6u])[0]);
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                6, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());

            // now delete the last unit leaderboard, this should completely
            // remove units from the server, even though we've left the unit
            // config in the repository, but only if allow delete is specified

            // first without allow delete
            uiLBNum = 6;
            repository.TitleUnitDelete(
                c_tid1,
                uiLBNum);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slUnitDatabaseMap.Count);
            Assert.AreEqual(true, ((bool[])slUnitDatabaseMap[6u])[0]);
            stats.UnitLBConfigGet(
                c_tid1,
                iUnitDatabase,
                6, 
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());

            // now with allow delete
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            slUnitDatabaseMap = stats.UnitLBGetDatabaseMap(c_tid1);
            Assert.AreEqual(0, slUnitDatabaseMap.Count);
            slUnitTitleDBMap = stats.UnitTitleGetDatabaseMap();
            Assert.AreEqual(0, slUnitTitleDBMap.Count);

            // comp template tests here

            // comps are complicated...

            // add a template to the repository and sync, this should work
            uiLBNum = 4;
            riLBResetInterval = ELBReset.ResetEveryYear;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 5;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);

            // there should be one competition partition on database server 0
            SortedList slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // the competition template should be there on server 0
            SortedList slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[4u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(5, uiDecayDays);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsTrue(bArbitrationRequired);
            Assert.IsFalse(bIsTeam);

            // a 2nd sync should be a noop...
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);

            // there should be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // the competition template should be there on server 0
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[4u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                uiLBNum, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(5, uiDecayDays);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsTrue(bArbitrationRequired);
            Assert.IsFalse(bIsTeam);

            // add a 2nd template to the repository and sync, this should work
            uiLBNum = 8;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 6;
            uiMaxAttachmentSize = 7;
            uiDecayDays = 2;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 56;
            uiExpirationSeconds = 907;
            bDontList = true;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);

            // there should still be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // both competition templates should be there on server 0
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[4u])[0]);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[8u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                4u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(5, uiDecayDays);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsTrue(bArbitrationRequired);
            Assert.IsFalse(bIsTeam);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                8u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(2, uiDecayDays);
            Assert.AreEqual(null, eloConfig);
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // now delete a template
            repository.TitleCompDelete(c_tid1, 4u);

            // sync should complain, but sync anyway. but with allow delete not specified,
            // both templates should still be there.
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);

            // there should still be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // both competition templates should be there on server 0
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[4u])[0]);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[8u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                4u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(5, uiDecayDays);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.IsTrue(bArbitrationRequired);
            Assert.IsFalse(bIsTeam);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                8u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(2, uiDecayDays);
            Assert.AreEqual(null, eloConfig);
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // now specify allow delete and the big nuke and resync should happen
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);

            // there should still be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // should now be only one competition template there on server 0
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[8u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                8u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(2, uiDecayDays);
            Assert.AreEqual(null, eloConfig);
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // change the definition of the 2nd template, this will cause a delete if allow delete specified
            uiLBNum = 8;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 6;
            uiMaxAttachmentSize = 8; // changed
            uiDecayDays = 2;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 56;
            uiExpirationSeconds = 907;
            bDontList = true;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // don't specify allow delete
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);

            // there should still be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // because we didn't allow delete, this template should not have changed
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[8u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                8u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(2, uiDecayDays);
            Assert.AreEqual(null, eloConfig);
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // now specify allow delete
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);

            // there should still be one competition partition on database server 0
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);

            // because we allowed delete, this template should have changed
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompTemplateDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompTemplateDBMap[8u])[0]);
            Assert.IsTrue(stats.CompTemplateConfigGet(
                c_tid1,
                0,
                8u, 
                out riLBResetInterval,
                out uiAttachmentCount,
                out uiMaxAttachmentSize,
                out uiDecayDays,
                out bArbitrationRequired,
                out bIsTeam,
                out eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(8, uiMaxAttachmentSize); // changed
            Assert.AreEqual(2, uiDecayDays);
            Assert.AreEqual(null, eloConfig);
            Assert.IsFalse(bArbitrationRequired);
            Assert.IsTrue(bIsTeam);

            // so far, there have been no competition partitions in the repository,
            // and the sync code as been defaulting to partition 0 on server 0.
            // add partitions 0 and 1 to the repository
            repository.TitleCompPartitionSet(c_tid1, 0u, 0);
            repository.TitleCompPartitionSet(c_tid1, 1u, 0);

            // sync should be happy to oblige
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);

            // there should now be 2 partitions
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[1u])[0]);

            // now delete one of the partitions, sync should get irritated
            repository.TitleCompPartitionDelete(c_tid1, 0u);
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                false,
                false,
                log);
            // there still be 2 partitions, because we didn't allow delete
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(2, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[0u])[0]);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[1u])[0]);

            // now allow delete
            CStatsSync.StatsSync(
                c_tid1, 
                repository, 
                stats,
                30 * 1000,
                c_iSqlTimeoutSeconds,
                c_iProgressReportIntervalMilliseconds,
                true,
                false,
                log);
            // there only be 1 partition left, because we allowed it to delete
            slCompPartitionDBMap = stats.CompPartitionGetDatabaseMap(c_tid1);
            Assert.AreEqual(1, slCompPartitionDBMap.Count);
            Assert.AreEqual(true, ((bool[])slCompPartitionDBMap[1u])[0]);

            // must close the object, or it holds the database open and
            // screws up other unit tests.
            stats.Close();
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CServerTest.cs ===
using System;
using System.Net;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CServerTest
    {
        [Test]
        public void ToStringTest()
        {
            CServer cs = new CServer();

            Assert.AreEqual("{null,null}", cs.ToString());

            cs.sServerName = "myServer";
            Assert.AreEqual("{myServer,null}", cs.ToString());

            cs.sServerName = null;
            cs.rgipAddresses = new IPAddress[0];
            Assert.AreEqual("{null,{}}", cs.ToString());

            cs.sServerName = null;
            cs.rgipAddresses = new IPAddress[1];
            Assert.AreEqual("{null,{null}}", cs.ToString());

            cs.rgipAddresses[0] = IPAddress.Parse("255.254.253.252");
            Assert.AreEqual("{null,{255.254.253.252}}", cs.ToString());

            cs.rgipAddresses = new IPAddress[2];
            Assert.AreEqual("{null,{null,null}}", cs.ToString());

            cs.rgipAddresses[0] = IPAddress.Parse("255.254.253.252");
            Assert.AreEqual("{null,{255.254.253.252,null}}", cs.ToString());

            cs.rgipAddresses[1] = IPAddress.Parse("0.1.2.3");
            Assert.AreEqual("{null,{255.254.253.252,0.1.2.3}}", cs.ToString());

            cs.sServerName = "myServer";
            Assert.AreEqual("{myServer,{255.254.253.252,0.1.2.3}}", cs.ToString());

            cs = new CServer("myServer", new IPAddress[0]);
            Assert.AreEqual("{myServer,{}}", cs.ToString());

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CSelectiveUpdateTest.cs ===
using Microsoft.Webstore.WstClient;
using NUnit.Framework;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using xonline.common.config;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt
{
    [TestFixture]
    public class CSelectiveUpdateTest
    {
        private string _serialnumValid;
        private string _serialnumInvalid;
        private int    _titleidValid = -65421;
        private int    _titleidInvalid = -65422;
        private Random _r = new Random();

        /// <summary>
        /// Generate a random serial number, with 9 in the 9th and 10th digits.
        /// </summary>
        /// <returns></returns>
        private string MakeSerialNumber()
        {
            StringBuilder serialnum = new StringBuilder();

            for(int iCurDigit = 0; iCurDigit < 12; ++iCurDigit)
            {
                if(iCurDigit != 8 && iCurDigit != 9)
                {
                    char c = (char)(_r.Next(10) + 30);

                    serialnum.Append(c);
                }
                else
                    serialnum.Append('9');
            }

            return serialnum.ToString();
        }

        /// <summary>
        /// Uses the Dump command to determine if a given serial number
        /// exists in t_machines or not.
        /// </summary>
        /// <param name="serialnum"></param>
        /// <returns>
        /// true: serial number was found in t_machines
        /// false: serial number was not found in t_machines
        /// </returns>
        private bool SerialNumberExists(string serialnum)
        {
            try
            {
                CSelectiveUpdate.Dump(serialnum);
                return true;
            }
            catch(SerialNumNotExistException)
            {
                return false;
            }
        }

        /// <summary>
        /// Call p_puid_get_next_id to retrieve a new puid.
        /// </summary>
        /// <returns>New puid</returns>
        private long GetNewPuid()
        {
            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "p_puid_get_next_id";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = 0; //TODO: make configurable?
                    cmd.Parameters.Add("@i_req_block_size", SqlDbType.BigInt).Value = 1; //TODO: hardcoded

                    SqlParameter puidParam = cmd.CreateParameter();
                    puidParam.Direction = ParameterDirection.Output;
                    puidParam.DbType = DbType.Int64;
                    puidParam.ParameterName = "@bi_next_id";
                    cmd.Parameters.Add(puidParam);

                    cmd.ExecuteNonQuery();

                    if ((int) ret.Value == 0)
                        return (long) (cmd.Parameters["@bi_next_id"].Value);
                    else
                        throw new Exception("Puid generation failed with error code " + ((uint)cmd.Parameters[0].Value).ToString());
                }
            }
        }

        /// <summary>
        /// Generate a new puid and insert the specified serialnum using
        /// the new puid.
        /// </summary>
        /// <param name="serialnum"></param>
        private void InsertSerialNumber(string serialnum)
        {
            WstConnection conn = null;
            WstCommand cmd = null;

            try
            {
                long puid = GetNewPuid();

                conn = new WstConnection();
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_xmacs_insertmachine";
                cmd.WstCommandType = WstCommandType.WriteOnly;
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstHash.GetHash(puid, conn.LogicalPartitions); // All Partitions

                SqlParameter ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);

                cmd.Parameters.Add("@serialnum", SqlDbType.NVarChar).Value = serialnum;
                cmd.Parameters.Add("@machinepuid", SqlDbType.BigInt).Value = puid;
                cmd.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt).Value = cmd.Partition;

                cmd.ExecuteNonQuery();

                uint hr = (uint)cmd.Parameters[0].Value;
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        [TestFixtureSetUp]
        public void TestFixtureSetUp()
        {
            //
            //  Generate a random serial number and add it to t_machines.
            //  Also a generate another random serial number and make sure
            //  it isn't in t_machines.  This is used for the invalid serial
            //  number cases.
            //

            do { _serialnumValid   = MakeSerialNumber(); } while(SerialNumberExists(_serialnumValid));
            do { _serialnumInvalid = MakeSerialNumber(); } while(SerialNumberExists(_serialnumInvalid));

            //
            //  The following call will fetch a machine puid to use
            //  for the new serial numbers, and insert it into t_machines.
            //

            InsertSerialNumber(_serialnumValid);

        }

        /// <summary>
        /// Valid serial number, valid title id
        /// </summary>
        [Test]
        public void SetIDTest_VV()
        {
            int iTitleIDOriginal = CSelectiveUpdate.Dump(_serialnumValid);
            CSelectiveUpdate.SetID(_serialnumValid, _titleidValid);
            Assert.AreEqual(CSelectiveUpdate.Dump(_serialnumValid), _titleidValid);
            CSelectiveUpdate.SetID(_serialnumValid, iTitleIDOriginal);
            Assert.AreEqual(CSelectiveUpdate.Dump(_serialnumValid), iTitleIDOriginal);
        }

        /// <summary>
        /// Valid serial number, invalid title id
        /// </summary>
        [Test]
        public void SetIDTest_VI()
        {
            int iTitleIDOriginal = CSelectiveUpdate.Dump(_serialnumValid);
            CSelectiveUpdate.SetID(_serialnumValid, _titleidInvalid);
            Assert.AreEqual(CSelectiveUpdate.Dump(_serialnumValid), _titleidInvalid);
            CSelectiveUpdate.SetID(_serialnumValid, iTitleIDOriginal);
            Assert.AreEqual(CSelectiveUpdate.Dump(_serialnumValid), iTitleIDOriginal);
        }

        /// <summary>
        /// Invalid serial number, valid title id
        /// </summary>
        [Test]
        [ExpectedException(typeof(SerialNumNotExistException))]
        public void SetIDTest_IV()
        {
            CSelectiveUpdate.SetID(_serialnumInvalid, _titleidValid);
        }

        /// <summary>
        /// Invalid serial number, invalid title id
        /// </summary>
        [Test]
        [ExpectedException(typeof(SerialNumNotExistException))]
        public void SetIDTest_II()
        {
            CSelectiveUpdate.SetID(_serialnumInvalid, _titleidInvalid);

        }

        /// <summary>
        /// Valid serial number
        /// </summary>
        [Test]
        public void DumpTest_V()
        {
            CSelectiveUpdate.Dump(_serialnumValid);
        }

        /// <summary>
        /// Invalid serial number
        /// </summary>
        [Test]
        [ExpectedException(typeof(SerialNumNotExistException))]
        public void DumpTest_I()
        {
            CSelectiveUpdate.Dump(_serialnumInvalid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CSqlUtils.cs ===
using System;
using System.IO;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    public class CSqlUtils
    {
        public static void RunSqlCommandScript(string sFileName, SqlConnection sqlConnection, CLog log)
        {
            FileStream fs = new FileStream(sFileName, FileMode.Open, FileAccess.Read);
            StreamReader sr = new StreamReader(fs);
            SqlCommand sqlCommand = sqlConnection.CreateCommand();

            // my cheezy parser. Read lines until you find a "go" and then run the commands.
            // this will fail if GO is not on a line by itself...
            StringBuilder sb = new StringBuilder();
            string sCommand = null;
            string sLine = sr.ReadLine();
            while (sLine != null)
            {
                if (sLine.Trim().ToLower() == "go")
                {
                    // we have a sql command batch, send it
                    sCommand = sb.ToString();
                    RunSqlCommand(sCommand, sqlConnection, log);
                    sb.Remove(0, sb.Length);
                }
                else
                {
                    sb.Append(sLine);
                    sb.Append("\n");
                }
                sLine = sr.ReadLine();
            }

            // the last command in a file may not have a "go". If there's anything in the 
            // string builder, then run it.
            sCommand = sb.ToString();
            if (sCommand.Trim() != "")
            {
                RunSqlCommand(sCommand, sqlConnection, log);
            }

            fs.Close();
        }

        public static void RunSqlCommand(string sCommand, SqlConnection sqlConnection, CLog log)
        {
            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.CommandText = sCommand;
            log.WriteLineV("Xbox.Tools.Framework.Test.CCreateStatsDB.RunSqlCommand: "
                + "Executing following Sql command on database '"
                + sqlConnection.Database
                + "' on server '"
                + sqlConnection.DataSource
                + "'");
            log.WriteLineV(sqlCommand.CommandText);
            sqlCommand.ExecuteNonQuery();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CTitleIdTest.cs ===
using System;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CTitleIdTest
    {
        [Test]
        public void CTitleId()
        {
            // construct a CTitleId  object using an integer - this construction cannot fail
            // then test the accessor methods.
            uint ui = 0xFEDCBA98;
            CTitleId tid = new CTitleId(ui);
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0xFEDCBA98", tid.sTitleIdHex);
            Assert.AreEqual("FEDCBA98", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("4275878552", tid.sTitleIdDecimal);
            Assert.AreEqual("0xFEDCBA98", tid.ToString());

            // These should all parse correctly
            tid = new CTitleId("  0xFEDCBA98  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0xFEDCBA98", tid.sTitleIdHex);
            Assert.AreEqual("FEDCBA98", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("4275878552", tid.sTitleIdDecimal);
            Assert.AreEqual("0xFEDCBA98", tid.ToString());
            tid = new CTitleId("  0XFEDCBA98  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0xFEDCBA98", tid.sTitleIdHex);
            Assert.AreEqual("FEDCBA98", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("4275878552", tid.sTitleIdDecimal);
            Assert.AreEqual("0xFEDCBA98", tid.ToString());
            tid = new CTitleId("  4275878552  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0xFEDCBA98", tid.sTitleIdHex);
            Assert.AreEqual("FEDCBA98", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("4275878552", tid.sTitleIdDecimal);
            Assert.AreEqual("0xFEDCBA98", tid.ToString());

            // check that leading zeros are (or are not) provided
            // as expected
            ui = 1;
            tid = new CTitleId("  0x1  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0x00000001", tid.sTitleIdHex);
            Assert.AreEqual("00000001", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("1", tid.sTitleIdDecimal);
            Assert.AreEqual("0x00000001", tid.ToString());
            tid = new CTitleId("  0X1  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0x00000001", tid.sTitleIdHex);
            Assert.AreEqual("00000001", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("1", tid.sTitleIdDecimal);
            Assert.AreEqual("0x00000001", tid.ToString());
            tid = new CTitleId("  1  ");
            Assert.AreEqual(ui, tid.uiTitleId);
            Assert.AreEqual("0x00000001", tid.sTitleIdHex);
            Assert.AreEqual("00000001", tid.sTitleIdHexNoPrefix);
            Assert.AreEqual("1", tid.sTitleIdDecimal);
            Assert.AreEqual("0x00000001", tid.ToString());

            // This should cause ArgumentNullException to be thrown
            bool fThrown;
            fThrown = false;
            try { tid = new CTitleId(null); } catch (ArgumentNullException) { fThrown = true; }
            Assert.IsTrue(fThrown);

            // These should cause FormatException to be thrown
            fThrown = false;
            try { tid = new CTitleId("  +1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  $1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  1.1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  1e1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  1,1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  1+  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  x1  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  junk  "); } catch (FormatException) { fThrown = true; }
            Assert.IsTrue(fThrown);

            // These should cause OverflowException to be thrown
            fThrown = false;
            try { tid = new CTitleId("  0x1FFFFFFFF  "); } catch (OverflowException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  0X1FFFFFFFF  "); } catch (OverflowException) { fThrown = true; }
            Assert.IsTrue(fThrown);
            fThrown = false;
            try { tid = new CTitleId("  4294967296  "); } catch (OverflowException) { fThrown = true; }
            Assert.IsTrue(fThrown);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CNPDBTest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CNPDBTest
    {
        [SetUp]
        public void CreateNPDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBTestLocalhost.CreateNPDBOnLocalhost starting");
            CCreateNPDB.CreateNPDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBTestLocalhost.CreateNPDBOnLocalhost complete");
        }

        [Test]
        public void ConstructorTest()
        {
            CLog log = new CLog();
            CTitleId tid = new CTitleId(0xffff4006);
            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=npdb";
            CServer[] rgWebCacheServers = new CServer[0];

            CNPDB npdb = null;

            // parameter validation tests

            // passing null sConnectionString should throw ArgumentNullException
            bool bThrown = false;
            try
            {
                npdb = new CNPDB(null, log);
            }
            catch (ArgumentNullException e)
            {
                bThrown = true;
                Assert.AreEqual("sNPDBConnectionString", e.ParamName);
            }
            Assert.IsTrue(bThrown);

            // call with invalid connection string should throw a CNPDB exception
            // because it can't connect to the database
            bThrown = false;
            try
            {
                npdb = new CNPDB("invalid connection string", log);
            }
            catch (CNPDBException NPDBException)
            {
                Assert.IsFalse(NPDBException.Message.IndexOf("Opening a connection") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // this call should work, check the log output
            npdb = new CNPDB(sConnectionString, log);

            // have to call Close
            npdb.Close();

            // calling Close twice should be a noop
            npdb.Close();

            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBTest.ConstructorTest: "
                + "calling constructor with null log - should be no log output");
            npdb = new CNPDB(sConnectionString, null);
            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBTest.ConstructorTest: "
                + "call with null log complete");
            npdb.Close();

            log.WriteLineV("Xbox.Tools.Framework.Test.CNPDBTest.ConstructorTest complete");
        }

        [Test]
        public void StringTest()
        {
            CLog log = new CLog();
            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=npdb";

            CNPDB npdb = new CNPDB(sConnectionString, log);
            try
            {
                CTitleId tid = new CTitleId(0xffff4006);
                SortedList sl;

                // should be no strings yet for our test title
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(0, sl.Count);

                // now insert a default string (lang id 0), and confirm we can get it back
                npdb.StringSet(tid, 0, 0, DateTime.MaxValue, "default", false);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(1, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);

                // insert another one, and confirm
                npdb.StringSet(tid, 0, (int)ELanguageName.italian, DateTime.MaxValue, "italian", false);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(2, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);
                Assert.AreEqual("italian", (string)sl[(int)ELanguageName.italian]);

                // update a string
                npdb.StringSet(tid, 0, (int)ELanguageName.italian, DateTime.MaxValue, "italian2", false);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(2, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);
                Assert.AreEqual("italian2", (string)sl[(int)ELanguageName.italian]);

                // make sure that bReportOnly works for Set
                npdb.StringSet(tid, 0, (int)ELanguageName.italian, DateTime.MaxValue, "italian3", true);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(2, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);
                Assert.AreEqual("italian2", (string)sl[(int)ELanguageName.italian]);

                // delete a string
                npdb.StringDelete(tid, 0, (int)ELanguageName.italian, false);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(1, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);

                // make sure report only works for delete...
                npdb.StringDelete(tid, 0, 0, true);
                sl = npdb.StringGetList(tid, 0);
                Assert.AreEqual(1, sl.Count);
                Assert.AreEqual("default", (string)sl[0]);
            }
            finally
            {
                npdb.Close();
            }

            return;
        }

        //connect to database
        //delete all rows from database
        //create outage object
        //add outage to database
        //update outage
        //delete Outage

        [Test]
        public void OutageTest()
        {

            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.UnitTest starting");


            string ConnString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=NPDB";
            bool bThrown = false;
            //bool bFound = false;

            try
            {
                // make sure we start completely clean
                CNPDB NPDB = new CNPDB(ConnString,null);
                CNPDB.Outage [] Outages = NPDB.CompOutageDowntimesGet();
                for (uint x = 0; x < Outages.Length; x++)
                {
                    log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                        + "Deleting Outage Id:" + Outages[x].Id);
                    NPDB.CompOutageDowntimeDelete( Outages[x].Start,Outages[x].End, false);
                }

                Outages = NPDB.CompOutageDowntimesGet();
                Assert.AreEqual(0, Outages.Length);

                //create an Outage array
                DateTime Time1 = DateTime.Parse("12/1/2010");
                DateTime Time2 = DateTime.Parse("12/2/2010");
                DateTime Time3 = DateTime.Parse("12/3/2010");
                DateTime Time4 = DateTime.Parse("12/4/2010");
                CNPDB.Outage testOutage1 = new CNPDB.Outage(Time1,Time2);
                CNPDB.Outage testOutage2 = new CNPDB.Outage(Time2,Time3);
                CNPDB.Outage testOutage3 = new CNPDB.Outage(Time3,Time4);

                // test set outages
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Testing outage set");
                NPDB.CompOutageDowntimeSet(testOutage1.Start,testOutage1.End,false);
                NPDB.CompOutageDowntimeSet(testOutage2.Start,testOutage2.End,false);
                NPDB.CompOutageDowntimeSet(testOutage3.Start,testOutage3.End,false);

                Outages = NPDB.CompOutageDowntimesGet();
                Assert.AreEqual(3, Outages.Length);

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Testing outage get");
                Outages = NPDB.CompOutageDowntimesGet();
                Assert.AreEqual(3, Outages.Length);

                for (uint x = 0; x < Outages.Length; x++)
                {
                    Assert.AreEqual(Outages[x].Start,testOutage1.Start);
                    Assert.AreEqual(Outages[x].End,testOutage1.End);
                }

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Testing outage delete");
                NPDB.CompOutageDowntimeDelete(testOutage1.Start,testOutage1.End,false);
                NPDB.CompOutageDowntimeDelete(testOutage2.Start,testOutage2.End,false);
                NPDB.CompOutageDowntimeDelete(testOutage3.Start,testOutage3.End,false);
                Assert.AreEqual(0, Outages.Length);

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Start Time cannot precede End Time.");
                bThrown = false;
                try
                {
                    DateTime Time5 = DateTime.Parse("12/5/2010");
                    DateTime Time6 = DateTime.Parse("12/6/2010");
                    NPDB.CompOutageDowntimeSet(Time6,Time5,false);
                }
                catch
                {
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Start Time and End Time must be 11 minutes apart.");
                bThrown = false;
                try
                {
                    DateTime Time7 = DateTime.Parse("12/5/2010 13:01");
                    DateTime Time8 = DateTime.Parse("12/5/2010 13:02");
                    NPDB.CompOutageDowntimeSet(Time7,Time8,false);
                }
                catch
                {
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Start Time must be at least 11 minutes after current system time.");
                bThrown = false;
                try
                {
                    DateTime Time9 = (DateTime.UtcNow).AddMinutes(1);
                    DateTime Time10 = DateTime.Parse("12/5/2010 13:02");
                    NPDB.CompOutageDowntimeSet(Time9,Time10,false);
                }
                catch
                {
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;

                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.OutageTest: "
                    + "Start Time cannot precede current system time.");
                bThrown = false;
                try
                {
                    DateTime Time11 = DateTime.Parse("12/5/1900");
                    NPDB.CompOutageDowntimeSet(Time11,DateTime.UtcNow,false);
                }
                catch
                {
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;

            }
            finally
            {
                //cleanup
            }
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CWebDBSyncTest.cs ===
using System;
using System.Collections;
using System.IO;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CWebDBSyncTest
    {
        private readonly CTitleId c_tid1 = new CTitleId(0xffff4006);
        private const string c_sSdPort = "localhost:1666";
        private const string c_sSdClient = "tmr_unittest";
        private const string c_sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=webdb";
        private readonly CLocale c_locEnUS = new CLocale("en-US");
        private readonly CLocale c_locEnCA = new CLocale("en-CA");
        private const int c_iCompTemplateShift = 26;

        [SetUp]
        public void SetUp()
        {
            CreateWebDBOnLocalhost();
            CleanupRepository();
        }
        
        private void CreateWebDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBSyncTest.CreateWebDBOnLocalhost starting");
            CCreateWebDB.CreateWebDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBSyncTest.CreateWebDBOnLocalhost complete");
        }

        private void CleanupRepository()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBSyncTest.CleanupRepository starting");
            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);
            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBSyncTest.CleanupRepository complete");
        }

        [Test]
        public void WebDBSyncTest()
        {
            CLog log = new CLog();

            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);

            repository.TitleCreate(c_tid1);

            // add a couple descriptions.
            // add some title description xmls to the repository
            CSourceDepot sd = new CSourceDepot(null, null, log);
            string sRoot = CPathUtil.AddPathTerminator(repository.RepositoryRoot);
            Directory.CreateDirectory(sRoot+@"ffff4006\message");
            File.Copy(@".\message\titles.english.xml", sRoot+@"ffff4006\message\titles.english.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.english.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.english.xml", "TitleDescTest");

            File.Copy(@".\message\titles.french.xml", sRoot+@"ffff4006\message\titles.french.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.french.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.french.xml", "TitleDescTest");

            string[] rgsConnectionStrings = new string[1];
            CWebDB webdb = new CWebDB(
                c_sConnectionString,
                log);

            // add a couple of each type of leaderboard to the repository, 
            // so we have something to attach web info to later
            uint uiLBNum = 1;
            int iStatsDatabase = 0;
            ELBReset riLBResetInterval = ELBReset.ResetEveryWeek;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 51;
            uint uiExpirationSeconds = 901;
            bool bDontList = false;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 2;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEveryMonth;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum,
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 3;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 53;
            uiExpirationSeconds = 903;
            bDontList = false;
            repository.TitleUnitSet(
                c_tid1,
                uiLBNum,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 4;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 54;
            uiExpirationSeconds = 904;
            bDontList = true;
            repository.TitleUnitSet(
                c_tid1,
                uiLBNum,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // Note: I should be able to make these id 1 and 2, but 
            // due to bug 35713 I can't.
            uiLBNum = 5;
            riLBResetInterval = ELBReset.ResetEvery2Months;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 55;
            uiExpirationSeconds = 905;
            bDontList = false;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 6;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEvery3Months;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 56;
            uiExpirationSeconds = 906;
            bDontList = true;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            bool bThrown;

            // param validation first
            bThrown = false;
            try
            {
                CWebDBSync.WebDBSync(
                    null, 
                    repository, 
                    webdb,
                    false,
                    log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CWebDBSync.WebDBSync(
                    c_tid1, 
                    null, 
                    webdb,
                    false,
                    log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("repository", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CWebDBSync.WebDBSync(
                    c_tid1, 
                    repository, 
                    null,
                    false,
                    log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("webdb", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CWebDBSync.WebDBSync(
                    c_tid1, 
                    repository, 
                    webdb,
                    false,
                    null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("log", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // not quite a no-op -title info will be added because
            // we have title descriptions.
            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            EESRBRating ESRBRating;
            CLocale locDefault;
            uint uiClusterId;
            Assert.IsTrue(webdb.TitleConfigGet(
                c_tid1,
                out ESRBRating,
                out locDefault,
                out uiClusterId));
            Assert.AreEqual(EESRBRating.Unspecified, ESRBRating);
            Assert.AreEqual("en-US", locDefault.ToString());
            Assert.AreEqual(0, uiClusterId);
            uint[] rgui = webdb.WebLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            // check for the title descriptions
            SortedList sl = webdb.TitleDescGetList(c_tid1);
            Assert.AreEqual(10, sl.Count);
            Assert.AreEqual("English Title Description", sl["en-AU"]);
            Assert.AreEqual("English Title Description", sl["en-CA"]);
            Assert.AreEqual("English Title Description", sl["en-IE"]);
            Assert.AreEqual("English Title Description", sl["en-GB"]);
            Assert.AreEqual("English Title Description", sl["en-SG"]);
            Assert.AreEqual("English Title Description", sl["en-US"]);
            Assert.AreEqual("French Title Description", sl["fr-BE"]);
            Assert.AreEqual("French Title Description", sl["fr-CA"]);
            Assert.AreEqual("French Title Description", sl["fr-CH"]);
            Assert.AreEqual("French Title Description", sl["fr-FR"]);

            // add a leaderboard description for each leaderboard, and make
            // sure that all of them got added, and they are the right 
            // leaderboard type, and all the other settings carried through

            // add a leaderboard description to the repository and sync again
            string sDesc;
            uiLBNum = 1;
            sDesc = "LB1 enUS description";
            repository.TitleLBDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 2;
            sDesc = "LB2 enUS description";
            repository.TitleLBDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 3;
            sDesc = "LB3 enUS description";
            repository.TitleUnitDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 4;
            sDesc = "LB4 enUS description";
            repository.TitleUnitDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 5;
            sDesc = "LB5 enUS description";
            repository.TitleCompDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 6;
            sDesc = "LB6 enUS description";
            repository.TitleCompDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            ELBReset resetInterval;
            EWebLBType webLBType;

            rgui = webdb.WebLBGetList(c_tid1);
            Assert.AreEqual(6, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(5 << c_iCompTemplateShift, rgui[4]);
            Assert.AreEqual(6 << c_iCompTemplateShift, rgui[5]);

            uiLBNum = 1;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetEveryWeek, resetInterval);
            Assert.AreEqual(51, uiEntriesPerCacheLine);
            Assert.AreEqual(901, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.Regular, webLBType);
            Assert.AreEqual(false, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB1 enUS description", sl[c_locEnUS.ToString()]);

            uiLBNum = 2;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetEveryMonth, resetInterval);
            Assert.AreEqual(52, uiEntriesPerCacheLine);
            Assert.AreEqual(902, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.RegularTeam, webLBType);
            Assert.AreEqual(true, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB2 enUS description", sl[c_locEnUS.ToString()]);

            uiLBNum = 3;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetNever, resetInterval);
            Assert.AreEqual(53, uiEntriesPerCacheLine);
            Assert.AreEqual(903, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.Unit, webLBType);
            Assert.AreEqual(false, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB3 enUS description", sl[c_locEnUS.ToString()]);

            uiLBNum = 4;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetNever, resetInterval);
            Assert.AreEqual(54, uiEntriesPerCacheLine);
            Assert.AreEqual(904, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.UnitTeam, webLBType);
            Assert.AreEqual(true, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB4 enUS description", sl[c_locEnUS.ToString()]);

            uiLBNum = 5 << c_iCompTemplateShift;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetEvery2Months, resetInterval);
            Assert.AreEqual(55, uiEntriesPerCacheLine);
            Assert.AreEqual(905, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.CompetitionTemplate, webLBType);
            Assert.AreEqual(false, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB5 enUS description", sl[c_locEnUS.ToString()]);

            uiLBNum = 6 << c_iCompTemplateShift;
            Assert.IsTrue(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            Assert.AreEqual(ELBReset.ResetEvery3Months, resetInterval);
            Assert.AreEqual(56, uiEntriesPerCacheLine);
            Assert.AreEqual(906, uiExpirationSeconds);
            Assert.AreEqual(EWebLBType.CompetitionTemplateTeam, webLBType);
            Assert.AreEqual(true, bDontList);
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB6 enUS description", sl[c_locEnUS.ToString()]);

            // now delete 3 of the descriptions.
            // 3 of the web leaderboards should disappear.
            uiLBNum = 1;
            repository.TitleLBDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 3;
            repository.TitleUnitDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 5;
            repository.TitleCompDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            rgui = webdb.WebLBGetList(c_tid1);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(2, rgui[0]);
            Assert.AreEqual(4, rgui[1]);
            Assert.AreEqual(6 << c_iCompTemplateShift, rgui[2]);

            // add a second leaderboard description to the remaining leaderboards
            // and sync again
            uiLBNum = 2;
            sDesc = "LB2 enCA description";
            repository.TitleLBDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            uiLBNum = 4;
            sDesc = "LB4 enCA description";
            repository.TitleUnitDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            uiLBNum = 6;
            sDesc = "LB6 enCA description";
            repository.TitleCompDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB2 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB2 enCA description", sl[c_locEnCA.ToString()]);
            uiLBNum = 4;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB4 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB4 enCA description", sl[c_locEnCA.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB6 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB6 enCA description", sl[c_locEnCA.ToString()]);

            // update a leaderboard description on each leaderboard and sync
            uiLBNum = 2;
            sDesc = "LB2 enCA description2";
            repository.TitleLBDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            uiLBNum = 4;
            sDesc = "LB4 enCA description2";
            repository.TitleUnitDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            uiLBNum = 6;
            sDesc = "LB6 enCA description2";
            repository.TitleCompDescSet(
                c_tid1,
                uiLBNum,
                c_locEnCA,
                sDesc);
            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB2 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB2 enCA description2", sl[c_locEnCA.ToString()]);
            uiLBNum = 4;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB4 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB4 enCA description2", sl[c_locEnCA.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB6 enUS description", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB6 enCA description2", sl[c_locEnCA.ToString()]);

            // remove the leaderboard description for the default locale
            // but leave the other one. This should make the leaderboard
            // disappear from webdb
            uiLBNum = 2;
            repository.TitleLBDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 4;
            repository.TitleUnitDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 6;
            repository.TitleCompDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            rgui = webdb.WebLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            uiLBNum = 2;
            Assert.IsFalse(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 4;
            Assert.IsFalse(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 6 << c_iCompTemplateShift;
            Assert.IsFalse(webdb.WebLBConfigGet(
                c_tid1,
                uiLBNum,
                out resetInterval,
                out uiEntriesPerCacheLine,
                out uiExpirationSeconds,
                out webLBType,
                out bDontList));
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // add back the leaderboard description for the default locale
            uiLBNum = 2;
            sDesc = "LB2 enUS description3";
            repository.TitleLBDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 4;
            sDesc = "LB4 enUS description3";
            repository.TitleUnitDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);
            uiLBNum = 6;
            sDesc = "LB6 enUS description3";
            repository.TitleCompDescSet(
                c_tid1,
                uiLBNum,
                c_locEnUS,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB2 enUS description3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB2 enCA description2", sl[c_locEnCA.ToString()]);

            uiLBNum = 4;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB4 enUS description3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB4 enCA description2", sl[c_locEnCA.ToString()]);

            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB6 enUS description3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB6 enCA description2", sl[c_locEnCA.ToString()]);

            // delete the non-default locale description
            uiLBNum = 2;
            repository.TitleLBDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);
            uiLBNum = 4;
            repository.TitleUnitDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);
            uiLBNum = 6;
            repository.TitleCompDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB2 enUS description3", sl[c_locEnUS.ToString()]);
            uiLBNum = 4;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB4 enUS description3", sl[c_locEnUS.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBDescGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB6 enUS description3", sl[c_locEnUS.ToString()]);

            // now add a leaderboard attribute
            uiLBNum = 2;
            uint uiId = 1;
            bool bIsPuid = true;
            repository.TitleLBAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 4;
            uiId = 2;
            bIsPuid = true;
            repository.TitleUnitAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 6;
            uiId = 3;
            bIsPuid = true;
            repository.TitleCompAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(true, sl[(uint)1]);
            uiLBNum = 4;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(true, sl[(uint)3]);

            // add another leaderboard attribute to the repository and sync
            uiLBNum = 2;
            uiId = 4;
            bIsPuid = false;
            repository.TitleLBAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 4;
            uiId = 5;
            bIsPuid = false;
            repository.TitleUnitAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 6;
            uiId = 6;
            bIsPuid = false;
            repository.TitleCompAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)1]);
            Assert.AreEqual(false, sl[(uint)4]);
            uiLBNum = 4;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)5]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(false, sl[(uint)6]);

            // update a leaderboard attribute in the repository and sync
            uiLBNum = 2;
            uiId = 1;
            bIsPuid = false;
            repository.TitleLBAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 4;
            uiId = 2;
            bIsPuid = false;
            repository.TitleUnitAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);
            uiLBNum = 6;
            uiId = 3;
            bIsPuid = false;
            repository.TitleCompAttrSet(
                c_tid1,
                uiLBNum,
                uiId,
                bIsPuid);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(false, sl[(uint)4]);
            uiLBNum = 4;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)5]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)3]);
            Assert.AreEqual(false, sl[(uint)6]);

            // delete a leaderboard attribute in the repository and sync
            uiLBNum = 2;
            uiId = 1;
            repository.TitleLBAttrDelete(
                c_tid1,
                uiLBNum,
                uiId);
            uiLBNum = 4;
            uiId = 2;
            repository.TitleUnitAttrDelete(
                c_tid1,
                uiLBNum,
                uiId);
            uiLBNum = 6;
            uiId = 3;
            repository.TitleCompAttrDelete(
                c_tid1,
                uiLBNum,
                uiId);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)4]);
            uiLBNum = 4;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)5]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sl = webdb.WebLBAttrGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)6]);

            // now add a leaderboard formatted value to the repository and sync
            // since we have not added a description for the default locale
            // nothing should be in webdb.
            string sName;
            EWebValueReturnType returnType;
            string sFormula;

            uiLBNum = 2;
            sName = "1";
            returnType = EWebValueReturnType.Team;
            sFormula = "attr[1]";
            repository.TitleLBValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 4;
            sName = "2";
            returnType = EWebValueReturnType.String;
            sFormula = "attr[2]";
            repository.TitleUnitValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 6;
            sName = "3";
            returnType = EWebValueReturnType.Days;
            sFormula = "attr[3]";
            repository.TitleCompValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            string[] rgs;
            uiLBNum = 2;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            uiLBNum = 4;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            uiLBNum = 6 << c_iCompTemplateShift;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // add a description for the default locale and sync
            // should see both the formatted value and the description for it
            uiLBNum = 2;
            sName = "1";
            sDesc = "LB2 enUS FV1 desc";
            repository.TitleLBValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);
            uiLBNum = 4;
            sName = "2";
            sDesc = "LB4 enUS FV2 desc";
            repository.TitleUnitValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);
            uiLBNum = 6;
            sName = "3";
            sDesc = "LB6 enUS FV3 desc";
            repository.TitleCompValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("1", rgs[0]);
            sName = "1";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Team, returnType);
            Assert.AreEqual("attr[1]", sFormula);
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB2 enUS FV1 desc", sl[c_locEnUS.ToString()]);
            uiLBNum = 4;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            sName = "2";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("attr[2]", sFormula);
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB4 enUS FV2 desc", sl[c_locEnUS.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("3", rgs[0]);
            sName = "3";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[3]", sFormula);
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB6 enUS FV3 desc", sl[c_locEnUS.ToString()]);

            // add another leaderboard formatted value, and a description for the
            // default locale to the repository and sync
            uiLBNum = 2;
            sName = "4";
            returnType = EWebValueReturnType.Hours;
            sFormula = "attr[4]";
            repository.TitleLBValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 2;
            sName = "4";
            sDesc = "LB2 enUS FV4 desc";
            repository.TitleLBValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);

            uiLBNum = 4;
            sName = "5";
            returnType = EWebValueReturnType.Minutes;
            sFormula = "attr[5]";
            repository.TitleUnitValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 4;
            sName = "5";
            sDesc = "LB4 enUS FV5 desc";
            repository.TitleUnitValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);

            uiLBNum = 6;
            sName = "6";
            returnType = EWebValueReturnType.Seconds;
            sFormula = "attr[6]";
            repository.TitleCompValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 6;
            sName = "6";
            sDesc = "LB6 enUS FV6 desc";
            repository.TitleCompValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("1", rgs[0]);
            Assert.AreEqual("4", rgs[1]);
            sName = "1";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Team, returnType);
            Assert.AreEqual("attr[1]", sFormula);
            sName = "4";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Hours, returnType);
            Assert.AreEqual("attr[4]", sFormula);

            uiLBNum = 4;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            sName = "2";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("attr[2]", sFormula);
            sName = "5";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Minutes, returnType);
            Assert.AreEqual("attr[5]", sFormula);

            uiLBNum = 6 << c_iCompTemplateShift;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("3", rgs[0]);
            Assert.AreEqual("6", rgs[1]);
            sName = "3";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[3]", sFormula);
            sName = "6";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Seconds, returnType);
            Assert.AreEqual("attr[6]", sFormula);

            // update a leaderboard formatted value in the repository and sync
            uiLBNum = 2;
            sName = "1";
            returnType = EWebValueReturnType.HundredMilliseconds;
            sFormula = "attr[1+1]";
            repository.TitleLBValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 4;
            sName = "2";
            returnType = EWebValueReturnType.TenMilliseconds;
            sFormula = "attr[2+1]";
            repository.TitleUnitValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);
            uiLBNum = 6;
            sName = "3";
            returnType = EWebValueReturnType.Milliseconds;
            sFormula = "attr[3+1]";
            repository.TitleCompValueSet(
                c_tid1,
                uiLBNum,
                sName,
                returnType,
                sFormula);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("1", rgs[0]);
            Assert.AreEqual("4", rgs[1]);
            sName = "1";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("attr[1+1]", sFormula);
            sName = "4";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Hours, returnType);
            Assert.AreEqual("attr[4]", sFormula);

            uiLBNum = 4;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            sName = "2";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.TenMilliseconds, returnType);
            Assert.AreEqual("attr[2+1]", sFormula);
            sName = "5";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Minutes, returnType);
            Assert.AreEqual("attr[5]", sFormula);

            uiLBNum = 6 << c_iCompTemplateShift;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("3", rgs[0]);
            Assert.AreEqual("6", rgs[1]);
            sName = "3";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Milliseconds, returnType);
            Assert.AreEqual("attr[3+1]", sFormula);
            sName = "6";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Seconds, returnType);
            Assert.AreEqual("attr[6]", sFormula);

            // delete a leaderboard formatted value in the repository and sync
            uiLBNum = 2;
            sName = "1";
            repository.TitleLBValueDelete(
                c_tid1,
                uiLBNum,
                sName);
            uiLBNum = 4;
            sName = "2";
            repository.TitleUnitValueDelete(
                c_tid1,
                uiLBNum,
                sName);
            uiLBNum = 6;
            sName = "3";
            repository.TitleCompValueDelete(
                c_tid1,
                uiLBNum,
                sName);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("4", rgs[0]);
            sName = "4";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Hours, returnType);
            Assert.AreEqual("attr[4]", sFormula);
            uiLBNum = 4;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("5", rgs[0]);
            sName = "5";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Minutes, returnType);
            Assert.AreEqual("attr[5]", sFormula);
            uiLBNum = 6 << c_iCompTemplateShift;
            rgs = webdb.WebLBValueGetList(
                c_tid1,
                uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("6", rgs[0]);
            sName = "6";
            Assert.IsTrue(webdb.WebLBValueGet(
                c_tid1,
                uiLBNum,
                sName,
                out returnType,
                out sFormula));
            Assert.AreEqual(EWebValueReturnType.Seconds, returnType);
            Assert.AreEqual("attr[6]", sFormula);

            // add a 2nd leaderboard formatted value description
            uiLBNum = 2;
            sName = "4";
            sDesc = "LB2 enCA FV4 desc";
            repository.TitleLBValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA,
                sDesc);
            uiLBNum = 4;
            sName = "5";
            sDesc = "LB4 enCA FV5 desc";
            repository.TitleUnitValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA,
                sDesc);
            uiLBNum = 6;
            sName = "6";
            sDesc = "LB6 enCA FV6 desc";
            repository.TitleCompValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sName = "4";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB2 enUS FV4 desc", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB2 enCA FV4 desc", sl[c_locEnCA.ToString()]);
            uiLBNum = 4;
            sName = "5";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB4 enUS FV5 desc", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB4 enCA FV5 desc", sl[c_locEnCA.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sName = "6";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB6 enUS FV6 desc", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB6 enCA FV6 desc", sl[c_locEnCA.ToString()]);

            // update a leaderboard formatted value description 
            uiLBNum = 2;
            sName = "4";
            sDesc = "LB2 enUS FV4 desc updated";
            repository.TitleLBValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);
            uiLBNum = 4;
            sName = "5";
            sDesc = "LB4 enUS FV5 desc updated";
            repository.TitleUnitValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);
            uiLBNum = 6;
            sName = "6";
            sDesc = "LB6 enUS FV6 desc updated";
            repository.TitleCompValueDescSet(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnUS,
                sDesc);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sName = "4";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB2 enUS FV4 desc updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB2 enCA FV4 desc", sl[c_locEnCA.ToString()]);
            uiLBNum = 4;
            sName = "5";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB4 enUS FV5 desc updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB4 enCA FV5 desc", sl[c_locEnCA.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sName = "6";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("LB6 enUS FV6 desc updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("LB6 enCA FV6 desc", sl[c_locEnCA.ToString()]);

            // remove a leaderboard formatted value description from the repository and sync again
            uiLBNum = 2;
            sName = "4";
            repository.TitleLBValueDescDelete(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA);
            uiLBNum = 4;
            sName = "5";
            repository.TitleUnitValueDescDelete(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA);
            uiLBNum = 6;
            sName = "6";
            repository.TitleCompValueDescDelete(
                c_tid1,
                uiLBNum,
                sName,
                c_locEnCA);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            uiLBNum = 2;
            sName = "4";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB2 enUS FV4 desc updated", sl[c_locEnUS.ToString()]);
            uiLBNum = 4;
            sName = "5";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB4 enUS FV5 desc updated", sl[c_locEnUS.ToString()]);
            uiLBNum = 6 << c_iCompTemplateShift;
            sName = "6";
            sl = webdb.WebLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("LB6 enUS FV6 desc updated", sl[c_locEnUS.ToString()]);

            // remove the last leaderboard descriptions - this should clear
            // all info for that leaderboard from webdb, even though the
            // repository still has other stuff about that leaderboard (like attributes)
            // remove a leaderboard description from the repository and sync again
            uiLBNum = 2;
            repository.TitleLBDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);
            repository.TitleLBDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 4;
            repository.TitleUnitDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);
            repository.TitleUnitDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);
            uiLBNum = 6;
            repository.TitleCompDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnCA);
            repository.TitleCompDescDelete(
                c_tid1,
                uiLBNum,
                c_locEnUS);

            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);

            rgui = webdb.WebLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);
            Assert.IsTrue(webdb.TitleConfigGet(
                c_tid1,
                out ESRBRating,
                out locDefault,
                out uiClusterId));

            // delete the title description for en-US, this should trigger a complete
            // removal of all info from webdb for this title
            sd.Delete(sRoot+@"ffff4006\message\titles.english.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.english.xml", "TitleDescTest");
            CWebDBSync.WebDBSync(
                c_tid1, 
                repository, 
                webdb,
                false,
                log);
            Assert.IsFalse(webdb.TitleConfigGet(
                c_tid1,
                out ESRBRating,
                out locDefault,
                out uiClusterId));

            // must close the object or it holds the database connection open
            // which messes up other tests..
            webdb.Close();

        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CVoucherTest.cs ===
using NUnit.Framework;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt
{
    [TestFixture]
    public class CVoucherTest
    {
        static private SHA1CryptoServiceProvider _sha = new SHA1CryptoServiceProvider();
        static private UnicodeEncoding _enc = new UnicodeEncoding();

        // Test offer ids
        const ulong testOffer1 = 0xFFFE000080000001;
        const ulong testOffer2 = 0xFFFE000080000002;
        const ulong testOffer3 = 0xFFFE000080000003;

        // Test sub code keys
        const string testKey1 = "AAAAA-BBBBB-CCCCC-DDDDD-EEEEE";
        const string testKey2 = "FFFFF-GGGGG-HHHHH-IIIII-JJJJJ";
        const string testKey3 = "KKKKK-LLLLL-MMMMM-NNNNN-OOOOO";

        /// <summary>
        /// Method to convert a subcode string into a hash.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        private static byte[] GetHashFromKey(string key)
        {
            // extra null is again, thanks to windows.net
            return _sha.ComputeHash(_enc.GetBytes(key + "\0"));
        }

        [Test]
        public void ConstructorTest()
        {
            CLog log = new CLog();

            CVoucher v = new CVoucher();

            v.Dispose();
        }


        [Test]
        public void VoucherTests()
        {
            CLog log = new CLog();
            CVoucher v = new CVoucher();
            uint result;

            try
            {
                byte [] hash = GetHashFromKey(testKey1);

                ArrayList info;
                ArrayList used;

                //  Get the initial state of the vouchers.  Delete any
                //  that may have been stranded by a previous run.

                log.WriteLine("Deleting any left over test vouchers.");

                v.GetVoucherInfo(hash, out info, out used);

                if(info.Count != 0)
                    v.DeleteVoucher(hash, CVoucher.CVOUCHER_ALL_OFFERS);

                v.GetVoucherInfo(hash, out info, out used);
                Assert.AreEqual(0, info.Count);

                //  Add a voucher associated with three different offers

                log.WriteLine("Adding test vouchers.");

                result = v.SetVoucher(hash, testOffer1, 16, 0);
                Assert.AreEqual(0, result);

                result = v.SetVoucher(hash, testOffer2, 16, 1);
                Assert.AreEqual(0, result);

                result = v.SetVoucher(hash, testOffer3, 16, 0);
                Assert.AreEqual(0, result);

                //  Make sure we get the information back correctly

                log.WriteLine("Retrieving info for voucher hash " + hash.ToString());

                v.GetVoucherInfo(hash, out info, out used);

                Assert.AreEqual(3, info.Count);
                Assert.AreEqual(0, used.Count);

                VoucherInfo vi;

                vi = (VoucherInfo)(info[0]);
                log.WriteLine("Offer ID = 0x" + vi._offerID.ToString("X") + ", Status = " + vi._status + ", Count = " + vi._numVouchers + ", Use Count = " + vi._useCount);

                Assert.AreEqual(testOffer1, vi._offerID);
                Assert.AreEqual(16, vi._useCount);
                Assert.AreEqual(CVoucher.VOUCHER_STATUS_ACTIVE, vi._status);
                Assert.AreEqual(1, vi._numVouchers);

                vi = (VoucherInfo)(info[1]);
                log.WriteLine("Offer ID = 0x" + vi._offerID.ToString("X") + ", Status = " + vi._status + ", Count = " + vi._numVouchers + ", Use Count = " + vi._useCount);

                Assert.AreEqual(testOffer2, vi._offerID);
                Assert.AreEqual(16, vi._useCount);
                Assert.AreEqual(CVoucher.VOUCHER_STATUS_DISABLED, vi._status);
                Assert.AreEqual(1, vi._numVouchers);

                vi = (VoucherInfo)(info[2]);
                log.WriteLine("Offer ID = 0x" + vi._offerID.ToString("X") + ", Status = " + vi._status + ", Count = " + vi._numVouchers + ", Use Count = " + vi._useCount);

                Assert.AreEqual(testOffer3, vi._offerID);
                Assert.AreEqual(16, vi._useCount);
                Assert.AreEqual(CVoucher.VOUCHER_STATUS_ACTIVE, vi._status);
                Assert.AreEqual(1, vi._numVouchers);

                //  Verify the summary info
                v.GetVouchersSummary(out info);

                log.WriteLine("Summary of vouchers in UODB:");
                foreach(VoucherInfo vi2 in info)
                {
                    log.WriteLine("Offer ID = 0x" + vi2._offerID.ToString("X") + ", Status = " + vi2._status + ", Count = " + vi2._numVouchers + ", Use Count = " + vi2._useCount);
                }

                //  Delete a single offer from hash
                v.DeleteVoucher(hash, testOffer3);
                v.GetVoucherInfo(hash, out info, out used);

                Assert.AreEqual(2, info.Count);
                Assert.AreEqual(0, used.Count);

                //  Enable/disable tests
                v.SetVoucher(hash, testOffer1, 16, 1); // disable previously enabled voucher
                v.SetVoucher(hash, testOffer2, 16, 0); // enable previously disabled voucher

                v.GetVoucherInfo(hash, out info, out used);

                Assert.AreEqual(2, info.Count);
                Assert.AreEqual(0, used.Count);

                vi = (VoucherInfo)(info[0]);
                log.WriteLine("Offer ID = 0x" + vi._offerID.ToString("X") + ", Status = " + vi._status + ", Count = " + vi._numVouchers + ", Use Count = " + vi._useCount);

                Assert.AreEqual(testOffer1, vi._offerID);
                Assert.AreEqual(16, vi._useCount);
                Assert.AreEqual(CVoucher.VOUCHER_STATUS_DISABLED, vi._status);
                Assert.AreEqual(1, vi._numVouchers);

                vi = (VoucherInfo)(info[1]);
                log.WriteLine("Offer ID = 0x" + vi._offerID.ToString("X") + ", Status = " + vi._status + ", Count = " + vi._numVouchers + ", Use Count = " + vi._useCount);

                Assert.AreEqual(testOffer2, vi._offerID);
                Assert.AreEqual(16, vi._useCount);
                Assert.AreEqual(CVoucher.VOUCHER_STATUS_ACTIVE, vi._status);
                Assert.AreEqual(1, vi._numVouchers);

                //  Delete all vouchers with a given hash
                v.DeleteVoucher(hash, CVoucher.CVOUCHER_ALL_OFFERS);

                //  Get voucher info again, should now have none
                v.GetVoucherInfo(hash, out info, out used);
                Assert.AreEqual(0, info.Count);
                Assert.AreEqual(0, used.Count);

                v.GetVouchersSummary(out info);

                log.WriteLine("Summary of vouchers in UODB:");
                foreach(VoucherInfo vi2 in info)
                {
                    log.WriteLine("Offer ID = 0x" + vi2._offerID.ToString("X") + ", Status = " + vi2._status + ", Count = " + vi2._numVouchers + ", Use Count = " + vi2._useCount);
                }
            }
            finally
            {
                v.Dispose();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CStatsTest.cs ===
using System;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Collections;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    // note - for these tests to run properly back to back, every connection string needs to 
    // specify Pooling=false so the database can be dropped and recreated between tests.

    [TestFixture]
    public class CStatsTypesTest
    {
        [Test]
        public void CELOMaxWeightRatingRangeTest()
        {
            CELOMaxWeightRatingRange ratingRange = new CELOMaxWeightRatingRange();
            Assert.AreEqual(0, ratingRange.uiStart);
            Assert.AreEqual(0, ratingRange.uiMaxWeight);
            Assert.AreEqual("{0,0}", ratingRange.ToString());
            Assert.AreEqual("0:0", ratingRange.ToStatsDBString());

            ratingRange = new CELOMaxWeightRatingRange(1,2);
            Assert.AreEqual(1, ratingRange.uiStart);
            Assert.AreEqual(2, ratingRange.uiMaxWeight);
            Assert.AreEqual("{1,2}", ratingRange.ToString());
            Assert.AreEqual("1:2", ratingRange.ToStatsDBString());
        }

        [Test]
        public void CELOConfigTest()
        {
            CELOConfig eloConfig = new CELOConfig();
            Assert.AreEqual(0, eloConfig.uiInitialPlayerRating);
            Assert.AreEqual(0, eloConfig.uiRatingScaleFactor);
            Assert.AreEqual(EELOExponentialBase.ten, eloConfig.exponentialBase);
            Assert.AreEqual(0, eloConfig.rgMaxWeightRatings.Length);
            Assert.AreEqual("{0,0,ten,{}}", eloConfig.ToString());
            bool bThrown = false;
            try
            {
                eloConfig.ToStatsDBString();
            }
            catch (Exception e)
            {
                Assert.IsFalse(e.Message.IndexOf("Invalid rgMaxWeightRatings") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            CELOMaxWeightRatingRange[] rgMaxWeightRatings = new CELOMaxWeightRatingRange[2];
            rgMaxWeightRatings[0] = new CELOMaxWeightRatingRange(10,20);
            rgMaxWeightRatings[1] = new CELOMaxWeightRatingRange(30,40);
            eloConfig = new CELOConfig(
                1,
                2,
                EELOExponentialBase.e,
                rgMaxWeightRatings);
            Assert.AreEqual(1, eloConfig.uiInitialPlayerRating);
            Assert.AreEqual(2, eloConfig.uiRatingScaleFactor);
            Assert.AreEqual(EELOExponentialBase.e, eloConfig.exponentialBase);
            Assert.AreEqual(2, eloConfig.rgMaxWeightRatings.Length);
            Assert.AreEqual("{1,2,e,{{10,20},{30,40}}}", eloConfig.ToString());
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=10:20,30:40", eloConfig.ToStatsDBString());

            // test Parse
            CELOConfig eloConfig2 = CELOConfig.Parse(eloConfig.ToStatsDBString());
            Assert.AreEqual(eloConfig.ToString(), eloConfig2.ToString());
            Assert.AreEqual(eloConfig.ToStatsDBString(), eloConfig2.ToStatsDBString());

            // ELO_C must start with 0:X
            Assert.IsFalse(eloConfig.IsValid());

            // ELO_C must have increasing start values
            eloConfig.rgMaxWeightRatings[0].uiStart = 0;
            eloConfig.rgMaxWeightRatings[1].uiStart = 0;
            Assert.IsFalse(eloConfig.IsValid());

            // this one should be good now
            eloConfig.rgMaxWeightRatings[1].uiStart =1;
            Assert.IsTrue(eloConfig.IsValid());
        }

        /*
        [Test]
        public void CLBInfoTest()
        {
            CLBInfo leaderboard = new CLBInfo();
            Assert.AreEqual(0, leaderboard.uiLBNum);
            Assert.AreEqual(Guid.Empty, leaderboard.guid);
            Assert.AreEqual(null, leaderboard.sServerName);
            Assert.AreEqual(null, leaderboard.sDatabaseName);
            Assert.AreEqual(ELBReset.ResetNever, leaderboard.riResetInterval);
            Assert.AreEqual(0, leaderboard.uiUserCount);
            Assert.AreEqual(0, leaderboard.uiAttachmentCount);
            Assert.AreEqual(0, leaderboard.uiMaxAttachmentSize);
            Assert.AreEqual(0, leaderboard.uiMaxRatingCount);
            Assert.AreEqual(0, leaderboard.lMinQualifyingRating);
            Assert.AreEqual(0, leaderboard.uiDecayDays);
            Assert.AreEqual(false, leaderboard.bIsArbitrated);
            Assert.AreEqual(false, leaderboard.bIsUnit);
            Assert.AreEqual(false, leaderboard.bIsTeam);
            Assert.AreEqual(false, leaderboard.bIsCompTemplate);
            Assert.AreEqual(false, leaderboard.bIsComp);
            Assert.AreEqual(0, leaderboard.uiTemplateLBNum);
            Assert.AreEqual(null, leaderboard.eloConfig);
            Assert.AreEqual(
                "{0,"
                + Guid.Empty.ToString()
                + ",null,null,ResetNever,0,0,0,0,0,0,False,False,False,False,False,0,null}",
                leaderboard.ToString());

            leaderboard.guid = Guid.NewGuid();
            leaderboard.sServerName = "server";
            leaderboard.sDatabaseName = "database";
            CELOMaxWeightRatingRange[] rgMaxWeightRatingRanges = new CELOMaxWeightRatingRange[2];
            rgMaxWeightRatingRanges[0] = new CELOMaxWeightRatingRange(10,20);
            rgMaxWeightRatingRanges[1] = new CELOMaxWeightRatingRange(30,40);
            CELOMaxWeightRatingRange[] rgMaxWeightRatings = new CELOMaxWeightRatingRange[2];
            rgMaxWeightRatings[0] = new CELOMaxWeightRatingRange(10,20);
            rgMaxWeightRatings[1] = new CELOMaxWeightRatingRange(30,40);
            leaderboard.eloConfig = new CELOConfig(
                1,
                2,
                EELOExponentialBase.e,
                rgMaxWeightRatings);
            Assert.AreEqual(
                "{0," + leaderboard.guid.ToString() + ",server,database,ResetNever,0,0,0,0,0,0,False,False,False,False,False,0,"
                + leaderboard.eloConfig.ToString() + "}",
                leaderboard.ToString());
        }
        */
    }

    [TestFixture]
    public class CStatsTest
    {
        private const uint c_uiTidTest = 0xffff4006;

        [SetUp]
        public void CreateStatsDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.CreateStatsDBOnLocalhost starting");
            CCreateStatsDB.CreateStatsDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.CreateStatsDBOnLocalhost complete");
        }

        [Test]
        public void ConstructorTest()
        {
            CLog log = new CLog();
            CTitleId tid = new CTitleId(0xffff4006);
            string[] rgsConnectionStrings = new string[0];
            CServer[] rgStatsFDServers = new CServer[0];

            // this should simply work - should however check the log output
            CStats cs = new CStats(rgsConnectionStrings, rgStatsFDServers, log);

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest: "
                + "calling constructor with null log - should be no log output");
            cs = new CStats(rgsConnectionStrings, rgStatsFDServers, null);
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest: "
                + "call will null log complete");

            // parameter validation tests

            // passing null rgsConnectionStrings should throw ArgumentNullException
            bool bThrown = false;
            try
            {
                cs = new CStats(null, rgStatsFDServers, log);
            }
            catch (ArgumentNullException e)
            {
                bThrown = true;
                Assert.AreEqual("rgsStatsDBConnectionStrings", e.ParamName);
            }
            Assert.IsTrue(bThrown);

            // passing null rgStatsFDServers should throw ArgumentNullException
            bThrown = false;
            try
            {
                cs = new CStats(rgsConnectionStrings, null, log);
            }
            catch (ArgumentNullException e)
            {
                bThrown = true;
                Assert.AreEqual("rgStatsFDServers", e.ParamName);
            }
            Assert.IsTrue(bThrown);

            // call with invalid connection strings should throw a CStatsException
            // because it can't connect to the database
            rgsConnectionStrings = new string[2];
            rgsConnectionStrings[0] = "invalid connection string 1";
            rgsConnectionStrings[1] = "invalid connection string 2";

            rgStatsFDServers = new CServer[2];

            rgStatsFDServers[0] = new CServer();
            rgStatsFDServers[0].sServerName = "servername0";
            rgStatsFDServers[0].rgipAddresses = new IPAddress[2];
            rgStatsFDServers[0].rgipAddresses[0] = IPAddress.Parse("1.2.3.4");
            rgStatsFDServers[0].rgipAddresses[1] = IPAddress.Parse("5.6.7.8");

            rgStatsFDServers[1] = new CServer();
            rgStatsFDServers[1].sServerName = "servername1";
            rgStatsFDServers[1].rgipAddresses = new IPAddress[2];
            rgStatsFDServers[1].rgipAddresses[0] = IPAddress.Parse("9.10.11.12");
            rgStatsFDServers[1].rgipAddresses[1] = IPAddress.Parse("13.14.15.16");

            bThrown = false;
            try
            {
                cs = new CStats(rgsConnectionStrings, rgStatsFDServers, log);
            }
            catch (CStatsException statsException)
            {
                Assert.IsFalse(statsException.Message.IndexOf("Opening a connection") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // call with valid connection string, should succeed. front door servers do
            // not need to be valid, because the constructor doesn't try to connect to them
            rgsConnectionStrings = new string[1];
            rgsConnectionStrings[0] = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
            cs = new CStats(rgsConnectionStrings, rgStatsFDServers, log);

            // have to call Close
            cs.Close();

            // calling Close twice should be a noop
            cs.Close();

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest complete");
        }

        [Test]
        public void LBTest()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.LBTest starting");

            // get a connection to xstats on localhost
            bool bThrown = false;
            bool bFound = false;
            CTitleId tid = new CTitleId(0xffff4006);
            string[] rgsConnectionStrings = new string[1];
            CServer[] rgStatsFDServers = new CServer[0];
            rgsConnectionStrings[0] = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
            CStats stats = new CStats(
                rgsConnectionStrings, 
                rgStatsFDServers, 
                log);

            try
            {
                // make sure we start completely clean
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.LBTest: "
                    + "Calling TitleDelete to start with clean database");
                stats.TitleDelete(tid, 0, false);

                // test the set/get/delete title config APIs
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.LBTest: "
                    + "Testing TitleConfigSet / TitleConfigGet / TitleConfigDelete");

                // do parameter validation testing on the TitleConfig calls

                // TitleConfigSet
                bThrown = false;
                try
                {
                    // null tid
                    stats.TitleConfigSet(null, 0, 0, 0, true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.TitleConfigSet(tid, 1, 0, 0, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.TitleConfigSet(tid, -1, 0, 0, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // TitleConfigGet
                uint uiMaxWrites;
                uint uiMaxReads;
                bThrown = false;
                try
                {
                    // null tid
                    stats.TitleConfigGet(null, 0, out uiMaxWrites, out uiMaxReads);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.TitleConfigGet(tid, 1, out uiMaxWrites, out uiMaxReads);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.TitleConfigGet(tid, -1, out uiMaxWrites, out uiMaxReads);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // TitleConfigDelete
                bThrown = false;
                try
                {
                    // null tid
                    stats.TitleConfigDelete(null, 0, true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.TitleConfigDelete(tid, 1, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.TitleConfigDelete(tid, -1, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // test the "all servers" version first

                // report only, should do nothing
                stats.TitleConfigSet(tid, 100, 200, true);

                // these should report no title configuration
                SortedList sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);
                bFound = true;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsFalse(bFound);
                Assert.AreEqual(0, uiMaxWrites);
                Assert.AreEqual(0, uiMaxReads);

                // do it for real this time
                stats.TitleConfigSet(tid, 100, 200, false);

                // this should report a title configuration, and set uiMaxWrites
                // and uiMaxReads to what we set above
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(1, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);
                bFound = false;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsTrue(bFound);
                Assert.AreEqual(100, uiMaxWrites);
                Assert.AreEqual(200, uiMaxReads);

                // now we should be able to delete the configuration, and
                // return to the previous state.

                // first try report only mode, which should change nothing
                stats.TitleConfigDelete(tid, 0, true);

                // because the previous call was report only, the database
                // should still have the previous configuration
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(1, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);
                bFound = false;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsTrue(bFound);
                Assert.AreEqual(100, uiMaxWrites);
                Assert.AreEqual(200, uiMaxReads);

                // now do it for real, should remove the title configuration
                stats.TitleConfigDelete(tid, 0, false);

                // title configuration should be gone now
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);
                bFound = true;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsFalse(bFound);
                Assert.AreEqual(0, uiMaxWrites);
                Assert.AreEqual(0, uiMaxReads);

                // now run the same tests, but use the single server
                // version of call

                // report only, should do nothing
                stats.TitleConfigSet(tid, 0, 100, 200, true);

                // this should report no title configuration, and set uiMaxWrites
                // and uiMaxReads to default values
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);
                bFound = true;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsFalse(bFound);
                Assert.AreEqual(0, uiMaxWrites);
                Assert.AreEqual(0, uiMaxReads);

                // do it for real this time
                stats.TitleConfigSet(tid, 0, 100, 200, false);

                // this should report a title configuration, and set uiMaxWrites
                // and uiMaxReads to what we set above
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(1, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);
                bFound = false;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsTrue(bFound);
                Assert.AreEqual(100, uiMaxWrites);
                Assert.AreEqual(200, uiMaxReads);

                // finally, add a second title configuration, so we can 
                // ensure the map call is capable of returning a list
                CTitleId tid2 = new CTitleId(0xffff4007);
                stats.TitleConfigSet(tid2, 0, 100, 200, false);
                sortedList = stats.TitleGetDatabaseMap();
                Assert.AreEqual(2, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);
                Assert.IsTrue(((bool[])sortedList[tid2.uiTitleId])[0]);

                // leave the title configuration there for later, so we can
                // test TitleDelete cleanup function

                // title config is tested, now we're on to leaderboard tests

                // test the parameter validation on the LB calls

                // LBConfigSet
                uint uiLBNum = 0;
                ELBReset leaderboardResetInterval 
                    = ELBReset.ResetNever;
                uint uiAttachmentCount = 0;
                uint uiMaxAttachmentSize = 0;
                uint uiDecayDays = 0;
                uint uiMaxRatingCount = 0;
                bool bRequireArbitration = false;
                bool bIsTeam = false;
                CELOConfig eloConfig = null;

                bThrown = false;
                try
                {
                    // null tid
                    stats.LBConfigSet(
                        null,
                        0, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.LBConfigSet(
                        tid,
                        1, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.LBConfigSet(
                        tid,
                        -1, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // can't specifiy both arbitration and attachments
                    uiAttachmentCount = 1;
                    uiMaxAttachmentSize = 0;
                    bRequireArbitration = true;
                    stats.LBConfigSet(
                        tid,
                        0, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("uiAttachmentCount", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // can't specifiy both arbitration and attachments
                    uiAttachmentCount = 0;
                    uiMaxAttachmentSize = 1;
                    bRequireArbitration = true;
                    stats.LBConfigSet(
                        tid,
                        0, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("uiMaxAttachmentSize", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // null ELO is ok, but an invalid one is not
                // default construtor has no max rating ranges and is
                // therefore invalid
                eloConfig = new CELOConfig();
                uiAttachmentCount = 0;
                uiMaxAttachmentSize = 0;
                bRequireArbitration = false;
                bThrown = false;
                try
                {
                    // invalid ELO config
                    stats.LBConfigSet(
                        tid,
                        0, 
                        uiLBNum,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        uiMaxRatingCount,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("eloConfig", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // LBConfigGet
                Guid guid;
                long lMinQualifyingRating;
                DateTime dateTimeCreated;
                byte bReadOnly;
                byte bCopying;
                byte bDelete;
                bThrown = false;
                try
                {
                    // null tid
                    stats.LBConfigGet(
                        null,
                        0, 
                        uiLBNum,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out uiMaxRatingCount,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig,
                        out guid,
                        out lMinQualifyingRating,
                        out dateTimeCreated,
                        out bReadOnly,
                        out bCopying,
                        out bDelete);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.LBConfigGet(
                        tid,
                        1, 
                        uiLBNum,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out uiMaxRatingCount,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig,
                        out guid,
                        out lMinQualifyingRating,
                        out dateTimeCreated,
                        out bReadOnly,
                        out bCopying,
                        out bDelete);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.LBConfigGet(
                        tid,
                        -1, 
                        uiLBNum,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out uiMaxRatingCount,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig,
                        out guid,
                        out lMinQualifyingRating,
                        out dateTimeCreated,
                        out bReadOnly,
                        out bCopying,
                        out bDelete);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // LBDelete
                bThrown = false;
                try
                {
                    // null tid
                    stats.LBDelete(
                        null,
                        0, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.LBDelete(
                        tid,
                        1, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.LBDelete(
                        tid,
                        -1, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // LBReset
                bThrown = false;
                try
                {
                    // null tid
                    stats.LBReset(
                        null,
                        0, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.LBReset(
                        tid,
                        1, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.LBReset(
                        tid,
                        -1, 
                        uiLBNum,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // LBMove
                bThrown = false;
                try
                {
                    // null tid
                    stats.LBMove(
                        null,
                        uiLBNum,
                        0, 
                        0,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iSourceStatsDatabase too large
                    stats.LBMove(
                        tid,
                        uiLBNum,
                        1, 
                        0,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iSourceStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iSourceStatsDatabase too small
                    stats.LBMove(
                        tid,
                        uiLBNum,
                        -1, 
                        0,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iSourceStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iDestStatsDatabase too large
                    stats.LBMove(
                        tid,
                        uiLBNum,
                        0, 
                        1,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iDestStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iDestStatsDatabase too small
                    stats.LBMove(
                        tid,
                        uiLBNum,
                        0, 
                        -1,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iDestStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iDestStatsDatabase cannot equal iSourceStatsDatabase
                    stats.LBMove(
                        tid,
                        uiLBNum,
                        0, 
                        0,
                        false,
                        0,
                        0,
                        0,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iDestStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // Phew! end of parameter validation stuff on the LB methods
                // now on to the real work

                // there's no leaderboards defined yet, so the map should be
                // empty
                SortedList sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(0, sortedListMap.Count);

                uiLBNum = 32;

                ELBReset leaderboardResetIntervalIn 
                    = ELBReset.ResetEveryWeek;
                uint uiAttachmentCountIn = 1;
                uint uiMaxAttachmentSizeIn = 2;
                uint uiDecayDaysIn = 3;
                uint uiMaxRatingCountIn = 100;
                bool bRequireArbitrationIn = false;
                bool bIsTeamIn = true;
                CELOConfig eloConfigIn 
                    = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:0,1:0");

                ELBReset leaderboardResetIntervalOut 
                    = ELBReset.ResetNever;
                uint uiAttachmentCountOut;
                uint uiMaxAttachmentSizeOut;
                uint uiDecayDaysOut;
                uint uiMaxRatingCountOut;
                bool bRequireArbitrationOut;
                bool bIsTeamOut;
                CELOConfig eloConfigOut;
                Guid guidOut;
                long lMinQualifyingRatingOut;
                DateTime dateTimeCreatedOut;
                byte bReadOnlyOut;
                byte bCopyingOut;
                byte bDeleteOut;

                // create a leaderboard in report only mode
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    true);

                // because the call was report only, the leaderboard map should
                // still be empty
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(0, sortedListMap.Count);

                // and LBConfigGet should indicate that the leaderboard
                // is not there.
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsFalse(bFound);

                // now create the leaderboard for real
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // it should show up in the map now
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(1, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);

                // and we should be able to retrieve it
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);

                // check that the definition matches what we set
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(uiMaxRatingCountIn, uiMaxRatingCountOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // try resetting this leaderboard. we'll know if it reset because
                // the guid should change

                // first try report only, of course, guid should not change
                Guid guidOriginal = guidOut;
                stats.LBReset(
                    tid,
                    0,
                    uiLBNum,
                    0,
                    true);

                // get the leaderboard again, confirm the guid hasn't changed
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(guidOriginal.ToString(), guidOut.ToString());

                // now do it for real, and confirm the guid changed
                stats.LBReset(
                    tid,
                    0,
                    uiLBNum,
                    0,
                    false);

                // get the leaderboard again, confirm the guid changed
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);
                Assert.IsFalse(guidOriginal.ToString() == guidOut.ToString());

                // try resetting a leaderboard that doesn't exist
                // shoudl throw exception
                bThrown = false;
                try
                {
                    stats.LBReset(
                        tid,
                        0,
                        0,
                        0,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("Unable to reset leaderboard") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // try changing the team status - should fail
                bThrown = false;
                try
                {
                    stats.LBConfigSet(
                        tid,
                        0,
                        uiLBNum, 
                        leaderboardResetIntervalIn,
                        uiAttachmentCountIn,
                        uiMaxAttachmentSizeIn,
                        uiDecayDaysIn,
                        uiMaxRatingCountIn,
                        bRequireArbitrationIn,
                        false,  // bIsTeam
                        eloConfigIn,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("Cannot change team status") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // try changing the max rating count, should fail
                bThrown = false;
                try
                {
                    stats.LBConfigSet(
                        tid,
                        0,
                        uiLBNum, 
                        leaderboardResetIntervalIn,
                        uiAttachmentCountIn,
                        uiMaxAttachmentSizeIn,
                        uiDecayDaysIn,
                        0, // bMaxRatingCount
                        bRequireArbitrationIn,
                        bIsTeamIn,
                        eloConfigIn,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("Cannot change max rating count") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // confirm that the previous two calls didn't actually change the
                // leaderboard definition
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(uiMaxRatingCountIn, uiMaxRatingCountOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // try changing something we're allowed to change, and confirm that
                // it takes
                bRequireArbitrationIn = false;
                uiAttachmentCountIn = 0;
                uiMaxAttachmentSizeIn = 0;
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(uiMaxRatingCountIn, uiMaxRatingCountOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // now create a second leaderboard, no ELO this time
                eloConfigIn = null;
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBNum + 1, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // check that it was created correctly
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum + 1, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(uiMaxRatingCountIn, uiMaxRatingCountOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(null, eloConfigOut);

                // check that both leaderboards are listed in the map
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(2, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);

                // now delete the original leaderboard

                // report only mode first
                stats.LBDelete(
                    tid,
                    0,
                    uiLBNum,
                    0,
                    true);

                // the leaderboard should still be there
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(2, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);

                // now delete it for real
                stats.LBDelete(
                    tid,
                    0,
                    uiLBNum,
                    0,
                    false);

                // the leaderboard should be gone
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(1, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);
                bFound = true;
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsFalse(bFound);

                // now insert four leaderboards, one with each "competition template"
                // bit set, so we can test the ability for LBGetDatabaseMap to ignore
                // competition template based leaderboards.
                uint uiLBComp1 = 0x20000001;
                uint uiLBComp2 = 0x10000001;
                uint uiLBComp3 = 0x08000001;
                uint uiLBComp4 = 0x04000001;
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBComp1, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBComp2, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBComp3, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);
                stats.LBConfigSet(
                    tid,
                    0,
                    uiLBComp4, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    uiMaxRatingCountIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // LBGetDatabaseMap should return these four leaderboards
                // if bIgnoreCompLBs is false
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(5, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBComp1])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBComp2])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBComp3])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBComp4])[0]);

                // LBGetDatabaseMap should not return these four leaderboards
                // if bIgnoreCompLBs is true
                sortedListMap = stats.LBGetDatabaseMap(tid, true);
                Assert.AreEqual(1, sortedListMap.Count);

                // finally, nuke the title completely, and confirm that 
                // both the title config and last remaining leaderboard
                // get cleaned up

                // report only first, should do nothing
                stats.TitleDelete(tid, 0, true);

                // confirm stuff is still there.
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(5, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);
                bFound = false;
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum+1, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsTrue(bFound);

                bFound = false;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsTrue(bFound);

                // now for real
                stats.TitleDelete(tid, 0, false);

                // confirm stuff is gone.
                sortedListMap = stats.LBGetDatabaseMap(tid, false);
                Assert.AreEqual(0, sortedListMap.Count);
                bFound = true;
                bFound = stats.LBConfigGet(
                    tid,
                    0,
                    uiLBNum+1, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out uiMaxRatingCountOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut,
                    out guidOut,
                    out lMinQualifyingRatingOut,
                    out dateTimeCreatedOut,
                    out bReadOnlyOut,
                    out bCopyingOut,
                    out bDeleteOut);
                Assert.IsFalse(bFound);

                bFound = true;
                bFound = stats.TitleConfigGet(tid, 0, out uiMaxWrites, out uiMaxReads);
                Assert.IsFalse(bFound);

                // done! We can't test LBMove or any multi server
                // stuff on localhost. That we'll have to test on testnet.
            }
            finally
            {
                stats.Close();
            }

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.LBTest complete");
        }

        [Test]
        public void UnitTest()
        {
            // Ha, UnitTest, that's rich

            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.UnitTest starting");

            // get a connection to xstats on localhost
            bool bThrown = false;
            bool bFound = false;
            CTitleId tid = new CTitleId(0xffff4006);
            string[] rgsConnectionStrings = new string[1];
            CServer[] rgStatsFDServers = new CServer[0];
            rgsConnectionStrings[0] = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
            CStats stats = new CStats(
                rgsConnectionStrings, 
                rgStatsFDServers, 
                log);

            try
            {
                // make sure we start completely clean
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.UnitTest: "
                    + "Calling TitleDelete to start with clean database");
                stats.TitleDelete(tid, 0, false);

                // test the set/get/delete unit config APIs
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.UnitTest: "
                    + "Testing UnitTitleConfigSet / UnitTitleConfigGet");

                int iStatsDatabaseIn = 0;
                double dDecayFactorIn = 30;
                uint uiMaxAvailUnitsIn = 50;
                uint uiSizeUnitCacheIn = 25;

                double dDecayFactorExpected = -Math.Log(2) / dDecayFactorIn;

                int iStatsDatabaseOut;
                double dDecayFactorOut;
                uint uiMaxAvailUnitsOut;
                uint uiSizeUnitCacheOut;

                // do parameter validation testing on the UnitTitleConfig calls

                // UnitTitleConfigSet
                bThrown = false;
                try
                {
                    // null tid
                    stats.UnitTitleConfigSet(null, 0, 1, 1, 1, true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.UnitTitleConfigSet(tid, 1, 1, 1, 1, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.UnitTitleConfigSet(tid, -1, 1, 1, 1, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // dDecayFactor too small
                    stats.UnitTitleConfigSet(tid, 0, -1, 1, 1, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("dDecayFactor", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // UnitTitleConfigGet
                bThrown = false;
                try
                {
                    // null tid
                    stats.UnitTitleConfigGet(
                        null,
                        0, 
                        out dDecayFactorOut, 
                        out uiMaxAvailUnitsOut, 
                        out uiSizeUnitCacheOut);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.UnitTitleConfigGet(
                        tid,
                        1, 
                        out dDecayFactorOut, 
                        out uiMaxAvailUnitsOut, 
                        out uiSizeUnitCacheOut);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.UnitTitleConfigGet(
                        tid,
                        -1,
                        out dDecayFactorOut,
                        out uiMaxAvailUnitsOut,
                        out uiSizeUnitCacheOut);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // right now, the title is not configured for units,
                // so UnitTitleConfigGet should return false
                bFound = true;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut,
                    out dDecayFactorOut,
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsFalse(bFound);

                // and there should be nothing in the unit title map
                SortedList sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);

                // set a unit config for this title
                // report only first.
                stats.UnitTitleConfigSet(
                    tid,
                    0,
                    dDecayFactorIn,
                    uiMaxAvailUnitsIn,
                    uiSizeUnitCacheIn,
                    true);

                // check to see that it's still not configured
                bFound = true;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut,
                    out dDecayFactorOut,
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsFalse(bFound);
                sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);

                // now set it for real
                stats.UnitTitleConfigSet(
                    tid,
                    0,
                    dDecayFactorIn,
                    uiMaxAvailUnitsIn,
                    uiSizeUnitCacheIn,
                    false);

                // check that it took
                bFound = false;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut,
                    out dDecayFactorOut,
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(iStatsDatabaseIn, iStatsDatabaseOut);
                Assert.AreEqual(dDecayFactorExpected, dDecayFactorOut);
                Assert.AreEqual(uiMaxAvailUnitsIn, uiMaxAvailUnitsOut);
                Assert.AreEqual(uiSizeUnitCacheIn, uiSizeUnitCacheOut);
                sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(1, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);

                // add another title, so we can test GetMap with more than
                // one title
                CTitleId tid2 = new CTitleId(0xffff4007);
                stats.UnitTitleConfigSet(
                    tid2,
                    0,
                    dDecayFactorIn,
                    uiMaxAvailUnitsIn,
                    uiSizeUnitCacheIn,
                    false);
                sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(2, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid.uiTitleId])[0]);
                Assert.IsTrue(((bool[])sortedList[tid2.uiTitleId])[0]);

                // don't test UnitTitleDelete until the end, because
                // it nukes everything, not just the title config

                // Now we start in on the unit leaderboard stuff

                // UnitLBConfigSet
                uint uiLBNum = 0;
                bool bRequireArbitration = false;
                bool bIsTeam = false;
                CELOConfig eloConfig = null;

                bThrown = false;
                try
                {
                    // null tid
                    stats.UnitLBConfigSet(
                        null,
                        0, 
                        uiLBNum,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.UnitLBConfigSet(
                        tid,
                        1, 
                        uiLBNum,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);
                
                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.UnitLBConfigSet(
                        tid,
                        -1, 
                        uiLBNum,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // null ELO is ok, but an invalid one is not
                // default construtor has no max rating ranges and is
                // therefore invalid
                eloConfig = new CELOConfig();
                bThrown = false;
                try
                {
                    // invalid ELO config
                    stats.UnitLBConfigSet(
                        tid,
                        0, 
                        uiLBNum,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("eloConfig", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);


                // UnitLBConfigGet
                bThrown = false;
                try
                {
                    // null tid
                    stats.UnitLBConfigGet(
                        null,
                        0, 
                        uiLBNum,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.UnitLBConfigGet(
                        tid,
                        1, 
                        uiLBNum,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.UnitLBConfigGet(
                        tid,
                        -1, 
                        uiLBNum,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // End of parameter validation stuff on the UnitLB methods
                // now on to the real work

                // there's no leaderboards defined yet, so the map should be
                // empty
                SortedList sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListMap.Count);

                uiLBNum = 32;

                bool bRequireArbitrationIn = false;
                bool bIsTeamIn = true;
                CELOConfig eloConfigIn 
                    = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:0,1:0");

                bool bRequireArbitrationOut;
                bool bIsTeamOut;
                CELOConfig eloConfigOut;

                // create a leaderboard in report only mode
                stats.UnitLBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    true);

                // because the call was report only, the leaderboard map should
                // still be empty
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListMap.Count);

                // and LBConfigGet should indicate that the leaderboard
                // is not there.
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsFalse(bFound);

                // now create the leaderboard for real
                stats.UnitLBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // it should show up in the map now
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(1, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);

                // and we should be able to retrieve it
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                // check that the definition matches what we set
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // try changing the team status - should fail
                bThrown = false;
                try
                {
                    stats.UnitLBConfigSet(
                        tid,
                        0,
                        uiLBNum, 
                        bRequireArbitrationIn,
                        false,  // bIsTeam
                        eloConfigIn,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("Cannot change team status") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // confirm that the previous call didn't actually change the
                // leaderboard definition
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // try changing something we're allowed to change, and confirm that
                // it takes
                bRequireArbitrationIn = false;
                stats.UnitLBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // now create a second leaderboard, no ELO this time
                eloConfigIn = null;
                stats.UnitLBConfigSet(
                    tid,
                    0,
                    uiLBNum + 1, 
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // check that it was created correctly
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum + 1, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(null, eloConfigOut);

                // check that both leaderboards are listed in the map
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);

                // disable units on this title completely, and confirm that 
                // both the title config and both leaderboards
                // get cleaned up

                // report only first, should do nothing
                stats.UnitTitleDelete(tid, 0, 0, true);

                // confirm stuff is still there.
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum+1])[0]);

                bFound = false;
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                bFound = false;
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum+1, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                bFound = false;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut, 
                    out dDecayFactorOut, 
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsTrue(bFound);

                // now for real
                stats.UnitTitleDelete(tid, 0, 0, false);

                // confirm stuff is gone.
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListMap.Count);

                bFound = true;
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsFalse(bFound);

                bFound = true;
                bFound = stats.UnitLBConfigGet(
                    tid,
                    0,
                    uiLBNum+1, 
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsFalse(bFound);

                bFound = true;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut, 
                    out dDecayFactorOut, 
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsFalse(bFound);

                // since the the title is not configured for units, I shouldn't
                // be able to create unit leaderboards
                bThrown = false;
                try
                {
                    stats.UnitLBConfigSet(
                        tid,
                        0,
                        uiLBNum, 
                        bRequireArbitrationIn,
                        bIsTeamIn,
                        eloConfigIn,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("has not been configured for units") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // finally, we want to make sure that TitleDelete gets the
                // unit stuff. So re-configure the title and create a leaderboard
                // then use TitleDelete to nuke them
                stats.UnitTitleConfigSet(
                    tid,
                    0,
                    dDecayFactorIn,
                    uiMaxAvailUnitsIn,
                    uiSizeUnitCacheIn,
                    false);

                // check that it took
                bFound = false;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut,
                    out dDecayFactorOut,
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(iStatsDatabaseIn, iStatsDatabaseOut);
                Assert.AreEqual(dDecayFactorExpected, dDecayFactorOut);
                Assert.AreEqual(uiMaxAvailUnitsIn, uiMaxAvailUnitsOut);
                Assert.AreEqual(uiSizeUnitCacheIn, uiSizeUnitCacheOut);

                stats.UnitLBConfigSet(
                    tid,
                    0,
                    uiLBNum, 
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // it should show up in the map
                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(1, sortedListMap.Count);
                Assert.IsTrue(((bool[])sortedListMap[uiLBNum])[0]);

                // now nuke everything with TitleDelete
                stats.TitleDelete(tid, 0, false);

                // confirm the title is no longer configured and the
                // leaderboard is gone
                bFound = true;
                bFound = stats.UnitTitleConfigGet(
                    tid,
                    out iStatsDatabaseOut,
                    out dDecayFactorOut,
                    out uiMaxAvailUnitsOut,
                    out uiSizeUnitCacheOut);
                Assert.IsFalse(bFound);

                sortedListMap = stats.UnitLBGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListMap.Count);

                // this map should still have tid2 hanging around
                sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(1, sortedList.Count);
                Assert.IsTrue(((bool[])sortedList[tid2.uiTitleId])[0]);

                // now clean up tid2
                stats.TitleDelete(tid2, 0, false);
                sortedList = stats.UnitTitleGetDatabaseMap();
                Assert.AreEqual(0, sortedList.Count);
            }
            finally
            {
                stats.Close();
            }
        }

        [Test]
        public void CompTest()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.CompTest starting");

            // get a connection to xstats on localhost
            bool bThrown = false;
            bool bFound = false;
            CTitleId tid = new CTitleId(0xffff4006);
            string[] rgsConnectionStrings = new string[1];
            CServer[] rgStatsFDServers = new CServer[0];
            rgsConnectionStrings[0] = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=xstats";
            CStats stats = new CStats(
                rgsConnectionStrings, 
                rgStatsFDServers, 
                log);

            try
            {
                // make sure we start completely clean
                log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.CompTest: "
                    + "Calling TitleDelete to start with clean database");
                stats.TitleDelete(tid, 0, false);

                // note - it is legal to create compeition templates on 
                // servers with no competition partitions. Therefore
                // I'm going to test the CompTempateSet/Get first

                // LBConfigSet
                uint uiTemplateId = 0;
                ELBReset leaderboardResetInterval 
                    = ELBReset.ResetNever;
                uint uiAttachmentCount = 0;
                uint uiMaxAttachmentSize = 0;
                uint uiDecayDays = 0;
                bool bRequireArbitration = false;
                bool bIsTeam = false;
                CELOConfig eloConfig = null;

                bThrown = false;
                try
                {
                    // null tid
                    stats.CompTemplateConfigSet(
                        null,
                        0, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.CompTemplateConfigSet(
                        tid,
                        1, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.CompTemplateConfigSet(
                        tid,
                        -1, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // template ids too large
                    uiAttachmentCount = 1;
                    uiMaxAttachmentSize = 0;
                    bRequireArbitration = true;
                    stats.CompTemplateConfigSet(
                        tid,
                        0, 
                        16,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("uiTemplateId", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // can't specifiy both arbitration and attachments
                    uiAttachmentCount = 1;
                    uiMaxAttachmentSize = 0;
                    bRequireArbitration = true;
                    stats.CompTemplateConfigSet(
                        tid,
                        0, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("uiAttachmentCount", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // can't specifiy both arbitration and attachments
                    uiAttachmentCount = 0;
                    uiMaxAttachmentSize = 1;
                    bRequireArbitration = true;
                    stats.CompTemplateConfigSet(
                        tid,
                        0, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("uiMaxAttachmentSize", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // null ELO is ok, but an invalid one is not
                // default construtor has no max rating ranges and is
                // therefore invalid
                eloConfig = new CELOConfig();
                uiAttachmentCount = 0;
                uiMaxAttachmentSize = 0;
                bRequireArbitration = false;
                bThrown = false;
                try
                {
                    // invalid ELO config
                    stats.CompTemplateConfigSet(
                        tid,
                        0, 
                        uiTemplateId,
                        leaderboardResetInterval,
                        uiAttachmentCount,
                        uiMaxAttachmentSize,
                        uiDecayDays,
                        bRequireArbitration,
                        bIsTeam,
                        eloConfig,
                        true);
                }
                catch (ArgumentException e)
                {
                    Assert.AreEqual("eloConfig", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // CompTemplateConfigGet
                bThrown = false;
                try
                {
                    // null tid
                    stats.CompTemplateConfigGet(
                        null,
                        0, 
                        uiTemplateId,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.CompTemplateConfigGet(
                        tid,
                        1, 
                        uiTemplateId,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.CompTemplateConfigGet(
                        tid,
                        -1, 
                        uiTemplateId,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // uiTemplateId too large
                    stats.CompTemplateConfigGet(
                        tid,
                        0, 
                        16,
                        out leaderboardResetInterval,
                        out uiAttachmentCount,
                        out uiMaxAttachmentSize,
                        out uiDecayDays,
                        out bRequireArbitration,
                        out bIsTeam,
                        out eloConfig);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("uiTemplateId", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // there's no templates defined yet, so the maps should be
                // empty
                SortedList sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListTemplateMap.Count);
                SortedList sortedListPartitionMap = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListPartitionMap.Count);
                SortedList sortedListTitleMap = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(0, sortedListTitleMap.Count);

                uiTemplateId = 14;

                ELBReset leaderboardResetIntervalIn 
                    = ELBReset.ResetEveryWeek;
                uint uiAttachmentCountIn = 1;
                uint uiMaxAttachmentSizeIn = 2;
                uint uiDecayDaysIn = 3;
                bool bRequireArbitrationIn = false;
                bool bIsTeamIn = true;
                CELOConfig eloConfigIn 
                    = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:0,1:0");

                ELBReset leaderboardResetIntervalOut 
                    = ELBReset.ResetNever;
                uint uiAttachmentCountOut;
                uint uiMaxAttachmentSizeOut;
                uint uiDecayDaysOut;
                bool bRequireArbitrationOut;
                bool bIsTeamOut;
                CELOConfig eloConfigOut;

                // create a template in report only mode
                stats.CompTemplateConfigSet(
                    tid,
                    0,
                    uiTemplateId, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    true);

                // because the call was report only, the template map should
                // still be empty
                sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListTemplateMap.Count);

                // and CompTemplateConfigGet should indicate that the template
                // is not there.
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsFalse(bFound);

                // now create the template for real
                stats.CompTemplateConfigSet(
                    tid,
                    0,
                    uiTemplateId, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // it should show up in the template map now
                sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(1, sortedListTemplateMap.Count);
                Assert.IsTrue(((bool[])sortedListTemplateMap[uiTemplateId])[0]);

                // this should also make it show up in the title map, but not the
                // partition map
                sortedListTitleMap = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(1, sortedListTitleMap.Count);
                Assert.IsTrue(((bool[])sortedListTitleMap[tid.uiTitleId])[0]);
                sortedListPartitionMap = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListPartitionMap.Count);

                // and we should be able to retrieve it
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                // check that the definition matches what we set
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // if we try to change ANYTHING about a competition template,
                // the call should fail.
                bThrown = false;
                try
                {
                    stats.CompTemplateConfigSet(
                        tid,
                        0,
                        uiTemplateId, 
                        leaderboardResetIntervalIn,
                        uiAttachmentCountIn+1, // note change
                        uiMaxAttachmentSizeIn,
                        uiDecayDaysIn,
                        bRequireArbitrationIn,
                        bIsTeamIn,
                        eloConfigIn,
                        false);
                }
                catch (CStatsException e)
                {
                    Assert.IsFalse(e.Message.IndexOf("Changing competition templates is not supported") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // confirm that the previous call didn't actually change the
                // competition template definition
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(eloConfigIn.ToStatsDBString(), eloConfigOut.ToStatsDBString());

                // now create a second template, no ELO this time
                eloConfigIn = null;
                stats.CompTemplateConfigSet(
                    tid,
                    0,
                    uiTemplateId + 1, 
                    leaderboardResetIntervalIn,
                    uiAttachmentCountIn,
                    uiMaxAttachmentSizeIn,
                    uiDecayDaysIn,
                    bRequireArbitrationIn,
                    bIsTeamIn,
                    eloConfigIn,
                    false);

                // check that it was created correctly
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId + 1, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(leaderboardResetIntervalIn, leaderboardResetIntervalOut);
                Assert.AreEqual(uiAttachmentCountIn, uiAttachmentCountOut);
                Assert.AreEqual(uiMaxAttachmentSizeIn, uiMaxAttachmentSizeOut);
                Assert.AreEqual(uiDecayDaysIn, uiDecayDaysOut);
                Assert.AreEqual(bRequireArbitrationIn, bRequireArbitrationOut);
                Assert.AreEqual(bIsTeamIn, bIsTeamOut);
                Assert.AreEqual(null, eloConfigOut);

                // check that both templates are listed in the map
                sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListTemplateMap.Count);
                Assert.IsTrue(((bool[])sortedListTemplateMap[uiTemplateId])[0]);
                Assert.IsTrue(((bool[])sortedListTemplateMap[uiTemplateId+1])[0]);

                // do parameter validation testing on the Partition calls

                // CompPartitionCreate
                bThrown = false;
                try
                {
                    // null tid
                    stats.CompPartitionCreate(null, 1, 0, true);
                }
                catch (ArgumentNullException e)
                {
                    Assert.AreEqual("tid", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too large
                    stats.CompPartitionCreate(tid, 1, 0, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // iStatsDatabase too small
                    stats.CompPartitionCreate(tid, -1, 0, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("iStatsDatabase", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                bThrown = false;
                try
                {
                    // uiPartition too large
                    stats.CompPartitionCreate(tid, 0, 4, true);
                }
                catch (ArgumentOutOfRangeException e)
                {
                    Assert.AreEqual("uiPartition", e.ParamName);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // at this point, the competition partition map
                // should be empty
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListPartitionMap.Count);

                // try creating partition 1, report only first of course
                stats.CompPartitionCreate(tid, 0, 1, true);

                // since it was report only, we should still have no
                // partitions
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListPartitionMap.Count);

                // now do it for real
                stats.CompPartitionCreate(tid, 0, 1, false);

                // now we should have partition 1 on server 0
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(1, sortedListPartitionMap.Count);
                Assert.IsTrue(((bool[])sortedListPartitionMap[(uint)1])[0]);

                // create another one..
                stats.CompPartitionCreate(tid, 0, 3, false);

                // now we should have partitions 1 and 3 on server 0
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListPartitionMap.Count);
                Assert.IsTrue(((bool[])sortedListPartitionMap[(uint)1])[0]);
                Assert.IsTrue(((bool[])sortedListPartitionMap[(uint)3])[0]);

                // the title map should still only show one title
                sortedListTitleMap
                    = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(1, sortedListTitleMap.Count);
                Assert.IsTrue(((bool[])sortedListTitleMap[tid.uiTitleId])[0]);

                // if we create a partition for another title, the 
                // title map should have two entries
                CTitleId tid2 = new CTitleId(0xffff4007);
                stats.CompPartitionCreate(tid2, 0, 2, false);
                sortedListTitleMap
                    = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(2, sortedListTitleMap.Count);
                Assert.IsTrue(((bool[])sortedListTitleMap[tid.uiTitleId])[0]);
                Assert.IsTrue(((bool[])sortedListTitleMap[tid2.uiTitleId])[0]);

                // that does it for partitions

                // finally, nuke the title completely, and confirm that 
                // both the partitions and templates are cleaned up
                // this is the ONLY method supported for changing
                // templates or partitions

                // report only first, should do nothing
                stats.TitleDelete(tid, 0, true);

                // confirm stuff is still there.
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListPartitionMap.Count);
                Assert.IsTrue(((bool[])sortedListPartitionMap[(uint)1])[0]);
                Assert.IsTrue(((bool[])sortedListPartitionMap[(uint)3])[0]);

                sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(2, sortedListTemplateMap.Count);
                Assert.IsTrue(((bool[])sortedListTemplateMap[uiTemplateId])[0]);
                Assert.IsTrue(((bool[])sortedListTemplateMap[uiTemplateId+1])[0]);

                bFound = false;
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                bFound = false;
                bFound = stats.CompTemplateConfigGet(
                    tid,
                    0,
                    uiTemplateId+1, 
                    out leaderboardResetIntervalOut,
                    out uiAttachmentCountOut,
                    out uiMaxAttachmentSizeOut,
                    out uiDecayDaysOut,
                    out bRequireArbitrationOut,
                    out bIsTeamOut,
                    out eloConfigOut);
                Assert.IsTrue(bFound);

                // now for real
                stats.TitleDelete(tid, 0, false);

                // confirm stuff is gone
                sortedListPartitionMap 
                    = stats.CompPartitionGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListPartitionMap.Count);

                sortedListTemplateMap = stats.CompTemplateGetDatabaseMap(tid);
                Assert.AreEqual(0, sortedListTemplateMap.Count);

                // this should still have tid2 in it
                sortedListTitleMap
                    = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(1, sortedListTitleMap.Count);
                Assert.IsTrue(((bool[])sortedListTitleMap[tid2.uiTitleId])[0]);

                // nuke tid2 and confirm
                stats.TitleDelete(tid2, 0, false);
                sortedListTitleMap
                    = stats.CompTitleGetDatabaseMap();
                Assert.AreEqual(0, sortedListTitleMap.Count);

                // done! We can't test any multi server
                // stuff on localhost. That we'll have to test on testnet.
            }
            finally
            {
                stats.Close();
            }

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.CompTest complete");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CWebDBTest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CWebDBTest
    {
        [SetUp]
        public void CreateWebDBOnLocalhost()
        {
            CLog log = new CLog();
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBTestLocalhost.CreateWebDBOnLocalhost starting");
            CCreateWebDB.CreateWebDB(log);
            log.WriteLineV("Xbox.Tools.Framework.Test.CWebDBTestLocalhost.CreateWebDBOnLocalhost complete");
        }

        [Test]
        public void ConstructorTest()
        {
            CLog log = new CLog();
            CTitleId tid = new CTitleId(0xffff4006);
            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=webdb";

            CWebDB webDB = null;

            // parameter validation tests

            // passing null rgsConnectionStrings should throw ArgumentNullException
            bool bThrown = false;
            try
            {
                webDB = new CWebDB(null, log);
            }
            catch (ArgumentNullException e)
            {
                bThrown = true;
                Assert.AreEqual("sWebDBConnectionString", e.ParamName);
            }
            Assert.IsTrue(bThrown);

            // call with invalid connection string should throw a CWebDB exception
            // because it can't connect to the database
            bThrown = false;
            try
            {
                webDB = new CWebDB("invalid connection string", log);
            }
            catch (CWebDBException webDBException)
            {
                Assert.IsFalse(webDBException.Message.IndexOf("Opening a connection") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // this call should work, check the log output
            webDB = new CWebDB(sConnectionString, log);

            // have to call Close
            webDB.Close();

            // calling Close twice should be a noop
            webDB.Close();

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest: "
                + "calling constructor with null log - should be no log output");
            webDB = new CWebDB(sConnectionString, null);
            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest: "
                + "call will null log complete");
            webDB.Close();

            log.WriteLineV("Xbox.Tools.Framework.Test.CStatsTest.ConstructorTest complete");
        }

        [Test]
        public void TitleConfigTest()
        {
            CLog log = new CLog();
            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=webdb";

            CWebDB webDB = new CWebDB(sConnectionString, log);
            try
            {

                // first, confirm that the title list is empty
                CTitleId[] rgTid = webDB.TitleGetList();
                Assert.AreEqual(0, rgTid.Length);

                // now create a new title config, report only first
                CTitleId tid = new CTitleId(0xffff4006);
                EESRBRating ESRBRatingIn = EESRBRating.Mature;
                CLocale locDefaultIn = new CLocale("en-US");
                uint uiClusterIdIn = 1;

                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    true);

                // because it was report only, there should still be nothing in the list
                rgTid = webDB.TitleGetList();
                Assert.AreEqual(0, rgTid.Length);

                // and TitleConfigGet should return false
                EESRBRating ESRBRatingOut;
                CLocale locDefaultOut;
                uint uiClusterIdOut;

                bool bFound = true;
                bFound = webDB.TitleConfigGet(
                    tid,
                    out ESRBRatingOut,
                    out locDefaultOut,
                    out uiClusterIdOut);
                Assert.IsFalse(bFound);

                // now do it for real
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // the list should report one title and it should match
                rgTid = webDB.TitleGetList();
                Assert.AreEqual(1, rgTid.Length);
                Assert.AreEqual(tid.ToString(), rgTid[0].ToString());

                // we should be able to get the config, and the params should match
                bFound = false;
                bFound = webDB.TitleConfigGet(
                    tid,
                    out ESRBRatingOut,
                    out locDefaultOut,
                    out uiClusterIdOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(ESRBRatingIn, ESRBRatingOut);
                Assert.AreEqual(locDefaultIn.ToString(), locDefaultOut.ToString());
                Assert.AreEqual(uiClusterIdIn, uiClusterIdOut);

                // add a second tid and confirm that the list how has two titles in it
                CTitleId tid2 = new CTitleId(0xffff4007);
                webDB.TitleConfigSet(
                    tid2,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                rgTid = webDB.TitleGetList();
                Assert.AreEqual(2, rgTid.Length);
                Assert.AreEqual(tid.ToString(), rgTid[0].ToString());
                Assert.AreEqual(tid2.ToString(), rgTid[1].ToString());

                // now delete the second title and confirm
                webDB.TitleDelete(tid2, false);
                rgTid = webDB.TitleGetList();
                Assert.AreEqual(1, rgTid.Length);
                Assert.AreEqual(tid.ToString(), rgTid[0].ToString());

                bFound = true;
                bFound = webDB.TitleConfigGet(
                    tid2,
                    out ESRBRatingOut,
                    out locDefaultOut,
                    out uiClusterIdOut);
                Assert.IsFalse(bFound);

                // check that there are currently no title descriptions
                SortedList sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(0, sortedList.Count);

                // set a title description for en-US, report only mode first
                CLocale localeEnUS = new CLocale("en-US");
                string sDescEnUS = "en-US title description";
                webDB.TitleDescSet(
                    tid,
                    localeEnUS,
                    sDescEnUS,
                    true);

                // should still be nothing there
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(0, sortedList.Count);

                // now add it for real
                webDB.TitleDescSet(
                    tid,
                    localeEnUS,
                    sDescEnUS,
                    false);

                // should be there now
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDescEnUS, (string)sortedList[localeEnUS.ToString()]);

                // add another, and check again
                CLocale localeEnCA = new CLocale("en-CA");
                string sDescEnCA = "en-CA title description";
                webDB.TitleDescSet(
                    tid,
                    localeEnCA,
                    sDescEnCA,
                    false);
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDescEnUS, (string)sortedList[localeEnUS.ToString()]);
                Assert.AreEqual(sDescEnCA, (string)sortedList[localeEnCA.ToString()]);

                // update a description, and confirm
                string sDescEnUS2 = "en-US updated title description";
                webDB.TitleDescSet(
                    tid,
                    localeEnUS,
                    sDescEnUS2,
                    false);
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDescEnUS2, (string)sortedList[localeEnUS.ToString()]);
                Assert.AreEqual(sDescEnCA, (string)sortedList[localeEnCA.ToString()]);

                // now delete one, report only first
                webDB.TitleDescDelete(
                    tid,
                    localeEnUS.ToString(),
                    true);

                // should be no change
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDescEnUS2, (string)sortedList[localeEnUS.ToString()]);
                Assert.AreEqual(sDescEnCA, (string)sortedList[localeEnCA.ToString()]);

                // now for real
                webDB.TitleDescDelete(
                    tid,
                    localeEnUS.ToString(),
                    false);

                // en-US should be gone
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDescEnCA, (string)sortedList[localeEnCA.ToString()]);

                // TitleDelete should clean up everything, report only first
                webDB.TitleDelete(tid, true);

                // should still be there
                rgTid = webDB.TitleGetList();
                Assert.AreEqual(1, rgTid.Length);
                Assert.AreEqual(tid.ToString(), rgTid[0].ToString());
                bFound = false;
                bFound = webDB.TitleConfigGet(
                    tid,
                    out ESRBRatingOut,
                    out locDefaultOut,
                    out uiClusterIdOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(ESRBRatingIn, ESRBRatingOut);
                Assert.AreEqual(locDefaultIn.ToString(), locDefaultOut.ToString());
                Assert.AreEqual(uiClusterIdIn, uiClusterIdOut);
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDescEnCA, (string)sortedList[localeEnCA.ToString()]);

                // now for real
                webDB.TitleDelete(tid, false);

                // should be gone
                rgTid = webDB.TitleGetList();
                Assert.AreEqual(0, rgTid.Length);
                sortedList  = webDB.TitleDescGetList(tid);
                Assert.AreEqual(0, sortedList.Count);
            }
            finally
            {
                webDB.Close();
            }

            return;
        }

        [Test]
        public void LBConfigTest()
        {
            CLog log = new CLog();
            string sConnectionString = "Server=localhost;Trusted_Connection=sspi;Pooling=false;Database=webdb";

            CWebDB webDB = new CWebDB(sConnectionString, log);
            try
            {
                CTitleId tid = new CTitleId(0xffff4006);
                EESRBRating ESRBRatingIn = EESRBRating.Mature;
                CLocale locDefaultIn = new CLocale("en-US");
                uint uiClusterIdIn = 1;
                uint[] rgui;
                bool bThrown;
                bool bFound;

                // get the leaderboard list for a title that doesn't exist
                // should be empty
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(0, rgui.Length);

                // try creating a leaderboard for a title that doesn't exist
                // should throw
                uint uiLBNum = 32;
                ELBReset resetInterval = ELBReset.ResetEveryWeek;
                uint uiEntriesPerCacheLine = 50;
                uint uiExpirationSeconds = 60;
                EWebLBType webLBType = EWebLBType.RegularTeam;
                bool bDontList = false;
                bThrown = false;
                try
                {
                    webDB.WebLBConfigSet(
                        tid,
                        uiLBNum,
                        resetInterval,
                        uiEntriesPerCacheLine,
                        uiExpirationSeconds,
                        webLBType,
                        bDontList,
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                    bThrown = true;
                }
                Assert.IsTrue(bThrown);

                // create a title config so we can create leaderboards
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // now create the leaderboard, report only first
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    true);

                // leaderboard list should still be empty
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(0, rgui.Length);

                // and we shouldn't be able to get the config
                ELBReset resetIntervalOut;
                uint uiEntriesPerCacheLineOut;
                uint uiExpirationSecondsOut;
                EWebLBType webLBTypeOut;
                bool bDontListOut;
                bFound = true;
                bFound = webDB.WebLBConfigGet(
                    tid,
                    uiLBNum,
                    out resetIntervalOut,
                    out uiEntriesPerCacheLineOut,
                    out uiExpirationSecondsOut,
                    out webLBTypeOut,
                    out bDontListOut);
                Assert.IsFalse(bFound);

                // now for real
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // leaderboard list should have 1
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(1, rgui.Length);
                Assert.AreEqual(uiLBNum, rgui[0]);

                // and we should be able to get the config
                bFound = false;
                bFound = webDB.WebLBConfigGet(
                    tid,
                    uiLBNum,
                    out resetIntervalOut,
                    out uiEntriesPerCacheLineOut,
                    out uiExpirationSecondsOut,
                    out webLBTypeOut,
                    out bDontListOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(resetInterval, resetIntervalOut);
                Assert.AreEqual(uiEntriesPerCacheLine, uiEntriesPerCacheLineOut);
                Assert.AreEqual(uiExpirationSeconds, uiExpirationSecondsOut);
                Assert.AreEqual(webLBType, webLBTypeOut);
                Assert.AreEqual(bDontList, bDontListOut);

                // create a second one
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum+1,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // leaderboard list should have 2
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(2, rgui.Length);
                Assert.AreEqual(uiLBNum, rgui[0]);
                Assert.AreEqual(uiLBNum+1, rgui[1]);

                // update the second one
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum+1,
                    resetInterval,
                    uiEntriesPerCacheLine+1,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // check that the update took
                bFound = false;
                bFound = webDB.WebLBConfigGet(
                    tid,
                    uiLBNum+1,
                    out resetIntervalOut,
                    out uiEntriesPerCacheLineOut,
                    out uiExpirationSecondsOut,
                    out webLBTypeOut,
                    out bDontListOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(resetInterval, resetIntervalOut);
                Assert.AreEqual(uiEntriesPerCacheLine+1, uiEntriesPerCacheLineOut);
                Assert.AreEqual(uiExpirationSeconds, uiExpirationSecondsOut);
                Assert.AreEqual(webLBType, webLBTypeOut);
                Assert.AreEqual(bDontList, bDontListOut);

                // now delete the second one, report only first
                webDB.WebLBDelete(
                    tid,
                    uiLBNum+1,
                    true);

                // leaderboard list should have 2
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(2, rgui.Length);
                Assert.AreEqual(uiLBNum, rgui[0]);
                Assert.AreEqual(uiLBNum+1, rgui[1]);

                // now for real
                webDB.WebLBDelete(
                    tid,
                    uiLBNum+1,
                    false);

                // leaderboard list should have 1 now
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(1, rgui.Length);
                Assert.AreEqual(uiLBNum, rgui[0]);

                // nuke the title, and confirm that the 
                // leaderboard is cleaned up as well
                webDB.TitleDelete(tid, false);

                // leaderboard list should be empty now
                rgui = webDB.WebLBGetList(tid);
                Assert.AreEqual(0, rgui.Length);

                // now we test the leaderboard description stuff

                // recreate the title
                // create a title config so we can create leaderboards
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // get a leaderboard description list for a non-existant
                // leaderboard
                SortedList sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // try to add a leaderboard description for a non-existant
                // leaderboard, should throw
                CLocale locale = new CLocale("en-US");
                string sDesc = "en-US LB Desc";
                bThrown = false;
                try
                {
                    webDB.WebLBDescSet(
                        tid, 
                        uiLBNum, 
                        locale, 
                        sDesc, 
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                }

                // add the leaderboard
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // now try adding the description, report only first
                webDB.WebLBDescSet(
                    tid,
                    uiLBNum,
                    locale,
                    sDesc,
                    true);

                // should be no description
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // now for real 
                webDB.WebLBDescSet(
                    tid, 
                    uiLBNum, 
                    locale, 
                    sDesc, 
                    false);

                // should be 1 description
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);

                // add another one
                CLocale locale2 = new CLocale("en-CA");
                string sDesc2 = "en-CA LB Desc";
                webDB.WebLBDescSet(
                    tid, 
                    uiLBNum, 
                    locale2, 
                    sDesc2, 
                    false);

                // should be 2 descriptions now
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // delete one description, report only first
                webDB.WebLBDescDelete(
                    tid,
                    uiLBNum,
                    locale.ToString(),
                    true);

                // should still be there.
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // now for real
                webDB.WebLBDescDelete(
                    tid,
                    uiLBNum,
                    locale.ToString(),
                    false);

                // should still be one there.
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // now delete the title, and confirm that the last 
                // description get cleaned up
                webDB.TitleDelete(tid, false);
                sortedList = webDB.WebLBDescGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // next we test raw attributes

                // recreate the title
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // get a raw attribute list for a non-existant
                // leaderboard
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // try to add a raw attribute to a non-existant
                // leaderboard, should throw
                uint uiAttrId = 50;
                bool bIsPuid = true;
                bThrown = false;
                try
                {
                    webDB.WebLBAttrSet(
                        tid, 
                        uiLBNum, 
                        uiAttrId,
                        bIsPuid,
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                }

                // add the leaderboard
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // now try adding the raw attribute, report only first
                webDB.WebLBAttrSet(
                    tid, 
                    uiLBNum, 
                    uiAttrId,
                    bIsPuid,
                    true);

                // should be no raw attributes
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // now for real 
                webDB.WebLBAttrSet(
                    tid, 
                    uiLBNum, 
                    uiAttrId,
                    bIsPuid,
                    false);

                // should be 1 raw attribute
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(bIsPuid, (bool)sortedList[uiAttrId]);

                // add another one
                webDB.WebLBAttrSet(
                    tid, 
                    uiLBNum, 
                    uiAttrId+1,
                    !bIsPuid,
                    false);

                // should be 2 raw attributes now
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(bIsPuid, (bool)sortedList[uiAttrId]);
                Assert.AreEqual(!bIsPuid, (bool)sortedList[uiAttrId+1]);

                // delete one description, report only first
                webDB.WebLBAttrDelete(
                    tid,
                    uiLBNum,
                    uiAttrId,
                    true);

                // should still be there.
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(bIsPuid, (bool)sortedList[uiAttrId]);
                Assert.AreEqual(!bIsPuid, (bool)sortedList[uiAttrId+1]);

                // now for real
                webDB.WebLBAttrDelete(
                    tid,
                    uiLBNum,
                    uiAttrId,
                    false);

                // should still be one there.
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(!bIsPuid, (bool)sortedList[uiAttrId+1]);

                // now delete the title, and confirm that the last 
                // description get cleaned up
                webDB.TitleDelete(tid, false);
                sortedList = webDB.WebLBAttrGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, sortedList.Count);

                // next up, formatted values!

                // recreate the title
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // get a formatted value list for a non-existant
                // leaderboard
                string [] rgs;
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, rgs.Length);

                // try to add a formatted value to a non-existant
                // leaderboard, should throw
                string sName = "1";
                EWebValueReturnType returnType = EWebValueReturnType.Hours;
                string sFormula = "attr[0]";
                bThrown = false;
                try
                {
                    webDB.WebLBValueSet(
                        tid, 
                        uiLBNum, 
                        sName,
                        returnType,
                        sFormula,
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                }

                // add the leaderboard
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // now try adding the formatted value, report only first
                webDB.WebLBValueSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    returnType,
                    sFormula,
                    true);

                // should be no formatted values
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, rgs.Length);

                EWebValueReturnType returnTypeOut;
                string sFormulaOut;

                bFound = true;
                bFound = webDB.WebLBValueGet(
                    tid,
                    uiLBNum,
                    sName,
                    out returnTypeOut,
                    out sFormulaOut);
                Assert.IsFalse(bFound);

                // now for real 
                webDB.WebLBValueSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    returnType,
                    sFormula,
                    false);

                // should now be 1 formatted value
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, rgs.Length);
                Assert.AreEqual(sName, rgs[0]);

                // check it
                bFound = false;
                bFound = webDB.WebLBValueGet(
                    tid,
                    uiLBNum,
                    sName,
                    out returnTypeOut,
                    out sFormulaOut);
                Assert.IsTrue(bFound);
                Assert.AreEqual(returnType, returnTypeOut);
                Assert.AreEqual(sFormula, sFormulaOut);

                // add another one
                string sName2 = "2";
                EWebValueReturnType returnType2 = EWebValueReturnType.Gamertag;
                string sFormula2 = "attr[2]";

                webDB.WebLBValueSet(
                    tid, 
                    uiLBNum, 
                    sName2,
                    returnType2,
                    sFormula2,
                    false);

                // should be 2 formatted values now
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, rgs.Length);
                Assert.AreEqual(sName, rgs[0]);
                Assert.AreEqual(sName2, rgs[1]);

                // delete one formatted value, report only first
                webDB.WebLBValueDelete(
                    tid,
                    uiLBNum,
                    sName,
                    true);

                // should still be there.
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(2, rgs.Length);
                Assert.AreEqual(sName, rgs[0]);
                Assert.AreEqual(sName2, rgs[1]);

                // now for real
                webDB.WebLBValueDelete(
                    tid,
                    uiLBNum,
                    sName,
                    false);

                // should still be one there.
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(1, rgs.Length);
                Assert.AreEqual(sName2, rgs[0]);

                // now delete the title, and confirm that the last 
                // formatted value gets cleaned up
                webDB.TitleDelete(tid, false);
                rgs = webDB.WebLBValueGetList(
                    tid,
                    uiLBNum);
                Assert.AreEqual(0, rgs.Length);

                // and lastly we come to the formatted value description stuff

                // recreate the title
                webDB.TitleConfigSet(
                    tid,
                    ESRBRatingIn,
                    locDefaultIn,
                    uiClusterIdIn,
                    false);

                // get a formatted value list for a non-existant
                // leaderboard
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(0, sortedList.Count);

                // try to add a formatted value description to a non-existant
                // leaderboard, should throw
                sName = "1";
                returnType = EWebValueReturnType.Hours;
                sFormula = "attr[0]";
                locale = new CLocale("en-US");
                sDesc = "en-US formatted value description";
                bThrown = false;
                try
                {
                    webDB.WebLBValueDescSet(
                        tid, 
                        uiLBNum, 
                        sName,
                        locale,
                        sDesc,
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                }

                // add the leaderboard
                webDB.WebLBConfigSet(
                    tid,
                    uiLBNum,
                    resetInterval,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    webLBType,
                    bDontList,
                    false);

                // the leaderboard exists now, but the formatted value doesn't,
                // so this should still throw
                bThrown = false;
                try
                {
                    webDB.WebLBValueDescSet(
                        tid, 
                        uiLBNum, 
                        sName,
                        locale,
                        sDesc,
                        false);
                }
                catch (CWebDBException webDBException)
                {
                    Assert.IsFalse(webDBException.Message.IndexOf("caused a SqlException") == -1);
                }

                // now finally add the formatted value
                webDB.WebLBValueSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    returnType,
                    sFormula,
                    false);

                // now we try adding the descriptions, report only first
                webDB.WebLBValueDescSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    locale,
                    sDesc,
                    true);

                // should still be no descriptions
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(0, sortedList.Count);

                // now add it for real
                webDB.WebLBValueDescSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    locale,
                    sDesc,
                    false);

                // now we should see it
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);

                // add another one
                locale2 = new CLocale("en-CA");
                sDesc2 = "en-CA formatted value description";
                webDB.WebLBValueDescSet(
                    tid, 
                    uiLBNum, 
                    sName,
                    locale2,
                    sDesc2,
                    false);

                // now we should see both
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // delete one description, report only first
                webDB.WebLBValueDescDelete(
                    tid,
                    uiLBNum,
                    sName,
                    locale.ToString(),
                    true);

                // should still be there.
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(2, sortedList.Count);
                Assert.AreEqual(sDesc, (string)sortedList[locale.ToString()]);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // now for real
                webDB.WebLBValueDescDelete(
                    tid,
                    uiLBNum,
                    sName,
                    locale.ToString(),
                    false);

                // should still be one there.
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(1, sortedList.Count);
                Assert.AreEqual(sDesc2, (string)sortedList[locale2.ToString()]);

                // now delete the title, and confirm that the last 
                // formatted value gets cleaned up
                webDB.TitleDelete(tid, false);
                sortedList = webDB.WebLBValueDescGetList(
                    tid,
                    uiLBNum,
                    sName);
                Assert.AreEqual(0, sortedList.Count);

                // done! all done!
            }
            finally
            {
                webDB.Close();
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CXscSubmitTest.cs ===
using System;
using System.Collections;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CXscSubmitTest
    {
        private const string c_sSdPort = "localhost:1666";
        private const string c_sSdClient = "tmr_unittest";
        private readonly CTitleId c_tid1 = new CTitleId(0xffff4006);

        [SetUp]
        public void SetUp()
        {
            CLog log = new CLog();
            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);

            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }

            repository.ServiceDefaultStatsLimitsDelete();
            repository.ServiceSubmit("CXscSubmitTest.Setup");
        }

        [Test]
        public void SubmitTest()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;
            CXsc xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            CRepository repository = new CRepository(c_sSdPort, c_sSdClient, log);

            // setup the test title
            repository.TitleCreate(c_tid1);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;
            SortedList sl;

            int iLBCount;

            // parameter validation first
            bThrown = false;
            try
            {
                CXscSubmit.Submit(null, xsc, repository, false, out iLBCount, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CXscSubmit.Submit(c_tid1, null, repository, false, out iLBCount, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("xsc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CXscSubmit.Submit(c_tid1, xsc, null, false, out iLBCount, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("repository", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                CXscSubmit.Submit(c_tid1, xsc, repository, false, out iLBCount, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("log", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            CXscSubmit.Submit(c_tid1, xsc, repository, false, out iLBCount, log);
            Assert.AreEqual(6, iLBCount);

            // confirm the repository looks the way we expect it to
            repository.DiscardCachedFiles();

            CLocale locDefault = null;
            Assert.IsTrue(repository.TitleDefaultLocaleGet(c_tid1, ref locDefault));
            Assert.AreEqual("en-CA", locDefault.ToString());

            // maxreads and maxwrites should've been set.
            uint uiMaxWrites = 0;
            uint uiMaxReads = 0;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(5, uiMaxWrites);
            Assert.AreEqual(5, uiMaxReads);

            // now set them to something other than the default, and confirm
            // they are not changed by future submits.
            repository.TitleLBLimitsSet(c_tid1, 10, 10);

            // should be two leaderboards
            uint[] rgui = repository.TitleLBGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // and two unit leaderboards
            rgui = repository.TitleUnitGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(3, rgui[0]);
            Assert.AreEqual(4, rgui[1]);

            // and two competition templates
            rgui = repository.TitleCompGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // should be a unit config
            int iUnitDatabase = -1;
            double dDecayFactor = -1.0;
            uint uiMaxAvailUnits = 0;
            uint uiSizeUnitCache = 0;
            Assert.IsTrue(repository.TitleUnitConfigGet(
                c_tid1, 
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(0, iUnitDatabase);
            // note multiply due to bug 36427
            Assert.AreEqual(90.0*60*24, dDecayFactor);
            Assert.AreEqual(100, uiMaxAvailUnits);
            Assert.AreEqual(100, uiSizeUnitCache);

            // examine leaderboard 1
            uiLBNum = 1;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(0, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine leaderboard 2
            uiLBNum = 2;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(0, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 Desc", sl["en-US"]);

            sl = repository.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(5, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(true, sl[(uint)4]);
            Assert.AreEqual(false, sl[(uint)5]);

            string[] rgs = repository.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);
            
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string sFormula = null;
            
            repository.TitleLBValueGet(c_tid1, uiLBNum, "65", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[1]", sFormula);
            sl = repository.TitleLBValueDescGetList(c_tid1, uiLBNum, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV1", sl["en-US"]);

            repository.TitleLBValueGet(c_tid1, uiLBNum, "66", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Team, returnType);
            Assert.AreEqual("attr[2]", sFormula);
            sl = repository.TitleLBValueDescGetList(c_tid1, uiLBNum, "66");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV2", sl["en-US"]);

            // examine unit leaderboard 3
            uiLBNum = 3;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine unit leaderboard 4
            uiLBNum = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 Desc", sl["en-US"]);

            sl = repository.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(3, sl.Count);
            Assert.AreEqual(false, sl[(uint)6]);
            Assert.AreEqual(true, sl[(uint)7]);
            Assert.AreEqual(false, sl[(uint)12]);

            rgs = repository.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleUnitValueGet(c_tid1, uiLBNum, "65", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]? 1 : 0", sFormula);
            sl = repository.TitleUnitValueDescGetList(c_tid1, uiLBNum, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 FV1", sl["en-US"]);

            repository.TitleUnitValueGet(c_tid1, uiLBNum, "66", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[7]", sFormula);
            sl = repository.TitleUnitValueDescGetList(c_tid1, uiLBNum, "66");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 FV2", sl["en-US"]);

            // examine competition template 1
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine competition template 2
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 Desc", sl["en-US"]);

            sl = repository.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(3, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);

            rgs = repository.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("72", rgs[0]);
            Assert.AreEqual("89", rgs[1]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleCompValueGet(c_tid1, uiLBNum, "72", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("true", sFormula);
            sl = repository.TitleCompValueDescGetList(c_tid1, uiLBNum, "72");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 FV1", sl["en-US"]);

            repository.TitleCompValueGet(c_tid1, uiLBNum, "89", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[100]", sFormula);
            sl = repository.TitleCompValueDescGetList(c_tid1, uiLBNum, "89");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 FV2", sl["en-US"]);

            // now apply an xsc that:
            //      removes leaderboard 1
            //      changes basic parameters on leaderboard 2
            //      removes a leaderboard description from leaderboard 2
            //      updates a leaderboard description on leaderboard 2
            //      removes an attribute from leaderboard 2
            //      updates an attribute on leaderboard 2
            //      removes a formatted value from leaderboard 2
            //      updates a formatted value on leaderboard 2
            //      removes a description from the remaining formatted value on leaderboard 2
            //      updates a description on the remaining formatted value on leaderboard 2
            //
            //      removes unit leaderboard 3
            //      changes basic parameters on unit leaderboard 4
            //      removes a leaderboard description from unit leaderboard 4
            //      updates a leaderboard description on unit leaderboard 4
            //      removes an attribute from unit leaderboard 4
            //      updates an attribute on unit leaderboard 4
            //      removes a formatted value from unit leaderboard 4
            //      updates a formatted value on unit leaderboard 4
            //      removes a description from the remaining formatted value on unit leaderboard 4
            //      updates a description on the remaining formatted value on unit leaderboard 4
            //
            //      removes competition template 1
            //      changes basic parameters on competition template 2
            //      removes a leaderboard description from competition template 2
            //      updates a leaderboard description on competition template 2
            //      removes an attribute from competition template 2
            //      updates an attribute on competition template 2
            //      removes a formatted value from competition template 2
            //      updates a formatted value on competition template 2
            //      removes a description from the remaining formatted value on competition template 2
            //      updates a description on the remaining formatted value on competition template 2
            //
            //      changes the leaderboard decay constant
            //
            xsc = new CXsc(@".\xsc\FFFF4006-v3-modified.xsc", log);
            CXscSubmit.Submit(c_tid1, xsc, repository, false, out iLBCount, log);
            Assert.AreEqual(3, iLBCount);

            // confirm the repository looks the way we expect it to
            // leaderboard 1 should be gone, only 2 remains
            repository.DiscardCachedFiles();

            // maxreads and maxwrites should not have been changed
            uiMaxWrites = 0;
            uiMaxReads = 0;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(10, uiMaxWrites);
            Assert.AreEqual(10, uiMaxReads);

            // only one leaderboard left
            rgui = repository.TitleLBGetList(c_tid1);
            Assert.AreEqual(1, rgui.Length);
            Assert.AreEqual(2, rgui[0]);

            // and one unit leaderboard
            rgui = repository.TitleUnitGetList(c_tid1);
            Assert.AreEqual(1, rgui.Length);
            Assert.AreEqual(4, rgui[0]);

            // and one competition template
            rgui = repository.TitleCompGetList(c_tid1);
            Assert.AreEqual(1, rgui.Length);
            Assert.AreEqual(2, rgui[0]);

            // should be a unit config
            iUnitDatabase = -1;
            dDecayFactor = -1.0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;
            Assert.IsTrue(repository.TitleUnitConfigGet(
                c_tid1, 
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(0, iUnitDatabase);
            // note multiply due to bug 36427
            Assert.AreEqual(60.0*60*24, dDecayFactor);
            Assert.AreEqual(100, uiMaxAvailUnits);
            Assert.AreEqual(100, uiSizeUnitCache);

            // examine leaderboard 2
            // stuff has changed
            uiLBNum = 2;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 54;
            uiExpirationSeconds = 904;
            bDontList = true;
            Assert.IsTrue(repository.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(0, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEvery2Months, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=1200;ELO_NEW=16000;ELO_C=0:600,20:500", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LB2 Desc Updated", sl["en-US"]);

            sl = repository.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(4, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(false, sl[(uint)5]);

            rgs = repository.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("66", rgs[0]);
            
            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleLBValueGet(c_tid1, uiLBNum, "66", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[2+2]", sFormula);
            sl = repository.TitleLBValueDescGetList(c_tid1, uiLBNum, "66");
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LB2 FV2 Updated", sl["en-US"]);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LB2 Desc Updated", sl["en-US"]);

            // examine unit leaderboard 4
            uiLBNum = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LB4 Desc updated", sl["en-US"]);

            sl = repository.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)7]);

            rgs = repository.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("65", rgs[0]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleUnitValueGet(c_tid1, uiLBNum, "65", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[4]", sFormula);
            sl = repository.TitleUnitValueDescGetList(c_tid1, uiLBNum, "65");
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LB4 FV1 updated", sl["en-US"]);

            // examine competition template 2
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LBT2 Desc updated", sl["en-US"]);

            sl = repository.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(true, sl[(uint)1]);

            rgs = repository.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("72", rgs[0]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleCompValueGet(c_tid1, uiLBNum, "72", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[2]", sFormula);
            sl = repository.TitleCompValueDescGetList(c_tid1, uiLBNum, "72");
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("enUS LBT2 FV1 updated", sl["en-US"]);

            // now we want to make sure that the values we expect to persist across 
            // syncs actually do persist across syncs.
            //
            // on leaderboards these are:
            // iStatsDB
            // uiEntriesPerCacheLine
            // uiExpirationSeconds
            // bDontList
            //
            // on unit leaderboards and competition templates, these are:
            // uiEntriesPerCacheLine
            // uiExpirationSeconds
            // bDontList
            // 
            // So, for this test we update the definition of leaderboard 2, 
            // unit leaderboard 4, and competition template 2 to change the
            // values above, and then sync the original file again.
            // 
            // After the sync, the defintions should match the xsc, but the
            // values noted above should not have been returned to their
            // default values.
            //
            // We also preserve the whole title unit config, except for the 
            // decay factor
            uiLBNum = 2;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetEvery3Months;
            uiAttachmentCount = 1;
            uiMaxAttachmentSize = 2;
            uiDecayDays = 3;
            uiMaxRatingCount = 4;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;
            repository.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 4;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            repository.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetEvery3Months;
            uiAttachmentCount = 1;
            uiMaxAttachmentSize = 2;
            uiDecayDays = 3;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 53;
            uiExpirationSeconds = 903;
            bDontList = true;
            repository.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            iUnitDatabase = 2;
            dDecayFactor = -10.0;
            uiMaxAvailUnits = 99;
            uiSizeUnitCache = 98;
            repository.TitleUnitConfigSet(
                c_tid1, 
                iUnitDatabase,
                dDecayFactor,
                uiMaxAvailUnits,
                uiSizeUnitCache);

            xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            CXscSubmit.Submit(c_tid1, xsc, repository, false, out iLBCount, log);
            Assert.AreEqual(6, iLBCount);

            repository.DiscardCachedFiles();

            // maxreads and maxwrites should not have been changed
            uiMaxWrites = 0;
            uiMaxReads = 0;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(10, uiMaxWrites);
            Assert.AreEqual(10, uiMaxReads);

            // should be two leaderboards
            rgui = repository.TitleLBGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // and two unit leaderboards
            rgui = repository.TitleUnitGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(3, rgui[0]);
            Assert.AreEqual(4, rgui[1]);

            // and two competition templates
            rgui = repository.TitleCompGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // should be a unit config
            iUnitDatabase = -1;
            dDecayFactor = -1.0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;
            Assert.IsTrue(repository.TitleUnitConfigGet(
                c_tid1, 
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(2, iUnitDatabase);
            // note multiply due to bug 36427
            Assert.AreEqual(90.0*60*24, dDecayFactor);
            Assert.AreEqual(99, uiMaxAvailUnits);
            Assert.AreEqual(98, uiSizeUnitCache);

            // examine leaderboard 1
            uiLBNum = 1;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(0, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine leaderboard 2
            uiLBNum = 2;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(1, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(51, uiEntriesPerCacheLine);
            Assert.AreEqual(901, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            sl = repository.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 Desc", sl["en-US"]);

            sl = repository.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(5, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(true, sl[(uint)4]);
            Assert.AreEqual(false, sl[(uint)5]);

            rgs = repository.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);
            
            returnType = EWebValueReturnType.String;
            sFormula = null;
            
            repository.TitleLBValueGet(c_tid1, uiLBNum, "65", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[1]", sFormula);
            sl = repository.TitleLBValueDescGetList(c_tid1, uiLBNum, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV1", sl["en-US"]);

            repository.TitleLBValueGet(c_tid1, uiLBNum, "66", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Team, returnType);
            Assert.AreEqual("attr[2]", sFormula);
            sl = repository.TitleLBValueDescGetList(c_tid1, uiLBNum, "66");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV2", sl["en-US"]);

            // examine unit leaderboard 3
            uiLBNum = 3;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine unit leaderboard 4
            uiLBNum = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(52, uiEntriesPerCacheLine);
            Assert.AreEqual(902, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            sl = repository.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 Desc", sl["en-US"]);

            sl = repository.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(3, sl.Count);
            Assert.AreEqual(false, sl[(uint)6]);
            Assert.AreEqual(true, sl[(uint)7]);
            Assert.AreEqual(false, sl[(uint)12]);

            rgs = repository.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleUnitValueGet(c_tid1, uiLBNum, "65", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]? 1 : 0", sFormula);
            sl = repository.TitleUnitValueDescGetList(c_tid1, uiLBNum, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 FV1", sl["en-US"]);

            repository.TitleUnitValueGet(c_tid1, uiLBNum, "66", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[7]", sFormula);
            sl = repository.TitleUnitValueDescGetList(c_tid1, uiLBNum, "66");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 FV2", sl["en-US"]);

            // examine competition template 1
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;

            Assert.IsTrue(repository.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            sl = repository.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            sl = repository.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // examine competition template 2
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = true;
            Assert.IsTrue(repository.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(53, uiEntriesPerCacheLine);
            Assert.AreEqual(903, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            sl = repository.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 Desc", sl["en-US"]);

            sl = repository.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(3, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);

            rgs = repository.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("72", rgs[0]);
            Assert.AreEqual("89", rgs[1]);

            returnType = EWebValueReturnType.String;
            sFormula = null;

            repository.TitleCompValueGet(c_tid1, uiLBNum, "72", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("true", sFormula);
            sl = repository.TitleCompValueDescGetList(c_tid1, uiLBNum, "72");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 FV1", sl["en-US"]);

            repository.TitleCompValueGet(c_tid1, uiLBNum, "89", ref returnType, ref sFormula);
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[100]", sFormula);
            sl = repository.TitleCompValueDescGetList(c_tid1, uiLBNum, "89");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 FV2", sl["en-US"]);

            // final test, remove the title to reset it, then override the default
            // maxreads and maxwrites in service.xml and submit - should get the new defaults
            repository.DiscardCachedFiles();
            repository.TitleDelete(c_tid1);
            repository.TitleCreate(c_tid1);
            repository.ServiceDefaultStatsLimitsSet(1, 2);

            CXscSubmit.Submit(c_tid1, xsc, repository, false, out iLBCount, log);
            Assert.AreEqual(6, iLBCount);

            uiMaxWrites = 0;
            uiMaxReads = 0;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(1, uiMaxWrites);
            Assert.AreEqual(2, uiMaxReads);

            // submit the title so we can view the xml
            repository.TitleSubmit(c_tid1, "XscSubmitTest");

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CTitleMgrTest.cs ===
using System;
using System.IO;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CTitleMgrTest
    {
        private readonly CTitleId c_tid1 = new CTitleId(0xffff4006);

        private const string c_sServiceXml = @"c:\tmr\service\service.xml";
        private const string c_sServiceXmlPath = @"c:\tmr\service";

        [SetUp]
        public void CleanupTestTitles()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;
            CRepository repository = new CRepository(null, null, log);

            // clean up from any previous tests
            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }

            // nuke the service xml file

            if (File.Exists(c_sServiceXml))
            {
                CSourceDepot sd = new CSourceDepot(null, null, log);
                sd.Delete(c_sServiceXml);
                sd.Submit(c_sServiceXml, "unit test cleaning up repository");
            }

            if (Directory.Exists(c_sServiceXmlPath))
            {
                CPathUtil.RemovePath(c_sServiceXmlPath);
            }
        }

        private void CreateTestTitles(CRepository repository, CLog log)
        {
            CSourceDepot sd = new CSourceDepot(null, null, log);

            // create titles
            repository.TitleCreate(c_tid1);

            // add supported xqs types to service.xml
            repository.ServiceQueryTypeSet("comp");
            repository.ServiceQueryTypeSet("lsp");
            repository.ServiceQueryTypeSet("compmgr");
            repository.ServiceQueryTypeSet("title");
        }

        [Test]
        public void StatsSubmitXscTest()
        {
            CLog log = new CLog();
            CRepository repository = new CRepository(null, null, log);
            CreateTestTitles(repository, log);

            CTitleMgr titleMgr = new CTitleMgr(
                repository,
                null,
                null,
                log);

            string sXscPathAndFileName = @".\xsc\ffff4006-v3.xsc";
            titleMgr.StatsSubmitXsc(
                c_tid1, 
                sXscPathAndFileName, 
                false);

            // confirm that the file was archived
            CSourceDepot sd = new CSourceDepot(null, null, log);
            string sDestinationPathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("submission")
                + Path.GetFileName(sXscPathAndFileName);

            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            string [] rgsFiles = sd.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);
        }

        [Test]
        public void QuerySubmitXqsTest()
        {
            CLog log = new CLog();
            CRepository repository = new CRepository(null, null, log);
            CreateTestTitles(repository, log);

            CTitleMgr titleMgr = new CTitleMgr(
                repository,
                null,
                null,
                log);

            string sXqsPathAndFileName = @".\xqs\ffff4006.xqs";
            titleMgr.QuerySubmitXqs(
                c_tid1, 
                sXqsPathAndFileName, 
                "comp",
                1);

            // confirm that the file was archived
            CSourceDepot sd = new CSourceDepot(null, null, log);
            string sDestinationPathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("submission")
                + Path.GetFileName(sXqsPathAndFileName);

            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            string [] rgsFiles = sd.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

        }

        [Test]
        public void GameConfigSubmitTest()
        {
            CLog log = new CLog();
            CRepository repository = new CRepository(null, null, log);
            CreateTestTitles(repository, log);

            CTitleMgr titleMgr = new CTitleMgr(
                repository,
                null,
                null,
                log);

            string gameConfigPathAndFileName = @".\gameconfig\TestGameConfig.xml";
            titleMgr.GameConfigSubmit(
                c_tid1, 
                gameConfigPathAndFileName);

            // confirm the file was checked in to the correct location
            CSourceDepot sd = new CSourceDepot(null, null, log);
            string destinationPathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("config")
                + "gameconfig_" + c_tid1.sTitleIdHexNoPrefix + ".xml";

            Assert.IsTrue(File.Exists(destinationPathAndFileName));
            string[] rgsFiles = sd.Files(destinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // confirm that the file was archived
            string archivePathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("submission")
                + Path.GetFileName(gameConfigPathAndFileName);

            Assert.IsTrue(File.Exists(archivePathAndFileName));
            rgsFiles = sd.Files(archivePathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CXscTest.cs ===
using System;
using System.Collections;
using NUnit.Framework;
using xonline.tools.framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CXscTest
    {
        [Test]
        public void XscTest()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            CXsc xsc = null;
            bool bThrown = false;
            CTitleId tidFFFF4006 = new CTitleId(0xffff4006);
            CTitleId tidFFFF4007 = new CTitleId(0xffff4007);
            CTitleId tidOut = null;
            double dUnitLBDecayFactor;
            CLocale locDefault;
            uint[] rguiLBs;
            uint[] rguiUnits;
            uint[] rguiComps;
            ELBReset lbReset = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bRequireArbitration = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            SortedList sl = null;
            string[] rgs = null;
            string sFormula;
            EWebValueReturnType returnType;

            // null filename
            bThrown = false;
            try
            {
                xsc = new CXsc((string)null, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sPathAndFileName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // non-existant filename
            bThrown = false;
            try
            {
                xsc = new CXsc("file-does-not-exist", log);
            }
            catch (CXscException e)
            {
                Assert.IsFalse(e.Message.IndexOf("does not exist") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // pass in a file that is not well formed xml
            bThrown = false;
            try
            {
                xsc = new CXsc(@".\xsc\FFFF4006-malformed.xsc", log);
            }
            catch (CXscException e)
            {
                Assert.IsFalse(e.Message.IndexOf("does not contain well formed xml data") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // pass in a file with a bad version number
            bThrown = false;
            try
            {
                xsc = new CXsc(@".\xsc\FFFF4006-badversion.xsc", log);
            }
            catch (CXscException e)
            {
                Assert.IsFalse(e.Message.IndexOf("unable to parse major version") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // pass in a file with no '.' in the version number, but is otherwise valid
            xsc = new CXsc(@".\xsc\FFFF4006-v5.xsc", log);
            Assert.AreEqual(5, xsc.Version);

            // pass in a file with no version specified
            xsc = new CXsc(@".\xsc\FFFF4006-noversion.xsc", log);
            Assert.AreEqual(1, xsc.Version);

            // pass in a version 1 file with nothing but a version header
            xsc = new CXsc(@".\xsc\FFFF4006-v1-empty.xsc", log);
            Assert.AreEqual(1, xsc.Version);

            // title id shouldn't be there
            Assert.IsFalse(xsc.TitleIdGet(out tidOut));
            Assert.IsTrue(tidOut == null);

            // decay factor shouldn't be there
            Assert.IsFalse(xsc.UnitDecayFactorGet(out dUnitLBDecayFactor));
            Assert.IsTrue(dUnitLBDecayFactor == 0.0);

            // default locale shouldn't be there
            Assert.IsFalse(xsc.DefaultLocaleGet(out locDefault));
            Assert.IsTrue(locDefault == null);

            // should be no leaderboards
            rguiLBs = xsc.LBGetList();
            Assert.AreEqual(0, rguiLBs.Length);
            Assert.IsFalse(xsc.LBConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // and no unit leaderboards
            rguiUnits = xsc.UnitGetList();
            Assert.AreEqual(0, rguiUnits.Length);
            Assert.IsFalse(xsc.UnitConfigGet(
                1, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // and no comp templates
            rguiComps = xsc.CompGetList();
            Assert.AreEqual(0, rguiComps.Length);
            Assert.IsFalse(xsc.CompConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // pass in a version 3 file
            xsc = new CXsc(@".\xsc\FFFF4006-v3-empty.xsc", log);
            Assert.AreEqual(3, xsc.Version);

            // title id shouldn't be there
            Assert.IsFalse(xsc.TitleIdGet(out tidOut));
            Assert.IsTrue(tidOut == null);

            // decay factor shouldn't be there
            Assert.IsFalse(xsc.UnitDecayFactorGet(out dUnitLBDecayFactor));
            Assert.IsTrue(dUnitLBDecayFactor == 0.0);

            // default locale shouldn't be there
            Assert.IsFalse(xsc.DefaultLocaleGet(out locDefault));
            Assert.IsTrue(locDefault == null);

            // should be no leaderboards
            rguiLBs = xsc.LBGetList();
            Assert.AreEqual(0, rguiLBs.Length);
            Assert.IsFalse(xsc.LBConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // and no unit leaderboards
            rguiUnits = xsc.UnitGetList();
            Assert.AreEqual(0, rguiUnits.Length);
            Assert.IsFalse(xsc.UnitConfigGet(
                1, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // and no comp templates
            rguiComps = xsc.CompGetList();
            Assert.AreEqual(0, rguiComps.Length);
            Assert.IsFalse(xsc.CompConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // pass in a non-empty version 1 file
            xsc = new CXsc(@".\xsc\FFFF4006-v1.xsc", log);
            Assert.AreEqual(1, xsc.Version);

            // title id should be there
            Assert.IsTrue(xsc.TitleIdGet(out tidOut));
            Assert.AreEqual(tidFFFF4006.ToString(), tidOut.ToString());

            // decay factor shouldn't be there, since this is version 1
            Assert.IsFalse(xsc.UnitDecayFactorGet(out dUnitLBDecayFactor));
            Assert.IsTrue(dUnitLBDecayFactor == 0.0);

            // default locale should be there
            Assert.IsTrue(xsc.DefaultLocaleGet(out locDefault));
            Assert.AreEqual("en-US", locDefault.ToString());

            // get the leaderboard list, should be three
            rguiLBs = xsc.LBGetList();
            Assert.AreEqual(3, rguiLBs.Length);
            Assert.AreEqual(1, rguiLBs[0]);
            Assert.AreEqual(2, rguiLBs[1]);
            Assert.AreEqual(3, rguiLBs[2]);

            // leaderboard 1
            Assert.IsTrue(xsc.LBConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetNever, lbReset);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);

            // leaderboard 2
            Assert.IsTrue(xsc.LBConfigGet(
                2, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, lbReset);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);

            // leaderboard 3
            Assert.IsTrue(xsc.LBConfigGet(
                3, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryMonth, lbReset);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);

            // leaderboard 4 does not exist
            Assert.IsFalse(xsc.LBConfigGet(
                4, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // should be no unit leaderboards
            rguiUnits = xsc.UnitGetList();
            Assert.AreEqual(0, rguiUnits.Length);

            // unit leaderboard 1 does not exist
            Assert.IsFalse(xsc.UnitConfigGet(
                1, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // shoudl be no comp templates
            rguiComps = xsc.CompGetList();
            Assert.AreEqual(0, rguiComps.Length);

            // comp template 1 does not exist
            Assert.IsFalse(xsc.CompConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // pass in a non-empty version 3 file
            xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            Assert.AreEqual(3, xsc.Version);

            // title id should be there
            Assert.IsTrue(xsc.TitleIdGet(out tidOut));
            Assert.AreEqual(tidFFFF4006.ToString(), tidOut.ToString());

            // decay factor should be there
            Assert.IsTrue(xsc.UnitDecayFactorGet(out dUnitLBDecayFactor));
            Assert.AreEqual(90.0, dUnitLBDecayFactor);

            // default locale should be there
            Assert.IsTrue(xsc.DefaultLocaleGet(out locDefault));
            Assert.AreEqual("en-CA", locDefault.ToString());

            // get the leaderboard list, should be two
            rguiLBs = xsc.LBGetList();
            Assert.AreEqual(2, rguiLBs.Length);
            Assert.AreEqual(1, rguiLBs[0]);
            Assert.AreEqual(2, rguiLBs[1]);

            // check out leaderboard 1
            Assert.IsTrue(xsc.LBConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetNever, lbReset);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);

            // no web descriptions
            sl = xsc.LBDescGetList(1);
            Assert.AreEqual(0, sl.Count);

            // no web raw attributes
            sl = xsc.LBAttrGetList(1);
            Assert.AreEqual(0, sl.Count);

            // no web formatted values
            rgs = xsc.LBValueGetList(1);
            Assert.AreEqual(0, rgs.Length);

            // check out leaderboard 2
            Assert.IsTrue(xsc.LBConfigGet(
                2, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetEveryWeek, lbReset);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bRequireArbitration);
            Assert.AreEqual(true, bIsTeam);
            CELOMaxWeightRatingRange[] eloRatingRanges = new CELOMaxWeightRatingRange[2];
            eloRatingRanges[0] = new CELOMaxWeightRatingRange(0, 500);
            eloRatingRanges[1] = new CELOMaxWeightRatingRange(10, 400);
            CELOConfig eloConfigExpected 
                = new CELOConfig(
                32000, 
                1000, 
                EELOExponentialBase.ten,
                eloRatingRanges);
            Assert.AreEqual(eloConfigExpected.ToString(), eloConfig.ToString());

            // should be 2 leaderboard descriptions
            sl = xsc.LBDescGetList(2);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 Desc", sl["en-US"]);
            Assert.IsFalse(sl.ContainsKey("en-AU"));

            // should be 5 raw attributes
            sl = xsc.LBAttrGetList(2);
            Assert.AreEqual((bool)sl[(uint)1], false);
            Assert.AreEqual((bool)sl[(uint)2], true);
            Assert.AreEqual((bool)sl[(uint)3], true);
            Assert.AreEqual((bool)sl[(uint)4], true);
            Assert.AreEqual((bool)sl[(uint)5], false);
            Assert.IsFalse(sl.ContainsKey((uint)6));

            // should be two formatted values, 65 and 66
            rgs = xsc.LBValueGetList(2);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);

            // check the details on the formatted values
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(xsc.LBValueGet(2, "65", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[1]", sFormula);
            Assert.IsTrue(xsc.LBValueGet(2, "66", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Team, returnType);
            Assert.AreEqual("attr[2]", sFormula);

            // there should be two descriptions on each formatted value
            sl = xsc.LBValueDescGetList(2, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV1", sl["en-US"]);
            sl = xsc.LBValueDescGetList(2, "66");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 FV2", sl["en-CA"]);
            Assert.AreEqual("enUS LB2 FV2", sl["en-US"]);

            // leaderboard 3 doesn't exist
            Assert.IsFalse(xsc.LBConfigGet(
                3, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref uiMaxRatingCount, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));

            // should be 2 unit leaderboards
            rguiUnits = xsc.UnitGetList();
            Assert.AreEqual(2, rguiUnits.Length);
            Assert.AreEqual(3, rguiUnits[0]);
            Assert.AreEqual(4, rguiUnits[1]);

            // check the config on unit lb 3
            eloConfig = null;
            Assert.IsTrue(xsc.UnitConfigGet(
                3, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(true, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            eloConfig = null;

            // should be no web lb description
            sl = xsc.UnitDescGetList(3);
            Assert.AreEqual(0, sl.Count);

            // should be no web raw attributes
            sl = xsc.UnitAttrGetList(3);
            Assert.AreEqual(0, sl.Count);

            // should be no formatted values
            rgs = xsc.UnitValueGetList(3);
            Assert.AreEqual(0, rgs.Length);

            // check out unit leaderboard 4
            Assert.IsTrue(xsc.UnitConfigGet(
                4, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(true, bRequireArbitration);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual(eloConfigExpected.ToString(), eloConfig.ToString());

            // should be 2 lb descriptions
            sl = xsc.UnitDescGetList(4);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 Desc", sl["en-US"]);
            Assert.IsFalse(sl.ContainsKey("en-AU"));

            // should be three raw attributes 
            sl = xsc.UnitAttrGetList(4);
            Assert.AreEqual(3, sl.Count);
            Assert.IsTrue((bool)sl[(uint)6] == false);
            Assert.IsTrue((bool)sl[(uint)7] == true);
            Assert.IsTrue((bool)sl[(uint)12] == false);

            // should be two formatted values
            rgs = xsc.UnitValueGetList(4);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("66", rgs[1]);

            // check the details on the formatted values
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(xsc.UnitValueGet(4, "65", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]? 1 : 0", sFormula);
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(xsc.UnitValueGet(4, "66", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[7]", sFormula);

            // there should be two descriptions on each formatted value
            sl = xsc.UnitValueDescGetList(4, "65");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LB4 FV1", sl["en-US"]);

            // should be two comp templates
            rguiComps = xsc.CompGetList();
            Assert.AreEqual(2, rguiComps.Length);
            Assert.AreEqual(1, rguiComps[0]);
            Assert.AreEqual(2, rguiComps[1]);

            // check out template 1
            eloConfig = null;
            lbReset = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            Assert.IsTrue(xsc.CompConfigGet(
                1, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetNever, lbReset);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bRequireArbitration);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);

            // should be no descriptions
            sl = xsc.CompDescGetList(1);
            Assert.AreEqual(0, sl.Count);

            // should be no raw attributes
            sl = xsc.CompAttrGetList(1);
            Assert.AreEqual(0, sl.Count);

            // should be no formatted values
            rgs = xsc.CompValueGetList(1);
            Assert.AreEqual(0, rgs.Length);

            // check out comp template 2
            Assert.IsTrue(xsc.CompConfigGet(
                2, 
                ref lbReset, 
                ref uiAttachmentCount, 
                ref uiMaxAttachmentSize, 
                ref uiDecayDays, 
                ref bRequireArbitration, 
                ref bIsTeam, 
                ref eloConfig));
            Assert.AreEqual(ELBReset.ResetNever, lbReset);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bRequireArbitration);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual(eloConfigExpected.ToString(), eloConfig.ToString());

            // should be 2 descriptions
            sl = xsc.CompDescGetList(2);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 Desc", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 Desc", sl["en-US"]);
            Assert.IsFalse(sl.ContainsKey("en-AU"));

            // should be one raw attribute (1)
            sl = xsc.CompAttrGetList(2);
            Assert.AreEqual(3, sl.Count);
            Assert.IsTrue((bool)sl[(uint)1] == false);
            Assert.IsTrue((bool)sl[(uint)2] == false);
            Assert.IsTrue((bool)sl[(uint)3] == true);

            // should be one formatted value, 72
            rgs = xsc.CompValueGetList(2);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("72", rgs[0]);
            Assert.AreEqual("89", rgs[1]);

            // check the details on the formatted values
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(xsc.CompValueGet(2, "72", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("true", sFormula);
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(xsc.CompValueGet(2, "89", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("attr[100]", sFormula);

            // there should be two descriptions on each formatted value
            sl = xsc.CompValueDescGetList(2, "72");
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV1", sl["en-CA"]);
            Assert.AreEqual("enUS LBT2 FV1", sl["en-US"]);

        }

        private void ShowResults(string[] rgsResults, CLog log)
        {
            log.WriteLineV("Results:");
            foreach (string sLine in rgsResults)
            {
                log.WriteLineV(sLine);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CXscValidateTest.cs ===
using System;
using NUnit.Framework;

namespace xonline.tools.framework.test.dvt 
{
    [TestFixture]
    public class CXscValidateTest
    {
        [Test]
        public void ValidateTest()
        {
            CTitleId tid = new CTitleId(0xffff4006);
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            log.Level = CLog.CONSOLE;

            CXsc xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            bool bThrown;

            // null xsc should throw
            bThrown = false;
            try
            {
                CXscValidate.Validate(null, tid, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("xsc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // null tid should throw
            bThrown = false;
            try
            {
                CXscValidate.Validate(xsc, null, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // null log should throw
            bThrown = false;
            try
            {
                CXscValidate.Validate(xsc, tid, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("log", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // valid v3 file
            xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // valid v1 file
            xsc = new CXsc(@".\xsc\FFFF4006-v1.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // missing tid
            xsc = new CXsc(@".\xsc\FFFF4006-v3-no-tid.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid tid
            xsc = new CXsc(@".\xsc\FFFF4006-v3-invalid-tid.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // two leaderboards w/ same number
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-duplicate.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid elo on leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-invalid-elo.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // attachments w/ arbitration on leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-attach-and-arb.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 0
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-raw-attr-0.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 65
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-raw-attr-65.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // invalid formula on leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-leaderboard-invalid-formula.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // two unit leaderboards w/ same number
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-duplicate.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // unit and individual leaderboard w/ same number
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-leaderboard-duplicate.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // no unit leaderboard decay constant w/ unit lbs
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-missing-decay-constant.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid elo on unit leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-invalid-elo.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 0
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-raw-attr-0.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 65
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-raw-attr-65.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // invalid formula on unit leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-invalid-formula.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // two templates with same id
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-duplicate.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // template id < 1
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-id-0.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // template id > 15
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-id-16.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid elo on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-invalid-elo.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // attachments w/ arbitration on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-attach-and-arb.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 0
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-raw-attr-0.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // raw attribute 65
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-raw-attr-65.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // invalid formula on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-invalid-formula.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // no default locale, but also no web info
            xsc = new CXsc(@".\xsc\FFFF4006-v3-no-locdefault-noweb.xsc", log);
            Assert.IsTrue(CXscValidate.Validate(xsc, tid, log));

            // no default locale, with web info
            xsc = new CXsc(@".\xsc\FFFF4006-v3-no-locdefault.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // no descriptions for default locale
            xsc = new CXsc(@".\xsc\FFFF4006-v3-no-desc-for-locdefault.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid leaderboard reset type
            xsc = new CXsc(@".\xsc\FFFF4006-v3-invalid-reset-type-leaderboard.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // invalid competition template reset type
            xsc = new CXsc(@".\xsc\FFFF4006-v3-invalid-reset-type-template.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // individual leaderboard id < 1
            xsc = new CXsc(@".\xsc\FFFF4006-v3-lb-id-too-small.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // individual leaderboard id > 65535
            xsc = new CXsc(@".\xsc\FFFF4006-v3-lb-id-too-large.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // unit leaderboard id > 65535
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-id-too-large.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

            // unit leaderboard id < 0
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-id-too-small.xsc", log);
            Assert.IsFalse(CXscValidate.Validate(xsc, tid, log));

        }

        [Test]
        public void PolicyTest()
        {
            CLog log = new CLog();
            CXsc xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            uint uiMaxSingleAttachSize = 2*1024*1024; // 2 meg
            uint uiMaxTotalAttachSize =  1*1024*1024*1024; // 1 gig
            uint uiMaxLeaderboardCount = 1000;
            bool bThrown;

            // null xsc should throw
            bThrown = false;
            try
            {
                CXscValidate.Policy(null, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("xsc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // null log should throw
            bThrown = false;
            try
            {
                CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("log", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // valid v3 file
            xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            Assert.IsTrue(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // valid v1 file
            xsc = new CXsc(@".\xsc\FFFF4006-v1.xsc", log);
            Assert.IsTrue(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // single attachment larger than uiMaxSingleAttachSize
            xsc = new CXsc(@".\xsc\FFFF4006-v3-large-attach.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // total attachments larger than uiMaxTotalAttachSize
            xsc = new CXsc(@".\xsc\FFFF4006-v3-large-total-attach.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // no arbitration on unit leaderboard
            xsc = new CXsc(@".\xsc\FFFF4006-v3-unit-no-arb.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // reset type not reset never on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-reset-not-never.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // no arbitration on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-no-arb.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // attachments on template
            xsc = new CXsc(@".\xsc\FFFF4006-v3-template-attach.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

            // too many leaderboards
            uiMaxLeaderboardCount = 3;
            xsc = new CXsc(@".\xsc\FFFF4006-v3.xsc", log);
            Assert.IsFalse(CXscValidate.Policy(xsc, uiMaxSingleAttachSize, uiMaxTotalAttachSize, uiMaxLeaderboardCount, log));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\dvt\CRepositoryTest.cs ===
using System;
using System.Xml;
using System.IO;
using System.Collections;
using NUnit.Framework;

namespace xonline.tools.framework.test.dvt 
{
    /// <summary>
    /// NUnit test class for CRepository class.
    /// </summary>
    [TestFixture]
    public class CRepositoryTest
    {
        private readonly CTitleId c_tid1 = new CTitleId(0xffff4006);
        private readonly CTitleId c_tid2 = new CTitleId(0xffff4007);
        private readonly CTitleId c_tid3 = new CTitleId(0xffff4008);
        private readonly CTitleId c_tid4 = new CTitleId(0xffff4009);
        private readonly CLocale c_locEnUS = new CLocale("en-US");
        private readonly CLocale c_locEnCA = new CLocale("en-CA");


        private const string c_sServiceXml = @"c:\tmr\service\service.xml";
        private const string c_sServiceXmlPath = @"c:\tmr\service";

        [SetUp]
        public void CleanupTestTitles()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;
            CRepository repository = new CRepository(null, null, log);

            // clean up from any previous tests
            if (repository.TitleExists(c_tid1))
            {
                repository.TitleDelete(c_tid1);
            }
            if (repository.TitleExists(c_tid2))
            {
                repository.TitleDelete(c_tid2);
            }
            if (repository.TitleExists(c_tid3))
            {
                repository.TitleDelete(c_tid3);
            }
            if (repository.TitleExists(c_tid4))
            {
                repository.TitleDelete(c_tid4);
            }

            // nuke the service xml file
            //
            // we don't want to nuke this any more...
            // the unit tests must be safe to run on 
            // devnet2's svc box, and this would affect other
            // titles...

            if (File.Exists(c_sServiceXml))
            {
                CSourceDepot sd = new CSourceDepot(null, null, log);
                sd.Delete(c_sServiceXml);
                sd.Submit(c_sServiceXml, "unit test cleaning up repository");
            }

            if (Directory.Exists(c_sServiceXmlPath))
            {
                CPathUtil.RemovePath(c_sServiceXmlPath);
            }


        }

        private void CreateTestTitles(CRepository repository, CLog log)
        {
            string sTitleRoot;
            string sTitleConfig;

            CSourceDepot sd = new CSourceDepot(null, null, log);

            // create titles
            repository.TitleCreate(c_tid1);
            repository.TitleCreate(c_tid2);
            repository.TitleCreate(c_tid3);

            // c_tid1 is our up to date title 
            // add some title description xmls
            string sRoot = CPathUtil.AddPathTerminator(repository.RepositoryRoot);
            Directory.CreateDirectory(sRoot+@"ffff4006\message");
            File.Copy(@".\message\titles.english.xml", sRoot+@"ffff4006\message\titles.english.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.english.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.english.xml", "TitleDescTest");

            File.Copy(@".\message\titles.french.xml", sRoot+@"ffff4006\message\titles.french.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.french.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.french.xml", "TitleDescTest");

            File.Copy(@".\message\titles.german.xml", sRoot+@"ffff4006\message\titles.german.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.german.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.german.xml", "TitleDescTest");

            File.Copy(@".\message\titles.italian.xml", sRoot+@"ffff4006\message\titles.italian.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.italian.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.italian.xml", "TitleDescTest");

            File.Copy(@".\message\titles.japanese.xml", sRoot+@"ffff4006\message\titles.japanese.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.japanese.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.japanese.xml", "TitleDescTest");

            File.Copy(@".\message\titles.invalid.xml", sRoot+@"ffff4006\message\titles.invalid.xml");
            sd.Add(sRoot+@"ffff4006\message\titles.invalid.xml");
            sd.Submit(sRoot+@"ffff4006\message\titles.invalid.xml", "TitleDescTest");

            // c_tid2 is a stats v2 title. It uses stats.xml for leaderboard
            // definitions, and stats.ini for other stuff
            CIni iniStats2 = new CIni();
            iniStats2.SetSetting("SETTINGS", "STATSDB", "2");

            sTitleRoot = Path.Combine(sd.ClientRoot, "ffff4007");
            sTitleConfig = Path.Combine(sTitleRoot, "config");
            if (!Directory.Exists(sTitleConfig))
            {
                Directory.CreateDirectory(sTitleConfig);
            }
            iniStats2.Save(Path.Combine(sTitleConfig, @"stats.ini"));
            File.Copy(@".\xsc\ffff4007-v1.xsc", Path.Combine(sTitleConfig, "stats.xml"));
            sd.Add(Path.Combine(sTitleConfig, "stats.xml"));
            sd.Submit(Path.Combine(sTitleConfig, "stats.xml"), "TitleLBTest");

            // tid3 is a stats v1 title that uses stats.ini for everything, 
            CIni iniStats3 = new CIni();
            iniStats3.SetSetting("SETTINGS", "STATSDB", "3");
            iniStats3.SetSetting("LEADERBOARDS", "1", "0");
            iniStats3.SetSetting("LEADERBOARDS", "2", "1");
            iniStats3.SetSetting("LEADERBOARDS", "3", "2");
            iniStats3.SetSetting("LEADERBOARDS", "4", "3");
            iniStats3.SetSetting("LEADERBOARDS", "5", "4");
            iniStats3.SetSetting("LEADERBOARDS", "6", "5");
            iniStats3.SetSetting("LEADERBOARDS", "7", "6");
            iniStats3.SetSetting("LEADERBOARDS", "10", "0");

            sTitleRoot = Path.Combine(sd.ClientRoot, "ffff4008");
            sTitleConfig = Path.Combine(sTitleRoot, "config");
            if (!Directory.Exists(sTitleConfig))
            {
                Directory.CreateDirectory(sTitleConfig);
            }
            iniStats3.Save(Path.Combine(sTitleConfig, "stats.ini"));
            sd.Add(Path.Combine(sTitleConfig, "stats.ini"));
            sd.Submit(Path.Combine(sTitleConfig, "stats.ini"), "TitleLBTest");

            // c_tid4 is a pre-released stats v3 title. It uses stats.xml for leaderboard
            // definitions, and stats.ini for other stuff, but the stats.xml is in the v3 format
            CIni iniStats4 = new CIni();
            sTitleRoot = Path.Combine(sd.ClientRoot, "ffff4009");
            sTitleConfig = Path.Combine(sTitleRoot, "config");

            iniStats4.SetSetting("SETTINGS", "STATSDB", "2");
            if (!Directory.Exists(sTitleConfig))
            {
                Directory.CreateDirectory(sTitleConfig);
            }
            iniStats4.Save(Path.Combine(sTitleConfig, "stats.ini"));
            File.Copy(@".\xsc\ffff4009-v3.xsc", Path.Combine(sTitleConfig, "stats.xml"));
            sd.Add(Path.Combine(sTitleConfig, "stats.xml"));
            sd.Submit(Path.Combine(sTitleConfig, "stats.xml"), "TitleLBTest");

        }

        // because these tests are being run on devnet2 and not just dev workstations,
        // this unit test is no longer safe because it affects global settings.
        [Test]
        public void ServiceLBPolicyTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);
            uint uiMaxSingleAttachSize;
            uint uiMaxTotalAttachSize;
            uint uiMaxLeaderboardCount;

            // the repository is empty, the service directory shouldn't exist
            string sRoot = CPathUtil.AddPathTerminator(repository1.RepositoryRoot);
            Assert.IsFalse(Directory.Exists(sRoot+@"service"));

            // Basic, get/set/delete tests 

            // get should return false because service.xml doesn't exist
            uiMaxSingleAttachSize = 1;
            uiMaxTotalAttachSize = 2;
            uiMaxLeaderboardCount = 3;
            Assert.IsFalse(repository1.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(1, uiMaxSingleAttachSize);
            Assert.AreEqual(2, uiMaxTotalAttachSize);
            Assert.AreEqual(3, uiMaxLeaderboardCount);

            // now set the values
            uiMaxSingleAttachSize = 4;
            uiMaxTotalAttachSize = 5;
            uiMaxLeaderboardCount = 6;
            repository1.ServiceLBPolicySet(
                uiMaxSingleAttachSize,
                uiMaxTotalAttachSize,
                uiMaxLeaderboardCount);

            // get should work now
            uiMaxSingleAttachSize = 7;
            uiMaxTotalAttachSize = 8;
            uiMaxLeaderboardCount = 9;
            Assert.IsTrue(repository1.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(4, uiMaxSingleAttachSize);
            Assert.AreEqual(5, uiMaxTotalAttachSize);
            Assert.AreEqual(6, uiMaxLeaderboardCount);

            // now delete the settings
            repository1.ServiceLBPolicyDelete();

            // repository 1 should see that they are gone
            uiMaxSingleAttachSize = 10;
            uiMaxTotalAttachSize = 11;
            uiMaxLeaderboardCount = 12;
            Assert.IsFalse(repository1.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(10, uiMaxSingleAttachSize);
            Assert.AreEqual(11, uiMaxTotalAttachSize);
            Assert.AreEqual(12, uiMaxLeaderboardCount);

            // now test the submit functionality

            // set from repository1
            uiMaxSingleAttachSize = 13;
            uiMaxTotalAttachSize = 14;
            uiMaxLeaderboardCount = 15;
            repository1.ServiceLBPolicySet(
                uiMaxSingleAttachSize,
                uiMaxTotalAttachSize,
                uiMaxLeaderboardCount);
 
            // do a get from repository2
            // won't see changes because they haven't been submitted
            // this will load the file and cache it
            uiMaxSingleAttachSize = 16;
            uiMaxTotalAttachSize = 17;
            uiMaxLeaderboardCount = 18;
            Assert.IsFalse(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(16, uiMaxSingleAttachSize);
            Assert.AreEqual(17, uiMaxTotalAttachSize);
            Assert.AreEqual(18, uiMaxLeaderboardCount);

            // now submit the change
            repository1.ServiceSubmit("ServiceLBPolicyTest");

            // repository2 is stil working off cached data so won't get the values
            uiMaxSingleAttachSize = 19;
            uiMaxTotalAttachSize = 20;
            uiMaxLeaderboardCount = 21;
            Assert.IsFalse(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(19, uiMaxSingleAttachSize);
            Assert.AreEqual(20, uiMaxTotalAttachSize);
            Assert.AreEqual(21, uiMaxLeaderboardCount);

            // tell repository2 to reload data, then it should see the change
            repository2.DiscardCachedFiles();
            uiMaxSingleAttachSize = 22;
            uiMaxTotalAttachSize = 23;
            uiMaxLeaderboardCount = 24;
            Assert.IsTrue(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(13, uiMaxSingleAttachSize);
            Assert.AreEqual(14, uiMaxTotalAttachSize);
            Assert.AreEqual(15, uiMaxLeaderboardCount);

            // remove the settings with repository1
            repository1.ServiceLBPolicyDelete();

            // even with a cache discard, won't see it because it hasn't been submitted
            repository2.DiscardCachedFiles();
            uiMaxSingleAttachSize = 25;
            uiMaxTotalAttachSize = 26;
            uiMaxLeaderboardCount = 27;
            Assert.IsTrue(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(13, uiMaxSingleAttachSize);
            Assert.AreEqual(14, uiMaxTotalAttachSize);
            Assert.AreEqual(15, uiMaxLeaderboardCount);

            // now submit it
            repository1.ServiceSubmit("ServiceLBPolicyTest");

            // won't see it without a cache discard
            uiMaxSingleAttachSize = 28;
            uiMaxTotalAttachSize = 29;
            uiMaxLeaderboardCount = 30;
            Assert.IsTrue(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(13, uiMaxSingleAttachSize);
            Assert.AreEqual(14, uiMaxTotalAttachSize);
            Assert.AreEqual(15, uiMaxLeaderboardCount);

            // should see it with a cache discard
            repository2.DiscardCachedFiles();
            uiMaxSingleAttachSize = 31;
            uiMaxTotalAttachSize = 32;
            uiMaxLeaderboardCount = 33;
            Assert.IsFalse(repository2.ServiceLBPolicyGet(
                ref uiMaxSingleAttachSize,
                ref uiMaxTotalAttachSize,
                ref uiMaxLeaderboardCount));
            Assert.AreEqual(31, uiMaxSingleAttachSize);
            Assert.AreEqual(32, uiMaxTotalAttachSize);
            Assert.AreEqual(33, uiMaxLeaderboardCount);

            // leave the file in the respotory with 
            // settings in there so we can view it
            uiMaxSingleAttachSize = 34;
            uiMaxTotalAttachSize = 35;
            uiMaxLeaderboardCount = 36;
            repository1.ServiceLBPolicySet(
                uiMaxSingleAttachSize,
                uiMaxTotalAttachSize,
                uiMaxLeaderboardCount);
            repository1.ServiceSubmit("ServiceLBPolicyTest");
        }

        // because these tests are being run on devnet2 and not just dev workstations,
        // this unit test is no longer safe because it affects global settings.
        [Test]
        public void ServiceDefaultStatsLimitsTest()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            CRepository repository = new CRepository(null, null, log);
            uint uiMaxWrites;
            uint uiMaxReads;

            // the repository is empty, the service directory shouldn't exist
            string sRoot = CPathUtil.AddPathTerminator(repository.RepositoryRoot);
            Assert.IsFalse(Directory.Exists(sRoot+@"service"));

            // Basic, get/set/delete tests 

            // get should return false because service.xml doesn't exist
            uiMaxWrites = 1;
            uiMaxReads = 2;
            Assert.IsFalse(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(1, uiMaxWrites);
            Assert.AreEqual(2, uiMaxReads);

            // now set the values
            uiMaxWrites = 3;
            uiMaxReads = 4;
            repository.ServiceDefaultStatsLimitsSet(
                uiMaxWrites,
                uiMaxReads);

            // get should work now
            uiMaxWrites = 5;
            uiMaxReads = 6;
            Assert.IsTrue(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(3, uiMaxWrites);
            Assert.AreEqual(4, uiMaxReads);

            // now delete the settings
            repository.ServiceDefaultStatsLimitsDelete();

            uiMaxWrites = 7;
            uiMaxReads = 8;
            Assert.IsFalse(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(7, uiMaxWrites);
            Assert.AreEqual(8, uiMaxReads);

            // now repeat the tests with a submit/flush cycle between each test

            repository.DiscardCachedFiles();

            // get should return false because service.xml doesn't exist
            uiMaxWrites = 1;
            uiMaxReads = 2;
            Assert.IsFalse(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(1, uiMaxWrites);
            Assert.AreEqual(2, uiMaxReads);

            // now set the values
            uiMaxWrites = 3;
            uiMaxReads = 4;
            repository.ServiceDefaultStatsLimitsSet(
                uiMaxWrites,
                uiMaxReads);

            repository.ServiceSubmit("ServiceDefaultStatsLimitsTest");
            repository.DiscardCachedFiles();

            // get should work now
            uiMaxWrites = 5;
            uiMaxReads = 6;
            Assert.IsTrue(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(3, uiMaxWrites);
            Assert.AreEqual(4, uiMaxReads);

            // now delete the settings
            repository.ServiceDefaultStatsLimitsDelete();
            repository.ServiceSubmit("ServiceDefaultStatsLimitsTest");
            repository.DiscardCachedFiles();

            uiMaxWrites = 7;
            uiMaxReads = 8;
            Assert.IsFalse(repository.ServiceDefaultStatsLimitsGet(
                ref uiMaxWrites,
                ref uiMaxReads));
            Assert.AreEqual(7, uiMaxWrites);
            Assert.AreEqual(8, uiMaxReads);

            // leave something to look at
            uiMaxWrites = 3;
            uiMaxReads = 4;
            repository.ServiceDefaultStatsLimitsSet(
                uiMaxWrites,
                uiMaxReads);

            repository.ServiceSubmit("ServiceDefaultStatsLimitsTest");
        }

        [Test]
        public void ServiceQueryTypeTest()
        {
            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            CRepository repository = new CRepository(null, null, log);

            // the repository is empty, the service directory shouldn't exist
            string sRoot = CPathUtil.AddPathTerminator(repository.RepositoryRoot);
            Assert.IsFalse(Directory.Exists(sRoot+@"service"));

            // parameter validation
            bool bThrown;

            bThrown = false;
            try
            {
                repository.ServiceQueryTypeSet(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.ServiceQueryTypeSet("");
            }
            catch (ArgumentException e)
            {
                Assert.IsFalse(e.Message.IndexOf("String.Empty is not a valid query type name") == -1);
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.ServiceQueryTypeDelete(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.ServiceQueryTypeDelete("");
            }
            catch (ArgumentException e)
            {
                Assert.IsFalse(e.Message.IndexOf("String.Empty is not a valid query type name") == -1);
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // Basic, get/set/delete tests 

            // get should return an empty because service.xml doesn't exist
            string[] rgsQueryTypeNames = null;
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(0, rgsQueryTypeNames.Length);

            // now set a type name
            repository.ServiceQueryTypeSet("type1");

            // the list should now have it
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(1, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);

            // delete the one we added
            repository.ServiceQueryTypeDelete("type1");

            // the list should now be empty again
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(0, rgsQueryTypeNames.Length);

            // add it back
            repository.ServiceQueryTypeSet("type1");

            // make sure it's there again
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(1, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);

            // add another one
            repository.ServiceQueryTypeSet("type2");

            // the list should have both now
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(2, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);
            Assert.AreEqual("type2", rgsQueryTypeNames[1]);

            // now repeat the tests with a submit/flush cycle between each test
            repository.DiscardCachedFiles();

            // get should return an empty because service.xml doesn't exist
            rgsQueryTypeNames = null;
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(0, rgsQueryTypeNames.Length);

            // now set a type name
            repository.ServiceQueryTypeSet("type1");
            repository.ServiceSubmit("ServiceQueryTypeTest");
            repository.DiscardCachedFiles();

            // the list should now have it
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(1, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);

            // delete the one we added
            repository.ServiceQueryTypeDelete("type1");
            repository.ServiceSubmit("ServiceQueryTypeTest");
            repository.DiscardCachedFiles();

            // the list should now be empty again
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(0, rgsQueryTypeNames.Length);

            // add it back
            repository.ServiceQueryTypeSet("type1");
            repository.ServiceSubmit("ServiceQueryTypeTest");
            repository.DiscardCachedFiles();

            // make sure it's there again
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(1, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);

            // add another one
            repository.ServiceQueryTypeSet("type2");
            repository.ServiceSubmit("ServiceQueryTypeTest");
            repository.DiscardCachedFiles();

            // the list should have both now
            rgsQueryTypeNames = repository.ServiceQueryTypeGetList();
            Assert.AreEqual(2, rgsQueryTypeNames.Length);
            Assert.AreEqual("type1", rgsQueryTypeNames[0]);
            Assert.AreEqual("type2", rgsQueryTypeNames[1]);

            // leave something to look at
            repository.ServiceSubmit("ServiceQueryTypeTest");
        }

        [Test]
        public void TitleCreateDeleteTest()
        {
            // no parameter validation to test in the constructor, null is allowed
            // for all params
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);

            bool bThrown;

            // Parameter validation on TitleCreate
            bThrown = false;
            try
            {
                repository.TitleCreate(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }

            // create tid
            repository.TitleCreate(c_tid1);

            // don't create c_tid2

            // trying to CreateTitle on a title that exists should throw
            bThrown = false;
            try
            {
                repository.TitleCreate(c_tid1);
            }
            catch (CRepositoryException e)
            {
                Assert.IsFalse(e.Message.IndexOf("already exists in repository") == -1);
                bThrown = true;
            }

            // TitleExists tests
            bThrown = false;
            try
            {
                repository.TitleExists(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            Assert.IsTrue(repository.TitleExists(c_tid1));
            Assert.IsFalse(repository.TitleExists(c_tid2));

            // TitleDelete tests

            // should work, title is there
            repository.TitleDelete(c_tid1);
            Assert.IsFalse(repository.TitleExists(c_tid1));

            // should throw, title doesn't exist
            bThrown = false;
            try
            {
                repository.TitleDelete(c_tid2);
            }
            catch (CRepositoryException e)
            {
                Assert.IsFalse(e.Message.IndexOf("does not exist in repository") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
        }

        [Test]
        public void TitleLBDefaultDBTest()
        {
            // no parameter validation to test in the constructor, null is allowed
            // for all params
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            bool bThrown;
            int iStatsDB = 0;

            CreateTestTitles(repository, log);

            // TitleLBDefaultDBGet/Set/Delete tests

            // param validation
            bThrown = false;
            try
            {
                repository.TitleLBDefaultDBGet(null, ref iStatsDB);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleLBDefaultDBSet(null, iStatsDB);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleLBDefaultDBDelete(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // get from c_tid1 should return nothing right now
            iStatsDB = 1;
            Assert.IsFalse(repository.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(1, iStatsDB);

            // get from c_tid2 should return the value from the legacy stats.ini
            iStatsDB = 0;
            Assert.IsTrue(repository.TitleLBDefaultDBGet(c_tid2, ref iStatsDB));
            Assert.AreEqual(2, iStatsDB);

            // set to c_tid1, and we should be able to get it back
            repository.TitleLBDefaultDBSet(c_tid1, 4);
            iStatsDB = 5;
            Assert.IsTrue(repository.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(4, iStatsDB);

            // set to c_tid2 should override the value in stats.ini.
            // stats.ini won't be changed... it will just be ignored in favor of the title xml
            repository.TitleLBDefaultDBSet(c_tid2, 6);
            iStatsDB = 7;
            Assert.IsTrue(repository.TitleLBDefaultDBGet(c_tid2, ref iStatsDB));
            Assert.AreEqual(6, iStatsDB);

            // delete c_tid1, get should then return nothing again
            repository.TitleLBDefaultDBDelete(c_tid1);
            iStatsDB = 8;
            Assert.IsFalse(repository.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(8, iStatsDB);

            // delete c_tid2, should fall back to what's in the stats.ini file
            repository.TitleLBDefaultDBDelete(c_tid2);
            iStatsDB = 9;
            Assert.IsTrue(repository.TitleLBDefaultDBGet(c_tid2, ref iStatsDB));
            Assert.AreEqual(2, iStatsDB);

            // deleteing when already gone should be a noop - shouldn't throw
            repository.TitleLBDefaultDBDelete(c_tid1);

            // now make sure title submit works as expected

            // set a value through repository
            repository.TitleLBDefaultDBSet(c_tid1, 12);

            // repository2 should not see it yet, because it hasn't been
            // submitted
            iStatsDB = 13;
            Assert.IsFalse(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(13, iStatsDB);

            // submit the change
            repository.TitleSubmit(c_tid1, "TitleLBDefaultDBTest");

            // repository2 still shouldn't see it because it has the value cached now
            iStatsDB = 14;
            Assert.IsFalse(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(14, iStatsDB);

            // but it will see it if we tell it to reload files
            repository2.DiscardCachedFiles();
            iStatsDB = 15;
            Assert.IsTrue(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(12, iStatsDB);

            // now delete the setting via repository
            repository.TitleLBDefaultDBDelete(c_tid1);

            // tell repository2 to reload it's files
            repository2.DiscardCachedFiles();

            // repository2 should still see the setting, beacuse
            // the change has not been submitted yet
            repository2.DiscardCachedFiles();
            iStatsDB = 16;
            Assert.IsTrue(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(12, iStatsDB);

            // now submit the change via repository 1
            repository.TitleSubmit(c_tid1, "TitleLBDefaultDBTest");

            // repository2 won't see the delete because it has a cached value
            iStatsDB = 17;
            Assert.IsTrue(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(12, iStatsDB);

            // but if it reloads files, it will see the delete
            repository2.DiscardCachedFiles();
            iStatsDB = 18;
            Assert.IsFalse(repository2.TitleLBDefaultDBGet(c_tid1, ref iStatsDB));
            Assert.AreEqual(18, iStatsDB);

            // leave the file with something in it so we can
            // view it.
            repository.TitleLBDefaultDBSet(c_tid1, 19);
            repository.TitleSubmit(c_tid1, "TitleLBDefaultDBTest");

        }


        [Test]
        public void TitleLBLimitsTest()
        {
            // no parameter validation to test in the constructor, null is allowed
            // for all params
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            bool bThrown;

            CreateTestTitles(repository, log);

            uint uiMaxWrites = 0;
            uint uiMaxReads = 0;

            // param validation
            bThrown = false;
            try
            {
                repository.TitleLBLimitsGet(null, ref uiMaxWrites, ref uiMaxReads);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleLBLimitsSet(null, uiMaxWrites, uiMaxReads);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleLBLimitsDelete(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // get from c_tid1 should return nothing right now
            uiMaxWrites = 1;
            uiMaxReads = 2;
            Assert.IsFalse(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(1, uiMaxWrites);
            Assert.AreEqual(2, uiMaxReads);

            // get from c_tid2 should return nothing right now
            uiMaxWrites = 3;
            uiMaxReads = 4;
            Assert.IsFalse(repository.TitleLBLimitsGet(c_tid2, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(3, uiMaxWrites);
            Assert.AreEqual(4, uiMaxReads);

            // set to c_tid1, and we should be able to get it back
            uiMaxWrites = 5;
            uiMaxReads = 6;
            repository.TitleLBLimitsSet(c_tid1, uiMaxWrites, uiMaxReads);
            uiMaxWrites = 7;
            uiMaxReads = 8;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(5, uiMaxWrites);
            Assert.AreEqual(6, uiMaxReads);

            // c_tid2 should require an upgrade before the set, but not after
            Assert.IsTrue(repository.TitleStatsUpgradeRequired(c_tid2));
            uiMaxWrites = 9;
            uiMaxReads = 10;
            repository.TitleLBLimitsSet(c_tid2, uiMaxWrites, uiMaxReads);
            uiMaxWrites = 11;
            uiMaxReads = 12;
            Assert.IsTrue(repository.TitleLBLimitsGet(c_tid2, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(9, uiMaxWrites);
            Assert.AreEqual(10, uiMaxReads);
            Assert.IsFalse(repository.TitleStatsUpgradeRequired(c_tid2));

            // submit tid1 to the repository so we can look at it after the
            // tests
            repository.TitleSubmit(c_tid1, "TitleLBLimitsTest");

            // now test delete
            uiMaxWrites = 13;
            uiMaxReads = 14;
            repository.TitleLBLimitsDelete(c_tid1);
            uiMaxWrites = 15;
            uiMaxReads = 16;
            Assert.IsFalse(repository.TitleLBLimitsGet(c_tid1, ref uiMaxWrites, ref uiMaxReads));
            Assert.AreEqual(15, uiMaxWrites);
            Assert.AreEqual(16, uiMaxReads);

        }

        [Test]
        public void TitleUnitConfigTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            int iUnitDatabase = -1;

            double dDecayFactor = 0.0;
            uint uiMaxAvailUnits = 0;
            uint uiSizeUnitCache = 0;

            // First all the param validation tests
            bThrown = false;
            try
            {
                repository1.TitleUnitConfigSet(null, iUnitDatabase, dDecayFactor, uiMaxAvailUnits, uiSizeUnitCache);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitConfigGet(null, ref iUnitDatabase, ref dDecayFactor, ref uiMaxAvailUnits, ref uiSizeUnitCache);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDeleteAll(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // get the unit from each title config - should be missing
            iUnitDatabase = 1;
            dDecayFactor = 2.0;
            uiMaxAvailUnits = 3;
            uiSizeUnitCache = 4;
            Assert.IsFalse(repository1.TitleUnitConfigGet(
                c_tid1,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(1, iUnitDatabase);
            Assert.AreEqual(2.0, dDecayFactor);
            Assert.AreEqual(3, uiMaxAvailUnits);
            Assert.AreEqual(4, uiSizeUnitCache);

            iUnitDatabase = 5;
            dDecayFactor = 6.0;
            uiMaxAvailUnits = 7;
            uiSizeUnitCache = 8;
            Assert.IsFalse(repository1.TitleUnitConfigGet(
                c_tid2,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(5, iUnitDatabase);
            Assert.AreEqual(6.0, dDecayFactor);
            Assert.AreEqual(7, uiMaxAvailUnits);
            Assert.AreEqual(8, uiSizeUnitCache);

            iUnitDatabase = 9;
            dDecayFactor = 10.0;
            uiMaxAvailUnits = 11;
            uiSizeUnitCache = 12;
            Assert.IsFalse(repository1.TitleUnitConfigGet(
                c_tid3,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(9, iUnitDatabase);
            Assert.AreEqual(10.0, dDecayFactor);
            Assert.AreEqual(11, uiMaxAvailUnits);
            Assert.AreEqual(12, uiSizeUnitCache);

            // set to tid1
            iUnitDatabase = 13;
            dDecayFactor = 14.0;
            uiMaxAvailUnits = 15;
            uiSizeUnitCache = 16;
            repository1.TitleUnitConfigSet(
                c_tid1,
                iUnitDatabase,
                dDecayFactor,
                uiMaxAvailUnits,
                uiSizeUnitCache);
            iUnitDatabase = 17;
            dDecayFactor = 18.0;
            uiMaxAvailUnits = 19;
            uiSizeUnitCache = 20;
            Assert.IsTrue(repository1.TitleUnitConfigGet(
                c_tid1,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(13, iUnitDatabase);
            Assert.AreEqual(14.0, dDecayFactor);
            Assert.AreEqual(15, uiMaxAvailUnits);
            Assert.AreEqual(16, uiSizeUnitCache);

            // get from a legacy title that has a decay factor in
            // the stats.xml file, this should work.
            iUnitDatabase = 9;
            dDecayFactor = 10.0;
            uiMaxAvailUnits = 11;
            uiSizeUnitCache = 12;
            Assert.IsTrue(repository1.TitleUnitConfigGet(
                c_tid4,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(2, iUnitDatabase);
            Assert.AreEqual(90.0, dDecayFactor);
            Assert.AreEqual(100, uiMaxAvailUnits);
            Assert.AreEqual(100, uiSizeUnitCache);

            // upgrade the titles and make sure the decay factor carries over as 
            // expected
            repository1.TitleStatsUpgrade(c_tid2);
            repository1.TitleStatsUpgrade(c_tid3);
            repository1.TitleStatsUpgrade(c_tid4);

            // tid2 didn't have a decay factor, shouldn't be a unit config
            iUnitDatabase = 5;
            dDecayFactor = 6.0;
            uiMaxAvailUnits = 7;
            uiSizeUnitCache = 8;
            Assert.IsFalse(repository1.TitleUnitConfigGet(
                c_tid2,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(5, iUnitDatabase);
            Assert.AreEqual(6.0, dDecayFactor);
            Assert.AreEqual(7, uiMaxAvailUnits);
            Assert.AreEqual(8, uiSizeUnitCache);

            // tid3 was a stats.ini file - no decay factor - no units
            iUnitDatabase = 9;
            dDecayFactor = 10.0;
            uiMaxAvailUnits = 11;
            uiSizeUnitCache = 12;
            Assert.IsFalse(repository1.TitleUnitConfigGet(
                c_tid3,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(9, iUnitDatabase);
            Assert.AreEqual(10.0, dDecayFactor);
            Assert.AreEqual(11, uiMaxAvailUnits);
            Assert.AreEqual(12, uiSizeUnitCache);

            // tid4 was a stats.xml title that has a decay factor and unit leaderboards
            // the unit config should be there.
            iUnitDatabase = 9;
            dDecayFactor = 10.0;
            uiMaxAvailUnits = 11;
            uiSizeUnitCache = 12;
            Assert.IsTrue(repository1.TitleUnitConfigGet(
                c_tid4,
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache));
            Assert.AreEqual(2, iUnitDatabase);
            Assert.AreEqual(90.0, dDecayFactor);
            Assert.AreEqual(100, uiMaxAvailUnits);
            Assert.AreEqual(100, uiSizeUnitCache);

        }

        [Test]
        public void TitleCompPartitionTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown = false;
            int iStatsDB = -1;

            // parameter validation
            bThrown = false;
            try
            {
                repository1.TitleCompPartitionGet(null, 0u, ref iStatsDB);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompPartitionGet(c_tid1, 4u, ref iStatsDB);
            }
            catch (ArgumentOutOfRangeException e)
            {
                Assert.AreEqual("uiPartitionId", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompPartitionSet(null, 0u, 0);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompPartitionSet(c_tid1, 4u, 0);
            }
            catch (ArgumentOutOfRangeException e)
            {
                Assert.AreEqual("uiPartitionId", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompPartitionDelete(null, 0u);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompPartitionDelete(c_tid1, 4u);
            }
            catch (ArgumentOutOfRangeException e)
            {
                Assert.AreEqual("uiPartitionId", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);


            // should be no competition partitions for an empty title
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 0u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 1u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 2u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 3u, ref iStatsDB));

            // should be no competition partitions for a legacy title
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid2, 0u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid2, 1u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid2, 2u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid2, 3u, ref iStatsDB));

            // set partitions, then retrieve them
            repository1.TitleCompPartitionSet(c_tid1, 0u, 2);
            repository1.TitleCompPartitionSet(c_tid1, 1u, 3);
            repository1.TitleCompPartitionSet(c_tid1, 2u, 4);
            repository1.TitleCompPartitionSet(c_tid1, 3u, 5);
            iStatsDB = 0;
            Assert.IsTrue(repository1.TitleCompPartitionGet(c_tid1, 0u, ref iStatsDB));
            Assert.AreEqual(2, iStatsDB);
            iStatsDB = 0;
            Assert.IsTrue(repository1.TitleCompPartitionGet(c_tid1, 1u, ref iStatsDB));
            Assert.AreEqual(3, iStatsDB);
            iStatsDB = 0;
            Assert.IsTrue(repository1.TitleCompPartitionGet(c_tid1, 2u, ref iStatsDB));
            Assert.AreEqual(4, iStatsDB);
            iStatsDB = 0;
            Assert.IsTrue(repository1.TitleCompPartitionGet(c_tid1, 3u, ref iStatsDB));
            Assert.AreEqual(5, iStatsDB);

            // delete them, and make sure they're gone
            repository1.TitleCompPartitionDelete(c_tid1, 0u);
            repository1.TitleCompPartitionDelete(c_tid1, 1u);
            repository1.TitleCompPartitionDelete(c_tid1, 2u);
            repository1.TitleCompPartitionDelete(c_tid1, 3u);
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 0u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 1u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 2u, ref iStatsDB));
            Assert.IsFalse(repository1.TitleCompPartitionGet(c_tid1, 3u, ref iStatsDB));

            // setting a competition partition on a legacy title should upgrade it
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            repository1.TitleCompPartitionSet(c_tid2, 0u, 2);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // same for the delete call
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            repository1.TitleCompPartitionSet(c_tid4, 0u, 2);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

        }

        [Test]
        public void TitleLBTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            // First all the param validation tests
            bThrown = false;
            try
            {
                repository1.TitleStatsUpgradeRequired(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleStatsUpgrade(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBGet(
                    null,
                    uiLBNum, 
                    ref iStatsDatabase,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBSet(
                    null,
                    uiLBNum, 
                    iStatsDatabase,
                    riLBResetInterval,
                    uiAttachmentCount,
                    uiMaxAttachmentSize,
                    uiDecayDays,
                    uiMaxRatingCount,
                    bArbitrationRequired,
                    bIsTeam,
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBDelete(
                    null,
                    uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2 and c_tid2 should
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));

            // get the leaderboard list from each title, confirm it contains
            // the expected values

            // tid 1 currently has no leaderboards defined
            uint[] rgui = repository1.TitleLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            // tid 2 should have leaderboards 1, 2 and 3
            rgui = repository1.TitleLBGetList(c_tid2);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);

            // tid 3 should have leaderboards 1 through 7, plus 10
            rgui = repository1.TitleLBGetList(c_tid3);
            Assert.AreEqual(8, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(5, rgui[4]);
            Assert.AreEqual(6, rgui[5]);
            Assert.AreEqual(7, rgui[6]);
            Assert.AreEqual(10, rgui[7]);

            // test the get function when working on legacy data
            uiLBNum = 2;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleLBGet(
                c_tid2,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(2, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // this is coming from stats.ini
            uiLBNum = 5;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;

            Assert.IsTrue(repository1.TitleLBGet(
                c_tid3,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(3, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEvery3Months, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now, add a couple leaderboards to the v3 title, and get them back
            uiLBNum = 2;
            iStatsDatabase = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 2;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = false;
            Assert.IsTrue(repository1.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(1, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(2, uiAttachmentCount);
            Assert.AreEqual(3, uiMaxAttachmentSize);
            Assert.AreEqual(4, uiDecayDays);
            Assert.AreEqual(5, uiMaxRatingCount);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.AreEqual(51, uiEntriesPerCacheLine);
            Assert.AreEqual(901, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            uiLBNum = 7;
            iStatsDatabase = 2;
            riLBResetInterval = ELBReset.ResetEveryMonth;
            uiAttachmentCount = 6;
            uiMaxAttachmentSize = 7;
            uiDecayDays = 8;
            uiMaxRatingCount = 9;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 7;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleLBGet(
                c_tid1,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(2, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryMonth, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(8, uiDecayDays);
            Assert.AreEqual(9, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            Assert.AreEqual(52, uiEntriesPerCacheLine);
            Assert.AreEqual(902, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now test the autoupgrade functionality.

            // update a leaderboard in tid2
            uiLBNum = 3;
            iStatsDatabase = 3;
            riLBResetInterval = ELBReset.ResetEvery2Months;
            uiAttachmentCount = 10;
            uiMaxAttachmentSize = 11;
            uiDecayDays = 12;
            uiMaxRatingCount = 13;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 53;
            uiExpirationSeconds = 903;
            bDontList = true;
            repository1.TitleLBSet(
                c_tid2,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // this title should no longer require an upgrade
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // it should still have 3 leaderboards...
            rgui = repository1.TitleLBGetList(c_tid2);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);

            // leaderboards 1 and 2 should match their old definitions
            uiLBNum = 1;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEvery2Months;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            bDontList = true;
            repository1.TitleLBGet(
                c_tid2,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
            Assert.AreEqual(2, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(0, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            uiLBNum = 2;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetEvery2Months;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            bDontList = true;
            repository1.TitleLBGet(
                c_tid2,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
            Assert.AreEqual(2, iStatsDatabase);
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(10000, uiAttachmentCount);
            Assert.AreEqual(20000, uiMaxAttachmentSize);
            Assert.AreEqual(90, uiDecayDays);
            Assert.AreEqual(100, uiMaxRatingCount);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // delete a leaderboard from tid3
            uiLBNum = 5;
            repository1.TitleLBDelete(c_tid3, uiLBNum);

            // this title should no longer require an upgrade
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid3));
            rgui = repository1.TitleLBGetList(c_tid3);
            Assert.AreEqual(7, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(6, rgui[4]);
            Assert.AreEqual(7, rgui[5]);
            Assert.AreEqual(10, rgui[6]);

            // all the remaining leaderboards should look the same
            // except for reset interval
            foreach(uint ui in rgui)
            {
                uiLBNum = ui;
                iStatsDatabase = 0;
                riLBResetInterval = ELBReset.ResetNever;
                uiAttachmentCount = 0;
                uiMaxAttachmentSize = 0;
                uiDecayDays = 0;
                uiMaxRatingCount = 0;
                bArbitrationRequired = false;
                bIsTeam = false;
                eloConfig = null;
                bDontList = true;
                Assert.IsTrue(repository1.TitleLBGet(
                    c_tid3,
                    uiLBNum, 
                    ref iStatsDatabase,
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList));
                Assert.AreEqual(3, iStatsDatabase);
                Assert.AreEqual(0, uiAttachmentCount);
                Assert.AreEqual(0, uiMaxAttachmentSize);
                Assert.AreEqual(0, uiDecayDays);
                Assert.AreEqual(0, uiMaxRatingCount);
                Assert.AreEqual(false, bArbitrationRequired);
                Assert.AreEqual(false, bIsTeam);
                Assert.IsTrue(eloConfig == null);
                Assert.AreEqual(50, uiEntriesPerCacheLine);
                Assert.AreEqual(900, uiExpirationSeconds);
                Assert.AreEqual(false, bDontList);

                switch (ui)
                {
                case 1:
                    Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
                    break;
                case 2:
                    Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
                    break;
                case 3:
                    Assert.AreEqual(ELBReset.ResetEveryMonth, riLBResetInterval);
                    break;
                case 4:
                    Assert.AreEqual(ELBReset.ResetEvery2Months, riLBResetInterval);
                    break;
                case 6:
                    Assert.AreEqual(ELBReset.ResetEvery6Months, riLBResetInterval);
                    break;
                case 7:
                    Assert.AreEqual(ELBReset.ResetEveryYear, riLBResetInterval);
                    break;
                case 10:
                    Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
                    break;
                default:
                    Assert.Fail();
                    break;
                }
            }

            // now none of these changes should be visible through a different
            // repository object, because they haven't been submitted...
            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2 and c_tid2 should
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));

            // get the leaderboard list from each title, confirm it contains
            // the expected values

            rgui = repository2.TitleLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            rgui = repository2.TitleLBGetList(c_tid2);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);

            rgui = repository2.TitleLBGetList(c_tid3);
            Assert.AreEqual(8, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(5, rgui[4]);
            Assert.AreEqual(6, rgui[5]);
            Assert.AreEqual(7, rgui[6]);
            Assert.AreEqual(10, rgui[7]);

            // now submit the changes made through repository1
            repository1.TitleSubmit(c_tid1, "CRepository unittest");
            repository1.TitleSubmit(c_tid2, "CRepository unittest");
            repository1.TitleSubmit(c_tid3, "CRepository unittest");

            // repository2 still has the old files cached however
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));

            rgui = repository2.TitleLBGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            rgui = repository2.TitleLBGetList(c_tid2);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);

            rgui = repository2.TitleLBGetList(c_tid3);
            Assert.AreEqual(8, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(5, rgui[4]);
            Assert.AreEqual(6, rgui[5]);
            Assert.AreEqual(7, rgui[6]);
            Assert.AreEqual(10, rgui[7]);

            // get rid of any cached files on repository2
            repository2.DiscardCachedFiles();

            // now repository2 should see the new stuff
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid3));

            rgui = repository2.TitleLBGetList(c_tid1);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(2, rgui[0]);
            Assert.AreEqual(7, rgui[1]);

            rgui = repository2.TitleLBGetList(c_tid2);
            Assert.AreEqual(3, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);

            rgui = repository2.TitleLBGetList(c_tid3);
            Assert.AreEqual(7, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);
            Assert.AreEqual(3, rgui[2]);
            Assert.AreEqual(4, rgui[3]);
            Assert.AreEqual(6, rgui[4]);
            Assert.AreEqual(7, rgui[5]);
            Assert.AreEqual(10, rgui[6]);
        }

        [Test]
        public void TitleUnitTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            // First all the param validation tests
            bThrown = false;
            try
            {
                repository1.TitleUnitGet(
                    null,
                    uiLBNum, 
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitSet(
                    null,
                    uiLBNum, 
                    bArbitrationRequired,
                    bIsTeam,
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDelete(
                    null,
                    uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2, c_tid3 and c_tid4 should
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));

            // get the unit leaderboard list from each title, confirm it contains
            // the expected values

            // tid 1 currently has no unit leaderboards defined
            uint[] rgui = repository1.TitleUnitGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            // tid 2 should have no unit leaderboards - it's using a "legacy" stats file
            rgui = repository1.TitleUnitGetList(c_tid2);
            Assert.AreEqual(0, rgui.Length);

            // tid 3 should have no unit leaderboards
            rgui = repository1.TitleUnitGetList(c_tid3);
            Assert.AreEqual(0, rgui.Length);

            // tid 4 should have unit leaderboards 3 & 4
            rgui = repository1.TitleUnitGetList(c_tid4);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(3, rgui[0]);
            Assert.AreEqual(4, rgui[1]);

            // test the get function when working on v3 stats.xml data
            uiLBNum = 4;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleUnitGet(
                c_tid4,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now, add a couple unit leaderboards to the v3 title, and get them back
            uiLBNum = 2;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 2;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = false;
            Assert.IsTrue(repository1.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.AreEqual(51, uiEntriesPerCacheLine);
            Assert.AreEqual(901, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            uiLBNum = 7;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 7;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleUnitGet(
                c_tid1,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            Assert.AreEqual(52, uiEntriesPerCacheLine);
            Assert.AreEqual(902, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now test the autoupgrade functionality.

            // update a unit leaderboard in tid4
            uiLBNum = 3;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 53;
            uiExpirationSeconds = 903;
            bDontList = true;
            repository1.TitleUnitSet(
                c_tid4,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // this title should no longer require an upgrade
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // it should still have 2 unit leaderboards...
            rgui = repository1.TitleUnitGetList(c_tid4);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(3, rgui[0]);
            Assert.AreEqual(4, rgui[1]);

            // unit leaderboard 4 should match their old definitions
            uiLBNum = 4;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            bDontList = true;
            repository1.TitleUnitGet(
                c_tid4,
                uiLBNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // delete a unit leaderboard from tid2
            uiLBNum = 5;
            repository1.TitleLBDelete(c_tid2, uiLBNum);
            // did the upgrade, but was a noop on the delete because it has no unit leaderboards

            // now none of these changes should be visible through a different
            // repository object, because they haven't been submitted...
            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2 and c_tid2 should
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid4));

            // now submit the changes made through repository1
            repository1.TitleSubmit(c_tid1, "CRepository unittest");
            repository1.TitleSubmit(c_tid2, "CRepository unittest");
            repository1.TitleSubmit(c_tid3, "CRepository unittest");
            repository1.TitleSubmit(c_tid4, "CRepository unittest");

            // repository2 still has the old files cached however
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid4));

            // get rid of any cached files on repository2
            repository2.DiscardCachedFiles();

            // now repository2 should see the new stuff
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid4));
        }

        [Test]
        public void TitleCompTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            // First all the param validation tests
            bThrown = false;
            try
            {
                repository1.TitleCompGet(
                    null,
                    uiLBNum, 
                    ref riLBResetInterval,
                    ref uiAttachmentCount,
                    ref uiMaxAttachmentSize,
                    ref uiDecayDays,
                    ref bArbitrationRequired,
                    ref bIsTeam,
                    ref eloConfig,
                    ref uiEntriesPerCacheLine,
                    ref uiExpirationSeconds,
                    ref bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompSet(
                    null,
                    uiLBNum, 
                    riLBResetInterval,
                    uiAttachmentCount,
                    uiMaxAttachmentSize,
                    uiDecayDays,
                    bArbitrationRequired,
                    bIsTeam,
                    eloConfig,
                    uiEntriesPerCacheLine,
                    uiExpirationSeconds,
                    bDontList);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDelete(
                    null,
                    uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2, c_tid3, and c_tid4 should
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));

            // get the comp template list from each title, confirm it contains
            // the expected values

            // tid 1 currently has no templates defined
            uint[] rgui = repository1.TitleCompGetList(c_tid1);
            Assert.AreEqual(0, rgui.Length);

            // tid 2 is using a legacy stats xsc file, no templates
            rgui = repository1.TitleCompGetList(c_tid2);
            Assert.AreEqual(0, rgui.Length);

            // tid 3 is using stats.ini, no templates
            rgui = repository1.TitleCompGetList(c_tid3);
            Assert.AreEqual(0, rgui.Length);

            // tid 4 is using a v3 stats xsc file, should have templates 1 and 2
            rgui = repository1.TitleCompGetList(c_tid4);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // test the get function when working on legacy data
            // note - not all parameters are stored in xsc, so some don't get changed!
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = false;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleCompGet(
                c_tid4,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(2, uiAttachmentCount);
            Assert.AreEqual(3, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.AreEqual(null, eloConfig);
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now, add a couple templates to the v3 title, and get them back
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = false;
            Assert.IsTrue(repository1.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetEveryWeek, riLBResetInterval);
            Assert.AreEqual(2, uiAttachmentCount);
            Assert.AreEqual(3, uiMaxAttachmentSize);
            Assert.AreEqual(4, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40", eloConfig.ToStatsDBString());
            Assert.AreEqual(51, uiEntriesPerCacheLine);
            Assert.AreEqual(901, uiExpirationSeconds);
            Assert.AreEqual(true, bDontList);

            uiLBNum = 7;
            riLBResetInterval = ELBReset.ResetEveryMonth;
            uiAttachmentCount = 6;
            uiMaxAttachmentSize = 7;
            uiDecayDays = 8;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 52;
            uiExpirationSeconds = 902;
            bDontList = false;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            uiLBNum = 7;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 0;
            uiExpirationSeconds = 0;
            bDontList = true;
            Assert.IsTrue(repository1.TitleCompGet(
                c_tid1,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList));
            Assert.AreEqual(ELBReset.ResetEveryMonth, riLBResetInterval);
            Assert.AreEqual(6, uiAttachmentCount);
            Assert.AreEqual(7, uiMaxAttachmentSize);
            Assert.AreEqual(8, uiDecayDays);
            Assert.AreEqual(false, bArbitrationRequired);
            Assert.AreEqual(false, bIsTeam);
            Assert.IsTrue(eloConfig == null);
            Assert.AreEqual(52, uiEntriesPerCacheLine);
            Assert.AreEqual(902, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // now test the autoupgrade functionality.

            // update a template in tid4
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEvery2Months;
            uiAttachmentCount = 10;
            uiMaxAttachmentSize = 11;
            uiDecayDays = 12;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = null;
            uiEntriesPerCacheLine = 53;
            uiExpirationSeconds = 903;
            bDontList = true;
            repository1.TitleCompSet(
                c_tid4,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // this title should no longer require an upgrade
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // comp template 2 should still be there
            rgui = repository1.TitleCompGetList(c_tid4);
            Assert.AreEqual(2, rgui.Length);
            Assert.AreEqual(1, rgui[0]);
            Assert.AreEqual(2, rgui[1]);

            // template 2 should match its old definition
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            bDontList = true;
            repository1.TitleCompGet(
                c_tid4,
                uiLBNum, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList);
            Assert.AreEqual(ELBReset.ResetNever, riLBResetInterval);
            Assert.AreEqual(0, uiAttachmentCount);
            Assert.AreEqual(0, uiMaxAttachmentSize);
            Assert.AreEqual(0, uiDecayDays);
            Assert.AreEqual(true, bArbitrationRequired);
            Assert.AreEqual(true, bIsTeam);
            Assert.AreEqual("ELO_E=10;ELO_K=1000;ELO_NEW=32000;ELO_C=0:500,10:400", eloConfig.ToStatsDBString());
            Assert.AreEqual(50, uiEntriesPerCacheLine);
            Assert.AreEqual(900, uiExpirationSeconds);
            Assert.AreEqual(false, bDontList);

            // delete a template from tid2
            uiLBNum = 5;
            repository1.TitleCompDelete(c_tid2, uiLBNum);
            // delete was a no-op, but still should upgrade the title

            // this title should no longer require an upgrade
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // now none of these changes should be visible through a different
            // repository object, because they haven't been submitted...
            // right now, c_tid1 should report that it doesn't
            // need to be upgraded, but c_tid2 and c_tid2 should
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid4));

            // now submit the changes made through repository1
            repository1.TitleSubmit(c_tid1, "CRepository unittest");
            repository1.TitleSubmit(c_tid2, "CRepository unittest");
            repository1.TitleSubmit(c_tid3, "CRepository unittest");
            repository1.TitleSubmit(c_tid4, "CRepository unittest");

            // repository2 still has the old files cached however
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid4));

            // get rid of any cached files on repository2
            repository2.DiscardCachedFiles();

            // now repository2 should see the new stuff
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid1));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid2));
            Assert.IsTrue(repository2.TitleStatsUpgradeRequired(c_tid3));
            Assert.IsFalse(repository2.TitleStatsUpgradeRequired(c_tid4));

        }


        [Test]
        public void TitleLBDescTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard descriptions later
            uiLBNum = 1;
            iStatsDatabase = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            uiMaxRatingCount = 6;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleLBDescGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBDescSet(null, uiLBNum, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBDescSet(c_tid1, uiLBNum, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBDescSet(c_tid1, uiLBNum, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBDescDelete(null, uiLBNum, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBDescDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleLBDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleLBDescSet(c_tid1, uiLBNum, c_locEnCA, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleLBDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleLBDescDelete(c_tid1, uiLBNum, c_locEnUS);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleLBDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleLBDescDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleLBDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the v2 title
            uiLBNum = 2;
            sl = repository1.TitleLBDescGetList(c_tid2, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB2 Desc", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS LB2 Desc", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleLBDescGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleLBDescSet(c_tid2, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid2, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA LB1 Desc", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // confirm that setting a description on a v1 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleLBDescSet(c_tid3, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleLBDescGetList(c_tid3, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid3));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid2, "TitleLBDescTest");
            repository1.TitleSubmit(c_tid3, "TitleLBDescTest");

        }

        [Test]
        public void TitleUnitDescTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title add a unit leaderboard so we can
            // set/get/delete leaderboard descriptions later
            uiLBNum = 1;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleUnitDescGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDescSet(null, uiLBNum, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitDescSet(c_tid1, uiLBNum, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDescSet(c_tid1, uiLBNum, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDescDelete(null, uiLBNum, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitDescDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleUnitDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleUnitDescSet(c_tid1, uiLBNum, c_locEnCA, sDesc);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleUnitDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleUnitDescDelete(c_tid1, uiLBNum, c_locEnUS);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleUnitDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleUnitDescDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleUnitDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the title using a v3 stats.xml
            uiLBNum = 4;
            sl = repository1.TitleUnitDescGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 Desc", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS LB4 Desc", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleUnitDescGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a title using stats.xml triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 4;
            sDesc = "en-US description 3";
            repository1.TitleUnitDescSet(c_tid4, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleUnitDescGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA LB4 Desc", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleCompDescTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title add a unit leaderboard so we can
            // set/get/delete leaderboard descriptions later
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleCompDescGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDescSet(null, uiLBNum, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompDescSet(c_tid1, uiLBNum, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDescSet(c_tid1, uiLBNum, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDescDelete(null, uiLBNum, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompDescDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleCompDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleCompDescSet(c_tid1, uiLBNum, c_locEnCA, sDesc);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleCompDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleCompDescDelete(c_tid1, uiLBNum, c_locEnUS);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleCompDescSet(c_tid1, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleCompDescDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleCompDescGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the title using a v3 stats.xml
            uiLBNum = 2;
            sl = repository1.TitleCompDescGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 Desc", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS LBT2 Desc", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleCompDescGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a title using stats.xml triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 2;
            sDesc = "en-US description 3";
            repository1.TitleCompDescSet(c_tid4, uiLBNum, c_locEnUS, sDesc);
            sl = repository1.TitleCompDescGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA LBT2 Desc", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }


        [Test]
        public void TitleLBAddrTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            uint uiId = 0;
            bool bIsPuid = false;
            SortedList sl;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard attributes later
            uiLBNum = 1;
            iStatsDatabase = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            uiMaxRatingCount = 6;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleLBAttrGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBAttrSet(null, uiLBNum, uiId, bIsPuid);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBAttrDelete(null, uiLBNum, uiId);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBAttrDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set an attribute and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleLBAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(bIsPuid, sl[uiId]);

            // set another one.
            uiLBNum = 1;
            uiId = 3;
            bIsPuid = false;
            repository1.TitleLBAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // reset the first one again
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = false;
            repository1.TitleLBAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke the first one
            uiLBNum = 1;
            uiId = 2;
            repository1.TitleLBAttrDelete(c_tid1, uiLBNum, uiId);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)3]);

            // add it back
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleLBAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleLBAttrDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleLBAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get attributes out of the v2 title
            uiLBNum = 2;
            sl = repository1.TitleLBAttrGetList(c_tid2, uiLBNum);
            Assert.AreEqual(3, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(false, sl[(uint)4]);

            // shouldn't be any attributes in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleLBAttrGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting an attribute on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            uiLBNum = 2;
            uiId = 6;
            bIsPuid = true;
            repository1.TitleLBAttrSet(c_tid2, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid2, uiLBNum);
            Assert.AreEqual(4, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(true, sl[(uint)3]);
            Assert.AreEqual(false, sl[(uint)4]);
            Assert.AreEqual(true, sl[(uint)6]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // confirm that setting a description on a v1 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleLBAttrSet(c_tid3, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleLBAttrGetList(c_tid3, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid3));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid2, "TitleLBDescTest");
            repository1.TitleSubmit(c_tid3, "TitleLBDescTest");

        }

        [Test]
        public void TitleUnitAddrTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            uint uiId = 0;
            bool bIsPuid = false;
            SortedList sl;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard attributes later
            uiLBNum = 1;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleUnitAttrGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitAttrSet(null, uiLBNum, uiId, bIsPuid);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitAttrDelete(null, uiLBNum, uiId);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitAttrDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set an attribute and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleUnitAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(bIsPuid, sl[uiId]);

            // set another one.
            uiLBNum = 1;
            uiId = 3;
            bIsPuid = false;
            repository1.TitleUnitAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // reset the first one again
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = false;
            repository1.TitleUnitAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke the first one
            uiLBNum = 1;
            uiId = 2;
            repository1.TitleUnitAttrDelete(c_tid1, uiLBNum, uiId);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)3]);

            // add it back
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleUnitAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleUnitAttrDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleUnitAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get attributes out of the v2 title
            uiLBNum = 4;
            sl = repository1.TitleUnitAttrGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)6]);
            Assert.AreEqual(false, sl[(uint)7]);

            // shouldn't be any attributes in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleUnitAttrGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting an attribute on a title using stats.xml triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 4;
            uiId = 6;
            bIsPuid = true;
            repository1.TitleUnitAttrSet(c_tid4, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleUnitAttrGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)6]);
            Assert.AreEqual(false, sl[(uint)7]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleCompAddrTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            uint uiId = 0;
            bool bIsPuid = false;
            SortedList sl;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard attributes later
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleCompAttrGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompAttrSet(null, uiLBNum, uiId, bIsPuid);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompAttrDelete(null, uiLBNum, uiId);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompAttrDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now set an attribute and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleCompAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(bIsPuid, sl[uiId]);

            // set another one.
            uiLBNum = 1;
            uiId = 3;
            bIsPuid = false;
            repository1.TitleCompAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // reset the first one again
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = false;
            repository1.TitleCompAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke the first one
            uiLBNum = 1;
            uiId = 2;
            repository1.TitleCompAttrDelete(c_tid1, uiLBNum, uiId);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)3]);

            // add it back
            uiLBNum = 1;
            uiId = 2;
            bIsPuid = true;
            repository1.TitleCompAttrSet(c_tid1, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(true, sl[(uint)2]);
            Assert.AreEqual(false, sl[(uint)3]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleCompAttrDeleteAll(c_tid1, uiLBNum);
            sl = repository1.TitleCompAttrGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // now get attributes out of a title using stats.xml
            uiLBNum = 2;
            sl = repository1.TitleCompAttrGetList(c_tid4, uiLBNum);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);

            // shouldn't be any attributes in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleCompAttrGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting an attribute on a title using stats.xml triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 2;
            uiId = 6;
            bIsPuid = true;
            repository1.TitleCompAttrSet(c_tid4, uiLBNum, uiId, bIsPuid);
            sl = repository1.TitleCompAttrGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual(false, sl[(uint)1]);
            Assert.AreEqual(true, sl[(uint)6]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleLBValueTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            string sName = "1";
            string sFormula = String.Empty;
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string[] rgs;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard formatted values later
            uiLBNum = 1;
            iStatsDatabase = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            uiMaxRatingCount = 6;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleLBValueGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueGet(null, uiLBNum, sName, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueGet(c_tid1, uiLBNum, null, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueSet(null, uiLBNum, sName, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueSet(c_tid1, uiLBNum, null, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sFormula", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueDelete(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleLBValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            uiLBNum = 2;
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleLBValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            // now set a value and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Days;
            sFormula = "attr[2]";
            repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            returnType = EWebValueReturnType.Float;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[2]", sFormula);

            // set another one.
            uiLBNum = 1;
            sName = "5";
            returnType = EWebValueReturnType.Gamertag;
            sFormula = "attr[5]";
            repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Hours;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("attr[5]", sFormula);

            // reset the first one again
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.HundredMilliseconds;
            sFormula = "attr[2+1]";
            repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Integer;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("attr[2+1]", sFormula);

            // now nuke the first one
            uiLBNum = 1;
            sName = "2";
            repository1.TitleLBValueDelete(c_tid1, uiLBNum, sName);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("5", rgs[0]);

            // add it back
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Millisecond;
            sFormula = "attr[2+2]";
            repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Millisecond, returnType);
            Assert.AreEqual("attr[2+2]", sFormula);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleLBValueDeleteAll(c_tid1, uiLBNum);
            rgs = repository1.TitleLBValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // now get values out of the v2 title
            uiLBNum = 2;
            rgs = repository1.TitleLBValueGetList(c_tid2, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("3501", rgs[0]);
            Assert.AreEqual("5902", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid2, uiLBNum, "3501", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]", sFormula);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid2, uiLBNum, "5902", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("1+2+3", sFormula);

            // shouldn't be any values in the v1 title
            uiLBNum = 1;
            rgs = repository1.TitleLBValueGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // confirm that setting a value on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            uiLBNum = 2;
            sName = "7";
            returnType = EWebValueReturnType.Percent;
            sFormula = "attr[7]";
            repository1.TitleLBValueSet(c_tid2, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid2, uiLBNum);
            Assert.AreEqual(3, rgs.Length);
            Assert.AreEqual("3501", rgs[0]);
            Assert.AreEqual("5902", rgs[1]);
            Assert.AreEqual("7", rgs[2]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid2, uiLBNum, "3501", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]", sFormula);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid2, uiLBNum, "5902", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Integer, returnType);
            Assert.AreEqual("1+2+3", sFormula);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid2, uiLBNum, "7", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Percent, returnType);
            Assert.AreEqual("attr[7]", sFormula);

            // confirm that setting a description on a v1 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            uiLBNum = 1;
            sName = "9";
            returnType = EWebValueReturnType.Timestamp;
            sFormula = "attr[9]";
            repository1.TitleLBValueSet(c_tid3, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleLBValueGetList(c_tid3, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("9", rgs[0]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleLBValueGet(c_tid3, uiLBNum, "9", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Timestamp, returnType);
            Assert.AreEqual("attr[9]", sFormula);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid3));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid2, "TitleLBDescTest");

        }

        [Test]
        public void TitleUnitValueTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            string sName = "1";
            string sFormula = String.Empty;
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string[] rgs;

            // c_tid1 is our up to date title add a unit leaderboard so we can
            // set/get/delete leaderboard formatted values later
            uiLBNum = 1;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleUnitValueGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueGet(null, uiLBNum, sName, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueGet(c_tid1, uiLBNum, null, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueSet(null, uiLBNum, sName, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueSet(c_tid1, uiLBNum, null, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sFormula", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueDelete(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleUnitValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            uiLBNum = 2;
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleUnitValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            // now set a value and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Days;
            sFormula = "attr[2]";
            repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            returnType = EWebValueReturnType.Float;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[2]", sFormula);

            // set another one.
            uiLBNum = 1;
            sName = "5";
            returnType = EWebValueReturnType.Gamertag;
            sFormula = "attr[5]";
            repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Hours;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("attr[5]", sFormula);

            // reset the first one again
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.HundredMilliseconds;
            sFormula = "attr[2+1]";
            repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Integer;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("attr[2+1]", sFormula);

            // now nuke the first one
            uiLBNum = 1;
            sName = "2";
            repository1.TitleUnitValueDelete(c_tid1, uiLBNum, sName);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("5", rgs[0]);

            // add it back
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Millisecond;
            sFormula = "attr[2+2]";
            repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Millisecond, returnType);
            Assert.AreEqual("attr[2+2]", sFormula);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleUnitValueDeleteAll(c_tid1, uiLBNum);
            rgs = repository1.TitleUnitValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // now get values out of the v2 title
            uiLBNum = 4;
            rgs = repository1.TitleUnitValueGetList(c_tid4, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            returnType = EWebValueReturnType.String;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid4, uiLBNum, "65", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]? 1 : 0", sFormula);

            // shouldn't be any values in the v1 title
            uiLBNum = 1;
            rgs = repository1.TitleUnitValueGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // confirm that setting a value on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 4;
            sName = "7";
            returnType = EWebValueReturnType.Percent;
            sFormula = "attr[7]";
            repository1.TitleUnitValueSet(c_tid4, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleUnitValueGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("65", rgs[0]);
            Assert.AreEqual("7", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid4, uiLBNum, "65", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("(int)attr[1]<(int)attr[2]? 1 : 0", sFormula);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleUnitValueGet(c_tid4, uiLBNum, "7", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Percent, returnType);
            Assert.AreEqual("attr[7]", sFormula);

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleCompValueTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            string sName = "1";
            string sFormula = String.Empty;
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string[] rgs;

            // c_tid1 is our up to date title add a leaderboard so we can
            // set/get/delete leaderboard formatted values later
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleCompValueGetList(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueGet(null, uiLBNum, sName, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueGet(c_tid1, uiLBNum, null, ref returnType, ref sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueSet(null, uiLBNum, sName, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueSet(c_tid1, uiLBNum, null, returnType, sFormula);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sFormula", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueDelete(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDelete(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleCompValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            uiLBNum = 2;
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);
            Assert.IsFalse(repository1.TitleCompValueGet(c_tid1, uiLBNum, "1", ref returnType, ref sFormula));

            // now set a value and get it back on the leaderboard
            // that exists
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Days;
            sFormula = "attr[2]";
            repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            returnType = EWebValueReturnType.Float;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Days, returnType);
            Assert.AreEqual("attr[2]", sFormula);

            // set another one.
            uiLBNum = 1;
            sName = "5";
            returnType = EWebValueReturnType.Gamertag;
            sFormula = "attr[5]";
            repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Hours;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Gamertag, returnType);
            Assert.AreEqual("attr[5]", sFormula);

            // reset the first one again
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.HundredMilliseconds;
            sFormula = "attr[2+1]";
            repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Integer;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.HundredMilliseconds, returnType);
            Assert.AreEqual("attr[2+1]", sFormula);

            // now nuke the first one
            uiLBNum = 1;
            sName = "2";
            repository1.TitleCompValueDelete(c_tid1, uiLBNum, sName);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("5", rgs[0]);

            // add it back
            uiLBNum = 1;
            sName = "2";
            returnType = EWebValueReturnType.Millisecond;
            sFormula = "attr[2+2]";
            repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("2", rgs[0]);
            Assert.AreEqual("5", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid1, uiLBNum, sName, ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Millisecond, returnType);
            Assert.AreEqual("attr[2+2]", sFormula);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleCompValueDeleteAll(c_tid1, uiLBNum);
            rgs = repository1.TitleCompValueGetList(c_tid1, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // now get values out of the v2 title
            uiLBNum = 2;
            rgs = repository1.TitleCompValueGetList(c_tid4, uiLBNum);
            Assert.AreEqual(1, rgs.Length);
            Assert.AreEqual("72", rgs[0]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid4, uiLBNum, "72", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("true", sFormula);

            // shouldn't be any values in the v1 title
            uiLBNum = 1;
            rgs = repository1.TitleCompValueGetList(c_tid3, uiLBNum);
            Assert.AreEqual(0, rgs.Length);

            // confirm that setting a value on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 2;
            sName = "7";
            returnType = EWebValueReturnType.Percent;
            sFormula = "attr[7]";
            repository1.TitleCompValueSet(c_tid4, uiLBNum, sName, returnType, sFormula);
            rgs = repository1.TitleCompValueGetList(c_tid4, uiLBNum);
            Assert.AreEqual(2, rgs.Length);
            Assert.AreEqual("7", rgs[0]);
            Assert.AreEqual("72", rgs[1]);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid4, uiLBNum, "7", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.Percent, returnType);
            Assert.AreEqual("attr[7]", sFormula);
            returnType = EWebValueReturnType.Minutes;
            sFormula = null;
            Assert.IsTrue(repository1.TitleCompValueGet(c_tid4, uiLBNum, "72", ref returnType, ref sFormula));
            Assert.AreEqual(EWebValueReturnType.String, returnType);
            Assert.AreEqual("true", sFormula);

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleLBValueDescTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title - add a leaderboard 
            uiLBNum = 1;
            iStatsDatabase = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            uiMaxRatingCount = 6;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // add a formatted value, so we have something to hang descriptions off
            string sName = "1";
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string sFormula = "attr[1]";
            repository1.TitleLBValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescGetList(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueDescSet(null, uiLBNum, sName, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescSet(c_tid1, uiLBNum, null, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBValueDescDelete(null, uiLBNum, sName, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescDelete(c_tid1, uiLBNum, null, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescDelete(c_tid1, uiLBNum, sName, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleLBDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back 
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, c_locEnCA, sDesc);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleLBValueDescDelete(c_tid1, uiLBNum, sName, c_locEnUS);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleLBValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleLBValueDescDeleteAll(c_tid1, uiLBNum, sName);
            sl = repository1.TitleLBValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the v2 title
            uiLBNum = 2;
            sName = "3501";
            sl = repository1.TitleLBValueDescGetList(c_tid2, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA value1", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS value1", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleLBValueDescGetList(c_tid3, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid2));
            uiLBNum = 2;
            sDesc = "enUS value1 updated";
            repository1.TitleLBValueDescSet(c_tid2, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleLBValueDescGetList(c_tid2, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enUS value1 updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA value1", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid2));

            // This throws because a v1 title cannot have formatted values
            // therefore you're trying to set a description on a value that doesn't exist.
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid3));
            uiLBNum = 1;
            sName = "1";
            sDesc = "enUS value1 updated2";
            bThrown = false;
            try
            {
                repository1.TitleLBValueDescSet(c_tid3, uiLBNum, sName, c_locEnUS, sDesc);
            }
            catch (CRepositoryException e)
            {
                Assert.IsFalse(e.Message.IndexOf("Cannot add a formatted value description because formatted value") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            sl = repository1.TitleLBValueDescGetList(c_tid3, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // note - while the call failed, the upgrade was a success.
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid3));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid2, "TitleLBDescTest");

        }

        [Test]
        public void TitleUnitValueDescTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title - add a leaderboard 
            uiLBNum = 1;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // add a formatted value, so we have something to hang descriptions off
            string sName = "1";
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string sFormula = "attr[1]";
            repository1.TitleUnitValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescGetList(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescSet(null, uiLBNum, sName, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, null, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescDelete(null, uiLBNum, sName, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescDelete(c_tid1, uiLBNum, null, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleUnitValueDescDelete(c_tid1, uiLBNum, sName, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleUnitDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back 
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, c_locEnCA, sDesc);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleUnitValueDescDelete(c_tid1, uiLBNum, sName, c_locEnUS);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleUnitValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleUnitValueDescDeleteAll(c_tid1, uiLBNum, sName);
            sl = repository1.TitleUnitValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the v2 title
            uiLBNum = 4;
            sName = "65";
            sl = repository1.TitleUnitValueDescGetList(c_tid4, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LB4 FV1", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS LB4 FV1", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleUnitValueDescGetList(c_tid3, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 4;
            sDesc = "enUS value1 updated";
            repository1.TitleUnitValueDescSet(c_tid4, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleUnitValueDescGetList(c_tid4, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enUS value1 updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA LB4 FV1", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid4, "TitleLBDescTest");

        }

        [Test]
        public void TitleCompValueDescTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList;

            String sDesc = String.Empty;
            SortedList sl;

            // c_tid1 is our up to date title - add a leaderboard 
            uiLBNum = 1;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 3;
            uiMaxAttachmentSize = 4;
            uiDecayDays = 5;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 52;
            bDontList = false;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);

            // add a formatted value, so we have something to hang descriptions off
            string sName = "1";
            EWebValueReturnType returnType = EWebValueReturnType.String;
            string sFormula = "attr[1]";
            repository1.TitleCompValueSet(c_tid1, uiLBNum, sName, returnType, sFormula);

            // first, parameter validation
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescGetList(null, uiLBNum, sName);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueDescSet(null, uiLBNum, sName, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescSet(c_tid1, uiLBNum, null, c_locEnUS, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, null, sDesc);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sDesc", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompValueDescDelete(null, uiLBNum, sName, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescDelete(c_tid1, uiLBNum, null, c_locEnUS);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository1.TitleCompValueDescDelete(c_tid1, uiLBNum, sName, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("locale", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository1.TitleCompDescDeleteAll(null, uiLBNum);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // test v3 title first. get should get nothing right now
            // both for a leaderboard that exists and one that doesn't
            uiLBNum = 1;
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            uiLBNum = 2;
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now set a description and get it back 
            uiLBNum = 1;
            sDesc = "en-US description";
            repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual(sDesc, sl[c_locEnUS.ToString()]);

            // set another one.
            uiLBNum = 1;
            sDesc = "en-CA description";
            repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, c_locEnCA, sDesc);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description", sl[c_locEnUS.ToString()]);

            // reset the first one again
            uiLBNum = 1;
            sDesc = "en-US description 2";
            repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 2", sl[c_locEnUS.ToString()]);

            // now nuke the first one
            uiLBNum = 1;
            repository1.TitleCompValueDescDelete(c_tid1, uiLBNum, sName, c_locEnUS);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(1, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);

            // add it back
            uiLBNum = 1;
            sDesc = "en-US description 3";
            repository1.TitleCompValueDescSet(c_tid1, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("en-CA description", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("en-US description 3", sl[c_locEnUS.ToString()]);

            // now nuke all of them
            uiLBNum = 1;
            repository1.TitleCompValueDescDeleteAll(c_tid1, uiLBNum, sName);
            sl = repository1.TitleCompValueDescGetList(c_tid1, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // now get descriptions out of the v2 title
            uiLBNum = 2;
            sName = "72";
            sl = repository1.TitleCompValueDescGetList(c_tid4, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enCA LBT2 FV1", sl[c_locEnCA.ToString()]);
            Assert.AreEqual("enUS LBT2 FV1", sl[c_locEnUS.ToString()]);

            // shouldn't be any descriptions in the v1 title
            uiLBNum = 1;
            sl = repository1.TitleCompValueDescGetList(c_tid3, uiLBNum, sName);
            Assert.AreEqual(0, sl.Count);

            // confirm that setting a description on a v2 title triggers
            // an upgrade
            Assert.IsTrue(repository1.TitleStatsUpgradeRequired(c_tid4));
            uiLBNum = 2;
            sDesc = "enUS value1 updated";
            repository1.TitleCompValueDescSet(c_tid4, uiLBNum, sName, c_locEnUS, sDesc);
            sl = repository1.TitleCompValueDescGetList(c_tid4, uiLBNum, sName);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("enUS value1 updated", sl[c_locEnUS.ToString()]);
            Assert.AreEqual("enCA LBT2 FV1", sl[c_locEnCA.ToString()]);
            Assert.IsFalse(repository1.TitleStatsUpgradeRequired(c_tid4));

            // not fully testing the title submit stuff at this time
            // just submit it so we have something in the repository to view
            repository1.TitleSubmit(c_tid2, "TitleLBDescTest");

        }

        [Test]
        public void TitleQueryPartitionTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);
            CRepository repository2 = new CRepository(null, null, log);

            bool bThrown;
            uint uiPartitionId = 0;

            CreateTestTitles(repository, log);

            // param validation
            bThrown = false;
            try
            {
                repository.TitleQueryPartitionGet(null, ref uiPartitionId);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleQueryPartitionSet(null, uiPartitionId);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleQueryPartitionDelete(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // get should return nothing right now
            uiPartitionId = 1;
            Assert.IsFalse(repository.TitleQueryPartitionGet(c_tid1, ref uiPartitionId));
            Assert.AreEqual(1, uiPartitionId);

            // set, and we should be able to get it back
            repository.TitleQueryPartitionSet(c_tid1, 2);
            uiPartitionId = 3;
            Assert.IsTrue(repository.TitleQueryPartitionGet(c_tid1, ref uiPartitionId));
            Assert.AreEqual(2, uiPartitionId);

            // delete, get should then return nothing again
            repository.TitleQueryPartitionDelete(c_tid1);
            uiPartitionId = 4;
            Assert.IsFalse(repository.TitleQueryPartitionGet(c_tid1, ref uiPartitionId));
            Assert.AreEqual(4, uiPartitionId);

            // deleteing when already gone should be a noop - shouldn't throw
            repository.TitleQueryPartitionDelete(c_tid1);

            // set a value then submit so we can view it
            repository.TitleQueryPartitionSet(c_tid1, 5);
            repository.TitleSubmit(c_tid1, "TitleQueryPartitionTest");
        }

        [Test]
        public void TitleQueryConfigXmlTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);

            bool bThrown;

            CreateTestTitles(repository, log);

            // define a few valid query types
            repository.ServiceQueryTypeSet("comp");
            repository.ServiceQueryTypeSet("lsp");
            repository.ServiceQueryTypeSet("title");
            repository.ServiceSubmit("TitleQueryConfigXmlTest");

            XmlDocument xmlDoc = new XmlDocument();

            // param validation
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlGet(null, ref xmlDoc, "comp");
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDoc, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlSet(null, xmlDoc, "comp");
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlSet(c_tid1, null, "comp");
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("xmlDocQueryConfig", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlSet(c_tid1, xmlDoc, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlDelete(null, "comp");
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlDelete(c_tid1, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sQueryTypeName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // try an invalid type

            // get doesn't care, it will return whatever is there...
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDoc, "invalid"));

            // set should throw if you specify an invalid type...
            bThrown = false;
            try
            {
                repository.TitleQueryConfigXmlSet(c_tid1, xmlDoc, "invalid");
            }
            catch (CRepositoryException e)
            {
                Assert.IsFalse(e.Message.IndexOf("Query type") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // delete also doesn't care, it will nuke whatever it finds
            repository.TitleQueryConfigXmlDelete(c_tid1, "invalid");

            // there is current no query config at all, so get for a valid type
            // should still return false.
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDoc, "comp"));

            // now test the upgrade... manually muck with the title xml file
            // to insert a legacy querysim node.
            // at this point, the title.xml has no query service node,
            // so we can just go ahead and create things from the root
            // on up
            XmlDocument xmlDocTitle = new XmlDocument();
            string sTitleXmlPathAndFileName 
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("config")
                + "title_"+c_tid1.sTitleIdHexNoPrefix+".xml";
            xmlDocTitle.Load(sTitleXmlPathAndFileName);
            XmlNode xmlNodeTitle = xmlDocTitle.SelectSingleNode("/Title");
            XmlElement xmlElemQueryService = xmlDocTitle.CreateElement("QueryService");
            xmlNodeTitle.AppendChild(xmlElemQueryService);

            // load up an xqs file and grab the querysim node
            XmlDocument xmlDocXqsComp = new XmlDocument();
            xmlDocXqsComp.Load(@".\xqs\ffff4006-comp.xqs");
            XmlNode xmlNodeQuerySim = xmlDocXqsComp.SelectSingleNode("/querysim");

            // create the querysim node in the title xml
            XmlDocumentFragment xmlDocFrag = xmlDocTitle.CreateDocumentFragment();
            xmlDocFrag.InnerXml = xmlNodeQuerySim.OuterXml;
            xmlElemQueryService.AppendChild(xmlDocFrag);

            // save the title xml back to the repository
            CSourceDepot sd = new CSourceDepot(null, null, log);
            sd.Edit(sTitleXmlPathAndFileName);
            xmlDocTitle.Save(sTitleXmlPathAndFileName);
            sd.Submit(sTitleXmlPathAndFileName, "TitleQueryConfigXmlTest");

            // now we're ready to run the upgrade test...
            // get for comp should get the stuff we set
            // but we have to make sure the repository flushes any cached title.xml first...
            repository.DiscardCachedFiles();
            XmlDocument xmlDocOut = null;
            Assert.IsTrue(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "comp"));
            Assert.AreEqual(xmlDocXqsComp.OuterXml, xmlDocOut.OuterXml);

            // get for anything else (valid) should return false
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "lsp"));
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "title"));

            // setting anything (in this case title) should trigger an upgrade of the
            // legacy comp stuff
            XmlDocument xmlDocXqsTitle = new XmlDocument();
            xmlDocXqsTitle.Load(@".\xqs\ffff4006-title.xqs");
            repository.TitleQueryConfigXmlSet(c_tid1, xmlDocXqsTitle, "title");
            repository.TitleSubmit(c_tid1, "TitleQueryConfigXmlTest");

            // confirm (manually) that the legacy querysim stuff has been moved
            xmlDocTitle.Load(sTitleXmlPathAndFileName);
            xmlNodeQuerySim = xmlDocTitle.SelectSingleNode("/Title/QueryService/querysim");
            Assert.IsTrue(xmlNodeQuerySim == null);
            xmlNodeQuerySim = xmlDocTitle.SelectSingleNode("/Title/QueryService/QueryType[@name=\"comp\"]/querysim");
            Assert.IsFalse(xmlNodeQuerySim == null);

            // get the comp stuff from it's new home
            Assert.IsTrue(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "comp"));
            Assert.AreEqual(xmlDocXqsComp.OuterXml, xmlDocOut.OuterXml);

            // get the title stuff from it's home
            Assert.IsTrue(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "title"));
            Assert.AreEqual(xmlDocXqsTitle.OuterXml, xmlDocOut.OuterXml);

            // delete the comp stuff, and confirm it's gone
            repository.TitleQueryConfigXmlDelete(c_tid1, "comp");
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "comp"));

            // a second delete should be a no-op, no throw
            repository.TitleQueryConfigXmlDelete(c_tid1, "comp");
            Assert.IsFalse(repository.TitleQueryConfigXmlGet(c_tid1, ref xmlDocOut, "comp"));

            // add back the comp stuff, and submit the title so we can have a look
            repository.TitleQueryConfigXmlSet(c_tid1, xmlDocXqsComp, "comp");
            repository.TitleSubmit(c_tid1, "TitleQueryConfigXmlTest");
        }

        [Test]
        public void AlternateTitleIdsTest()
        {
            uint [] aAlternateTitleIds = null;

            CLog log = new CLog();
            log.Level = CLog.FULLTRACE;

            CRepository repository = new CRepository(null, null, log);

            //bool bThrown;

            CreateTestTitles(repository, log);

            //  Initially there shouldn't be any alternate title ids in the file

            bool bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsFalse(bFound);
            Assert.IsNull(aAlternateTitleIds);

            //  Start adding alt titles
            //  Add first one
            repository.TitleAlternateTitleIdSet(c_tid1, c_tid2);
            repository.TitleSubmit(c_tid1, "Added one alternate title id.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsTrue(bFound);
            Assert.AreEqual(1, aAlternateTitleIds.Length);

            //  Add another one
            repository.TitleAlternateTitleIdSet(c_tid1, c_tid3);
            repository.TitleSubmit(c_tid1, "Added another alternate title id.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsTrue(bFound);
            Assert.AreEqual(2, aAlternateTitleIds.Length);

            //  Make sure we can't add the same one twice
            repository.TitleAlternateTitleIdSet(c_tid1, c_tid3);
            repository.TitleSubmit(c_tid1, "Added dup alternate title id.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsTrue(bFound);
            Assert.AreEqual(2, aAlternateTitleIds.Length);

            //  Add another one
            repository.TitleAlternateTitleIdSet(c_tid1, c_tid4);
            repository.TitleSubmit(c_tid1, "Added third alternate title id.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsTrue(bFound);
            Assert.AreEqual(3, aAlternateTitleIds.Length);

            //  Delete one
            repository.TitleAlternateTitleIdDelete(c_tid1, c_tid2);
            repository.TitleSubmit(c_tid1, "Deleted one alt id.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsTrue(bFound);
            Assert.AreEqual(2, aAlternateTitleIds.Length);

            //  Delete the rest
            repository.TitleAlternateTitleIdDeleteAll(c_tid1);
            repository.TitleSubmit(c_tid1, "Removed all alt ids.");
            repository.DiscardCachedFiles();

            bFound = repository.TitleAlternateTitleIdGetList(c_tid1, ref aAlternateTitleIds);
            Assert.IsFalse(bFound);
            Assert.IsNull(aAlternateTitleIds);
        }

        [Test]
        public void TitleDescGetListTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);

            bool bThrown;

            CreateTestTitles(repository, log);

            // param validation
            bThrown = false;
            try
            {
                repository.TitleDescGetListByLang(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleDescGetListByLocale(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            SortedList sl = repository.TitleDescGetListByLang(c_tid1);
            Assert.AreEqual(2, sl.Count);
            Assert.AreEqual("English Title Description", sl[ELanguageName.english]);
            Assert.AreEqual("French Title Description", sl[ELanguageName.french]);

            sl = repository.TitleDescGetListByLocale(c_tid1);
            Assert.AreEqual(10, sl.Count);
            Assert.AreEqual("English Title Description", sl["en-AU"]);
            Assert.AreEqual("English Title Description", sl["en-CA"]);
            Assert.AreEqual("English Title Description", sl["en-IE"]);
            Assert.AreEqual("English Title Description", sl["en-GB"]);
            Assert.AreEqual("English Title Description", sl["en-SG"]);
            Assert.AreEqual("English Title Description", sl["en-US"]);
            Assert.AreEqual("French Title Description", sl["fr-BE"]);
            Assert.AreEqual("French Title Description", sl["fr-CA"]);
            Assert.AreEqual("French Title Description", sl["fr-CH"]);
            Assert.AreEqual("French Title Description", sl["fr-FR"]);

        }

        [Test]
        public void TitleContainsStatsInfoTest()
        {
            CLog log = new CLog();
            //log.Level = CLog.FULLTRACE;
            //log.Level = CLog.CONSOLE;
            log.Level = CLog.DATAMOD2;

            CRepository repository1 = new CRepository(null, null, log);

            CreateTestTitles(repository1, log);

            bool bThrown;
            uint uiLBNum = 0;
            int iStatsDatabase = -1;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            // First all the param validation tests
            bThrown = false;
            try
            {
                repository1.TitleContainsStatsInfo(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // c_tid1 has no leaderboards defined anywhere, and should report
            // no stats information
            Assert.IsFalse(repository1.TitleContainsStatsInfo(c_tid1));

            // add a single leaderboard, and confirm that it now contains
            // stats info.
            uiLBNum = 1;
            iStatsDatabase = 0;
            riLBResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            uiMaxRatingCount = 100;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 50;
            uiExpirationSeconds = 900;
            bDontList = false;
            repository1.TitleLBSet(
                c_tid1,
                uiLBNum, 
                iStatsDatabase,
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            Assert.IsTrue(repository1.TitleContainsStatsInfo(c_tid1));

            // remove the individual leaderboard and confirm that it now
            // reports no stats info
            repository1.TitleLBDelete(c_tid1, uiLBNum);
            Assert.IsFalse(repository1.TitleContainsStatsInfo(c_tid1));

            // add a unit leaderboard and confirm that it now reports stats info
            uiLBNum = 4;
            bArbitrationRequired = false;
            bIsTeam = false;
            eloConfig = null;
            uiEntriesPerCacheLine = 50;
            uiExpirationSeconds = 900;
            bDontList = true;
            repository1.TitleUnitSet(
                c_tid1,
                uiLBNum, 
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            Assert.IsTrue(repository1.TitleContainsStatsInfo(c_tid1));

            // delete the unit leaderboard and confirm that it now reports no stats info
            repository1.TitleUnitDelete(c_tid1, uiLBNum);
            Assert.IsFalse(repository1.TitleContainsStatsInfo(c_tid1));

            // now add a competition template and confirm that it now reports stats info
            uiLBNum = 2;
            riLBResetInterval = ELBReset.ResetEveryWeek;
            uiAttachmentCount = 2;
            uiMaxAttachmentSize = 3;
            uiDecayDays = 4;
            bArbitrationRequired = true;
            bIsTeam = true;
            eloConfig = CELOConfig.Parse("ELO_E=E;ELO_K=2;ELO_NEW=1;ELO_C=0:20,30:40");
            uiEntriesPerCacheLine = 51;
            uiExpirationSeconds = 901;
            bDontList = true;
            repository1.TitleCompSet(
                c_tid1,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                bDontList);
            Assert.IsTrue(repository1.TitleContainsStatsInfo(c_tid1));

            // now remove the competition and confirm that it reports no stats info
            repository1.TitleCompDelete(c_tid1, uiLBNum);
            Assert.IsFalse(repository1.TitleContainsStatsInfo(c_tid1));

            // c_tid2 has a legacy stats.xml file that contains leaderboards, 
            // and should therefore report stats information
            Assert.IsTrue(repository1.TitleContainsStatsInfo(c_tid2));

            // c_tid3 has a legacy stats.ini that contains leaderboards, and
            // therefore should report stats informatin
            Assert.IsTrue(repository1.TitleContainsStatsInfo(c_tid3));

        }

        [Test]
        public void TitleArchiveFileTest()
        {
            // no parameter validation to test in the constructor, null is allowed
            // for all params
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);
            CSourceDepot sourceDepot = new CSourceDepot(null, null, log);

            bool bThrown;

            CreateTestTitles(repository, log);

            string sPathAndFileName = @".\archive\TestArchiveFile.txt";
            string sComment = "CRepository.TitleArchiveFileTest";

            // param validation
            bThrown = false;
            try
            {
                repository.TitleArchiveFile(null, sPathAndFileName, sComment);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleArchiveFile(c_tid1, null, sComment);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sPathAndFileName", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleArchiveFile(c_tid1, sPathAndFileName, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("sComment", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // try a non-existant source file
            bThrown = false;
            try
            {
                repository.TitleArchiveFile(c_tid1, "i_dont_exist.txt", sComment);
            }
            catch (ArgumentException e)
            {
                Assert.AreEqual("sPathAndFileName", e.ParamName);
                Assert.IsFalse(e.Message.IndexOf("i_dont_exist.txt does not exist") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // where do we expect the file to end up?
            string sDestinationPathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("submission")
                + Path.GetFileName(sPathAndFileName);

            // make sure there's nothing already there
            Assert.IsFalse(File.Exists(sDestinationPathAndFileName));

            // submit the archive file, and confirm it's been checked in
            // at the destination
            repository.TitleArchiveFile(c_tid1, sPathAndFileName, sComment);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            string [] rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // submit it again, and confirm it again - this time it will 
            // have used sd edit instead of sd add
            repository.TitleArchiveFile(c_tid1, sPathAndFileName, sComment);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // now to test the corner cases
            // file exists but is not in source depot - should overwrite
            // and check in
            sourceDepot.Delete(sDestinationPathAndFileName);
            sourceDepot.Submit(sDestinationPathAndFileName, sComment);
            if (!Directory.Exists(Path.GetDirectoryName(sDestinationPathAndFileName)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(sDestinationPathAndFileName));
            }
            File.Copy(sPathAndFileName, sDestinationPathAndFileName);
            repository.TitleArchiveFile(c_tid1, sPathAndFileName, sComment);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // file exists but is not in source depot, but IS read only
            // should clear the read only attribute, overwrite and
            // check in
            sourceDepot.Delete(sDestinationPathAndFileName);
            sourceDepot.Submit(sDestinationPathAndFileName, sComment);
            if (!Directory.Exists(Path.GetDirectoryName(sDestinationPathAndFileName)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(sDestinationPathAndFileName));
            }
            File.Copy(sPathAndFileName, sDestinationPathAndFileName);
            File.SetAttributes(sDestinationPathAndFileName, FileAttributes.ReadOnly);
            repository.TitleArchiveFile(c_tid1, sPathAndFileName, sComment);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

        }

        [Test]
        public void TitleGameConfigTest()
        {
            CLog log = new CLog();
            log.Level = CLog.DATAMOD2;

            CRepository repository = new CRepository(null, null, log);
            CSourceDepot sourceDepot = new CSourceDepot(null, null, log);

            bool bThrown;

            CreateTestTitles(repository, log);

            string gameConfigFile = @".\gameconfig\TestGameConfig.xml";
            string comment = "TitleGameConfigTest";

            // param validation
            bThrown = false;
            try
            {
                repository.TitleGameConfigSet(null, gameConfigFile);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleGameConfigSet(c_tid1, null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("gameConfigFile", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // try a non-existant source file
            bThrown = false;
            try
            {
                repository.TitleGameConfigSet(c_tid1, "i_dont_exist.txt");
            }
            catch (ArgumentException e)
            {
                Assert.AreEqual("gameConfigFile", e.ParamName);
                Assert.IsFalse(e.Message.IndexOf("i_dont_exist.txt does not exist") == -1);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            bThrown = false;
            try
            {
                repository.TitleGameConfigGet(null);
            }
            catch (ArgumentNullException e)
            {
                Assert.AreEqual("tid", e.ParamName);
                bThrown = true;
            }
            Assert.IsTrue(bThrown);

            // where do we expect the file to end up?
            string sDestinationPathAndFileName
                = CPathUtil.AddPathTerminator(repository.RepositoryRoot)
                + CPathUtil.AddPathTerminator(c_tid1.sTitleIdHexNoPrefix)
                + CPathUtil.AddPathTerminator("config")
                + "gameconfig_"+c_tid1.sTitleIdHexNoPrefix+".xml";

            // make sure there's nothing already there
            Assert.IsFalse(File.Exists(sDestinationPathAndFileName));

            // try to get a non existant game config - should return
            // null
            FileStream gameConfig = repository.TitleGameConfigGet(c_tid1);
            Assert.AreEqual(null, gameConfig);

            // submit the game config file, and confirm it's been checked in
            // at the destination
            repository.TitleGameConfigSet(c_tid1, gameConfigFile);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            string[] rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // submit it again, and confirm it again - this time it will 
            // have used sd edit instead of sd add
            repository.TitleGameConfigSet(c_tid1, gameConfigFile);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // now to test the corner cases
            // file exists but is not in source depot - should overwrite
            // and check in
            sourceDepot.Delete(sDestinationPathAndFileName);
            sourceDepot.Submit(sDestinationPathAndFileName, comment);
            if (!Directory.Exists(Path.GetDirectoryName(sDestinationPathAndFileName)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(sDestinationPathAndFileName));
            }
            File.Copy(gameConfigFile, sDestinationPathAndFileName);
            repository.TitleGameConfigSet(c_tid1, gameConfigFile);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // file exists but is not in source depot, but IS read only
            // should clear the read only attribute, overwrite and
            // check in
            sourceDepot.Delete(sDestinationPathAndFileName);
            sourceDepot.Submit(sDestinationPathAndFileName, comment);
            if (!Directory.Exists(Path.GetDirectoryName(sDestinationPathAndFileName)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(sDestinationPathAndFileName));
            }
            File.Copy(gameConfigFile, sDestinationPathAndFileName);
            File.SetAttributes(sDestinationPathAndFileName, FileAttributes.ReadOnly);
            repository.TitleGameConfigSet(c_tid1, gameConfigFile);
            Assert.IsTrue(File.Exists(sDestinationPathAndFileName));
            rgsFiles = sourceDepot.Files(sDestinationPathAndFileName, true);
            Assert.AreEqual(1, rgsFiles.Length);

            // get the file stream from the repository
            gameConfig = repository.TitleGameConfigGet(c_tid1);
            Assert.IsTrue(gameConfig != null);

            // make sure it matches the file we gave it
            FileStream gameConfig2 = new FileStream(gameConfigFile, FileMode.Open, FileAccess.Read, FileShare.Read);
            StreamReader gameConfig2Reader = new StreamReader(gameConfig2);
            string gameConfig2Contents = gameConfig2Reader.ReadToEnd();
            StreamReader gameConfigReader = new StreamReader(gameConfig);
            string gameConfigContents = gameConfigReader.ReadToEnd();
            Assert.AreEqual(gameConfig2Contents, gameConfigContents);
            gameConfigReader.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\v3xsd\StatsV3xmlTest.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using NUnit.Framework;
using xonline.tools.framework;
using xonline.tools.framework.test.v3xsd;

namespace xonline.tools.framework.test.v3xsd 
{
    [TestFixture]
    public class CStatsV3XmlTest
    {
        [Test]
        public void CStatsV3RoundTrip()
        {
            // this is a cheezy test, since it doesn't really test that I got the xml schema right. However, it does
            // at least confirm that the code generated by xsd can be used to read and write xml data.

            CTitle title = new CTitle();
            title.TitleID = "abcdef01";
            title.Version = "00000100";
            title.UnitLeaderboardDecayConstant = "5";
            title.Default_Locale = "en-US";

            title.LeaderboardContainer = new CLeaderboardContainer[4];
            title.LeaderboardContainer[0] = new CLeaderboardContainer();
            title.LeaderboardContainer[0].type = LeaderboardTypeType.individual;
            title.LeaderboardContainer[1] = new CLeaderboardContainer();
            title.LeaderboardContainer[1].type = LeaderboardTypeType.units;
            title.LeaderboardContainer[2] = new CLeaderboardContainer();
            title.LeaderboardContainer[2].type = LeaderboardTypeType.teams;
            title.LeaderboardContainer[3] = new CLeaderboardContainer();
            title.LeaderboardContainer[3].type = LeaderboardTypeType.competitions;

            title.LeaderboardContainer[0].Leaderboard = new CLeaderboard[2];
            title.LeaderboardContainer[1].Leaderboard = new CLeaderboard[1];
            title.LeaderboardContainer[2].Leaderboard = new CLeaderboard[0];

            title.LeaderboardContainer[0].Leaderboard[0] = new CLeaderboard();
            title.LeaderboardContainer[0].Leaderboard[0].ID= "1";
            title.LeaderboardContainer[0].Leaderboard[0].Reset = "0";
            title.LeaderboardContainer[0].Leaderboard[0].DecayDays= "1";
            title.LeaderboardContainer[0].Leaderboard[0].TopOneHundred = false;
            title.LeaderboardContainer[0].Leaderboard[0].Arbitrate = false;
            title.LeaderboardContainer[0].Leaderboard[0].ELO = new CELO();
            title.LeaderboardContainer[0].Leaderboard[0].ELO.InitialPlayerRating = "1";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.RatingScaleFactor = "1";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.ExponentialBase = ELOExponentialBaseType.E;
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray = new CMaxWeightRatingRange[1];
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0] = new CMaxWeightRatingRange();
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0].maxweight = "10";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0].start = "1";
            title.LeaderboardContainer[0].Leaderboard[0].Names = new CLocalizedName[1];
            title.LeaderboardContainer[0].Leaderboard[0].Names[0] = new CLocalizedName();
            title.LeaderboardContainer[0].Leaderboard[0].Names[0].Locale = "en-US";
            title.LeaderboardContainer[0].Leaderboard[0].Names[0].Name = "en-US name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues = new CFormattedValue[1];
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0] = new CFormattedValue();
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names = new CLocalizedName[1];
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0] = new CLocalizedName();
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0].Locale = "en-US";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0].Name = "en-US name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].NameID = "1";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Type = FormattedValueReturnType.Integer;
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].FriendlyAdminName = "name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Formula = "formula";
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes = new CAttribute[1];
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0] = new CAttribute();
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0].Index = "1";
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0].PUID = false;

            title.LeaderboardContainer[0].Leaderboard[1] = new CLeaderboard();
            title.LeaderboardContainer[0].Leaderboard[1].ID= "2";

            string sFilename = "StatsV3XmlTestRoundTrip.xml";
            FileStream fs = new FileStream(sFilename, FileMode.Create);
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(CTitle));
            xmlSerializer.Serialize(fs, title);
            fs.Close();

            fs = new FileStream(sFilename, FileMode.Open);
            CTitle title2 = (CTitle)xmlSerializer.Deserialize(fs);
            fs.Close();
            
            Assert.AreEqual(title.TitleID, title2.TitleID);
            Assert.AreEqual(title.Version, title2.Version);
            Assert.AreEqual(title.UnitLeaderboardDecayConstant, title2.UnitLeaderboardDecayConstant);
            Assert.AreEqual(title.Default_Locale, title2.Default_Locale);
            for (int i1 = 0; i1 < title.LeaderboardContainer.Length; ++i1)
            {
                if (title.LeaderboardContainer[i1] == null) continue;
                
                Assert.AreEqual(title.LeaderboardContainer[i1].type, title2.LeaderboardContainer[i1].type);
                if (title.LeaderboardContainer[i1].Leaderboard == null) continue;
                
                for (int i2 = 0; i2 < title.LeaderboardContainer[i1].Leaderboard.Length; ++i2)
                {
                    if (title.LeaderboardContainer[i1].Leaderboard[i2] == null) continue;

                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ID, title2.LeaderboardContainer[i1].Leaderboard[i2].ID);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Reset, title2.LeaderboardContainer[i1].Leaderboard[i2].Reset);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].DecayDays, title2.LeaderboardContainer[i1].Leaderboard[i2].DecayDays);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].TopOneHundred, title2.LeaderboardContainer[i1].Leaderboard[i2].TopOneHundred);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Arbitrate, title2.LeaderboardContainer[i1].Leaderboard[i2].Arbitrate);
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].ELO != null)
                    {
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.InitialPlayerRating, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.InitialPlayerRating);
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.RatingScaleFactor, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.RatingScaleFactor);
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.ExponentialBase, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.ExponentialBase);
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].maxweight, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].maxweight);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].start, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].start);
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].Names != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].Names.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Locale, title2.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Locale);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Name, title2.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Name);
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].NameID, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].NameID);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Type, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Type);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].FriendlyAdminName, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].FriendlyAdminName);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Formula, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Formula);
                            if (title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names != null)
                            {
                                for (int i4 = 0; i4 < title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names.Length; ++i4)
                                {
                                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Locale, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Locale);
                                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Name, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Name);
                                }
                            }
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].Index, title2.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].Index);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].PUID, title2.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].PUID);
                        }
                    }
                }
            }

        }
        public void CStatsV3Deserialize()
        {
            // use text writer to generate an XML file that tests the boundary conditions of the schema.
            // don't want to use the CTitle class generated by xsd, because that doesn't independantly
            // implement the schema. What we're really trying to unit test here is the xsd, not the C#
            // class that was generated by xsd.exe
            
            string sFilename = "StatsV3BoundaryConditions.xml";
            FileStream fs = new FileStream(sFilename, FileMode.Create);
            XmlTextWriter xmlTextWriter = new XmlTextWriter(fs, null);
            xmlTextWriter.Formatting = Formatting.Indented;

            /*
            Console.WriteLine("CStatsV3Deserialize::Creating XmlSerializer(typeof(CTitle))");
            XmlSerializer xmlsTitle = new XmlSerializer(typeof(CTitle));
            string sPath = ".\\ValidStatsV3.xsc";
            Console.WriteLine("CStatsV3Deserialize::Opening xml file '" + sPath + "' which should parse correctly");
            FileStream fs = new FileStream(".\\ValidStatsV3.xsc", FileMode.Open);
            Console.WriteLine("CStatsV3Deserialize::Deserializing file");
            CTitle title = (CTitle)xmlsTitle.Deserialize(fs);
            Console.WriteLine("CStatsV3Deserialize::Deserializing complete! Checking created object");

            Assert.AreEqual("3.0", title.Version);
            Assert.AreEqual("baadf00d", title.TitleID);
            Assert.AreEqual("en-US", title.Default_Locale);

            Assert.AreEqual(LeaderboardTypeType.individual , title.LeaderboardContainer[0].type);
            */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FWVer\FWVer.cs ===
using System;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;

namespace xonline.tools.fwver
{
    /// <summary>
    /// Provides a command line interface to the core SqlRunner functionality.
    /// </summary>
    class FrameWorkVersion
    {

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        static int Main(string[] args)
        {
            FrameWorkVersion theCmd = new FrameWorkVersion();
            theCmd.ParseCommandLine(args);
            return theCmd.RunIt();
        }

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)", 
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("FWVer");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Checks the FW Ver of all binaries in the drop directory.");
            Console.WriteLine();
 
        }

        /// <summary>
        /// Creates a SqlRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            try
            {
                DirectoryInfo dirInfo = new DirectoryInfo( Directory.GetCurrentDirectory() );
                // Check binaries in current directory
                CheckDirectory( dirInfo );
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing FWVer. - " + ex.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        private void CheckDirectory(DirectoryInfo dirInfo)
        {
            // exe's
            FileInfo[] fileInfoExe = dirInfo.GetFiles( "*.exe" );
            foreach( FileInfo exe in fileInfoExe)
            {
                CheckFrameworkVersion( exe );
            }
            FileInfo[] fileInfoDll = dirInfo.GetFiles( "*.dll" );
            foreach( FileInfo dll in fileInfoDll)
            {
                CheckFrameworkVersion( dll );
            }
            // Sub directories
            DirectoryInfo[] subdirsInfo = dirInfo.GetDirectories();
            foreach ( DirectoryInfo subdirInfo in subdirsInfo )
            {
                CheckDirectory( subdirInfo );
            }
        }

        private void CheckFrameworkVersion( FileInfo file )
        {
            string filename = file.DirectoryName + "\\" + file.Name;
            try
            {
                Assembly asm = Assembly.ReflectionOnlyLoadFrom( filename );
                Console.WriteLine( asm.ImageRuntimeVersion + "\t" + filename );
            }
            catch (FileLoadException )
            {
                Console.WriteLine( "duplicate binary\t" + filename );
            }
            catch (BadImageFormatException )
            {
                Console.WriteLine( "unmanaged binary\t" + filename );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\db.cpp ===
#include "db.h"
#include "env.h"
#include "dbdebug.h"


CDBConnection::CDBConnection(SQLHANDLE hEnv, CHAR *szConnectionString, DWORD dwSize) : m_hDB(0)
{
    SQLRETURN rt;
    SQLSMALLINT siSize = (dwSize) ? (SQLSMALLINT) strlen(szConnectionString) : (SQLSMALLINT) dwSize;
    rt = SQLAllocHandle(SQL_HANDLE_DBC, hEnv, &m_hDB);
    CHECK_RETVAL(rt, hEnv, SQL_HANDLE_ENV, Error);

    // Connect to the database
    rt = SQLDriverConnectA(m_hDB, 0, (SQLCHAR *) szConnectionString, SQL_NTS, 
                            (SQLCHAR *) szConnectionString, siSize, NULL, SQL_DRIVER_NOPROMPT);
    if(SQL_SUCCESS_WITH_INFO == rt)
    {
        DebugOutput("DB: AllocHandle for 0x%08x for %s", m_hDB, szConnectionString);
        return;
    }
    CHECK_RETVAL(rt, m_hDB, SQL_HANDLE_DBC, Error);
    DebugOutput("DB: AllocHandle for 0x%08x for %s", m_hDB, szConnectionString);

    return;
Error:
    if(m_hDB)
    {
        rt = SQLFreeHandle(SQL_HANDLE_DBC, m_hDB);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_DBC, m_hDB, rt);
        }
    }
    m_hDB = 0;
}

CDBConnection::CDBConnection(SQLHANDLE hEnv, WCHAR *szConnectionString, DWORD dwSize) : m_hDB(0)
{
    SQLRETURN rt;
    SQLSMALLINT siSize = (dwSize) ? (SQLSMALLINT) wcslen(szConnectionString) : (SQLSMALLINT) dwSize;
    rt = SQLAllocHandle(SQL_HANDLE_DBC, hEnv, &m_hDB);
    CHECK_RETVAL(rt, hEnv, SQL_HANDLE_ENV, Error);

    // Connect to the database
    rt = SQLDriverConnectW(m_hDB, 0, (SQLWCHAR *) szConnectionString, SQL_NTS, 
                            (SQLWCHAR *) szConnectionString, siSize, NULL, SQL_DRIVER_NOPROMPT);
    if(SQL_SUCCESS_WITH_INFO == rt)
    {
        DebugOutput("DB: AllocHandle for 0x%08x for %s", m_hDB, szConnectionString);
        return;
    }
    CHECK_RETVAL(rt, m_hDB, SQL_HANDLE_DBC, Error);

    DebugOutput("DB: AllocHandle for 0x%08x for %S", m_hDB, szConnectionString);

    return;
Error:
    if(m_hDB)
    {
        rt = SQLFreeHandle(SQL_HANDLE_DBC, m_hDB);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_DBC, m_hDB, rt);
        }
    }
    m_hDB = 0;
}

CDBConnection::~CDBConnection()
{
    SQLRETURN rt;
    if(m_hDB)
    {
        SQLDisconnect(m_hDB);
        if(m_hDB)
        {
            rt = SQLFreeHandle(SQL_HANDLE_DBC, m_hDB);
            if(SQL_SUCCESS != rt)
            {
                DisplayError(SQL_HANDLE_DBC, m_hDB, rt);
            }
        }
        DebugOutput("DB: FreeHandle for 0x%08x", m_hDB);
    }
    m_hDB = 0;
}


BOOL CDBConnection::DBError()
{
    return m_hDB == SQL_NULL_HANDLE;
}


CDBStatement* CDBConnection::Prepare(CHAR *szQuery)
{
    CDBStatement *pStmt = new CDBStatement(m_hDB, szQuery);
    if(!pStmt)
        return 0;
    
    if(!*pStmt)
    {
        delete pStmt;
        pStmt = 0;
    }
    return pStmt;
}

CDBStatement* CDBConnection::Prepare(WCHAR *szQuery)
{
    CDBStatement *pStmt = new CDBStatement(m_hDB, szQuery);
    if(!pStmt)
        return 0;
    
    if(!*pStmt)
    {
        delete pStmt;
        pStmt = 0;
    }
    return pStmt;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\test\v3xsd\StatsV3xml.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.framework.test.v3xsd  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute("Title", Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class CTitle {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LeaderboardContainer")]
        public CLeaderboardContainer[] LeaderboardContainer;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string TitleID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string UnitLeaderboardDecayConstant;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Version;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="language")]
        public string Default_Locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLeaderboardContainer {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Leaderboard")]
        public CLeaderboard[] Leaderboard;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public LeaderboardTypeType type;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLeaderboard {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string Reset;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string DecayDays;
        
        /// <remarks/>
        public bool TopOneHundred;
        
        /// <remarks/>
        public bool Arbitrate;
        
        /// <remarks/>
        public CELO ELO;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public CLocalizedName[] Names;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("FormattedValue", IsNullable=false)]
        public CFormattedValue[] FormattedValues;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Attribute", IsNullable=false)]
        public CAttribute[] RawAttributes;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="integer")]
        public string ID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CELO {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string InitialPlayerRating;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string RatingScaleFactor;
        
        /// <remarks/>
        public ELOExponentialBaseType ExponentialBase;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("MaxWeightRatingRange", IsNullable=false)]
        public CMaxWeightRatingRange[] MaxWeightRatingRangeArray;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum ELOExponentialBaseType {
        
        /// <remarks/>
        E,
        
        /// <remarks/>
        e,
        
        /// <remarks/>
        [System.Xml.Serialization.XmlEnumAttribute("10")]
        Item10,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CMaxWeightRatingRange {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string start;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string maxweight;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CAttribute {
        
        /// <remarks/>
        public bool PUID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string Index;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CFormattedValue {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public CLocalizedName[] Names;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="positiveInteger")]
        public string NameID;
        
        /// <remarks/>
        public FormattedValueReturnType Type;
        
        /// <remarks/>
        public string FriendlyAdminName;
        
        /// <remarks/>
        public string Formula;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLocalizedName {
        
        /// <remarks/>
        public string Name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="language")]
        public string Locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum FormattedValueReturnType {
        
        /// <remarks/>
        Integer,
        
        /// <remarks/>
        Float,
        
        /// <remarks/>
        Percent,
        
        /// <remarks/>
        Gamertag,
        
        /// <remarks/>
        Timestamp,
        
        /// <remarks/>
        Milliseconds,
        
        /// <remarks/>
        TenMilliseconds,
        
        /// <remarks/>
        HundredMilliseconds,
        
        /// <remarks/>
        Seconds,
        
        /// <remarks/>
        Minutes,
        
        /// <remarks/>
        Hours,
        
        /// <remarks/>
        Days,
        
        /// <remarks/>
        String,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum LeaderboardTypeType {
        
        /// <remarks/>
        individual,
        
        /// <remarks/>
        units,
        
        /// <remarks/>
        teams,
        
        /// <remarks/>
        competitions,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\GenDashPrices1\Langauges.cs ===
/*
 * Langauges.cs
 *
 * Supports language code and culture/locale conversions, etc.
 * 
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Author: Ben Zotto (benzotto)
 */

using System;
using System.Diagnostics;

namespace xonline.tools.gendashprices1 
{
    public enum DashLanguages
    {
        ENGLISH = 1,
        JAPANESE,
        GERMAN,
        FRENCH,
        SPANISH,
        ITALIAN        
    }

    class Languages
    {
        
        /// <summary>
        /// Given a dash lanaguage setting, retrieves a default culture for that langauge.
        /// </summary>
        /// <param name="lang"></param>
        /// <returns></returns>
        public static string GetLanguageDefaultCulture(DashLanguages lang) 
        {
            string defaultCulture;

            switch(lang) 
            {
                case DashLanguages.ENGLISH:
                    defaultCulture = "en-US";
                    break;

                case DashLanguages.JAPANESE:
                    defaultCulture = "ja-JP";
                    break;

                case DashLanguages.GERMAN:
                    defaultCulture = "de-DE";
                    break;

                case DashLanguages.FRENCH:
                    defaultCulture = "fr-FR";
                    break;

                case DashLanguages.SPANISH:
                    defaultCulture = "es-ES";
                    break;

                case DashLanguages.ITALIAN:
                    defaultCulture = "it-IT";
                    break;

                default:
                    throw new Exception( "Unsupported Dash lanagauge setting: " + (int)lang );                        
            }

            return defaultCulture;
        }

        /// <summary>
        /// Given a Dash language value, returns the two-letter neutral language code (ie, "en")
        /// </summary>
        /// <param name="lang"></param>
        /// <returns></returns>
        public static string GetLanguageCode(DashLanguages lang) 
        {
            string languageCode;

            switch(lang) 
            {
                case DashLanguages.ENGLISH:
                    languageCode = "en";
                    break;

                case DashLanguages.JAPANESE:
                    languageCode = "ja";                    
                    break;

                case DashLanguages.GERMAN:
                    languageCode = "de";                    
                    break;

                case DashLanguages.FRENCH:
                    languageCode = "fr";                    
                    break;

                case DashLanguages.SPANISH:
                    languageCode = "es";                    
                    break;

                case DashLanguages.ITALIAN:
                    languageCode = "it";
                    break;

                default:
                    throw new Exception("Unsupported Dash lanagauge setting: " + (int)lang );                            
            }

            return languageCode;
        }

        public static string BuildLocale(DashLanguages lang, string countryCode)
        {
            Trace.Assert(countryCode != null);
            Trace.Assert(countryCode.Length == 2);

            return( GetLanguageCode(lang) + "-" + countryCode );
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\GenDashPrices1\GenDashPrices.cs ===
/*
 * GenDashPrices.cs
 *
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 * Author: Ben Zotto (benzotto), 3/15/02
 *
 * This utility generates an enumeration blob of price structures for the XDash to use
 * at account signup (bootstrapping) time.  Input is a .ini like file:
 * 
 * Each [section] is titled after a language ID from the Dash. e.g. [1]
 * Each row thereafter contains four fields, whitespace separated:
 *
 * countryID	ISOcurrencyCode	 wholePrice	    fractionalPrice
 * 
 * Comments beginning with (;) and blank lines are ignored. 
 */

using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Diagnostics;
using System.Globalization;

namespace xonline.tools.gendashprices1 
{

    class GenDashPrices
    {

        class Price 
        {
            public byte format;
            public byte country;
            public int whole;
            public int fraction;
            public string isoCode;
        }


        // the bits of the lower nibble for the format byte
        const int SEP_IS_COMMA = 0x1;
        const int DECIMAL_PART = 0x2;
        const int IS_PAD_SPACE = 0x4;
        const int MARKER_PRECEDES = 0x8;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        public static void Main(string[] args)
        {         
            StreamReader input;
            StreamWriter output;
            string inLine;
            int currentLangNum = -1;
            string[] currentDataSet = new String[4];
            Price curPrice;
            ArrayList priceStructs = new ArrayList();
            int n;

            if(args.Length != 2) 
            {
                Console.WriteLine("usage: GenDashPrices <input script> <output file>");
                return;
            }
            
            try 
            {
                input = File.OpenText(args[0]);
                output = new StreamWriter(args[1], false);
            } 
            catch (Exception e) 
            {
                Console.WriteLine("GenDashPrices: " + e.Message);
                return;
            }


            
            while(true) 
            {
                
                inLine = input.ReadLine();                           

                // is this the start of a new section?
                if(inLine == null || inLine.StartsWith("[")) 
                {                                  
                    // write out the old section
                    if(currentLangNum != -1)
                    {
                        output.WriteLine(" ");      // blank line
                        output.WriteLine("[" + currentLangNum + "]");
                        output.WriteLine(DumpBlob(priceStructs));     
                        priceStructs.Clear();
                    }
                    if(inLine == null) break;

                    // figure out the new section
                    n = inLine.IndexOf(']');
                    if (n <= 1)
                    {
                        Console.WriteLine("GenDashPrices: Error in file: couldn't parse '" + inLine + "'");
                        return;
                    }
                    
                    currentLangNum = Int32.Parse(inLine.Substring(1, n-1));                                                        
                    continue;
                }

                // skip comments, blank lines
                if(inLine.StartsWith(";") || inLine == "" ) 
                {
                    continue;
                }

                try 
                {
                    // ok, this is real data. parse it and format it.
                    currentDataSet = inLine.Split(new char[] {' ', ',', '\t'}, 4);
                    curPrice = new Price();
                    curPrice.country = (byte)Int32.Parse(currentDataSet[0]);
                    curPrice.isoCode = currentDataSet[1];
                    curPrice.whole = Int32.Parse(currentDataSet[2]);
                    curPrice.fraction = Int32.Parse(currentDataSet[2]);
                    curPrice.format = BuildCurrencyFormat(curPrice.isoCode, currentLangNum, curPrice.country);
                
                    priceStructs.Add(curPrice);
                } 
                catch (Exception e) 
                {
                    Console.WriteLine("GenDashPrices: " + e.Message);
                    return;
                }
            }
       
            
            // we're done with the file, close up.
            output.Close();
            input.Close();

            Console.WriteLine("GenDashPrices: success.");
        }
               
        private static string DumpBlob(ArrayList al)
        {
            StringBuilder sb = new StringBuilder();

            // start off by indicating this is binary, for SQL.
            sb.Append("0x");
                
            //
            // All the substrings are required to get the
            // data in little-endian order.
            //
          
            // dump the number of records we're expecting
            sb.Append(al.Count.ToString("X8").Substring(6,2));
            sb.Append(al.Count.ToString("X8").Substring(4,2));
            sb.Append(al.Count.ToString("X8").Substring(2,2));
            sb.Append(al.Count.ToString("X8").Substring(0,2));

            // dump the price data
            foreach(Price p in al) 
            {
                // dump the country byte
                sb.Append(p.country.ToString("X2"));
                sb.Append("000000");                        // padding to DWORD
                
                // whole part
                sb.Append(p.whole.ToString("X8").Substring(6,2));
                sb.Append(p.whole.ToString("X8").Substring(4,2));
                sb.Append(p.whole.ToString("X8").Substring(2,2));
                sb.Append(p.whole.ToString("X8").Substring(0,2));

                // fractional part
                sb.Append(p.fraction.ToString("X8").Substring(6,2));
                sb.Append(p.fraction.ToString("X8").Substring(4,2));
                sb.Append(p.fraction.ToString("X8").Substring(2,2));
                sb.Append(p.fraction.ToString("X8").Substring(0,2));
                
                // format byte
                sb.Append(p.format.ToString("X2"));
                sb.Append("00");         // padding to DWORD

                // unicode iso char array
                char[] code = p.isoCode.ToCharArray(0, 3);                
                sb.Append(Convert.ToUInt32(code[0]).ToString("X2"));
                sb.Append("00");         // high byte of unicode char, comes second.
                sb.Append(Convert.ToUInt32(code[1]).ToString("X2"));
                sb.Append("00");        
                sb.Append(Convert.ToUInt32(code[2]).ToString("X2"));
                sb.Append("00");         

                // no end padding
            }

            return sb.ToString();
        }


        //-----------------------------------------------------
        // BuildCurrencyFormat
        //
        //     Logic to determine the correct currency format for this user.
        //
        private static byte BuildCurrencyFormat(string isoCurrencyCode, int languageId, int countryNum) 
        {   
            int formatByteHigh;
            int formatByteLow;
            string defaultCulture;
            string countryCode;
            string cultureCode;
            int decimalDigits;
            CultureInfo userCulture;

            byte formatByte;
        
            switch(countryNum) 
            {
                case 103:
                    countryCode = "US";
                    break;
                case 16:
                    countryCode = "CA";
                    break;
                case 24:
                    countryCode = "DE";
                    break;
                case 34:
                    countryCode = "FR";
                    break;
                case 35:
                    countryCode = "GB";
                    break;
                case 53:
                    countryCode = "JP";
                    break;
                default:
                    throw new Exception("Unknown country number " + countryNum + ". Please update GenDashPrices.cs");
            }



            // assert that the currency we're getting is the one we should expect for this user.
            // we don't *really* support the whole spectrum of COUNTRYxLANGUAGExCURRENCY formats...
            // we lock COUNTRY to CURRENCY and assume there is a many:1 mapping there.            
            Trace.Assert(isoCurrencyCode == (new RegionInfo(countryCode)).ISOCurrencySymbol);

            // we'll start off by determining the currency we're using and sending back.
            // this is a function of the country code.
            switch(isoCurrencyCode) 
            {
                case "USD":
                    if(countryCode == "US") 
                    {
                        formatByteHigh = 0xD;           // this means: "$"
                    } 
                    else 
                    {
                        formatByteHigh = 0xB;           // this means: "US$"
                    } 
                    break;
                case "AUD":
                    formatByteHigh = 0x0;
                    break;
                case "CAD":
                    formatByteHigh = 0x1;
                    break;
                case "CHF":
                    formatByteHigh = 0x2;
                    break;
                case "DKK":
                    formatByteHigh = 0x3;
                    break;
                case "EUR":
                    formatByteHigh = 0x4;
                    break;
                case "GBP":
                    formatByteHigh = 0x5;
                    break;
                case "JPY":
                    formatByteHigh = 0x6;
                    break;
                case "KRW":
                    formatByteHigh = 0x7;
                    break;
                case "NOK":
                    formatByteHigh = 0x8;
                    break;
                case "NZD":
                    formatByteHigh = 0x9;
                    break;
                case "SEK":
                    formatByteHigh = 0xA;
                    break;
                case "ZAR":
                    formatByteHigh = 0xC;
                    break;
                default:
                    formatByteHigh = 0xE;       // unknown currency!!
                    break;
            }


            // now that the upper byte of the format is done, figure out the languageXcountry mapping
            // for the lower byte data.
            //
            formatByteLow = 0x0;
 
            // attempt to create a culture code from what we know.
            cultureCode = Languages.GetLanguageCode((DashLanguages)languageId) + "-" + countryCode;
            try 
            {
                userCulture = new CultureInfo(cultureCode, false);                
            } 
            catch (ArgumentException)
            {
                defaultCulture = Languages.GetLanguageDefaultCulture((DashLanguages)languageId);
                // this combination isn't valid.               
                Trace.Write("Culture " + cultureCode + " invalid, using default culture " + defaultCulture);                   
                userCulture = new CultureInfo(defaultCulture, false);            
            }
           
            // figure out decimal places -- nontrivial since this value is stored in the 
            // cultureinfo, not the regioninfo.
            //
            decimalDigits = GetNumberDecimalDigits(countryCode);
            if(decimalDigits == 2) 
            {
                formatByteLow |= DECIMAL_PART;
            } 
            else if(decimalDigits > 0) 
            {
                // warning...
                throw new Exception("Currency format for " + countryCode + " requires nonstandard decimal places!");
                // ...but leave the digits as none.
            }

            // figure out currency decimal separator
            if( (formatByteLow & DECIMAL_PART) != 0 ) 
            {
                // either a comma, or not (thus always ".")
                if(userCulture.NumberFormat.CurrencyDecimalSeparator == ",") 
                {
                    formatByteLow |= SEP_IS_COMMA;
                }
            } 
            else 
            {
                // overload the decimal separator bit with thousands-sep info.
                if(userCulture.NumberFormat.CurrencyGroupSeparator == ",") 
                {            
                    formatByteLow |= SEP_IS_COMMA;
                }
            }

            // figure out the position and spacing of currency character
            switch(userCulture.NumberFormat.CurrencyPositivePattern) 
            {
                case 0:         // $n
                    formatByteLow |= MARKER_PRECEDES;
                    break;
                case 1:         // n$
                    // a no-op
                    break;
                case 2:         // $ n
                    formatByteLow |= (MARKER_PRECEDES | IS_PAD_SPACE);
                    break;
                case 3:         // n $
                    formatByteLow |= IS_PAD_SPACE;
                    break;
                default:
                    throw new Exception("Unrecognized currency symbol placement recommended by .net!");
            }

            // now handle the one special case-- where it's unrecognized by the client, so the client
            // will use the ISO code and we'll need to enforce a space so we don't get FOO12.99
            if(formatByteHigh == 0xE) 
            {
                formatByteLow |= IS_PAD_SPACE;
            }

            // build byte from parts
            formatByte = (byte)formatByteLow;
            formatByte |= (byte)(formatByteHigh << 4);

            return formatByte;             
        }

        private static int GetNumberDecimalDigits(string countryCode)
        {
            string culture;
            CultureInfo ci;

            switch(countryCode) 
            {
                case "US":
                    culture = "en-US";
                    break;
                case "CA":
                    culture = "en-CA";
                    break;
                case "JP":
                    culture = "ja-JP";
                    break;
                case "GB":
                    culture = "en-GB";
                    break;
                case "FR":
                    culture = "fr-FR";
                    break;
                case "DE":
                    culture = "de-DE";
                    break;
                default:
                    throw new Exception("I don't recognize country code " + countryCode + " as being "
                        + "supported by Xbox Online. ");                    
            }
                   
            ci = new CultureInfo(culture);
            return ci.NumberFormat.CurrencyDecimalDigits;
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\db.h ===
#pragma once

#include <windows.h>
#include <sql.h>
#include <sqlext.h>
#include "stmt.h"

class CDBConnection : CDBBase
{
public:
    CDBConnection(SQLHANDLE hEnv, CHAR *szConnectionString, DWORD dwSize = 0);
    CDBConnection(SQLHANDLE hEnv, WCHAR *szConnectionString, DWORD dwSize = 0);
    ~CDBConnection();

    inline operator BOOL() {return m_hDB != SQL_NULL_HANDLE;}

    CDBStatement* Prepare(CHAR *szQuery);
    CDBStatement* Prepare(WCHAR *szQuery);

    BOOL DBError();

protected:
    SQLHANDLE m_hDB;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\dbdebug.h ===
#pragma once

#include <windows.h>
#include <sql.h>
#include <sqlext.h>

extern bool g_fDBAccessorDebugFlag;

#define CHECK_RETVAL(ret, handle, handletype, label)                                    \
    if(SQL_SUCCESS != ret && SQL_SUCCESS_WITH_INFO != ret)                              \
    {                                                                                   \
        DisplayError(handletype, handle, ret);                                          \
        goto label;                                                                     \
    }                                                                                   \
    if(SQL_SUCCESS_WITH_INFO == ret)                                                    \
    {                                                                                   \
        DisplayError(handletype, handle, ret);                                          \
    }


void DisplayError(SQLSMALLINT, SQLHANDLE, SQLRETURN);

void DebugOutput(char *szFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\dbdebug.cpp ===
#include "dbdebug.h"
#include <stdio.h>
#include "dbaccessor.h"
#include <assert.h>

static DWORD g_dwDBAccessorDebugFlags = 0;
static CHAR g_szHost[256] = "";

#ifndef CALL_TYPE
#define CALL_TYPE __stdcall
#endif // CALL_TYPE

VOID CALL_TYPE SetErrorReporting(DWORD dwReports, CHAR *szHost)
{
    g_dwDBAccessorDebugFlags = dwReports;
    if(DB_REPORT_EVENT & dwReports)
    {
        if(szHost)
            strcpy(g_szHost, szHost);
        else
            throw "To report to the event log, the host parameter must be set.";
    }
}

static void DoDebug(WORD dwType, const CHAR *szMsg)
{
    if(EVENTLOG_INFORMATION_TYPE == dwType && !(g_dwDBAccessorDebugFlags & DB_REPORT_INFORMATIONAL))
    {
        return;
    }
    if(g_dwDBAccessorDebugFlags & DB_REPORT_DEBUGSTRING)
    {
        OutputDebugStringA(szMsg);
    }
    if(g_dwDBAccessorDebugFlags & DB_REPORT_EVENT)
    {
        HANDLE  hEventSource;
        LPCSTR  lpszStrings[1];

        lpszStrings[0] = szMsg;

        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSourceA(NULL, g_szHost);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEventA(hEventSource, dwType, 0, 0, NULL, 1, 0, &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    if(g_dwDBAccessorDebugFlags & DB_REPORT_STDERR)
    {
        fputs(szMsg, stderr);
    }
    if(g_dwDBAccessorDebugFlags & DB_REPORT_ASSERT && EVENTLOG_INFORMATION_TYPE != dwType)
    {
        assert(!"An error occurred in DBAccessor.lib.");
    }
/*    if(g_dwDBAccessorDebugFlags & DB_REPORT_THROW && EVENTLOG_INFORMATION_TYPE != dwType)
    {
        throw szMsg;
    }*/
}

#define ARRAY_SIZEOF(x)     (sizeof(x)/sizeof(x[0]))
void DisplayError(SQLSMALLINT iHType, SQLHANDLE hHandle, SQLRETURN retval)
{
    SQLSMALLINT iRecNo;
    SQLCHAR szState[6];
    SQLINTEGER iNativeErr;
    SQLCHAR szMessage[1024];
    CHAR szString[1024];
    SQLSMALLINT iBytesWritten;
    SQLRETURN rt;
    
    iRecNo = 1;

    sprintf(szString, "Return Value being examined: %d\n", retval);
    if(SQL_SUCCESS_WITH_INFO == retval)
    {
        DoDebug(EVENTLOG_INFORMATION_TYPE, szString);
    }

    while(1)
    {
        rt = SQLGetDiagRecA(iHType, hHandle, iRecNo, szState, &iNativeErr, szMessage, sizeof(szMessage), &iBytesWritten);

        if(SQL_NO_DATA == rt)
            break;

        if(SQL_SUCCESS != rt  && SQL_SUCCESS_WITH_INFO != rt)
        {
            DoDebug(EVENTLOG_ERROR_TYPE, "ERROR getting error information from SQL.");
        }

        _snprintf(szString, ARRAY_SIZEOF(szString) - 1, "ERROR: 0x%08x [%s]: %s\n", iNativeErr, szState, szMessage);
        szString[ARRAY_SIZEOF(szString) - 1] = 0;
        DoDebug((SQL_SUCCESS_WITH_INFO == retval) ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_ERROR_TYPE, szString);
        ++iRecNo;
    }
}   

void DebugOutput(char *szFmt, ...)
{
    va_list vargs;
    va_start(vargs, szFmt);
    if(g_dwDBAccessorDebugFlags & DB_REPORT_DEBUGSTRING && g_dwDBAccessorDebugFlags & DB_REPORT_INFORMATIONAL)
    {
        CHAR szMsg[1024];
        DWORD dwWritten;
        dwWritten = _vsnprintf(szMsg, ARRAY_SIZEOF(szMsg) - 1, szFmt, vargs);
        szMsg[ARRAY_SIZEOF(szMsg) - 1] = 0;
        OutputDebugStringA(szMsg);
    }
    va_end(vargs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\env.cpp ===
#include "env.h"
#include "dbdebug.h"
#include <stdio.h>

SQLHANDLE CDBAccessorEnvironment::m_hEnv = SQL_NULL_HANDLE;

CDBAccessorEnvironment::CDBAccessorEnvironment()
{
    SQLRETURN rt;

    rt = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &m_hEnv);
    CHECK_RETVAL(rt, m_hEnv, SQL_HANDLE_ENV, Error);

    rt = SQLSetEnvAttr(m_hEnv, SQL_ATTR_ODBC_VERSION, (LPVOID) SQL_OV_ODBC3, 0);
    CHECK_RETVAL(rt, m_hEnv, SQL_HANDLE_ENV, Error);

    rt = SQLSetEnvAttr(m_hEnv, SQL_ATTR_CONNECTION_POOLING, (LPVOID) SQL_CP_ONE_PER_DRIVER, 0);
    CHECK_RETVAL(rt, m_hEnv, SQL_HANDLE_ENV, Error);

    return;

Error:
    if(m_hEnv)
        SQLFreeHandle(SQL_HANDLE_ENV, m_hEnv);
    m_hEnv = NULL;
}

CDBAccessorEnvironment::~CDBAccessorEnvironment()
{
    if(m_hEnv)
        SQLFreeHandle(SQL_HANDLE_ENV, m_hEnv);
    m_hEnv = NULL;
}

CDBConnection* CDBAccessorEnvironment::SQLConnect(CHAR *szMachine, CHAR *szDatabase, CHAR *szUsername, CHAR *szPassword)
{
    CHAR szBuf[512];
    CDBConnection *pConn;
    _snprintf(szBuf, sizeof(szBuf) - 1, "SERVER=%s;DRIVER=SQL Server;DATABASE=%s;UID=%s;PWD=%s", (szMachine) ? szMachine : "",
                                                                                                (szDatabase) ? szDatabase : "",
                                                                                                (szUsername) ? szUsername : "",
                                                                                                (szPassword) ? szPassword : "");
    pConn = new CDBConnection(m_hEnv, szBuf, sizeof(szBuf));
    if(!pConn)
        return 0;
    
    if(!*pConn)
    {
        delete pConn;
        pConn = 0;
    }
    return pConn;
}

CDBConnection* CDBAccessorEnvironment::DirectConnect(CHAR *szConnectionString)
{
    CDBConnection *pConn;
    pConn = new CDBConnection(m_hEnv, szConnectionString);
    if(!pConn)
        return 0;
    
    if(!*pConn)
    {
        delete pConn;
        pConn = 0;
    }
    return pConn;
}

CDBConnection* CDBAccessorEnvironment::SQLConnect(WCHAR *szMachine, WCHAR *szDatabase, WCHAR *szUsername, WCHAR *szPassword)
{
    WCHAR szBuf[512];
    CDBConnection *pConn;
    _snwprintf(szBuf, sizeof(szBuf)/sizeof(szBuf[0]) - 1, L"SERVER=%s;DRIVER=SQL Server;DATABASE=%s;UID=%s;PWD=%s", (szMachine) ? szMachine : L"",
                                                                                                  (szDatabase) ? szDatabase : L"",
                                                                                                  (szUsername) ? szUsername : L"",
                                                                                                  (szPassword) ? szPassword : L"");
    pConn = new CDBConnection(m_hEnv, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if(!pConn)
        return 0;
    
    if(!*pConn)
    {
        delete pConn;
        pConn = 0;
    }
    return pConn;
}

CDBConnection* CDBAccessorEnvironment::DirectConnect(WCHAR *szConnectionString)
{
    CDBConnection *pConn;
    pConn = new CDBConnection(m_hEnv, szConnectionString);
    if(!pConn)
        return 0;
    
    if(!*pConn)
    {
        delete pConn;
        pConn = 0;
    }
    return pConn;
}

BOOL DBAEnvError()
{
    return CDBAccessorEnvironment::m_hEnv == SQL_NULL_HANDLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\dbaccessor.h ===
#pragma once

#define CALL_TYPE __stdcall

#define HDB_NULL        (0)
#define DB_NTS          (-3)
#define DB_NULL_DATA    (-1)

typedef struct sDBConn {DWORD conn;}  * HDBCONN;
typedef struct sDBStmt {int stmt;}  * HDBSTMT;

#include <oledb.h>

enum PARAM_IO_TYPE
{
    PARAM_IO_UNKNOWN,
    PARAM_IO_INPUT,
    PARAM_IO_INPUT_OUTPUT,
    PARAM_IO_RESULT_COL,
    PARAM_IO_OUTPUT,
    PARAM_IO_RETURN_VALUE
};

enum DB_REPORT_TYPES
{
    DB_REPORT_DEBUGSTRING = 1,
    DB_REPORT_EVENT = 2,
    DB_REPORT_STDERR = 4,
    DB_REPORT_ASSERT = 8,
//    DB_REPORT_THROW = 16,
    DB_REPORT_INFORMATIONAL = 128,
};

VOID CALL_TYPE SetErrorReporting(DWORD dwReports, CHAR *szHost = 0);

VOID CALL_TYPE DBClose(HDBCONN& hConn);
VOID CALL_TYPE DBClose(HDBSTMT& hStmt);

HDBCONN CALL_TYPE DBSQLConnect(CHAR *szMachine, CHAR *szDatabase = 0, CHAR *szUsername = 0, CHAR *szPassword = 0);
HDBCONN CALL_TYPE DBSQLConnect(WCHAR *szMachine, WCHAR *szDatabase = 0, WCHAR *szUsername = 0, WCHAR *szPassword = 0);
HDBCONN CALL_TYPE DBDirectConnect(CHAR *szConnectionString);
HDBCONN CALL_TYPE DBDirectConnect(WCHAR *szConnectionString);

HDBSTMT CALL_TYPE DBPrepare(HDBCONN hBase, CHAR *szQuery);
HDBSTMT CALL_TYPE DBPrepare(HDBCONN hBase, WCHAR *szQuery);

// Simple implementation DBStmtBindParam's
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, double *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, float *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, int *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, long *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, short *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, char *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, unsigned int *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, unsigned long *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, unsigned short *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, unsigned char *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, bool *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, __int64 *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, unsigned __int64 *pParam, int *pOptions = 0);

// More complex implemenations for DBStmtBindParam
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, DBTIMESTAMP *pParam, int *pOptions = 0);
BOOL CALL_TYPE DBStmtBindParamSeq(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, CHAR *pParam, DWORD *pdwSize);
BOOL CALL_TYPE DBStmtBindParamSeq(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, WCHAR *pParam, DWORD *pdwSize);
BOOL CALL_TYPE DBStmtBindParamSeq(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, BYTE *pParam, DWORD *pdwSize);

BOOL CALL_TYPE DBStmtExecute(HDBSTMT hStmt);
BOOL CALL_TYPE DBStmtFetch(HDBSTMT hStmt, BOOL &fDone);
BOOL CALL_TYPE DBStmtReset(HDBSTMT hStmt);
BOOL CALL_TYPE DBStmtPrepare(HDBSTMT hStmt, CHAR *szQuery);
BOOL CALL_TYPE DBStmtPrepare(HDBSTMT hStmt, WCHAR *szQuery);
BOOL CALL_TYPE DBStmtCloseCursor(HDBSTMT hStmt);
BOOL CALL_TYPE DBStmtMoreResults(HDBSTMT hStmt);

BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, double *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, float *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, bool *pParam, DWORD *pdwSize = 0);

BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, int *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, long *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, short *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, char *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, unsigned int *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, unsigned long *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, unsigned short *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, unsigned char *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, __int64 *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, unsigned __int64 *pParam, DWORD *pdwSize = 0);

BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, DBTIMESTAMP *pParam, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, CHAR *pParam, DWORD dwSize, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, WCHAR *pParam, DWORD dwSize, DWORD *pdwSize = 0);
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, BYTE *pParam, DWORD dwSize, DWORD *pdwSize = 0);

#undef CALL_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\stmt.cpp ===
#include "stmt.h"
#include "dbdebug.h"

CDBStatement::CDBStatement(SQLHANDLE hDB, CHAR *szStatement) : m_hStmt(0)
{
    SQLRETURN rt;

    rt = SQLAllocHandle(SQL_HANDLE_STMT, hDB, &m_hStmt);
    CHECK_RETVAL(rt, hDB, SQL_HANDLE_DBC, Error);

    rt = SQLPrepareA(m_hStmt, (SQLCHAR *) szStatement, SQL_NTS);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    DebugOutput("STMT: AllocHandle 0x%08x for %s", m_hStmt, szStatement);
    return;
Error:
    if(m_hStmt)
    {
        rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
        }
    }
    m_hStmt = 0;
}

CDBStatement::CDBStatement(SQLHANDLE hDB, WCHAR *szStatement) : m_hStmt(0)
{
    SQLRETURN rt;

    rt = SQLAllocHandle(SQL_HANDLE_STMT, hDB, &m_hStmt);
    CHECK_RETVAL(rt, hDB, SQL_HANDLE_DBC, Error);

    rt = SQLPrepareW(m_hStmt, szStatement, SQL_NTS);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    DebugOutput("STMT: AllocHandle 0x%08x for %S", m_hStmt, szStatement);
    return;
Error:
    if(m_hStmt)
    {
        rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
        }
    }
    m_hStmt = 0;
}


CDBStatement::~CDBStatement()
{
    SQLRETURN rt;
    if(m_hStmt)
    {
        if(m_hStmt)
        {
            rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
            if(SQL_SUCCESS != rt)
            {
                DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
            }
        }
        DebugOutput("STMT: FreeHandle for 0x%08x", m_hStmt);
    }
    m_hStmt = 0;
}

BOOL CDBStatement::Execute()
{
    SQLRETURN rt;
    SQLCloseCursor(m_hStmt);
    rt = SQLExecute(m_hStmt);
    if(SQL_NO_DATA == rt)
        return TRUE;
    
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;

Error:
    return FALSE;
}


BOOL CDBStatement::Fetch(BOOL &fDone)
{
    int rt;
    SQLRETURN& res = (SQLRETURN&) rt;
    fDone = FALSE;
    res = SQLFetch(m_hStmt);
    if(SQL_NO_DATA == res)
    {
        res = SQLMoreResults(m_hStmt);
        if(SQL_NO_DATA == res)
        {
            fDone = TRUE;
            return FALSE;
        }
        CHECK_RETVAL(res, m_hStmt, SQL_HANDLE_STMT, Error);
        res = SQLFetch(m_hStmt);
    }
    CHECK_RETVAL(res, m_hStmt, SQL_HANDLE_STMT, Error);
    return TRUE;
Error:
    return FALSE;
}

BOOL CDBStatement::MoreResults()
{
    SQLRETURN rt;
    rt = SQLMoreResults(m_hStmt);
    if(SQL_NO_DATA == rt)
        goto Error;
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    return FALSE;
}


BOOL CDBStatement::Reset()
{
    SQLRETURN rt;
    rt = SQLFreeStmt(m_hStmt, SQL_UNBIND);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);
    rt = SQLFreeStmt(m_hStmt, SQL_RESET_PARAMS);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);
    rt = SQLFreeStmt(m_hStmt, SQL_CLOSE);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    if(m_hStmt)
    {
        rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
        }
    }
    m_hStmt = 0;
    return FALSE;
}

BOOL CDBStatement::Prepare(CHAR *szQuery)
{
    SQLRETURN rt;
    rt = SQLPrepareA(m_hStmt, (SQLCHAR *) szQuery, SQL_NTS);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    if(m_hStmt)
    {
        rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
        }
    }
    m_hStmt = 0;
    return FALSE;
}

BOOL CDBStatement::Prepare(WCHAR *szQuery)
{
    SQLRETURN rt;
    rt = SQLPrepareW(m_hStmt, (SQLWCHAR *) szQuery, SQL_NTS);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    if(m_hStmt)
    {
        rt = SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);
        if(SQL_SUCCESS != rt)
        {
            DisplayError(SQL_HANDLE_STMT, m_hStmt, rt);
        }
    }
    m_hStmt = 0;
    return FALSE;
}

BOOL CDBStatement::CloseCursor()
{
    SQLRETURN rt;
    rt = SQLCloseCursor(m_hStmt);
    //CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);
    return TRUE;
//Error:
//  return FALSE;
}


// BindParameter Implementations
//
#define BIND_PARAM_IMPL_BASIC(ctype, sqltypeid)                                                                 \
BOOL CDBStatement::BindParameter(int index, PARAM_IO_TYPE ioType, ctype *pParam, int *pOptions)                 \
{                                                                                                               \
    SQLRETURN rt;                                                                                               \
    SQLSMALLINT siType = 0;                                                                                     \
    SQLUINTEGER uiLength = 0;                                                                                   \
    SQLSMALLINT siDecimalDigits = 0;                                                                            \
    SQLSMALLINT siNullable = 0;                                                                                                                                   \
                                                                                                                                                                                 \
    rt = SQLDescribeParam(m_hStmt, (SQLUSMALLINT) index, &siType, &uiLength, &siDecimalDigits, &siNullable);               \
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);                                                                                          \
    /*DebugOutput("SQLDescribeParam: %d, %d, %d, %d, %d\n", index, siType, uiLength, siDecimalDigits, siNullable);*/    \
                                                                                                                \
    rt = SQLBindParameter(m_hStmt, (SQLUSMALLINT) index, (SQLSMALLINT) ioType, sqltypeid, siType, uiLength,     \
                                siDecimalDigits, pParam, sizeof(ctype), (SQLINTEGER *) pOptions);               \
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);                                                          \
                                                                                                                \
    return TRUE;                                                                                                \
Error:                                                                                                          \
    return FALSE;                                                                                               \
}

BIND_PARAM_IMPL_BASIC(double, SQL_C_DOUBLE)
BIND_PARAM_IMPL_BASIC(float, SQL_C_FLOAT)
BIND_PARAM_IMPL_BASIC(int, SQL_C_SLONG)
BIND_PARAM_IMPL_BASIC(long, SQL_C_SLONG)
BIND_PARAM_IMPL_BASIC(short, SQL_C_SSHORT)
BIND_PARAM_IMPL_BASIC(char, SQL_C_STINYINT)
BIND_PARAM_IMPL_BASIC(unsigned int, SQL_C_ULONG)
BIND_PARAM_IMPL_BASIC(unsigned long, SQL_C_ULONG)
BIND_PARAM_IMPL_BASIC(unsigned short, SQL_C_USHORT)
BIND_PARAM_IMPL_BASIC(unsigned char, SQL_C_UTINYINT)
BIND_PARAM_IMPL_BASIC(bool, SQL_C_BIT)
BIND_PARAM_IMPL_BASIC(__int64, SQL_C_SBIGINT)
BIND_PARAM_IMPL_BASIC(unsigned __int64, SQL_C_UBIGINT)
BIND_PARAM_IMPL_BASIC(DBTIMESTAMP, SQL_C_TIMESTAMP)

BOOL CDBStatement::BindParameter(int index, PARAM_IO_TYPE ioType, CHAR *pParam, DWORD *pdwSize)
{
    SQLRETURN rt;
    SQLSMALLINT siType = 0;
    SQLUINTEGER uiLength = 0;
    SQLSMALLINT siDecimalDigits = 0;
    SQLSMALLINT siNullable = 0;

    rt = SQLDescribeParam(m_hStmt, (SQLUSMALLINT) index, &siType, &uiLength, &siDecimalDigits, &siNullable);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    rt = SQLBindParameter(m_hStmt, (SQLUSMALLINT) index, (SQLSMALLINT) ioType, SQL_C_CHAR, siType, uiLength, 0, pParam, *pdwSize, (long *) pdwSize);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    return FALSE;
}

BOOL CDBStatement::BindParameter(int index, PARAM_IO_TYPE ioType, WCHAR *pParam, DWORD *pdwSize)
{
    return FALSE;
}

BOOL CDBStatement::BindParameter(int index, PARAM_IO_TYPE ioType, BYTE *pParam, DWORD *pdwSize)
{
    return FALSE;
}

// BindParameter Implementations
//
#define BIND_COL_IMPL_BASIC(ctype, sqltypeid)                                                                   \
BOOL CDBStatement::BindColumn(int index, ctype *pParam, DWORD *pdwSize)                                         \
{                                                                                                               \
    SQLRETURN rt;                                                                                               \
                                                                                                                \
    rt = SQLBindCol(m_hStmt, (SQLUSMALLINT) index, sqltypeid, pParam, sizeof(ctype), (SQLINTEGER *) pdwSize);   \
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);                                                          \
                                                                                                                \
    return TRUE;                                                                                                \
Error:                                                                                                          \
    return FALSE;                                                                                               \
}

BIND_COL_IMPL_BASIC(double, SQL_C_DOUBLE)
BIND_COL_IMPL_BASIC(float, SQL_C_FLOAT)
BIND_COL_IMPL_BASIC(int, SQL_C_SLONG)
BIND_COL_IMPL_BASIC(long, SQL_C_SLONG)
BIND_COL_IMPL_BASIC(short, SQL_C_SSHORT)
BIND_COL_IMPL_BASIC(char, SQL_C_STINYINT)
BIND_COL_IMPL_BASIC(unsigned int, SQL_C_ULONG)
BIND_COL_IMPL_BASIC(unsigned long, SQL_C_ULONG)
BIND_COL_IMPL_BASIC(unsigned short, SQL_C_USHORT)
BIND_COL_IMPL_BASIC(unsigned char, SQL_C_UTINYINT)
BIND_COL_IMPL_BASIC(bool, SQL_C_BIT)
BIND_COL_IMPL_BASIC(__int64, SQL_C_SBIGINT)
BIND_COL_IMPL_BASIC(unsigned __int64, SQL_C_UBIGINT)
BIND_COL_IMPL_BASIC(DBTIMESTAMP, SQL_C_TIMESTAMP)


BOOL CDBStatement::BindColumn(int index, CHAR *pParam, DWORD dwSize, DWORD *pdwSize)
{
    SQLRETURN rt;
    rt = SQLBindCol(m_hStmt, (SQLUSMALLINT) index, SQL_C_CHAR, pParam, (SQLINTEGER) dwSize, (SQLINTEGER *) pdwSize);
    CHECK_RETVAL(rt, m_hStmt, SQL_HANDLE_STMT, Error);

    return TRUE;
Error:
    return FALSE;
}

BOOL CDBStatement::BindColumn(int index, WCHAR *pParam, DWORD dwSize, DWORD *pdwSize)
{
    return FALSE;
}

BOOL CDBStatement::BindColumn(int index, BYTE *pParam, DWORD dwSize, DWORD *pdwSize)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\dbaccessor.cpp ===
#include <windows.h>
#include <assert.h>
#include "env.h"
#include "dbdebug.h"
#include "dbaccessor.h"

#define CALL_TYPE __stdcall

static CDBAccessorEnvironment g_DBA;

VOID CALL_TYPE DBClose(HDBCONN& hObj)
{
    delete ((CDBConnection *) hObj);
    hObj = 0;
}

VOID CALL_TYPE DBClose(HDBSTMT& hObj)
{
    delete ((CDBStatement *) hObj);
    hObj = 0;
}


HDBCONN CALL_TYPE DBSQLConnect(CHAR *szMachine, CHAR *szDatabase, CHAR *szUsername, CHAR *szPassword)
{
    return (HDBCONN) g_DBA.SQLConnect(szMachine, szDatabase, szUsername, szPassword);
}

HDBCONN CALL_TYPE DBSQLConnect(WCHAR *szMachine, WCHAR *szDatabase, WCHAR *szUsername, WCHAR *szPassword)
{
    return (HDBCONN) g_DBA.SQLConnect(szMachine, szDatabase, szUsername, szPassword);
}

HDBCONN CALL_TYPE DBDirectConnect(CHAR *szConnectionString)
{
    return (HDBCONN) g_DBA.DirectConnect(szConnectionString);
}

HDBCONN CALL_TYPE DBDirectConnect(WCHAR *szConnectionString)
{
    return (HDBCONN) g_DBA.DirectConnect(szConnectionString);
}

HDBSTMT CALL_TYPE DBPrepare(HDBCONN hBase, CHAR *szQuery)
{
    return (HDBSTMT) ((CDBConnection *) hBase)->Prepare(szQuery);
}

HDBSTMT CALL_TYPE DBPrepare(HDBCONN hBase, WCHAR *szQuery)
{
    return (HDBSTMT) ((CDBConnection *) hBase)->Prepare(szQuery);
}


BOOL CALL_TYPE DBStmtExecute(HDBSTMT hStmt)
{
    return ((CDBStatement *) hStmt)->Execute();
}

BOOL CALL_TYPE DBStmtFetch(HDBSTMT hStmt, BOOL& fDone)
{
    return ((CDBStatement *) hStmt)->Fetch(fDone);
}

BOOL CALL_TYPE DBStmtReset(HDBSTMT hStmt)
{
    return ((CDBStatement *) hStmt)->Reset();
}

BOOL CALL_TYPE DBStmtPrepare(HDBSTMT hStmt, CHAR *szQuery)
{
    return ((CDBStatement *) hStmt)->Prepare(szQuery);
}

BOOL CALL_TYPE DBStmtPrepare(HDBSTMT hStmt, WCHAR *szQuery)
{
    return ((CDBStatement *) hStmt)->Prepare(szQuery);
}

BOOL CALL_TYPE DBStmtCloseCursor(HDBSTMT hStmt)
{
    return ((CDBStatement *) hStmt)->CloseCursor();
}

BOOL CALL_TYPE DBStmtMoreResults(HDBSTMT hStmt)
{
    return ((CDBStatement *) hStmt)->MoreResults();
}


// Simple implementation BindParameter's
#define DBSTMTBINDPARAMIMPL(type)                                                                               \
BOOL CALL_TYPE DBStmtBindParam(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, type *pParam, int *pOptions)     \
{                                                                                                               \
    return ((CDBStatement *) hStmt)->BindParameter(index, ioType, pParam, pOptions);                            \
}

DBSTMTBINDPARAMIMPL(double)
DBSTMTBINDPARAMIMPL(float)
DBSTMTBINDPARAMIMPL(int)
DBSTMTBINDPARAMIMPL(long)
DBSTMTBINDPARAMIMPL(short)
DBSTMTBINDPARAMIMPL(char)
DBSTMTBINDPARAMIMPL(unsigned int)
DBSTMTBINDPARAMIMPL(unsigned long)
DBSTMTBINDPARAMIMPL(unsigned short)
DBSTMTBINDPARAMIMPL(unsigned char)
DBSTMTBINDPARAMIMPL(bool)
DBSTMTBINDPARAMIMPL(__int64)
DBSTMTBINDPARAMIMPL(unsigned __int64)
DBSTMTBINDPARAMIMPL(DBTIMESTAMP)

// More complex implemenations for BindParameter
#define DBSTMTBINDPARAMIMPL2(type)                                                                              \
BOOL CALL_TYPE DBStmtBindParamSeq(HDBSTMT hStmt, int index, PARAM_IO_TYPE ioType, type *pParam, DWORD *pdwSize) \
{                                                                                                               \
    return ((CDBStatement *) hStmt)->BindParameter(index, ioType, pParam, pdwSize);                             \
}

DBSTMTBINDPARAMIMPL2(CHAR)
DBSTMTBINDPARAMIMPL2(WCHAR)
DBSTMTBINDPARAMIMPL2(BYTE)


#define DBSTMTBINDCOLIMPL(type)                                                             \
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, type *pParam, DWORD *pdwSize)        \
{                                                                                           \
    return ((CDBStatement *) hStmt)->BindColumn(index, pParam, pdwSize);                    \
}

DBSTMTBINDCOLIMPL(double)
DBSTMTBINDCOLIMPL(float)
DBSTMTBINDCOLIMPL(int)
DBSTMTBINDCOLIMPL(long)
DBSTMTBINDCOLIMPL(short)
DBSTMTBINDCOLIMPL(char)
DBSTMTBINDCOLIMPL(unsigned int)
DBSTMTBINDCOLIMPL(unsigned long)
DBSTMTBINDCOLIMPL(unsigned short)
DBSTMTBINDCOLIMPL(unsigned char)
DBSTMTBINDCOLIMPL(bool)
DBSTMTBINDCOLIMPL(__int64)
DBSTMTBINDCOLIMPL(unsigned __int64)
DBSTMTBINDCOLIMPL(DBTIMESTAMP)

#define DBSTMTBINDCOLIMPL2(type)                                                                            \
BOOL CALL_TYPE DBStmtBindCol(HDBSTMT hStmt, int index, type *pParam, DWORD dwSize, DWORD *pdwSize)          \
{                                                                                                           \
    return ((CDBStatement *) hStmt)->BindColumn(index, pParam, dwSize, pdwSize);                            \
}

DBSTMTBINDCOLIMPL2(CHAR)
DBSTMTBINDCOLIMPL2(WCHAR)
DBSTMTBINDCOLIMPL2(BYTE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\env.h ===
#pragma once

#include <windows.h>
#include <sql.h>
#include "db.h"

class CDBAccessorEnvironment
{
public:
    CDBAccessorEnvironment();
    ~CDBAccessorEnvironment();

    CDBConnection* SQLConnect(CHAR *szMachine, CHAR *szDatabase = 0, CHAR *szUsername = 0, CHAR *szPassword = 0);
    CDBConnection* DirectConnect(CHAR *szConnectionString);

    CDBConnection* SQLConnect(WCHAR *szMachine, WCHAR *szDatabase = 0, WCHAR *szUsername = 0, WCHAR *szPassword = 0);
    CDBConnection* DirectConnect(WCHAR *szConnectionString);

    friend BOOL DBAEnvError();

protected:
    static SQLHANDLE m_hEnv;
};

BOOL DBAEnvError();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_dbaccessor_none_12.4.56.0_none_8113e28580b86d4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dbaccessor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.manifest
XP_MANIFEST_PATH=manifests\x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.cat
XP_CATALOG_PATH=manifests\x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.cat
XP_PAYLOAD_PATH=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dbaccessor,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\stmt.h ===
#pragma once

#include <windows.h>
#include <sql.h>
#include <sqlext.h>
#include "dbaccessor.h"

class CDBBase
{
public:
    CDBBase() {}
    virtual ~CDBBase() {}
};

class CDBStatement : CDBBase
{
public:
    CDBStatement(SQLHANDLE hDB, CHAR *szStatement);
    CDBStatement(SQLHANDLE hDB, WCHAR *szStatement);
    ~CDBStatement();

    inline operator BOOL() {return m_hStmt != SQL_NULL_HANDLE;}

    // Simple implementation BindParameter's
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, double *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, float *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, int *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, long *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, short *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, char *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, unsigned int *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, unsigned long *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, unsigned short *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, unsigned char *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, bool *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, __int64 *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, unsigned __int64 *pParam, int *pOptions = 0);

    // More complex implemenations for BindParameter
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, DBTIMESTAMP *pParam, int *pOptions = 0);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, CHAR *pParam, DWORD *pdwSize);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, WCHAR *pParam, DWORD *pdwSize);
    BOOL BindParameter(int index, PARAM_IO_TYPE ioType, BYTE *pParam, DWORD *pdwSize);

    BOOL Execute();
    BOOL Fetch(BOOL &fDone);
    BOOL Reset();
    BOOL Prepare(CHAR *szQuery);
    BOOL Prepare(WCHAR *szQuery);
    BOOL CloseCursor();
    BOOL MoreResults();

    BOOL BindColumn(int index, double *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, float *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, bool *pParam, DWORD *pdwSize = 0);

    BOOL BindColumn(int index, int *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, long *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, short *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, char *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, unsigned int *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, unsigned long *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, unsigned short *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, unsigned char *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, __int64 *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, unsigned __int64 *pParam, DWORD *pdwSize = 0);

    BOOL BindColumn(int index, DBTIMESTAMP *pParam, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, CHAR *pParam, DWORD dwSize, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, WCHAR *pParam, DWORD dwSize, DWORD *pdwSize = 0);
    BOOL BindColumn(int index, BYTE *pParam, DWORD dwSize, DWORD *pdwSize = 0);

protected:
    SQLHANDLE m_hStmt;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\critsect.h ===
#pragma once


class CCriticalSection
{
public:
    inline CCriticalSection() {InitializeCriticalSection(&m_cs);}
    inline ~CCriticalSection() {DeleteCriticalSection(&m_cs);}

    inline void Enter() {EnterCriticalSection(&m_cs);}
    inline void Leave() {LeaveCriticalSection(&m_cs);}
    inline BOOL TryEnter() {return TryEnterCriticalSection(&m_cs);}
protected:
    CRITICAL_SECTION m_cs;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\dbaccessor\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_dbaccessor_none_12.4.56.0_none_8113e28580b86d4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dbaccessor
ASSEMBLY_IDENTITY_P