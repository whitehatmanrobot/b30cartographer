ileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define ITraceDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define ITraceDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define ITraceDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define ITraceDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define ITraceDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define ITraceDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define ITraceDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define ITraceDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define ITraceDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define ITraceDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define ITraceDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define ITraceDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define ITraceDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define ITraceDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define ITraceDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define ITraceDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define ITraceDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define ITraceDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define ITraceDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define ITraceDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define ITraceDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define ITraceDataCollector_get_BufferSize(This,size)	\
    ( (This)->lpVtbl -> get_BufferSize(This,size) ) 

#define ITraceDataCollector_put_BufferSize(This,size)	\
    ( (This)->lpVtbl -> put_BufferSize(This,size) ) 

#define ITraceDataCollector_get_BuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> get_BuffersLost(This,buffers) ) 

#define ITraceDataCollector_put_BuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> put_BuffersLost(This,buffers) ) 

#define ITraceDataCollector_get_BuffersWritten(This,buffers)	\
    ( (This)->lpVtbl -> get_BuffersWritten(This,buffers) ) 

#define ITraceDataCollector_put_BuffersWritten(This,buffers)	\
    ( (This)->lpVtbl -> put_BuffersWritten(This,buffers) ) 

#define ITraceDataCollector_get_ClockType(This,clock)	\
    ( (This)->lpVtbl -> get_ClockType(This,clock) ) 

#define ITraceDataCollector_put_ClockType(This,clock)	\
    ( (This)->lpVtbl -> put_ClockType(This,clock) ) 

#define ITraceDataCollector_get_EventsLost(This,events)	\
    ( (This)->lpVtbl -> get_EventsLost(This,events) ) 

#define ITraceDataCollector_put_EventsLost(This,events)	\
    ( (This)->lpVtbl -> put_EventsLost(This,events) ) 

#define ITraceDataCollector_get_ExtendedModes(This,mode)	\
    ( (This)->lpVtbl -> get_ExtendedModes(This,mode) ) 

#define ITraceDataCollector_put_ExtendedModes(This,mode)	\
    ( (This)->lpVtbl -> put_ExtendedModes(This,mode) ) 

#define ITraceDataCollector_get_FlushTimer(This,seconds)	\
    ( (This)->lpVtbl -> get_FlushTimer(This,seconds) ) 

#define ITraceDataCollector_put_FlushTimer(This,seconds)	\
    ( (This)->lpVtbl -> put_FlushTimer(This,seconds) ) 

#define ITraceDataCollector_get_FreeBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_FreeBuffers(This,buffers) ) 

#define ITraceDataCollector_put_FreeBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_FreeBuffers(This,buffers) ) 

#define ITraceDataCollector_get_Guid(This,guid)	\
    ( (This)->lpVtbl -> get_Guid(This,guid) ) 

#define ITraceDataCollector_put_Guid(This,guid)	\
    ( (This)->lpVtbl -> put_Guid(This,guid) ) 

#define ITraceDataCollector_get_IsKernelTrace(This,kernel)	\
    ( (This)->lpVtbl -> get_IsKernelTrace(This,kernel) ) 

#define ITraceDataCollector_get_MaximumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_MaximumBuffers(This,buffers) ) 

#define ITraceDataCollector_put_MaximumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_MaximumBuffers(This,buffers) ) 

#define ITraceDataCollector_get_MinimumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_MinimumBuffers(This,buffers) ) 

#define ITraceDataCollector_put_MinimumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_MinimumBuffers(This,buffers) ) 

#define ITraceDataCollector_get_NumberOfBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_NumberOfBuffers(This,buffers) ) 

#define ITraceDataCollector_put_NumberOfBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_NumberOfBuffers(This,buffers) ) 

#define ITraceDataCollector_get_PreallocateFile(This,allocate)	\
    ( (This)->lpVtbl -> get_PreallocateFile(This,allocate) ) 

#define ITraceDataCollector_put_PreallocateFile(This,allocate)	\
    ( (This)->lpVtbl -> put_PreallocateFile(This,allocate) ) 

#define ITraceDataCollector_get_ProcessMode(This,process)	\
    ( (This)->lpVtbl -> get_ProcessMode(This,process) ) 

#define ITraceDataCollector_put_ProcessMode(This,process)	\
    ( (This)->lpVtbl -> put_ProcessMode(This,process) ) 

#define ITraceDataCollector_get_RealTimeBuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> get_RealTimeBuffersLost(This,buffers) ) 

#define ITraceDataCollector_put_RealTimeBuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> put_RealTimeBuffersLost(This,buffers) ) 

#define ITraceDataCollector_get_SessionId(This,id)	\
    ( (This)->lpVtbl -> get_SessionId(This,id) ) 

#define ITraceDataCollector_put_SessionId(This,id)	\
    ( (This)->lpVtbl -> put_SessionId(This,id) ) 

#define ITraceDataCollector_get_SessionName(This,name)	\
    ( (This)->lpVtbl -> get_SessionName(This,name) ) 

#define ITraceDataCollector_put_SessionName(This,name)	\
    ( (This)->lpVtbl -> put_SessionName(This,name) ) 

#define ITraceDataCollector_get_SessionThreadId(This,tid)	\
    ( (This)->lpVtbl -> get_SessionThreadId(This,tid) ) 

#define ITraceDataCollector_put_SessionThreadId(This,tid)	\
    ( (This)->lpVtbl -> put_SessionThreadId(This,tid) ) 

#define ITraceDataCollector_get_StreamMode(This,mode)	\
    ( (This)->lpVtbl -> get_StreamMode(This,mode) ) 

#define ITraceDataCollector_put_StreamMode(This,mode)	\
    ( (This)->lpVtbl -> put_StreamMode(This,mode) ) 

#define ITraceDataCollector_get_TraceDataProviders(This,providers)	\
    ( (This)->lpVtbl -> get_TraceDataProviders(This,providers) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataCollector_INTERFACE_DEFINED__ */


#ifndef __IConfigurationDataCollector_INTERFACE_DEFINED__
#define __IConfigurationDataCollector_INTERFACE_DEFINED__

/* interface IConfigurationDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IConfigurationDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837514-098b-11d8-9414-505054503030")
    IConfigurationDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxCount( 
            /* [retval][out] */ __RPC__out unsigned long *count) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxCount( 
            /* [in] */ unsigned long count) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxRecursiveDepth( 
            /* [retval][out] */ __RPC__out unsigned long *depth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxRecursiveDepth( 
            /* [in] */ unsigned long depth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxTotalSize( 
            /* [retval][out] */ __RPC__out unsigned long *size) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxTotalSize( 
            /* [in] */ unsigned long size) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Files( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Files) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Files( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Files) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ManagementQueries( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Queries) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ManagementQueries( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Queries) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_QueryNetworkAdapters( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *network) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_QueryNetworkAdapters( 
            /* [in] */ VARIANT_BOOL network) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegistryKeys( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *query) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RegistryKeys( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * query) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegistryMaxRecursiveDepth( 
            /* [retval][out] */ __RPC__out unsigned long *depth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RegistryMaxRecursiveDepth( 
            /* [in] */ unsigned long depth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SystemStateFile( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *FileName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SystemStateFile( 
            /* [in] */ __RPC__in BSTR FileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigurationDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IConfigurationDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IConfigurationDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IConfigurationDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxCount )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *count);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxCount )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ unsigned long count);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxRecursiveDepth )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *depth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxRecursiveDepth )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ unsigned long depth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxTotalSize )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *size);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxTotalSize )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ unsigned long size);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Files )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Files);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Files )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Files);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManagementQueries )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Queries);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ManagementQueries )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Queries);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueryNetworkAdapters )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *network);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_QueryNetworkAdapters )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL network);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegistryKeys )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *query);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RegistryKeys )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * query);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegistryMaxRecursiveDepth )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *depth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RegistryMaxRecursiveDepth )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ unsigned long depth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SystemStateFile )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *FileName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SystemStateFile )( 
            __RPC__in IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR FileName);
        
        END_INTERFACE
    } IConfigurationDataCollectorVtbl;

    interface IConfigurationDataCollector
    {
        CONST_VTBL struct IConfigurationDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigurationDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigurationDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigurationDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigurationDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IConfigurationDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IConfigurationDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IConfigurationDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IConfigurationDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IConfigurationDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IConfigurationDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IConfigurationDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IConfigurationDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IConfigurationDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IConfigurationDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IConfigurationDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IConfigurationDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IConfigurationDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IConfigurationDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IConfigurationDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IConfigurationDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IConfigurationDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IConfigurationDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IConfigurationDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IConfigurationDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IConfigurationDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IConfigurationDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IConfigurationDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IConfigurationDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IConfigurationDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IConfigurationDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IConfigurationDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IConfigurationDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IConfigurationDataCollector_get_FileMaxCount(This,count)	\
    ( (This)->lpVtbl -> get_FileMaxCount(This,count) ) 

#define IConfigurationDataCollector_put_FileMaxCount(This,count)	\
    ( (This)->lpVtbl -> put_FileMaxCount(This,count) ) 

#define IConfigurationDataCollector_get_FileMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> get_FileMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_put_FileMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> put_FileMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_get_FileMaxTotalSize(This,size)	\
    ( (This)->lpVtbl -> get_FileMaxTotalSize(This,size) ) 

#define IConfigurationDataCollector_put_FileMaxTotalSize(This,size)	\
    ( (This)->lpVtbl -> put_FileMaxTotalSize(This,size) ) 

#define IConfigurationDataCollector_get_Files(This,Files)	\
    ( (This)->lpVtbl -> get_Files(This,Files) ) 

#define IConfigurationDataCollector_put_Files(This,Files)	\
    ( (This)->lpVtbl -> put_Files(This,Files) ) 

#define IConfigurationDataCollector_get_ManagementQueries(This,Queries)	\
    ( (This)->lpVtbl -> get_ManagementQueries(This,Queries) ) 

#define IConfigurationDataCollector_put_ManagementQueries(This,Queries)	\
    ( (This)->lpVtbl -> put_ManagementQueries(This,Queries) ) 

#define IConfigurationDataCollector_get_QueryNetworkAdapters(This,network)	\
    ( (This)->lpVtbl -> get_QueryNetworkAdapters(This,network) ) 

#define IConfigurationDataCollector_put_QueryNetworkAdapters(This,network)	\
    ( (This)->lpVtbl -> put_QueryNetworkAdapters(This,network) ) 

#define IConfigurationDataCollector_get_RegistryKeys(This,query)	\
    ( (This)->lpVtbl -> get_RegistryKeys(This,query) ) 

#define IConfigurationDataCollector_put_RegistryKeys(This,query)	\
    ( (This)->lpVtbl -> put_RegistryKeys(This,query) ) 

#define IConfigurationDataCollector_get_RegistryMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> get_RegistryMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_put_RegistryMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> put_RegistryMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_get_SystemStateFile(This,FileName)	\
    ( (This)->lpVtbl -> get_SystemStateFile(This,FileName) ) 

#define IConfigurationDataCollector_put_SystemStateFile(This,FileName)	\
    ( (This)->lpVtbl -> put_SystemStateFile(This,FileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConfigurationDataCollector_INTERFACE_DEFINED__ */


#ifndef __IAlertDataCollector_INTERFACE_DEFINED__
#define __IAlertDataCollector_INTERFACE_DEFINED__

/* interface IAlertDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IAlertDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837516-098b-11d8-9414-505054503030")
    IAlertDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AlertThresholds( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *alerts) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AlertThresholds( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * alerts) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EventLog( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *log) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EventLog( 
            /* [in] */ VARIANT_BOOL log) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SampleInterval( 
            /* [retval][out] */ __RPC__out unsigned long *interval) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SampleInterval( 
            /* [in] */ unsigned long interval) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Task( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Task( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskRunAsSelf( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskRunAsSelf( 
            /* [in] */ VARIANT_BOOL RunAsSelf) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskArguments( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskUserTextArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskUserTextArguments( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TriggerDataCollectorSet( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TriggerDataCollectorSet( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlertDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAlertDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAlertDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IAlertDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAlertDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlertThresholds )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *alerts);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlertThresholds )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * alerts);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventLog )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *log);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventLog )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL log);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SampleInterval )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *interval);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SampleInterval )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ unsigned long interval);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Task )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Task )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskRunAsSelf )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskRunAsSelf )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL RunAsSelf);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskArguments )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskArguments )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskUserTextArguments )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskUserTextArguments )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TriggerDataCollectorSet )( 
            __RPC__in IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TriggerDataCollectorSet )( 
            __RPC__in IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        END_INTERFACE
    } IAlertDataCollectorVtbl;

    interface IAlertDataCollector
    {
        CONST_VTBL struct IAlertDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlertDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAlertDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAlertDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAlertDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAlertDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAlertDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAlertDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAlertDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IAlertDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IAlertDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IAlertDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IAlertDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IAlertDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IAlertDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IAlertDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IAlertDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IAlertDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IAlertDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IAlertDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IAlertDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IAlertDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IAlertDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IAlertDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IAlertDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IAlertDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IAlertDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IAlertDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IAlertDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IAlertDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IAlertDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IAlertDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IAlertDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IAlertDataCollector_get_AlertThresholds(This,alerts)	\
    ( (This)->lpVtbl -> get_AlertThresholds(This,alerts) ) 

#define IAlertDataCollector_put_AlertThresholds(This,alerts)	\
    ( (This)->lpVtbl -> put_AlertThresholds(This,alerts) ) 

#define IAlertDataCollector_get_EventLog(This,log)	\
    ( (This)->lpVtbl -> get_EventLog(This,log) ) 

#define IAlertDataCollector_put_EventLog(This,log)	\
    ( (This)->lpVtbl -> put_EventLog(This,log) ) 

#define IAlertDataCollector_get_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> get_SampleInterval(This,interval) ) 

#define IAlertDataCollector_put_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> put_SampleInterval(This,interval) ) 

#define IAlertDataCollector_get_Task(This,task)	\
    ( (This)->lpVtbl -> get_Task(This,task) ) 

#define IAlertDataCollector_put_Task(This,task)	\
    ( (This)->lpVtbl -> put_Task(This,task) ) 

#define IAlertDataCollector_get_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> get_TaskRunAsSelf(This,RunAsSelf) ) 

#define IAlertDataCollector_put_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> put_TaskRunAsSelf(This,RunAsSelf) ) 

#define IAlertDataCollector_get_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> get_TaskArguments(This,task) ) 

#define IAlertDataCollector_put_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> put_TaskArguments(This,task) ) 

#define IAlertDataCollector_get_TaskUserTextArguments(This,task)	\
    ( (This)->lpVtbl -> get_TaskUserTextArguments(This,task) ) 

#define IAlertDataCollector_put_TaskUserTextArguments(This,task)	\
    ( (This)->lpVtbl -> put_TaskUserTextArguments(This,task) ) 

#define IAlertDataCollector_get_TriggerDataCollectorSet(This,name)	\
    ( (This)->lpVtbl -> get_TriggerDataCollectorSet(This,name) ) 

#define IAlertDataCollector_put_TriggerDataCollectorSet(This,name)	\
    ( (This)->lpVtbl -> put_TriggerDataCollectorSet(This,name) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAlertDataCollector_INTERFACE_DEFINED__ */


#ifndef __IApiTracingDataCollector_INTERFACE_DEFINED__
#define __IApiTracingDataCollector_INTERFACE_DEFINED__

/* interface IApiTracingDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IApiTracingDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383751a-098b-11d8-9414-505054503030")
    IApiTracingDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogApiNamesOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logapinames) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogApiNamesOnly( 
            /* [in] */ VARIANT_BOOL logapinames) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogApisRecursively( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logrecursively) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogApisRecursively( 
            /* [in] */ VARIANT_BOOL logrecursively) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *exepath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExePath( 
            /* [in] */ __RPC__in BSTR exepath) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogFilePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *logfilepath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogFilePath( 
            /* [in] */ __RPC__in BSTR logfilepath) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeModules( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includemodules) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeModules( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includemodules) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeApis( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includeapis) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeApis( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includeapis) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExcludeApis( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *excludeapis) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExcludeApis( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * excludeapis) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApiTracingDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IApiTracingDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IApiTracingDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IApiTracingDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogApiNamesOnly )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logapinames);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogApiNamesOnly )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL logapinames);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogApisRecursively )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logrecursively);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogApisRecursively )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL logrecursively);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExePath )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *exepath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExePath )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR exepath);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogFilePath )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *logfilepath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogFilePath )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR logfilepath);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeModules )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includemodules);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeModules )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includemodules);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeApis )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includeapis);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeApis )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includeapis);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExcludeApis )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *excludeapis);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExcludeApis )( 
            __RPC__in IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * excludeapis);
        
        END_INTERFACE
    } IApiTracingDataCollectorVtbl;

    interface IApiTracingDataCollector
    {
        CONST_VTBL struct IApiTracingDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApiTracingDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApiTracingDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApiTracingDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApiTracingDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IApiTracingDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IApiTracingDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IApiTracingDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IApiTracingDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IApiTracingDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IApiTracingDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IApiTracingDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IApiTracingDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IApiTracingDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IApiTracingDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IApiTracingDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IApiTracingDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IApiTracingDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IApiTracingDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IApiTracingDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IApiTracingDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IApiTracingDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IApiTracingDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IApiTracingDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IApiTracingDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IApiTracingDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IApiTracingDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IApiTracingDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IApiTracingDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IApiTracingDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IApiTracingDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IApiTracingDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IApiTracingDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IApiTracingDataCollector_get_LogApiNamesOnly(This,logapinames)	\
    ( (This)->lpVtbl -> get_LogApiNamesOnly(This,logapinames) ) 

#define IApiTracingDataCollector_put_LogApiNamesOnly(This,logapinames)	\
    ( (This)->lpVtbl -> put_LogApiNamesOnly(This,logapinames) ) 

#define IApiTracingDataCollector_get_LogApisRecursively(This,logrecursively)	\
    ( (This)->lpVtbl -> get_LogApisRecursively(This,logrecursively) ) 

#define IApiTracingDataCollector_put_LogApisRecursively(This,logrecursively)	\
    ( (This)->lpVtbl -> put_LogApisRecursively(This,logrecursively) ) 

#define IApiTracingDataCollector_get_ExePath(This,exepath)	\
    ( (This)->lpVtbl -> get_ExePath(This,exepath) ) 

#define IApiTracingDataCollector_put_ExePath(This,exepath)	\
    ( (This)->lpVtbl -> put_ExePath(This,exepath) ) 

#define IApiTracingDataCollector_get_LogFilePath(This,logfilepath)	\
    ( (This)->lpVtbl -> get_LogFilePath(This,logfilepath) ) 

#define IApiTracingDataCollector_put_LogFilePath(This,logfilepath)	\
    ( (This)->lpVtbl -> put_LogFilePath(This,logfilepath) ) 

#define IApiTracingDataCollector_get_IncludeModules(This,includemodules)	\
    ( (This)->lpVtbl -> get_IncludeModules(This,includemodules) ) 

#define IApiTracingDataCollector_put_IncludeModules(This,includemodules)	\
    ( (This)->lpVtbl -> put_IncludeModules(This,includemodules) ) 

#define IApiTracingDataCollector_get_IncludeApis(This,includeapis)	\
    ( (This)->lpVtbl -> get_IncludeApis(This,includeapis) ) 

#define IApiTracingDataCollector_put_IncludeApis(This,includeapis)	\
    ( (This)->lpVtbl -> put_IncludeApis(This,includeapis) ) 

#define IApiTracingDataCollector_get_ExcludeApis(This,excludeapis)	\
    ( (This)->lpVtbl -> get_ExcludeApis(This,excludeapis) ) 

#define IApiTracingDataCollector_put_ExcludeApis(This,excludeapis)	\
    ( (This)->lpVtbl -> put_ExcludeApis(This,excludeapis) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApiTracingDataCollector_INTERFACE_DEFINED__ */


#ifndef __IDataCollectorCollection_INTERFACE_DEFINED__
#define __IDataCollectorCollection_INTERFACE_DEFINED__

/* interface IDataCollectorCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollectorCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837502-098b-11d8-9414-505054503030")
    IDataCollectorCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **collector) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt IDataCollector *collector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT collector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IDataCollectorCollection *collectors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDataCollectorFromXml( 
            /* [in] */ __RPC__in BSTR bstrXml,
            /* [out] */ __RPC__deref_out_opt IValueMap **pValidation,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **pCollector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDataCollector( 
            /* [in] */ DataCollectorType Type,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **Collector) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDataCollectorCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDataCollectorCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDataCollectorCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollectorCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IDataCollectorCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **collector);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IDataCollectorCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IDataCollectorCollection * This,
            __RPC__in_opt IDataCollector *collector);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IDataCollectorCollection * This,
            VARIANT collector);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IDataCollectorCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            __RPC__in IDataCollectorCollection * This,
            __RPC__in_opt IDataCollectorCollection *collectors);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDataCollectorFromXml )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ __RPC__in BSTR bstrXml,
            /* [out] */ __RPC__deref_out_opt IValueMap **pValidation,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **pCollector);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDataCollector )( 
            __RPC__in IDataCollectorCollection * This,
            /* [in] */ DataCollectorType Type,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **Collector);
        
        END_INTERFACE
    } IDataCollectorCollectionVtbl;

    interface IDataCollectorCollection
    {
        CONST_VTBL struct IDataCollectorCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollectorCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollectorCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollectorCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollectorCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollectorCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollectorCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollectorCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollectorCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IDataCollectorCollection_get_Item(This,index,collector)	\
    ( (This)->lpVtbl -> get_Item(This,index,collector) ) 

#define IDataCollectorCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IDataCollectorCollection_Add(This,collector)	\
    ( (This)->lpVtbl -> Add(This,collector) ) 

#define IDataCollectorCollection_Remove(This,collector)	\
    ( (This)->lpVtbl -> Remove(This,collector) ) 

#define IDataCollectorCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IDataCollectorCollection_AddRange(This,collectors)	\
    ( (This)->lpVtbl -> AddRange(This,collectors) ) 

#define IDataCollectorCollection_CreateDataCollectorFromXml(This,bstrXml,pValidation,pCollector)	\
    ( (This)->lpVtbl -> CreateDataCollectorFromXml(This,bstrXml,pValidation,pCollector) ) 

#define IDataCollectorCollection_CreateDataCollector(This,Type,Collector)	\
    ( (This)->lpVtbl -> CreateDataCollector(This,Type,Collector) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollectorCollection_INTERFACE_DEFINED__ */


#ifndef __IDataCollectorSetCollection_INTERFACE_DEFINED__
#define __IDataCollectorSetCollection_INTERFACE_DEFINED__

/* interface IDataCollectorSetCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollectorSetCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837524-098b-11d8-9414-505054503030")
    IDataCollectorSetCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **set) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt IDataCollectorSet *set) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT set) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IDataCollectorSetCollection *sets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataCollectorSets( 
            /* [unique][in] */ __RPC__in_opt BSTR server,
            /* [unique][in] */ __RPC__in_opt BSTR filter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorSetCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDataCollectorSetCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDataCollectorSetCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollectorSetCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **set);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IDataCollectorSetCollection * This,
            __RPC__in_opt IDataCollectorSet *set);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IDataCollectorSetCollection * This,
            VARIANT set);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IDataCollectorSetCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            __RPC__in IDataCollectorSetCollection * This,
            __RPC__in_opt IDataCollectorSetCollection *sets);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataCollectorSets )( 
            __RPC__in IDataCollectorSetCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR server,
            /* [unique][in] */ __RPC__in_opt BSTR filter);
        
        END_INTERFACE
    } IDataCollectorSetCollectionVtbl;

    interface IDataCollectorSetCollection
    {
        CONST_VTBL struct IDataCollectorSetCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollectorSetCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollectorSetCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollectorSetCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollectorSetCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollectorSetCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollectorSetCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollectorSetCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollectorSetCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IDataCollectorSetCollection_get_Item(This,index,set)	\
    ( (This)->lpVtbl -> get_Item(This,index,set) ) 

#define IDataCollectorSetCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IDataCollectorSetCollection_Add(This,set)	\
    ( (This)->lpVtbl -> Add(This,set) ) 

#define IDataCollectorSetCollection_Remove(This,set)	\
    ( (This)->lpVtbl -> Remove(This,set) ) 

#define IDataCollectorSetCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IDataCollectorSetCollection_AddRange(This,sets)	\
    ( (This)->lpVtbl -> AddRange(This,sets) ) 

#define IDataCollectorSetCollection_GetDataCollectorSets(This,server,filter)	\
    ( (This)->lpVtbl -> GetDataCollectorSets(This,server,filter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollectorSetCollection_INTERFACE_DEFINED__ */


#ifndef __ITraceDataProvider_INTERFACE_DEFINED__
#define __ITraceDataProvider_INTERFACE_DEFINED__

/* interface ITraceDataProvider */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_ITraceDataProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837512-098b-11d8-9414-505054503030")
    ITraceDataProvider : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ __RPC__out GUID *guid) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Guid( 
            /* [in] */ GUID guid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Level( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppLevel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeywordsAny( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeywordsAll( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *FilterEnabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterEnabled( 
            /* [in] */ VARIANT_BOOL FilterEnabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterType( 
            /* [retval][out] */ __RPC__out ULONG *pulType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterType( 
            /* [in] */ ULONG ulType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterData( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterData( 
            /* [in] */ __RPC__in SAFEARRAY * pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [unique][in] */ __RPC__in_opt BSTR bstrServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ __RPC__in_opt IDispatch *pFrom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecurity( 
            /* [in] */ __RPC__in BSTR Sddl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurity( 
            /* [in] */ ULONG SecurityInfo,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Sddl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisteredProcesses( 
            /* [out] */ __RPC__deref_out_opt IValueMap **Processes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITraceDataProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITraceDataProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITraceDataProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITraceDataProvider * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITraceDataProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out GUID *guid);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Guid )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ GUID guid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Level )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppLevel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeywordsAny )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeywordsAll )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterEnabled )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *FilterEnabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterEnabled )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ VARIANT_BOOL FilterEnabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterType )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out ULONG *pulType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterType )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ ULONG ulType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterData )( 
            __RPC__in ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterData )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in SAFEARRAY * pData);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [unique][in] */ __RPC__in_opt BSTR bstrServer);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in_opt IDispatch *pFrom);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecurity )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR Sddl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurity )( 
            __RPC__in ITraceDataProvider * This,
            /* [in] */ ULONG SecurityInfo,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Sddl);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredProcesses )( 
            __RPC__in ITraceDataProvider * This,
            /* [out] */ __RPC__deref_out_opt IValueMap **Processes);
        
        END_INTERFACE
    } ITraceDataProviderVtbl;

    interface ITraceDataProvider
    {
        CONST_VTBL struct ITraceDataProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITraceDataProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITraceDataProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITraceDataProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITraceDataProvider_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITraceDataProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITraceDataProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITraceDataProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITraceDataProvider_get_DisplayName(This,name)	\
    ( (This)->lpVtbl -> get_DisplayName(This,name) ) 

#define ITraceDataProvider_put_DisplayName(This,name)	\
    ( (This)->lpVtbl -> put_DisplayName(This,name) ) 

#define ITraceDataProvider_get_Guid(This,guid)	\
    ( (This)->lpVtbl -> get_Guid(This,guid) ) 

#define ITraceDataProvider_put_Guid(This,guid)	\
    ( (This)->lpVtbl -> put_Guid(This,guid) ) 

#define ITraceDataProvider_get_Level(This,ppLevel)	\
    ( (This)->lpVtbl -> get_Level(This,ppLevel) ) 

#define ITraceDataProvider_get_KeywordsAny(This,ppKeywords)	\
    ( (This)->lpVtbl -> get_KeywordsAny(This,ppKeywords) ) 

#define ITraceDataProvider_get_KeywordsAll(This,ppKeywords)	\
    ( (This)->lpVtbl -> get_KeywordsAll(This,ppKeywords) ) 

#define ITraceDataProvider_get_Properties(This,ppProperties)	\
    ( (This)->lpVtbl -> get_Properties(This,ppProperties) ) 

#define ITraceDataProvider_get_FilterEnabled(This,FilterEnabled)	\
    ( (This)->lpVtbl -> get_FilterEnabled(This,FilterEnabled) ) 

#define ITraceDataProvider_put_FilterEnabled(This,FilterEnabled)	\
    ( (This)->lpVtbl -> put_FilterEnabled(This,FilterEnabled) ) 

#define ITraceDataProvider_get_FilterType(This,pulType)	\
    ( (This)->lpVtbl -> get_FilterType(This,pulType) ) 

#define ITraceDataProvider_put_FilterType(This,ulType)	\
    ( (This)->lpVtbl -> put_FilterType(This,ulType) ) 

#define ITraceDataProvider_get_FilterData(This,ppData)	\
    ( (This)->lpVtbl -> get_FilterData(This,ppData) ) 

#define ITraceDataProvider_put_FilterData(This,pData)	\
    ( (This)->lpVtbl -> put_FilterData(This,pData) ) 

#define ITraceDataProvider_Query(This,bstrName,bstrServer)	\
    ( (This)->lpVtbl -> Query(This,bstrName,bstrServer) ) 

#define ITraceDataProvider_Resolve(This,pFrom)	\
    ( (This)->lpVtbl -> Resolve(This,pFrom) ) 

#define ITraceDataProvider_SetSecurity(This,Sddl)	\
    ( (This)->lpVtbl -> SetSecurity(This,Sddl) ) 

#define ITraceDataProvider_GetSecurity(This,SecurityInfo,Sddl)	\
    ( (This)->lpVtbl -> GetSecurity(This,SecurityInfo,Sddl) ) 

#define ITraceDataProvider_GetRegisteredProcesses(This,Processes)	\
    ( (This)->lpVtbl -> GetRegisteredProcesses(This,Processes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataProvider_INTERFACE_DEFINED__ */


#ifndef __ITraceDataProviderCollection_INTERFACE_DEFINED__
#define __ITraceDataProviderCollection_INTERFACE_DEFINED__

/* interface ITraceDataProviderCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ITraceDataProviderCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837510-098b-11d8-9414-505054503030")
    ITraceDataProviderCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **ppProvider) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt ITraceDataProvider *pProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT vProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt ITraceDataProviderCollection *providers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTraceDataProvider( 
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTraceDataProviders( 
            /* [unique][in] */ __RPC__in_opt BSTR server) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTraceDataProvidersByProcess( 
            /* [unique][in] */ __RPC__in_opt BSTR Server,
            /* [in] */ ULONG Pid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITraceDataProviderCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITraceDataProviderCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITraceDataProviderCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITraceDataProviderCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **ppProvider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in ITraceDataProviderCollection * This,
            __RPC__in_opt ITraceDataProvider *pProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in ITraceDataProviderCollection * This,
            VARIANT vProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in ITraceDataProviderCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            __RPC__in ITraceDataProviderCollection * This,
            __RPC__in_opt ITraceDataProviderCollection *providers);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTraceDataProvider )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **Provider);
        
        HRESULT ( STDMETHODCALLTYPE *GetTraceDataProviders )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR server);
        
        HRESULT ( STDMETHODCALLTYPE *GetTraceDataProvidersByProcess )( 
            __RPC__in ITraceDataProviderCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR Server,
            /* [in] */ ULONG Pid);
        
        END_INTERFACE
    } ITraceDataProviderCollectionVtbl;

    interface ITraceDataProviderCollection
    {
        CONST_VTBL struct ITraceDataProviderCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITraceDataProviderCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITraceDataProviderCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITraceDataProviderCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITraceDataProviderCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITraceDataProviderCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITraceDataProviderCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITraceDataProviderCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITraceDataProviderCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define ITraceDataProviderCollection_get_Item(This,index,ppProvider)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppProvider) ) 

#define ITraceDataProviderCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define ITraceDataProviderCollection_Add(This,pProvider)	\
    ( (This)->lpVtbl -> Add(This,pProvider) ) 

#define ITraceDataProviderCollection_Remove(This,vProvider)	\
    ( (This)->lpVtbl -> Remove(This,vProvider) ) 

#define ITraceDataProviderCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ITraceDataProviderCollection_AddRange(This,providers)	\
    ( (This)->lpVtbl -> AddRange(This,providers) ) 

#define ITraceDataProviderCollection_CreateTraceDataProvider(This,Provider)	\
    ( (This)->lpVtbl -> CreateTraceDataProvider(This,Provider) ) 

#define ITraceDataProviderCollection_GetTraceDataProviders(This,server)	\
    ( (This)->lpVtbl -> GetTraceDataProviders(This,server) ) 

#define ITraceDataProviderCollection_GetTraceDataProvidersByProcess(This,Server,Pid)	\
    ( (This)->lpVtbl -> GetTraceDataProvidersByProcess(This,Server,Pid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataProviderCollection_INTERFACE_DEFINED__ */


#ifndef __ISchedule_INTERFACE_DEFINED__
#define __ISchedule_INTERFACE_DEFINED__

/* interface ISchedule */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_ISchedule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383753a-098b-11d8-9414-505054503030")
    ISchedule : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StartDate( 
            /* [retval][out] */ __RPC__out VARIANT *start) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StartDate( 
            /* [in] */ VARIANT start) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EndDate( 
            /* [retval][out] */ __RPC__out VARIANT *end) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EndDate( 
            /* [in] */ VARIANT end) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out VARIANT *start) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ VARIANT start) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Days( 
            /* [retval][out] */ __RPC__out WeekDays *days) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Days( 
            /* [in] */ WeekDays days) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISchedule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISchedule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISchedule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ISchedule * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ISchedule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ISchedule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchedule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartDate )( 
            __RPC__in ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *start);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartDate )( 
            __RPC__in ISchedule * This,
            /* [in] */ VARIANT start);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndDate )( 
            __RPC__in ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *end);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndDate )( 
            __RPC__in ISchedule * This,
            /* [in] */ VARIANT end);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            __RPC__in ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *start);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            __RPC__in ISchedule * This,
            /* [in] */ VARIANT start);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Days )( 
            __RPC__in ISchedule * This,
            /* [retval][out] */ __RPC__out WeekDays *days);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Days )( 
            __RPC__in ISchedule * This,
            /* [in] */ WeekDays days);
        
        END_INTERFACE
    } IScheduleVtbl;

    interface ISchedule
    {
        CONST_VTBL struct IScheduleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchedule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchedule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchedule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchedule_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchedule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchedule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchedule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchedule_get_StartDate(This,start)	\
    ( (This)->lpVtbl -> get_StartDate(This,start) ) 

#define ISchedule_put_StartDate(This,start)	\
    ( (This)->lpVtbl -> put_StartDate(This,start) ) 

#define ISchedule_get_EndDate(This,end)	\
    ( (This)->lpVtbl -> get_EndDate(This,end) ) 

#define ISchedule_put_EndDate(This,end)	\
    ( (This)->lpVtbl -> put_EndDate(This,end) ) 

#define ISchedule_get_StartTime(This,start)	\
    ( (This)->lpVtbl -> get_StartTime(This,start) ) 

#define ISchedule_put_StartTime(This,start)	\
    ( (This)->lpVtbl -> put_StartTime(This,start) ) 

#define ISchedule_get_Days(This,days)	\
    ( (This)->lpVtbl -> get_Days(This,days) ) 

#define ISchedule_put_Days(This,days)	\
    ( (This)->lpVtbl -> put_Days(This,days) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchedule_INTERFACE_DEFINED__ */


#ifndef __IScheduleCollection_INTERFACE_DEFINED__
#define __IScheduleCollection_INTERFACE_DEFINED__

/* interface IScheduleCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IScheduleCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383753d-098b-11d8-9414-505054503030")
    IScheduleCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **ppSchedule) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ienum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt ISchedule *pSchedule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT vSchedule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IScheduleCollection *pSchedules) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSchedule( 
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **Schedule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduleCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IScheduleCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IScheduleCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IScheduleCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IScheduleCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IScheduleCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IScheduleCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IScheduleCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IScheduleCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IScheduleCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **ppSchedule);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IScheduleCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ienum);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IScheduleCollection * This,
            __RPC__in_opt ISchedule *pSchedule);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IScheduleCollection * This,
            VARIANT vSchedule);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IScheduleCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            __RPC__in IScheduleCollection * This,
            __RPC__in_opt IScheduleCollection *pSchedules);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSchedule )( 
            __RPC__in IScheduleCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **Schedule);
        
        END_INTERFACE
    } IScheduleCollectionVtbl;

    interface IScheduleCollection
    {
        CONST_VTBL struct IScheduleCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScheduleCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScheduleCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScheduleCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScheduleCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IScheduleCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IScheduleCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IScheduleCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IScheduleCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IScheduleCollection_get_Item(This,index,ppSchedule)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppSchedule) ) 

#define IScheduleCollection_get__NewEnum(This,ienum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ienum) ) 

#define IScheduleCollection_Add(This,pSchedule)	\
    ( (This)->lpVtbl -> Add(This,pSchedule) ) 

#define IScheduleCollection_Remove(This,vSchedule)	\
    ( (This)->lpVtbl -> Remove(This,vSchedule) ) 

#define IScheduleCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IScheduleCollection_AddRange(This,pSchedules)	\
    ( (This)->lpVtbl -> AddRange(This,pSchedules) ) 

#define IScheduleCollection_CreateSchedule(This,Schedule)	\
    ( (This)->lpVtbl -> CreateSchedule(This,Schedule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScheduleCollection_INTERFACE_DEFINED__ */


#ifndef __IValueMapItem_INTERFACE_DEFINED__
#define __IValueMapItem_INTERFACE_DEFINED__

/* interface IValueMapItem */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IValueMapItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837533-098b-11d8-9414-505054503030")
    IValueMapItem : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR description) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *key) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ __RPC__in BSTR key) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *Value) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ValueMapType( 
            /* [retval][out] */ __RPC__out ValueMapType *type) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ValueMapType( 
            /* [in] */ ValueMapType type) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueMapItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IValueMapItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IValueMapItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IValueMapItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IValueMapItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IValueMapItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ __RPC__in BSTR description);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IValueMapItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            __RPC__in IValueMapItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *key);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ __RPC__in BSTR key);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IValueMapItem * This,
            /* [retval][out] */ __RPC__out VARIANT *Value);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ VARIANT Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValueMapType )( 
            __RPC__in IValueMapItem * This,
            /* [retval][out] */ __RPC__out ValueMapType *type);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ValueMapType )( 
            __RPC__in IValueMapItem * This,
            /* [in] */ ValueMapType type);
        
        END_INTERFACE
    } IValueMapItemVtbl;

    interface IValueMapItem
    {
        CONST_VTBL struct IValueMapItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueMapItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueMapItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueMapItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueMapItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IValueMapItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IValueMapItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IValueMapItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IValueMapItem_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IValueMapItem_put_Description(This,description)	\
    ( (This)->lpVtbl -> put_Description(This,description) ) 

#define IValueMapItem_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define IValueMapItem_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define IValueMapItem_get_Key(This,key)	\
    ( (This)->lpVtbl -> get_Key(This,key) ) 

#define IValueMapItem_put_Key(This,key)	\
    ( (This)->lpVtbl -> put_Key(This,key) ) 

#define IValueMapItem_get_Value(This,Value)	\
    ( (This)->lpVtbl -> get_Value(This,Value) ) 

#define IValueMapItem_put_Value(This,Value)	\
    ( (This)->lpVtbl -> put_Value(This,Value) ) 

#define IValueMapItem_get_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> get_ValueMapType(This,type) ) 

#define IValueMapItem_put_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> put_ValueMapType(This,type) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueMapItem_INTERFACE_DEFINED__ */


#ifndef __IValueMap_INTERFACE_DEFINED__
#define __IValueMap_INTERFACE_DEFINED__

/* interface IValueMap */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IValueMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837534-098b-11d8-9414-505054503030")
    IValueMap : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **value) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR description) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *Value) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ValueMapType( 
            /* [retval][out] */ __RPC__out ValueMapType *type) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ValueMapType( 
            /* [in] */ ValueMapType type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            VARIANT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IValueMap *map) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValueMapItem( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **Item) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IValueMap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IValueMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IValueMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IValueMap * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IValueMap * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IValueMap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IValueMap * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IValueMap * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IValueMap * This,
            /* [in] */ __RPC__in BSTR description);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__out VARIANT *Value);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            __RPC__in IValueMap * This,
            /* [in] */ VARIANT Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValueMapType )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__out ValueMapType *type);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ValueMapType )( 
            __RPC__in IValueMap * This,
            /* [in] */ ValueMapType type);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IValueMap * This,
            VARIANT value);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IValueMap * This,
            VARIANT value);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IValueMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            __RPC__in IValueMap * This,
            __RPC__in_opt IValueMap *map);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValueMapItem )( 
            __RPC__in IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **Item);
        
        END_INTERFACE
    } IValueMapVtbl;

    interface IValueMap
    {
        CONST_VTBL struct IValueMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueMap_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IValueMap_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IValueMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IValueMap_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IValueMap_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IValueMap_get_Item(This,index,value)	\
    ( (This)->lpVtbl -> get_Item(This,index,value) ) 

#define IValueMap_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IValueMap_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IValueMap_put_Description(This,description)	\
    ( (This)->lpVtbl -> put_Description(This,description) ) 

#define IValueMap_get_Value(This,Value)	\
    ( (This)->lpVtbl -> get_Value(This,Value) ) 

#define IValueMap_put_Value(This,Value)	\
    ( (This)->lpVtbl -> put_Value(This,Value) ) 

#define IValueMap_get_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> get_ValueMapType(This,type) ) 

#define IValueMap_put_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> put_ValueMapType(This,type) ) 

#define IValueMap_Add(This,value)	\
    ( (This)->lpVtbl -> Add(This,value) ) 

#define IValueMap_Remove(This,value)	\
    ( (This)->lpVtbl -> Remove(This,value) ) 

#define IValueMap_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IValueMap_AddRange(This,map)	\
    ( (This)->lpVtbl -> AddRange(This,map) ) 

#define IValueMap_CreateValueMapItem(This,Item)	\
    ( (This)->lpVtbl -> CreateValueMapItem(This,Item) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueMap_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837521-098b-11d8-9414-505054503030")
DataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_TraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("0383751c-098b-11d8-9414-505054503030")
TraceSession;
#endif

EXTERN_C const CLSID CLSID_TraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837530-098b-11d8-9414-505054503030")
TraceSessionCollection;
#endif

EXTERN_C const CLSID CLSID_TraceDataProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("03837513-098b-11d8-9414-505054503030")
TraceDataProvider;
#endif

EXTERN_C const CLSID CLSID_TraceDataProviderCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837511-098b-11d8-9414-505054503030")
TraceDataProviderCollection;
#endif

EXTERN_C const CLSID CLSID_DataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837525-098b-11d8-9414-505054503030")
DataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_LegacyDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837526-098b-11d8-9414-505054503030")
LegacyDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_LegacyDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837527-098b-11d8-9414-505054503030")
LegacyDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_LegacyTraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("03837528-098b-11d8-9414-505054503030")
LegacyTraceSession;
#endif

EXTERN_C const CLSID CLSID_LegacyTraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837529-098b-11d8-9414-505054503030")
LegacyTraceSessionCollection;
#endif

EXTERN_C const CLSID CLSID_ServerDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837531-098b-11d8-9414-505054503030")
ServerDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_ServerDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837532-098b-11d8-9414-505054503030")
ServerDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_SystemDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837546-098b-11d8-9414-505054503030")
SystemDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_SystemDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837547-098b-11d8-9414-505054503030")
SystemDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_BootTraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("03837538-098b-11d8-9414-505054503030")
BootTraceSession;
#endif

EXTERN_C const CLSID CLSID_BootTraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837539-098b-11d8-9414-505054503030")
BootTraceSessionCollection;
#endif
#endif /* __PlaLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PortableDeviceConnectApi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for PortableDeviceConnectApi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceConnectApi_h__
#define __PortableDeviceConnectApi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumPortableDeviceConnectors_FWD_DEFINED__
#define __IEnumPortableDeviceConnectors_FWD_DEFINED__
typedef interface IEnumPortableDeviceConnectors IEnumPortableDeviceConnectors;
#endif 	/* __IEnumPortableDeviceConnectors_FWD_DEFINED__ */


#ifndef __IPortableDeviceConnector_FWD_DEFINED__
#define __IPortableDeviceConnector_FWD_DEFINED__
typedef interface IPortableDeviceConnector IPortableDeviceConnector;
#endif 	/* __IPortableDeviceConnector_FWD_DEFINED__ */


#ifndef __IConnectionRequestCallback_FWD_DEFINED__
#define __IConnectionRequestCallback_FWD_DEFINED__
typedef interface IConnectionRequestCallback IConnectionRequestCallback;
#endif 	/* __IConnectionRequestCallback_FWD_DEFINED__ */


#ifndef __EnumBthMtpConnectors_FWD_DEFINED__
#define __EnumBthMtpConnectors_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumBthMtpConnectors EnumBthMtpConnectors;
#else
typedef struct EnumBthMtpConnectors EnumBthMtpConnectors;
#endif /* __cplusplus */

#endif 	/* __EnumBthMtpConnectors_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "propsys.h"
#include "PortableDeviceConnectImports.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceConnectApi_0000_0000 */
/* [local] */ 






// Property set by the MTP Bluetooth Enumerator indicate whether the device is connected
// DEVPKEY_MTPBTH_IsConnected, DEVPROP_TYPE_BOOLEAN
// 
// {ea1237fa-589d-4472-84e4-0abe36fd62ef}.2
DEFINE_DEVPROPKEY(DEVPKEY_MTPBTH_IsConnected,            0xea1237fa, 0x589d, 0x4472, 0x84, 0xe4, 0x0a, 0xbe, 0x36, 0xfd, 0x62, 0xef, 2);



extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceConnectApi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceConnectApi_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumPortableDeviceConnectors_INTERFACE_DEFINED__
#define __IEnumPortableDeviceConnectors_INTERFACE_DEFINED__

/* interface IEnumPortableDeviceConnectors */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumPortableDeviceConnectors;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfdef549-9247-454f-bd82-06fe80853faa")
    IEnumPortableDeviceConnectors : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT32 cRequested,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cRequested, *pcFetched) IPortableDeviceConnector **pConnectors,
            /* [unique][out][in] */ __RPC__inout_opt UINT32 *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT32 cConnectors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceConnectors **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPortableDeviceConnectorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumPortableDeviceConnectors * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumPortableDeviceConnectors * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumPortableDeviceConnectors * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumPortableDeviceConnectors * This,
            /* [in] */ UINT32 cRequested,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cRequested, *pcFetched) IPortableDeviceConnector **pConnectors,
            /* [unique][out][in] */ __RPC__inout_opt UINT32 *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumPortableDeviceConnectors * This,
            /* [in] */ UINT32 cConnectors);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumPortableDeviceConnectors * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumPortableDeviceConnectors * This,
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceConnectors **ppEnum);
        
        END_INTERFACE
    } IEnumPortableDeviceConnectorsVtbl;

    interface IEnumPortableDeviceConnectors
    {
        CONST_VTBL struct IEnumPortableDeviceConnectorsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPortableDeviceConnectors_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPortableDeviceConnectors_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPortableDeviceConnectors_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPortableDeviceConnectors_Next(This,cRequested,pConnectors,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cRequested,pConnectors,pcFetched) ) 

#define IEnumPortableDeviceConnectors_Skip(This,cConnectors)	\
    ( (This)->lpVtbl -> Skip(This,cConnectors) ) 

#define IEnumPortableDeviceConnectors_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPortableDeviceConnectors_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPortableDeviceConnectors_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceConnector_INTERFACE_DEFINED__
#define __IPortableDeviceConnector_INTERFACE_DEFINED__

/* interface IPortableDeviceConnector */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("625e2df8-6392-4cf0-9ad1-3cfa5f17775c")
    IPortableDeviceConnector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( 
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in const DEVPROPKEY *pPropertyKey,
            /* [out] */ __RPC__out DEVPROPTYPE *pPropertyType,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppData,
            /* [out] */ __RPC__out UINT32 *pcbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ __RPC__in const DEVPROPKEY *pPropertyKey,
            /* [in] */ DEVPROPTYPE PropertyType,
            /* [size_is][in] */ __RPC__in_ecount_full(cbData) const BYTE *pData,
            /* [in] */ UINT32 cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPID( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszPnPID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPortableDeviceConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPortableDeviceConnector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in_opt IConnectionRequestCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in const DEVPROPKEY *pPropertyKey,
            /* [out] */ __RPC__out DEVPROPTYPE *pPropertyType,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppData,
            /* [out] */ __RPC__out UINT32 *pcbData);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [in] */ __RPC__in const DEVPROPKEY *pPropertyKey,
            /* [in] */ DEVPROPTYPE PropertyType,
            /* [size_is][in] */ __RPC__in_ecount_full(cbData) const BYTE *pData,
            /* [in] */ UINT32 cbData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPnPID )( 
            __RPC__in IPortableDeviceConnector * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszPnPID);
        
        END_INTERFACE
    } IPortableDeviceConnectorVtbl;

    interface IPortableDeviceConnector
    {
        CONST_VTBL struct IPortableDeviceConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceConnector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceConnector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceConnector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceConnector_Connect(This,pCallback)	\
    ( (This)->lpVtbl -> Connect(This,pCallback) ) 

#define IPortableDeviceConnector_Disconnect(This,pCallback)	\
    ( (This)->lpVtbl -> Disconnect(This,pCallback) ) 

#define IPortableDeviceConnector_Cancel(This,pCallback)	\
    ( (This)->lpVtbl -> Cancel(This,pCallback) ) 

#define IPortableDeviceConnector_GetProperty(This,pPropertyKey,pPropertyType,ppData,pcbData)	\
    ( (This)->lpVtbl -> GetProperty(This,pPropertyKey,pPropertyType,ppData,pcbData) ) 

#define IPortableDeviceConnector_SetProperty(This,pPropertyKey,PropertyType,pData,cbData)	\
    ( (This)->lpVtbl -> SetProperty(This,pPropertyKey,PropertyType,pData,cbData) ) 

#define IPortableDeviceConnector_GetPnPID(This,ppwszPnPID)	\
    ( (This)->lpVtbl -> GetPnPID(This,ppwszPnPID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceConnector_INTERFACE_DEFINED__ */


#ifndef __IConnectionRequestCallback_INTERFACE_DEFINED__
#define __IConnectionRequestCallback_INTERFACE_DEFINED__

/* interface IConnectionRequestCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConnectionRequestCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("272c9ae0-7161-4ae0-91bd-9f448ee9c427")
    IConnectionRequestCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnComplete( 
            /* [in] */ HRESULT hrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectionRequestCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IConnectionRequestCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IConnectionRequestCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IConnectionRequestCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnComplete )( 
            __RPC__in IConnectionRequestCallback * This,
            /* [in] */ HRESULT hrStatus);
        
        END_INTERFACE
    } IConnectionRequestCallbackVtbl;

    interface IConnectionRequestCallback
    {
        CONST_VTBL struct IConnectionRequestCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectionRequestCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConnectionRequestCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConnectionRequestCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConnectionRequestCallback_OnComplete(This,hrStatus)	\
    ( (This)->lpVtbl -> OnComplete(This,hrStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConnectionRequestCallback_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceConnectApiLib_LIBRARY_DEFINED__
#define __PortableDeviceConnectApiLib_LIBRARY_DEFINED__

/* library PortableDeviceConnectApiLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceConnectApiLib;

EXTERN_C const CLSID CLSID_EnumBthMtpConnectors;

#ifdef __cplusplus

class DECLSPEC_UUID("a1570149-e645-4f43-8b0d-409b061db2fc")
EnumBthMtpConnectors;
#endif
#endif /* __PortableDeviceConnectApiLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2006.
//
//  File:       propapi.h
//
//  Contents:   Structured storage properties APIs
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef VOID* NTPROP;

#include <propidl.h>

EXTERN_C
__success(TRUE)  /* Raises status on failure */
ULONG __stdcall
StgPropertyLengthAsVariant(
            __in_bcount(cbProp) const SERIALIZEDPROPERTYVALUE* pProp,
            __in ULONG cbProp,
            __in USHORT CodePage,
            __in __reserved BYTE bReserved);


#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\propkeydef.h ===
#ifndef PID_FIRST_USABLE
#define PID_FIRST_USABLE 2
#endif

#ifndef REFPROPERTYKEY
#ifdef __cplusplus
#define REFPROPERTYKEY const PROPERTYKEY &
#else // !__cplusplus
#define REFPROPERTYKEY const PROPERTYKEY * __MIDL_CONST
#endif // __cplusplus
#endif //REFPROPERTYKEY

#ifdef DEFINE_PROPERTYKEY
#undef DEFINE_PROPERTYKEY
#endif

#ifdef INITGUID
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
#endif // INITGUID

#ifndef IsEqualPropertyKey
#define IsEqualPropertyKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#endif  // IsEqualPropertyKey

#ifndef _PROPERTYKEY_EQUALITY_OPERATORS_
#define _PROPERTYKEY_EQUALITY_OPERATORS_
#ifdef __cplusplus
extern "C++"
{
__inline int operator == (REFPROPERTYKEY pkeyOne, REFPROPERTYKEY pkeyOther) { return IsEqualPropertyKey(pkeyOne, pkeyOther); }
__inline int operator != (REFPROPERTYKEY pkeyOne, REFPROPERTYKEY pkeyOther) { return !(pkeyOne == pkeyOther); }
}
#endif // __cplusplus
#endif // _PROPERTYKEY_EQUALITY_OPERATORS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PortableDeviceTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for PortableDeviceTypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceTypes_h__
#define __PortableDeviceTypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWpdSerializer_FWD_DEFINED__
#define __IWpdSerializer_FWD_DEFINED__
typedef interface IWpdSerializer IWpdSerializer;
#endif 	/* __IWpdSerializer_FWD_DEFINED__ */


#ifndef __IPortableDeviceValues_FWD_DEFINED__
#define __IPortableDeviceValues_FWD_DEFINED__
typedef interface IPortableDeviceValues IPortableDeviceValues;
#endif 	/* __IPortableDeviceValues_FWD_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_FWD_DEFINED__
#define __IPortableDeviceKeyCollection_FWD_DEFINED__
typedef interface IPortableDeviceKeyCollection IPortableDeviceKeyCollection;
#endif 	/* __IPortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_FWD_DEFINED__
#define __IPortableDevicePropVariantCollection_FWD_DEFINED__
typedef interface IPortableDevicePropVariantCollection IPortableDevicePropVariantCollection;
#endif 	/* __IPortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_FWD_DEFINED__
#define __IPortableDeviceValuesCollection_FWD_DEFINED__
typedef interface IPortableDeviceValuesCollection IPortableDeviceValuesCollection;
#endif 	/* __IPortableDeviceValuesCollection_FWD_DEFINED__ */


#ifndef __WpdSerializer_FWD_DEFINED__
#define __WpdSerializer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WpdSerializer WpdSerializer;
#else
typedef struct WpdSerializer WpdSerializer;
#endif /* __cplusplus */

#endif 	/* __WpdSerializer_FWD_DEFINED__ */


#ifndef __PortableDeviceValues_FWD_DEFINED__
#define __PortableDeviceValues_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValues PortableDeviceValues;
#else
typedef struct PortableDeviceValues PortableDeviceValues;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValues_FWD_DEFINED__ */


#ifndef __PortableDeviceKeyCollection_FWD_DEFINED__
#define __PortableDeviceKeyCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceKeyCollection PortableDeviceKeyCollection;
#else
typedef struct PortableDeviceKeyCollection PortableDeviceKeyCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __PortableDevicePropVariantCollection_FWD_DEFINED__
#define __PortableDevicePropVariantCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#else
typedef struct PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __PortableDeviceValuesCollection_FWD_DEFINED__
#define __PortableDeviceValuesCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValuesCollection PortableDeviceValuesCollection;
#else
typedef struct PortableDeviceValuesCollection PortableDeviceValuesCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValuesCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceTypes_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0501) // XP and later







extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_s_ifspec;

#ifndef __IWpdSerializer_INTERFACE_DEFINED__
#define __IWpdSerializer_INTERFACE_DEFINED__

/* interface IWpdSerializer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWpdSerializer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b32f4002-bb27-45ff-af4f-06631c1e8dad")
    IWpdSerializer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesFromBuffer( 
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteIPortableDeviceValuesToBuffer( 
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferFromIPortableDeviceValues( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerializedSize( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWpdSerializerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWpdSerializer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWpdSerializer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWpdSerializer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesFromBuffer )( 
            __RPC__in IWpdSerializer * This,
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams);
        
        HRESULT ( STDMETHODCALLTYPE *WriteIPortableDeviceValuesToBuffer )( 
            __RPC__in IWpdSerializer * This,
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferFromIPortableDeviceValues )( 
            __RPC__in IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedSize )( 
            __RPC__in IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        END_INTERFACE
    } IWpdSerializerVtbl;

    interface IWpdSerializer
    {
        CONST_VTBL struct IWpdSerializerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWpdSerializer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWpdSerializer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWpdSerializer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWpdSerializer_GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams) ) 

#define IWpdSerializer_WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten)	\
    ( (This)->lpVtbl -> WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten) ) 

#define IWpdSerializer_GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize)	\
    ( (This)->lpVtbl -> GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize) ) 

#define IWpdSerializer_GetSerializedSize(This,pSource,pdwSize)	\
    ( (This)->lpVtbl -> GetSerializedSize(This,pSource,pdwSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWpdSerializer_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValues_INTERFACE_DEFINED__
#define __IPortableDeviceValues_INTERFACE_DEFINED__

/* interface IPortableDeviceValues */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValues;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6848f6f2-3155-4f86-b6f5-263eeeab3143")
    IPortableDeviceValues : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesFromPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesToPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPortableDeviceValues * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPortableDeviceValues * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in DWORD *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedLargeIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedLargeIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedLargeIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedLargeIntegerValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetFloatValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetFloatValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeyValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBoolValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoolValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIUnknownValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUnknownValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGuidValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDevicePropVariantCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDevicePropVariantCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceKeyCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceKeyCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesCollectionValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesFromPropertyStore )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesToPropertyStore )( 
            __RPC__in IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IPortableDeviceValues * This);
        
        END_INTERFACE
    } IPortableDeviceValuesVtbl;

    interface IPortableDeviceValues
    {
        CONST_VTBL struct IPortableDeviceValuesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValues_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValues_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValues_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValues_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#define IPortableDeviceValues_GetAt(This,index,pKey,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,index,pKey,pValue) ) 

#define IPortableDeviceValues_SetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetStringValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetStringValue(This,key,Value) ) 

#define IPortableDeviceValues_GetStringValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetStringValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetFloatValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetFloatValue(This,key,Value) ) 

#define IPortableDeviceValues_GetFloatValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetFloatValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetErrorValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetErrorValue(This,key,Value) ) 

#define IPortableDeviceValues_GetErrorValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetErrorValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetKeyValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetKeyValue(This,key,Value) ) 

#define IPortableDeviceValues_GetKeyValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetKeyValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBoolValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetBoolValue(This,key,Value) ) 

#define IPortableDeviceValues_GetBoolValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetBoolValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetIUnknownValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIUnknownValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIUnknownValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIUnknownValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetGuidValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetGuidValue(This,key,Value) ) 

#define IPortableDeviceValues_GetGuidValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetGuidValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBufferValue(This,key,pValue,cbValue)	\
    ( (This)->lpVtbl -> SetBufferValue(This,key,pValue,cbValue) ) 

#define IPortableDeviceValues_GetBufferValue(This,key,ppValue,pcbValue)	\
    ( (This)->lpVtbl -> GetBufferValue(This,key,ppValue,pcbValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDevicePropVariantCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDevicePropVariantCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDevicePropVariantCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDevicePropVariantCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceKeyCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceKeyCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceKeyCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceKeyCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_RemoveValue(This,key)	\
    ( (This)->lpVtbl -> RemoveValue(This,key) ) 

#define IPortableDeviceValues_CopyValuesFromPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesFromPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_CopyValuesToPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesToPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValues_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_INTERFACE_DEFINED__
#define __IPortableDeviceKeyCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceKeyCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceKeyCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dada2357-e0ad-492e-98db-dd61c53ba353")
    IPortableDeviceKeyCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in REFPROPERTYKEY Key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceKeyCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPortableDeviceKeyCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFPROPERTYKEY Key);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceKeyCollectionVtbl;

    interface IPortableDeviceKeyCollection
    {
        CONST_VTBL struct IPortableDeviceKeyCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceKeyCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceKeyCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceKeyCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceKeyCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceKeyCollection_GetAt(This,dwIndex,pKey)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pKey) ) 

#define IPortableDeviceKeyCollection_Add(This,Key)	\
    ( (This)->lpVtbl -> Add(This,Key) ) 

#define IPortableDeviceKeyCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceKeyCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceKeyCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__
#define __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__

/* interface IPortableDevicePropVariantCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevicePropVariantCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89b2e422-4f1b-4316-bcef-a44afea83eb3")
    IPortableDevicePropVariantCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out VARTYPE *pvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [in] */ const VARTYPE vt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropVariantCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPortableDevicePropVariantCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [out] */ __RPC__out VARTYPE *pvt);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeType )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ const VARTYPE vt);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDevicePropVariantCollectionVtbl;

    interface IPortableDevicePropVariantCollection
    {
        CONST_VTBL struct IPortableDevicePropVariantCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevicePropVariantCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevicePropVariantCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevicePropVariantCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevicePropVariantCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDevicePropVariantCollection_GetAt(This,dwIndex,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pValue) ) 

#define IPortableDevicePropVariantCollection_Add(This,pValue)	\
    ( (This)->lpVtbl -> Add(This,pValue) ) 

#define IPortableDevicePropVariantCollection_GetType(This,pvt)	\
    ( (This)->lpVtbl -> GetType(This,pvt) ) 

#define IPortableDevicePropVariantCollection_ChangeType(This,vt)	\
    ( (This)->lpVtbl -> ChangeType(This,vt) ) 

#define IPortableDevicePropVariantCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDevicePropVariantCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_INTERFACE_DEFINED__
#define __IPortableDeviceValuesCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceValuesCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValuesCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e3f2d79-4e07-48c4-8208-d8c2e5af4a99")
    IPortableDeviceValuesCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPortableDeviceValuesCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceValuesCollectionVtbl;

    interface IPortableDeviceValuesCollection
    {
        CONST_VTBL struct IPortableDeviceValuesCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValuesCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValuesCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValuesCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValuesCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceValuesCollection_GetAt(This,dwIndex,ppValues)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,ppValues) ) 

#define IPortableDeviceValuesCollection_Add(This,pValues)	\
    ( (This)->lpVtbl -> Add(This,pValues) ) 

#define IPortableDeviceValuesCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceValuesCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValuesCollection_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceTypesLib_LIBRARY_DEFINED__
#define __PortableDeviceTypesLib_LIBRARY_DEFINED__

/* library PortableDeviceTypesLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceTypesLib;

EXTERN_C const CLSID CLSID_WpdSerializer;

#ifdef __cplusplus

class DECLSPEC_UUID("0b91a74b-ad7c-4a9d-b563-29eef9167172")
WpdSerializer;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValues;

#ifdef __cplusplus

class DECLSPEC_UUID("0c15d503-d017-47ce-9016-7b3f978721cc")
PortableDeviceValues;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceKeyCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("de2d022d-2480-43be-97f0-d1fa2cf98f4f")
PortableDeviceKeyCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDevicePropVariantCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("08a99e2f-6d6d-4b80-af5a-baf2bcbe4cb9")
PortableDevicePropVariantCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValuesCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("3882134d-14cf-4220-9cb4-435f86d83f60")
PortableDeviceValuesCollection;
#endif
#endif /* __PortableDeviceTypesLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_PortableDeviceTypes_0000_0005 */
/* [local] */ 

#endif // (_WIN32_WINNT >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\prntvpt.h ===
/*++

Copyright (c) 1996-2004 Microsoft Corporation

Module Name:

    prnptntv.h

Abstract:

    Print ticket APIs for Win32 applications

--*/

#ifndef _PRNPTNTV_H_
#define _PRNPTNTV_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

DECLARE_HANDLE(HPTPROVIDER);

#define PRINTTICKET_ISTREAM_APIS 1

#define S_PT_NO_CONFLICT                 (0x00040001)
#define S_PT_CONFLICT_RESOLVED           (0x00040002)

/*
    PrintTicket stream provided by the caller did not
    follow PrintTicket framework specification or the XML
    could not be parsed.  If returned by 
    PTMergeAndValidatePrintTicket, it indicates that the 
    base ticket contained the error.
*/
#define E_PRINTTICKET_FORMAT             (0x80040003)

/*
    PrintCapabilities document generated by the driver
    did not follow the specification.  This indicates an
    error in the driver.
*/
#define E_PRINTCAPABILITIES_FORMAT       (0x80040004)

/*
    The delta print ticket parameter passed to 
    PTMergeAndValidatePrintTicket did not
    follow PrintTicket framework specification or
    the XML could not be parsed.
*/
#define E_DELTA_PRINTTICKET_FORMAT       (0x80040005)

typedef enum tagEDefaultDevmodeType
{
    kUserDefaultDevmode,
    kPrinterDefaultDevmode
} EDefaultDevmodeType;

typedef enum 
{
    kPTPageScope,
    kPTDocumentScope,
    kPTJobScope
} EPrintTicketScope;


HRESULT WINAPI
PTQuerySchemaVersionSupport(
            __in        PCWSTR       pszPrinterName,
            __out       DWORD       *pMaxVersion
            );

HRESULT WINAPI
PTOpenProvider( 
            __in        PCWSTR       pszPrinterName,
                        DWORD        dwVersion,
            __out       HPTPROVIDER *phProvider
            );

HRESULT WINAPI
PTOpenProviderEx( 
            __in  PCWSTR       pszPrinterName,
                  DWORD        dwMaxVersion,
                  DWORD        dwPrefVersion,
            __out HPTPROVIDER *phProvider,
            __out DWORD       *pUsedVersion
            );

HRESULT WINAPI
PTCloseProvider(
            __in  HPTPROVIDER hProvider
            );

HRESULT WINAPI
PTReleaseMemory(
    __in PVOID pBuffer
    );
    
HRESULT WINAPI
PTGetPrintCapabilities( 
            __in            HPTPROVIDER         hProvider,
            __in_opt        IStream            *pPrintTicket,
            __inout         IStream            *pCapabilities,
            __out_opt       BSTR               *pbstrErrorMessage
            );
        
HRESULT WINAPI
PTMergeAndValidatePrintTicket(
            __in            HPTPROVIDER        hProvider,
            __in            IStream           *pBaseTicket,
            __in_opt        IStream           *pDeltaTicket,
            __in            EPrintTicketScope  scope,
            __inout         IStream           *pResultTicket, 
            __out_opt       BSTR              *pbstrErrorMessage 
            );

HRESULT WINAPI
PTConvertPrintTicketToDevMode( 
            __in                     HPTPROVIDER          hProvider,
            __in                     IStream             *pPrintTicket,
                                     EDefaultDevmodeType  baseDevmodeType,
            __in                     EPrintTicketScope  scope,
            __out                    ULONG               *pcbDevmode,
            __deref_out_bcount(*pcbDevmode) OUT PDEVMODE *ppDevmode,
            __out_opt                BSTR                *pbstrErrorMessage 
            );
        
HRESULT WINAPI
PTConvertDevModeToPrintTicket( 
            __in        HPTPROVIDER        hProvider,
                        ULONG              cbDevmode,
            __in        PDEVMODE           pDevmode,
            __in        EPrintTicketScope  scope,
            __inout     IStream           *pPrintTicket
            );
        
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _PRNPTNTV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\powrprof.h ===
/*****************************************************************************\
*                                                                             *
* powrprof.h - - Interface for powrprof.dll, the power policy applicator      *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Registry storage structures for the GLOBAL_POWER_POLICY data. There are two
// structures, GLOBAL_MACHINE_POWER_POLICY and GLOBAL_USER_POWER_POLICY. the
// GLOBAL_MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// GLOBAL_USER_POWER_POLICY stores the per user data.

typedef struct _GLOBAL_MACHINE_POWER_POLICY{
    ULONG                   Revision;
    SYSTEM_POWER_STATE      LidOpenWakeAc;
    SYSTEM_POWER_STATE      LidOpenWakeDc;
    ULONG                   BroadcastCapacityResolution;
} GLOBAL_MACHINE_POWER_POLICY, *PGLOBAL_MACHINE_POWER_POLICY;

typedef struct _GLOBAL_USER_POWER_POLICY{
    ULONG                   Revision;
    POWER_ACTION_POLICY     PowerButtonAc;
    POWER_ACTION_POLICY     PowerButtonDc;
    POWER_ACTION_POLICY     SleepButtonAc;
    POWER_ACTION_POLICY     SleepButtonDc;
    POWER_ACTION_POLICY     LidCloseAc;
    POWER_ACTION_POLICY     LidCloseDc;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];
    ULONG                   GlobalFlags;
} GLOBAL_USER_POWER_POLICY, *PGLOBAL_USER_POWER_POLICY;

// Structure to manage global power policies at the user level. This structure
// contains data which is common across all power policy profiles.

typedef struct _GLOBAL_POWER_POLICY{
    GLOBAL_USER_POWER_POLICY    user;
    GLOBAL_MACHINE_POWER_POLICY mach;
} GLOBAL_POWER_POLICY, *PGLOBAL_POWER_POLICY;

// Registry storage structures for the POWER_POLICY data. There are three
// structures, MACHINE_POWER_POLICY, MACHINE_PROCESSOR_POWER_POLICY and
// USER_POWER_POLICY. the MACHINE_POWER_POLICY stores per machine data for 
// which there is no UI.  USER_POWER_POLICY stores the per user data.

typedef struct _MACHINE_POWER_POLICY{
    ULONG                   Revision;       // 1

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleepAc;
    SYSTEM_POWER_STATE      MinSleepDc;
    SYSTEM_POWER_STATE      ReducedLatencySleepAc;
    SYSTEM_POWER_STATE      ReducedLatencySleepDc;

    // parameters for dozing
    ULONG                   DozeTimeoutAc;
    ULONG                   DozeTimeoutDc;
    ULONG                   DozeS4TimeoutAc;
    ULONG                   DozeS4TimeoutDc;

    // processor policies
    UCHAR                   MinThrottleAc;
    UCHAR                   MinThrottleDc;
    UCHAR                   pad1[2];
    POWER_ACTION_POLICY     OverThrottledAc;
    POWER_ACTION_POLICY     OverThrottledDc;

} MACHINE_POWER_POLICY, *PMACHINE_POWER_POLICY;

//
// deprecated
//

typedef struct _MACHINE_PROCESSOR_POWER_POLICY {
    ULONG                   Revision;       // 1
    
    PROCESSOR_POWER_POLICY  ProcessorPolicyAc;    
    PROCESSOR_POWER_POLICY  ProcessorPolicyDc;    

} MACHINE_PROCESSOR_POWER_POLICY, *PMACHINE_PROCESSOR_POWER_POLICY;

typedef struct _USER_POWER_POLICY {
    ULONG                   Revision;       // 1

    // "system idle" detection
    POWER_ACTION_POLICY     IdleAc;
    POWER_ACTION_POLICY     IdleDc;
    ULONG                   IdleTimeoutAc;
    ULONG                   IdleTimeoutDc;
    UCHAR                   IdleSensitivityAc;
    UCHAR                   IdleSensitivityDc;
    
    // Throttling Policy
    UCHAR                   ThrottlePolicyAc;
    UCHAR                   ThrottlePolicyDc;

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MaxSleepAc;
    SYSTEM_POWER_STATE      MaxSleepDc;

    // For future use
    ULONG                   Reserved[2];

    // video policies
    ULONG                   VideoTimeoutAc;
    ULONG                   VideoTimeoutDc;

    // hard disk policies
    ULONG                   SpindownTimeoutAc;
    ULONG                   SpindownTimeoutDc;

    // processor policies
    BOOLEAN                 OptimizeForPowerAc;
    BOOLEAN                 OptimizeForPowerDc;
    UCHAR                   FanThrottleToleranceAc;
    UCHAR                   FanThrottleToleranceDc;
    UCHAR                   ForcedThrottleAc;
    UCHAR                   ForcedThrottleDc;
    
} USER_POWER_POLICY, *PUSER_POWER_POLICY;

// Structure to manage power policies at the user level. This structure
// contains data which is unique across power policy profiles.

typedef struct _POWER_POLICY {
    USER_POWER_POLICY       user;
    MACHINE_POWER_POLICY    mach;
} POWER_POLICY, *PPOWER_POLICY;

// Constants for GlobalFlags

#define EnableSysTrayBatteryMeter   0x01
#define EnableMultiBatteryDisplay   0x02
#define EnablePasswordLogon         0x04
#define EnableWakeOnRing            0x08
#define EnableVideoDimDisplay       0x10

//
// Power setting attribute flags
//

#define POWER_ATTRIBUTE_HIDE        0x00000001

// This constant is passed as a uiID to WritePwrScheme.
#define NEWSCHEME (UINT)-1

// Prototype for EnumPwrSchemes callback proceedures.

typedef
BOOLEAN
CALLBACK
PWRSCHEMESENUMPROC_V1 (
    __in UINT Index,
    __in DWORD NameSize,
    __in_bcount(NameSize) LPTSTR Name,
    __in DWORD DescriptionSize,
    __in_bcount(DescriptionSize) LPTSTR Description,
    __in PPOWER_POLICY Policy,
    __inout_opt LPARAM Context
    );

typedef
BOOLEAN
CALLBACK
PWRSCHEMESENUMPROC_V2 (
    __in UINT Index,
    __in DWORD NameSize,
    __in_bcount(NameSize) LPWSTR Name,
    __in DWORD DescriptionSize,
    __in_bcount(DescriptionSize) LPWSTR Description,
    __in PPOWER_POLICY Policy,
    __inout_opt LPARAM Context
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef PWRSCHEMESENUMPROC_V2 *PWRSCHEMESENUMPROC;

#else

typedef PWRSCHEMESENUMPROC_V1 *PWRSCHEMESENUMPROC;

#endif

// Public function prototypes

STDAPI_(BOOLEAN)
GetPwrDiskSpindownRange(
    __out PUINT puiMax,
    __out PUINT puiMin
    );   

STDAPI_(BOOLEAN)
EnumPwrSchemes(
    __in PWRSCHEMESENUMPROC lpfn,
    __in LPARAM lParam
    );

STDAPI_(BOOLEAN)
ReadGlobalPwrPolicy(
    __in PGLOBAL_POWER_POLICY pGlobalPowerPolicy
    );
        
STDAPI_(BOOLEAN)
ReadPwrScheme(
    __in UINT uiID,
    __out PPOWER_POLICY pPowerPolicy
    );
    
STDAPI_(BOOLEAN)
WritePwrScheme(
    __in PUINT puiID,
    __in LPCWSTR lpszSchemeName,
    __in_opt LPCWSTR lpszDescription,
    __in PPOWER_POLICY lpScheme
    );

STDAPI_(BOOLEAN)
WriteGlobalPwrPolicy(
        __in PGLOBAL_POWER_POLICY pGlobalPowerPolicy
    );
        
STDAPI_(BOOLEAN)
DeletePwrScheme(
        __in UINT uiID
        );
        
STDAPI_(BOOLEAN)
GetActivePwrScheme(
        __out PUINT puiID
    );
        
STDAPI_(BOOLEAN)
SetActivePwrScheme(
    __in UINT uiID,
    __in_opt PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __in_opt PPOWER_POLICY pPowerPolicy
    );
    
STDAPI_(BOOLEAN)
GetPwrCapabilities(
        __out PSYSTEM_POWER_CAPABILITIES lpspc
    );

STDAPI_(BOOLEAN)
IsPwrSuspendAllowed(
        VOID
        );

STDAPI_(BOOLEAN)
IsPwrHibernateAllowed(
        VOID
        );
        
STDAPI_(BOOLEAN)
IsPwrShutdownAllowed(
        VOID
        );

STDAPI_(BOOLEAN)
IsAdminOverrideActive(
    __in PADMINISTRATOR_POWER_POLICY papp
    );
    
STDAPI_(BOOLEAN)
SetSuspendState(
    __in BOOLEAN bHibernate,
    __in BOOLEAN bForce,
    __in BOOLEAN bWakeupEventsDisabled
    );
    
STDAPI_(BOOLEAN)
GetCurrentPowerPolicies(
    __out PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __out PPOWER_POLICY pPowerPolicy
    );

STDAPI_(BOOLEAN)
CanUserWritePwrScheme(
        VOID
        );

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
// deprecated.
//
STDAPI_(BOOLEAN)
ReadProcessorPwrScheme(
    __in UINT uiID,
    __out PMACHINE_PROCESSOR_POWER_POLICY pMachineProcessorPowerPolicy
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
// deprecated.
//    
STDAPI_(BOOLEAN)
WriteProcessorPwrScheme(
    __in UINT uiID,
    __in PMACHINE_PROCESSOR_POWER_POLICY pMachineProcessorPowerPolicy
    );
#endif

STDAPI_(BOOLEAN)
ValidatePowerPolicies(
    __inout_opt PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __inout_opt PPOWER_POLICY pPowerPolicy
    );
    
#ifndef NT_SUCCESS
#define NTSTATUS LONG
#define _OVERRIDE_NTSTATUS_
#endif

NTSTATUS
WINAPI
CallNtPowerInformation (
    __in POWER_INFORMATION_LEVEL InformationLevel,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );

#ifdef _OVERRIDE_NTSTATUS_
#undef NTSTATUS
#endif

//
// Enum which defines which field inside of a
// power setting is being accessed.
//
typedef enum _POWER_DATA_ACCESSOR {
        
        //
        // Used by read/write and enumeration engines
        //
        ACCESS_AC_POWER_SETTING_INDEX = 0,
        ACCESS_DC_POWER_SETTING_INDEX,
        ACCESS_FRIENDLY_NAME,
        ACCESS_DESCRIPTION,
        ACCESS_POSSIBLE_POWER_SETTING,
        ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME,
        ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION,
        ACCESS_DEFAULT_AC_POWER_SETTING,
        ACCESS_DEFAULT_DC_POWER_SETTING,
        ACCESS_POSSIBLE_VALUE_MIN,
        ACCESS_POSSIBLE_VALUE_MAX,
        ACCESS_POSSIBLE_VALUE_INCREMENT,
        ACCESS_POSSIBLE_VALUE_UNITS,
        ACCESS_ICON_RESOURCE,
        ACCESS_DEFAULT_SECURITY_DESCRIPTOR,
        ACCESS_ATTRIBUTES,
        
        //
        // Used by enumeration engine.
        //
        ACCESS_SCHEME,
        ACCESS_SUBGROUP,
        ACCESS_INDIVIDUAL_SETTING,
        
        //
        // Used by access check
        //
        ACCESS_ACTIVE_SCHEME,
        ACCESS_CREATE_SCHEME,

        //
        // Used by override ranges.
        //

        ACCESS_AC_POWER_SETTING_MAX,
        ACCESS_DC_POWER_SETTING_MAX,
        ACCESS_AC_POWER_SETTING_MIN,
        ACCESS_DC_POWER_SETTING_MIN
        
} POWER_DATA_ACCESSOR, *PPOWER_DATA_ACCESSOR;

//
// =========================================
// Power Scheme APIs
// =========================================
//

#if !defined(_HPOWERNOTIFY_DEF_)

#define _HPOWERNOTIFY_DEF_

typedef  PVOID           HPOWERNOTIFY;
typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
DWORD
PowerSettingRegisterNotification (
    __in LPCGUID SettingGuid,
    __in DWORD Flags,
    __in HANDLE Recipient,
    __out PHPOWERNOTIFY RegistrationHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
DWORD
PowerSettingUnregisterNotification (
    __inout HPOWERNOTIFY RegistrationHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerSettingAccessCheck (
    __in POWER_DATA_ACCESSOR AccessFlags,
    __in_opt CONST GUID *PowerGuid
    );
#endif

//
// Read functions.
//
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadACValueIndex (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD AcValueIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadDCValueIndex (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD DcValueIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadACValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __out_bcount_opt(*BufferSize) LPBYTE Buffer,
    __inout_opt LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadDCValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadPossibleValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadPossibleFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadPossibleDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadValueMin (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueMinimum
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadValueMax (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueMaximum
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadValueIncrement (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueIncrement
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadValueUnitsSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) UCHAR *Buffer,
    __inout LPDWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadACDefaultIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid OPTIONAL,
    __in CONST GUID *PowerSettingGuid,
    __out LPDWORD AcDefaultIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadDCDefaultIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __out LPDWORD DcDefaultIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadIconResourceSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
#endif
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReadSettingAttributes (
    __in_opt CONST GUID *SubGroupGuid,
    __in_opt CONST GUID *PowerSettingGuid
    );
#endif

//
// Write functions.
//
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteACValueIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD AcValueIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteDCValueIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD DcValueIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteDescription (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWritePossibleValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG Type,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWritePossibleFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWritePossibleDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteValueMin (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueMinimum
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteValueMax (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueMaximum
    );
#endif
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteValueIncrement (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueIncrement
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteValueUnitsSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteACDefaultIndex (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in DWORD DefaultAcIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteDCDefaultIndex (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in DWORD DefaultDcIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteIconResourceSpecifier (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
#endif
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerWriteSettingAttributes (
    __in_opt CONST GUID *SubGroupGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD Attributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerDuplicateScheme (
    __in_opt HKEY RootPowerKey,
    __in const GUID *SourceSchemeGuid,
    __deref_inout GUID **DestinationSchemeGuid
    );
#endif
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerImportPowerScheme (
    __in_opt HKEY RootPowerKey,
    __in LPCWSTR ImportFileNamePath,
    __deref_inout GUID **DestinationSchemeGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerDeleteScheme (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerRemovePowerSetting (
   __in CONST GUID *PowerSettingSubKeyGuid,
   __in CONST GUID *PowerSettingGuid
   );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerCreateSetting (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerCreatePossibleSetting (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex 
    );
#endif

//
// Enumerate Functions.
//
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerEnumerate (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in POWER_DATA_ACCESSOR AccessFlags,
    __in ULONG Index,
    __out_bcount_opt(*BufferSize) UCHAR *Buffer,
    __inout DWORD *BufferSize
    );
#endif

//
// Activate Functions.
//
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerSetActiveScheme (
    __in_opt HKEY UserRootPowerKey,
    __in_opt CONST GUID *SchemeGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerGetActiveScheme (
    __in_opt HKEY UserRootPowerKey,
    __deref_out GUID **ActivePolicyGuid
    );
#endif
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerOpenUserPowerKey (
    __out HKEY *phUserPowerKey,
    __in REGSAM Access,
    __in BOOL OpenExisting
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerOpenSystemPowerKey (
    __out HKEY *phSystemPowerKey,
    __in REGSAM Access,
    __in BOOL OpenExisting
    );
#endif
        
#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerCanRestoreIndividualDefaultPowerScheme (
    __in CONST GUID *SchemeGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerRestoreIndividualDefaultPowerScheme (
    __in CONST GUID *SchemeGuid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerRestoreDefaultPowerSchemes(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(DWORD)
PowerReplaceDefaultPowerSchemes(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
STDAPI_(POWER_PLATFORM_ROLE)
PowerDeterminePlatformRole(
    VOID
    );
#endif

//
// =========================================
// Device Power APIs
// =========================================
//
//
// ========================================================
// These flags tell us how to interpret a query of
// device power.  Use these (or a combination of these)
// for the QueryInterpretationFlags parameter sent into
// DevicePowerEnumDevices().
//
// They'll ask us for some devices that supports some
// D state.  These flags help us determine what the
// user really wants.  I.e. does he want the device
// name, or the hardware ID.  Does he want some device
// that supports some D state, or does he want us to
// go see if that devices supports some S state? ...
// ========================================================
//

//
// Return HardwareID instead of the friendly device name, which
// is the default.
//
#define DEVICEPOWER_HARDWAREID             (0x80000000)

//
//
// 'and' the requested power states.  I.e. if the user requested
// that we query devices supporting D1 and D3, this flag says
// "give me devices that support D1 *and* D3".  Without this
// flag, the query would be interpreted as "give me devices
// that support D1 *or* D3".
//
#define DEVICEPOWER_AND_OPERATION          (0x40000000)

// Only preform the query on devices that are present in the system.
//
#define DEVICEPOWER_FILTER_DEVICES_PRESENT (0x20000000)

//
// Only preform the query on devices that are actual hardware.
//
#define DEVICEPOWER_FILTER_HARDWARE        (0x10000000)

//
// Only preform the query on devices that are armed to wake the
// system from a sleep state.
//
#define DEVICEPOWER_FILTER_WAKEENABLED     (0x08000000)

//
// Only preform the query on devices that are capable of being programmed
// to wake the system from a sleep state.
//
#define DEVICEPOWER_FILTER_WAKEPROGRAMMABLE (0x04000000)

//
// Go find the device who's name is specifed by an input
// parameter, then see if it's got the capabilities specified
// in QueryFlags.
//
#define DEVICEPOWER_FILTER_ON_NAME         (0x02000000)



//
// Define flags to set/clear capabilities in the devices.
//

//
// Enable the device to wake the system from a sleep state.
//
#define DEVICEPOWER_SET_WAKEENABLED (0x00000001)

//
// Disable the device from waking the system from a sleep
// state.
//
#define DEVICEPOWER_CLEAR_WAKEENABLED (0x00000002)




//
// For the QueryFlags parameter, the user should send in
// one of the PDCAP_D*_SUPPORTED flags found in ntpoapi.h.
//
// #define PDCAP_D0_SUPPORTED              0x00000001
// #define PDCAP_D1_SUPPORTED              0x00000002
// #define PDCAP_D2_SUPPORTED              0x00000004
// #define PDCAP_D3_SUPPORTED              0x00000008
// #define PDCAP_WAKE_FROM_D0_SUPPORTED    0x00000010
// #define PDCAP_WAKE_FROM_D1_SUPPORTED    0x00000020
// #define PDCAP_WAKE_FROM_D2_SUPPORTED    0x00000040
// #define PDCAP_WAKE_FROM_D3_SUPPORTED    0x00000080
// #define PDCAP_WARM_EJECT_SUPPORTED      0x00000100
//
// The user can also send in a combination of these values
// to do queries that match either or both of the specified
// flags.  E.g. if the user used (PDCAP_D1_SUPPORTED | PDCAP_D3_SUPPORTED),
// then the query would return a device that supported *either*
// D1 or D3.  The user could specify QUERY_AND_OPERATION in
// QueryInterpretationFlags to get a device that supported
// D1 *and* D3.
//

//
// We also support querying on S states.  Although devices don't
// really understand system states, we can use the D-to-S state
// mappings to derive this.  For example, if we ask a device if
// he supports S2, we can derive that by looking at his D-to-S
// mappings.  Suppose the device has a D-to-S state mapping
// that looks like this:
// S0 -> D0
// S1 -> D3
// S2 -> D3
// S3 -> D3
// S4 -> D3
// S5 -> D3
//
// We see that S2 maps to D3 on this device.  Does this device
// actually support D3?  We can find that out.  If so, then we
// say that this device supports S2.
//
// We have to make up the S-state vectors because there's no
// existing values like the PDCAP_D* values.
//
#define PDCAP_S0_SUPPORTED              0x00010000
#define PDCAP_S1_SUPPORTED              0x00020000
#define PDCAP_S2_SUPPORTED              0x00040000
#define PDCAP_S3_SUPPORTED              0x00080000
#define PDCAP_WAKE_FROM_S0_SUPPORTED    0x00100000
#define PDCAP_WAKE_FROM_S1_SUPPORTED    0x00200000
#define PDCAP_WAKE_FROM_S2_SUPPORTED    0x00400000
#define PDCAP_WAKE_FROM_S3_SUPPORTED    0x00800000
#define PDCAP_S4_SUPPORTED              0x01000000
#define PDCAP_S5_SUPPORTED              0x02000000

//
// Function prototypes
//
#if (NTDDI_VERSION >= NTDDI_WS03)
STDAPI_(BOOLEAN)
DevicePowerEnumDevices(
    __in ULONG  QueryIndex,
    __in ULONG  QueryInterpretationFlags,
    __in ULONG  QueryFlags,
    __out_bcount_opt(*pBufferSize) PBYTE  pReturnBuffer,
    __inout PULONG pBufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
STDAPI_(DWORD)
DevicePowerSetDeviceState(
    __in LPCWSTR DeviceDescription,
    __in ULONG SetFlags,
    __in_opt PVOID SetData
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
STDAPI_(BOOLEAN)
DevicePowerOpen(
    __in_opt ULONG DebugMask
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
STDAPI_(BOOLEAN)
DevicePowerClose(
    VOID
    );
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PostMake.Inc ===
#----------------------------------------------------------------------------
#
# Descriptions:
#   Generic Make File Postfix for EDK Environment
#
# Copyright:
#   Copyright (C) Microsoft Corp. 1993-1999.  All Rights Reserved.
#
#----------------------------------------------------------------------------

!ifndef PRIVATE_CLEAN
clean:
!else
generic_clean:
!endif
    del $(DIRBLD)\*.obj \
        $(DIRBLD)\*.err \
        $(DIRBLD)\*.lib \
        $(DIRBLD)\*.exe \
        $(DIRBLD)\*.dll \
        $(DIRBLD)\*.map \
        $(DIRBLD)\*.res \
        $(DIRBLD)\*.pch \
        $(DIRBLD)\*.exp

cleanall: clean
    del $(DIRPCH)\*.obj \
        $(DIRPCH)\*.pch

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disable precompiled headers if NOPCH is defined.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

!ifdef NOPCH
!include "nopch.inc"
!endif

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #1 used in most .C EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edk.obj: $(DIRPCHSRC)\edk.c
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR1) $(CFLAGS) $(DIRPCHSRC)\edk.c $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR1) $(CFLAGS) $(DIRPCHSRC)\edk.c $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #2 used in most .CPP EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edkx.obj: $(DIRPCHSRC)\edkx.cpp
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR2) $(CFLAGS) $(DIRPCHSRC)\edkx.cpp $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR2) $(CFLAGS) $(DIRPCHSRC)\edkx.cpp $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #3 used for .CPP and MFC applications.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edkafx.obj: $(DIRPCHSRC)\edkafx.cpp
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR3) $(CPPFLAGS) $(DIRPCHSRC)\edkafx.cpp $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR3) $(CPPFLAGS) $(DIRPCHSRC)\edkafx.cpp $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #4 used in UNICODE .C EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edku.obj: $(DIRPCHSRC)\edku.c
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR4) $(CFLAGS) $(DIRPCHSRC)\edku.c $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR4) $(CFLAGS) $(DIRPCHSRC)\edku.c $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ProfInfo.h ===
//=============================================================================
//  profinfo.h   -   Header file for profile info structure.
//
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//=============================================================================

#ifndef _INC_PROFINFO
#define _INC_PROFINFO

#ifdef __midl
#define FAR
#define MIDL_STRING [string, unique]
#else
#define MIDL_STRING
#endif  // __midl

typedef struct _PROFILEINFOA {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPSTR       lpUserName;             // User name (required)
    MIDL_STRING LPSTR       lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPSTR       lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOA, FAR * LPPROFILEINFOA;
typedef struct _PROFILEINFOW {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPWSTR      lpUserName;             // User name (required)
    MIDL_STRING LPWSTR      lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPWSTR      lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOW, FAR * LPPROFILEINFOW;
#ifdef UNICODE
typedef PROFILEINFOW PROFILEINFO;
typedef LPPROFILEINFOW LPPROFILEINFO;
#else
typedef PROFILEINFOA PROFILEINFO;
typedef LPPROFILEINFOA LPPROFILEINFO;
#endif // UNICODE

#endif  // _INC_PROFINFO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\propkey.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================


#ifndef _INC_PROPKEY
#define _INC_PROPKEY

#ifndef DEFINE_API_PKEY
#define DEFINE_API_PKEY(name, managed_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) \
        DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid)
#endif

#include <propkeydef.h>

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

 
//-----------------------------------------------------------------------------
// Audio properties

//  Name:     System.Audio.ChannelCount -- PKEY_Audio_ChannelCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 7 (PIDASI_CHANNEL_COUNT)
//
//  Indicates the channel count for the audio file.  Values: 1 (mono), 2 (stereo).
DEFINE_PROPERTYKEY(PKEY_Audio_ChannelCount, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 7);

// Possible discrete values for PKEY_Audio_ChannelCount are:
#define AUDIO_CHANNELCOUNT_MONO             1ul
#define AUDIO_CHANNELCOUNT_STEREO           2ul

//  Name:     System.Audio.Compression -- PKEY_Audio_Compression
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 10 (PIDASI_COMPRESSION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_Compression, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 10);

//  Name:     System.Audio.EncodingBitrate -- PKEY_Audio_EncodingBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 4 (PIDASI_AVG_DATA_RATE)
//
//  Indicates the average data rate in Hz for the audio file in "bits per second".
DEFINE_PROPERTYKEY(PKEY_Audio_EncodingBitrate, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

//  Name:     System.Audio.Format -- PKEY_Audio_Format
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_BSTR.
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 2 (PIDASI_FORMAT)
//
//  Indicates the format of the audio file.
DEFINE_PROPERTYKEY(PKEY_Audio_Format, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 2);

//  Name:     System.Audio.IsVariableBitRate -- PKEY_Audio_IsVariableBitRate
//  Type:     Boolean -- VT_BOOL
//  FormatID: {E6822FEE-8C17-4D62-823C-8E9CFCBD1D5C}, 100
DEFINE_PROPERTYKEY(PKEY_Audio_IsVariableBitRate, 0xE6822FEE, 0x8C17, 0x4D62, 0x82, 0x3C, 0x8E, 0x9C, 0xFC, 0xBD, 0x1D, 0x5C, 100);

//  Name:     System.Audio.PeakValue -- PKEY_Audio_PeakValue
//  Type:     UInt32 -- VT_UI4
//  FormatID: {2579E5D0-1116-4084-BD9A-9B4F7CB4DF5E}, 100
DEFINE_PROPERTYKEY(PKEY_Audio_PeakValue, 0x2579E5D0, 0x1116, 0x4084, 0xBD, 0x9A, 0x9B, 0x4F, 0x7C, 0xB4, 0xDF, 0x5E, 100);

//  Name:     System.Audio.SampleRate -- PKEY_Audio_SampleRate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 5 (PIDASI_SAMPLE_RATE)
//
//  Indicates the audio sample rate for the audio file in "samples per second".
DEFINE_PROPERTYKEY(PKEY_Audio_SampleRate, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 5);

//  Name:     System.Audio.SampleSize -- PKEY_Audio_SampleSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 6 (PIDASI_SAMPLE_SIZE)
//
//  Indicates the audio sample size for the audio file in "bits per sample".
DEFINE_PROPERTYKEY(PKEY_Audio_SampleSize, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Audio.StreamName -- PKEY_Audio_StreamName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 9 (PIDASI_STREAM_NAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_StreamName, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

//  Name:     System.Audio.StreamNumber -- PKEY_Audio_StreamNumber
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 8 (PIDASI_STREAM_NUMBER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_StreamNumber, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 8);

 
 
//-----------------------------------------------------------------------------
// Calendar properties

//  Name:     System.Calendar.Duration -- PKEY_Calendar_Duration
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {293CA35A-09AA-4DD2-B180-1FE245728A52}, 100
//
//  The duration as specified in a string.
DEFINE_PROPERTYKEY(PKEY_Calendar_Duration, 0x293CA35A, 0x09AA, 0x4DD2, 0xB1, 0x80, 0x1F, 0xE2, 0x45, 0x72, 0x8A, 0x52, 100);

//  Name:     System.Calendar.IsOnline -- PKEY_Calendar_IsOnline
//  Type:     Boolean -- VT_BOOL
//  FormatID: {BFEE9149-E3E2-49A7-A862-C05988145CEC}, 100
//
//  Identifies if the event is an online event.
DEFINE_PROPERTYKEY(PKEY_Calendar_IsOnline, 0xBFEE9149, 0xE3E2, 0x49A7, 0xA8, 0x62, 0xC0, 0x59, 0x88, 0x14, 0x5C, 0xEC, 100);

//  Name:     System.Calendar.IsRecurring -- PKEY_Calendar_IsRecurring
//  Type:     Boolean -- VT_BOOL
//  FormatID: {315B9C8D-80A9-4EF9-AE16-8E746DA51D70}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_IsRecurring, 0x315B9C8D, 0x80A9, 0x4EF9, 0xAE, 0x16, 0x8E, 0x74, 0x6D, 0xA5, 0x1D, 0x70, 100);

//  Name:     System.Calendar.Location -- PKEY_Calendar_Location
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F6272D18-CECC-40B1-B26A-3911717AA7BD}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_Location, 0xF6272D18, 0xCECC, 0x40B1, 0xB2, 0x6A, 0x39, 0x11, 0x71, 0x7A, 0xA7, 0xBD, 100);

//  Name:     System.Calendar.OptionalAttendeeAddresses -- PKEY_Calendar_OptionalAttendeeAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D55BAE5A-3892-417A-A649-C6AC5AAAEAB3}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_OptionalAttendeeAddresses, 0xD55BAE5A, 0x3892, 0x417A, 0xA6, 0x49, 0xC6, 0xAC, 0x5A, 0xAA, 0xEA, 0xB3, 100);

//  Name:     System.Calendar.OptionalAttendeeNames -- PKEY_Calendar_OptionalAttendeeNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {09429607-582D-437F-84C3-DE93A2B24C3C}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_OptionalAttendeeNames, 0x09429607, 0x582D, 0x437F, 0x84, 0xC3, 0xDE, 0x93, 0xA2, 0xB2, 0x4C, 0x3C, 100);

//  Name:     System.Calendar.OrganizerAddress -- PKEY_Calendar_OrganizerAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {744C8242-4DF5-456C-AB9E-014EFB9021E3}, 100
//
//  Address of the organizer organizing the event.
DEFINE_PROPERTYKEY(PKEY_Calendar_OrganizerAddress, 0x744C8242, 0x4DF5, 0x456C, 0xAB, 0x9E, 0x01, 0x4E, 0xFB, 0x90, 0x21, 0xE3, 100);

//  Name:     System.Calendar.OrganizerName -- PKEY_Calendar_OrganizerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {AAA660F9-9865-458E-B484-01BC7FE3973E}, 100
//
//  Name of the organizer organizing the event.
DEFINE_PROPERTYKEY(PKEY_Calendar_OrganizerName, 0xAAA660F9, 0x9865, 0x458E, 0xB4, 0x84, 0x01, 0xBC, 0x7F, 0xE3, 0x97, 0x3E, 100);

//  Name:     System.Calendar.ReminderTime -- PKEY_Calendar_ReminderTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {72FC5BA4-24F9-4011-9F3F-ADD27AFAD818}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_ReminderTime, 0x72FC5BA4, 0x24F9, 0x4011, 0x9F, 0x3F, 0xAD, 0xD2, 0x7A, 0xFA, 0xD8, 0x18, 100);

//  Name:     System.Calendar.RequiredAttendeeAddresses -- PKEY_Calendar_RequiredAttendeeAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {0BA7D6C3-568D-4159-AB91-781A91FB71E5}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_RequiredAttendeeAddresses, 0x0BA7D6C3, 0x568D, 0x4159, 0xAB, 0x91, 0x78, 0x1A, 0x91, 0xFB, 0x71, 0xE5, 100);

//  Name:     System.Calendar.RequiredAttendeeNames -- PKEY_Calendar_RequiredAttendeeNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {B33AF30B-F552-4584-936C-CB93E5CDA29F}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_RequiredAttendeeNames, 0xB33AF30B, 0xF552, 0x4584, 0x93, 0x6C, 0xCB, 0x93, 0xE5, 0xCD, 0xA2, 0x9F, 100);

//  Name:     System.Calendar.Resources -- PKEY_Calendar_Resources
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {00F58A38-C54B-4C40-8696-97235980EAE1}, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_Resources, 0x00F58A38, 0xC54B, 0x4C40, 0x86, 0x96, 0x97, 0x23, 0x59, 0x80, 0xEA, 0xE1, 100);

//  Name:     System.Calendar.ResponseStatus -- PKEY_Calendar_ResponseStatus
//  Type:     UInt16 -- VT_UI2
//  FormatID: {188C1F91-3C40-4132-9EC5-D8B03B72A8A2}, 100
//  
//  This property stores the status of the user responses to meetings in her calendar.
DEFINE_PROPERTYKEY(PKEY_Calendar_ResponseStatus, 0x188C1F91, 0x3C40, 0x4132, 0x9E, 0xC5, 0xD8, 0xB0, 0x3B, 0x72, 0xA8, 0xA2, 100);

// Possible discrete values for PKEY_Calendar_ResponseStatus are:
#define CALENDAR_RESPONSESTATUS_NONE        0u
#define CALENDAR_RESPONSESTATUS_ORGANIZED   1u
#define CALENDAR_RESPONSESTATUS_TENTATIVE   2u
#define CALENDAR_RESPONSESTATUS_ACCEPTED    3u
#define CALENDAR_RESPONSESTATUS_DECLINED    4u
#define CALENDAR_RESPONSESTATUS_NOTRESPONDED 5u

//  Name:     System.Calendar.ShowTimeAs -- PKEY_Calendar_ShowTimeAs
//  Type:     UInt16 -- VT_UI2
//  FormatID: {5BF396D4-5EB2-466F-BDE9-2FB3F2361D6E}, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_Calendar_ShowTimeAs, 0x5BF396D4, 0x5EB2, 0x466F, 0xBD, 0xE9, 0x2F, 0xB3, 0xF2, 0x36, 0x1D, 0x6E, 100);

// Possible discrete values for PKEY_Calendar_ShowTimeAs are:
#define CALENDAR_SHOWTIMEAS_FREE            0u
#define CALENDAR_SHOWTIMEAS_TENTATIVE       1u
#define CALENDAR_SHOWTIMEAS_BUSY            2u
#define CALENDAR_SHOWTIMEAS_OOF             3u

//  Name:     System.Calendar.ShowTimeAsText -- PKEY_Calendar_ShowTimeAsText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {53DA57CF-62C0-45C4-81DE-7610BCEFD7F5}, 100
//  
//  This is the user-friendly form of System.Calendar.ShowTimeAs.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Calendar_ShowTimeAsText, 0x53DA57CF, 0x62C0, 0x45C4, 0x81, 0xDE, 0x76, 0x10, 0xBC, 0xEF, 0xD7, 0xF5, 100);
 
//-----------------------------------------------------------------------------
// Communication properties



//  Name:     System.Communication.AccountName -- PKEY_Communication_AccountName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 9
//
//  Account Name
DEFINE_PROPERTYKEY(PKEY_Communication_AccountName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 9);

//  Name:     System.Communication.DateItemExpires -- PKEY_Communication_DateItemExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {428040AC-A177-4C8A-9760-F6F761227F9A}, 100
//  
//  Date the item expires due to the retention policy.
DEFINE_PROPERTYKEY(PKEY_Communication_DateItemExpires, 0x428040AC, 0xA177, 0x4C8A, 0x97, 0x60, 0xF6, 0xF7, 0x61, 0x22, 0x7F, 0x9A, 100);

//  Name:     System.Communication.FollowupIconIndex -- PKEY_Communication_FollowupIconIndex
//  Type:     Int32 -- VT_I4
//  FormatID: {83A6347E-6FE4-4F40-BA9C-C4865240D1F4}, 100
//  
//  This is the icon index used on messages marked for followup.
DEFINE_PROPERTYKEY(PKEY_Communication_FollowupIconIndex, 0x83A6347E, 0x6FE4, 0x4F40, 0xBA, 0x9C, 0xC4, 0x86, 0x52, 0x40, 0xD1, 0xF4, 100);

//  Name:     System.Communication.HeaderItem -- PKEY_Communication_HeaderItem
//  Type:     Boolean -- VT_BOOL
//  FormatID: {C9C34F84-2241-4401-B607-BD20ED75AE7F}, 100
//  
//  This property will be true if the item is a header item which means the item hasn't been fully downloaded.
DEFINE_PROPERTYKEY(PKEY_Communication_HeaderItem, 0xC9C34F84, 0x2241, 0x4401, 0xB6, 0x07, 0xBD, 0x20, 0xED, 0x75, 0xAE, 0x7F, 100);

//  Name:     System.Communication.PolicyTag -- PKEY_Communication_PolicyTag
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {EC0B4191-AB0B-4C66-90B6-C6637CDEBBAB}, 100
//  
//  This a string used to identify the retention policy applied to the item.
DEFINE_PROPERTYKEY(PKEY_Communication_PolicyTag, 0xEC0B4191, 0xAB0B, 0x4C66, 0x90, 0xB6, 0xC6, 0x63, 0x7C, 0xDE, 0xBB, 0xAB, 100);

//  Name:     System.Communication.SecurityFlags -- PKEY_Communication_SecurityFlags
//  Type:     Int32 -- VT_I4
//  FormatID: {8619A4B6-9F4D-4429-8C0F-B996CA59E335}, 100
//  
//  Security flags associated with the item to know if the item is encrypted, signed or DRM enabled.
DEFINE_PROPERTYKEY(PKEY_Communication_SecurityFlags, 0x8619A4B6, 0x9F4D, 0x4429, 0x8C, 0x0F, 0xB9, 0x96, 0xCA, 0x59, 0xE3, 0x35, 100);

//  Name:     System.Communication.Suffix -- PKEY_Communication_Suffix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {807B653A-9E91-43EF-8F97-11CE04EE20C5}, 100
DEFINE_PROPERTYKEY(PKEY_Communication_Suffix, 0x807B653A, 0x9E91, 0x43EF, 0x8F, 0x97, 0x11, 0xCE, 0x04, 0xEE, 0x20, 0xC5, 100);

//  Name:     System.Communication.TaskStatus -- PKEY_Communication_TaskStatus
//  Type:     UInt16 -- VT_UI2
//  FormatID: {BE1A72C6-9A1D-46B7-AFE7-AFAF8CEF4999}, 100
DEFINE_PROPERTYKEY(PKEY_Communication_TaskStatus, 0xBE1A72C6, 0x9A1D, 0x46B7, 0xAF, 0xE7, 0xAF, 0xAF, 0x8C, 0xEF, 0x49, 0x99, 100);

// Possible discrete values for PKEY_Communication_TaskStatus are:
#define TASKSTATUS_NOTSTARTED               0u
#define TASKSTATUS_INPROGRESS               1u
#define TASKSTATUS_COMPLETE                 2u
#define TASKSTATUS_WAITING                  3u
#define TASKSTATUS_DEFERRED                 4u

//  Name:     System.Communication.TaskStatusText -- PKEY_Communication_TaskStatusText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A6744477-C237-475B-A075-54F34498292A}, 100
//  
//  This is the user-friendly form of System.Communication.TaskStatus.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Communication_TaskStatusText, 0xA6744477, 0xC237, 0x475B, 0xA0, 0x75, 0x54, 0xF3, 0x44, 0x98, 0x29, 0x2A, 100);
 
//-----------------------------------------------------------------------------
// Computer properties



//  Name:     System.Computer.DecoratedFreeSpace -- PKEY_Computer_DecoratedFreeSpace
//  Type:     Multivalue UInt64 -- VT_VECTOR | VT_UI8  (For variants: VT_ARRAY | VT_UI8)
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 7  (Filesystem Volume Properties)
//
//  Free space and total space: "%s free of %s"
DEFINE_PROPERTYKEY(PKEY_Computer_DecoratedFreeSpace, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 7);
 
//-----------------------------------------------------------------------------
// Contact properties



//  Name:     System.Contact.Anniversary -- PKEY_Contact_Anniversary
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {9AD5BADB-CEA7-4470-A03D-B84E51B9949E}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Anniversary, 0x9AD5BADB, 0xCEA7, 0x4470, 0xA0, 0x3D, 0xB8, 0x4E, 0x51, 0xB9, 0x94, 0x9E, 100);

//  Name:     System.Contact.AssistantName -- PKEY_Contact_AssistantName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CD102C9C-5540-4A88-A6F6-64E4981C8CD1}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_AssistantName, 0xCD102C9C, 0x5540, 0x4A88, 0xA6, 0xF6, 0x64, 0xE4, 0x98, 0x1C, 0x8C, 0xD1, 100);

//  Name:     System.Contact.AssistantTelephone -- PKEY_Contact_AssistantTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9A93244D-A7AD-4FF8-9B99-45EE4CC09AF6}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_AssistantTelephone, 0x9A93244D, 0xA7AD, 0x4FF8, 0x9B, 0x99, 0x45, 0xEE, 0x4C, 0xC0, 0x9A, 0xF6, 100);

//  Name:     System.Contact.Birthday -- PKEY_Contact_Birthday
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 47
DEFINE_PROPERTYKEY(PKEY_Contact_Birthday, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 47);

//  Name:     System.Contact.BusinessAddress -- PKEY_Contact_BusinessAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {730FB6DD-CF7C-426B-A03F-BD166CC9EE24}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddress, 0x730FB6DD, 0xCF7C, 0x426B, 0xA0, 0x3F, 0xBD, 0x16, 0x6C, 0xC9, 0xEE, 0x24, 100);

//  Name:     System.Contact.BusinessAddressCity -- PKEY_Contact_BusinessAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {402B5934-EC5A-48C3-93E6-85E86A2D934E}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressCity, 0x402B5934, 0xEC5A, 0x48C3, 0x93, 0xE6, 0x85, 0xE8, 0x6A, 0x2D, 0x93, 0x4E, 100);

//  Name:     System.Contact.BusinessAddressCountry -- PKEY_Contact_BusinessAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {B0B87314-FCF6-4FEB-8DFF-A50DA6AF561C}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressCountry, 0xB0B87314, 0xFCF6, 0x4FEB, 0x8D, 0xFF, 0xA5, 0x0D, 0xA6, 0xAF, 0x56, 0x1C, 100);

//  Name:     System.Contact.BusinessAddressPostalCode -- PKEY_Contact_BusinessAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E1D4A09E-D758-4CD1-B6EC-34A8B5A73F80}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressPostalCode, 0xE1D4A09E, 0xD758, 0x4CD1, 0xB6, 0xEC, 0x34, 0xA8, 0xB5, 0xA7, 0x3F, 0x80, 100);

//  Name:     System.Contact.BusinessAddressPostOfficeBox -- PKEY_Contact_BusinessAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {BC4E71CE-17F9-48D5-BEE9-021DF0EA5409}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressPostOfficeBox, 0xBC4E71CE, 0x17F9, 0x48D5, 0xBE, 0xE9, 0x02, 0x1D, 0xF0, 0xEA, 0x54, 0x09, 100);

//  Name:     System.Contact.BusinessAddressState -- PKEY_Contact_BusinessAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {446F787F-10C4-41CB-A6C4-4D0343551597}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressState, 0x446F787F, 0x10C4, 0x41CB, 0xA6, 0xC4, 0x4D, 0x03, 0x43, 0x55, 0x15, 0x97, 100);

//  Name:     System.Contact.BusinessAddressStreet -- PKEY_Contact_BusinessAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DDD1460F-C0BF-4553-8CE4-10433C908FB0}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressStreet, 0xDDD1460F, 0xC0BF, 0x4553, 0x8C, 0xE4, 0x10, 0x43, 0x3C, 0x90, 0x8F, 0xB0, 100);

//  Name:     System.Contact.BusinessFaxNumber -- PKEY_Contact_BusinessFaxNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {91EFF6F3-2E27-42CA-933E-7C999FBE310B}, 100
//
//  Business fax number of the contact.
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessFaxNumber, 0x91EFF6F3, 0x2E27, 0x42CA, 0x93, 0x3E, 0x7C, 0x99, 0x9F, 0xBE, 0x31, 0x0B, 100);

//  Name:     System.Contact.BusinessHomePage -- PKEY_Contact_BusinessHomePage
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {56310920-2491-4919-99CE-EADB06FAFDB2}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessHomePage, 0x56310920, 0x2491, 0x4919, 0x99, 0xCE, 0xEA, 0xDB, 0x06, 0xFA, 0xFD, 0xB2, 100);

//  Name:     System.Contact.BusinessTelephone -- PKEY_Contact_BusinessTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6A15E5A0-0A1E-4CD7-BB8C-D2F1B0C929BC}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessTelephone, 0x6A15E5A0, 0x0A1E, 0x4CD7, 0xBB, 0x8C, 0xD2, 0xF1, 0xB0, 0xC9, 0x29, 0xBC, 100);

//  Name:     System.Contact.CallbackTelephone -- PKEY_Contact_CallbackTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {BF53D1C3-49E0-4F7F-8567-5A821D8AC542}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CallbackTelephone, 0xBF53D1C3, 0x49E0, 0x4F7F, 0x85, 0x67, 0x5A, 0x82, 0x1D, 0x8A, 0xC5, 0x42, 100);

//  Name:     System.Contact.CarTelephone -- PKEY_Contact_CarTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8FDC6DEA-B929-412B-BA90-397A257465FE}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CarTelephone, 0x8FDC6DEA, 0xB929, 0x412B, 0xBA, 0x90, 0x39, 0x7A, 0x25, 0x74, 0x65, 0xFE, 100);

//  Name:     System.Contact.Children -- PKEY_Contact_Children
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D4729704-8EF1-43EF-9024-2BD381187FD5}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Children, 0xD4729704, 0x8EF1, 0x43EF, 0x90, 0x24, 0x2B, 0xD3, 0x81, 0x18, 0x7F, 0xD5, 100);

//  Name:     System.Contact.CompanyMainTelephone -- PKEY_Contact_CompanyMainTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8589E481-6040-473D-B171-7FA89C2708ED}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CompanyMainTelephone, 0x8589E481, 0x6040, 0x473D, 0xB1, 0x71, 0x7F, 0xA8, 0x9C, 0x27, 0x08, 0xED, 100);

//  Name:     System.Contact.Department -- PKEY_Contact_Department
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FC9F7306-FF8F-4D49-9FB6-3FFE5C0951EC}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Department, 0xFC9F7306, 0xFF8F, 0x4D49, 0x9F, 0xB6, 0x3F, 0xFE, 0x5C, 0x09, 0x51, 0xEC, 100);

//  Name:     System.Contact.EmailAddress -- PKEY_Contact_EmailAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F8FA7FA3-D12B-4785-8A4E-691A94F7A3E7}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress, 0xF8FA7FA3, 0xD12B, 0x4785, 0x8A, 0x4E, 0x69, 0x1A, 0x94, 0xF7, 0xA3, 0xE7, 100);

//  Name:     System.Contact.EmailAddress2 -- PKEY_Contact_EmailAddress2
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {38965063-EDC8-4268-8491-B7723172CF29}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress2, 0x38965063, 0xEDC8, 0x4268, 0x84, 0x91, 0xB7, 0x72, 0x31, 0x72, 0xCF, 0x29, 100);

//  Name:     System.Contact.EmailAddress3 -- PKEY_Contact_EmailAddress3
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {644D37B4-E1B3-4BAD-B099-7E7C04966ACA}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress3, 0x644D37B4, 0xE1B3, 0x4BAD, 0xB0, 0x99, 0x7E, 0x7C, 0x04, 0x96, 0x6A, 0xCA, 100);

//  Name:     System.Contact.EmailAddresses -- PKEY_Contact_EmailAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {84D8F337-981D-44B3-9615-C7596DBA17E3}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddresses, 0x84D8F337, 0x981D, 0x44B3, 0x96, 0x15, 0xC7, 0x59, 0x6D, 0xBA, 0x17, 0xE3, 100);

//  Name:     System.Contact.EmailName -- PKEY_Contact_EmailName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CC6F4F24-6083-4BD4-8754-674D0DE87AB8}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailName, 0xCC6F4F24, 0x6083, 0x4BD4, 0x87, 0x54, 0x67, 0x4D, 0x0D, 0xE8, 0x7A, 0xB8, 100);

//  Name:     System.Contact.FileAsName -- PKEY_Contact_FileAsName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F1A24AA7-9CA7-40F6-89EC-97DEF9FFE8DB}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FileAsName, 0xF1A24AA7, 0x9CA7, 0x40F6, 0x89, 0xEC, 0x97, 0xDE, 0xF9, 0xFF, 0xE8, 0xDB, 100);

//  Name:     System.Contact.FirstName -- PKEY_Contact_FirstName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {14977844-6B49-4AAD-A714-A4513BF60460}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FirstName, 0x14977844, 0x6B49, 0x4AAD, 0xA7, 0x14, 0xA4, 0x51, 0x3B, 0xF6, 0x04, 0x60, 100);

//  Name:     System.Contact.FullName -- PKEY_Contact_FullName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {635E9051-50A5-4BA2-B9DB-4ED056C77296}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FullName, 0x635E9051, 0x50A5, 0x4BA2, 0xB9, 0xDB, 0x4E, 0xD0, 0x56, 0xC7, 0x72, 0x96, 100);

//  Name:     System.Contact.Gender -- PKEY_Contact_Gender
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Gender, 0x3C8CEE58, 0xD4F0, 0x4CF9, 0xB7, 0x56, 0x4E, 0x5D, 0x24, 0x44, 0x7B, 0xCD, 100);

//  Name:     System.Contact.GenderValue -- PKEY_Contact_GenderValue
//  Type:     UInt16 -- VT_UI2
//  FormatID: {3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD}, 101
DEFINE_PROPERTYKEY(PKEY_Contact_GenderValue, 0x3C8CEE58, 0xD4F0, 0x4CF9, 0xB7, 0x56, 0x4E, 0x5D, 0x24, 0x44, 0x7B, 0xCD, 101);

// Possible discrete values for PKEY_Contact_GenderValue are:
#define GENDERVALUE_UNSPECIFIED             0u
#define GENDERVALUE_FEMALE                  1u
#define GENDERVALUE_MALE                    2u

//  Name:     System.Contact.Hobbies -- PKEY_Contact_Hobbies
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {5DC2253F-5E11-4ADF-9CFE-910DD01E3E70}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Hobbies, 0x5DC2253F, 0x5E11, 0x4ADF, 0x9C, 0xFE, 0x91, 0x0D, 0xD0, 0x1E, 0x3E, 0x70, 100);

//  Name:     System.Contact.HomeAddress -- PKEY_Contact_HomeAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {98F98354-617A-46B8-8560-5B1B64BF1F89}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddress, 0x98F98354, 0x617A, 0x46B8, 0x85, 0x60, 0x5B, 0x1B, 0x64, 0xBF, 0x1F, 0x89, 100);

//  Name:     System.Contact.HomeAddressCity -- PKEY_Contact_HomeAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 65
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressCity, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 65);

//  Name:     System.Contact.HomeAddressCountry -- PKEY_Contact_HomeAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {08A65AA1-F4C9-43DD-9DDF-A33D8E7EAD85}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressCountry, 0x08A65AA1, 0xF4C9, 0x43DD, 0x9D, 0xDF, 0xA3, 0x3D, 0x8E, 0x7E, 0xAD, 0x85, 100);

//  Name:     System.Contact.HomeAddressPostalCode -- PKEY_Contact_HomeAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8AFCC170-8A46-4B53-9EEE-90BAE7151E62}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressPostalCode, 0x8AFCC170, 0x8A46, 0x4B53, 0x9E, 0xEE, 0x90, 0xBA, 0xE7, 0x15, 0x1E, 0x62, 100);

//  Name:     System.Contact.HomeAddressPostOfficeBox -- PKEY_Contact_HomeAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7B9F6399-0A3F-4B12-89BD-4ADC51C918AF}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressPostOfficeBox, 0x7B9F6399, 0x0A3F, 0x4B12, 0x89, 0xBD, 0x4A, 0xDC, 0x51, 0xC9, 0x18, 0xAF, 100);

//  Name:     System.Contact.HomeAddressState -- PKEY_Contact_HomeAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C89A23D0-7D6D-4EB8-87D4-776A82D493E5}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressState, 0xC89A23D0, 0x7D6D, 0x4EB8, 0x87, 0xD4, 0x77, 0x6A, 0x82, 0xD4, 0x93, 0xE5, 100);

//  Name:     System.Contact.HomeAddressStreet -- PKEY_Contact_HomeAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0ADEF160-DB3F-4308-9A21-06237B16FA2A}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressStreet, 0x0ADEF160, 0xDB3F, 0x4308, 0x9A, 0x21, 0x06, 0x23, 0x7B, 0x16, 0xFA, 0x2A, 100);

//  Name:     System.Contact.HomeFaxNumber -- PKEY_Contact_HomeFaxNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {660E04D6-81AB-4977-A09F-82313113AB26}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeFaxNumber, 0x660E04D6, 0x81AB, 0x4977, 0xA0, 0x9F, 0x82, 0x31, 0x31, 0x13, 0xAB, 0x26, 100);

//  Name:     System.Contact.HomeTelephone -- PKEY_Contact_HomeTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 20
DEFINE_PROPERTYKEY(PKEY_Contact_HomeTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 20);

//  Name:     System.Contact.IMAddress -- PKEY_Contact_IMAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D68DBD8A-3374-4B81-9972-3EC30682DB3D}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_IMAddress, 0xD68DBD8A, 0x3374, 0x4B81, 0x99, 0x72, 0x3E, 0xC3, 0x06, 0x82, 0xDB, 0x3D, 100);

//  Name:     System.Contact.Initials -- PKEY_Contact_Initials
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F3D8F40D-50CB-44A2-9718-40CB9119495D}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Initials, 0xF3D8F40D, 0x50CB, 0x44A2, 0x97, 0x18, 0x40, 0xCB, 0x91, 0x19, 0x49, 0x5D, 100);

//  Name:     System.Contact.JA.CompanyNamePhonetic -- PKEY_Contact_JA_CompanyNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 2
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_CompanyNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 2);

//  Name:     System.Contact.JA.FirstNamePhonetic -- PKEY_Contact_JA_FirstNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 3
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_FirstNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 3);

//  Name:     System.Contact.JA.LastNamePhonetic -- PKEY_Contact_JA_LastNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 4
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_LastNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 4);

//  Name:     System.Contact.JobTitle -- PKEY_Contact_JobTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 6
DEFINE_PROPERTYKEY(PKEY_Contact_JobTitle, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 6);

//  Name:     System.Contact.Label -- PKEY_Contact_Label
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {97B0AD89-DF49-49CC-834E-660974FD755B}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Label, 0x97B0AD89, 0xDF49, 0x49CC, 0x83, 0x4E, 0x66, 0x09, 0x74, 0xFD, 0x75, 0x5B, 100);

//  Name:     System.Contact.LastName -- PKEY_Contact_LastName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8F367200-C270-457C-B1D4-E07C5BCD90C7}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_LastName, 0x8F367200, 0xC270, 0x457C, 0xB1, 0xD4, 0xE0, 0x7C, 0x5B, 0xCD, 0x90, 0xC7, 100);

//  Name:     System.Contact.MailingAddress -- PKEY_Contact_MailingAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C0AC206A-827E-4650-95AE-77E2BB74FCC9}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_MailingAddress, 0xC0AC206A, 0x827E, 0x4650, 0x95, 0xAE, 0x77, 0xE2, 0xBB, 0x74, 0xFC, 0xC9, 100);

//  Name:     System.Contact.MiddleName -- PKEY_Contact_MiddleName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 71
DEFINE_PROPERTYKEY(PKEY_Contact_MiddleName, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 71);

//  Name:     System.Contact.MobileTelephone -- PKEY_Contact_MobileTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 35
DEFINE_PROPERTYKEY(PKEY_Contact_MobileTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 35);

//  Name:     System.Contact.NickName -- PKEY_Contact_NickName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 74
DEFINE_PROPERTYKEY(PKEY_Contact_NickName, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 74);

//  Name:     System.Contact.OfficeLocation -- PKEY_Contact_OfficeLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 7
DEFINE_PROPERTYKEY(PKEY_Contact_OfficeLocation, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 7);

//  Name:     System.Contact.OtherAddress -- PKEY_Contact_OtherAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {508161FA-313B-43D5-83A1-C1ACCF68622C}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddress, 0x508161FA, 0x313B, 0x43D5, 0x83, 0xA1, 0xC1, 0xAC, 0xCF, 0x68, 0x62, 0x2C, 100);

//  Name:     System.Contact.OtherAddressCity -- PKEY_Contact_OtherAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6E682923-7F7B-4F0C-A337-CFCA296687BF}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressCity, 0x6E682923, 0x7F7B, 0x4F0C, 0xA3, 0x37, 0xCF, 0xCA, 0x29, 0x66, 0x87, 0xBF, 100);

//  Name:     System.Contact.OtherAddressCountry -- PKEY_Contact_OtherAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8F167568-0AAE-4322-8ED9-6055B7B0E398}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressCountry, 0x8F167568, 0x0AAE, 0x4322, 0x8E, 0xD9, 0x60, 0x55, 0xB7, 0xB0, 0xE3, 0x98, 100);

//  Name:     System.Contact.OtherAddressPostalCode -- PKEY_Contact_OtherAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {95C656C1-2ABF-4148-9ED3-9EC602E3B7CD}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressPostalCode, 0x95C656C1, 0x2ABF, 0x4148, 0x9E, 0xD3, 0x9E, 0xC6, 0x02, 0xE3, 0xB7, 0xCD, 100);

//  Name:     System.Contact.OtherAddressPostOfficeBox -- PKEY_Contact_OtherAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {8B26EA41-058F-43F6-AECC-4035681CE977}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressPostOfficeBox, 0x8B26EA41, 0x058F, 0x43F6, 0xAE, 0xCC, 0x40, 0x35, 0x68, 0x1C, 0xE9, 0x77, 100);

//  Name:     System.Contact.OtherAddressState -- PKEY_Contact_OtherAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {71B377D6-E570-425F-A170-809FAE73E54E}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressState, 0x71B377D6, 0xE570, 0x425F, 0xA1, 0x70, 0x80, 0x9F, 0xAE, 0x73, 0xE5, 0x4E, 100);

//  Name:     System.Contact.OtherAddressStreet -- PKEY_Contact_OtherAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FF962609-B7D6-4999-862D-95180D529AEA}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressStreet, 0xFF962609, 0xB7D6, 0x4999, 0x86, 0x2D, 0x95, 0x18, 0x0D, 0x52, 0x9A, 0xEA, 100);

//  Name:     System.Contact.PagerTelephone -- PKEY_Contact_PagerTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D6304E01-F8F5-4F45-8B15-D024A6296789}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PagerTelephone, 0xD6304E01, 0xF8F5, 0x4F45, 0x8B, 0x15, 0xD0, 0x24, 0xA6, 0x29, 0x67, 0x89, 100);

//  Name:     System.Contact.PersonalTitle -- PKEY_Contact_PersonalTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 69
DEFINE_PROPERTYKEY(PKEY_Contact_PersonalTitle, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 69);

//  Name:     System.Contact.PrimaryAddressCity -- PKEY_Contact_PrimaryAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C8EA94F0-A9E3-4969-A94B-9C62A95324E0}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressCity, 0xC8EA94F0, 0xA9E3, 0x4969, 0xA9, 0x4B, 0x9C, 0x62, 0xA9, 0x53, 0x24, 0xE0, 100);

//  Name:     System.Contact.PrimaryAddressCountry -- PKEY_Contact_PrimaryAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E53D799D-0F3F-466E-B2FF-74634A3CB7A4}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressCountry, 0xE53D799D, 0x0F3F, 0x466E, 0xB2, 0xFF, 0x74, 0x63, 0x4A, 0x3C, 0xB7, 0xA4, 100);

//  Name:     System.Contact.PrimaryAddressPostalCode -- PKEY_Contact_PrimaryAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {18BBD425-ECFD-46EF-B612-7B4A6034EDA0}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressPostalCode, 0x18BBD425, 0xECFD, 0x46EF, 0xB6, 0x12, 0x7B, 0x4A, 0x60, 0x34, 0xED, 0xA0, 100);

//  Name:     System.Contact.PrimaryAddressPostOfficeBox -- PKEY_Contact_PrimaryAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DE5EF3C7-46E1-484E-9999-62C5308394C1}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressPostOfficeBox, 0xDE5EF3C7, 0x46E1, 0x484E, 0x99, 0x99, 0x62, 0xC5, 0x30, 0x83, 0x94, 0xC1, 100);

//  Name:     System.Contact.PrimaryAddressState -- PKEY_Contact_PrimaryAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F1176DFE-7138-4640-8B4C-AE375DC70A6D}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressState, 0xF1176DFE, 0x7138, 0x4640, 0x8B, 0x4C, 0xAE, 0x37, 0x5D, 0xC7, 0x0A, 0x6D, 100);

//  Name:     System.Contact.PrimaryAddressStreet -- PKEY_Contact_PrimaryAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {63C25B20-96BE-488F-8788-C09C407AD812}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressStreet, 0x63C25B20, 0x96BE, 0x488F, 0x87, 0x88, 0xC0, 0x9C, 0x40, 0x7A, 0xD8, 0x12, 100);

//  Name:     System.Contact.PrimaryEmailAddress -- PKEY_Contact_PrimaryEmailAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 48
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryEmailAddress, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 48);

//  Name:     System.Contact.PrimaryTelephone -- PKEY_Contact_PrimaryTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 25
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 25);

//  Name:     System.Contact.Profession -- PKEY_Contact_Profession
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7268AF55-1CE4-4F6E-A41F-B6E4EF10E4A9}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Profession, 0x7268AF55, 0x1CE4, 0x4F6E, 0xA4, 0x1F, 0xB6, 0xE4, 0xEF, 0x10, 0xE4, 0xA9, 100);

//  Name:     System.Contact.SpouseName -- PKEY_Contact_SpouseName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9D2408B6-3167-422B-82B0-F583B7A7CFE3}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_SpouseName, 0x9D2408B6, 0x3167, 0x422B, 0x82, 0xB0, 0xF5, 0x83, 0xB7, 0xA7, 0xCF, 0xE3, 100);

//  Name:     System.Contact.Suffix -- PKEY_Contact_Suffix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 73
DEFINE_PROPERTYKEY(PKEY_Contact_Suffix, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 73);

//  Name:     System.Contact.TelexNumber -- PKEY_Contact_TelexNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C554493C-C1F7-40C1-A76C-EF8C0614003E}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_TelexNumber, 0xC554493C, 0xC1F7, 0x40C1, 0xA7, 0x6C, 0xEF, 0x8C, 0x06, 0x14, 0x00, 0x3E, 100);

//  Name:     System.Contact.TTYTDDTelephone -- PKEY_Contact_TTYTDDTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {AAF16BAC-2B55-45E6-9F6D-415EB94910DF}, 100
DEFINE_PROPERTYKEY(PKEY_Contact_TTYTDDTelephone, 0xAAF16BAC, 0x2B55, 0x45E6, 0x9F, 0x6D, 0x41, 0x5E, 0xB9, 0x49, 0x10, 0xDF, 100);

//  Name:     System.Contact.WebPage -- PKEY_Contact_WebPage
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 18
DEFINE_PROPERTYKEY(PKEY_Contact_WebPage, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 18);
 
//-----------------------------------------------------------------------------
// Core properties



//  Name:     System.AcquisitionID -- PKEY_AcquisitionID
//  Type:     Int32 -- VT_I4
//  FormatID: {65A98875-3C80-40AB-ABBC-EFDAF77DBEE2}, 100
//
//  Hash to determine acquisition session.
DEFINE_PROPERTYKEY(PKEY_AcquisitionID, 0x65A98875, 0x3C80, 0x40AB, 0xAB, 0xBC, 0xEF, 0xDA, 0xF7, 0x7D, 0xBE, 0xE2, 100);

//  Name:     System.ApplicationName -- PKEY_ApplicationName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 18 (PIDSI_APPNAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_ApplicationName, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 18);

//  Name:     System.Author -- PKEY_Author
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 4 (PIDSI_AUTHOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Author, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 4);

//  Name:     System.Capacity -- PKEY_Capacity
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 3 (PID_VOLUME_CAPACITY)  (Filesystem Volume Properties)
//
//  The amount of total space in bytes.
DEFINE_PROPERTYKEY(PKEY_Capacity, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 3);

//  Name:     System.Category -- PKEY_Category
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 2 (PIDDSI_CATEGORY)
//
//  Legacy code treats this as VT_LPSTR.
DEFINE_PROPERTYKEY(PKEY_Category, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 2);

//  Name:     System.Comment -- PKEY_Comment
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 6 (PIDSI_COMMENTS)
//
//  Comments.
DEFINE_PROPERTYKEY(PKEY_Comment, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 6);

//  Name:     System.Company -- PKEY_Company
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 15 (PIDDSI_COMPANY)
//
//  The company or publisher.
DEFINE_PROPERTYKEY(PKEY_Company, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 15);

//  Name:     System.ComputerName -- PKEY_ComputerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 5 (PID_COMPUTERNAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_ComputerName, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 5);

//  Name:     System.ContainedItems -- PKEY_ContainedItems
//  Type:     Multivalue Guid -- VT_VECTOR | VT_CLSID  (For variants: VT_ARRAY | VT_CLSID)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 29
//  
//  The list of type of items, this item contains. For example, this item contains urls, attachments etc.
//  This is represented as a vector array of GUIDs where each GUID represents certain type.
DEFINE_PROPERTYKEY(PKEY_ContainedItems, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 29);

//  Name:     System.ContentStatus -- PKEY_ContentStatus
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 27
DEFINE_PROPERTYKEY(PKEY_ContentStatus, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 27);

//  Name:     System.ContentType -- PKEY_ContentType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 26
DEFINE_PROPERTYKEY(PKEY_ContentType, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 26);

//  Name:     System.Copyright -- PKEY_Copyright
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 11 (PIDMSI_COPYRIGHT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Copyright, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 11);

//  Name:     System.DateAccessed -- PKEY_DateAccessed
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 16 (PID_STG_ACCESSTIME)
//
//  The time of the last access to the item.  The Indexing Service friendly name is 'access'.
DEFINE_PROPERTYKEY(PKEY_DateAccessed, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 16);

//  Name:     System.DateAcquired -- PKEY_DateAcquired
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {2CBAA8F5-D81F-47CA-B17A-F8D822300131}, 100
//  
//  The time the file entered the system via acquisition.  This is not the same as System.DateImported.
//  Examples are when pictures are acquired from a camera, or when music is purchased online.
DEFINE_PROPERTYKEY(PKEY_DateAcquired, 0x2CBAA8F5, 0xD81F, 0x47CA, 0xB1, 0x7A, 0xF8, 0xD8, 0x22, 0x30, 0x01, 0x31, 100);

//  Name:     System.DateArchived -- PKEY_DateArchived
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {43F8D7B7-A444-4F87-9383-52271C9B915C}, 100
DEFINE_PROPERTYKEY(PKEY_DateArchived, 0x43F8D7B7, 0xA444, 0x4F87, 0x93, 0x83, 0x52, 0x27, 0x1C, 0x9B, 0x91, 0x5C, 100);

//  Name:     System.DateCompleted -- PKEY_DateCompleted
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {72FAB781-ACDA-43E5-B155-B2434F85E678}, 100
DEFINE_PROPERTYKEY(PKEY_DateCompleted, 0x72FAB781, 0xACDA, 0x43E5, 0xB1, 0x55, 0xB2, 0x43, 0x4F, 0x85, 0xE6, 0x78, 100);

//  Name:     System.DateCreated -- PKEY_DateCreated
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 15 (PID_STG_CREATETIME)
//
//  The date and time the item was created. The Indexing Service friendly name is 'create'.
DEFINE_PROPERTYKEY(PKEY_DateCreated, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 15);

//  Name:     System.DateImported -- PKEY_DateImported
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 18258
//
//  The time the file is imported into a separate database.  This is not the same as System.DateAcquired.  (Eg, 2003:05:22 13:55:04)
DEFINE_PROPERTYKEY(PKEY_DateImported, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 18258);

//  Name:     System.DateModified -- PKEY_DateModified
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 14 (PID_STG_WRITETIME)
//
//  The date and time of the last write to the item. The Indexing Service friendly name is 'write'.
DEFINE_PROPERTYKEY(PKEY_DateModified, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 14);

//  Name:     System.DueDate -- PKEY_DueDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {3F8472B5-E0AF-4DB2-8071-C53FE76AE7CE}, 100
DEFINE_PROPERTYKEY(PKEY_DueDate, 0x3F8472B5, 0xE0AF, 0x4DB2, 0x80, 0x71, 0xC5, 0x3F, 0xE7, 0x6A, 0xE7, 0xCE, 100);

//  Name:     System.EndDate -- PKEY_EndDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {C75FAA05-96FD-49E7-9CB4-9F601082D553}, 100
DEFINE_PROPERTYKEY(PKEY_EndDate, 0xC75FAA05, 0x96FD, 0x49E7, 0x9C, 0xB4, 0x9F, 0x60, 0x10, 0x82, 0xD5, 0x53, 100);

//  Name:     System.FileAllocationSize -- PKEY_FileAllocationSize
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 18 (PID_STG_ALLOCSIZE)
//
//  
DEFINE_PROPERTYKEY(PKEY_FileAllocationSize, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 18);

//  Name:     System.FileAttributes -- PKEY_FileAttributes
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 13 (PID_STG_ATTRIBUTES)
//  
//  This is the WIN32_FIND_DATA dwFileAttributes for the file-based item.
DEFINE_PROPERTYKEY(PKEY_FileAttributes, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 13);

//  Name:     System.FileCount -- PKEY_FileCount
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 12
//
//  
DEFINE_PROPERTYKEY(PKEY_FileCount, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 12);

//  Name:     System.FileDescription -- PKEY_FileDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 3 (PIDVSI_FileDescription)
//  
//  This is a user-friendly description of the file.
DEFINE_PROPERTYKEY(PKEY_FileDescription, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 3);

//  Name:     System.FileExtension -- PKEY_FileExtension
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E4F10A3C-49E6-405D-8288-A23BD4EEAA6C}, 100
//  
//  This is the file extension of the file based item, including the leading period.  
//  
//  If System.FileName is VT_EMPTY, then this property should be too.  Otherwise, it should be derived
//  appropriately by the data source from System.FileName.  If System.FileName does not have a file 
//  extension, this value should be VT_EMPTY.
//  
//  To obtain the type of any item (including an item that is not a file), use System.ItemType.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                ".txt"
//      "\\server\share\mydir\goodnews.doc"   ".doc"
//      "\\server\share\numbers.xls"          ".xls"
//      "\\server\share\folder"               VT_EMPTY
//      "c:\foo\MyFolder"                     VT_EMPTY
//      [desktop]                             VT_EMPTY
DEFINE_PROPERTYKEY(PKEY_FileExtension, 0xE4F10A3C, 0x49E6, 0x405D, 0x82, 0x88, 0xA2, 0x3B, 0xD4, 0xEE, 0xAA, 0x6C, 100);

//  Name:     System.FileFRN -- PKEY_FileFRN
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 21 (PID_STG_FRN)
//  
//  This is the unique file ID, also known as the File Reference Number. For a given file, this is the same value
//  as is found in the structure variable FILE_ID_BOTH_DIR_INFO.FileId, via GetFileInformationByHandleEx().
DEFINE_PROPERTYKEY(PKEY_FileFRN, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 21);

//  Name:     System.FileName -- PKEY_FileName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {41CF5AE0-F75A-4806-BD87-59C7D9248EB9}, 100
//  
//  This is the file name (including extension) of the file.
//  
//  It is possible that the item might not exist on a filesystem (ie, it may not be opened 
//  using CreateFile).  Nonetheless, if the item is represented as a file from the logical sense 
//  (and its name follows standard Win32 file-naming syntax), then the data source should emit this property.
//  
//  If an item is not a file, then the value for this property is VT_EMPTY.  See 
//  System.ItemNameDisplay.
//  
//  This has the same value as System.ParsingName for items that are provided by the Shell's file folder.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "hello.txt"
//      "\\server\share\mydir\goodnews.doc"   "goodnews.doc"
//      "\\server\share\numbers.xls"          "numbers.xls"
//      "c:\foo\MyFolder"                     "MyFolder"
//      (email message)                       VT_EMPTY
//      (song on portable device)             "song.wma"
DEFINE_PROPERTYKEY(PKEY_FileName, 0x41CF5AE0, 0xF75A, 0x4806, 0xBD, 0x87, 0x59, 0xC7, 0xD9, 0x24, 0x8E, 0xB9, 100);

//  Name:     System.FileOwner -- PKEY_FileOwner
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Misc) {9B174B34-40FF-11D2-A27E-00C04FC30871}, 4 (PID_MISC_OWNER)
//  
//  This is the owner of the file, according to the file system.
DEFINE_PROPERTYKEY(PKEY_FileOwner, 0x9B174B34, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 4);

//  Name:     System.FileVersion -- PKEY_FileVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 4 (PIDVSI_FileVersion)
//
//  
DEFINE_PROPERTYKEY(PKEY_FileVersion, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 4);

//  Name:     System.FindData -- PKEY_FindData
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 0 (PID_FINDDATA)
//
//  WIN32_FIND_DATAW in buffer of bytes.
DEFINE_PROPERTYKEY(PKEY_FindData, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 0);

//  Name:     System.FlagColor -- PKEY_FlagColor
//  Type:     UInt16 -- VT_UI2
//  FormatID: {67DF94DE-0CA7-4D6F-B792-053A3E4F03CF}, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_FlagColor, 0x67DF94DE, 0x0CA7, 0x4D6F, 0xB7, 0x92, 0x05, 0x3A, 0x3E, 0x4F, 0x03, 0xCF, 100);

// Possible discrete values for PKEY_FlagColor are:
#define FLAGCOLOR_PURPLE                    1u
#define FLAGCOLOR_ORANGE                    2u
#define FLAGCOLOR_GREEN                     3u
#define FLAGCOLOR_YELLOW                    4u
#define FLAGCOLOR_BLUE                      5u
#define FLAGCOLOR_RED                       6u

//  Name:     System.FlagColorText -- PKEY_FlagColorText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {45EAE747-8E2A-40AE-8CBF-CA52ABA6152A}, 100
//  
//  This is the user-friendly form of System.FlagColor.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_FlagColorText, 0x45EAE747, 0x8E2A, 0x40AE, 0x8C, 0xBF, 0xCA, 0x52, 0xAB, 0xA6, 0x15, 0x2A, 100);

//  Name:     System.FlagStatus -- PKEY_FlagStatus
//  Type:     Int32 -- VT_I4
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 12
//
//  Status of Flag.  Values: (0=none 1=white 2=Red).  cdoPR_FLAG_STATUS
DEFINE_PROPERTYKEY(PKEY_FlagStatus, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 12);

// Possible discrete values for PKEY_FlagStatus are:
#define FLAGSTATUS_NOTFLAGGED               0l
#define FLAGSTATUS_COMPLETED                1l
#define FLAGSTATUS_FOLLOWUP                 2l

//  Name:     System.FlagStatusText -- PKEY_FlagStatusText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DC54FD2E-189D-4871-AA01-08C2F57A4ABC}, 100
//  
//  This is the user-friendly form of System.FlagStatus.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_FlagStatusText, 0xDC54FD2E, 0x189D, 0x4871, 0xAA, 0x01, 0x08, 0xC2, 0xF5, 0x7A, 0x4A, 0xBC, 100);

//  Name:     System.FreeSpace -- PKEY_FreeSpace
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 2 (PID_VOLUME_FREE)  (Filesystem Volume Properties)
//
//  The amount of free space in bytes.
DEFINE_PROPERTYKEY(PKEY_FreeSpace, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 2);

//  Name:     System.FullText -- PKEY_FullText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {1E3EE840-BC2B-476C-8237-2ACD1A839B22}, 6
//  
//  This PKEY is used to specify search terms that should be applied as broadly as possible,
//  across all valid properties for the data source(s) being searched.  It should not be
//  emitted from a data source.
DEFINE_PROPERTYKEY(PKEY_FullText, 0x1E3EE840, 0xBC2B, 0x476C, 0x82, 0x37, 0x2A, 0xCD, 0x1A, 0x83, 0x9B, 0x22, 6);

//  Name:     System.Identity -- PKEY_Identity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A26F4AFC-7346-4299-BE47-EB1AE613139F}, 100
DEFINE_PROPERTYKEY(PKEY_Identity, 0xA26F4AFC, 0x7346, 0x4299, 0xBE, 0x47, 0xEB, 0x1A, 0xE6, 0x13, 0x13, 0x9F, 100);

//  Name:     System.Identity.Blob -- PKEY_Identity_Blob
//  Type:     Blob -- VT_BLOB
//  FormatID: {8C3B93A4-BAED-1A83-9A32-102EE313F6EB}, 100
//
//  Blob used to import/export identities
DEFINE_PROPERTYKEY(PKEY_Identity_Blob, 0x8C3B93A4, 0xBAED, 0x1A83, 0x9A, 0x32, 0x10, 0x2E, 0xE3, 0x13, 0xF6, 0xEB, 100);

//  Name:     System.Identity.DisplayName -- PKEY_Identity_DisplayName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7D683FC9-D155-45A8-BB1F-89D19BCB792F}, 100
//
//  Display Name
DEFINE_PROPERTYKEY(PKEY_Identity_DisplayName, 0x7D683FC9, 0xD155, 0x45A8, 0xBB, 0x1F, 0x89, 0xD1, 0x9B, 0xCB, 0x79, 0x2F, 100);

//  Name:     System.Identity.IsMeIdentity -- PKEY_Identity_IsMeIdentity
//  Type:     Boolean -- VT_BOOL
//  FormatID: {A4108708-09DF-4377-9DFC-6D99986D5A67}, 100
//
//  Is it Me Identity
DEFINE_PROPERTYKEY(PKEY_Identity_IsMeIdentity, 0xA4108708, 0x09DF, 0x4377, 0x9D, 0xFC, 0x6D, 0x99, 0x98, 0x6D, 0x5A, 0x67, 100);

//  Name:     System.Identity.PrimaryEmailAddress -- PKEY_Identity_PrimaryEmailAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FCC16823-BAED-4F24-9B32-A0982117F7FA}, 100
//
//  Primary Email Address
DEFINE_PROPERTYKEY(PKEY_Identity_PrimaryEmailAddress, 0xFCC16823, 0xBAED, 0x4F24, 0x9B, 0x32, 0xA0, 0x98, 0x21, 0x17, 0xF7, 0xFA, 100);

//  Name:     System.Identity.ProviderID -- PKEY_Identity_ProviderID
//  Type:     Guid -- VT_CLSID
//  FormatID: {74A7DE49-FA11-4D3D-A006-DB7E08675916}, 100
//
//  Provider ID
DEFINE_PROPERTYKEY(PKEY_Identity_ProviderID, 0x74A7DE49, 0xFA11, 0x4D3D, 0xA0, 0x06, 0xDB, 0x7E, 0x08, 0x67, 0x59, 0x16, 100);

//  Name:     System.Identity.UniqueID -- PKEY_Identity_UniqueID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E55FC3B0-2B60-4220-918E-B21E8BF16016}, 100
//
//  Unique ID
DEFINE_PROPERTYKEY(PKEY_Identity_UniqueID, 0xE55FC3B0, 0x2B60, 0x4220, 0x91, 0x8E, 0xB2, 0x1E, 0x8B, 0xF1, 0x60, 0x16, 100);

//  Name:     System.Identity.UserName -- PKEY_Identity_UserName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C4322503-78CA-49C6-9ACC-A68E2AFD7B6B}, 100
//
//  Identity User Name
DEFINE_PROPERTYKEY(PKEY_Identity_UserName, 0xC4322503, 0x78CA, 0x49C6, 0x9A, 0xCC, 0xA6, 0x8E, 0x2A, 0xFD, 0x7B, 0x6B, 100);

//  Name:     System.IdentityProvider.Name -- PKEY_IdentityProvider_Name
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {B96EFF7B-35CA-4A35-8607-29E3A54C46EA}, 100
//
//  Identity Provider Name
DEFINE_PROPERTYKEY(PKEY_IdentityProvider_Name, 0xB96EFF7B, 0x35CA, 0x4A35, 0x86, 0x07, 0x29, 0xE3, 0xA5, 0x4C, 0x46, 0xEA, 100);

//  Name:     System.IdentityProvider.Picture -- PKEY_IdentityProvider_Picture
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {2425166F-5642-4864-992F-98FD98F294C3}, 100
//
//  Picture for the Identity Provider
DEFINE_PROPERTYKEY(PKEY_IdentityProvider_Picture, 0x2425166F, 0x5642, 0x4864, 0x99, 0x2F, 0x98, 0xFD, 0x98, 0xF2, 0x94, 0xC3, 100);

//  Name:     System.ImageParsingName -- PKEY_ImageParsingName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D7750EE0-C6A4-48EC-B53E-B87B52E6D073}, 100
DEFINE_PROPERTYKEY(PKEY_ImageParsingName, 0xD7750EE0, 0xC6A4, 0x48EC, 0xB5, 0x3E, 0xB8, 0x7B, 0x52, 0xE6, 0xD0, 0x73, 100);

//  Name:     System.Importance -- PKEY_Importance
//  Type:     Int32 -- VT_I4
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 11
DEFINE_PROPERTYKEY(PKEY_Importance, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 11);

// Possible range of values for PKEY_Importance are:
#define IMPORTANCE_LOW_MIN                  0l
#define IMPORTANCE_LOW_SET                  1l
#define IMPORTANCE_LOW_MAX                  1l

#define IMPORTANCE_NORMAL_MIN               2l
#define IMPORTANCE_NORMAL_SET               3l
#define IMPORTANCE_NORMAL_MAX               4l

#define IMPORTANCE_HIGH_MIN                 5l
#define IMPORTANCE_HIGH_SET                 5l
#define IMPORTANCE_HIGH_MAX                 5l


//  Name:     System.ImportanceText -- PKEY_ImportanceText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A3B29791-7713-4E1D-BB40-17DB85F01831}, 100
//  
//  This is the user-friendly form of System.Importance.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_ImportanceText, 0xA3B29791, 0x7713, 0x4E1D, 0xBB, 0x40, 0x17, 0xDB, 0x85, 0xF0, 0x18, 0x31, 100);

//  Name:     System.IsAttachment -- PKEY_IsAttachment
//  Type:     Boolean -- VT_BOOL
//  FormatID: {F23F425C-71A1-4FA8-922F-678EA4A60408}, 100
//
//  Identifies if this item is an attachment.
DEFINE_PROPERTYKEY(PKEY_IsAttachment, 0xF23F425C, 0x71A1, 0x4FA8, 0x92, 0x2F, 0x67, 0x8E, 0xA4, 0xA6, 0x04, 0x08, 100);

//  Name:     System.IsDefaultNonOwnerSaveLocation -- PKEY_IsDefaultNonOwnerSaveLocation
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 5
//
//  Identifies the default save location for a library for non-owners of the library
DEFINE_PROPERTYKEY(PKEY_IsDefaultNonOwnerSaveLocation, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 5);

//  Name:     System.IsDefaultSaveLocation -- PKEY_IsDefaultSaveLocation
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 3
//
//  Identifies the default save location for a library for the owner of the library
DEFINE_PROPERTYKEY(PKEY_IsDefaultSaveLocation, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 3);

//  Name:     System.IsDeleted -- PKEY_IsDeleted
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5CDA5FC8-33EE-4FF3-9094-AE7BD8868C4D}, 100
DEFINE_PROPERTYKEY(PKEY_IsDeleted, 0x5CDA5FC8, 0x33EE, 0x4FF3, 0x90, 0x94, 0xAE, 0x7B, 0xD8, 0x86, 0x8C, 0x4D, 100);

//  Name:     System.IsEncrypted -- PKEY_IsEncrypted
//  Type:     Boolean -- VT_BOOL
//  FormatID: {90E5E14E-648B-4826-B2AA-ACAF790E3513}, 10
//
//  Is the item encrypted?
DEFINE_PROPERTYKEY(PKEY_IsEncrypted, 0x90E5E14E, 0x648B, 0x4826, 0xB2, 0xAA, 0xAC, 0xAF, 0x79, 0x0E, 0x35, 0x13, 10);

//  Name:     System.IsFlagged -- PKEY_IsFlagged
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5DA84765-E3FF-4278-86B0-A27967FBDD03}, 100
DEFINE_PROPERTYKEY(PKEY_IsFlagged, 0x5DA84765, 0xE3FF, 0x4278, 0x86, 0xB0, 0xA2, 0x79, 0x67, 0xFB, 0xDD, 0x03, 100);

//  Name:     System.IsFlaggedComplete -- PKEY_IsFlaggedComplete
//  Type:     Boolean -- VT_BOOL
//  FormatID: {A6F360D2-55F9-48DE-B909-620E090A647C}, 100
DEFINE_PROPERTYKEY(PKEY_IsFlaggedComplete, 0xA6F360D2, 0x55F9, 0x48DE, 0xB9, 0x09, 0x62, 0x0E, 0x09, 0x0A, 0x64, 0x7C, 100);

//  Name:     System.IsIncomplete -- PKEY_IsIncomplete
//  Type:     Boolean -- VT_BOOL
//  FormatID: {346C8BD1-2E6A-4C45-89A4-61B78E8E700F}, 100
//
//  Identifies if the message was not completely received for some error condition.
DEFINE_PROPERTYKEY(PKEY_IsIncomplete, 0x346C8BD1, 0x2E6A, 0x4C45, 0x89, 0xA4, 0x61, 0xB7, 0x8E, 0x8E, 0x70, 0x0F, 100);

//  Name:     System.IsLocationSupported -- PKEY_IsLocationSupported
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 8
//
//  A bool value to know if a location is supported (locally indexable, or remotely indexed).
DEFINE_PROPERTYKEY(PKEY_IsLocationSupported, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 8);

//  Name:     System.IsPinnedToNameSpaceTree -- PKEY_IsPinnedToNameSpaceTree
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 2
//
//  A bool value to know if a shell folder is pinned to the navigation pane
DEFINE_PROPERTYKEY(PKEY_IsPinnedToNameSpaceTree, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 2);

//  Name:     System.IsRead -- PKEY_IsRead
//  Type:     Boolean -- VT_BOOL
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 10
//
//  Has the item been read?
DEFINE_PROPERTYKEY(PKEY_IsRead, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 10);

//  Name:     System.IsSearchOnlyItem -- PKEY_IsSearchOnlyItem
//  Type:     Boolean -- VT_BOOL
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 4
//
//  Identifies if a location or a library is search only
DEFINE_PROPERTYKEY(PKEY_IsSearchOnlyItem, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 4);

//  Name:     System.IsSendToTarget -- PKEY_IsSendToTarget
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 33
//
//  Provided by certain shell folders. Return TRUE if the folder is a valid Send To target.
DEFINE_PROPERTYKEY(PKEY_IsSendToTarget, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 33);

//  Name:     System.IsShared -- PKEY_IsShared
//  Type:     Boolean -- VT_BOOL
//  FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 100
//
//  Is this item shared?  This only checks for ACLs that are not inherited.
DEFINE_PROPERTYKEY(PKEY_IsShared, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 100);

//  Name:     System.ItemAuthors -- PKEY_ItemAuthors
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D0A04F0A-462A-48A4-BB2F-3706E88DBD7D}, 100
//  
//  This is the generic list of authors associated with an item. 
//  
//  For example, the artist name for a track is the item author.
DEFINE_PROPERTYKEY(PKEY_ItemAuthors, 0xD0A04F0A, 0x462A, 0x48A4, 0xBB, 0x2F, 0x37, 0x06, 0xE8, 0x8D, 0xBD, 0x7D, 100);

//  Name:     System.ItemClassType -- PKEY_ItemClassType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {048658AD-2DB8-41A4-BBB6-AC1EF1207EB1}, 100
DEFINE_PROPERTYKEY(PKEY_ItemClassType, 0x048658AD, 0x2DB8, 0x41A4, 0xBB, 0xB6, 0xAC, 0x1E, 0xF1, 0x20, 0x7E, 0xB1, 100);

//  Name:     System.ItemDate -- PKEY_ItemDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {F7DB74B4-4287-4103-AFBA-F1B13DCD75CF}, 100
//  
//  This is the main date for an item. The date of interest. 
//  
//  For example, for photos this maps to System.Photo.DateTaken.
DEFINE_PROPERTYKEY(PKEY_ItemDate, 0xF7DB74B4, 0x4287, 0x4103, 0xAF, 0xBA, 0xF1, 0xB1, 0x3D, 0xCD, 0x75, 0xCF, 100);

//  Name:     System.ItemFolderNameDisplay -- PKEY_ItemFolderNameDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 2 (PID_STG_DIRECTORY)
//  
//  This is the user-friendly display name of the parent folder of an item.
//  
//  If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it 
//  should be derived appropriately by the data source from System.ItemFolderPathDisplay.
//  
//  If the folder is a file folder, the value will be localized if a localized name is available.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "bar"
//      "\\server\share\mydir\goodnews.doc"   "mydir"
//      "\\server\share\numbers.xls"          "share"
//      "c:\foo\MyFolder"                     "foo"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Inbox"
DEFINE_PROPERTYKEY(PKEY_ItemFolderNameDisplay, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 2);

//  Name:     System.ItemFolderPathDisplay -- PKEY_ItemFolderPathDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 6
//  
//  This is the user-friendly display path of the parent folder of an item.
//  
//  If System.ItemPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it should 
//  be derived appropriately by the data source from System.ItemPathDisplay.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "c:\foo\bar"
//      "\\server\share\mydir\goodnews.doc"   "\\server\share\mydir"
//      "\\server\share\numbers.xls"          "\\server\share"
//      "c:\foo\MyFolder"                     "c:\foo"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox Account/Inbox"
DEFINE_PROPERTYKEY(PKEY_ItemFolderPathDisplay, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 6);

//  Name:     System.ItemFolderPathDisplayNarrow -- PKEY_ItemFolderPathDisplayNarrow
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DABD30ED-0043-4789-A7F8-D013A4736622}, 100
//  
//  This is the user-friendly display path of the parent folder of an item.  The format of the string
//  should be tailored such that the folder name comes first, to optimize for a narrow viewing column.
//  
//  If the folder is a file folder, the value includes localized names if they are present.
//  
//  If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it should
//  be derived appropriately by the data source from System.ItemFolderPathDisplay.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "bar (c:\foo)"
//      "\\server\share\mydir\goodnews.doc"   "mydir (\\server\share)"
//      "\\server\share\numbers.xls"          "share (\\server)"
//      "c:\foo\MyFolder"                     "foo (c:\)"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Inbox (/Mailbox Account)"
DEFINE_PROPERTYKEY(PKEY_ItemFolderPathDisplayNarrow, 0xDABD30ED, 0x0043, 0x4789, 0xA7, 0xF8, 0xD0, 0x13, 0xA4, 0x73, 0x66, 0x22, 100);

//  Name:     System.ItemName -- PKEY_ItemName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6B8DA074-3B5C-43BC-886F-0A2CDCE00B6F}, 100
//  
//  This is the base-name of the System.ItemNameDisplay.
//  
//  If the item is a file this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  If the item is a message, then the value of this property does not include the forwarding or
//  reply prefixes (see System.ItemNamePrefix).
DEFINE_PROPERTYKEY(PKEY_ItemName, 0x6B8DA074, 0x3B5C, 0x43BC, 0x88, 0x6F, 0x0A, 0x2C, 0xDC, 0xE0, 0x0B, 0x6F, 100);

//  Name:     System.ItemNameDisplay -- PKEY_ItemNameDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 10 (PID_STG_NAME)
//  
//  This is the display name in "most complete" form.  This is the best effort unique representation
//  of the name of an item that makes sense for end users to read.  It is the concatentation of
//  System.ItemNamePrefix and System.ItemName.
//  
//  If the item is a file this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  There are acceptable cases when System.FileName is not VT_EMPTY, yet the value of this property 
//  is completely different.  Email messages are a key example.  If the item is an email message, 
//  the item name is likely the subject.  In that case, the value must be the concatenation of the
//  System.ItemNamePrefix and System.ItemName.  Since the value of System.ItemNamePrefix excludes
//  any trailing whitespace, the concatenation must include a whitespace when generating System.ItemNameDisplay.
//  
//  Note that this property is not guaranteed to be unique, but the idea is to promote the most likely
//  candidate that can be unique and also makes sense for end users. For example, for documents, you
//  might think about using System.Title as the System.ItemNameDisplay, but in practice the title of
//  the documents may not be useful or unique enough to be of value as the sole System.ItemNameDisplay.  
//  Instead, providing the value of System.FileName as the value of System.ItemNameDisplay is a better
//  candidate.  In Windows Mail, the emails are stored in the file system as .eml files and the 
//  System.FileName for those files are not human-friendly as they contain GUIDs. In this example, 
//  promoting System.Subject as System.ItemNameDisplay makes more sense.
//  
//  Compatibility notes:
//  
//  Shell folder implementations on Vista: use PKEY_ItemNameDisplay for the name column when
//  you want Explorer to call ISF::GetDisplayNameOf(SHGDN_NORMAL) to get the value of the name. Use
//  another PKEY (like PKEY_ItemName) when you want Explorer to call either the folder's property store or
//  ISF2::GetDetailsEx in order to get the value of the name.
//  
//  Shell folder implementations on XP: the first column needs to be the name column, and Explorer
//  will call ISF::GetDisplayNameOf to get the value of the name.  The PKEY/SCID does not matter.
//  
//  Example values:
//  
//      File:          "hello.txt"
//      Message:       "Re: Let's talk about Tom's argyle socks!"
//      Device folder: "song.wma"
//      Folder:        "Documents"
DEFINE_PROPERTYKEY(PKEY_ItemNameDisplay, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 10);

//  Name:     System.ItemNamePrefix -- PKEY_ItemNamePrefix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D7313FF1-A77A-401C-8C99-3DBDD68ADD36}, 100
//  
//  This is the prefix of an item, used for email messages.
//  where the subject begins with "Re:" which is the prefix.
//  
//  If the item is a file, then the value of this property is VT_EMPTY.
//  
//  If the item is a message, then the value of this property is the forwarding or reply 
//  prefixes (including delimiting colon, but no whitespace), or VT_EMPTY if there is no prefix.
//  
//  Example values:
//  
//  System.ItemNamePrefix    System.ItemName      System.ItemNameDisplay
//  ---------------------    -------------------  ----------------------
//  VT_EMPTY                 "Great day"          "Great day"
//  "Re:"                    "Great day"          "Re: Great day"
//  "Fwd: "                  "Monthly budget"     "Fwd: Monthly budget"
//  VT_EMPTY                 "accounts.xls"       "accounts.xls"
DEFINE_PROPERTYKEY(PKEY_ItemNamePrefix, 0xD7313FF1, 0xA77A, 0x401C, 0x8C, 0x99, 0x3D, 0xBD, 0xD6, 0x8A, 0xDD, 0x36, 100);

//  Name:     System.ItemParticipants -- PKEY_ItemParticipants
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D4D0AA16-9948-41A4-AA85-D97FF9646993}, 100
//  
//  This is the generic list of people associated with an item and who contributed 
//  to the item. 
//  
//  For example, this is the combination of people in the To list, Cc list and 
//  sender of an email message.
DEFINE_PROPERTYKEY(PKEY_ItemParticipants, 0xD4D0AA16, 0x9948, 0x41A4, 0xAA, 0x85, 0xD9, 0x7F, 0xF9, 0x64, 0x69, 0x93, 100);

//  Name:     System.ItemPathDisplay -- PKEY_ItemPathDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 7
//  
//  This is the user-friendly display path to the item.
//  
//  If the item is a file or folder this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  For other items,this is the user-friendly equivalent, assuming the item exists in hierarchical storage.
//  
//  Unlike System.ItemUrl, this property value does not include the URL scheme.
//  
//  To parse an item path, use System.ItemUrl or System.ParsingPath.  To reference shell 
//  namespace items using shell APIs, use System.ParsingPath.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "c:\foo\bar\hello.txt"
//      "\\server\share\mydir\goodnews.doc"   "\\server\share\mydir\goodnews.doc"
//      "\\server\share\numbers.xls"          "\\server\share\numbers.xls"
//      "c:\foo\MyFolder"                     "c:\foo\MyFolder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox Account/Inbox/'Re: Hello!'"
DEFINE_PROPERTYKEY(PKEY_ItemPathDisplay, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 7);

//  Name:     System.ItemPathDisplayNarrow -- PKEY_ItemPathDisplayNarrow
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 8
//  
//  This is the user-friendly display path to the item. The format of the string should be 
//  tailored such that the name comes first, to optimize for a narrow viewing column.
//  
//  If the item is a file, the value excludes the file extension, and includes localized names if they are present.
//  If the item is a message, the value includes the System.ItemNamePrefix.
//  
//  To parse an item path, use System.ItemUrl or System.ParsingPath.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "hello (c:\foo\bar)"
//      "\\server\share\mydir\goodnews.doc"   "goodnews (\\server\share\mydir)"
//      "\\server\share\folder"               "folder (\\server\share)"
//      "c:\foo\MyFolder"                     "MyFolder (c:\foo)"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Re: Hello! (/Mailbox Account/Inbox)"
DEFINE_PROPERTYKEY(PKEY_ItemPathDisplayNarrow, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 8);

//  Name:     System.ItemType -- PKEY_ItemType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 11
//  
//  This is the canonical type of the item and is intended to be programmatically
//  parsed.
//  
//  If there is no canonical type, the value is VT_EMPTY.
//  
//  If the item is a file (ie, System.FileName is not VT_EMPTY), the value is the same as
//  System.FileExtension.
//  
//  Use System.ItemTypeText when you want to display the type to end users in a view.  (If
//   the item is a file, passing the System.ItemType value to PSFormatForDisplay will
//   result in the same value as System.ItemTypeText.)
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                ".txt"
//      "\\server\share\mydir\goodnews.doc"   ".doc"
//      "\\server\share\folder"               "Directory"
//      "c:\foo\MyFolder"                     "Directory"
//      [desktop]                             "Folder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "MAPI/IPM.Message"
DEFINE_PROPERTYKEY(PKEY_ItemType, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 11);

//  Name:     System.ItemTypeText -- PKEY_ItemTypeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 4 (PID_STG_STORAGETYPE)
//  
//  This is the user friendly type name of the item.  This is not intended to be
//  programmatically parsed.
//  
//  If System.ItemType is VT_EMPTY, the value of this property is also VT_EMPTY.
//  
//  If the item is a file, the value of this property is the same as if you passed the 
//  file's System.ItemType value to PSFormatForDisplay.
//  
//  This property should not be confused with System.Kind, where System.Kind is a high-level
//  user friendly kind name. For example, for a document, System.Kind = "Document" and 
//  System.Item.Type = ".doc" and System.Item.TypeText = "Microsoft Word Document"
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "Text File"
//      "\\server\share\mydir\goodnews.doc"   "Microsoft Word Document"
//      "\\server\share\folder"               "File Folder"
//      "c:\foo\MyFolder"                     "File Folder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Outlook E-Mail Message"
DEFINE_PROPERTYKEY(PKEY_ItemTypeText, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 4);

//  Name:     System.ItemUrl -- PKEY_ItemUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 9 (DISPID_QUERY_VIRTUALPATH)
//  
//  This always represents a well formed URL that points to the item.  
//  
//  To reference shell namespace items using shell APIs, use System.ParsingPath.
//  
//  Example values:
//  
//      Files:    "file:///c:/foo/bar/hello.txt"
//                "csc://{GUID}/..."
//      Messages: "mapi://..."
DEFINE_PROPERTYKEY(PKEY_ItemUrl, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 9);

//  Name:     System.Keywords -- PKEY_Keywords
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 5 (PIDSI_KEYWORDS)
//
//  The keywords for the item.  Also referred to as tags.
DEFINE_PROPERTYKEY(PKEY_Keywords, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 5);

//  Name:     System.Kind -- PKEY_Kind
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {1E3EE840-BC2B-476C-8237-2ACD1A839B22}, 3
//  
//  System.Kind is used to map extensions to various .Search folders.
//  Extensions are mapped to Kinds at HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\KindMap
//  The list of kinds is not extensible.
DEFINE_PROPERTYKEY(PKEY_Kind, 0x1E3EE840, 0xBC2B, 0x476C, 0x82, 0x37, 0x2A, 0xCD, 0x1A, 0x83, 0x9B, 0x22, 3);

// Possible discrete values for PKEY_Kind are:
#define KIND_CALENDAR                       L"calendar"
#define KIND_COMMUNICATION                  L"communication"
#define KIND_CONTACT                        L"contact"
#define KIND_DOCUMENT                       L"document"
#define KIND_EMAIL                          L"email"
#define KIND_FEED                           L"feed"
#define KIND_FOLDER                         L"folder"
#define KIND_GAME                           L"game"
#define KIND_INSTANTMESSAGE                 L"instantmessage"
#define KIND_JOURNAL                        L"journal"
#define KIND_LINK                           L"link"
#define KIND_MOVIE                          L"movie"
#define KIND_MUSIC                          L"music"
#define KIND_NOTE                           L"note"
#define KIND_PICTURE                        L"picture"
#define KIND_PROGRAM                        L"program"
#define KIND_RECORDEDTV                     L"recordedtv"
#define KIND_SEARCHFOLDER                   L"searchfolder"
#define KIND_TASK                           L"task"
#define KIND_VIDEO                          L"video"
#define KIND_WEBHISTORY                     L"webhistory"

//  Name:     System.KindText -- PKEY_KindText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F04BEF95-C585-4197-A2B7-DF46FDC9EE6D}, 100
//  
//  This is the user-friendly form of System.Kind.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_KindText, 0xF04BEF95, 0xC585, 0x4197, 0xA2, 0xB7, 0xDF, 0x46, 0xFD, 0xC9, 0xEE, 0x6D, 100);

//  Name:     System.Language -- PKEY_Language
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 28
//
//  
DEFINE_PROPERTYKEY(PKEY_Language, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 28);

//  Name:     System.MileageInformation -- PKEY_MileageInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FDF84370-031A-4ADD-9E91-0D775F1C6605}, 100
DEFINE_PROPERTYKEY(PKEY_MileageInformation, 0xFDF84370, 0x031A, 0x4ADD, 0x9E, 0x91, 0x0D, 0x77, 0x5F, 0x1C, 0x66, 0x05, 100);

//  Name:     System.MIMEType -- PKEY_MIMEType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0B63E350-9CCC-11D0-BCDB-00805FCCCE04}, 5
//
//  The MIME type.  Eg, for EML files: 'message/rfc822'.
DEFINE_PROPERTYKEY(PKEY_MIMEType, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 5);

//  Name:     System.Null -- PKEY_Null
//  Type:     Null -- VT_NULL
//  FormatID: {00000000-0000-0000-0000-000000000000}, 0
DEFINE_PROPERTYKEY(PKEY_Null, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0);

//  Name:     System.OfflineAvailability -- PKEY_OfflineAvailability
//  Type:     UInt32 -- VT_UI4
//  FormatID: {A94688B6-7D9F-4570-A648-E3DFC0AB2B3F}, 100
DEFINE_PROPERTYKEY(PKEY_OfflineAvailability, 0xA94688B6, 0x7D9F, 0x4570, 0xA6, 0x48, 0xE3, 0xDF, 0xC0, 0xAB, 0x2B, 0x3F, 100);

// Possible discrete values for PKEY_OfflineAvailability are:
#define OFFLINEAVAILABILITY_NOT_AVAILABLE   0ul
#define OFFLINEAVAILABILITY_AVAILABLE       1ul
#define OFFLINEAVAILABILITY_ALWAYS_AVAILABLE 2ul

//  Name:     System.OfflineStatus -- PKEY_OfflineStatus
//  Type:     UInt32 -- VT_UI4
//  FormatID: {6D24888F-4718-4BDA-AFED-EA0FB4386CD8}, 100
DEFINE_PROPERTYKEY(PKEY_OfflineStatus, 0x6D24888F, 0x4718, 0x4BDA, 0xAF, 0xED, 0xEA, 0x0F, 0xB4, 0x38, 0x6C, 0xD8, 100);

// Possible discrete values for PKEY_OfflineStatus are:
#define OFFLINESTATUS_ONLINE                0ul
#define OFFLINESTATUS_OFFLINE               1ul
#define OFFLINESTATUS_OFFLINE_FORCED        2ul
#define OFFLINESTATUS_OFFLINE_SLOW          3ul
#define OFFLINESTATUS_OFFLINE_ERROR         4ul
#define OFFLINESTATUS_OFFLINE_ITEM_VERSION_CONFLICT 5ul
#define OFFLINESTATUS_OFFLINE_SUSPENDED     6ul

//  Name:     System.OriginalFileName -- PKEY_OriginalFileName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 6
//  
//  
DEFINE_PROPERTYKEY(PKEY_OriginalFileName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 6);

//  Name:     System.OwnerSID -- PKEY_OwnerSID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 6
//
//  SID of the user that owns the library.
DEFINE_PROPERTYKEY(PKEY_OwnerSID, 0x5D76B67F, 0x9B3D, 0x44BB, 0xB6, 0xAE, 0x25, 0xDA, 0x4F, 0x63, 0x8A, 0x67, 6);

//  Name:     System.ParentalRating -- PKEY_ParentalRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 21 (PIDMSI_PARENTAL_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ParentalRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 21);

//  Name:     System.ParentalRatingReason -- PKEY_ParentalRatingReason
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {10984E0A-F9F2-4321-B7EF-BAF195AF4319}, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingReason, 0x10984E0A, 0xF9F2, 0x4321, 0xB7, 0xEF, 0xBA, 0xF1, 0x95, 0xAF, 0x43, 0x19, 100);

//  Name:     System.ParentalRatingsOrganization -- PKEY_ParentalRatingsOrganization
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A7FE0840-1344-46F0-8D37-52ED712A4BF9}, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingsOrganization, 0xA7FE0840, 0x1344, 0x46F0, 0x8D, 0x37, 0x52, 0xED, 0x71, 0x2A, 0x4B, 0xF9, 100);

//  Name:     System.ParsingBindContext -- PKEY_ParsingBindContext
//  Type:     Any -- VT_NULL  Legacy code may treat this as VT_UNKNOWN.
//  FormatID: {DFB9A04D-362F-4CA3-B30B-0254B17B5B84}, 100
//  
//  used to get the IBindCtx for an item for parsing
DEFINE_PROPERTYKEY(PKEY_ParsingBindContext, 0xDFB9A04D, 0x362F, 0x4CA3, 0xB3, 0x0B, 0x02, 0x54, 0xB1, 0x7B, 0x5B, 0x84, 100);

//  Name:     System.ParsingName -- PKEY_ParsingName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 24
//  
//  The shell namespace name of an item relative to a parent folder.  This name may be passed to 
//  IShellFolder::ParseDisplayName() of the parent shell folder.
DEFINE_PROPERTYKEY(PKEY_ParsingName, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 24);

//  Name:     System.ParsingPath -- PKEY_ParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 30
//  
//  This is the shell namespace path to the item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_ParsingPath, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 30);

//  Name:     System.PerceivedType -- PKEY_PerceivedType
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 9
//
//  The perceived type of a shell item, based upon its canonical type.
DEFINE_PROPERTYKEY(PKEY_PerceivedType, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 9);

// For the enumerated values of PKEY_PerceivedType, see the PERCEIVED_TYPE_* values in shtypes.idl.

//  Name:     System.PercentFull -- PKEY_PercentFull
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 5  (Filesystem Volume Properties)
//
//  The amount filled as a percentage, multiplied by 100 (ie, the valid range is 0 through 100).
DEFINE_PROPERTYKEY(PKEY_PercentFull, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 5);

//  Name:     System.Priority -- PKEY_Priority
//  Type:     UInt16 -- VT_UI2
//  FormatID: {9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4}, 5
//
//  
DEFINE_PROPERTYKEY(PKEY_Priority, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 5);

// Possible discrete values for PKEY_Priority are:
#define PRIORITY_PROP_LOW                   0u
#define PRIORITY_PROP_NORMAL                1u
#define PRIORITY_PROP_HIGH                  2u

//  Name:     System.PriorityText -- PKEY_PriorityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D98BE98B-B86B-4095-BF52-9D23B2E0A752}, 100
//  
//  This is the user-friendly form of System.Priority.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_PriorityText, 0xD98BE98B, 0xB86B, 0x4095, 0xBF, 0x52, 0x9D, 0x23, 0xB2, 0xE0, 0xA7, 0x52, 100);

//  Name:     System.Project -- PKEY_Project
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {39A7F922-477C-48DE-8BC8-B28441E342E3}, 100
DEFINE_PROPERTYKEY(PKEY_Project, 0x39A7F922, 0x477C, 0x48DE, 0x8B, 0xC8, 0xB2, 0x84, 0x41, 0xE3, 0x42, 0xE3, 100);

//  Name:     System.ProviderItemID -- PKEY_ProviderItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F21D9941-81F0-471A-ADEE-4E74B49217ED}, 100
//  
//  
DEFINE_PROPERTYKEY(PKEY_ProviderItemID, 0xF21D9941, 0x81F0, 0x471A, 0xAD, 0xEE, 0x4E, 0x74, 0xB4, 0x92, 0x17, 0xED, 100);

//  Name:     System.Rating -- PKEY_Rating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 9 (PIDMSI_RATING)
//  
//  Indicates the users preference rating of an item on a scale of 1-99 (1-12 = One Star, 
//  13-37 = Two Stars, 38-62 = Three Stars, 63-87 = Four Stars, 88-99 = Five Stars).
DEFINE_PROPERTYKEY(PKEY_Rating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

// Use the following constants to convert between visual stars and the ratings value:
#define RATING_ONE_STAR_MIN                 1ul
#define RATING_ONE_STAR_SET                 1ul
#define RATING_ONE_STAR_MAX                 12ul

#define RATING_TWO_STARS_MIN                13ul
#define RATING_TWO_STARS_SET                25ul
#define RATING_TWO_STARS_MAX                37ul

#define RATING_THREE_STARS_MIN              38ul
#define RATING_THREE_STARS_SET              50ul
#define RATING_THREE_STARS_MAX              62ul

#define RATING_FOUR_STARS_MIN               63ul
#define RATING_FOUR_STARS_SET               75ul
#define RATING_FOUR_STARS_MAX               87ul

#define RATING_FIVE_STARS_MIN               88ul
#define RATING_FIVE_STARS_SET               99ul
#define RATING_FIVE_STARS_MAX               99ul


//  Name:     System.RatingText -- PKEY_RatingText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {90197CA7-FD8F-4E8C-9DA3-B57E1E609295}, 100
//  
//  This is the user-friendly form of System.Rating.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_RatingText, 0x90197CA7, 0xFD8F, 0x4E8C, 0x9D, 0xA3, 0xB5, 0x7E, 0x1E, 0x60, 0x92, 0x95, 100);

//  Name:     System.Sensitivity -- PKEY_Sensitivity
//  Type:     UInt16 -- VT_UI2
//  FormatID: {F8D3F6AC-4874-42CB-BE59-AB454B30716A}, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_Sensitivity, 0xF8D3F6AC, 0x4874, 0x42CB, 0xBE, 0x59, 0xAB, 0x45, 0x4B, 0x30, 0x71, 0x6A, 100);

// Possible discrete values for PKEY_Sensitivity are:
#define SENSITIVITY_PROP_NORMAL             0u
#define SENSITIVITY_PROP_PERSONAL           1u
#define SENSITIVITY_PROP_PRIVATE            2u
#define SENSITIVITY_PROP_CONFIDENTIAL       3u

//  Name:     System.SensitivityText -- PKEY_SensitivityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D0C7F054-3F72-4725-8527-129A577CB269}, 100
//  
//  This is the user-friendly form of System.Sensitivity.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_SensitivityText, 0xD0C7F054, 0x3F72, 0x4725, 0x85, 0x27, 0x12, 0x9A, 0x57, 0x7C, 0xB2, 0x69, 100);

//  Name:     System.SFGAOFlags -- PKEY_SFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 25
//
//  IShellFolder::GetAttributesOf flags, with SFGAO_PKEYSFGAOMASK attributes masked out.
DEFINE_PROPERTYKEY(PKEY_SFGAOFlags, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 25);

//  Name:     System.SharedWith -- PKEY_SharedWith
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 200
//
//  Who is the item shared with?
DEFINE_PROPERTYKEY(PKEY_SharedWith, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 200);

//  Name:     System.ShareUserRating -- PKEY_ShareUserRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 12 (PIDMSI_SHARE_USER_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ShareUserRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.SharingStatus -- PKEY_SharingStatus
//  Type:     UInt32 -- VT_UI4
//  FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 300
//
//  What is the item's sharing status (not shared, shared, everyone (homegroup or everyone), or private)?
DEFINE_PROPERTYKEY(PKEY_SharingStatus, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 300);

// Possible discrete values for PKEY_SharingStatus are:
#define SHARINGSTATUS_NOTSHARED             0ul
#define SHARINGSTATUS_SHARED                1ul
#define SHARINGSTATUS_PRIVATE               2ul

//  Name:     System.Shell.OmitFromView -- PKEY_Shell_OmitFromView
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DE35258C-C695-4CBC-B982-38B0AD24CED0}, 2
//  
//  Set this to a string value of 'True' to omit this item from shell views
DEFINE_PROPERTYKEY(PKEY_Shell_OmitFromView, 0xDE35258C, 0xC695, 0x4CBC, 0xB9, 0x82, 0x38, 0xB0, 0xAD, 0x24, 0xCE, 0xD0, 2);

//  Name:     System.SimpleRating -- PKEY_SimpleRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: {A09F084E-AD41-489F-8076-AA5BE3082BCA}, 100
//  
//  Indicates the users preference rating of an item on a scale of 0-5 (0=unrated, 1=One Star, 2=Two Stars, 3=Three Stars,
//  4=Four Stars, 5=Five Stars)
DEFINE_PROPERTYKEY(PKEY_SimpleRating, 0xA09F084E, 0xAD41, 0x489F, 0x80, 0x76, 0xAA, 0x5B, 0xE3, 0x08, 0x2B, 0xCA, 100);

//  Name:     System.Size -- PKEY_Size
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 12 (PID_STG_SIZE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Size, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 12);

//  Name:     System.SoftwareUsed -- PKEY_SoftwareUsed
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 305
//
//  PropertyTagSoftwareUsed
DEFINE_PROPERTYKEY(PKEY_SoftwareUsed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 305);

//  Name:     System.SourceItem -- PKEY_SourceItem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {668CDFA5-7A1B-4323-AE4B-E527393A1D81}, 100
DEFINE_PROPERTYKEY(PKEY_SourceItem, 0x668CDFA5, 0x7A1B, 0x4323, 0xAE, 0x4B, 0xE5, 0x27, 0x39, 0x3A, 0x1D, 0x81, 100);

//  Name:     System.StartDate -- PKEY_StartDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {48FD6EC8-8A12-4CDF-A03E-4EC5A511EDDE}, 100
DEFINE_PROPERTYKEY(PKEY_StartDate, 0x48FD6EC8, 0x8A12, 0x4CDF, 0xA0, 0x3E, 0x4E, 0xC5, 0xA5, 0x11, 0xED, 0xDE, 100);

//  Name:     System.Status -- PKEY_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_IntSite) {000214A1-0000-0000-C000-000000000046}, 9
DEFINE_PROPERTYKEY(PKEY_Status, 0x000214A1, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 9);

//  Name:     System.Subject -- PKEY_Subject
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 3 (PIDSI_SUBJECT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Subject, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 3);

//  Name:     System.Thumbnail -- PKEY_Thumbnail
//  Type:     Clipboard -- VT_CF
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 17 (PIDSI_THUMBNAIL)
//
//  A data that represents the thumbnail in VT_CF format.
DEFINE_PROPERTYKEY(PKEY_Thumbnail, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 17);

//  Name:     System.ThumbnailCacheId -- PKEY_ThumbnailCacheId
//  Type:     UInt64 -- VT_UI8
//  FormatID: {446D16B1-8DAD-4870-A748-402EA43D788C}, 100
//  
//  Unique value that can be used as a key to cache thumbnails. The value changes when the name, volume, or data modified 
//  of an item changes.
DEFINE_PROPERTYKEY(PKEY_ThumbnailCacheId, 0x446D16B1, 0x8DAD, 0x4870, 0xA7, 0x48, 0x40, 0x2E, 0xA4, 0x3D, 0x78, 0x8C, 100);

//  Name:     System.ThumbnailStream -- PKEY_ThumbnailStream
//  Type:     Stream -- VT_STREAM
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 27
//
//  Data that represents the thumbnail in VT_STREAM format that GDI+/WindowsCodecs supports (jpg, png, etc).
DEFINE_PROPERTYKEY(PKEY_ThumbnailStream, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 27);

//  Name:     System.Title -- PKEY_Title
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 2 (PIDSI_TITLE)
//
//  Title of item.
DEFINE_PROPERTYKEY(PKEY_Title, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 2);

//  Name:     System.TotalFileSize -- PKEY_TotalFileSize
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 14
//
//  
DEFINE_PROPERTYKEY(PKEY_TotalFileSize, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 14);

//  Name:     System.Trademarks -- PKEY_Trademarks
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 9 (PIDVSI_Trademarks)
//
//  
DEFINE_PROPERTYKEY(PKEY_Trademarks, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 9);
 
//-----------------------------------------------------------------------------
// Devices properties



//  Name:     System.Device.PrinterURL -- PKEY_Device_PrinterURL
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0B48F35A-BE6E-4F17-B108-3C4073D1669A}, 15
//
//  Printer information Printer URL.
DEFINE_PROPERTYKEY(PKEY_Device_PrinterURL, 0x0B48F35A, 0xBE6E, 0x4F17, 0xB1, 0x08, 0x3C, 0x40, 0x73, 0xD1, 0x66, 0x9A, 15);

//  Name:     System.DeviceInterface.PrinterDriverDirectory -- PKEY_DeviceInterface_PrinterDriverDirectory
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {847C66DE-B8D6-4AF9-ABC3-6F4F926BC039}, 14
//
//  Printer information Printer Driver Directory.
DEFINE_PROPERTYKEY(PKEY_DeviceInterface_PrinterDriverDirectory, 0x847C66DE, 0xB8D6, 0x4AF9, 0xAB, 0xC3, 0x6F, 0x4F, 0x92, 0x6B, 0xC0, 0x39, 14);

//  Name:     System.DeviceInterface.PrinterDriverName -- PKEY_DeviceInterface_PrinterDriverName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {AFC47170-14F5-498C-8F30-B0D19BE449C6}, 11
//
//  Printer information Driver Name.
DEFINE_PROPERTYKEY(PKEY_DeviceInterface_PrinterDriverName, 0xAFC47170, 0x14F5, 0x498C, 0x8F, 0x30, 0xB0, 0xD1, 0x9B, 0xE4, 0x49, 0xC6, 11);

//  Name:     System.DeviceInterface.PrinterName -- PKEY_DeviceInterface_PrinterName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0A7B84EF-0C27-463F-84EF-06C5070001BE}, 10
//
//  Printer information Printer Name.
DEFINE_PROPERTYKEY(PKEY_DeviceInterface_PrinterName, 0x0A7B84EF, 0x0C27, 0x463F, 0x84, 0xEF, 0x06, 0xC5, 0x07, 0x00, 0x01, 0xBE, 10);

//  Name:     System.DeviceInterface.PrinterPortName -- PKEY_DeviceInterface_PrinterPortName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {EEC7B761-6F94-41B1-949F-C729720DD13C}, 12
//
//  Printer information Port Name.
DEFINE_PROPERTYKEY(PKEY_DeviceInterface_PrinterPortName, 0xEEC7B761, 0x6F94, 0x41B1, 0x94, 0x9F, 0xC7, 0x29, 0x72, 0x0D, 0xD1, 0x3C, 12);

//  Name:     System.Devices.BatteryLife -- PKEY_Devices_BatteryLife
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 10
//
//  Remaining battery life of the device as an integer between 0 and 100 percent.
DEFINE_PROPERTYKEY(PKEY_Devices_BatteryLife, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 10);

//  Name:     System.Devices.BatteryPlusCharging -- PKEY_Devices_BatteryPlusCharging
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 22
//
//  Remaining battery life of the device as an integer between 0 and 100 percent and the device's charging state.
DEFINE_PROPERTYKEY(PKEY_Devices_BatteryPlusCharging, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 22);

//  Name:     System.Devices.BatteryPlusChargingText -- PKEY_Devices_BatteryPlusChargingText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 23
//
//  Remaining battery life of the device and the device's charging state as a string.
DEFINE_PROPERTYKEY(PKEY_Devices_BatteryPlusChargingText, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 23);

//  Name:     System.Devices.Category -- PKEY_Devices_Category_Desc_Singular
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 91
//
//  Singular form of device category.
DEFINE_PROPERTYKEY(PKEY_Devices_Category_Desc_Singular, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 91);

//  Name:     System.Devices.CategoryGroup -- PKEY_Devices_CategoryGroup_Desc
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 94
//
//  Plural form of device category.
DEFINE_PROPERTYKEY(PKEY_Devices_CategoryGroup_Desc, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 94);

//  Name:     System.Devices.CategoryPlural -- PKEY_Devices_Category_Desc_Plural
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 92
//
//  Plural form of device category.
DEFINE_PROPERTYKEY(PKEY_Devices_Category_Desc_Plural, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 92);

//  Name:     System.Devices.ChargingState -- PKEY_Devices_ChargingState
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 11
//
//  Boolean value representing if the device is currently charging.
DEFINE_PROPERTYKEY(PKEY_Devices_ChargingState, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 11);

//  Name:     System.Devices.Connected -- PKEY_Devices_IsConnected
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 55
//
//  Device connection state. If VARIANT_TRUE, indicates the device is currently connected to the computer.
DEFINE_PROPERTYKEY(PKEY_Devices_IsConnected, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 55);

//  Name:     System.Devices.ContainerId -- PKEY_Devices_ContainerId
//  Type:     Guid -- VT_CLSID
//  FormatID: {8C7ED206-3F8A-4827-B3AB-AE9E1FAEFC6C}, 2
//
//  Device container ID.
DEFINE_PROPERTYKEY(PKEY_Devices_ContainerId, 0x8C7ED206, 0x3F8A, 0x4827, 0xB3, 0xAB, 0xAE, 0x9E, 0x1F, 0xAE, 0xFC, 0x6C, 2);

//  Name:     System.Devices.DefaultTooltip -- PKEY_Devices_DefaultTooltip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 153
//
//  Tooltip for default state
DEFINE_PROPERTYKEY(PKEY_Devices_DefaultTooltip, 0x880F70A2, 0x6082, 0x47AC, 0x8A, 0xAB, 0xA7, 0x39, 0xD1, 0xA3, 0x00, 0xC3, 153);

//  Name:     System.Devices.DeviceDescription1 -- PKEY_Devices_DeviceDescription1
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 81
//
//  First line of descriptive text about the device.
DEFINE_PROPERTYKEY(PKEY_Devices_DeviceDescription1, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 81);

//  Name:     System.Devices.DeviceDescription2 -- PKEY_Devices_DeviceDescription2
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 82
//
//  Second line of descriptive text about the device.
DEFINE_PROPERTYKEY(PKEY_Devices_DeviceDescription2, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 82);

//  Name:     System.Devices.DiscoveryMethod -- PKEY_Devices_DiscoveryMethod
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 52
//
//  Device discovery method. This indicates on what transport or physical connection the device is discovered.
DEFINE_PROPERTYKEY(PKEY_Devices_DiscoveryMethod, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 52);

//  Name:     System.Devices.FriendlyName -- PKEY_Devices_FriendlyName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 12288
//
//  Device friendly name.
DEFINE_PROPERTYKEY(PKEY_Devices_FriendlyName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 12288);

//  Name:     System.Devices.FunctionPaths -- PKEY_Devices_FunctionPaths
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 3
//
//  Available functions for this device.
DEFINE_PROPERTYKEY(PKEY_Devices_FunctionPaths, 0xD08DD4C0, 0x3A9E, 0x462E, 0x82, 0x90, 0x7B, 0x63, 0x6B, 0x25, 0x76, 0xB9, 3);

//  Name:     System.Devices.InterfacePaths -- PKEY_Devices_InterfacePaths
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 2
//
//  Available interfaces for this device.
DEFINE_PROPERTYKEY(PKEY_Devices_InterfacePaths, 0xD08DD4C0, 0x3A9E, 0x462E, 0x82, 0x90, 0x7B, 0x63, 0x6B, 0x25, 0x76, 0xB9, 2);

//  Name:     System.Devices.IsDefault -- PKEY_Devices_IsDefaultDevice
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 86
//
//  If VARIANT_TRUE, the device is not working properly.
DEFINE_PROPERTYKEY(PKEY_Devices_IsDefaultDevice, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 86);

//  Name:     System.Devices.IsNetworkConnected -- PKEY_Devices_IsNetworkDevice
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 85
//
//  If VARIANT_TRUE, the device is not working properly.
DEFINE_PROPERTYKEY(PKEY_Devices_IsNetworkDevice, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 85);

//  Name:     System.Devices.IsShared -- PKEY_Devices_IsSharedDevice
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 84
//
//  If VARIANT_TRUE, the device is not working properly.
DEFINE_PROPERTYKEY(PKEY_Devices_IsSharedDevice, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 84);

//  Name:     System.Devices.IsSoftwareInstalling -- PKEY_Devices_IsSoftwareInstalling
//  Type:     Boolean -- VT_BOOL
//  FormatID: {83DA6326-97A6-4088-9453-A1923F573B29}, 9
//
//  If VARIANT_TRUE, the device installer is currently installing software.
DEFINE_PROPERTYKEY(PKEY_Devices_IsSoftwareInstalling, 0x83DA6326, 0x97A6, 0x4088, 0x94, 0x53, 0xA1, 0x92, 0x3F, 0x57, 0x3B, 0x29, 9);

//  Name:     System.Devices.LaunchDeviceStageFromExplorer -- PKEY_Devices_LaunchDeviceStageFromExplorer
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 77
//
//  Indicates whether to launch Device Stage or not
DEFINE_PROPERTYKEY(PKEY_Devices_LaunchDeviceStageFromExplorer, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 77);

//  Name:     System.Devices.LocalMachine -- PKEY_Devices_IsLocalMachine
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 70
//
//  If VARIANT_TRUE, the device in question is actually the computer.
DEFINE_PROPERTYKEY(PKEY_Devices_IsLocalMachine, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 70);

//  Name:     System.Devices.Manufacturer -- PKEY_Devices_Manufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8192
//
//  Device manufacturer.
DEFINE_PROPERTYKEY(PKEY_Devices_Manufacturer, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 8192);

//  Name:     System.Devices.MissedCalls -- PKEY_Devices_MissedCalls
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 5
//
//  Number of missed calls on the device.
DEFINE_PROPERTYKEY(PKEY_Devices_MissedCalls, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 5);

//  Name:     System.Devices.ModelName -- PKEY_Devices_ModelName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8194
//
//  Model name of the device.
DEFINE_PROPERTYKEY(PKEY_Devices_ModelName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 8194);

//  Name:     System.Devices.ModelNumber -- PKEY_Devices_ModelNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8195
//
//  Model number of the device.
DEFINE_PROPERTYKEY(PKEY_Devices_ModelNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 8195);

//  Name:     System.Devices.NetworkedTooltip -- PKEY_Devices_NetworkedTooltip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 152
//
//  Tooltip for connection state
DEFINE_PROPERTYKEY(PKEY_Devices_NetworkedTooltip, 0x880F70A2, 0x6082, 0x47AC, 0x8A, 0xAB, 0xA7, 0x39, 0xD1, 0xA3, 0x00, 0xC3, 152);

//  Name:     System.Devices.NetworkName -- PKEY_Devices_NetworkName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 7
//
//  Name of the device's network.
DEFINE_PROPERTYKEY(PKEY_Devices_NetworkName, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 7);

//  Name:     System.Devices.NetworkType -- PKEY_Devices_NetworkType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 8
//
//  String representing the type of the device's network.
DEFINE_PROPERTYKEY(PKEY_Devices_NetworkType, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 8);

//  Name:     System.Devices.NewPictures -- PKEY_Devices_NewPictures
//  Type:     UInt16 -- VT_UI2
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 4
//
//  Number of new pictures on the device.
DEFINE_PROPERTYKEY(PKEY_Devices_NewPictures, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 4);

//  Name:     System.Devices.Notification -- PKEY_Devices_Notification
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {06704B0C-E830-4C81-9178-91E4E95A80A0}, 3
//
//  Device Notification Property.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification, 0x06704B0C, 0xE830, 0x4C81, 0x91, 0x78, 0x91, 0xE4, 0xE9, 0x5A, 0x80, 0xA0, 3);

//  Name:     System.Devices.Notifications.LowBattery -- PKEY_Devices_Notification_LowBattery
//  Type:     Byte -- VT_UI1
//  FormatID: {C4C07F2B-8524-4E66-AE3A-A6235F103BEB}, 2
//
//  Device Low Battery Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_LowBattery, 0xC4C07F2B, 0x8524, 0x4E66, 0xAE, 0x3A, 0xA6, 0x23, 0x5F, 0x10, 0x3B, 0xEB, 2);

//  Name:     System.Devices.Notifications.MissedCall -- PKEY_Devices_Notification_MissedCall
//  Type:     Byte -- VT_UI1
//  FormatID: {6614EF48-4EFE-4424-9EDA-C79F404EDF3E}, 2
//
//  Device Missed Call Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_MissedCall, 0x6614EF48, 0x4EFE, 0x4424, 0x9E, 0xDA, 0xC7, 0x9F, 0x40, 0x4E, 0xDF, 0x3E, 2);

//  Name:     System.Devices.Notifications.NewMessage -- PKEY_Devices_Notification_NewMessage
//  Type:     Byte -- VT_UI1
//  FormatID: {2BE9260A-2012-4742-A555-F41B638B7DCB}, 2
//
//  Device New Message Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_NewMessage, 0x2BE9260A, 0x2012, 0x4742, 0xA5, 0x55, 0xF4, 0x1B, 0x63, 0x8B, 0x7D, 0xCB, 2);

//  Name:     System.Devices.Notifications.NewVoicemail -- PKEY_Devices_Notification_NewVoicemail
//  Type:     Byte -- VT_UI1
//  FormatID: {59569556-0A08-4212-95B9-FAE2AD6413DB}, 2
//
//  Device Voicemail Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_NewVoicemail, 0x59569556, 0x0A08, 0x4212, 0x95, 0xB9, 0xFA, 0xE2, 0xAD, 0x64, 0x13, 0xDB, 2);

//  Name:     System.Devices.Notifications.StorageFull -- PKEY_Devices_Notification_StorageFull
//  Type:     UInt64 -- VT_UI8
//  FormatID: {A0E00EE1-F0C7-4D41-B8E7-26A7BD8D38B0}, 2
//
//  Device Storage Full Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_StorageFull, 0xA0E00EE1, 0xF0C7, 0x4D41, 0xB8, 0xE7, 0x26, 0xA7, 0xBD, 0x8D, 0x38, 0xB0, 2);

//  Name:     System.Devices.Notifications.StorageFullLinkText -- PKEY_Devices_Notification_StorageFullLinkText
//  Type:     UInt64 -- VT_UI8
//  FormatID: {A0E00EE1-F0C7-4D41-B8E7-26A7BD8D38B0}, 3
//
//  Link Text for the Device Storage Full Notification.
DEFINE_PROPERTYKEY(PKEY_Devices_Notification_StorageFullLinkText, 0xA0E00EE1, 0xF0C7, 0x4D41, 0xB8, 0xE7, 0x26, 0xA7, 0xBD, 0x8D, 0x38, 0xB0, 3);

//  Name:     System.Devices.NotificationStore -- PKEY_Devices_NotificationStore
//  Type:     Object -- VT_UNKNOWN
//  FormatID: {06704B0C-E830-4C81-9178-91E4E95A80A0}, 2
//
//  Device Notification Store.
DEFINE_PROPERTYKEY(PKEY_Devices_NotificationStore, 0x06704B0C, 0xE830, 0x4C81, 0x91, 0x78, 0x91, 0xE4, 0xE9, 0x5A, 0x80, 0xA0, 2);

//  Name:     System.Devices.NotWorkingProperly -- PKEY_Devices_IsNotWorkingProperly
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 83
//
//  If VARIANT_TRUE, the device is not working properly.
DEFINE_PROPERTYKEY(PKEY_Devices_IsNotWorkingProperly, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 83);

//  Name:     System.Devices.Paired -- PKEY_Devices_IsPaired
//  Type:     Boolean -- VT_BOOL
//  FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 56
//
//  Device paired state. If VARIANT_TRUE, indicates the device is not paired with the computer.
DEFINE_PROPERTYKEY(PKEY_Devices_IsPaired, 0x78C34FC8, 0x104A, 0x4ACA, 0x9E, 0xA4, 0x52, 0x4D, 0x52, 0x99, 0x6E, 0x57, 56);

//  Name:     System.Devices.PrimaryCategory -- PKEY_Devices_PrimaryCategory
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 10
//
//  Primary category group for this device.
DEFINE_PROPERTYKEY(PKEY_Devices_PrimaryCategory, 0xD08DD4C0, 0x3A9E, 0x462E, 0x82, 0x90, 0x7B, 0x63, 0x6B, 0x25, 0x76, 0xB9, 10);

//  Name:     System.Devices.Roaming -- PKEY_Devices_Roaming
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 9
//
//  Status indicator used to indicate if the device is roaming.
DEFINE_PROPERTYKEY(PKEY_Devices_Roaming, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 9);

//  Name:     System.Devices.SafeRemovalRequired -- PKEY_Devices_SafeRemovalRequired
//  Type:     Boolean -- VT_BOOL
//  FormatID: {AFD97640-86A3-4210-B67C-289C41AABE55}, 2
//
//  Indicates if a device requires safe removal or not
DEFINE_PROPERTYKEY(PKEY_Devices_SafeRemovalRequired, 0xAFD97640, 0x86A3, 0x4210, 0xB6, 0x7C, 0x28, 0x9C, 0x41, 0xAA, 0xBE, 0x55, 2);

//  Name:     System.Devices.SharedTooltip -- PKEY_Devices_SharedTooltip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 151
//
//  Tooltip for sharing state
DEFINE_PROPERTYKEY(PKEY_Devices_SharedTooltip, 0x880F70A2, 0x6082, 0x47AC, 0x8A, 0xAB, 0xA7, 0x39, 0xD1, 0xA3, 0x00, 0xC3, 151);

//  Name:     System.Devices.SignalStrength -- PKEY_Devices_SignalStrength
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 2
//
//  Device signal strength.
DEFINE_PROPERTYKEY(PKEY_Devices_SignalStrength, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 2);

//  Name:     System.Devices.Status1 -- PKEY_Devices_Status1
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 257
//
//  1st line of device status.
DEFINE_PROPERTYKEY(PKEY_Devices_Status1, 0xD08DD4C0, 0x3A9E, 0x462E, 0x82, 0x90, 0x7B, 0x63, 0x6B, 0x25, 0x76, 0xB9, 257);

//  Name:     System.Devices.Status2 -- PKEY_Devices_Status2
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 258
//
//  2nd line of device status.
DEFINE_PROPERTYKEY(PKEY_Devices_Status2, 0xD08DD4C0, 0x3A9E, 0x462E, 0x82, 0x90, 0x7B, 0x63, 0x6B, 0x25, 0x76, 0xB9, 258);

//  Name:     System.Devices.StorageCapacity -- PKEY_Devices_StorageCapacity
//  Type:     UInt64 -- VT_UI8
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 12
//
//  Total storage capacity of the device.
DEFINE_PROPERTYKEY(PKEY_Devices_StorageCapacity, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 12);

//  Name:     System.Devices.StorageFreeSpace -- PKEY_Devices_StorageFreeSpace
//  Type:     UInt64 -- VT_UI8
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 13
//
//  Total free space of the storage of the device.
DEFINE_PROPERTYKEY(PKEY_Devices_StorageFreeSpace, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 13);

//  Name:     System.Devices.StorageFreeSpacePercent -- PKEY_Devices_StorageFreeSpacePercent
//  Type:     UInt32 -- VT_UI4
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 14
//
//  Total free space of the storage of the device as a percentage.
DEFINE_PROPERTYKEY(PKEY_Devices_StorageFreeSpacePercent, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 14);

//  Name:     System.Devices.TextMessages -- PKEY_Devices_TextMessages
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 3
//
//  Number of unread text messages on the device.
DEFINE_PROPERTYKEY(PKEY_Devices_TextMessages, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 3);

//  Name:     System.Devices.Voicemail -- PKEY_Devices_Voicemail
//  Type:     Byte -- VT_UI1
//  FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 6
//
//  Status indicator used to indicate if the device has voicemail.
DEFINE_PROPERTYKEY(PKEY_Devices_Voicemail, 0x49CD1F76, 0x5626, 0x4B17, 0xA4, 0xE8, 0x18, 0xB4, 0xAA, 0x1A, 0x22, 0x13, 6);
 
//-----------------------------------------------------------------------------
// Document properties



//  Name:     System.Document.ByteCount -- PKEY_Document_ByteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 4 (PIDDSI_BYTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ByteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 4);

//  Name:     System.Document.CharacterCount -- PKEY_Document_CharacterCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 16 (PIDSI_CHARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_CharacterCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 16);

//  Name:     System.Document.ClientID -- PKEY_Document_ClientID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {276D7BB0-5B34-4FB0-AA4B-158ED12A1809}, 100
DEFINE_PROPERTYKEY(PKEY_Document_ClientID, 0x276D7BB0, 0x5B34, 0x4FB0, 0xAA, 0x4B, 0x15, 0x8E, 0xD1, 0x2A, 0x18, 0x09, 100);

//  Name:     System.Document.Contributor -- PKEY_Document_Contributor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {F334115E-DA1B-4509-9B3D-119504DC7ABB}, 100
DEFINE_PROPERTYKEY(PKEY_Document_Contributor, 0xF334115E, 0xDA1B, 0x4509, 0x9B, 0x3D, 0x11, 0x95, 0x04, 0xDC, 0x7A, 0xBB, 100);

//  Name:     System.Document.DateCreated -- PKEY_Document_DateCreated
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 12 (PIDSI_CREATE_DTM)
//  
//  This property is stored in the document, not obtained from the file system.
DEFINE_PROPERTYKEY(PKEY_Document_DateCreated, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 12);

//  Name:     System.Document.DatePrinted -- PKEY_Document_DatePrinted
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 11 (PIDSI_LASTPRINTED)
//
//  Legacy name: "DocLastPrinted".
DEFINE_PROPERTYKEY(PKEY_Document_DatePrinted, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 11);

//  Name:     System.Document.DateSaved -- PKEY_Document_DateSaved
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 13 (PIDSI_LASTSAVE_DTM)
//
//  Legacy name: "DocLastSavedTm".
DEFINE_PROPERTYKEY(PKEY_Document_DateSaved, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 13);

//  Name:     System.Document.Division -- PKEY_Document_Division
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {1E005EE6-BF27-428B-B01C-79676ACD2870}, 100
DEFINE_PROPERTYKEY(PKEY_Document_Division, 0x1E005EE6, 0xBF27, 0x428B, 0xB0, 0x1C, 0x79, 0x67, 0x6A, 0xCD, 0x28, 0x70, 100);

//  Name:     System.Document.DocumentID -- PKEY_Document_DocumentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E08805C8-E395-40DF-80D2-54F0D6C43154}, 100
DEFINE_PROPERTYKEY(PKEY_Document_DocumentID, 0xE08805C8, 0xE395, 0x40DF, 0x80, 0xD2, 0x54, 0xF0, 0xD6, 0xC4, 0x31, 0x54, 100);

//  Name:     System.Document.HiddenSlideCount -- PKEY_Document_HiddenSlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 9 (PIDDSI_HIDDENCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_HiddenSlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 9);

//  Name:     System.Document.LastAuthor -- PKEY_Document_LastAuthor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 8 (PIDSI_LASTAUTHOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LastAuthor, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 8);

//  Name:     System.Document.LineCount -- PKEY_Document_LineCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 5 (PIDDSI_LINECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LineCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 5);

//  Name:     System.Document.Manager -- PKEY_Document_Manager
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 14 (PIDDSI_MANAGER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Manager, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 14);

//  Name:     System.Document.MultimediaClipCount -- PKEY_Document_MultimediaClipCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 10 (PIDDSI_MMCLIPCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_MultimediaClipCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 10);

//  Name:     System.Document.NoteCount -- PKEY_Document_NoteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 8 (PIDDSI_NOTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_NoteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 8);

//  Name:     System.Document.PageCount -- PKEY_Document_PageCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 14 (PIDSI_PAGECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PageCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 14);

//  Name:     System.Document.ParagraphCount -- PKEY_Document_ParagraphCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 6 (PIDDSI_PARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ParagraphCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 6);

//  Name:     System.Document.PresentationFormat -- PKEY_Document_PresentationFormat
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 3 (PIDDSI_PRESFORMAT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PresentationFormat, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 3);

//  Name:     System.Document.RevisionNumber -- PKEY_Document_RevisionNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 9 (PIDSI_REVNUMBER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_RevisionNumber, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 9);

//  Name:     System.Document.Security -- PKEY_Document_Security
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 19
//
//  Access control information, from SummaryInfo propset
DEFINE_PROPERTYKEY(PKEY_Document_Security, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 19);

//  Name:     System.Document.SlideCount -- PKEY_Document_SlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 7 (PIDDSI_SLIDECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_SlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 7);

//  Name:     System.Document.Template -- PKEY_Document_Template
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 7 (PIDSI_TEMPLATE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Template, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 7);

//  Name:     System.Document.TotalEditingTime -- PKEY_Document_TotalEditingTime
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 10 (PIDSI_EDITTIME)
//
//  100ns units, not milliseconds. VT_FILETIME for IPropertySetStorage handlers (legacy)
DEFINE_PROPERTYKEY(PKEY_Document_TotalEditingTime, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 10);

//  Name:     System.Document.Version -- PKEY_Document_Version
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 29
DEFINE_PROPERTYKEY(PKEY_Document_Version, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 29);

//  Name:     System.Document.WordCount -- PKEY_Document_WordCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 15 (PIDSI_WORDCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_WordCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 15);

 
 
//-----------------------------------------------------------------------------
// DRM properties

//  Name:     System.DRM.DatePlayExpires -- PKEY_DRM_DatePlayExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 6 (PIDDRSI_PLAYEXPIRES)
//
//  Indicates when play expires for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayExpires, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 6);

//  Name:     System.DRM.DatePlayStarts -- PKEY_DRM_DatePlayStarts
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 5 (PIDDRSI_PLAYSTARTS)
//
//  Indicates when play starts for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayStarts, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 5);

//  Name:     System.DRM.Description -- PKEY_DRM_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 3 (PIDDRSI_DESCRIPTION)
//
//  Displays the description for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_Description, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 3);

//  Name:     System.DRM.IsProtected -- PKEY_DRM_IsProtected
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 2 (PIDDRSI_PROTECTED)
//
//  
DEFINE_PROPERTYKEY(PKEY_DRM_IsProtected, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 2);

//  Name:     System.DRM.PlayCount -- PKEY_DRM_PlayCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 4 (PIDDRSI_PLAYCOUNT)
//
//  Indicates the play count for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_PlayCount, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 4);
 
//-----------------------------------------------------------------------------
// GPS properties

//  Name:     System.GPS.Altitude -- PKEY_GPS_Altitude
//  Type:     Double -- VT_R8
//  FormatID: {827EDB4F-5B73-44A7-891D-FDFFABEA35CA}, 100
//  
//  Indicates the altitude based on the reference in PKEY_GPS_AltitudeRef.  Calculated from PKEY_GPS_AltitudeNumerator and 
//  PKEY_GPS_AltitudeDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_Altitude, 0x827EDB4F, 0x5B73, 0x44A7, 0x89, 0x1D, 0xFD, 0xFF, 0xAB, 0xEA, 0x35, 0xCA, 100);

//  Name:     System.GPS.AltitudeDenominator -- PKEY_GPS_AltitudeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {78342DCB-E358-4145-AE9A-6BFE4E0F9F51}, 100
//
//  Denominator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeDenominator, 0x78342DCB, 0xE358, 0x4145, 0xAE, 0x9A, 0x6B, 0xFE, 0x4E, 0x0F, 0x9F, 0x51, 100);

//  Name:     System.GPS.AltitudeNumerator -- PKEY_GPS_AltitudeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {2DAD1EB7-816D-40D3-9EC3-C9773BE2AADE}, 100
//
//  Numerator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeNumerator, 0x2DAD1EB7, 0x816D, 0x40D3, 0x9E, 0xC3, 0xC9, 0x77, 0x3B, 0xE2, 0xAA, 0xDE, 100);

//  Name:     System.GPS.AltitudeRef -- PKEY_GPS_AltitudeRef
//  Type:     Byte -- VT_UI1
//  FormatID: {46AC629D-75EA-4515-867F-6DC4321C5844}, 100
//
//  Indicates the reference for the altitude property. (eg: above sea level, below sea level, absolute value)
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeRef, 0x46AC629D, 0x75EA, 0x4515, 0x86, 0x7F, 0x6D, 0xC4, 0x32, 0x1C, 0x58, 0x44, 100);

//  Name:     System.GPS.AreaInformation -- PKEY_GPS_AreaInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {972E333E-AC7E-49F1-8ADF-A70D07A9BCAB}, 100
//
//  Represents the name of the GPS area
DEFINE_PROPERTYKEY(PKEY_GPS_AreaInformation, 0x972E333E, 0xAC7E, 0x49F1, 0x8A, 0xDF, 0xA7, 0x0D, 0x07, 0xA9, 0xBC, 0xAB, 100);

//  Name:     System.GPS.Date -- PKEY_GPS_Date
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {3602C812-0F3B-45F0-85AD-603468D69423}, 100
//
//  Date and time of the GPS record
DEFINE_PROPERTYKEY(PKEY_GPS_Date, 0x3602C812, 0x0F3B, 0x45F0, 0x85, 0xAD, 0x60, 0x34, 0x68, 0xD6, 0x94, 0x23, 100);

//  Name:     System.GPS.DestBearing -- PKEY_GPS_DestBearing
//  Type:     Double -- VT_R8
//  FormatID: {C66D4B3C-E888-47CC-B99F-9DCA3EE34DEA}, 100
//  
//  Indicates the bearing to the destination point.  Calculated from PKEY_GPS_DestBearingNumerator and 
//  PKEY_GPS_DestBearingDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearing, 0xC66D4B3C, 0xE888, 0x47CC, 0xB9, 0x9F, 0x9D, 0xCA, 0x3E, 0xE3, 0x4D, 0xEA, 100);

//  Name:     System.GPS.DestBearingDenominator -- PKEY_GPS_DestBearingDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {7ABCF4F8-7C3F-4988-AC91-8D2C2E97ECA5}, 100
//
//  Denominator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingDenominator, 0x7ABCF4F8, 0x7C3F, 0x4988, 0xAC, 0x91, 0x8D, 0x2C, 0x2E, 0x97, 0xEC, 0xA5, 100);

//  Name:     System.GPS.DestBearingNumerator -- PKEY_GPS_DestBearingNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {BA3B1DA9-86EE-4B5D-A2A4-A271A429F0CF}, 100
//
//  Numerator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingNumerator, 0xBA3B1DA9, 0x86EE, 0x4B5D, 0xA2, 0xA4, 0xA2, 0x71, 0xA4, 0x29, 0xF0, 0xCF, 100);

//  Name:     System.GPS.DestBearingRef -- PKEY_GPS_DestBearingRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9AB84393-2A0F-4B75-BB22-7279786977CB}, 100
//
//  Indicates the reference used for the giving the bearing to the destination point.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingRef, 0x9AB84393, 0x2A0F, 0x4B75, 0xBB, 0x22, 0x72, 0x79, 0x78, 0x69, 0x77, 0xCB, 100);

//  Name:     System.GPS.DestDistance -- PKEY_GPS_DestDistance
//  Type:     Double -- VT_R8
//  FormatID: {A93EAE04-6804-4F24-AC81-09B266452118}, 100
//  
//  Indicates the distance to the destination point.  Calculated from PKEY_GPS_DestDistanceNumerator and 
//  PKEY_GPS_DestDistanceDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistance, 0xA93EAE04, 0x6804, 0x4F24, 0xAC, 0x81, 0x09, 0xB2, 0x66, 0x45, 0x21, 0x18, 100);

//  Name:     System.GPS.DestDistanceDenominator -- PKEY_GPS_DestDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {9BC2C99B-AC71-4127-9D1C-2596D0D7DCB7}, 100
//
//  Denominator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceDenominator, 0x9BC2C99B, 0xAC71, 0x4127, 0x9D, 0x1C, 0x25, 0x96, 0xD0, 0xD7, 0xDC, 0xB7, 100);

//  Name:     System.GPS.DestDistanceNumerator -- PKEY_GPS_DestDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {2BDA47DA-08C6-4FE1-80BC-A72FC517C5D0}, 100
//
//  Numerator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceNumerator, 0x2BDA47DA, 0x08C6, 0x4FE1, 0x80, 0xBC, 0xA7, 0x2F, 0xC5, 0x17, 0xC5, 0xD0, 100);

//  Name:     System.GPS.DestDistanceRef -- PKEY_GPS_DestDistanceRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {ED4DF2D3-8695-450B-856F-F5C1C53ACB66}, 100
//
//  Indicates the unit used to express the distance to the destination.  (eg: kilometers, miles, knots)
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceRef, 0xED4DF2D3, 0x8695, 0x450B, 0x85, 0x6F, 0xF5, 0xC1, 0xC5, 0x3A, 0xCB, 0x66, 100);

//  Name:     System.GPS.DestLatitude -- PKEY_GPS_DestLatitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: {9D1D7CC5-5C39-451C-86B3-928E2D18CC47}, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLatitudeNumerator and 
//  PKEY_GPS_DestLatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitude, 0x9D1D7CC5, 0x5C39, 0x451C, 0x86, 0xB3, 0x92, 0x8E, 0x2D, 0x18, 0xCC, 0x47, 100);

//  Name:     System.GPS.DestLatitudeDenominator -- PKEY_GPS_DestLatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {3A372292-7FCA-49A7-99D5-E47BB2D4E7AB}, 100
//
//  Denominator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeDenominator, 0x3A372292, 0x7FCA, 0x49A7, 0x99, 0xD5, 0xE4, 0x7B, 0xB2, 0xD4, 0xE7, 0xAB, 100);

//  Name:     System.GPS.DestLatitudeNumerator -- PKEY_GPS_DestLatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {ECF4B6F6-D5A6-433C-BB92-4076650FC890}, 100
//
//  Numerator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeNumerator, 0xECF4B6F6, 0xD5A6, 0x433C, 0xBB, 0x92, 0x40, 0x76, 0x65, 0x0F, 0xC8, 0x90, 100);

//  Name:     System.GPS.DestLatitudeRef -- PKEY_GPS_DestLatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CEA820B9-CE61-4885-A128-005D9087C192}, 100
//
//  Indicates whether the latitude destination point is north or south latitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeRef, 0xCEA820B9, 0xCE61, 0x4885, 0xA1, 0x28, 0x00, 0x5D, 0x90, 0x87, 0xC1, 0x92, 100);

//  Name:     System.GPS.DestLongitude -- PKEY_GPS_DestLongitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: {47A96261-CB4C-4807-8AD3-40B9D9DBC6BC}, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLongitudeNumerator and 
//  PKEY_GPS_DestLongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitude, 0x47A96261, 0xCB4C, 0x4807, 0x8A, 0xD3, 0x40, 0xB9, 0xD9, 0xDB, 0xC6, 0xBC, 100);

//  Name:     System.GPS.DestLongitudeDenominator -- PKEY_GPS_DestLongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {425D69E5-48AD-4900-8D80-6EB6B8D0AC86}, 100
//
//  Denominator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeDenominator, 0x425D69E5, 0x48AD, 0x4900, 0x8D, 0x80, 0x6E, 0xB6, 0xB8, 0xD0, 0xAC, 0x86, 100);

//  Name:     System.GPS.DestLongitudeNumerator -- PKEY_GPS_DestLongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {A3250282-FB6D-48D5-9A89-DBCACE75CCCF}, 100
//
//  Numerator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeNumerator, 0xA3250282, 0xFB6D, 0x48D5, 0x9A, 0x89, 0xDB, 0xCA, 0xCE, 0x75, 0xCC, 0xCF, 100);

//  Name:     System.GPS.DestLongitudeRef -- PKEY_GPS_DestLongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {182C1EA6-7C1C-4083-AB4B-AC6C9F4ED128}, 100
//
//  Indicates whether the longitude destination point is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeRef, 0x182C1EA6, 0x7C1C, 0x4083, 0xAB, 0x4B, 0xAC, 0x6C, 0x9F, 0x4E, 0xD1, 0x28, 100);

//  Name:     System.GPS.Differential -- PKEY_GPS_Differential
//  Type:     UInt16 -- VT_UI2
//  FormatID: {AAF4EE25-BD3B-4DD7-BFC4-47F77BB00F6D}, 100
//
//  Indicates whether differential correction was applied to the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_Differential, 0xAAF4EE25, 0xBD3B, 0x4DD7, 0xBF, 0xC4, 0x47, 0xF7, 0x7B, 0xB0, 0x0F, 0x6D, 100);

//  Name:     System.GPS.DOP -- PKEY_GPS_DOP
//  Type:     Double -- VT_R8
//  FormatID: {0CF8FB02-1837-42F1-A697-A7017AA289B9}, 100
//
//  Indicates the GPS DOP (data degree of precision).  Calculated from PKEY_GPS_DOPNumerator and PKEY_GPS_DOPDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_DOP, 0x0CF8FB02, 0x1837, 0x42F1, 0xA6, 0x97, 0xA7, 0x01, 0x7A, 0xA2, 0x89, 0xB9, 100);

//  Name:     System.GPS.DOPDenominator -- PKEY_GPS_DOPDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {A0BE94C5-50BA-487B-BD35-0654BE8881ED}, 100
//
//  Denominator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPDenominator, 0xA0BE94C5, 0x50BA, 0x487B, 0xBD, 0x35, 0x06, 0x54, 0xBE, 0x88, 0x81, 0xED, 100);

//  Name:     System.GPS.DOPNumerator -- PKEY_GPS_DOPNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {47166B16-364F-4AA0-9F31-E2AB3DF449C3}, 100
//
//  Numerator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPNumerator, 0x47166B16, 0x364F, 0x4AA0, 0x9F, 0x31, 0xE2, 0xAB, 0x3D, 0xF4, 0x49, 0xC3, 100);

//  Name:     System.GPS.ImgDirection -- PKEY_GPS_ImgDirection
//  Type:     Double -- VT_R8
//  FormatID: {16473C91-D017-4ED9-BA4D-B6BAA55DBCF8}, 100
//  
//  Indicates direction of the image when it was captured.  Calculated from PKEY_GPS_ImgDirectionNumerator and 
//  PKEY_GPS_ImgDirectionDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirection, 0x16473C91, 0xD017, 0x4ED9, 0xBA, 0x4D, 0xB6, 0xBA, 0xA5, 0x5D, 0xBC, 0xF8, 100);

//  Name:     System.GPS.ImgDirectionDenominator -- PKEY_GPS_ImgDirectionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {10B24595-41A2-4E20-93C2-5761C1395F32}, 100
//
//  Denominator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionDenominator, 0x10B24595, 0x41A2, 0x4E20, 0x93, 0xC2, 0x57, 0x61, 0xC1, 0x39, 0x5F, 0x32, 100);

//  Name:     System.GPS.ImgDirectionNumerator -- PKEY_GPS_ImgDirectionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {DC5877C7-225F-45F7-BAC7-E81334B6130A}, 100
//
//  Numerator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionNumerator, 0xDC5877C7, 0x225F, 0x45F7, 0xBA, 0xC7, 0xE8, 0x13, 0x34, 0xB6, 0x13, 0x0A, 100);

//  Name:     System.GPS.ImgDirectionRef -- PKEY_GPS_ImgDirectionRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A4AAA5B7-1AD0-445F-811A-0F8F6E67F6B5}, 100
//
//  Indicates reference for giving the direction of the image when it was captured.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionRef, 0xA4AAA5B7, 0x1AD0, 0x445F, 0x81, 0x1A, 0x0F, 0x8F, 0x6E, 0x67, 0xF6, 0xB5, 100);

//  Name:     System.GPS.Latitude -- PKEY_GPS_Latitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: {8727CFFF-4868-4EC6-AD5B-81B98521D1AB}, 100
//  
//  Indicates the latitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LatitudeNumerator and PKEY_GPS_LatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Latitude, 0x8727CFFF, 0x4868, 0x4EC6, 0xAD, 0x5B, 0x81, 0xB9, 0x85, 0x21, 0xD1, 0xAB, 100);

//  Name:     System.GPS.LatitudeDenominator -- PKEY_GPS_LatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {16E634EE-2BFF-497B-BD8A-4341AD39EEB9}, 100
//
//  Denominator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeDenominator, 0x16E634EE, 0x2BFF, 0x497B, 0xBD, 0x8A, 0x43, 0x41, 0xAD, 0x39, 0xEE, 0xB9, 100);

//  Name:     System.GPS.LatitudeNumerator -- PKEY_GPS_LatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {7DDAAAD1-CCC8-41AE-B750-B2CB8031AEA2}, 100
//
//  Numerator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeNumerator, 0x7DDAAAD1, 0xCCC8, 0x41AE, 0xB7, 0x50, 0xB2, 0xCB, 0x80, 0x31, 0xAE, 0xA2, 100);

//  Name:     System.GPS.LatitudeRef -- PKEY_GPS_LatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {029C0252-5B86-46C7-ACA0-2769FFC8E3D4}, 100
//
//  Indicates whether latitude is north or south latitude 
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeRef, 0x029C0252, 0x5B86, 0x46C7, 0xAC, 0xA0, 0x27, 0x69, 0xFF, 0xC8, 0xE3, 0xD4, 100);

//  Name:     System.GPS.Longitude -- PKEY_GPS_Longitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: {C4C4DBB2-B593-466B-BBDA-D03D27D5E43A}, 100
//  
//  Indicates the longitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LongitudeNumerator and PKEY_GPS_LongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Longitude, 0xC4C4DBB2, 0xB593, 0x466B, 0xBB, 0xDA, 0xD0, 0x3D, 0x27, 0xD5, 0xE4, 0x3A, 100);

//  Name:     System.GPS.LongitudeDenominator -- PKEY_GPS_LongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {BE6E176C-4534-4D2C-ACE5-31DEDAC1606B}, 100
//
//  Denominator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeDenominator, 0xBE6E176C, 0x4534, 0x4D2C, 0xAC, 0xE5, 0x31, 0xDE, 0xDA, 0xC1, 0x60, 0x6B, 100);

//  Name:     System.GPS.LongitudeNumerator -- PKEY_GPS_LongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: {02B0F689-A914-4E45-821D-1DDA452ED2C4}, 100
//
//  Numerator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeNumerator, 0x02B0F689, 0xA914, 0x4E45, 0x82, 0x1D, 0x1D, 0xDA, 0x45, 0x2E, 0xD2, 0xC4, 100);

//  Name:     System.GPS.LongitudeRef -- PKEY_GPS_LongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {33DCF22B-28D5-464C-8035-1EE9EFD25278}, 100
//
//  Indicates whether longitude is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeRef, 0x33DCF22B, 0x28D5, 0x464C, 0x80, 0x35, 0x1E, 0xE9, 0xEF, 0xD2, 0x52, 0x78, 100);

//  Name:     System.GPS.MapDatum -- PKEY_GPS_MapDatum
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {2CA2DAE6-EDDC-407D-BEF1-773942ABFA95}, 100
//
//  Indicates the geodetic survey data used by the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_MapDatum, 0x2CA2DAE6, 0xEDDC, 0x407D, 0xBE, 0xF1, 0x77, 0x39, 0x42, 0xAB, 0xFA, 0x95, 100);

//  Name:     System.GPS.MeasureMode -- PKEY_GPS_MeasureMode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A015ED5D-AAEA-4D58-8A86-3C586920EA0B}, 100
//
//  Indicates the GPS measurement mode.  (eg: 2-dimensional, 3-dimensional)
DEFINE_PROPERTYKEY(PKEY_GPS_MeasureMode, 0xA015ED5D, 0xAAEA, 0x4D58, 0x8A, 0x86, 0x3C, 0x58, 0x69, 0x20, 0xEA, 0x0B, 100);

//  Name:     System.GPS.ProcessingMethod -- PKEY_GPS_ProcessingMethod
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {59D49E61-840F-4AA9-A939-E2099B7F6399}, 100
//
//  Indicates the name of the method used for location finding
DEFINE_PROPERTYKEY(PKEY_GPS_ProcessingMethod, 0x59D49E61, 0x840F, 0x4AA9, 0xA9, 0x39, 0xE2, 0x09, 0x9B, 0x7F, 0x63, 0x99, 100);

//  Name:     System.GPS.Satellites -- PKEY_GPS_Satellites
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {467EE575-1F25-4557-AD4E-B8B58B0D9C15}, 100
//
//  Indicates the GPS satellites used for measurements
DEFINE_PROPERTYKEY(PKEY_GPS_Satellites, 0x467EE575, 0x1F25, 0x4557, 0xAD, 0x4E, 0xB8, 0xB5, 0x8B, 0x0D, 0x9C, 0x15, 100);

//  Name:     System.GPS.Speed -- PKEY_GPS_Speed
//  Type:     Double -- VT_R8
//  FormatID: {DA5D0862-6E76-4E1B-BABD-70021BD25494}, 100
//  
//  Indicates the speed of the GPS receiver movement.  Calculated from PKEY_GPS_SpeedNumerator and 
//  PKEY_GPS_SpeedDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Speed, 0xDA5D0862, 0x6E76, 0x4E1B, 0xBA, 0xBD, 0x70, 0x02, 0x1B, 0xD2, 0x54, 0x94, 100);

//  Name:     System.GPS.SpeedDenominator -- PKEY_GPS_SpeedDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {7D122D5A-AE5E-4335-8841-D71E7CE72F53}, 100
//
//  Denominator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedDenominator, 0x7D122D5A, 0xAE5E, 0x4335, 0x88, 0x41, 0xD7, 0x1E, 0x7C, 0xE7, 0x2F, 0x53, 100);

//  Name:     System.GPS.SpeedNumerator -- PKEY_GPS_SpeedNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {ACC9CE3D-C213-4942-8B48-6D0820F21C6D}, 100
//
//  Numerator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedNumerator, 0xACC9CE3D, 0xC213, 0x4942, 0x8B, 0x48, 0x6D, 0x08, 0x20, 0xF2, 0x1C, 0x6D, 100);

//  Name:     System.GPS.SpeedRef -- PKEY_GPS_SpeedRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {ECF7F4C9-544F-4D6D-9D98-8AD79ADAF453}, 100
//  
//  Indicates the unit used to express the speed of the GPS receiver movement.  (eg: kilometers per hour, 
//  miles per hour, knots).
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedRef, 0xECF7F4C9, 0x544F, 0x4D6D, 0x9D, 0x98, 0x8A, 0xD7, 0x9A, 0xDA, 0xF4, 0x53, 100);

//  Name:     System.GPS.Status -- PKEY_GPS_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {125491F4-818F-46B2-91B5-D537753617B2}, 100
//  
//  Indicates the status of the GPS receiver when the image was recorded.  (eg: measurement in progress, 
//  measurement interoperability).
DEFINE_PROPERTYKEY(PKEY_GPS_Status, 0x125491F4, 0x818F, 0x46B2, 0x91, 0xB5, 0xD5, 0x37, 0x75, 0x36, 0x17, 0xB2, 100);

//  Name:     System.GPS.Track -- PKEY_GPS_Track
//  Type:     Double -- VT_R8
//  FormatID: {76C09943-7C33-49E3-9E7E-CDBA872CFADA}, 100
//  
//  Indicates the direction of the GPS receiver movement.  Calculated from PKEY_GPS_TrackNumerator and 
//  PKEY_GPS_TrackDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Track, 0x76C09943, 0x7C33, 0x49E3, 0x9E, 0x7E, 0xCD, 0xBA, 0x87, 0x2C, 0xFA, 0xDA, 100);

//  Name:     System.GPS.TrackDenominator -- PKEY_GPS_TrackDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {C8D1920C-01F6-40C0-AC86-2F3A4AD00770}, 100
//
//  Denominator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackDenominator, 0xC8D1920C, 0x01F6, 0x40C0, 0xAC, 0x86, 0x2F, 0x3A, 0x4A, 0xD0, 0x07, 0x70, 100);

//  Name:     System.GPS.TrackNumerator -- PKEY_GPS_TrackNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {702926F4-44A6-43E1-AE71-45627116893B}, 100
//
//  Numerator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackNumerator, 0x702926F4, 0x44A6, 0x43E1, 0xAE, 0x71, 0x45, 0x62, 0x71, 0x16, 0x89, 0x3B, 100);

//  Name:     System.GPS.TrackRef -- PKEY_GPS_TrackRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {35DBE6FE-44C3-4400-AAAE-D2C799C407E8}, 100
//
//  Indicates reference for the direction of the GPS receiver movement.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_TrackRef, 0x35DBE6FE, 0x44C3, 0x4400, 0xAA, 0xAE, 0xD2, 0xC7, 0x99, 0xC4, 0x07, 0xE8, 100);

//  Name:     System.GPS.VersionID -- PKEY_GPS_VersionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: {22704DA4-C6B2-4A99-8E56-F16DF8C92599}, 100
//
//  Indicates the version of the GPS information
DEFINE_PROPERTYKEY(PKEY_GPS_VersionID, 0x22704DA4, 0xC6B2, 0x4A99, 0x8E, 0x56, 0xF1, 0x6D, 0xF8, 0xC9, 0x25, 0x99, 100);
 
//-----------------------------------------------------------------------------
// Image properties



//  Name:     System.Image.BitDepth -- PKEY_Image_BitDepth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 7 (PIDISI_BITDEPTH)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_BitDepth, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 7);

//  Name:     System.Image.ColorSpace -- PKEY_Image_ColorSpace
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 40961
//
//  PropertyTagExifColorSpace
DEFINE_PROPERTYKEY(PKEY_Image_ColorSpace, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 40961);

// Possible discrete values for PKEY_Image_ColorSpace are:
#define IMAGE_COLORSPACE_SRGB               1u
#define IMAGE_COLORSPACE_UNCALIBRATED       0xFFFFu

//  Name:     System.Image.CompressedBitsPerPixel -- PKEY_Image_CompressedBitsPerPixel
//  Type:     Double -- VT_R8
//  FormatID: {364B6FA9-37AB-482A-BE2B-AE02F60D4318}, 100
//
//  Calculated from PKEY_Image_CompressedBitsPerPixelNumerator and PKEY_Image_CompressedBitsPerPixelDenominator.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixel, 0x364B6FA9, 0x37AB, 0x482A, 0xBE, 0x2B, 0xAE, 0x02, 0xF6, 0x0D, 0x43, 0x18, 100);

//  Name:     System.Image.CompressedBitsPerPixelDenominator -- PKEY_Image_CompressedBitsPerPixelDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {1F8844E1-24AD-4508-9DFD-5326A415CE02}, 100
//
//  Denominator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelDenominator, 0x1F8844E1, 0x24AD, 0x4508, 0x9D, 0xFD, 0x53, 0x26, 0xA4, 0x15, 0xCE, 0x02, 100);

//  Name:     System.Image.CompressedBitsPerPixelNumerator -- PKEY_Image_CompressedBitsPerPixelNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {D21A7148-D32C-4624-8900-277210F79C0F}, 100
//
//  Numerator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelNumerator, 0xD21A7148, 0xD32C, 0x4624, 0x89, 0x00, 0x27, 0x72, 0x10, 0xF7, 0x9C, 0x0F, 100);

//  Name:     System.Image.Compression -- PKEY_Image_Compression
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 259
//
//  Indicates the image compression level.  PropertyTagCompression.
DEFINE_PROPERTYKEY(PKEY_Image_Compression, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 259);

// Possible discrete values for PKEY_Image_Compression are:
#define IMAGE_COMPRESSION_UNCOMPRESSED      1u
#define IMAGE_COMPRESSION_CCITT_T3          2u
#define IMAGE_COMPRESSION_CCITT_T4          3u
#define IMAGE_COMPRESSION_CCITT_T6          4u
#define IMAGE_COMPRESSION_LZW               5u
#define IMAGE_COMPRESSION_JPEG              6u
#define IMAGE_COMPRESSION_PACKBITS          32773u

//  Name:     System.Image.CompressionText -- PKEY_Image_CompressionText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {3F08E66F-2F44-4BB9-A682-AC35D2562322}, 100
//  
//  This is the user-friendly form of System.Image.Compression.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Image_CompressionText, 0x3F08E66F, 0x2F44, 0x4BB9, 0xA6, 0x82, 0xAC, 0x35, 0xD2, 0x56, 0x23, 0x22, 100);

//  Name:     System.Image.Dimensions -- PKEY_Image_Dimensions
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 13 (PIDISI_DIMENSIONS)
//
//  Indicates the dimensions of the image.
DEFINE_PROPERTYKEY(PKEY_Image_Dimensions, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Image.HorizontalResolution -- PKEY_Image_HorizontalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 5 (PIDISI_RESOLUTIONX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 5);

//  Name:     System.Image.HorizontalSize -- PKEY_Image_HorizontalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 3 (PIDISI_CX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Image.ImageID -- PKEY_Image_ImageID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {10DABE05-32AA-4C29-BF1A-63E2D220587F}, 100
DEFINE_PROPERTYKEY(PKEY_Image_ImageID, 0x10DABE05, 0x32AA, 0x4C29, 0xBF, 0x1A, 0x63, 0xE2, 0xD2, 0x20, 0x58, 0x7F, 100);

//  Name:     System.Image.ResolutionUnit -- PKEY_Image_ResolutionUnit
//  Type:     Int16 -- VT_I2
//  FormatID: {19B51FA6-1F92-4A5C-AB48-7DF0ABD67444}, 100
DEFINE_PROPERTYKEY(PKEY_Image_ResolutionUnit, 0x19B51FA6, 0x1F92, 0x4A5C, 0xAB, 0x48, 0x7D, 0xF0, 0xAB, 0xD6, 0x74, 0x44, 100);

//  Name:     System.Image.VerticalResolution -- PKEY_Image_VerticalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 6 (PIDISI_RESOLUTIONY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Image.VerticalSize -- PKEY_Image_VerticalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 4 (PIDISI_CY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

 
 
//-----------------------------------------------------------------------------
// Journal properties

//  Name:     System.Journal.Contacts -- PKEY_Journal_Contacts
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {DEA7C82C-1D89-4A66-9427-A4E3DEBABCB1}, 100
DEFINE_PROPERTYKEY(PKEY_Journal_Contacts, 0xDEA7C82C, 0x1D89, 0x4A66, 0x94, 0x27, 0xA4, 0xE3, 0xDE, 0xBA, 0xBC, 0xB1, 100);

//  Name:     System.Journal.EntryType -- PKEY_Journal_EntryType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {95BEB1FC-326D-4644-B396-CD3ED90E6DDF}, 100
DEFINE_PROPERTYKEY(PKEY_Journal_EntryType, 0x95BEB1FC, 0x326D, 0x4644, 0xB3, 0x96, 0xCD, 0x3E, 0xD9, 0x0E, 0x6D, 0xDF, 100);
 
//-----------------------------------------------------------------------------
// LayoutPattern properties



//  Name:     System.LayoutPattern.ContentViewModeForBrowse -- PKEY_LayoutPattern_ContentViewModeForBrowse
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 500
//  
//  Specifies the layout pattern that the content view mode should apply for this item in the context of browsing.
//  Register the regvalue under the name of "ContentViewModeLayoutPatternForBrowse".
DEFINE_PROPERTYKEY(PKEY_LayoutPattern_ContentViewModeForBrowse, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 500);

// Possible discrete values for PKEY_LayoutPattern_ContentViewModeForBrowse are:
#define LAYOUTPATTERN_CVMFB_ALPHA           L"alpha"
#define LAYOUTPATTERN_CVMFB_BETA            L"beta"
#define LAYOUTPATTERN_CVMFB_GAMMA           L"gamma"
#define LAYOUTPATTERN_CVMFB_DELTA           L"delta"

//  Name:     System.LayoutPattern.ContentViewModeForSearch -- PKEY_LayoutPattern_ContentViewModeForSearch
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 501
//  
//  Specifies the layout pattern that the content view mode should apply for this item in the context of searching.
//  Register the regvalue under the name of "ContentViewModeLayoutPatternForSearch".
DEFINE_PROPERTYKEY(PKEY_LayoutPattern_ContentViewModeForSearch, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 501);

// Possible discrete values for PKEY_LayoutPattern_ContentViewModeForSearch are:
#define LAYOUTPATTERN_CVMFS_ALPHA           L"alpha"
#define LAYOUTPATTERN_CVMFS_BETA            L"beta"
#define LAYOUTPATTERN_CVMFS_GAMMA           L"gamma"
#define LAYOUTPATTERN_CVMFS_DELTA           L"delta"
 
//-----------------------------------------------------------------------------
// Link properties



//  Name:     System.Link.Arguments -- PKEY_Link_Arguments
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {436F2667-14E2-4FEB-B30A-146C53B5B674}, 100
DEFINE_PROPERTYKEY(PKEY_Link_Arguments, 0x436F2667, 0x14E2, 0x4FEB, 0xB3, 0x0A, 0x14, 0x6C, 0x53, 0xB5, 0xB6, 0x74, 100);

//  Name:     System.Link.Comment -- PKEY_Link_Comment
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 5
DEFINE_PROPERTYKEY(PKEY_Link_Comment, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 5);

//  Name:     System.Link.DateVisited -- PKEY_Link_DateVisited
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 23  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_DateVisited, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 23);

//  Name:     System.Link.Description -- PKEY_Link_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 21  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_Description, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 21);

//  Name:     System.Link.Status -- PKEY_Link_Status
//  Type:     Int32 -- VT_I4
//  FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 3 (PID_LINK_TARGET_TYPE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Link_Status, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 3);

// Possible discrete values for PKEY_Link_Status are:
#define LINK_STATUS_RESOLVED                1l
#define LINK_STATUS_BROKEN                  2l

//  Name:     System.Link.TargetExtension -- PKEY_Link_TargetExtension
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {7A7D76F4-B630-4BD7-95FF-37CC51A975C9}, 2
//
//  The file extension of the link target.  See System.File.Extension
DEFINE_PROPERTYKEY(PKEY_Link_TargetExtension, 0x7A7D76F4, 0xB630, 0x4BD7, 0x95, 0xFF, 0x37, 0xCC, 0x51, 0xA9, 0x75, 0xC9, 2);

//  Name:     System.Link.TargetParsingPath -- PKEY_Link_TargetParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 2 (PID_LINK_TARGET)
//  
//  This is the shell namespace path to the target of the link item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the target item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the target item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_Link_TargetParsingPath, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 2);

//  Name:     System.Link.TargetSFGAOFlags -- PKEY_Link_TargetSFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 8
//  
//  IShellFolder::GetAttributesOf flags for the target of a link, with SFGAO_PKEYSFGAOMASK 
//  attributes masked out.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlags, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 8);
 
//-----------------------------------------------------------------------------
// Media properties



//  Name:     System.Media.AuthorUrl -- PKEY_Media_AuthorUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 32 (PIDMSI_AUTHOR_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_AuthorUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 32);

//  Name:     System.Media.AverageLevel -- PKEY_Media_AverageLevel
//  Type:     UInt32 -- VT_UI4
//  FormatID: {09EDD5B6-B301-43C5-9990-D00302EFFD46}, 100
DEFINE_PROPERTYKEY(PKEY_Media_AverageLevel, 0x09EDD5B6, 0xB301, 0x43C5, 0x99, 0x90, 0xD0, 0x03, 0x02, 0xEF, 0xFD, 0x46, 100);

//  Name:     System.Media.ClassPrimaryID -- PKEY_Media_ClassPrimaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 13 (PIDMSI_CLASS_PRIMARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassPrimaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Media.ClassSecondaryID -- PKEY_Media_ClassSecondaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 14 (PIDMSI_CLASS_SECONDARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassSecondaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 14);

//  Name:     System.Media.CollectionGroupID -- PKEY_Media_CollectionGroupID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 24 (PIDMSI_COLLECTION_GROUP_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionGroupID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 24);

//  Name:     System.Media.CollectionID -- PKEY_Media_CollectionID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 25 (PIDMSI_COLLECTION_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 25);

//  Name:     System.Media.ContentDistributor -- PKEY_Media_ContentDistributor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 18 (PIDMSI_CONTENTDISTRIBUTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentDistributor, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 18);

//  Name:     System.Media.ContentID -- PKEY_Media_ContentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 26 (PIDMSI_CONTENT_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 26);

//  Name:     System.Media.CreatorApplication -- PKEY_Media_CreatorApplication
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 27 (PIDMSI_TOOL_NAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplication, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 27);

//  Name:     System.Media.CreatorApplicationVersion -- PKEY_Media_CreatorApplicationVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 28 (PIDMSI_TOOL_VERSION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplicationVersion, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 28);

//  Name:     System.Media.DateEncoded -- PKEY_Media_DateEncoded
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {2E4B640D-5019-46D8-8881-55414CC5CAA0}, 100
//
//  DateTime is in UTC (in the doc, not file system).
DEFINE_PROPERTYKEY(PKEY_Media_DateEncoded, 0x2E4B640D, 0x5019, 0x46D8, 0x88, 0x81, 0x55, 0x41, 0x4C, 0xC5, 0xCA, 0xA0, 100);

//  Name:     System.Media.DateReleased -- PKEY_Media_DateReleased
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DE41CC29-6971-4290-B472-F59F2E2F31E2}, 100
DEFINE_PROPERTYKEY(PKEY_Media_DateReleased, 0xDE41CC29, 0x6971, 0x4290, 0xB4, 0x72, 0xF5, 0x9F, 0x2E, 0x2F, 0x31, 0xE2, 100);

//  Name:     System.Media.Duration -- PKEY_Media_Duration
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 3 (PIDASI_TIMELENGTH)
//
//  100ns units, not milliseconds
DEFINE_PROPERTYKEY(PKEY_Media_Duration, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Media.DVDID -- PKEY_Media_DVDID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 15 (PIDMSI_DVDID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_DVDID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 15);

//  Name:     System.Media.EncodedBy -- PKEY_Media_EncodedBy
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 36 (PIDMSI_ENCODED_BY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodedBy, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 36);

//  Name:     System.Media.EncodingSettings -- PKEY_Media_EncodingSettings
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 37 (PIDMSI_ENCODING_SETTINGS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodingSettings, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 37);

//  Name:     System.Media.FrameCount -- PKEY_Media_FrameCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 12 (PIDISI_FRAMECOUNT)
//
//  Indicates the frame count for the image.
DEFINE_PROPERTYKEY(PKEY_Media_FrameCount, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.Media.MCDI -- PKEY_Media_MCDI
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 16 (PIDMSI_MCDI)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MCDI, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 16);

//  Name:     System.Media.MetadataContentProvider -- PKEY_Media_MetadataContentProvider
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 17 (PIDMSI_PROVIDER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MetadataContentProvider, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 17);

//  Name:     System.Media.Producer -- PKEY_Media_Producer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 22 (PIDMSI_PRODUCER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Producer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 22);

//  Name:     System.Media.PromotionUrl -- PKEY_Media_PromotionUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 33 (PIDMSI_PROMOTION_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_PromotionUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 33);

//  Name:     System.Media.ProtectionType -- PKEY_Media_ProtectionType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 38
//  
//  If media is protected, how is it protected?
DEFINE_PROPERTYKEY(PKEY_Media_ProtectionType, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 38);

//  Name:     System.Media.ProviderRating -- PKEY_Media_ProviderRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 39
//  
//  Rating (0 - 99) supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 39);

//  Name:     System.Media.ProviderStyle -- PKEY_Media_ProviderStyle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 40
//  
//  Style of music or video, supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderStyle, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 40);

//  Name:     System.Media.Publisher -- PKEY_Media_Publisher
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 30 (PIDMSI_PUBLISHER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Publisher, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 30);

//  Name:     System.Media.SubscriptionContentId -- PKEY_Media_SubscriptionContentId
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9AEBAE7A-9644-487D-A92C-657585ED751A}, 100
DEFINE_PROPERTYKEY(PKEY_Media_SubscriptionContentId, 0x9AEBAE7A, 0x9644, 0x487D, 0xA9, 0x2C, 0x65, 0x75, 0x85, 0xED, 0x75, 0x1A, 100);

//  Name:     System.Media.SubTitle -- PKEY_Media_SubTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 38 (PIDSI_MUSIC_SUB_TITLE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_SubTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 38);

//  Name:     System.Media.UniqueFileIdentifier -- PKEY_Media_UniqueFileIdentifier
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 35 (PIDMSI_UNIQUE_FILE_IDENTIFIER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UniqueFileIdentifier, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 35);

//  Name:     System.Media.UserNoAutoInfo -- PKEY_Media_UserNoAutoInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 41
//  
//  If true, do NOT alter this file's metadata. Set by user.
DEFINE_PROPERTYKEY(PKEY_Media_UserNoAutoInfo, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 41);

//  Name:     System.Media.UserWebUrl -- PKEY_Media_UserWebUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 34 (PIDMSI_USER_WEB_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UserWebUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 34);

//  Name:     System.Media.Writer -- PKEY_Media_Writer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 23 (PIDMSI_WRITER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Writer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 23);

//  Name:     System.Media.Year -- PKEY_Media_Year
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 5 (PIDSI_MUSIC_YEAR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Year, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 5);
 
//-----------------------------------------------------------------------------
// Message properties



//  Name:     System.Message.AttachmentContents -- PKEY_Message_AttachmentContents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {3143BF7C-80A8-4854-8880-E2E40189BDD0}, 100
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentContents, 0x3143BF7C, 0x80A8, 0x4854, 0x88, 0x80, 0xE2, 0xE4, 0x01, 0x89, 0xBD, 0xD0, 100);

//  Name:     System.Message.AttachmentNames -- PKEY_Message_AttachmentNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 21
//
//  The names of the attachments in a message
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentNames, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 21);

//  Name:     System.Message.BccAddress -- PKEY_Message_BccAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 2
//
//  Addresses in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 2);

//  Name:     System.Message.BccName -- PKEY_Message_BccName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 3
//
//  person names in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 3);

//  Name:     System.Message.CcAddress -- PKEY_Message_CcAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 4
//
//  Addresses in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 4);

//  Name:     System.Message.CcName -- PKEY_Message_CcName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 5
//
//  person names in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 5);

//  Name:     System.Message.ConversationID -- PKEY_Message_ConversationID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {DC8F80BD-AF1E-4289-85B6-3DFC1B493992}, 100
DEFINE_PROPERTYKEY(PKEY_Message_ConversationID, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 100);

//  Name:     System.Message.ConversationIndex -- PKEY_Message_ConversationIndex
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: {DC8F80BD-AF1E-4289-85B6-3DFC1B493992}, 101
//  
//  
DEFINE_PROPERTYKEY(PKEY_Message_ConversationIndex, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 101);

//  Name:     System.Message.DateReceived -- PKEY_Message_DateReceived
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 20
//
//  Date and Time communication was received
DEFINE_PROPERTYKEY(PKEY_Message_DateReceived, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 20);

//  Name:     System.Message.DateSent -- PKEY_Message_DateSent
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 19
//
//  Date and Time communication was sent
DEFINE_PROPERTYKEY(PKEY_Message_DateSent, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 19);

//  Name:     System.Message.Flags -- PKEY_Message_Flags
//  Type:     Int32 -- VT_I4
//  FormatID: {A82D9EE7-CA67-4312-965E-226BCEA85023}, 100
//  
//  These are flags associated with email messages to know if a read receipt is pending, etc.
//  The values stored here by Outlook are defined for PR_MESSAGE_FLAGS on MSDN. 
DEFINE_PROPERTYKEY(PKEY_Message_Flags, 0xA82D9EE7, 0xCA67, 0x4312, 0x96, 0x5E, 0x22, 0x6B, 0xCE, 0xA8, 0x50, 0x23, 100);

//  Name:     System.Message.FromAddress -- PKEY_Message_FromAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 13
DEFINE_PROPERTYKEY(PKEY_Message_FromAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 13);

//  Name:     System.Message.FromName -- PKEY_Message_FromName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 14
//
//  Address in from field as person name
DEFINE_PROPERTYKEY(PKEY_Message_FromName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 14);

//  Name:     System.Message.HasAttachments -- PKEY_Message_HasAttachments
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4}, 8
//
//  
DEFINE_PROPERTYKEY(PKEY_Message_HasAttachments, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 8);

//  Name:     System.Message.IsFwdOrReply -- PKEY_Message_IsFwdOrReply
//  Type:     Int32 -- VT_I4
//  FormatID: {9A9BC088-4F6D-469E-9919-E705412040F9}, 100
DEFINE_PROPERTYKEY(PKEY_Message_IsFwdOrReply, 0x9A9BC088, 0x4F6D, 0x469E, 0x99, 0x19, 0xE7, 0x05, 0x41, 0x20, 0x40, 0xF9, 100);

//  Name:     System.Message.MessageClass -- PKEY_Message_MessageClass
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CD9ED458-08CE-418F-A70E-F912C7BB9C5C}, 103
//  
//  What type of outlook msg this is (meeting, task, mail, etc.)
DEFINE_PROPERTYKEY(PKEY_Message_MessageClass, 0xCD9ED458, 0x08CE, 0x418F, 0xA7, 0x0E, 0xF9, 0x12, 0xC7, 0xBB, 0x9C, 0x5C, 103);

//  Name:     System.Message.ProofInProgress -- PKEY_Message_ProofInProgress
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9098F33C-9A7D-48A8-8DE5-2E1227A64E91}, 100
//  
//  This property will be true if the message junk email proofing is still in progress.
DEFINE_PROPERTYKEY(PKEY_Message_ProofInProgress, 0x9098F33C, 0x9A7D, 0x48A8, 0x8D, 0xE5, 0x2E, 0x12, 0x27, 0xA6, 0x4E, 0x91, 100);

//  Name:     System.Message.SenderAddress -- PKEY_Message_SenderAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0BE1C8E7-1981-4676-AE14-FDD78F05A6E7}, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderAddress, 0x0BE1C8E7, 0x1981, 0x4676, 0xAE, 0x14, 0xFD, 0xD7, 0x8F, 0x05, 0xA6, 0xE7, 100);

//  Name:     System.Message.SenderName -- PKEY_Message_SenderName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0DA41CFA-D224-4A18-AE2F-596158DB4B3A}, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderName, 0x0DA41CFA, 0xD224, 0x4A18, 0xAE, 0x2F, 0x59, 0x61, 0x58, 0xDB, 0x4B, 0x3A, 100);

//  Name:     System.Message.Store -- PKEY_Message_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 15
//
//  The store (aka protocol handler) FILE, MAIL, OUTLOOKEXPRESS
DEFINE_PROPERTYKEY(PKEY_Message_Store, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 15);

//  Name:     System.Message.ToAddress -- PKEY_Message_ToAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 16
//
//  Addresses in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 16);

//  Name:     System.Message.ToDoFlags -- PKEY_Message_ToDoFlags
//  Type:     Int32 -- VT_I4
//  FormatID: {1F856A9F-6900-4ABA-9505-2D5F1B4D66CB}, 100
//  
//  Flags associated with a message flagged to know if it's still active, if it was custom flagged, etc.
DEFINE_PROPERTYKEY(PKEY_Message_ToDoFlags, 0x1F856A9F, 0x6900, 0x4ABA, 0x95, 0x05, 0x2D, 0x5F, 0x1B, 0x4D, 0x66, 0xCB, 100);

//  Name:     System.Message.ToDoTitle -- PKEY_Message_ToDoTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {BCCC8A3C-8CEF-42E5-9B1C-C69079398BC7}, 100
DEFINE_PROPERTYKEY(PKEY_Message_ToDoTitle, 0xBCCC8A3C, 0x8CEF, 0x42E5, 0x9B, 0x1C, 0xC6, 0x90, 0x79, 0x39, 0x8B, 0xC7, 100);

//  Name:     System.Message.ToName -- PKEY_Message_ToName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 17
//
//  Person names in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 17);
 
//-----------------------------------------------------------------------------
// Music properties

//  Name:     System.Music.AlbumArtist -- PKEY_Music_AlbumArtist
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 13 (PIDSI_MUSIC_ALBUM_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumArtist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 13);

//  Name:     System.Music.AlbumID -- PKEY_Music_AlbumID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 100
//  
//  Concatenation of System.Music.AlbumArtist and System.Music.AlbumTitle, suitable for indexing and display.
//  Used to differentiate albums with the same title from different artists.
DEFINE_PROPERTYKEY(PKEY_Music_AlbumID, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 100);

//  Name:     System.Music.AlbumTitle -- PKEY_Music_AlbumTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 4 (PIDSI_MUSIC_ALBUM)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 4);

//  Name:     System.Music.Artist -- PKEY_Music_Artist
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 2 (PIDSI_MUSIC_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Artist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 2);

//  Name:     System.Music.BeatsPerMinute -- PKEY_Music_BeatsPerMinute
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 35 (PIDSI_MUSIC_BEATS_PER_MINUTE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_BeatsPerMinute, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 35);

//  Name:     System.Music.Composer -- PKEY_Music_Composer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 19 (PIDMSI_COMPOSER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Composer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 19);

//  Name:     System.Music.Conductor -- PKEY_Music_Conductor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 36 (PIDSI_MUSIC_CONDUCTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Conductor, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 36);

//  Name:     System.Music.ContentGroupDescription -- PKEY_Music_ContentGroupDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 33 (PIDSI_MUSIC_CONTENT_GROUP_DESCRIPTION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_ContentGroupDescription, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 33);

//  Name:     System.Music.DisplayArtist -- PKEY_Music_DisplayArtist
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FD122953-FA93-4EF7-92C3-04C946B2F7C8}, 100
//  
//  This property returns the best representation of Album Artist for a given music file
//  based upon AlbumArtist, ContributingArtist and compilation info.
DEFINE_PROPERTYKEY(PKEY_Music_DisplayArtist, 0xFD122953, 0xFA93, 0x4EF7, 0x92, 0xC3, 0x04, 0xC9, 0x46, 0xB2, 0xF7, 0xC8, 100);

//  Name:     System.Music.Genre -- PKEY_Music_Genre
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 11 (PIDSI_MUSIC_GENRE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Genre, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 11);

//  Name:     System.Music.InitialKey -- PKEY_Music_InitialKey
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 34 (PIDSI_MUSIC_INITIAL_KEY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_InitialKey, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 34);

//  Name:     System.Music.IsCompilation -- PKEY_Music_IsCompilation
//  Type:     Boolean -- VT_BOOL
//  FormatID: {C449D5CB-9EA4-4809-82E8-AF9D59DED6D1}, 100
//
//  Indicates whether the file is part of a compilation.
DEFINE_PROPERTYKEY(PKEY_Music_IsCompilation, 0xC449D5CB, 0x9EA4, 0x4809, 0x82, 0xE8, 0xAF, 0x9D, 0x59, 0xDE, 0xD6, 0xD1, 100);

//  Name:     System.Music.Lyrics -- PKEY_Music_Lyrics
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 12 (PIDSI_MUSIC_LYRICS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Lyrics, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 12);

//  Name:     System.Music.Mood -- PKEY_Music_Mood
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 39 (PIDSI_MUSIC_MOOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Mood, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 39);

//  Name:     System.Music.PartOfSet -- PKEY_Music_PartOfSet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 37 (PIDSI_MUSIC_PART_OF_SET)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_PartOfSet, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 37);

//  Name:     System.Music.Period -- PKEY_Music_Period
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 31 (PIDMSI_PERIOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Period, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 31);

//  Name:     System.Music.SynchronizedLyrics -- PKEY_Music_SynchronizedLyrics
//  Type:     Blob -- VT_BLOB
//  FormatID: {6B223B6A-162E-4AA9-B39F-05D678FC6D77}, 100
DEFINE_PROPERTYKEY(PKEY_Music_SynchronizedLyrics, 0x6B223B6A, 0x162E, 0x4AA9, 0xB3, 0x9F, 0x05, 0xD6, 0x78, 0xFC, 0x6D, 0x77, 100);

//  Name:     System.Music.TrackNumber -- PKEY_Music_TrackNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 7 (PIDSI_MUSIC_TRACK)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_TrackNumber, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 7);

 
 
//-----------------------------------------------------------------------------
// Note properties

//  Name:     System.Note.Color -- PKEY_Note_Color
//  Type:     UInt16 -- VT_UI2
//  FormatID: {4776CAFA-BCE4-4CB1-A23E-265E76D8EB11}, 100
DEFINE_PROPERTYKEY(PKEY_Note_Color, 0x4776CAFA, 0xBCE4, 0x4CB1, 0xA2, 0x3E, 0x26, 0x5E, 0x76, 0xD8, 0xEB, 0x11, 100);

// Possible discrete values for PKEY_Note_Color are:
#define NOTE_COLOR_BLUE                     0u
#define NOTE_COLOR_GREEN                    1u
#define NOTE_COLOR_PINK                     2u
#define NOTE_COLOR_YELLOW                   3u
#define NOTE_COLOR_WHITE                    4u
#define NOTE_COLOR_LIGHTGREEN               5u

//  Name:     System.Note.ColorText -- PKEY_Note_ColorText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {46B4E8DE-CDB2-440D-885C-1658EB65B914}, 100
//  
//  This is the user-friendly form of System.Note.Color.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Note_ColorText, 0x46B4E8DE, 0xCDB2, 0x440D, 0x88, 0x5C, 0x16, 0x58, 0xEB, 0x65, 0xB9, 0x14, 100);
 
//-----------------------------------------------------------------------------
// Photo properties



//  Name:     System.Photo.Aperture -- PKEY_Photo_Aperture
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37378
//
//  PropertyTagExifAperture.  Calculated from PKEY_Photo_ApertureNumerator and PKEY_Photo_ApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_Aperture, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37378);

//  Name:     System.Photo.ApertureDenominator -- PKEY_Photo_ApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {E1A9A38B-6685-46BD-875E-570DC7AD7320}, 100
//
//  Denominator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureDenominator, 0xE1A9A38B, 0x6685, 0x46BD, 0x87, 0x5E, 0x57, 0x0D, 0xC7, 0xAD, 0x73, 0x20, 100);

//  Name:     System.Photo.ApertureNumerator -- PKEY_Photo_ApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {0337ECEC-39FB-4581-A0BD-4C4CC51E9914}, 100
//
//  Numerator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureNumerator, 0x0337ECEC, 0x39FB, 0x4581, 0xA0, 0xBD, 0x4C, 0x4C, 0xC5, 0x1E, 0x99, 0x14, 100);

//  Name:     System.Photo.Brightness -- PKEY_Photo_Brightness
//  Type:     Double -- VT_R8
//  FormatID: {1A701BF6-478C-4361-83AB-3701BB053C58}, 100 (PropertyTagExifBrightness)
//  
//  This is the brightness of the photo.
//  
//  Calculated from PKEY_Photo_BrightnessNumerator and PKEY_Photo_BrightnessDenominator.
//  
//  The units are "APEX", normally in the range of -99.99 to 99.99. If the numerator of 
//  the recorded value is FFFFFFFF.H, "Unknown" should be indicated.
DEFINE_PROPERTYKEY(PKEY_Photo_Brightness, 0x1A701BF6, 0x478C, 0x4361, 0x83, 0xAB, 0x37, 0x01, 0xBB, 0x05, 0x3C, 0x58, 100);

//  Name:     System.Photo.BrightnessDenominator -- PKEY_Photo_BrightnessDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {6EBE6946-2321-440A-90F0-C043EFD32476}, 100
//
//  Denominator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessDenominator, 0x6EBE6946, 0x2321, 0x440A, 0x90, 0xF0, 0xC0, 0x43, 0xEF, 0xD3, 0x24, 0x76, 100);

//  Name:     System.Photo.BrightnessNumerator -- PKEY_Photo_BrightnessNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {9E7D118F-B314-45A0-8CFB-D654B917C9E9}, 100
//
//  Numerator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessNumerator, 0x9E7D118F, 0xB314, 0x45A0, 0x8C, 0xFB, 0xD6, 0x54, 0xB9, 0x17, 0xC9, 0xE9, 100);

//  Name:     System.Photo.CameraManufacturer -- PKEY_Photo_CameraManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 271 (PropertyTagEquipMake)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraManufacturer, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 271);

//  Name:     System.Photo.CameraModel -- PKEY_Photo_CameraModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 272 (PropertyTagEquipModel)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraModel, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 272);

//  Name:     System.Photo.CameraSerialNumber -- PKEY_Photo_CameraSerialNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 273
//
//  Serial number of camera that produced this photo
DEFINE_PROPERTYKEY(PKEY_Photo_CameraSerialNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 273);

//  Name:     System.Photo.Contrast -- PKEY_Photo_Contrast
//  Type:     UInt32 -- VT_UI4
//  FormatID: {2A785BA9-8D23-4DED-82E6-60A350C86A10}, 100
//  
//  This indicates the direction of contrast processing applied by the camera 
//  when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Contrast, 0x2A785BA9, 0x8D23, 0x4DED, 0x82, 0xE6, 0x60, 0xA3, 0x50, 0xC8, 0x6A, 0x10, 100);

// Possible discrete values for PKEY_Photo_Contrast are:
#define PHOTO_CONTRAST_NORMAL               0ul
#define PHOTO_CONTRAST_SOFT                 1ul
#define PHOTO_CONTRAST_HARD                 2ul

//  Name:     System.Photo.ContrastText -- PKEY_Photo_ContrastText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {59DDE9F2-5253-40EA-9A8B-479E96C6249A}, 100
//  
//  This is the user-friendly form of System.Photo.Contrast.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ContrastText, 0x59DDE9F2, 0x5253, 0x40EA, 0x9A, 0x8B, 0x47, 0x9E, 0x96, 0xC6, 0x24, 0x9A, 100);

//  Name:     System.Photo.DateTaken -- PKEY_Photo_DateTaken
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 36867
//
//  PropertyTagExifDTOrig
DEFINE_PROPERTYKEY(PKEY_Photo_DateTaken, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 36867);

//  Name:     System.Photo.DigitalZoom -- PKEY_Photo_DigitalZoom
//  Type:     Double -- VT_R8
//  FormatID: {F85BF840-A925-4BC2-B0C4-8E36B598679E}, 100
//
//  PropertyTagExifDigitalZoom.  Calculated from PKEY_Photo_DigitalZoomNumerator and PKEY_Photo_DigitalZoomDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoom, 0xF85BF840, 0xA925, 0x4BC2, 0xB0, 0xC4, 0x8E, 0x36, 0xB5, 0x98, 0x67, 0x9E, 100);

//  Name:     System.Photo.DigitalZoomDenominator -- PKEY_Photo_DigitalZoomDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {745BAF0E-E5C1-4CFB-8A1B-D031A0A52393}, 100
//
//  Denominator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomDenominator, 0x745BAF0E, 0xE5C1, 0x4CFB, 0x8A, 0x1B, 0xD0, 0x31, 0xA0, 0xA5, 0x23, 0x93, 100);

//  Name:     System.Photo.DigitalZoomNumerator -- PKEY_Photo_DigitalZoomNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {16CBB924-6500-473B-A5BE-F1599BCBE413}, 100
//
//  Numerator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomNumerator, 0x16CBB924, 0x6500, 0x473B, 0xA5, 0xBE, 0xF1, 0x59, 0x9B, 0xCB, 0xE4, 0x13, 100);

//  Name:     System.Photo.Event -- PKEY_Photo_Event
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 18248
//
//  The event at which the photo was taken
DEFINE_PROPERTYKEY(PKEY_Photo_Event, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 18248);

//  Name:     System.Photo.EXIFVersion -- PKEY_Photo_EXIFVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D35F743A-EB2E-47F2-A286-844132CB1427}, 100
//
//  The EXIF version.
DEFINE_PROPERTYKEY(PKEY_Photo_EXIFVersion, 0xD35F743A, 0xEB2E, 0x47F2, 0xA2, 0x86, 0x84, 0x41, 0x32, 0xCB, 0x14, 0x27, 100);

//  Name:     System.Photo.ExposureBias -- PKEY_Photo_ExposureBias
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37380
//
//  PropertyTagExifExposureBias.  Calculated from PKEY_Photo_ExposureBiasNumerator and PKEY_Photo_ExposureBiasDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBias, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37380);

//  Name:     System.Photo.ExposureBiasDenominator -- PKEY_Photo_ExposureBiasDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: {AB205E50-04B7-461C-A18C-2F233836E627}, 100
//
//  Denominator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasDenominator, 0xAB205E50, 0x04B7, 0x461C, 0xA1, 0x8C, 0x2F, 0x23, 0x38, 0x36, 0xE6, 0x27, 100);

//  Name:     System.Photo.ExposureBiasNumerator -- PKEY_Photo_ExposureBiasNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: {738BF284-1D87-420B-92CF-5834BF6EF9ED}, 100
//
//  Numerator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasNumerator, 0x738BF284, 0x1D87, 0x420B, 0x92, 0xCF, 0x58, 0x34, 0xBF, 0x6E, 0xF9, 0xED, 100);

//  Name:     System.Photo.ExposureIndex -- PKEY_Photo_ExposureIndex
//  Type:     Double -- VT_R8
//  FormatID: {967B5AF8-995A-46ED-9E11-35B3C5B9782D}, 100
//
//  PropertyTagExifExposureIndex.  Calculated from PKEY_Photo_ExposureIndexNumerator and PKEY_Photo_ExposureIndexDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndex, 0x967B5AF8, 0x995A, 0x46ED, 0x9E, 0x11, 0x35, 0xB3, 0xC5, 0xB9, 0x78, 0x2D, 100);

//  Name:     System.Photo.ExposureIndexDenominator -- PKEY_Photo_ExposureIndexDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {93112F89-C28B-492F-8A9D-4BE2062CEE8A}, 100
//
//  Denominator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexDenominator, 0x93112F89, 0xC28B, 0x492F, 0x8A, 0x9D, 0x4B, 0xE2, 0x06, 0x2C, 0xEE, 0x8A, 100);

//  Name:     System.Photo.ExposureIndexNumerator -- PKEY_Photo_ExposureIndexNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {CDEDCF30-8919-44DF-8F4C-4EB2FFDB8D89}, 100
//
//  Numerator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexNumerator, 0xCDEDCF30, 0x8919, 0x44DF, 0x8F, 0x4C, 0x4E, 0xB2, 0xFF, 0xDB, 0x8D, 0x89, 100);

//  Name:     System.Photo.ExposureProgram -- PKEY_Photo_ExposureProgram
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 34850 (PropertyTagExifExposureProg)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgram, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34850);

// Possible discrete values for PKEY_Photo_ExposureProgram are:
#define PHOTO_EXPOSUREPROGRAM_UNKNOWN       0ul
#define PHOTO_EXPOSUREPROGRAM_MANUAL        1ul
#define PHOTO_EXPOSUREPROGRAM_NORMAL        2ul
#define PHOTO_EXPOSUREPROGRAM_APERTURE      3ul
#define PHOTO_EXPOSUREPROGRAM_SHUTTER       4ul
#define PHOTO_EXPOSUREPROGRAM_CREATIVE      5ul
#define PHOTO_EXPOSUREPROGRAM_ACTION        6ul
#define PHOTO_EXPOSUREPROGRAM_PORTRAIT      7ul
#define PHOTO_EXPOSUREPROGRAM_LANDSCAPE     8ul

//  Name:     System.Photo.ExposureProgramText -- PKEY_Photo_ExposureProgramText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FEC690B7-5F30-4646-AE47-4CAAFBA884A3}, 100
//  
//  This is the user-friendly form of System.Photo.ExposureProgram.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgramText, 0xFEC690B7, 0x5F30, 0x4646, 0xAE, 0x47, 0x4C, 0xAA, 0xFB, 0xA8, 0x84, 0xA3, 100);

//  Name:     System.Photo.ExposureTime -- PKEY_Photo_ExposureTime
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 33434
//
//  PropertyTagExifExposureTime.  Calculated from  PKEY_Photo_ExposureTimeNumerator and PKEY_Photo_ExposureTimeDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTime, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33434);

//  Name:     System.Photo.ExposureTimeDenominator -- PKEY_Photo_ExposureTimeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {55E98597-AD16-42E0-B624-21599A199838}, 100
//
//  Denominator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeDenominator, 0x55E98597, 0xAD16, 0x42E0, 0xB6, 0x24, 0x21, 0x59, 0x9A, 0x19, 0x98, 0x38, 100);

//  Name:     System.Photo.ExposureTimeNumerator -- PKEY_Photo_ExposureTimeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {257E44E2-9031-4323-AC38-85C552871B2E}, 100
//
//  Numerator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeNumerator, 0x257E44E2, 0x9031, 0x4323, 0xAC, 0x38, 0x85, 0xC5, 0x52, 0x87, 0x1B, 0x2E, 100);

//  Name:     System.Photo.Flash -- PKEY_Photo_Flash
//  Type:     Byte -- VT_UI1
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37385
//
//  PropertyTagExifFlash
DEFINE_PROPERTYKEY(PKEY_Photo_Flash, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37385);

// Possible discrete values for PKEY_Photo_Flash are:
#define PHOTO_FLASH_NONE                    0
#define PHOTO_FLASH_FLASH                   1
#define PHOTO_FLASH_WITHOUTSTROBE           5
#define PHOTO_FLASH_WITHSTROBE              7
#define PHOTO_FLASH_FLASH_COMPULSORY        9
#define PHOTO_FLASH_FLASH_COMPULSORY_NORETURNLIGHT 13
#define PHOTO_FLASH_FLASH_COMPULSORY_RETURNLIGHT 15
#define PHOTO_FLASH_NONE_COMPULSORY         16
#define PHOTO_FLASH_NONE_AUTO               24
#define PHOTO_FLASH_FLASH_AUTO              25
#define PHOTO_FLASH_FLASH_AUTO_NORETURNLIGHT 29
#define PHOTO_FLASH_FLASH_AUTO_RETURNLIGHT  31
#define PHOTO_FLASH_NOFUNCTION              32
#define PHOTO_FLASH_FLASH_REDEYE            65
#define PHOTO_FLASH_FLASH_REDEYE_NORETURNLIGHT 69
#define PHOTO_FLASH_FLASH_REDEYE_RETURNLIGHT 71
#define PHOTO_FLASH_FLASH_COMPULSORY_REDEYE 73
#define PHOTO_FLASH_FLASH_COMPULSORY_REDEYE_NORETURNLIGHT 77
#define PHOTO_FLASH_FLASH_COMPULSORY_REDEYE_RETURNLIGHT 79
#define PHOTO_FLASH_FLASH_AUTO_REDEYE       89
#define PHOTO_FLASH_FLASH_AUTO_REDEYE_NORETURNLIGHT 93
#define PHOTO_FLASH_FLASH_AUTO_REDEYE_RETURNLIGHT 95

//  Name:     System.Photo.FlashEnergy -- PKEY_Photo_FlashEnergy
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 41483
//
//  PropertyTagExifFlashEnergy.  Calculated from PKEY_Photo_FlashEnergyNumerator and PKEY_Photo_FlashEnergyDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergy, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 41483);

//  Name:     System.Photo.FlashEnergyDenominator -- PKEY_Photo_FlashEnergyDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {D7B61C70-6323-49CD-A5FC-C84277162C97}, 100
//
//  Denominator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyDenominator, 0xD7B61C70, 0x6323, 0x49CD, 0xA5, 0xFC, 0xC8, 0x42, 0x77, 0x16, 0x2C, 0x97, 100);

//  Name:     System.Photo.FlashEnergyNumerator -- PKEY_Photo_FlashEnergyNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {FCAD3D3D-0858-400F-AAA3-2F66CCE2A6BC}, 100
//
//  Numerator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyNumerator, 0xFCAD3D3D, 0x0858, 0x400F, 0xAA, 0xA3, 0x2F, 0x66, 0xCC, 0xE2, 0xA6, 0xBC, 100);

//  Name:     System.Photo.FlashManufacturer -- PKEY_Photo_FlashManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {AABAF6C9-E0C5-4719-8585-57B103E584FE}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashManufacturer, 0xAABAF6C9, 0xE0C5, 0x4719, 0x85, 0x85, 0x57, 0xB1, 0x03, 0xE5, 0x84, 0xFE, 100);

//  Name:     System.Photo.FlashModel -- PKEY_Photo_FlashModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {FE83BB35-4D1A-42E2-916B-06F3E1AF719E}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashModel, 0xFE83BB35, 0x4D1A, 0x42E2, 0x91, 0x6B, 0x06, 0xF3, 0xE1, 0xAF, 0x71, 0x9E, 100);

//  Name:     System.Photo.FlashText -- PKEY_Photo_FlashText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6B8B68F6-200B-47EA-8D25-D8050F57339F}, 100
//  
//  This is the user-friendly form of System.Photo.Flash.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_FlashText, 0x6B8B68F6, 0x200B, 0x47EA, 0x8D, 0x25, 0xD8, 0x05, 0x0F, 0x57, 0x33, 0x9F, 100);

//  Name:     System.Photo.FNumber -- PKEY_Photo_FNumber
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 33437
//
//  PropertyTagExifFNumber.  Calculated from PKEY_Photo_FNumberNumerator and PKEY_Photo_FNumberDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33437);

//  Name:     System.Photo.FNumberDenominator -- PKEY_Photo_FNumberDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {E92A2496-223B-4463-A4E3-30EABBA79D80}, 100
//
//  Denominator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberDenominator, 0xE92A2496, 0x223B, 0x4463, 0xA4, 0xE3, 0x30, 0xEA, 0xBB, 0xA7, 0x9D, 0x80, 100);

//  Name:     System.Photo.FNumberNumerator -- PKEY_Photo_FNumberNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {1B97738A-FDFC-462F-9D93-1957E08BE90C}, 100
//
//  Numerator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberNumerator, 0x1B97738A, 0xFDFC, 0x462F, 0x9D, 0x93, 0x19, 0x57, 0xE0, 0x8B, 0xE9, 0x0C, 100);

//  Name:     System.Photo.FocalLength -- PKEY_Photo_FocalLength
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37386
//
//  PropertyTagExifFocalLength.  Calculated from PKEY_Photo_FocalLengthNumerator and PKEY_Photo_FocalLengthDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLength, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37386);

//  Name:     System.Photo.FocalLengthDenominator -- PKEY_Photo_FocalLengthDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {305BC615-DCA1-44A5-9FD4-10C0BA79412E}, 100
//
//  Denominator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthDenominator, 0x305BC615, 0xDCA1, 0x44A5, 0x9F, 0xD4, 0x10, 0xC0, 0xBA, 0x79, 0x41, 0x2E, 100);

//  Name:     System.Photo.FocalLengthInFilm -- PKEY_Photo_FocalLengthInFilm
//  Type:     UInt16 -- VT_UI2
//  FormatID: {A0E74609-B84D-4F49-B860-462BD9971F98}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthInFilm, 0xA0E74609, 0xB84D, 0x4F49, 0xB8, 0x60, 0x46, 0x2B, 0xD9, 0x97, 0x1F, 0x98, 100);

//  Name:     System.Photo.FocalLengthNumerator -- PKEY_Photo_FocalLengthNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {776B6B3B-1E3D-4B0C-9A0E-8FBAF2A8492A}, 100
//
//  Numerator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthNumerator, 0x776B6B3B, 0x1E3D, 0x4B0C, 0x9A, 0x0E, 0x8F, 0xBA, 0xF2, 0xA8, 0x49, 0x2A, 100);

//  Name:     System.Photo.FocalPlaneXResolution -- PKEY_Photo_FocalPlaneXResolution
//  Type:     Double -- VT_R8
//  FormatID: {CFC08D97-C6F7-4484-89DD-EBEF4356FE76}, 100
//  
//  PropertyTagExifFocalXRes.  Calculated from PKEY_Photo_FocalPlaneXResolutionNumerator and 
//  PKEY_Photo_FocalPlaneXResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolution, 0xCFC08D97, 0xC6F7, 0x4484, 0x89, 0xDD, 0xEB, 0xEF, 0x43, 0x56, 0xFE, 0x76, 100);

//  Name:     System.Photo.FocalPlaneXResolutionDenominator -- PKEY_Photo_FocalPlaneXResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {0933F3F5-4786-4F46-A8E8-D64DD37FA521}, 100
//
//  Denominator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionDenominator, 0x0933F3F5, 0x4786, 0x4F46, 0xA8, 0xE8, 0xD6, 0x4D, 0xD3, 0x7F, 0xA5, 0x21, 100);

//  Name:     System.Photo.FocalPlaneXResolutionNumerator -- PKEY_Photo_FocalPlaneXResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {DCCB10AF-B4E2-4B88-95F9-031B4D5AB490}, 100
//
//  Numerator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionNumerator, 0xDCCB10AF, 0xB4E2, 0x4B88, 0x95, 0xF9, 0x03, 0x1B, 0x4D, 0x5A, 0xB4, 0x90, 100);

//  Name:     System.Photo.FocalPlaneYResolution -- PKEY_Photo_FocalPlaneYResolution
//  Type:     Double -- VT_R8
//  FormatID: {4FFFE4D0-914F-4AC4-8D6F-C9C61DE169B1}, 100
//  
//  PropertyTagExifFocalYRes.  Calculated from PKEY_Photo_FocalPlaneYResolutionNumerator and 
//  PKEY_Photo_FocalPlaneYResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolution, 0x4FFFE4D0, 0x914F, 0x4AC4, 0x8D, 0x6F, 0xC9, 0xC6, 0x1D, 0xE1, 0x69, 0xB1, 100);

//  Name:     System.Photo.FocalPlaneYResolutionDenominator -- PKEY_Photo_FocalPlaneYResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {1D6179A6-A876-4031-B013-3347B2B64DC8}, 100
//
//  Denominator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionDenominator, 0x1D6179A6, 0xA876, 0x4031, 0xB0, 0x13, 0x33, 0x47, 0xB2, 0xB6, 0x4D, 0xC8, 100);

//  Name:     System.Photo.FocalPlaneYResolutionNumerator -- PKEY_Photo_FocalPlaneYResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {A2E541C5-4440-4BA8-867E-75CFC06828CD}, 100
//
//  Numerator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionNumerator, 0xA2E541C5, 0x4440, 0x4BA8, 0x86, 0x7E, 0x75, 0xCF, 0xC0, 0x68, 0x28, 0xCD, 100);

//  Name:     System.Photo.GainControl -- PKEY_Photo_GainControl
//  Type:     Double -- VT_R8
//  FormatID: {FA304789-00C7-4D80-904A-1E4DCC7265AA}, 100 (PropertyTagExifGainControl)
//  
//  This indicates the degree of overall image gain adjustment.
//  
//  Calculated from PKEY_Photo_GainControlNumerator and PKEY_Photo_GainControlDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControl, 0xFA304789, 0x00C7, 0x4D80, 0x90, 0x4A, 0x1E, 0x4D, 0xCC, 0x72, 0x65, 0xAA, 100);

// Possible discrete values for PKEY_Photo_GainControl are:
#define PHOTO_GAINCONTROL_NONE              0.0
#define PHOTO_GAINCONTROL_LOWGAINUP         1.0
#define PHOTO_GAINCONTROL_HIGHGAINUP        2.0
#define PHOTO_GAINCONTROL_LOWGAINDOWN       3.0
#define PHOTO_GAINCONTROL_HIGHGAINDOWN      4.0

//  Name:     System.Photo.GainControlDenominator -- PKEY_Photo_GainControlDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {42864DFD-9DA4-4F77-BDED-4AAD7B256735}, 100
//
//  Denominator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlDenominator, 0x42864DFD, 0x9DA4, 0x4F77, 0xBD, 0xED, 0x4A, 0xAD, 0x7B, 0x25, 0x67, 0x35, 100);

//  Name:     System.Photo.GainControlNumerator -- PKEY_Photo_GainControlNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {8E8ECF7C-B7B8-4EB8-A63F-0EE715C96F9E}, 100
//
//  Numerator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlNumerator, 0x8E8ECF7C, 0xB7B8, 0x4EB8, 0xA6, 0x3F, 0x0E, 0xE7, 0x15, 0xC9, 0x6F, 0x9E, 100);

//  Name:     System.Photo.GainControlText -- PKEY_Photo_GainControlText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C06238B2-0BF9-4279-A723-25856715CB9D}, 100
//  
//  This is the user-friendly form of System.Photo.GainControl.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlText, 0xC06238B2, 0x0BF9, 0x4279, 0xA7, 0x23, 0x25, 0x85, 0x67, 0x15, 0xCB, 0x9D, 100);

//  Name:     System.Photo.ISOSpeed -- PKEY_Photo_ISOSpeed
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 34855
//
//  PropertyTagExifISOSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ISOSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34855);

//  Name:     System.Photo.LensManufacturer -- PKEY_Photo_LensManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E6DDCAF7-29C5-4F0A-9A68-D19412EC7090}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensManufacturer, 0xE6DDCAF7, 0x29C5, 0x4F0A, 0x9A, 0x68, 0xD1, 0x94, 0x12, 0xEC, 0x70, 0x90, 100);

//  Name:     System.Photo.LensModel -- PKEY_Photo_LensModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {E1277516-2B5F-4869-89B1-2E585BD38B7A}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensModel, 0xE1277516, 0x2B5F, 0x4869, 0x89, 0xB1, 0x2E, 0x58, 0x5B, 0xD3, 0x8B, 0x7A, 100);

//  Name:     System.Photo.LightSource -- PKEY_Photo_LightSource
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37384
//
//  PropertyTagExifLightSource
DEFINE_PROPERTYKEY(PKEY_Photo_LightSource, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37384);

// Possible discrete values for PKEY_Photo_LightSource are:
#define PHOTO_LIGHTSOURCE_UNKNOWN           0ul
#define PHOTO_LIGHTSOURCE_DAYLIGHT          1ul
#define PHOTO_LIGHTSOURCE_FLUORESCENT       2ul
#define PHOTO_LIGHTSOURCE_TUNGSTEN          3ul
#define PHOTO_LIGHTSOURCE_STANDARD_A        17ul
#define PHOTO_LIGHTSOURCE_STANDARD_B        18ul
#define PHOTO_LIGHTSOURCE_STANDARD_C        19ul
#define PHOTO_LIGHTSOURCE_D55               20ul
#define PHOTO_LIGHTSOURCE_D65               21ul
#define PHOTO_LIGHTSOURCE_D75               22ul

//  Name:     System.Photo.MakerNote -- PKEY_Photo_MakerNote
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: {FA303353-B659-4052-85E9-BCAC79549B84}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNote, 0xFA303353, 0xB659, 0x4052, 0x85, 0xE9, 0xBC, 0xAC, 0x79, 0x54, 0x9B, 0x84, 100);

//  Name:     System.Photo.MakerNoteOffset -- PKEY_Photo_MakerNoteOffset
//  Type:     UInt64 -- VT_UI8
//  FormatID: {813F4124-34E6-4D17-AB3E-6B1F3C2247A1}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNoteOffset, 0x813F4124, 0x34E6, 0x4D17, 0xAB, 0x3E, 0x6B, 0x1F, 0x3C, 0x22, 0x47, 0xA1, 100);

//  Name:     System.Photo.MaxAperture -- PKEY_Photo_MaxAperture
//  Type:     Double -- VT_R8
//  FormatID: {08F6D7C2-E3F2-44FC-AF1E-5AA5C81A2D3E}, 100
//
//  Calculated from PKEY_Photo_MaxApertureNumerator and PKEY_Photo_MaxApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_MaxAperture, 0x08F6D7C2, 0xE3F2, 0x44FC, 0xAF, 0x1E, 0x5A, 0xA5, 0xC8, 0x1A, 0x2D, 0x3E, 100);

//  Name:     System.Photo.MaxApertureDenominator -- PKEY_Photo_MaxApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {C77724D4-601F-46C5-9B89-C53F93BCEB77}, 100
//
//  Denominator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureDenominator, 0xC77724D4, 0x601F, 0x46C5, 0x9B, 0x89, 0xC5, 0x3F, 0x93, 0xBC, 0xEB, 0x77, 100);

//  Name:     System.Photo.MaxApertureNumerator -- PKEY_Photo_MaxApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {C107E191-A459-44C5-9AE6-B952AD4B906D}, 100
//
//  Numerator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureNumerator, 0xC107E191, 0xA459, 0x44C5, 0x9A, 0xE6, 0xB9, 0x52, 0xAD, 0x4B, 0x90, 0x6D, 100);

//  Name:     System.Photo.MeteringMode -- PKEY_Photo_MeteringMode
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37383
//
//  PropertyTagExifMeteringMode
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringMode, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37383);

// Possible discrete values for PKEY_Photo_MeteringMode are:
#define PHOTO_METERINGMODE_UNKNOWN          0u
#define PHOTO_METERINGMODE_AVERAGE          1u
#define PHOTO_METERINGMODE_CENTER           2u
#define PHOTO_METERINGMODE_SPOT             3u
#define PHOTO_METERINGMODE_MULTISPOT        4u
#define PHOTO_METERINGMODE_PATTERN          5u
#define PHOTO_METERINGMODE_PARTIAL          6u

//  Name:     System.Photo.MeteringModeText -- PKEY_Photo_MeteringModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {F628FD8C-7BA8-465A-A65B-C5AA79263A9E}, 100
//  
//  This is the user-friendly form of System.Photo.MeteringMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringModeText, 0xF628FD8C, 0x7BA8, 0x465A, 0xA6, 0x5B, 0xC5, 0xAA, 0x79, 0x26, 0x3A, 0x9E, 100);

//  Name:     System.Photo.Orientation -- PKEY_Photo_Orientation
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 274 (PropertyTagOrientation)
//  
//  This is the image orientation viewed in terms of rows and columns.
DEFINE_PROPERTYKEY(PKEY_Photo_Orientation, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 274);

// Possible discrete values for PKEY_Photo_Orientation are:
#define PHOTO_ORIENTATION_NORMAL            1u
#define PHOTO_ORIENTATION_FLIPHORIZONTAL    2u
#define PHOTO_ORIENTATION_ROTATE180         3u
#define PHOTO_ORIENTATION_FLIPVERTICAL      4u
#define PHOTO_ORIENTATION_TRANSPOSE         5u
#define PHOTO_ORIENTATION_ROTATE270         6u
#define PHOTO_ORIENTATION_TRANSVERSE        7u
#define PHOTO_ORIENTATION_ROTATE90          8u

//  Name:     System.Photo.OrientationText -- PKEY_Photo_OrientationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A9EA193C-C511-498A-A06B-58E2776DCC28}, 100
//  
//  This is the user-friendly form of System.Photo.Orientation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_OrientationText, 0xA9EA193C, 0xC511, 0x498A, 0xA0, 0x6B, 0x58, 0xE2, 0x77, 0x6D, 0xCC, 0x28, 100);

//  Name:     System.Photo.PeopleNames -- PKEY_Photo_PeopleNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: {E8309B6E-084C-49B4-B1FC-90A80331B638}, 100
//
//  The people tags on an image.
DEFINE_PROPERTYKEY(PKEY_Photo_PeopleNames, 0xE8309B6E, 0x084C, 0x49B4, 0xB1, 0xFC, 0x90, 0xA8, 0x03, 0x31, 0xB6, 0x38, 100);

//  Name:     System.Photo.PhotometricInterpretation -- PKEY_Photo_PhotometricInterpretation
//  Type:     UInt16 -- VT_UI2
//  FormatID: {341796F1-1DF9-4B1C-A564-91BDEFA43877}, 100
//  
//  This is the pixel composition. In JPEG compressed data, a JPEG marker is used 
//  instead of this property.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretation, 0x341796F1, 0x1DF9, 0x4B1C, 0xA5, 0x64, 0x91, 0xBD, 0xEF, 0xA4, 0x38, 0x77, 100);

// Possible discrete values for PKEY_Photo_PhotometricInterpretation are:
#define PHOTO_PHOTOMETRIC_RGB               2u
#define PHOTO_PHOTOMETRIC_YCBCR             6u

//  Name:     System.Photo.PhotometricInterpretationText -- PKEY_Photo_PhotometricInterpretationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {821437D6-9EAB-4765-A589-3B1CBBD22A61}, 100
//  
//  This is the user-friendly form of System.Photo.PhotometricInterpretation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretationText, 0x821437D6, 0x9EAB, 0x4765, 0xA5, 0x89, 0x3B, 0x1C, 0xBB, 0xD2, 0x2A, 0x61, 100);

//  Name:     System.Photo.ProgramMode -- PKEY_Photo_ProgramMode
//  Type:     UInt32 -- VT_UI4
//  FormatID: {6D217F6D-3F6A-4825-B470-5F03CA2FBE9B}, 100
//  
//  This is the class of the program used by the camera to set exposure when the 
//  picture is taken.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramMode, 0x6D217F6D, 0x3F6A, 0x4825, 0xB4, 0x70, 0x5F, 0x03, 0xCA, 0x2F, 0xBE, 0x9B, 100);

// Possible discrete values for PKEY_Photo_ProgramMode are:
#define PHOTO_PROGRAMMODE_NOTDEFINED        0ul
#define PHOTO_PROGRAMMODE_MANUAL            1ul
#define PHOTO_PROGRAMMODE_NORMAL            2ul
#define PHOTO_PROGRAMMODE_APERTURE          3ul
#define PHOTO_PROGRAMMODE_SHUTTER           4ul
#define PHOTO_PROGRAMMODE_CREATIVE          5ul
#define PHOTO_PROGRAMMODE_ACTION            6ul
#define PHOTO_PROGRAMMODE_PORTRAIT          7ul
#define PHOTO_PROGRAMMODE_LANDSCAPE         8ul

//  Name:     System.Photo.ProgramModeText -- PKEY_Photo_ProgramModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7FE3AA27-2648-42F3-89B0-454E5CB150C3}, 100
//  
//  This is the user-friendly form of System.Photo.ProgramMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramModeText, 0x7FE3AA27, 0x2648, 0x42F3, 0x89, 0xB0, 0x45, 0x4E, 0x5C, 0xB1, 0x50, 0xC3, 100);

//  Name:     System.Photo.RelatedSoundFile -- PKEY_Photo_RelatedSoundFile
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {318A6B45-087F-4DC2-B8CC-05359551FC9E}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_RelatedSoundFile, 0x318A6B45, 0x087F, 0x4DC2, 0xB8, 0xCC, 0x05, 0x35, 0x95, 0x51, 0xFC, 0x9E, 100);

//  Name:     System.Photo.Saturation -- PKEY_Photo_Saturation
//  Type:     UInt32 -- VT_UI4
//  FormatID: {49237325-A95A-4F67-B211-816B2D45D2E0}, 100
//  
//  This indicates the direction of saturation processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Saturation, 0x49237325, 0xA95A, 0x4F67, 0xB2, 0x11, 0x81, 0x6B, 0x2D, 0x45, 0xD2, 0xE0, 100);

// Possible discrete values for PKEY_Photo_Saturation are:
#define PHOTO_SATURATION_NORMAL             0ul
#define PHOTO_SATURATION_LOW                1ul
#define PHOTO_SATURATION_HIGH               2ul

//  Name:     System.Photo.SaturationText -- PKEY_Photo_SaturationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {61478C08-B600-4A84-BBE4-E99C45F0A072}, 100
//  
//  This is the user-friendly form of System.Photo.Saturation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SaturationText, 0x61478C08, 0xB600, 0x4A84, 0xBB, 0xE4, 0xE9, 0x9C, 0x45, 0xF0, 0xA0, 0x72, 100);

//  Name:     System.Photo.Sharpness -- PKEY_Photo_Sharpness
//  Type:     UInt32 -- VT_UI4
//  FormatID: {FC6976DB-8349-4970-AE97-B3C5316A08F0}, 100
//  
//  This indicates the direction of sharpness processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Sharpness, 0xFC6976DB, 0x8349, 0x4970, 0xAE, 0x97, 0xB3, 0xC5, 0x31, 0x6A, 0x08, 0xF0, 100);

// Possible discrete values for PKEY_Photo_Sharpness are:
#define PHOTO_SHARPNESS_NORMAL              0ul
#define PHOTO_SHARPNESS_SOFT                1ul
#define PHOTO_SHARPNESS_HARD                2ul

//  Name:     System.Photo.SharpnessText -- PKEY_Photo_SharpnessText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {51EC3F47-DD50-421D-8769-334F50424B1E}, 100
//  
//  This is the user-friendly form of System.Photo.Sharpness.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SharpnessText, 0x51EC3F47, 0xDD50, 0x421D, 0x87, 0x69, 0x33, 0x4F, 0x50, 0x42, 0x4B, 0x1E, 100);

//  Name:     System.Photo.ShutterSpeed -- PKEY_Photo_ShutterSpeed
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37377
//
//  PropertyTagExifShutterSpeed.  Calculated from PKEY_Photo_ShutterSpeedNumerator and PKEY_Photo_ShutterSpeedDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37377);

//  Name:     System.Photo.ShutterSpeedDenominator -- PKEY_Photo_ShutterSpeedDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: {E13D8975-81C7-4948-AE3F-37CAE11E8FF7}, 100
//
//  Denominator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedDenominator, 0xE13D8975, 0x81C7, 0x4948, 0xAE, 0x3F, 0x37, 0xCA, 0xE1, 0x1E, 0x8F, 0xF7, 100);

//  Name:     System.Photo.ShutterSpeedNumerator -- PKEY_Photo_ShutterSpeedNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: {16EA4042-D6F4-4BCA-8349-7C78D30FB333}, 100
//
//  Numerator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedNumerator, 0x16EA4042, 0xD6F4, 0x4BCA, 0x83, 0x49, 0x7C, 0x78, 0xD3, 0x0F, 0xB3, 0x33, 100);

//  Name:     System.Photo.SubjectDistance -- PKEY_Photo_SubjectDistance
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37382
//
//  PropertyTagExifSubjectDist.  Calculated from PKEY_Photo_SubjectDistanceNumerator and PKEY_Photo_SubjectDistanceDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistance, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37382);

//  Name:     System.Photo.SubjectDistanceDenominator -- PKEY_Photo_SubjectDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {0C840A88-B043-466D-9766-D4B26DA3FA77}, 100
//
//  Denominator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceDenominator, 0x0C840A88, 0xB043, 0x466D, 0x97, 0x66, 0xD4, 0xB2, 0x6D, 0xA3, 0xFA, 0x77, 100);

//  Name:     System.Photo.SubjectDistanceNumerator -- PKEY_Photo_SubjectDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: {8AF4961C-F526-43E5-AA81-DB768219178D}, 100
//
//  Numerator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceNumerator, 0x8AF4961C, 0xF526, 0x43E5, 0xAA, 0x81, 0xDB, 0x76, 0x82, 0x19, 0x17, 0x8D, 100);

//  Name:     System.Photo.TagViewAggregate -- PKEY_Photo_TagViewAggregate
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: {B812F15D-C2D8-4BBF-BACD-79744346113F}, 100
//
//  A read-only aggregation of tag-like properties for use in building views.
DEFINE_PROPERTYKEY(PKEY_Photo_TagViewAggregate, 0xB812F15D, 0xC2D8, 0x4BBF, 0xBA, 0xCD, 0x79, 0x74, 0x43, 0x46, 0x11, 0x3F, 100);

//  Name:     System.Photo.TranscodedForSync -- PKEY_Photo_TranscodedForSync
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9A8EBB75-6458-4E82-BACB-35C0095B03BB}, 100
DEFINE_PROPERTYKEY(PKEY_Photo_TranscodedForSync, 0x9A8EBB75, 0x6458, 0x4E82, 0xBA, 0xCB, 0x35, 0xC0, 0x09, 0x5B, 0x03, 0xBB, 100);

//  Name:     System.Photo.WhiteBalance -- PKEY_Photo_WhiteBalance
//  Type:     UInt32 -- VT_UI4
//  FormatID: {EE3D3D8A-5381-4CFA-B13B-AAF66B5F4EC9}, 100
//  
//  This indicates the white balance mode set when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalance, 0xEE3D3D8A, 0x5381, 0x4CFA, 0xB1, 0x3B, 0xAA, 0xF6, 0x6B, 0x5F, 0x4E, 0xC9, 100);

// Possible discrete values for PKEY_Photo_WhiteBalance are:
#define PHOTO_WHITEBALANCE_AUTO             0ul
#define PHOTO_WHITEBALANCE_MANUAL           1ul

//  Name:     System.Photo.WhiteBalanceText -- PKEY_Photo_WhiteBalanceText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6336B95E-C7A7-426D-86FD-7AE3D39C84B4}, 100
//  
//  This is the user-friendly form of System.Photo.WhiteBalance.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalanceText, 0x6336B95E, 0xC7A7, 0x426D, 0x86, 0xFD, 0x7A, 0xE3, 0xD3, 0x9C, 0x84, 0xB4, 100);
 
//-----------------------------------------------------------------------------
// PropGroup properties

//  Name:     System.PropGroup.Advanced -- PKEY_PropGroup_Advanced
//  Type:     Null -- VT_NULL
//  FormatID: {900A403B-097B-4B95-8AE2-071FDAEEB118}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Advanced, 0x900A403B, 0x097B, 0x4B95, 0x8A, 0xE2, 0x07, 0x1F, 0xDA, 0xEE, 0xB1, 0x18, 100);

//  Name:     System.PropGroup.Audio -- PKEY_PropGroup_Audio
//  Type:     Null -- VT_NULL
//  FormatID: {2804D469-788F-48AA-8570-71B9C187E138}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Audio, 0x2804D469, 0x788F, 0x48AA, 0x85, 0x70, 0x71, 0xB9, 0xC1, 0x87, 0xE1, 0x38, 100);

//  Name:     System.PropGroup.Calendar -- PKEY_PropGroup_Calendar
//  Type:     Null -- VT_NULL
//  FormatID: {9973D2B5-BFD8-438A-BA94-5349B293181A}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Calendar, 0x9973D2B5, 0xBFD8, 0x438A, 0xBA, 0x94, 0x53, 0x49, 0xB2, 0x93, 0x18, 0x1A, 100);

//  Name:     System.PropGroup.Camera -- PKEY_PropGroup_Camera
//  Type:     Null -- VT_NULL
//  FormatID: {DE00DE32-547E-4981-AD4B-542F2E9007D8}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Camera, 0xDE00DE32, 0x547E, 0x4981, 0xAD, 0x4B, 0x54, 0x2F, 0x2E, 0x90, 0x07, 0xD8, 100);

//  Name:     System.PropGroup.Contact -- PKEY_PropGroup_Contact
//  Type:     Null -- VT_NULL
//  FormatID: {DF975FD3-250A-4004-858F-34E29A3E37AA}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Contact, 0xDF975FD3, 0x250A, 0x4004, 0x85, 0x8F, 0x34, 0xE2, 0x9A, 0x3E, 0x37, 0xAA, 100);

//  Name:     System.PropGroup.Content -- PKEY_PropGroup_Content
//  Type:     Null -- VT_NULL
//  FormatID: {D0DAB0BA-368A-4050-A882-6C010FD19A4F}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Content, 0xD0DAB0BA, 0x368A, 0x4050, 0xA8, 0x82, 0x6C, 0x01, 0x0F, 0xD1, 0x9A, 0x4F, 100);

//  Name:     System.PropGroup.Description -- PKEY_PropGroup_Description
//  Type:     Null -- VT_NULL
//  FormatID: {8969B275-9475-4E00-A887-FF93B8B41E44}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Description, 0x8969B275, 0x9475, 0x4E00, 0xA8, 0x87, 0xFF, 0x93, 0xB8, 0xB4, 0x1E, 0x44, 100);

//  Name:     System.PropGroup.FileSystem -- PKEY_PropGroup_FileSystem
//  Type:     Null -- VT_NULL
//  FormatID: {E3A7D2C1-80FC-4B40-8F34-30EA111BDC2E}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_FileSystem, 0xE3A7D2C1, 0x80FC, 0x4B40, 0x8F, 0x34, 0x30, 0xEA, 0x11, 0x1B, 0xDC, 0x2E, 100);

//  Name:     System.PropGroup.General -- PKEY_PropGroup_General
//  Type:     Null -- VT_NULL
//  FormatID: {CC301630-B192-4C22-B372-9F4C6D338E07}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_General, 0xCC301630, 0xB192, 0x4C22, 0xB3, 0x72, 0x9F, 0x4C, 0x6D, 0x33, 0x8E, 0x07, 100);

//  Name:     System.PropGroup.GPS -- PKEY_PropGroup_GPS
//  Type:     Null -- VT_NULL
//  FormatID: {F3713ADA-90E3-4E11-AAE5-FDC17685B9BE}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_GPS, 0xF3713ADA, 0x90E3, 0x4E11, 0xAA, 0xE5, 0xFD, 0xC1, 0x76, 0x85, 0xB9, 0xBE, 100);

//  Name:     System.PropGroup.Image -- PKEY_PropGroup_Image
//  Type:     Null -- VT_NULL
//  FormatID: {E3690A87-0FA8-4A2A-9A9F-FCE8827055AC}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Image, 0xE3690A87, 0x0FA8, 0x4A2A, 0x9A, 0x9F, 0xFC, 0xE8, 0x82, 0x70, 0x55, 0xAC, 100);

//  Name:     System.PropGroup.Media -- PKEY_PropGroup_Media
//  Type:     Null -- VT_NULL
//  FormatID: {61872CF7-6B5E-4B4B-AC2D-59DA84459248}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Media, 0x61872CF7, 0x6B5E, 0x4B4B, 0xAC, 0x2D, 0x59, 0xDA, 0x84, 0x45, 0x92, 0x48, 100);

//  Name:     System.PropGroup.MediaAdvanced -- PKEY_PropGroup_MediaAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: {8859A284-DE7E-4642-99BA-D431D044B1EC}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_MediaAdvanced, 0x8859A284, 0xDE7E, 0x4642, 0x99, 0xBA, 0xD4, 0x31, 0xD0, 0x44, 0xB1, 0xEC, 100);

//  Name:     System.PropGroup.Message -- PKEY_PropGroup_Message
//  Type:     Null -- VT_NULL
//  FormatID: {7FD7259D-16B4-4135-9F97-7C96ECD2FA9E}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Message, 0x7FD7259D, 0x16B4, 0x4135, 0x9F, 0x97, 0x7C, 0x96, 0xEC, 0xD2, 0xFA, 0x9E, 100);

//  Name:     System.PropGroup.Music -- PKEY_PropGroup_Music
//  Type:     Null -- VT_NULL
//  FormatID: {68DD6094-7216-40F1-A029-43FE7127043F}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Music, 0x68DD6094, 0x7216, 0x40F1, 0xA0, 0x29, 0x43, 0xFE, 0x71, 0x27, 0x04, 0x3F, 100);

//  Name:     System.PropGroup.Origin -- PKEY_PropGroup_Origin
//  Type:     Null -- VT_NULL
//  FormatID: {2598D2FB-5569-4367-95DF-5CD3A177E1A5}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Origin, 0x2598D2FB, 0x5569, 0x4367, 0x95, 0xDF, 0x5C, 0xD3, 0xA1, 0x77, 0xE1, 0xA5, 100);

//  Name:     System.PropGroup.PhotoAdvanced -- PKEY_PropGroup_PhotoAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: {0CB2BF5A-9EE7-4A86-8222-F01E07FDADAF}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_PhotoAdvanced, 0x0CB2BF5A, 0x9EE7, 0x4A86, 0x82, 0x22, 0xF0, 0x1E, 0x07, 0xFD, 0xAD, 0xAF, 100);

//  Name:     System.PropGroup.RecordedTV -- PKEY_PropGroup_RecordedTV
//  Type:     Null -- VT_NULL
//  FormatID: {E7B33238-6584-4170-A5C0-AC25EFD9DA56}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_RecordedTV, 0xE7B33238, 0x6584, 0x4170, 0xA5, 0xC0, 0xAC, 0x25, 0xEF, 0xD9, 0xDA, 0x56, 100);

//  Name:     System.PropGroup.Video -- PKEY_PropGroup_Video
//  Type:     Null -- VT_NULL
//  FormatID: {BEBE0920-7671-4C54-A3EB-49FDDFC191EE}, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Video, 0xBEBE0920, 0x7671, 0x4C54, 0xA3, 0xEB, 0x49, 0xFD, 0xDF, 0xC1, 0x91, 0xEE, 100);
 
//-----------------------------------------------------------------------------
// PropList properties



//  Name:     System.InfoTipText -- PKEY_InfoTipText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 17
//  
//  The text (with formatted property values) to show in the infotip.
DEFINE_PROPERTYKEY(PKEY_InfoTipText, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 17);

//  Name:     System.PropList.ConflictPrompt -- PKEY_PropList_ConflictPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 11
//  
//  The list of properties to show in the file operation conflict resolution dialog. Properties with empty 
//  values will not be displayed. Register under the regvalue of "ConflictPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_ConflictPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 11);

//  Name:     System.PropList.ContentViewModeForBrowse -- PKEY_PropList_ContentViewModeForBrowse
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 13
//  
//  The list of properties to show in the content view mode of an item in the context of browsing.
//  Register the regvalue under the name of "ContentViewModeForBrowse".
DEFINE_PROPERTYKEY(PKEY_PropList_ContentViewModeForBrowse, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 13);

//  Name:     System.PropList.ContentViewModeForSearch -- PKEY_PropList_ContentViewModeForSearch
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 14
//  
//  The list of properties to show in the content view mode of an item in the context of searching.
//  Register the regvalue under the name of "ContentViewModeForSearch".
DEFINE_PROPERTYKEY(PKEY_PropList_ContentViewModeForSearch, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 14);

//  Name:     System.PropList.ExtendedTileInfo -- PKEY_PropList_ExtendedTileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 9
//  
//  The list of properties to show in the listview on extended tiles. Register under the regvalue of 
//  "ExtendedTileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_ExtendedTileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 9);

//  Name:     System.PropList.FileOperationPrompt -- PKEY_PropList_FileOperationPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 10
//  
//  The list of properties to show in the file operation confirmation dialog. Properties with empty values 
//  will not be displayed. If this list is not specified, then the InfoTip property list is used instead. 
//  Register under the regvalue of "FileOperationPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_FileOperationPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 10);

//  Name:     System.PropList.FullDetails -- PKEY_PropList_FullDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 2
//  
//  The list of all the properties to show in the details page.  Property groups can be included in this list 
//  in order to more easily organize the UI.  Register under the regvalue of "FullDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_FullDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 2);

//  Name:     System.PropList.InfoTip -- PKEY_PropList_InfoTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 4 (PID_PROPLIST_INFOTIP)
//  
//  The list of properties to show in the infotip. Properties with empty values will not be displayed. Register 
//  under the regvalue of "InfoTip".
DEFINE_PROPERTYKEY(PKEY_PropList_InfoTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 4);

//  Name:     System.PropList.NonPersonal -- PKEY_PropList_NonPersonal
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {49D1091F-082E-493F-B23F-D2308AA9668C}, 100
//  
//  The list of properties that are considered 'non-personal'. When told to remove all non-personal properties 
//  from a given file, the system will leave these particular properties untouched. Register under the regvalue 
//  of "NonPersonal".
DEFINE_PROPERTYKEY(PKEY_PropList_NonPersonal, 0x49D1091F, 0x082E, 0x493F, 0xB2, 0x3F, 0xD2, 0x30, 0x8A, 0xA9, 0x66, 0x8C, 100);

//  Name:     System.PropList.PreviewDetails -- PKEY_PropList_PreviewDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 8
//
//  The list of properties to display in the preview pane.  Register under the regvalue of "PreviewDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 8);

//  Name:     System.PropList.PreviewTitle -- PKEY_PropList_PreviewTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 6
//  
//  The one or two properties to display in the preview pane title section.  The optional second property is 
//  displayed as a subtitle.  Register under the regvalue of "PreviewTitle".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewTitle, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 6);

//  Name:     System.PropList.QuickTip -- PKEY_PropList_QuickTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 5 (PID_PROPLIST_QUICKTIP)
//  
//  The list of properties to show in the infotip when the item is on a slow network. Properties with empty 
//  values will not be displayed. Register under the regvalue of "QuickTip".
DEFINE_PROPERTYKEY(PKEY_PropList_QuickTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 5);

//  Name:     System.PropList.TileInfo -- PKEY_PropList_TileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 3 (PID_PROPLIST_TILEINFO)
//  
//  The list of properties to show in the listview on tiles. Register under the regvalue of "TileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_TileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 3);

//  Name:     System.PropList.XPDetailsPanel -- PKEY_PropList_XPDetailsPanel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_WebView) {F2275480-F782-4291-BD94-F13693513AEC}, 0 (PID_DISPLAY_PROPERTIES)
//
//  The list of properties to display in the XP webview details panel. Obsolete.
DEFINE_PROPERTYKEY(PKEY_PropList_XPDetailsPanel, 0xF2275480, 0xF782, 0x4291, 0xBD, 0x94, 0xF1, 0x36, 0x93, 0x51, 0x3A, 0xEC, 0);
 
//-----------------------------------------------------------------------------
// RecordedTV properties



//  Name:     System.RecordedTV.ChannelNumber -- PKEY_RecordedTV_ChannelNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 7
//
//  Example: 42
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ChannelNumber, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 7);

//  Name:     System.RecordedTV.Credits -- PKEY_RecordedTV_Credits
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 4
//
//  Example: "Don Messick/Frank Welker/Casey Kasem/Heather North/Nicole Jaffe;;;"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_Credits, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 4);

//  Name:     System.RecordedTV.DateContentExpires -- PKEY_RecordedTV_DateContentExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 15
DEFINE_PROPERTYKEY(PKEY_RecordedTV_DateContentExpires, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 15);

//  Name:     System.RecordedTV.EpisodeName -- PKEY_RecordedTV_EpisodeName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 2
//
//  Example: "Nowhere to Hyde"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_EpisodeName, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 2);

//  Name:     System.RecordedTV.IsATSCContent -- PKEY_RecordedTV_IsATSCContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 16
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsATSCContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 16);

//  Name:     System.RecordedTV.IsClosedCaptioningAvailable -- PKEY_RecordedTV_IsClosedCaptioningAvailable
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 12
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsClosedCaptioningAvailable, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 12);

//  Name:     System.RecordedTV.IsDTVContent -- PKEY_RecordedTV_IsDTVContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 17
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsDTVContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 17);

//  Name:     System.RecordedTV.IsHDContent -- PKEY_RecordedTV_IsHDContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 18
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsHDContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 18);

//  Name:     System.RecordedTV.IsRepeatBroadcast -- PKEY_RecordedTV_IsRepeatBroadcast
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 13
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsRepeatBroadcast, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 13);

//  Name:     System.RecordedTV.IsSAP -- PKEY_RecordedTV_IsSAP
//  Type:     Boolean -- VT_BOOL
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 14
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsSAP, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 14);

//  Name:     System.RecordedTV.NetworkAffiliation -- PKEY_RecordedTV_NetworkAffiliation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {2C53C813-FB63-4E22-A1AB-0B331CA1E273}, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_NetworkAffiliation, 0x2C53C813, 0xFB63, 0x4E22, 0xA1, 0xAB, 0x0B, 0x33, 0x1C, 0xA1, 0xE2, 0x73, 100);

//  Name:     System.RecordedTV.OriginalBroadcastDate -- PKEY_RecordedTV_OriginalBroadcastDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {4684FE97-8765-4842-9C13-F006447B178C}, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_OriginalBroadcastDate, 0x4684FE97, 0x8765, 0x4842, 0x9C, 0x13, 0xF0, 0x06, 0x44, 0x7B, 0x17, 0x8C, 100);

//  Name:     System.RecordedTV.ProgramDescription -- PKEY_RecordedTV_ProgramDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 3
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ProgramDescription, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 3);

//  Name:     System.RecordedTV.RecordingTime -- PKEY_RecordedTV_RecordingTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {A5477F61-7A82-4ECA-9DDE-98B69B2479B3}, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_RecordingTime, 0xA5477F61, 0x7A82, 0x4ECA, 0x9D, 0xDE, 0x98, 0xB6, 0x9B, 0x24, 0x79, 0xB3, 100);

//  Name:     System.RecordedTV.StationCallSign -- PKEY_RecordedTV_StationCallSign
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 5
//
//  Example: "TOONP"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationCallSign, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 5);

//  Name:     System.RecordedTV.StationName -- PKEY_RecordedTV_StationName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {1B5439E7-EBA1-4AF8-BDD7-7AF1D4549493}, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationName, 0x1B5439E7, 0xEBA1, 0x4AF8, 0xBD, 0xD7, 0x7A, 0xF1, 0xD4, 0x54, 0x94, 0x93, 100);
 
//-----------------------------------------------------------------------------
// Search properties



//  Name:     System.Search.AutoSummary -- PKEY_Search_AutoSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 2
//
//  General Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_AutoSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 2);

//  Name:     System.Search.ContainerHash -- PKEY_Search_ContainerHash
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {BCEEE283-35DF-4D53-826A-F36A3EEFC6BE}, 100
//
//  Hash code used to identify attachments to be deleted based on a common container url
DEFINE_PROPERTYKEY(PKEY_Search_ContainerHash, 0xBCEEE283, 0x35DF, 0x4D53, 0x82, 0x6A, 0xF3, 0x6A, 0x3E, 0xEF, 0xC6, 0xBE, 100);

//  Name:     System.Search.Contents -- PKEY_Search_Contents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 19 (PID_STG_CONTENTS)
//  
//  The contents of the item. This property is for query restrictions only; it cannot be retrieved in a 
//  query result. The Indexing Service friendly name is 'contents'.
DEFINE_PROPERTYKEY(PKEY_Search_Contents, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 19);

//  Name:     System.Search.EntryID -- PKEY_Search_EntryID
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 5 (PROPID_QUERY_WORKID)
//  
//  The entry ID for an item within a given catalog in the Windows Search Index.
//  This value may be recycled, and therefore is not considered unique over time.
DEFINE_PROPERTYKEY(PKEY_Search_EntryID, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 5);

//  Name:     System.Search.ExtendedProperties -- PKEY_Search_ExtendedProperties
//  Type:     Blob -- VT_BLOB
//  FormatID: {7B03B546-FA4F-4A52-A2FE-03D5311E5865}, 100
DEFINE_PROPERTYKEY(PKEY_Search_ExtendedProperties, 0x7B03B546, 0xFA4F, 0x4A52, 0xA2, 0xFE, 0x03, 0xD5, 0x31, 0x1E, 0x58, 0x65, 100);

//  Name:     System.Search.GatherTime -- PKEY_Search_GatherTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {0B63E350-9CCC-11D0-BCDB-00805FCCCE04}, 8
//
//  The Datetime that the Windows Search Gatherer process last pushed properties of this document to the Windows Search Gatherer Plugins.
DEFINE_PROPERTYKEY(PKEY_Search_GatherTime, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 8);

//  Name:     System.Search.HitCount -- PKEY_Search_HitCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 4 (PROPID_QUERY_HITCOUNT)
//  
//  When using CONTAINS over the Windows Search Index, this is the number of matches of the term.
//  If there are multiple CONTAINS, an AND computes the min number of hits and an OR the max number of hits.
DEFINE_PROPERTYKEY(PKEY_Search_HitCount, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 4);

//  Name:     System.Search.IsClosedDirectory -- PKEY_Search_IsClosedDirectory
//  Type:     Boolean -- VT_BOOL
//  FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 23
//
//  If this property is emitted with a value of TRUE, then it indicates that this URL's last modified time applies to all of it's children, and if this URL is deleted then all of it's children are deleted as well.  For example, this would be emitted as TRUE when emitting the URL of an email so that all attachments are tied to the last modified time of that email.
DEFINE_PROPERTYKEY(PKEY_Search_IsClosedDirectory, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 23);

//  Name:     System.Search.IsFullyContained -- PKEY_Search_IsFullyContained
//  Type:     Boolean -- VT_BOOL
//  FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 24
//
//  Any child URL of a URL which has System.Search.IsClosedDirectory=TRUE must emit System.Search.IsFullyContained=TRUE.  This ensures that the URL is not deleted at the end of a crawl because it hasn't been visited (which is the normal mechanism for detecting deletes).  For example an email attachment would emit this property
DEFINE_PROPERTYKEY(PKEY_Search_IsFullyContained, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 24);

//  Name:     System.Search.QueryFocusedSummary -- PKEY_Search_QueryFocusedSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 3
//
//  Query Focused Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_QueryFocusedSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 3);

//  Name:     System.Search.QueryFocusedSummaryWithFallback -- PKEY_Search_QueryFocusedSummaryWithFallback
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 4
//
//  Query Focused Summary of the document, if none is available it returns the AutoSummary.
DEFINE_PROPERTYKEY(PKEY_Search_QueryFocusedSummaryWithFallback, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 4);

//  Name:     System.Search.Rank -- PKEY_Search_Rank
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 3 (PROPID_QUERY_RANK)
//  
//  Relevance rank of row. Ranges from 0-1000. Larger numbers = better matches.  Query-time only.
DEFINE_PROPERTYKEY(PKEY_Search_Rank, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 3);

//  Name:     System.Search.Store -- PKEY_Search_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {A06992B3-8CAF-4ED7-A547-B259E32AC9FC}, 100
//
//  The identifier for the protocol handler that produced this item. (E.g. MAPI, CSC, FILE etc.)
DEFINE_PROPERTYKEY(PKEY_Search_Store, 0xA06992B3, 0x8CAF, 0x4ED7, 0xA5, 0x47, 0xB2, 0x59, 0xE3, 0x2A, 0xC9, 0xFC, 100);

//  Name:     System.Search.UrlToIndex -- PKEY_Search_UrlToIndex
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 2
//
//  This property should be emitted by a container IFilter for each child URL within the container.  The children will eventually be crawled by the indexer if they are within scope.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndex, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 2);

//  Name:     System.Search.UrlToIndexWithModificationTime -- PKEY_Search_UrlToIndexWithModificationTime
//  Type:     Multivalue Any -- VT_VECTOR | VT_NULL  (For variants: VT_ARRAY | VT_NULL)
//  FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 12
//
//  This property is the same as System.Search.UrlToIndex except that it includes the time the URL was last modified.  This is an optimization for the indexer as it doesn't have to call back into the protocol handler to ask for this information to determine if the content needs to be indexed again.  The property is a vector with two elements, a VT_LPWSTR with the URL and a VT_FILETIME for the last modified time.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndexWithModificationTime, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 12);
 
//-----------------------------------------------------------------------------
// Shell properties



//  Name:     System.DescriptionID -- PKEY_DescriptionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 2 (PID_DESCRIPTIONID)
//
//  The contents of a SHDESCRIPTIONID structure as a buffer of bytes.
DEFINE_PROPERTYKEY(PKEY_DescriptionID, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 2);

//  Name:     System.InternalName -- PKEY_InternalName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 5 (PIDVSI_InternalName)
//
//  
DEFINE_PROPERTYKEY(PKEY_InternalName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 5);

//  Name:     System.Link.TargetSFGAOFlagsStrings -- PKEY_Link_TargetSFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D6942081-D53B-443D-AD47-5E059D9CD27A}, 3
//  
//  Expresses the SFGAO flags of a link as string values and is used as a query optimization.  See 
//  PKEY_Shell_SFGAOFlagsStrings for possible values of this.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 3);

//  Name:     System.Link.TargetUrl -- PKEY_Link_TargetUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 2  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_TargetUrl, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 2);

//  Name:     System.NamespaceCLSID -- PKEY_NamespaceCLSID
//  Type:     Guid -- VT_CLSID
//  FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 6
//
//  The CLSID of the name space extension for an item, the object that implements IShellFolder for this item
DEFINE_PROPERTYKEY(PKEY_NamespaceCLSID, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 6);

//  Name:     System.Shell.SFGAOFlagsStrings -- PKEY_Shell_SFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: {D6942081-D53B-443D-AD47-5E059D9CD27A}, 2
//
//  Expresses the SFGAO flags as string values and is used as a query optimization.
DEFINE_PROPERTYKEY(PKEY_Shell_SFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 2);

// Possible discrete values for PKEY_Shell_SFGAOFlagsStrings are:
#define SFGAOSTR_FILESYS                    L"filesys"               // SFGAO_FILESYSTEM
#define SFGAOSTR_FILEANC                    L"fileanc"               // SFGAO_FILESYSANCESTOR
#define SFGAOSTR_STORAGEANC                 L"storageanc"               // SFGAO_STORAGEANCESTOR
#define SFGAOSTR_STREAM                     L"stream"               // SFGAO_STREAM
#define SFGAOSTR_LINK                       L"link"               // SFGAO_LINK
#define SFGAOSTR_HIDDEN                     L"hidden"               // SFGAO_HIDDEN
#define SFGAOSTR_SUPERHIDDEN                L"superhidden"               // SFGAO_SUPERHIDDEN
#define SFGAOSTR_FOLDER                     L"folder"               // SFGAO_FOLDER
#define SFGAOSTR_NONENUM                    L"nonenum"               // SFGAO_NONENUMERATED
#define SFGAOSTR_BROWSABLE                  L"browsable"               // SFGAO_BROWSABLE
 
//-----------------------------------------------------------------------------
// Software properties



//  Name:     System.AppUserModel.ExcludeFromShowInNewInstall -- PKEY_AppUserModel_ExcludeFromShowInNewInstall
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 8
DEFINE_PROPERTYKEY(PKEY_AppUserModel_ExcludeFromShowInNewInstall, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 8);

//  Name:     System.AppUserModel.ID -- PKEY_AppUserModel_ID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 5
DEFINE_PROPERTYKEY(PKEY_AppUserModel_ID, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 5);

//  Name:     System.AppUserModel.IsDestListSeparator -- PKEY_AppUserModel_IsDestListSeparator
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 6
DEFINE_PROPERTYKEY(PKEY_AppUserModel_IsDestListSeparator, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 6);

//  Name:     System.AppUserModel.PreventPinning -- PKEY_AppUserModel_PreventPinning
//  Type:     Boolean -- VT_BOOL
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 9
DEFINE_PROPERTYKEY(PKEY_AppUserModel_PreventPinning, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 9);

//  Name:     System.AppUserModel.RelaunchCommand -- PKEY_AppUserModel_RelaunchCommand
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 2
DEFINE_PROPERTYKEY(PKEY_AppUserModel_RelaunchCommand, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 2);

//  Name:     System.AppUserModel.RelaunchDisplayNameResource -- PKEY_AppUserModel_RelaunchDisplayNameResource
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 4
DEFINE_PROPERTYKEY(PKEY_AppUserModel_RelaunchDisplayNameResource, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 4);

//  Name:     System.AppUserModel.RelaunchIconResource -- PKEY_AppUserModel_RelaunchIconResource
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 3
DEFINE_PROPERTYKEY(PKEY_AppUserModel_RelaunchIconResource, 0x9F4C2855, 0x9F79, 0x4B39, 0xA8, 0xD0, 0xE1, 0xD4, 0x2D, 0xE1, 0xD5, 0xF3, 3);

//  Name:     System.Software.DateLastUsed -- PKEY_Software_DateLastUsed
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: {841E4F90-FF59-4D16-8947-E81BBFFAB36D}, 16
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_DateLastUsed, 0x841E4F90, 0xFF59, 0x4D16, 0x89, 0x47, 0xE8, 0x1B, 0xBF, 0xFA, 0xB3, 0x6D, 16);

//  Name:     System.Software.ProductName -- PKEY_Software_ProductName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 7
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_ProductName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 7);
 
//-----------------------------------------------------------------------------
// Sync properties



//  Name:     System.Sync.Comments -- PKEY_Sync_Comments
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 13
DEFINE_PROPERTYKEY(PKEY_Sync_Comments, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 13);

//  Name:     System.Sync.ConflictDescription -- PKEY_Sync_ConflictDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 4
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictDescription, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 4);

//  Name:     System.Sync.ConflictFirstLocation -- PKEY_Sync_ConflictFirstLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictFirstLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 6);

//  Name:     System.Sync.ConflictSecondLocation -- PKEY_Sync_ConflictSecondLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 7
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictSecondLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 7);

//  Name:     System.Sync.HandlerCollectionID -- PKEY_Sync_HandlerCollectionID
//  Type:     Guid -- VT_CLSID
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerCollectionID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 2);

//  Name:     System.Sync.HandlerID -- PKEY_Sync_HandlerID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 3
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 3);

//  Name:     System.Sync.HandlerName -- PKEY_Sync_HandlerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 2);

//  Name:     System.Sync.HandlerType -- PKEY_Sync_HandlerType
//  Type:     UInt32 -- VT_UI4
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 8
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerType, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 8);

// Possible discrete values for PKEY_Sync_HandlerType are:
#define SYNC_HANDLERTYPE_OTHER              0ul
#define SYNC_HANDLERTYPE_PROGRAMS           1ul
#define SYNC_HANDLERTYPE_DEVICES            2ul
#define SYNC_HANDLERTYPE_FOLDERS            3ul
#define SYNC_HANDLERTYPE_WEBSERVICES        4ul
#define SYNC_HANDLERTYPE_COMPUTERS          5ul

//  Name:     System.Sync.HandlerTypeLabel -- PKEY_Sync_HandlerTypeLabel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 9
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerTypeLabel, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 9);

//  Name:     System.Sync.ItemID -- PKEY_Sync_ItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ItemID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 6);

//  Name:     System.Sync.ItemName -- PKEY_Sync_ItemName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 3
DEFINE_PROPERTYKEY(PKEY_Sync_ItemName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 3);

//  Name:     System.Sync.ProgressPercentage -- PKEY_Sync_ProgressPercentage
//  Type:     UInt32 -- VT_UI4
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 23
//
//  An integer value between 0 and 100 representing the percentage completed.
DEFINE_PROPERTYKEY(PKEY_Sync_ProgressPercentage, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 23);

//  Name:     System.Sync.State -- PKEY_Sync_State
//  Type:     UInt32 -- VT_UI4
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 24
//
//  Sync state.
DEFINE_PROPERTYKEY(PKEY_Sync_State, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 24);

// Possible discrete values for PKEY_Sync_State are:
#define SYNC_STATE_NOTSETUP                 0ul
#define SYNC_STATE_SYNCNOTRUN               1ul
#define SYNC_STATE_IDLE                     2ul
#define SYNC_STATE_ERROR                    3ul
#define SYNC_STATE_PENDING                  4ul
#define SYNC_STATE_SYNCING                  5ul

//  Name:     System.Sync.Status -- PKEY_Sync_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 10
DEFINE_PROPERTYKEY(PKEY_Sync_Status, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 10);
 
//-----------------------------------------------------------------------------
// Task properties

//  Name:     System.Task.BillingInformation -- PKEY_Task_BillingInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {D37D52C6-261C-4303-82B3-08B926AC6F12}, 100
DEFINE_PROPERTYKEY(PKEY_Task_BillingInformation, 0xD37D52C6, 0x261C, 0x4303, 0x82, 0xB3, 0x08, 0xB9, 0x26, 0xAC, 0x6F, 0x12, 100);

//  Name:     System.Task.CompletionStatus -- PKEY_Task_CompletionStatus
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {084D8A0A-E6D5-40DE-BF1F-C8820E7C877C}, 100
DEFINE_PROPERTYKEY(PKEY_Task_CompletionStatus, 0x084D8A0A, 0xE6D5, 0x40DE, 0xBF, 0x1F, 0xC8, 0x82, 0x0E, 0x7C, 0x87, 0x7C, 100);

//  Name:     System.Task.Owner -- PKEY_Task_Owner
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: {08C7CC5F-60F2-4494-AD75-55E3E0B5ADD0}, 100
DEFINE_PROPERTYKEY(PKEY_Task_Owner, 0x08C7CC5F, 0x60F2, 0x4494, 0xAD, 0x75, 0x55, 0xE3, 0xE0, 0xB5, 0xAD, 0xD0, 100);

 
 
//-----------------------------------------------------------------------------
// Video properties

//  Name:     System.Video.Compression -- PKEY_Video_Compression
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 10 (PIDVSI_COMPRESSION)
//
//  Indicates the level of compression for the video stream.  "Compression".
DEFINE_PROPERTYKEY(PKEY_Video_Compression, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 10);

//  Name:     System.Video.Director -- PKEY_Video_Director
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 20 (PIDMSI_DIRECTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Video_Director, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 20);

//  Name:     System.Video.EncodingBitrate -- PKEY_Video_EncodingBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 8 (PIDVSI_DATA_RATE)
//
//  Indicates the data rate in "bits per second" for the video stream. "DataRate".
DEFINE_PROPERTYKEY(PKEY_Video_EncodingBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 8);

//  Name:     System.Video.FourCC -- PKEY_Video_FourCC
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 44
//  
//  Indicates the 4CC for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FourCC, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 44);

//  Name:     System.Video.FrameHeight -- PKEY_Video_FrameHeight
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 4
//
//  Indicates the frame height for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameHeight, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

//  Name:     System.Video.FrameRate -- PKEY_Video_FrameRate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 6 (PIDVSI_FRAME_RATE)
//
//  Indicates the frame rate in "frames per millisecond" for the video stream.  "FrameRate".
DEFINE_PROPERTYKEY(PKEY_Video_FrameRate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Video.FrameWidth -- PKEY_Video_FrameWidth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 3
//
//  Indicates the frame width for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameWidth, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Video.HorizontalAspectRatio -- PKEY_Video_HorizontalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 42
//  
//  Indicates the horizontal portion of the aspect ratio. The X portion of XX:YY,
//  like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_HorizontalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 42);

//  Name:     System.Video.SampleSize -- PKEY_Video_SampleSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 9 (PIDVSI_SAMPLE_SIZE)
//
//  Indicates the sample size in bits for the video stream.  "SampleSize".
DEFINE_PROPERTYKEY(PKEY_Video_SampleSize, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

//  Name:     System.Video.StreamName -- PKEY_Video_StreamName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 2 (PIDVSI_STREAM_NAME)
//
//  Indicates the name for the video stream. "StreamName".
DEFINE_PROPERTYKEY(PKEY_Video_StreamName, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 2);

//  Name:     System.Video.StreamNumber -- PKEY_Video_StreamNumber
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 11 (PIDVSI_STREAM_NUMBER)
//
//  "Stream Number".
DEFINE_PROPERTYKEY(PKEY_Video_StreamNumber, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 11);

//  Name:     System.Video.TotalBitrate -- PKEY_Video_TotalBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 43 (PIDVSI_TOTAL_BITRATE)
//
//  Indicates the total data rate in "bits per second" for all video and audio streams.
DEFINE_PROPERTYKEY(PKEY_Video_TotalBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 43);

//  Name:     System.Video.TranscodedForSync -- PKEY_Video_TranscodedForSync
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 46
DEFINE_PROPERTYKEY(PKEY_Video_TranscodedForSync, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 46);

//  Name:     System.Video.VerticalAspectRatio -- PKEY_Video_VerticalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 45
//  
//  Indicates the vertical portion of the aspect ratio. The Y portion of 
//  XX:YY, like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_VerticalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 45);
 
//-----------------------------------------------------------------------------
// Volume properties



//  Name:     System.Volume.FileSystem -- PKEY_Volume_FileSystem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 4 (PID_VOLUME_FILESYSTEM)  (Filesystem Volume Properties)
//
//  Indicates the filesystem of the volume.
DEFINE_PROPERTYKEY(PKEY_Volume_FileSystem, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 4);

//  Name:     System.Volume.IsMappedDrive -- PKEY_Volume_IsMappedDrive
//  Type:     Boolean -- VT_BOOL
//  FormatID: {149C0B69-2C2D-48FC-808F-D318D78C4636}, 2
DEFINE_PROPERTYKEY(PKEY_Volume_IsMappedDrive, 0x149C0B69, 0x2C2D, 0x48FC, 0x80, 0x8F, 0xD3, 0x18, 0xD7, 0x8C, 0x46, 0x36, 2);

//  Name:     System.Volume.IsRoot -- PKEY_Volume_IsRoot
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 10  (Filesystem Volume Properties)
//
//  
DEFINE_PROPERTYKEY(PKEY_Volume_IsRoot, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 10);

#endif  /* _INC_PROPKEY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PropIdl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propidl_h__
#define __propidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertyStorage_FWD_DEFINED__
#define __IPropertyStorage_FWD_DEFINED__
typedef interface IPropertyStorage IPropertyStorage;
#endif 	/* __IPropertyStorage_FWD_DEFINED__ */


#ifndef __IPropertySetStorage_FWD_DEFINED__
#define __IPropertySetStorage_FWD_DEFINED__
typedef interface IPropertySetStorage IPropertySetStorage;
#endif 	/* __IPropertySetStorage_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_FWD_DEFINED__
#define __IEnumSTATPROPSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSTG IEnumSTATPROPSTG;
#endif 	/* __IEnumSTATPROPSTG_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_FWD_DEFINED__
#define __IEnumSTATPROPSETSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;
#endif 	/* __IEnumSTATPROPSETSTG_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_propidl_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#pragma warning(disable:4237)    /* obsolete member named 'bool' */
#endif
#if ( _MSC_VER >= 1020 )
#pragma once
#endif



typedef struct tagVersionedStream
    {
    GUID guidVersion;
    IStream *pStream;
    } 	VERSIONEDSTREAM;

typedef struct tagVersionedStream *LPVERSIONEDSTREAM;


// Flags for IPropertySetStorage::Create
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

//   (This flag is only supported on StgCreatePropStg & StgOpenPropStg
#define	PROPSETFLAG_UNBUFFERED	( 4 )

//   (This flag causes a version-1 property set to be created
#define	PROPSETFLAG_CASE_SENSITIVE	( 8 )


// Flags for the reservied PID_BEHAVIOR property
#define	PROPSET_BEHAVIOR_CASE_SENSITIVE	( 1 )

#ifdef MIDL_PASS
// This is the PROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT PROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT PROPVARIANT;
#endif
typedef struct tagCAC
    {
    ULONG cElems;
    CHAR *pElems;
    } 	CAC;

typedef struct tagCAUB
    {
    ULONG cElems;
    UCHAR *pElems;
    } 	CAUB;

typedef struct tagCAI
    {
    ULONG cElems;
    SHORT *pElems;
    } 	CAI;

typedef struct tagCAUI
    {
    ULONG cElems;
    USHORT *pElems;
    } 	CAUI;

typedef struct tagCAL
    {
    ULONG cElems;
    LONG *pElems;
    } 	CAL;

typedef struct tagCAUL
    {
    ULONG cElems;
    ULONG *pElems;
    } 	CAUL;

typedef struct tagCAFLT
    {
    ULONG cElems;
    FLOAT *pElems;
    } 	CAFLT;

typedef struct tagCADBL
    {
    ULONG cElems;
    DOUBLE *pElems;
    } 	CADBL;

typedef struct tagCACY
    {
    ULONG cElems;
    CY *pElems;
    } 	CACY;

typedef struct tagCADATE
    {
    ULONG cElems;
    DATE *pElems;
    } 	CADATE;

typedef struct tagCABSTR
    {
    ULONG cElems;
    BSTR *pElems;
    } 	CABSTR;

typedef struct tagCABSTRBLOB
    {
    ULONG cElems;
    BSTRBLOB *pElems;
    } 	CABSTRBLOB;

typedef struct tagCABOOL
    {
    ULONG cElems;
    VARIANT_BOOL *pElems;
    } 	CABOOL;

typedef struct tagCASCODE
    {
    ULONG cElems;
    SCODE *pElems;
    } 	CASCODE;

typedef struct tagCAPROPVARIANT
    {
    ULONG cElems;
    PROPVARIANT *pElems;
    } 	CAPROPVARIANT;

typedef struct tagCAH
    {
    ULONG cElems;
    LARGE_INTEGER *pElems;
    } 	CAH;

typedef struct tagCAUH
    {
    ULONG cElems;
    ULARGE_INTEGER *pElems;
    } 	CAUH;

typedef struct tagCALPSTR
    {
    ULONG cElems;
    LPSTR *pElems;
    } 	CALPSTR;

typedef struct tagCALPWSTR
    {
    ULONG cElems;
    LPWSTR *pElems;
    } 	CALPWSTR;

typedef struct tagCAFILETIME
    {
    ULONG cElems;
    FILETIME *pElems;
    } 	CAFILETIME;

typedef struct tagCACLIPDATA
    {
    ULONG cElems;
    CLIPDATA *pElems;
    } 	CACLIPDATA;

typedef struct tagCACLSID
    {
    ULONG cElems;
    CLSID *pElems;
    } 	CACLSID;

#ifdef MIDL_PASS
// This is the PROPVARIANT padding layout for marshaling.
typedef BYTE PROPVAR_PAD1;

typedef BYTE PROPVAR_PAD2;

typedef ULONG PROPVAR_PAD3;

#else
// This is the standard C layout of the structure.
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;
#define tag_inner_PROPVARIANT
#endif

#if !defined(_MSC_EXTENSIONS)

struct tagPROPVARIANT;

#else
#ifndef MIDL_PASS
struct tagPROPVARIANT {
  union {
#endif
struct tag_inner_PROPVARIANT
    {
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    /* [switch_type] */ union 
        {
         /* Empty union arm */ 
        CHAR cVal;
        UCHAR bVal;
        SHORT iVal;
        USHORT uiVal;
        LONG lVal;
        ULONG ulVal;
        INT intVal;
        UINT uintVal;
        LARGE_INTEGER hVal;
        ULARGE_INTEGER uhVal;
        FLOAT fltVal;
        DOUBLE dblVal;
        VARIANT_BOOL boolVal;
        _VARIANT_BOOL bool;
        SCODE scode;
        CY cyVal;
        DATE date;
        FILETIME filetime;
        CLSID *puuid;
        CLIPDATA *pclipdata;
        BSTR bstrVal;
        BSTRBLOB bstrblobVal;
        BLOB blob;
        LPSTR pszVal;
        LPWSTR pwszVal;
        IUnknown *punkVal;
        IDispatch *pdispVal;
        IStream *pStream;
        IStorage *pStorage;
        LPVERSIONEDSTREAM pVersionedStream;
        LPSAFEARRAY parray;
        CAC cac;
        CAUB caub;
        CAI cai;
        CAUI caui;
        CAL cal;
        CAUL caul;
        CAH cah;
        CAUH cauh;
        CAFLT caflt;
        CADBL cadbl;
        CABOOL cabool;
        CASCODE cascode;
        CACY cacy;
        CADATE cadate;
        CAFILETIME cafiletime;
        CACLSID cauuid;
        CACLIPDATA caclipdata;
        CABSTR cabstr;
        CABSTRBLOB cabstrblob;
        CALPSTR calpstr;
        CALPWSTR calpwstr;
        CAPROPVARIANT capropvar;
        CHAR *pcVal;
        UCHAR *pbVal;
        SHORT *piVal;
        USHORT *puiVal;
        LONG *plVal;
        ULONG *pulVal;
        INT *pintVal;
        UINT *puintVal;
        FLOAT *pfltVal;
        DOUBLE *pdblVal;
        VARIANT_BOOL *pboolVal;
        DECIMAL *pdecVal;
        SCODE *pscode;
        CY *pcyVal;
        DATE *pdate;
        BSTR *pbstrVal;
        IUnknown **ppunkVal;
        IDispatch **ppdispVal;
        LPSAFEARRAY *pparray;
        PROPVARIANT *pvarVal;
        } 	;
    } ;
#ifndef MIDL_PASS
    DECIMAL decVal;
  };
};
#endif

#endif /* _MSC_EXTENSIONS */

#ifdef MIDL_PASS
// This is the LPPROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT *LPPROPVARIANT;

typedef const PROPVARIANT *REFPROPVARIANT;

#else

// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT * LPPROPVARIANT;

#ifndef _REFPROPVARIANT_DEFINED
#define _REFPROPVARIANT_DEFINED
#ifdef __cplusplus
#define REFPROPVARIANT const PROPVARIANT &
#else
#define REFPROPVARIANT const PROPVARIANT * __MIDL_CONST
#endif
#endif

#endif // MIDL_PASS

// Reserved global Property IDs
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_BEHAVIOR	( 0x80000003 )

#define	PID_ILLEGAL	( 0xffffffff )

// Range which is read-only to downlevel implementations
#define	PID_MIN_READONLY	( 0x80000000 )

#define	PID_MAX_READONLY	( 0xbfffffff )

// Property IDs for the DiscardableInformation Property Set

#define PIDDI_THUMBNAIL          0x00000002L // VT_BLOB

// Property IDs for the SummaryInformation Property Set

#define PIDSI_TITLE               0x00000002L  // VT_LPSTR
#define PIDSI_SUBJECT             0x00000003L  // VT_LPSTR
#define PIDSI_AUTHOR              0x00000004L  // VT_LPSTR
#define PIDSI_KEYWORDS            0x00000005L  // VT_LPSTR
#define PIDSI_COMMENTS            0x00000006L  // VT_LPSTR
#define PIDSI_TEMPLATE            0x00000007L  // VT_LPSTR
#define PIDSI_LASTAUTHOR          0x00000008L  // VT_LPSTR
#define PIDSI_REVNUMBER           0x00000009L  // VT_LPSTR
#define PIDSI_EDITTIME            0x0000000aL  // VT_FILETIME (UTC)
#define PIDSI_LASTPRINTED         0x0000000bL  // VT_FILETIME (UTC)
#define PIDSI_CREATE_DTM          0x0000000cL  // VT_FILETIME (UTC)
#define PIDSI_LASTSAVE_DTM        0x0000000dL  // VT_FILETIME (UTC)
#define PIDSI_PAGECOUNT           0x0000000eL  // VT_I4
#define PIDSI_WORDCOUNT           0x0000000fL  // VT_I4
#define PIDSI_CHARCOUNT           0x00000010L  // VT_I4
#define PIDSI_THUMBNAIL           0x00000011L  // VT_CF
#define PIDSI_APPNAME             0x00000012L  // VT_LPSTR
#define PIDSI_DOC_SECURITY        0x00000013L  // VT_I4

// Property IDs for the DocSummaryInformation Property Set

#define PIDDSI_CATEGORY          0x00000002 // VT_LPSTR
#define PIDDSI_PRESFORMAT        0x00000003 // VT_LPSTR
#define PIDDSI_BYTECOUNT         0x00000004 // VT_I4
#define PIDDSI_LINECOUNT         0x00000005 // VT_I4
#define PIDDSI_PARCOUNT          0x00000006 // VT_I4
#define PIDDSI_SLIDECOUNT        0x00000007 // VT_I4
#define PIDDSI_NOTECOUNT         0x00000008 // VT_I4
#define PIDDSI_HIDDENCOUNT       0x00000009 // VT_I4
#define PIDDSI_MMCLIPCOUNT       0x0000000A // VT_I4
#define PIDDSI_SCALE             0x0000000B // VT_BOOL
#define PIDDSI_HEADINGPAIR       0x0000000C // VT_VARIANT | VT_VECTOR
#define PIDDSI_DOCPARTS          0x0000000D // VT_LPSTR | VT_VECTOR
#define PIDDSI_MANAGER           0x0000000E // VT_LPSTR
#define PIDDSI_COMPANY           0x0000000F // VT_LPSTR
#define PIDDSI_LINKSDIRTY        0x00000010 // VT_BOOL


//  FMTID_MediaFileSummaryInfo - Property IDs

#define PIDMSI_EDITOR                   0x00000002L  // VT_LPWSTR
#define PIDMSI_SUPPLIER                 0x00000003L  // VT_LPWSTR
#define PIDMSI_SOURCE                   0x00000004L  // VT_LPWSTR
#define PIDMSI_SEQUENCE_NO              0x00000005L  // VT_LPWSTR
#define PIDMSI_PROJECT                  0x00000006L  // VT_LPWSTR
#define PIDMSI_STATUS                   0x00000007L  // VT_UI4
#define PIDMSI_OWNER                    0x00000008L  // VT_LPWSTR
#define PIDMSI_RATING                   0x00000009L  // VT_LPWSTR
#define PIDMSI_PRODUCTION               0x0000000AL  // VT_FILETIME (UTC)
#define PIDMSI_COPYRIGHT                0x0000000BL  // VT_LPWSTR

//  PIDMSI_STATUS value definitions

enum PIDMSI_STATUS_VALUE
    {	PIDMSI_STATUS_NORMAL	= 0,
	PIDMSI_STATUS_NEW	= ( PIDMSI_STATUS_NORMAL + 1 ) ,
	PIDMSI_STATUS_PRELIM	= ( PIDMSI_STATUS_NEW + 1 ) ,
	PIDMSI_STATUS_DRAFT	= ( PIDMSI_STATUS_PRELIM + 1 ) ,
	PIDMSI_STATUS_INPROGRESS	= ( PIDMSI_STATUS_DRAFT + 1 ) ,
	PIDMSI_STATUS_EDIT	= ( PIDMSI_STATUS_INPROGRESS + 1 ) ,
	PIDMSI_STATUS_REVIEW	= ( PIDMSI_STATUS_EDIT + 1 ) ,
	PIDMSI_STATUS_PROOF	= ( PIDMSI_STATUS_REVIEW + 1 ) ,
	PIDMSI_STATUS_FINAL	= ( PIDMSI_STATUS_PROOF + 1 ) ,
	PIDMSI_STATUS_OTHER	= 0x7fff
    } ;
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct tagPROPSPEC
    {
    ULONG ulKind;
    /* [switch_type] */ union 
        {
        PROPID propid;
        LPOLESTR lpwstr;
         /* Empty union arm */ 
        } 	DUMMYUNIONNAME;
    } 	PROPSPEC;

typedef struct tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    } 	STATPROPSTG;

// Macros for parsing the OS Version of the Property Set Header
#define PROPSETHDR_OSVER_KIND(dwOSVer)      HIWORD( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF
typedef struct tagSTATPROPSETSTG
    {
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
    } 	STATPROPSETSTG;



extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0000_v0_0_s_ifspec;

#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

/* interface IPropertyStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000138-0000-0000-C000-000000000046")
    IPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            __RPC__in IPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            __RPC__in IPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        END_INTERFACE
    } IPropertyStorageVtbl;

    interface IPropertyStorage
    {
        CONST_VTBL struct IPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySetStorage_INTERFACE_DEFINED__
#define __IPropertySetStorage_INTERFACE_DEFINED__

/* interface IPropertySetStorage */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertySetStorage *LPPROPERTYSETSTORAGE;


EXTERN_C const IID IID_IPropertySetStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013A-0000-0000-C000-000000000046")
    IPropertySetStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [unique][in] */ __RPC__in_opt const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ __RPC__in REFFMTID rfmtid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertySetStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertySetStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertySetStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [unique][in] */ __RPC__in_opt const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            __RPC__in IPropertySetStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IPropertySetStorageVtbl;

    interface IPropertySetStorage
    {
        CONST_VTBL struct IPropertySetStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySetStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySetStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySetStorage_Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)	\
    ( (This)->lpVtbl -> Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg) ) 

#define IPropertySetStorage_Open(This,rfmtid,grfMode,ppprstg)	\
    ( (This)->lpVtbl -> Open(This,rfmtid,grfMode,ppprstg) ) 

#define IPropertySetStorage_Delete(This,rfmtid)	\
    ( (This)->lpVtbl -> Delete(This,rfmtid) ) 

#define IPropertySetStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySetStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATPROPSTG *LPENUMSTATPROPSTG;


EXTERN_C const IID IID_IEnumSTATPROPSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000139-0000-0000-C000-000000000046")
    IEnumSTATPROPSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  STATPROPSTG *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumSTATPROPSTG * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumSTATPROPSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumSTATPROPSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  STATPROPSTG *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumSTATPROPSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumSTATPROPSTG * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSTGVtbl;

    interface IEnumSTATPROPSTG
    {
        CONST_VTBL struct IEnumSTATPROPSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSTG_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATPROPSTG_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATPROPSTG_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATPROPSTG_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATPROPSTG_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATPROPSTG_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATPROPSTG_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    __RPC__in IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSTG_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSETSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG;


EXTERN_C const IID IID_IEnumSTATPROPSETSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013B-0000-0000-C000-000000000046")
    IEnumSTATPROPSETSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  STATPROPSETSTG *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSETSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumSTATPROPSETSTG * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumSTATPROPSETSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumSTATPROPSETSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(celt, *pceltFetched)  STATPROPSETSTG *rgelt,
            /* [annotation][out] */ 
            __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumSTATPROPSETSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumSTATPROPSETSTG * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSETSTGVtbl;

    interface IEnumSTATPROPSETSTG
    {
        CONST_VTBL struct IEnumSTATPROPSETSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSETSTG_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATPROPSETSTG_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATPROPSETSTG_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATPROPSETSTG_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATPROPSETSTG_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATPROPSETSTG_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATPROPSETSTG_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    __RPC__in IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSETSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSETSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propidl_0000_0004 */
/* [local] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertyStorage *LPPROPERTYSTORAGE;

__checkReturn WINOLEAPI PropVariantCopy(
            __out PROPVARIANT* pvarDest,
            __in const PROPVARIANT * pvarSrc);

WINOLEAPI PropVariantClear(__inout PROPVARIANT* pvar);

WINOLEAPI FreePropVariantArray(
            __in ULONG cVariants,
            __inout_ecount(cVariants) PROPVARIANT* rgvars);

#if defined(_MSC_EXTENSIONS)


#define _PROPVARIANTINIT_DEFINED_

#   ifdef __cplusplus

inline void PropVariantInit (__out PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}

#   else

#   define PropVariantInit(pvar) memset ( (pvar), 0, sizeof(PROPVARIANT) )

#   endif


#endif /* _MSC_EXTENSIONS */


#ifndef _STGCREATEPROPSTG_DEFINED_

__checkReturn WINOLEAPI StgCreatePropStg(
            __in IUnknown* pUnk,
            __in REFFMTID fmtid,
            __in const CLSID* pclsid,
            __in DWORD grfFlags,
            __in __reserved DWORD dwReserved,
            __deref_out IPropertyStorage** ppPropStg);

__checkReturn WINOLEAPI StgOpenPropStg(
            __in IUnknown* pUnk,
            __in REFFMTID fmtid,
            __in DWORD grfFlags,
            __in __reserved DWORD dwReserved,
            __deref_out IPropertyStorage** ppPropStg);

__checkReturn WINOLEAPI StgCreatePropSetStg(
            __in IStorage* pStorage,
            __in __reserved DWORD dwReserved,
            __deref_out IPropertySetStorage** ppPropSetStg);

#define CCH_MAX_PROPSTG_NAME    31

__checkReturn WINOLEAPI FmtIdToPropStgName(
            __in const FMTID* pfmtid,
            __out_ecount(CCH_MAX_PROPSTG_NAME+1) LPOLESTR oszName);

__checkReturn WINOLEAPI PropStgNameToFmtId(
            __in const LPOLESTR oszName,
            __out FMTID* pfmtid);

#endif

#ifndef _SERIALIZEDPROPERTYVALUE_DEFINED_
#define _SERIALIZEDPROPERTYVALUE_DEFINED_
typedef struct tagSERIALIZEDPROPERTYVALUE
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;
#endif

EXTERN_C
__success(TRUE)  /* Raises status on failure */
SERIALIZEDPROPERTYVALUE* __stdcall
StgConvertVariantToProperty(
            __in const PROPVARIANT* pvar,
            __in USHORT CodePage,
            __out_bcount_opt(*pcb) SERIALIZEDPROPERTYVALUE* pprop,
            __inout ULONG* pcb,
            __in PROPID pid,
            __in __reserved BOOLEAN fReserved,
            __inout_opt ULONG* pcIndirect);

#ifdef __cplusplus
class PMemoryAllocator;

EXTERN_C
__success(TRUE)  /* Raises status on failure */
BOOLEAN __stdcall
StgConvertPropertyToVariant(
            __in const SERIALIZEDPROPERTYVALUE* pprop,
            __in USHORT CodePage,
            __out PROPVARIANT* pvar,
            __in PMemoryAllocator* pma);
#endif


#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)    /* Nameless struct/union */
#pragma warning(default:4237)    /* keywords bool, true, false, etc.. */
#endif


extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  STATPROPSTG *rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub( 
    __RPC__in IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [annotation][length_is][size_is][out] */ 
    __out_ecount_part(celt, *pceltFetched)  STATPROPSETSTG *rgelt,
    /* [annotation][out] */ 
    __out_opt __deref_out_range(0, celt)  ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub( 
    __RPC__in IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSETSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ProvExce.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

#ifdef _M_CEE_PURE
#define PROVIDER_EXCEPT_API_INLINE __clrcall
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE __se_translator_function_m
#else
#define PROVIDER_EXCEPT_API_INLINE __cdecl
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE _se_translator_function
#endif

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

#ifndef _M_CEE_PURE

class CSetStructuredExceptionHandler
{
private:

    PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE m_PrevFunc ;

public:

    static void PROVIDER_EXCEPT_API_INLINE trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		// Foreign exception translator is no longer used
	}

	~CSetStructuredExceptionHandler ()
	{
	}
} ;

#endif // ndef _M_CEE_PURE

/**************************************************************
 *
 **************************************************************/


#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\propsys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for propsys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propsys_h__
#define __propsys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInitializeWithFile_FWD_DEFINED__
#define __IInitializeWithFile_FWD_DEFINED__
typedef interface IInitializeWithFile IInitializeWithFile;
#endif 	/* __IInitializeWithFile_FWD_DEFINED__ */


#ifndef __IInitializeWithStream_FWD_DEFINED__
#define __IInitializeWithStream_FWD_DEFINED__
typedef interface IInitializeWithStream IInitializeWithStream;
#endif 	/* __IInitializeWithStream_FWD_DEFINED__ */


#ifndef __IPropertyStore_FWD_DEFINED__
#define __IPropertyStore_FWD_DEFINED__
typedef interface IPropertyStore IPropertyStore;
#endif 	/* __IPropertyStore_FWD_DEFINED__ */


#ifndef __INamedPropertyStore_FWD_DEFINED__
#define __INamedPropertyStore_FWD_DEFINED__
typedef interface INamedPropertyStore INamedPropertyStore;
#endif 	/* __INamedPropertyStore_FWD_DEFINED__ */


#ifndef __IObjectWithPropertyKey_FWD_DEFINED__
#define __IObjectWithPropertyKey_FWD_DEFINED__
typedef interface IObjectWithPropertyKey IObjectWithPropertyKey;
#endif 	/* __IObjectWithPropertyKey_FWD_DEFINED__ */


#ifndef __IPropertyChange_FWD_DEFINED__
#define __IPropertyChange_FWD_DEFINED__
typedef interface IPropertyChange IPropertyChange;
#endif 	/* __IPropertyChange_FWD_DEFINED__ */


#ifndef __IPropertyChangeArray_FWD_DEFINED__
#define __IPropertyChangeArray_FWD_DEFINED__
typedef interface IPropertyChangeArray IPropertyChangeArray;
#endif 	/* __IPropertyChangeArray_FWD_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_FWD_DEFINED__
#define __IPropertyStoreCapabilities_FWD_DEFINED__
typedef interface IPropertyStoreCapabilities IPropertyStoreCapabilities;
#endif 	/* __IPropertyStoreCapabilities_FWD_DEFINED__ */


#ifndef __IPropertyStoreCache_FWD_DEFINED__
#define __IPropertyStoreCache_FWD_DEFINED__
typedef interface IPropertyStoreCache IPropertyStoreCache;
#endif 	/* __IPropertyStoreCache_FWD_DEFINED__ */


#ifndef __IPropertyEnumType_FWD_DEFINED__
#define __IPropertyEnumType_FWD_DEFINED__
typedef interface IPropertyEnumType IPropertyEnumType;
#endif 	/* __IPropertyEnumType_FWD_DEFINED__ */


#ifndef __IPropertyEnumType2_FWD_DEFINED__
#define __IPropertyEnumType2_FWD_DEFINED__
typedef interface IPropertyEnumType2 IPropertyEnumType2;
#endif 	/* __IPropertyEnumType2_FWD_DEFINED__ */


#ifndef __IPropertyEnumTypeList_FWD_DEFINED__
#define __IPropertyEnumTypeList_FWD_DEFINED__
typedef interface IPropertyEnumTypeList IPropertyEnumTypeList;
#endif 	/* __IPropertyEnumTypeList_FWD_DEFINED__ */


#ifndef __IPropertyDescription_FWD_DEFINED__
#define __IPropertyDescription_FWD_DEFINED__
typedef interface IPropertyDescription IPropertyDescription;
#endif 	/* __IPropertyDescription_FWD_DEFINED__ */


#ifndef __IPropertyDescription2_FWD_DEFINED__
#define __IPropertyDescription2_FWD_DEFINED__
typedef interface IPropertyDescription2 IPropertyDescription2;
#endif 	/* __IPropertyDescription2_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_FWD_DEFINED__
#define __IPropertyDescriptionAliasInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionAliasInfo IPropertyDescriptionAliasInfo;
#endif 	/* __IPropertyDescriptionAliasInfo_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_FWD_DEFINED__
#define __IPropertyDescriptionSearchInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionSearchInfo IPropertyDescriptionSearchInfo;
#endif 	/* __IPropertyDescriptionSearchInfo_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionRelatedPropertyInfo_FWD_DEFINED__
#define __IPropertyDescriptionRelatedPropertyInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionRelatedPropertyInfo IPropertyDescriptionRelatedPropertyInfo;
#endif 	/* __IPropertyDescriptionRelatedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPropertySystem_FWD_DEFINED__
#define __IPropertySystem_FWD_DEFINED__
typedef interface IPropertySystem IPropertySystem;
#endif 	/* __IPropertySystem_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionList_FWD_DEFINED__
#define __IPropertyDescriptionList_FWD_DEFINED__
typedef interface IPropertyDescriptionList IPropertyDescriptionList;
#endif 	/* __IPropertyDescriptionList_FWD_DEFINED__ */


#ifndef __IPropertyStoreFactory_FWD_DEFINED__
#define __IPropertyStoreFactory_FWD_DEFINED__
typedef interface IPropertyStoreFactory IPropertyStoreFactory;
#endif 	/* __IPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_FWD_DEFINED__
#define __IDelayedPropertyStoreFactory_FWD_DEFINED__
typedef interface IDelayedPropertyStoreFactory IDelayedPropertyStoreFactory;
#endif 	/* __IDelayedPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IPersistSerializedPropStorage_FWD_DEFINED__
#define __IPersistSerializedPropStorage_FWD_DEFINED__
typedef interface IPersistSerializedPropStorage IPersistSerializedPropStorage;
#endif 	/* __IPersistSerializedPropStorage_FWD_DEFINED__ */


#ifndef __IPersistSerializedPropStorage2_FWD_DEFINED__
#define __IPersistSerializedPropStorage2_FWD_DEFINED__
typedef interface IPersistSerializedPropStorage2 IPersistSerializedPropStorage2;
#endif 	/* __IPersistSerializedPropStorage2_FWD_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_FWD_DEFINED__
#define __IPropertySystemChangeNotify_FWD_DEFINED__
typedef interface IPropertySystemChangeNotify IPropertySystemChangeNotify;
#endif 	/* __IPropertySystemChangeNotify_FWD_DEFINED__ */


#ifndef __ICreateObject_FWD_DEFINED__
#define __ICreateObject_FWD_DEFINED__
typedef interface ICreateObject ICreateObject;
#endif 	/* __ICreateObject_FWD_DEFINED__ */


#ifndef __InMemoryPropertyStore_FWD_DEFINED__
#define __InMemoryPropertyStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class InMemoryPropertyStore InMemoryPropertyStore;
#else
typedef struct InMemoryPropertyStore InMemoryPropertyStore;
#endif /* __cplusplus */

#endif 	/* __InMemoryPropertyStore_FWD_DEFINED__ */


#ifndef __PropertySystem_FWD_DEFINED__
#define __PropertySystem_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertySystem PropertySystem;
#else
typedef struct PropertySystem PropertySystem;
#endif /* __cplusplus */

#endif 	/* __PropertySystem_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "shtypes.h"
#include "StructuredQueryCondition.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_propsys_0000_0000 */
/* [local] */ 

#ifndef PSSTDAPI
#if defined(_PROPSYS_)
#define PSSTDAPI          STDAPI
#define PSSTDAPI_(type)   STDAPI_(type)
#else
#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // PSSTDAPI
#if 0
typedef PROPERTYKEY *REFPROPERTYKEY;

#endif // 0
#include <propkeydef.h>


extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_s_ifspec;

#ifndef __IInitializeWithFile_INTERFACE_DEFINED__
#define __IInitializeWithFile_INTERFACE_DEFINED__

/* interface IInitializeWithFile */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7d14566-0509-4cce-a71f-0a554233bd9b")
    IInitializeWithFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeWithFile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeWithFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeWithFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IInitializeWithFile * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithFileVtbl;

    interface IInitializeWithFile
    {
        CONST_VTBL struct IInitializeWithFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithFile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithFile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithFile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithFile_Initialize(This,pszFilePath,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pszFilePath,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithFile_INTERFACE_DEFINED__ */


#ifndef __IInitializeWithStream_INTERFACE_DEFINED__
#define __IInitializeWithStream_INTERFACE_DEFINED__

/* interface IInitializeWithStream */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b824b49d-22ac-4161-ac8a-9916e8fa3f7f")
    IInitializeWithStream : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [annotation][in] */ 
            __in  IStream *pstream,
            /* [annotation][in] */ 
            __in  DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInitializeWithStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInitializeWithStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInitializeWithStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithStream * This,
            /* [annotation][in] */ 
            __in  IStream *pstream,
            /* [annotation][in] */ 
            __in  DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithStreamVtbl;

    interface IInitializeWithStream
    {
        CONST_VTBL struct IInitializeWithStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithStream_Initialize(This,pstream,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pstream,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_RemoteInitialize_Proxy( 
    __RPC__in IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IInitializeWithStream_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitializeWithStream_INTERFACE_DEFINED__ */


#ifndef __IPropertyStore_INTERFACE_DEFINED__
#define __IPropertyStore_INTERFACE_DEFINED__

/* interface IPropertyStore */
/* [unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")
    IPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out DWORD *cProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPropertyStore * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IPropertyStore * This);
        
        END_INTERFACE
    } IPropertyStoreVtbl;

    interface IPropertyStore
    {
        CONST_VTBL struct IPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStore_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStore_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStore_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStore_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStore_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0003 */
/* [local] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertyStore *LPPROPERTYSTORE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_s_ifspec;

#ifndef __INamedPropertyStore_INTERFACE_DEFINED__
#define __INamedPropertyStore_INTERFACE_DEFINED__

/* interface INamedPropertyStore */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_INamedPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71604b0f-97b0-4764-8577-2f13e98a1422")
    INamedPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNamedValue( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedValue( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INamedPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INamedPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INamedPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedValue )( 
            __RPC__in INamedPropertyStore * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamedValue )( 
            __RPC__in INamedPropertyStore * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
            __RPC__in INamedPropertyStore * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameAt )( 
            __RPC__in INamedPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        END_INTERFACE
    } INamedPropertyStoreVtbl;

    interface INamedPropertyStore
    {
        CONST_VTBL struct INamedPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedPropertyStore_GetNamedValue(This,pszName,ppropvar)	\
    ( (This)->lpVtbl -> GetNamedValue(This,pszName,ppropvar) ) 

#define INamedPropertyStore_SetNamedValue(This,pszName,propvar)	\
    ( (This)->lpVtbl -> SetNamedValue(This,pszName,propvar) ) 

#define INamedPropertyStore_GetNameCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetNameCount(This,pdwCount) ) 

#define INamedPropertyStore_GetNameAt(This,iProp,pbstrName)	\
    ( (This)->lpVtbl -> GetNameAt(This,iProp,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0004 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum GETPROPERTYSTOREFLAGS
    {	GPS_DEFAULT	= 0,
	GPS_HANDLERPROPERTIESONLY	= 0x1,
	GPS_READWRITE	= 0x2,
	GPS_TEMPORARY	= 0x4,
	GPS_FASTPROPERTIESONLY	= 0x8,
	GPS_OPENSLOWITEM	= 0x10,
	GPS_DELAYCREATION	= 0x20,
	GPS_BESTEFFORT	= 0x40,
	GPS_NO_OPLOCK	= 0x80,
	GPS_MASK_VALID	= 0xff
    } 	GETPROPERTYSTOREFLAGS;

DEFINE_ENUM_FLAG_OPERATORS(GETPROPERTYSTOREFLAGS)


extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_s_ifspec;

#ifndef __IObjectWithPropertyKey_INTERFACE_DEFINED__
#define __IObjectWithPropertyKey_INTERFACE_DEFINED__

/* interface IObjectWithPropertyKey */
/* [uuid][object] */ 


EXTERN_C const IID IID_IObjectWithPropertyKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc0ca0a7-c316-4fd2-9031-3e628e6d4f23")
    IObjectWithPropertyKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyKey( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithPropertyKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectWithPropertyKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectWithPropertyKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            __RPC__in IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IObjectWithPropertyKey * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        END_INTERFACE
    } IObjectWithPropertyKeyVtbl;

    interface IObjectWithPropertyKey
    {
        CONST_VTBL struct IObjectWithPropertyKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithPropertyKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithPropertyKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithPropertyKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithPropertyKey_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IObjectWithPropertyKey_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithPropertyKey_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0005 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum PKA_FLAGS
    {	PKA_SET	= 0,
	PKA_APPEND	= ( PKA_SET + 1 ) ,
	PKA_DELETE	= ( PKA_APPEND + 1 ) 
    } 	PKA_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_s_ifspec;

#ifndef __IPropertyChange_INTERFACE_DEFINED__
#define __IPropertyChange_INTERFACE_DEFINED__

/* interface IPropertyChange */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f917bc8a-1bba-4478-a245-1bde03eb9431")
    IPropertyChange : public IObjectWithPropertyKey
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ApplyToPropVariant( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyChange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            __RPC__in IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyChange * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyToPropVariant )( 
            __RPC__in IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut);
        
        END_INTERFACE
    } IPropertyChangeVtbl;

    interface IPropertyChange
    {
        CONST_VTBL struct IPropertyChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChange_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IPropertyChange_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 


#define IPropertyChange_ApplyToPropVariant(This,propvarIn,ppropvarOut)	\
    ( (This)->lpVtbl -> ApplyToPropVariant(This,propvarIn,ppropvarOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChange_INTERFACE_DEFINED__ */


#ifndef __IPropertyChangeArray_INTERFACE_DEFINED__
#define __IPropertyChangeArray_INTERFACE_DEFINED__

/* interface IPropertyChangeArray */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChangeArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("380f5cad-1b5e-42f2-805d-637fd392d31e")
    IPropertyChangeArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcOperations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendOrReplace( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT iIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeyInArray( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyChangeArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyChangeArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPropertyChangeArray * This,
            /* [out] */ __RPC__out UINT *pcOperations);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *AppendOrReplace )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ UINT iIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeyInArray )( 
            __RPC__in IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyChangeArrayVtbl;

    interface IPropertyChangeArray
    {
        CONST_VTBL struct IPropertyChangeArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChangeArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChangeArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChangeArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChangeArray_GetCount(This,pcOperations)	\
    ( (This)->lpVtbl -> GetCount(This,pcOperations) ) 

#define IPropertyChangeArray_GetAt(This,iIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iIndex,riid,ppv) ) 

#define IPropertyChangeArray_InsertAt(This,iIndex,ppropChange)	\
    ( (This)->lpVtbl -> InsertAt(This,iIndex,ppropChange) ) 

#define IPropertyChangeArray_Append(This,ppropChange)	\
    ( (This)->lpVtbl -> Append(This,ppropChange) ) 

#define IPropertyChangeArray_AppendOrReplace(This,ppropChange)	\
    ( (This)->lpVtbl -> AppendOrReplace(This,ppropChange) ) 

#define IPropertyChangeArray_RemoveAt(This,iIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,iIndex) ) 

#define IPropertyChangeArray_IsKeyInArray(This,key)	\
    ( (This)->lpVtbl -> IsKeyInArray(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChangeArray_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_INTERFACE_DEFINED__
#define __IPropertyStoreCapabilities_INTERFACE_DEFINED__

/* interface IPropertyStoreCapabilities */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8e2d566-186e-4d49-bf41-6909ead56acc")
    IPropertyStoreCapabilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsPropertyWritable( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyStoreCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyStoreCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPropertyWritable )( 
            __RPC__in IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyStoreCapabilitiesVtbl;

    interface IPropertyStoreCapabilities
    {
        CONST_VTBL struct IPropertyStoreCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCapabilities_IsPropertyWritable(This,key)	\
    ( (This)->lpVtbl -> IsPropertyWritable(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCapabilities_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCache_INTERFACE_DEFINED__
#define __IPropertyStoreCache_INTERFACE_DEFINED__

/* interface IPropertyStoreCache */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum PSC_STATE
    {	PSC_NORMAL	= 0,
	PSC_NOTINSOURCE	= 1,
	PSC_DIRTY	= 2,
	PSC_READONLY	= 3
    } 	PSC_STATE;


EXTERN_C const IID IID_IPropertyStoreCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3017056d-9a91-4e90-937d-746c72abbf4f")
    IPropertyStoreCache : public IPropertyStore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyStoreCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPropertyStoreCache * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueAndState )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAndState )( 
            __RPC__in IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state);
        
        END_INTERFACE
    } IPropertyStoreCacheVtbl;

    interface IPropertyStoreCache
    {
        CONST_VTBL struct IPropertyStoreCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCache_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStoreCache_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStoreCache_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStoreCache_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStoreCache_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IPropertyStoreCache_GetState(This,key,pstate)	\
    ( (This)->lpVtbl -> GetState(This,key,pstate) ) 

#define IPropertyStoreCache_GetValueAndState(This,key,ppropvar,pstate)	\
    ( (This)->lpVtbl -> GetValueAndState(This,key,ppropvar,pstate) ) 

#define IPropertyStoreCache_SetState(This,key,state)	\
    ( (This)->lpVtbl -> SetState(This,key,state) ) 

#define IPropertyStoreCache_SetValueAndState(This,key,ppropvar,state)	\
    ( (This)->lpVtbl -> SetValueAndState(This,key,ppropvar,state) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCache_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumType_INTERFACE_DEFINED__
#define __IPropertyEnumType_INTERFACE_DEFINED__

/* interface IPropertyEnumType */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum PROPENUMTYPE
    {	PET_DISCRETEVALUE	= 0,
	PET_RANGEDVALUE	= 1,
	PET_DEFAULTVALUE	= 2,
	PET_ENDRANGE	= 3
    } 	PROPENUMTYPE;


EXTERN_C const IID IID_IPropertyEnumType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11e1fbf9-2d56-4a6b-8db3-7cd193a471f2")
    IPropertyEnumType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnumType( 
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeMinValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeSetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayText( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyEnumType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyEnumType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyEnumType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
            __RPC__in IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
            __RPC__in IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
            __RPC__in IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
            __RPC__in IPropertyEnumType * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
        
        END_INTERFACE
    } IPropertyEnumTypeVtbl;

    interface IPropertyEnumType
    {
        CONST_VTBL struct IPropertyEnumTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumType_GetEnumType(This,penumtype)	\
    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 

#define IPropertyEnumType_GetValue(This,ppropvar)	\
    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 

#define IPropertyEnumType_GetRangeMinValue(This,ppropvarMin)	\
    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 

#define IPropertyEnumType_GetRangeSetValue(This,ppropvarSet)	\
    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 

#define IPropertyEnumType_GetDisplayText(This,ppszDisplay)	\
    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumType_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumType2_INTERFACE_DEFINED__
#define __IPropertyEnumType2_INTERFACE_DEFINED__

/* interface IPropertyEnumType2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyEnumType2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b6e051c-5ddd-4321-9070-fe2acb55e794")
    IPropertyEnumType2 : public IPropertyEnumType
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImageReference( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszImageRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumType2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyEnumType2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyEnumType2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageReference )( 
            __RPC__in IPropertyEnumType2 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszImageRes);
        
        END_INTERFACE
    } IPropertyEnumType2Vtbl;

    interface IPropertyEnumType2
    {
        CONST_VTBL struct IPropertyEnumType2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumType2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumType2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumType2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumType2_GetEnumType(This,penumtype)	\
    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 

#define IPropertyEnumType2_GetValue(This,ppropvar)	\
    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 

#define IPropertyEnumType2_GetRangeMinValue(This,ppropvarMin)	\
    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 

#define IPropertyEnumType2_GetRangeSetValue(This,ppropvarSet)	\
    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 

#define IPropertyEnumType2_GetDisplayText(This,ppszDisplay)	\
    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 


#define IPropertyEnumType2_GetImageReference(This,ppszImageRes)	\
    ( (This)->lpVtbl -> GetImageReference(This,ppszImageRes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumType2_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumTypeList_INTERFACE_DEFINED__
#define __IPropertyEnumTypeList_INTERFACE_DEFINED__

/* interface IPropertyEnumTypeList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyEnumTypeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a99400f4-3d84-4557-94ba-1242fb2cc9a6")
    IPropertyEnumTypeList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pctypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionAt( 
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindMatchingIndex( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyEnumTypeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyEnumTypeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPropertyEnumTypeList * This,
            /* [out] */ __RPC__out UINT *pctypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPropertyEnumTypeList * This,
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionAt )( 
            __RPC__in IPropertyEnumTypeList * This,
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FindMatchingIndex )( 
            __RPC__in IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex);
        
        END_INTERFACE
    } IPropertyEnumTypeListVtbl;

    interface IPropertyEnumTypeList
    {
        CONST_VTBL struct IPropertyEnumTypeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumTypeList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumTypeList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumTypeList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumTypeList_GetCount(This,pctypes)	\
    ( (This)->lpVtbl -> GetCount(This,pctypes) ) 

#define IPropertyEnumTypeList_GetAt(This,itype,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,itype,riid,ppv) ) 

#define IPropertyEnumTypeList_GetConditionAt(This,nIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetConditionAt(This,nIndex,riid,ppv) ) 

#define IPropertyEnumTypeList_FindMatchingIndex(This,propvarCmp,pnIndex)	\
    ( (This)->lpVtbl -> FindMatchingIndex(This,propvarCmp,pnIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumTypeList_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescription_INTERFACE_DEFINED__
#define __IPropertyDescription_INTERFACE_DEFINED__

/* interface IPropertyDescription */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum PROPDESC_TYPE_FLAGS
    {	PDTF_DEFAULT	= 0,
	PDTF_MULTIPLEVALUES	= 0x1,
	PDTF_ISINNATE	= 0x2,
	PDTF_ISGROUP	= 0x4,
	PDTF_CANGROUPBY	= 0x8,
	PDTF_CANSTACKBY	= 0x10,
	PDTF_ISTREEPROPERTY	= 0x20,
	PDTF_INCLUDEINFULLTEXTQUERY	= 0x40,
	PDTF_ISVIEWABLE	= 0x80,
	PDTF_ISQUERYABLE	= 0x100,
	PDTF_CANBEPURGED	= 0x200,
	PDTF_SEARCHRAWVALUE	= 0x400,
	PDTF_ISSYSTEMPROPERTY	= 0x80000000,
	PDTF_MASK_ALL	= 0x800007ff
    } 	PROPDESC_TYPE_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(PROPDESC_TYPE_FLAGS)
typedef /* [v1_enum] */ 
enum PROPDESC_VIEW_FLAGS
    {	PDVF_DEFAULT	= 0,
	PDVF_CENTERALIGN	= 0x1,
	PDVF_RIGHTALIGN	= 0x2,
	PDVF_BEGINNEWGROUP	= 0x4,
	PDVF_FILLAREA	= 0x8,
	PDVF_SORTDESCENDING	= 0x10,
	PDVF_SHOWONLYIFPRESENT	= 0x20,
	PDVF_SHOWBYDEFAULT	= 0x40,
	PDVF_SHOWINPRIMARYLIST	= 0x80,
	PDVF_SHOWINSECONDARYLIST	= 0x100,
	PDVF_HIDELABEL	= 0x200,
	PDVF_HIDDEN	= 0x800,
	PDVF_CANWRAP	= 0x1000,
	PDVF_MASK_ALL	= 0x1bff
    } 	PROPDESC_VIEW_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(PROPDESC_VIEW_FLAGS)
typedef /* [v1_enum] */ 
enum PROPDESC_DISPLAYTYPE
    {	PDDT_STRING	= 0,
	PDDT_NUMBER	= 1,
	PDDT_BOOLEAN	= 2,
	PDDT_DATETIME	= 3,
	PDDT_ENUMERATED	= 4
    } 	PROPDESC_DISPLAYTYPE;

typedef /* [v1_enum] */ 
enum PROPDESC_GROUPING_RANGE
    {	PDGR_DISCRETE	= 0,
	PDGR_ALPHANUMERIC	= 1,
	PDGR_SIZE	= 2,
	PDGR_DYNAMIC	= 3,
	PDGR_DATE	= 4,
	PDGR_PERCENT	= 5,
	PDGR_ENUMERATED	= 6
    } 	PROPDESC_GROUPING_RANGE;

typedef /* [v1_enum] */ 
enum PROPDESC_FORMAT_FLAGS
    {	PDFF_DEFAULT	= 0,
	PDFF_PREFIXNAME	= 0x1,
	PDFF_FILENAME	= 0x2,
	PDFF_ALWAYSKB	= 0x4,
	PDFF_RESERVED_RIGHTTOLEFT	= 0x8,
	PDFF_SHORTTIME	= 0x10,
	PDFF_LONGTIME	= 0x20,
	PDFF_HIDETIME	= 0x40,
	PDFF_SHORTDATE	= 0x80,
	PDFF_LONGDATE	= 0x100,
	PDFF_HIDEDATE	= 0x200,
	PDFF_RELATIVEDATE	= 0x400,
	PDFF_USEEDITINVITATION	= 0x800,
	PDFF_READONLY	= 0x1000,
	PDFF_NOAUTOREADINGORDER	= 0x2000
    } 	PROPDESC_FORMAT_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(PROPDESC_FORMAT_FLAGS)
typedef /* [v1_enum] */ 
enum PROPDESC_SORTDESCRIPTION
    {	PDSD_GENERAL	= 0,
	PDSD_A_Z	= 1,
	PDSD_LOWEST_HIGHEST	= 2,
	PDSD_SMALLEST_BIGGEST	= 3,
	PDSD_OLDEST_NEWEST	= 4
    } 	PROPDESC_SORTDESCRIPTION;

typedef /* [v1_enum] */ 
enum PROPDESC_RELATIVEDESCRIPTION_TYPE
    {	PDRDT_GENERAL	= 0,
	PDRDT_DATE	= 1,
	PDRDT_SIZE	= 2,
	PDRDT_COUNT	= 3,
	PDRDT_REVISION	= 4,
	PDRDT_LENGTH	= 5,
	PDRDT_DURATION	= 6,
	PDRDT_SPEED	= 7,
	PDRDT_RATE	= 8,
	PDRDT_RATING	= 9,
	PDRDT_PRIORITY	= 10
    } 	PROPDESC_RELATIVEDESCRIPTION_TYPE;

typedef /* [v1_enum] */ 
enum PROPDESC_AGGREGATION_TYPE
    {	PDAT_DEFAULT	= 0,
	PDAT_FIRST	= 1,
	PDAT_SUM	= 2,
	PDAT_AVERAGE	= 3,
	PDAT_DATERANGE	= 4,
	PDAT_UNION	= 5,
	PDAT_MAX	= 6,
	PDAT_MIN	= 7
    } 	PROPDESC_AGGREGATION_TYPE;

typedef /* [v1_enum] */ 
enum PROPDESC_CONDITION_TYPE
    {	PDCOT_NONE	= 0,
	PDCOT_STRING	= 1,
	PDCOT_SIZE	= 2,
	PDCOT_DATETIME	= 3,
	PDCOT_BOOLEAN	= 4,
	PDCOT_NUMBER	= 5
    } 	PROPDESC_CONDITION_TYPE;


EXTERN_C const IID IID_IPropertyDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f79d558-3e96-4549-a1d1-7d75d2288814")
    IPropertyDescription : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
            /* [out] */ __RPC__out VARTYPE *pvartype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditInvitation( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnWidth( 
            /* [out] */ __RPC__out UINT *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayType( 
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnState( 
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupingRange( 
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescriptionType( 
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescription( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescription( 
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescriptionLabel( 
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAggregationType( 
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumTypeList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CoerceToCanonicalValue( 
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueCanonical( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescription * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            __RPC__in IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            __RPC__in IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescription * This,
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            __RPC__in IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        END_INTERFACE
    } IPropertyDescriptionVtbl;

    interface IPropertyDescription
    {
        CONST_VTBL struct IPropertyDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescription_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescription_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescription_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescription_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescription_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescription_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescription_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescription_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescription_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescription_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescription_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescription_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescription_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescription_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescription_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescription_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescription_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescription_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescription_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescription_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescription_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_RemoteCoerceToCanonicalValue_Proxy( 
    __RPC__in IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);


void __RPC_STUB IPropertyDescription_RemoteCoerceToCanonicalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyDescription_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescription2_INTERFACE_DEFINED__
#define __IPropertyDescription2_INTERFACE_DEFINED__

/* interface IPropertyDescription2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescription2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57d2eded-5062-400e-b107-5dae79fe57a6")
    IPropertyDescription2 : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImageReferenceForValue( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszImageRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescription2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescription2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescription2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IPropertyDescription2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyDescription2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            __RPC__in IPropertyDescription2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            __RPC__in IPropertyDescription2 * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescription2 * This,
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageReferenceForValue )( 
            __RPC__in IPropertyDescription2 * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszImageRes);
        
        END_INTERFACE
    } IPropertyDescription2Vtbl;

    interface IPropertyDescription2
    {
        CONST_VTBL struct IPropertyDescription2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescription2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescription2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescription2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescription2_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescription2_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescription2_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescription2_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescription2_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescription2_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescription2_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescription2_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescription2_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescription2_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescription2_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescription2_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescription2_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescription2_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescription2_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescription2_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescription2_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescription2_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescription2_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescription2_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescription2_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescription2_GetImageReferenceForValue(This,propvar,ppszImageRes)	\
    ( (This)->lpVtbl -> GetImageReferenceForValue(This,propvar,ppszImageRes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescription2_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionAliasInfo */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionAliasInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f67104fc-2af9-46fd-b32d-243c1404f3d1")
    IPropertyDescriptionAliasInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSortByAlias( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalSortByAliases( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionAliasInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescriptionAliasInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescriptionAliasInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionAliasInfo * This,
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortByAlias )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdditionalSortByAliases )( 
            __RPC__in IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionAliasInfoVtbl;

    interface IPropertyDescriptionAliasInfo
    {
        CONST_VTBL struct IPropertyDescriptionAliasInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionAliasInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionAliasInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionAliasInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionAliasInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionAliasInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionAliasInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionAliasInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionAliasInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionAliasInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionAliasInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionAliasInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionAliasInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionAliasInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionAliasInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionAliasInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionAliasInfo_GetSortByAlias(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSortByAlias(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_GetAdditionalSortByAliases(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetAdditionalSortByAliases(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionSearchInfo */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum PROPDESC_SEARCHINFO_FLAGS
    {	PDSIF_DEFAULT	= 0,
	PDSIF_ININVERTEDINDEX	= 0x1,
	PDSIF_ISCOLUMN	= 0x2,
	PDSIF_ISCOLUMNSPARSE	= 0x4,
	PDSIF_ALWAYSINCLUDE	= 0x8
    } 	PROPDESC_SEARCHINFO_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(PROPDESC_SEARCHINFO_FLAGS)
typedef /* [v1_enum] */ 
enum PROPDESC_COLUMNINDEX_TYPE
    {	PDCIT_NONE	= 0,
	PDCIT_ONDISK	= 1,
	PDCIT_INMEMORY	= 2,
	PDCIT_ONDEMAND	= 3,
	PDCIT_ONDISKALL	= 4,
	PDCIT_ONDISKVECTOR	= 5
    } 	PROPDESC_COLUMNINDEX_TYPE;


EXTERN_C const IID IID_IPropertyDescriptionSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("078f91bd-29a2-440f-924e-46a291524520")
    IPropertyDescriptionSearchInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSearchInfoFlags( 
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnIndexType( 
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProjectionString( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
            /* [out] */ __RPC__out UINT *pcbMaxSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescriptionSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescriptionSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionSearchInfo * This,
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSearchInfoFlags )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnIndexType )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType);
        
        HRESULT ( STDMETHODCALLTYPE *GetProjectionString )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
            __RPC__in IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcbMaxSize);
        
        END_INTERFACE
    } IPropertyDescriptionSearchInfoVtbl;

    interface IPropertyDescriptionSearchInfo
    {
        CONST_VTBL struct IPropertyDescriptionSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionSearchInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionSearchInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionSearchInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionSearchInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionSearchInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionSearchInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionSearchInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionSearchInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionSearchInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionSearchInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionSearchInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionSearchInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionSearchInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionSearchInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionSearchInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionSearchInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionSearchInfo_GetSearchInfoFlags(This,ppdsiFlags)	\
    ( (This)->lpVtbl -> GetSearchInfoFlags(This,ppdsiFlags) ) 

#define IPropertyDescriptionSearchInfo_GetColumnIndexType(This,ppdciType)	\
    ( (This)->lpVtbl -> GetColumnIndexType(This,ppdciType) ) 

#define IPropertyDescriptionSearchInfo_GetProjectionString(This,ppszProjection)	\
    ( (This)->lpVtbl -> GetProjectionString(This,ppszProjection) ) 

#define IPropertyDescriptionSearchInfo_GetMaxSize(This,pcbMaxSize)	\
    ( (This)->lpVtbl -> GetMaxSize(This,pcbMaxSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionRelatedPropertyInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionRelatedPropertyInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionRelatedPropertyInfo */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionRelatedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("507393f4-2a3d-4a60-b59e-d9c75716c2dd")
    IPropertyDescriptionRelatedPropertyInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRelatedProperty( 
            /* [in] */ __RPC__in LPCWSTR pszRelationshipName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionRelatedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionRelatedPropertyInfo * This,
            /* [annotation][out][in] */ 
            __inout  PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelatedProperty )( 
            __RPC__in IPropertyDescriptionRelatedPropertyInfo * This,
            /* [in] */ __RPC__in LPCWSTR pszRelationshipName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionRelatedPropertyInfoVtbl;

    interface IPropertyDescriptionRelatedPropertyInfo
    {
        CONST_VTBL struct IPropertyDescriptionRelatedPropertyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionRelatedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionRelatedPropertyInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionRelatedPropertyInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionRelatedPropertyInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionRelatedPropertyInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionRelatedPropertyInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionRelatedPropertyInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionRelatedPropertyInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionRelatedPropertyInfo_GetRelatedProperty(This,pszRelationshipName,riid,ppv)	\
    ( (This)->lpVtbl -> GetRelatedProperty(This,pszRelationshipName,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionRelatedPropertyInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0017 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum PROPDESC_ENUMFILTER
    {	PDEF_ALL	= 0,
	PDEF_SYSTEM	= 1,
	PDEF_NONSYSTEM	= 2,
	PDEF_VIEWABLE	= 3,
	PDEF_QUERYABLE	= 4,
	PDEF_INFULLTEXTQUERY	= 5,
	PDEF_COLUMN	= 6
    } 	PROPDESC_ENUMFILTER;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0017_v0_0_s_ifspec;

#ifndef __IPropertySystem_INTERFACE_DEFINED__
#define __IPropertySystem_INTERFACE_DEFINED__

/* interface IPropertySystem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca724e8a-c3e6-442b-88a4-6fb0db8035a3")
    IPropertySystem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionByName( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionListFromString( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratePropertyDescriptions( 
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [range][in] */ __RPC__in_range(0,0x8000) DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplayAlloc( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPropertySchema( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterPropertySchema( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshPropertySchema( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertySystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertySystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertySystem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            __RPC__in IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionByName )( 
            __RPC__in IPropertySystem * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionListFromString )( 
            __RPC__in IPropertySystem * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratePropertyDescriptions )( 
            __RPC__in IPropertySystem * This,
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            __RPC__in IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [range][in] */ __RPC__in_range(0,0x8000) DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplayAlloc )( 
            __RPC__in IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPropertySchema )( 
            __RPC__in IPropertySystem * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterPropertySchema )( 
            __RPC__in IPropertySystem * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshPropertySchema )( 
            __RPC__in IPropertySystem * This);
        
        END_INTERFACE
    } IPropertySystemVtbl;

    interface IPropertySystem
    {
        CONST_VTBL struct IPropertySystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystem_GetPropertyDescription(This,propkey,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescription(This,propkey,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv) ) 

#define IPropertySystem_EnumeratePropertyDescriptions(This,filterOn,riid,ppv)	\
    ( (This)->lpVtbl -> EnumeratePropertyDescriptions(This,filterOn,riid,ppv) ) 

#define IPropertySystem_FormatForDisplay(This,key,propvar,pdff,pszText,cchText)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,key,propvar,pdff,pszText,cchText) ) 

#define IPropertySystem_FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay) ) 

#define IPropertySystem_RegisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> RegisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_UnregisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> UnregisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_RefreshPropertySchema(This)	\
    ( (This)->lpVtbl -> RefreshPropertySchema(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystem_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionList_INTERFACE_DEFINED__
#define __IPropertyDescriptionList_INTERFACE_DEFINED__

/* interface IPropertyDescriptionList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f9fc1d0-c39b-4b26-817f-011967d3440e")
    IPropertyDescriptionList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcElem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyDescriptionList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyDescriptionList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyDescriptionList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IPropertyDescriptionList * This,
            /* [out] */ __RPC__out UINT *pcElem);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IPropertyDescriptionList * This,
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionListVtbl;

    interface IPropertyDescriptionList
    {
        CONST_VTBL struct IPropertyDescriptionListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionList_GetCount(This,pcElem)	\
    ( (This)->lpVtbl -> GetCount(This,pcElem) ) 

#define IPropertyDescriptionList_GetAt(This,iElem,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iElem,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionList_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreFactory_INTERFACE_DEFINED__
#define __IPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc110b6d-57e8-4148-a9c6-91015ab2f3a5")
    IPropertyStoreFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            __RPC__in IPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            __RPC__in IPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyStoreFactoryVtbl;

    interface IPropertyStoreFactory
    {
        CONST_VTBL struct IPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreFactory_INTERFACE_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
#define __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IDelayedPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDelayedPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40d4577f-e237-4bdb-bd69-58f089431b6a")
    IDelayedPropertyStoreFactory : public IPropertyStoreFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDelayedPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelayedPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDelayedPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDelayedPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDelayedPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            __RPC__in IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            __RPC__in IDelayedPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelayedPropertyStore )( 
            __RPC__in IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IDelayedPropertyStoreFactoryVtbl;

    interface IDelayedPropertyStoreFactory
    {
        CONST_VTBL struct IDelayedPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelayedPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelayedPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelayedPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelayedPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IDelayedPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 


#define IDelayedPropertyStoreFactory_GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv)	\
    ( (This)->lpVtbl -> GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0021 */
/* [local] */ 

/* [v1_enum] */ 
enum _PERSIST_SPROPSTORE_FLAGS
    {	FPSPS_DEFAULT	= 0,
	FPSPS_READONLY	= 0x1
    } ;
typedef int PERSIST_SPROPSTORE_FLAGS;

typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE;

typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;

typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_s_ifspec;

#ifndef __IPersistSerializedPropStorage_INTERFACE_DEFINED__
#define __IPersistSerializedPropStorage_INTERFACE_DEFINED__

/* interface IPersistSerializedPropStorage */
/* [object][local][unique][uuid] */ 


EXTERN_C const IID IID_IPersistSerializedPropStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e318ad57-0aa0-450f-aca5-6fab7103d917")
    IPersistSerializedPropStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyStorage( 
            /* [annotation][in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [annotation][in] */ 
            __in  DWORD cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorage( 
            /* [annotation][out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [annotation][out] */ 
            __out  DWORD *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistSerializedPropStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistSerializedPropStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistSerializedPropStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [annotation][in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [annotation][in] */ 
            __in  DWORD cb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [annotation][out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [annotation][out] */ 
            __out  DWORD *pcb);
        
        END_INTERFACE
    } IPersistSerializedPropStorageVtbl;

    interface IPersistSerializedPropStorage
    {
        CONST_VTBL struct IPersistSerializedPropStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistSerializedPropStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistSerializedPropStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistSerializedPropStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistSerializedPropStorage_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define IPersistSerializedPropStorage_SetPropertyStorage(This,psps,cb)	\
    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 

#define IPersistSerializedPropStorage_GetPropertyStorage(This,ppsps,pcb)	\
    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistSerializedPropStorage_INTERFACE_DEFINED__ */


#ifndef __IPersistSerializedPropStorage2_INTERFACE_DEFINED__
#define __IPersistSerializedPropStorage2_INTERFACE_DEFINED__

/* interface IPersistSerializedPropStorage2 */
/* [object][local][unique][uuid] */ 


EXTERN_C const IID IID_IPersistSerializedPropStorage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77effa68-4f98-4366-ba72-573b3d880571")
    IPersistSerializedPropStorage2 : public IPersistSerializedPropStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorageSize( 
            /* [annotation][out] */ 
            __out  DWORD *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorageBuffer( 
            /* [annotation][out] */ 
            __out_bcount_part(cb, *pcbWritten)  SERIALIZEDPROPSTORAGE *psps,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out  DWORD *pcbWritten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistSerializedPropStorage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistSerializedPropStorage2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistSerializedPropStorage2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistSerializedPropStorage2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IPersistSerializedPropStorage2 * This,
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
            IPersistSerializedPropStorage2 * This,
            /* [annotation][in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [annotation][in] */ 
            __in  DWORD cb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
            IPersistSerializedPropStorage2 * This,
            /* [annotation][out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [annotation][out] */ 
            __out  DWORD *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorageSize )( 
            IPersistSerializedPropStorage2 * This,
            /* [annotation][out] */ 
            __out  DWORD *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorageBuffer )( 
            IPersistSerializedPropStorage2 * This,
            /* [annotation][out] */ 
            __out_bcount_part(cb, *pcbWritten)  SERIALIZEDPROPSTORAGE *psps,
            /* [in] */ DWORD cb,
            /* [annotation][out] */ 
            __out  DWORD *pcbWritten);
        
        END_INTERFACE
    } IPersistSerializedPropStorage2Vtbl;

    interface IPersistSerializedPropStorage2
    {
        CONST_VTBL struct IPersistSerializedPropStorage2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistSerializedPropStorage2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistSerializedPropStorage2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistSerializedPropStorage2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistSerializedPropStorage2_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define IPersistSerializedPropStorage2_SetPropertyStorage(This,psps,cb)	\
    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 

#define IPersistSerializedPropStorage2_GetPropertyStorage(This,ppsps,pcb)	\
    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 


#define IPersistSerializedPropStorage2_GetPropertyStorageSize(This,pcb)	\
    ( (This)->lpVtbl -> GetPropertyStorageSize(This,pcb) ) 

#define IPersistSerializedPropStorage2_GetPropertyStorageBuffer(This,psps,cb,pcbWritten)	\
    ( (This)->lpVtbl -> GetPropertyStorageBuffer(This,psps,cb,pcbWritten) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistSerializedPropStorage2_INTERFACE_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_INTERFACE_DEFINED__
#define __IPropertySystemChangeNotify_INTERFACE_DEFINED__

/* interface IPropertySystemChangeNotify */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystemChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa955fd9-38be-4879-a6ce-824cf52d609f")
    IPropertySystemChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SchemaRefreshed( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPropertySystemChangeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPropertySystemChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPropertySystemChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *SchemaRefreshed )( 
            __RPC__in IPropertySystemChangeNotify * This);
        
        END_INTERFACE
    } IPropertySystemChangeNotifyVtbl;

    interface IPropertySystemChangeNotify
    {
        CONST_VTBL struct IPropertySystemChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystemChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystemChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystemChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystemChangeNotify_SchemaRefreshed(This)	\
    ( (This)->lpVtbl -> SchemaRefreshed(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystemChangeNotify_INTERFACE_DEFINED__ */


#ifndef __ICreateObject_INTERFACE_DEFINED__
#define __ICreateObject_INTERFACE_DEFINED__

/* interface ICreateObject */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ICreateObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75121952-e0d0-43e5-9380-1d80483acf72")
    ICreateObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICreateObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICreateObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICreateObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            __RPC__in ICreateObject * This,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ICreateObjectVtbl;

    interface ICreateObject
    {
        CONST_VTBL struct ICreateObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateObject_CreateObject(This,clsid,pUnkOuter,riid,ppv)	\
    ( (This)->lpVtbl -> CreateObject(This,clsid,pUnkOuter,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0025 */
/* [local] */ 

// Format a property value for display purposes
PSSTDAPI PSFormatForDisplay(
    __in REFPROPERTYKEY propkey,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdfFlags,
    __out_ecount(cchText) LPWSTR pwszText,
    __in DWORD cchText);

PSSTDAPI PSFormatForDisplayAlloc(
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out PWSTR *ppszDisplay);

PSSTDAPI PSFormatPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out LPWSTR *ppszDisplay);

// Retrieve the image reference associated with a property value (if specified)
PSSTDAPI PSGetImageReferenceForValue(
    __in REFPROPERTYKEY propkey,
    __in REFPROPVARIANT propvar,
    __deref_out PWSTR *ppszImageRes);


#define PKEY_PIDSTR_MAX     10   // will take care of any long integer value
#define GUIDSTRING_MAX      (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)  // "{12345678-1234-1234-1234-123456789012}"
#define PKEYSTR_MAX         (GUIDSTRING_MAX + 1 + PKEY_PIDSTR_MAX)

// Convert a PROPERTYKEY to and from a PWSTR
PSSTDAPI PSStringFromPropertyKey(
    __in REFPROPERTYKEY pkey,
    __out_ecount(cch) LPWSTR psz,
    __in UINT cch);

PSSTDAPI PSPropertyKeyFromString(
    __in LPCWSTR pszString,
    __out PROPERTYKEY *pkey);


// Creates an in-memory property store
// Returns an IPropertyStore, IPersistSerializedPropStorage, and related interfaces interface
PSSTDAPI PSCreateMemoryPropertyStore(
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only, delay-bind multiplexing property store
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateDelayedMultiplexPropertyStore(
    __in GETPROPERTYSTOREFLAGS flags,
    __in IDelayedPropertyStoreFactory *pdpsf,
    __in_ecount(cStores) const DWORD *rgStoreIds,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only property store from one or more sources (which each must support either IPropertyStore or IPropertySetStorage)
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateMultiplexPropertyStore(
    __in_ecount(cStores) IUnknown **prgpunkStores,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a container for IPropertyChanges
// Returns an IPropertyChangeArray interface
PSSTDAPI PSCreatePropertyChangeArray(
    __in_ecount_opt(cChanges) const PROPERTYKEY *rgpropkey,
    __in_ecount_opt(cChanges) const PKA_FLAGS *rgflags,
    __in_ecount_opt(cChanges) const PROPVARIANT *rgpropvar,
    __in UINT cChanges,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a simple property change
// Returns an IPropertyChange interface
PSSTDAPI PSCreateSimplePropertyChange(
    __in PKA_FLAGS flags,
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property description
// Returns an IPropertyDescription interface
PSSTDAPI PSGetPropertyDescription(
    __in REFPROPERTYKEY propkey,
    __in REFIID riid,
    __deref_out void **ppv);

PSSTDAPI PSGetPropertyDescriptionByName(
    __in LPCWSTR pszCanonicalName,
    __in REFIID riid,
    __deref_out void **ppv);


// Lookup a per-machine registered file property handler
PSSTDAPI PSLookupPropertyHandlerCLSID(
    __in PCWSTR pszFilePath,
    __out CLSID *pclsid);
// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandler(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// punkCreateObject supports ICreateObject
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandlerWithCreateObject(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in IUnknown *punkCreateObject,
    __in REFIID riid,
    __deref_out void **ppv);


// Get or set a property value from a store
PSSTDAPI PSGetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __out PROPVARIANT *ppropvar);

PSSTDAPI PSSetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in REFPROPVARIANT propvar);


// Interact with the set of property descriptions
PSSTDAPI PSRegisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSUnregisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSRefreshPropertySchema(void);

// Returns either: IPropertyDescriptionList or IEnumUnknown interfaces
PSSTDAPI PSEnumeratePropertyDescriptions(
    __in PROPDESC_ENUMFILTER filterOn,
    __in REFIID riid,
    __deref_out void **ppv);


// Convert between a PROPERTYKEY and its canonical name
PSSTDAPI PSGetPropertyKeyFromName(
    __in PCWSTR pszName,
    __out PROPERTYKEY *ppropkey);

PSSTDAPI PSGetNameFromPropertyKey(
    __in REFPROPERTYKEY propkey,
    __deref_out PWSTR *ppszCanonicalName);


// Coerce and canonicalize a property value
PSSTDAPI PSCoerceToCanonicalValue(
    __in REFPROPERTYKEY key,
    __inout PROPVARIANT *ppropvar);


// Convert a 'prop:' string into a list of property descriptions
// Returns an IPropertyDescriptionList interface
PSSTDAPI PSGetPropertyDescriptionListFromString(
    __in LPCWSTR pszPropList,
    __in REFIID riid,
    __deref_out void **ppv);


// Wrap an IPropertySetStorage interface in an IPropertyStore interface
// Returns an IPropertyStore or related interface
PSSTDAPI PSCreatePropertyStoreFromPropertySetStorage(
    __in IPropertySetStorage *ppss,
    __in DWORD grfMode,
    __in REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore or IPropertySetStorage
// On success, the returned ppv is guaranteed to support IPropertyStore.
// If punkSource already supports IPropertyStore, no wrapper is created.
PSSTDAPI PSCreatePropertyStoreFromObject(
    __in IUnknown *punk,
    __in DWORD grfMode,
    __in REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore
// riid may be IPropertyStore, IPropertySetStorage, IPropertyStoreCapabilities, or IObjectProvider
PSSTDAPI PSCreateAdapterFromPropertyStore(
    __in IPropertyStore *pps,
    __in REFIID riid,
    __deref_out void **ppv);


// Talk to the property system using an interface
// Returns an IPropertySystem interface
PSSTDAPI PSGetPropertySystem(
    __in REFIID riid,
    __deref_out void **ppv);


// Obtain a value from serialized property storage
PSSTDAPI PSGetPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in REFPROPERTYKEY rpkey, 
    __out PROPVARIANT *ppropvar);


// Obtain a named value from serialized property storage
PSSTDAPI PSGetNamedPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in LPCWSTR pszName, 
    __out PROPVARIANT *ppropvar);


// Helper functions for reading and writing values from IPropertyBag's.
PSSTDAPI PSPropertyBag_ReadType(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out VARIANT *var,
    VARTYPE type);
PSSTDAPI PSPropertyBag_ReadStr(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out_ecount(characterCount) LPWSTR value,
    int characterCount);
PSSTDAPI PSPropertyBag_ReadStrAlloc(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __deref_out PWSTR *value);
PSSTDAPI PSPropertyBag_ReadBSTR(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __deref_out BSTR *value);
PSSTDAPI PSPropertyBag_WriteStr(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in LPCWSTR value);
PSSTDAPI PSPropertyBag_WriteBSTR(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in BSTR value);
PSSTDAPI PSPropertyBag_ReadInt(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out INT *value);
PSSTDAPI PSPropertyBag_WriteInt(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    INT value);
PSSTDAPI PSPropertyBag_ReadSHORT(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out SHORT *value);
PSSTDAPI PSPropertyBag_WriteSHORT(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    SHORT value);
PSSTDAPI PSPropertyBag_ReadLONG(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out LONG *value);
PSSTDAPI PSPropertyBag_WriteLONG(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    LONG value);
PSSTDAPI PSPropertyBag_ReadDWORD(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out DWORD *value);
PSSTDAPI PSPropertyBag_WriteDWORD(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    DWORD value);
PSSTDAPI PSPropertyBag_ReadBOOL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out BOOL *value);
PSSTDAPI PSPropertyBag_WriteBOOL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    BOOL value);
PSSTDAPI PSPropertyBag_ReadPOINTL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out POINTL *value);
PSSTDAPI PSPropertyBag_WritePOINTL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in const POINTL *value);
PSSTDAPI PSPropertyBag_ReadPOINTS(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out POINTS *value);
PSSTDAPI PSPropertyBag_WritePOINTS(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in const POINTS *value);
PSSTDAPI PSPropertyBag_ReadRECTL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out RECTL *value);
PSSTDAPI PSPropertyBag_WriteRECTL(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in const RECTL *value);
PSSTDAPI PSPropertyBag_ReadStream(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __deref_out IStream **value);
PSSTDAPI PSPropertyBag_WriteStream(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in IStream *value);
PSSTDAPI PSPropertyBag_Delete(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName);
PSSTDAPI PSPropertyBag_ReadULONGLONG(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out ULONGLONG *value);
PSSTDAPI PSPropertyBag_WriteULONGLONG(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    ULONGLONG value);
PSSTDAPI PSPropertyBag_ReadUnknown(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in REFIID riid,
    __deref_out void **ppv);
PSSTDAPI PSPropertyBag_WriteUnknown(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in IUnknown *punk);
PSSTDAPI PSPropertyBag_ReadGUID(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out GUID *value);
PSSTDAPI PSPropertyBag_WriteGUID(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in const GUID *value);
PSSTDAPI PSPropertyBag_ReadPropertyKey(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __out PROPERTYKEY *value);
PSSTDAPI PSPropertyBag_WritePropertyKey(
    __in IPropertyBag *propBag,
    __in LPCWSTR propName,
    __in REFPROPERTYKEY value);


extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0025_v0_0_s_ifspec;


#ifndef __PropSysObjects_LIBRARY_DEFINED__
#define __PropSysObjects_LIBRARY_DEFINED__

/* library PropSysObjects */
/* [version][lcid][uuid] */ 


EXTERN_C const IID LIBID_PropSysObjects;

EXTERN_C const CLSID CLSID_InMemoryPropertyStore;

#ifdef __cplusplus

class DECLSPEC_UUID("9a02e012-6303-4e1e-b9a1-630f802592c5")
InMemoryPropertyStore;
#endif

EXTERN_C const CLSID CLSID_PropertySystem;

#ifdef __cplusplus

class DECLSPEC_UUID("b8967f85-58ae-4f46-9fb2-5d7904798f4b")
PropertySystem;
#endif
#endif /* __PropSysObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Proxy( 
    IInitializeWithStream * This,
    /* [annotation][in] */ 
    __in  IStream *pstream,
    /* [annotation][in] */ 
    __in  DWORD grfMode);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Stub( 
    __RPC__in IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);

/* [local] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Proxy( 
    IPropertyDescription * This,
    /* [annotation][out][in] */ 
    __inout  PROPVARIANT *ppropvar);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Stub( 
    __RPC__in IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\propvarutil.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// propvarutil.h - Variant and PropVariant helpers
//
//===========================================================================

#pragma once

typedef __success(return >= 0) LONG NTSTATUS;
#include <propapi.h>
#include <shtypes.h>
#include <shlwapi.h>

#ifndef PSSTDAPI
#if defined(_PROPSYS_)
#define PSSTDAPI          STDAPI
#define PSSTDAPI_(type)   STDAPI_(type)
#else
#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // PSSTDAPI

enum tagPSTIME_FLAGS
{
    PSTF_UTC   = 0x00000000,
    PSTF_LOCAL = 0x00000001,
};
typedef int PSTIME_FLAGS;

//====================
//
// PropVariant Helpers
//
//====================

// Initialize a propvariant
PSSTDAPI InitPropVariantFromResource(__in HINSTANCE hinst, __in UINT id, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromBuffer(__in_bcount(cb) const void *pv, __in UINT cb, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromCLSID(__in REFCLSID clsid, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromGUIDAsString(__in REFGUID guid, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromFileTime(__in const FILETIME *pftIn, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromPropVariantVectorElem(__in REFPROPVARIANT propvarIn, __in ULONG iElem, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantVectorFromPropVariant(__in REFPROPVARIANT propvarSingle, __out PROPVARIANT *ppropvarVector);
PSSTDAPI InitPropVariantFromStrRet(__inout STRRET *pstrret, __in_opt PCUITEMID_CHILD pidl, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromBooleanVector(__in_ecount_opt(cElems) const BOOL *prgf, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt16Vector(__in_ecount_opt(cElems) const SHORT *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt16Vector(__in_ecount_opt(cElems) const USHORT *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt32Vector(__in_ecount_opt(cElems) const LONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt32Vector(__in_ecount_opt(cElems) const ULONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt64Vector(__in_ecount_opt(cElems) const LONGLONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt64Vector(__in_ecount_opt(cElems) const ULONGLONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromDoubleVector(__in_ecount_opt(cElems) const DOUBLE *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromFileTimeVector(__in_ecount_opt(cElems) const FILETIME *prgft, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringVector(__in_ecount_opt(cElems) PCWSTR *prgsz, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringAsVector(__in_opt PCWSTR psz, __out PROPVARIANT *ppropvar);
#ifdef __cplusplus
HRESULT  InitPropVariantFromBoolean(__in BOOL fVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt16(__in SHORT nVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt16(__in USHORT uiVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt32(__in LONG lVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt32(__in ULONG ulVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt64(__in LONGLONG llVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt64(__in ULONGLONG ullVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromDouble(__in DOUBLE dblVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromString(__in PCWSTR psz, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromGUIDAsBuffer(__in REFGUID guid, __out PROPVARIANT *ppropvar);
BOOL     IsPropVariantVector(__in REFPROPVARIANT propvar);
BOOL     IsPropVariantString(__in REFPROPVARIANT propvar);
#endif

// Extract data from a propvariant
PSSTDAPI_(BOOL)      PropVariantToBooleanWithDefault(__in REFPROPVARIANT propvarIn, __in BOOL fDefault);
PSSTDAPI_(SHORT)     PropVariantToInt16WithDefault(__in REFPROPVARIANT propvarIn, __in SHORT iDefault);
PSSTDAPI_(USHORT)    PropVariantToUInt16WithDefault(__in REFPROPVARIANT propvarIn, __in USHORT uiDefault);
PSSTDAPI_(LONG)      PropVariantToInt32WithDefault(__in REFPROPVARIANT propvarIn, __in LONG lDefault);
PSSTDAPI_(ULONG)     PropVariantToUInt32WithDefault(__in REFPROPVARIANT propvarIn, __in ULONG ulDefault);
PSSTDAPI_(LONGLONG)  PropVariantToInt64WithDefault(__in REFPROPVARIANT propvarIn, __in LONGLONG llDefault);
PSSTDAPI_(ULONGLONG) PropVariantToUInt64WithDefault(__in REFPROPVARIANT propvarIn, __in ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)    PropVariantToDoubleWithDefault(__in REFPROPVARIANT propvarIn, __in DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)    PropVariantToStringWithDefault(__in REFPROPVARIANT propvarIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI             PropVariantToBoolean(__in REFPROPVARIANT propvarIn, __out BOOL *pfRet);
PSSTDAPI             PropVariantToInt16(__in REFPROPVARIANT propvarIn, __out SHORT *piRet);
PSSTDAPI             PropVariantToUInt16(__in REFPROPVARIANT propvarIn, __out USHORT *puiRet);
PSSTDAPI             PropVariantToInt32(__in REFPROPVARIANT propvarIn, __out LONG *plRet);
PSSTDAPI             PropVariantToUInt32(__in REFPROPVARIANT propvarIn, __out ULONG *pulRet);
PSSTDAPI             PropVariantToInt64(__in REFPROPVARIANT propvarIn, __out LONGLONG *pllRet);
PSSTDAPI             PropVariantToUInt64(__in REFPROPVARIANT propvarIn, __out ULONGLONG *pullRet);
PSSTDAPI             PropVariantToDouble(__in REFPROPVARIANT propvarIn, __out DOUBLE *pdblRet);
PSSTDAPI             PropVariantToBuffer(__in REFPROPVARIANT propvar, __out_bcount(cb) void *pv, __in UINT cb);
PSSTDAPI             PropVariantToString(__in REFPROPVARIANT propvar, __out_ecount(cch) PWSTR psz, __in UINT cch);
PSSTDAPI             PropVariantToGUID(__in REFPROPVARIANT propvar, __out GUID *pguid);
__checkReturn PSSTDAPI PropVariantToStringAlloc(__in REFPROPVARIANT propvar, __deref_out PWSTR *ppszOut);
__checkReturn PSSTDAPI PropVariantToBSTR(__in REFPROPVARIANT propvar, __deref_out BSTR *pbstrOut);
__checkReturn PSSTDAPI PropVariantToStrRet(__in REFPROPVARIANT propvar, __out STRRET *pstrret);
PSSTDAPI             PropVariantToFileTime(__in REFPROPVARIANT propvar, __in PSTIME_FLAGS pstfOut, __out FILETIME* pftOut);
#ifdef __cplusplus
HRESULT              PropVariantToCLSID(__in REFPROPVARIANT propvar, __out CLSID *pclsid);
#endif

// Returns element count of a VT_VECTOR or VT_ARRAY value; or 1 otherwise
PSSTDAPI_(ULONG) PropVariantGetElementCount(__in REFPROPVARIANT propvar);

// Extract data from a propvariant into a vector
PSSTDAPI PropVariantToBooleanVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgf, *pcElem) BOOL *prgf, __in ULONG crgf, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt16Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) SHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt16Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) USHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt32Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt32Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt64Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt64Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToDoubleVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToFileTimeVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgft, *pcElem) FILETIME *prgft, __in ULONG crgft, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToStringVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, __in ULONG crgsz, __out ULONG *pcElem);


// Extract data from a propvariant and return an newly allocated vector (free with CoTaskMemFree)
__checkReturn PSSTDAPI PropVariantToBooleanVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt16VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt16VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt32VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt32VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt64VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt64VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToDoubleVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToFileTimeVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) FILETIME **pprgft, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToStringVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Extract a single element from a propvariant.  If it is a VT_VECTOR or VT_ARRAY, returns the element you request.
// Otherwise iElem must equal 0 and the function will returns the value.
PSSTDAPI PropVariantGetBooleanElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out BOOL *pfVal);
PSSTDAPI PropVariantGetInt16Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out SHORT *pnVal);
PSSTDAPI PropVariantGetUInt16Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out USHORT *pnVal);
PSSTDAPI PropVariantGetInt32Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out LONG *pnVal);
PSSTDAPI PropVariantGetUInt32Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out ULONG *pnVal);
PSSTDAPI PropVariantGetInt64Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI PropVariantGetUInt64Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI PropVariantGetDoubleElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out DOUBLE *pnVal);
PSSTDAPI PropVariantGetFileTimeElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out FILETIME *pftVal);
__checkReturn PSSTDAPI PropVariantGetStringElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  PropVariantGetElem(__in REFPROPVARIANT propvarIn, __in ULONG iElem, __out PROPVARIANT *ppropvar);
#endif

// Helpers
PSSTDAPI_(void) ClearPropVariantArray(__inout_ecount(cVars) PROPVARIANT *rgPropVar, __in UINT cVars);

typedef enum 
{
    PVCU_DEFAULT = 0,
    PVCU_SECOND  = 1,
    PVCU_MINUTE  = 2,
    PVCU_HOUR    = 3,
    PVCU_DAY     = 4,
    PVCU_MONTH   = 5,
    PVCU_YEAR    = 6
} PROPVAR_COMPARE_UNIT;

enum tagPROPVAR_COMPARE_FLAGS
{
    PVCF_DEFAULT                 = 0x00000000,   // When comparing strings, use StrCmpLogical
    PVCF_TREATEMPTYASGREATERTHAN = 0x00000001,   // Empty/null values are greater-than non-empty values
    PVCF_USESTRCMP               = 0x00000002,   // When comparing strings, use StrCmp
    PVCF_USESTRCMPC              = 0x00000004,   // When comparing strings, use StrCmpC
    PVCF_USESTRCMPI              = 0x00000008,   // When comparing strings, use StrCmpI
    PVCF_USESTRCMPIC             = 0x00000010,   // When comparing strings, use StrCmpIC
};
typedef int PROPVAR_COMPARE_FLAGS;

// Comparisons
PSSTDAPI_(int) PropVariantCompareEx(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2, __in PROPVAR_COMPARE_UNIT unit, __in PROPVAR_COMPARE_FLAGS flags);
#ifdef __cplusplus
int PropVariantCompare(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2);
#endif

enum tagPROPVAR_CHANGE_FLAGS
{
    PVCHF_DEFAULT           = 0x00000000,
    PVCHF_NOVALUEPROP       = 0x00000001,       // Maps to VARIANT_NOVALUEPROP for VariantChangeType
    PVCHF_ALPHABOOL         = 0x00000002,       // Maps to VARIANT_ALPHABOOL for VariantChangeType
    PVCHF_NOUSEROVERRIDE    = 0x00000004,       // Maps to VARIANT_NOUSEROVERRIDE for VariantChangeType
    PVCHF_LOCALBOOL         = 0x00000008,       // Maps to VARIANT_LOCALBOOL for VariantChangeType
    PVCHF_NOHEXSTRING       = 0x00000010,       // Don't convert a string that looks like hexadecimal (0xABCD) to the numerical equivalent
};
typedef int PROPVAR_CHANGE_FLAGS;

// Coersions
PSSTDAPI PropVariantChangeType(__out PROPVARIANT *ppropvarDest, __in REFPROPVARIANT propvarSrc, __in PROPVAR_CHANGE_FLAGS flags, __in VARTYPE vt);

// Conversions
PSSTDAPI PropVariantToVariant(__in const PROPVARIANT *pPropVar, __out VARIANT *pVar);
PSSTDAPI VariantToPropVariant(__in const VARIANT* pVar, __out PROPVARIANT* pPropVar);

// Stg functions
__checkReturn PSSTDAPI StgSerializePropVariant(
            __in const PROPVARIANT* ppropvar,
            __deref_out_bcount(*pcb) SERIALIZEDPROPERTYVALUE** ppProp,
            __out ULONG* pcb);
    
PSSTDAPI StgDeserializePropVariant(
            __in const SERIALIZEDPROPERTYVALUE* pprop,
            __in ULONG cbMax,
            __out PROPVARIANT* ppropvar);



//================
//
// Variant Helpers
//
//================

#ifdef __cplusplus
BOOL IsVarTypeFloat(__in VARTYPE vt);
BOOL IsVariantArray(__in REFVARIANT var);
BOOL IsVariantString(__in REFVARIANT var);
BOOL IsVarTypeNumber(__in VARTYPE vt);
BOOL IsVarTypeInteger(__in VARTYPE vt);
#endif

// Initialize a VARIANT
PSSTDAPI InitVariantFromResource(__in HINSTANCE hinst, __in UINT id, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBuffer(__in_bcount(cb) const void *pv, __in UINT cb, __out VARIANT *pvar);
PSSTDAPI InitVariantFromGUIDAsString(__in REFGUID guid, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTime(__in const FILETIME *pft, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTimeArray(__in_ecount_opt(cElems) const FILETIME *prgft, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStrRet(__in STRRET *pstrret, __in PCUITEMID_CHILD pidl, __out VARIANT *pvar);
PSSTDAPI InitVariantFromVariantArrayElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBooleanArray(__in_ecount(cElems) const BOOL *prgf, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt16Array(__in_ecount(cElems) const SHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt16Array(__in_ecount(cElems) const USHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt32Array(__in_ecount(cElems) const LONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt32Array(__in_ecount(cElems) const ULONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt64Array(__in_ecount(cElems) const LONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt64Array(__in_ecount(cElems) const ULONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromDoubleArray(__in_ecount(cElems) const DOUBLE *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStringArray(__in_ecount(cElems) PCWSTR *prgsz, __in ULONG cElems, __out VARIANT *pvar);
#ifdef __cplusplus
HRESULT  InitVariantFromBoolean(__in BOOL fVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt16(__in SHORT iVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt16(__in USHORT uiVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt32(__in LONG lVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt32(__in ULONG ulVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt64(__in LONGLONG llVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt64(__in ULONGLONG ullVal, __out VARIANT *pvar);
HRESULT  InitVariantFromDouble(__in DOUBLE dblVal, __out VARIANT *pvar);
HRESULT  InitVariantFromString(__in PCWSTR psz, __out VARIANT *pvar);
HRESULT  InitVariantFromDispatch(__in_opt IDispatch* pdisp, __out VARIANT *pvar);
HRESULT  InitVariantFromDosDateTime(__in WORD wDate, __in WORD wTime, __out VARIANT *pvar);
HRESULT  InitVariantFromGUIDAsBuffer(__in REFGUID guid, __out VARIANT *pvar);
#endif

// Extract data from a VARIANT
PSSTDAPI_(BOOL)       VariantToBooleanWithDefault(__in REFVARIANT varIn, __in BOOL fDefault);
PSSTDAPI_(SHORT)      VariantToInt16WithDefault(__in REFVARIANT varIn, __in SHORT iDefault);
PSSTDAPI_(USHORT)     VariantToUInt16WithDefault(__in REFVARIANT varIn, __in USHORT uiDefault);
PSSTDAPI_(LONG)       VariantToInt32WithDefault(__in REFVARIANT varIn, __in LONG lDefault);
PSSTDAPI_(ULONG)      VariantToUInt32WithDefault(__in REFVARIANT varIn, __in ULONG ulDefault);
PSSTDAPI_(LONGLONG)   VariantToInt64WithDefault(__in REFVARIANT varIn, __in LONGLONG llDefault);
PSSTDAPI_(ULONGLONG)  VariantToUInt64WithDefault(__in REFVARIANT varIn, __in ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)     VariantToDoubleWithDefault(__in REFVARIANT varIn, __in DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)     VariantToStringWithDefault(__in REFVARIANT varIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI              VariantToBoolean(__in REFVARIANT varIn, __out BOOL *pfRet);
PSSTDAPI              VariantToInt16(__in REFVARIANT varIn, __out SHORT *piRet);
PSSTDAPI              VariantToUInt16(__in REFVARIANT varIn, __out USHORT *puiRet);
PSSTDAPI              VariantToInt32(__in REFVARIANT varIn, __out LONG *plRet);
PSSTDAPI              VariantToUInt32(__in REFVARIANT varIn, __out ULONG *pulRet);
PSSTDAPI              VariantToInt64(__in REFVARIANT varIn, __out LONGLONG *pllRet);
PSSTDAPI              VariantToUInt64(__in REFVARIANT varIn, __out ULONGLONG *pullRet);
PSSTDAPI              VariantToDouble(__in REFVARIANT varIn, __out DOUBLE *pdblRet);
PSSTDAPI              VariantToBuffer(__in REFVARIANT varIn, __out_bcount(cb) void *pv, __in UINT cb);
PSSTDAPI              VariantToGUID(__in REFVARIANT varIn, __out GUID *pguid);
PSSTDAPI              VariantToString(__in REFVARIANT varIn, __out_ecount(cchBuf) PWSTR pszBuf, __in UINT cchBuf);
__checkReturn PSSTDAPI VariantToStringAlloc(__in REFVARIANT varIn, __deref_out PWSTR *ppszBuf);
PSSTDAPI              VariantToDosDateTime(__in REFVARIANT varIn, __out WORD *pwDate, __out WORD *pwTime);
__checkReturn PSSTDAPI VariantToStrRet(__in REFVARIANT varIn, __out STRRET *pstrret);
PSSTDAPI              VariantToFileTime(__in REFVARIANT varIn, __in PSTIME_FLAGS stfOut, __out FILETIME* pftOut);

// Get the element count.  Returns number of elements for values of type VT_ARRAY; returns 1 otherwise.
PSSTDAPI_(ULONG) VariantGetElementCount(__in REFVARIANT varIn);

// Extract data from a VARIANT into a vector
PSSTDAPI VariantToBooleanArray(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) BOOL *prgf, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt16Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) SHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt16Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) USHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt32Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt32Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt64Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt64Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToDoubleArray(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, __in ULONG crgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToStringArray(__in REFVARIANT var, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, __in ULONG crgsz, __out ULONG *pcElem);

// Extract data from a VARIANT into a newly allocated vector (free with CoTaskMemFree)
__checkReturn PSSTDAPI VariantToBooleanArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt16ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt16ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt32ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt32ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt64ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt64ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToDoubleArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToStringArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Get a single element of a VARIANT.  If it is type VT_ARRAY, returns a the requested element.  Otherwise
// iElem must equal 0 and the function returns the value.
PSSTDAPI VariantGetBooleanElem(__in REFVARIANT var, __in ULONG iElem, __out BOOL *pfVal);
PSSTDAPI VariantGetInt16Elem(__in REFVARIANT var, __in ULONG iElem, __out SHORT *pnVal);
PSSTDAPI VariantGetUInt16Elem(__in REFVARIANT var, __in ULONG iElem, __out USHORT *pnVal);
PSSTDAPI VariantGetInt32Elem(__in REFVARIANT var, __in ULONG iElem, __out LONG *pnVal);
PSSTDAPI VariantGetUInt32Elem(__in REFVARIANT var, __in ULONG iElem, __out ULONG *pnVal);
PSSTDAPI VariantGetInt64Elem(__in REFVARIANT var, __in ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI VariantGetUInt64Elem(__in REFVARIANT var, __in ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI VariantGetDoubleElem(__in REFVARIANT var, __in ULONG iElem, __out DOUBLE *pnVal);
__checkReturn PSSTDAPI VariantGetStringElem(__in REFVARIANT var, __in ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  VariantGetElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar);
#endif

// Helpers
PSSTDAPI_(void) ClearVariantArray(__inout_ecount(cvars) VARIANT *pvars, __in UINT cvars);
PSSTDAPI_(int) VariantCompare(__in REFVARIANT var1, __in REFVARIANT var2);

//===========================
//
// Property-specific notions
//
//===========================


// The progress bar property control uses a specially formatted PROPVARIANT to convey the look of the progress bar
// propvar.vt = VT_UI4
// propvar.caul.pElems[0] = current progress
// propvar.caul.pElems[1] = total progress
// propvar.caul.pElems[2] = DRAWPROGRESSFLAGS (see below);
typedef enum DRAWPROGRESSFLAGS
{
    DPF_NONE                = 0x0,  // No progress flags.
    DPF_MARQUEE             = 0x1,  // The progress bar should draw in marquee mode.
    DPF_MARQUEE_COMPLETE    = 0x2,  // The marquee format progress bar has completed.
    DPF_ERROR               = 0x4,  // The progress bar should be drawn in the error state.
    DPF_WARNING             = 0x8,  // The progress bar should be drawn in the warning state.
    DPF_STOPPED             = 0x10, // The progress bar is stopped.
} DRAWPROGRESSFLAGS;

//================
//
// Inline Helpers
//
//================

#if defined(__cplusplus) && !defined(NO_PROPVAR_INLINES)
inline HRESULT InitPropVariantFromBoolean(__in BOOL fVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_BOOL;
    ppropvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt16(__in SHORT nVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I2;
    ppropvar->iVal = nVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt16(__in USHORT uiVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI2;
    ppropvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt32(__in LONG lVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I4;
    ppropvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt32(__in ULONG ulVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI4;
    ppropvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt64(__in LONGLONG llVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I8;
    ppropvar->hVal.QuadPart = llVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt64(__in ULONGLONG ullVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI8;
    ppropvar->uhVal.QuadPart = ullVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromDouble(__in DOUBLE dblVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_R8;
    ppropvar->dblVal = dblVal;
    return S_OK;
}

// Creates a VT_LPWSTR propvariant.
inline HRESULT InitPropVariantFromString(__in PCWSTR psz, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_LPWSTR;
    HRESULT hr = SHStrDupW(psz, &ppropvar->pwszVal);
    if (FAILED(hr))
    {
        PropVariantInit(ppropvar);
    }
    return hr;
}

// Creates a VT_VECTOR | VT_UI1 propvariant.
inline HRESULT InitPropVariantFromGUIDAsBuffer(__in REFGUID guid, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromBuffer(&guid, sizeof(GUID), ppropvar);
}

inline BOOL IsPropVariantVector(__in REFPROPVARIANT propvar)
{
    return (propvar.vt & (VT_ARRAY | VT_VECTOR));
}

// If TRUE, propvar contains a unicode string.  Use PropVariantToStringWithDefault(propvar, NULL) to retrieve it.
inline BOOL IsPropVariantString(__in REFPROPVARIANT propvar)
{
    return (PropVariantToStringWithDefault(propvar, NULL) != NULL);
}

// Handles int instead of LONG
inline HRESULT PropVariantToInt32(__in REFPROPVARIANT propvarIn, __out int *piRet)
{
    return PropVariantToInt32(propvarIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT PropVariantToUInt32(__in REFPROPVARIANT propvarIn, __out UINT *piRet)
{
    return PropVariantToUInt32(propvarIn, (ULONG*)piRet);
}

inline HRESULT PropVariantToCLSID(__in REFPROPVARIANT propvarIn, __out CLSID *pclsid)
{ 
    return PropVariantToGUID(propvarIn, (GUID*)pclsid);
}  


inline int PropVariantCompare(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2)
{
    return PropVariantCompareEx(propvar1, propvar2, PVCU_DEFAULT, PVCF_DEFAULT);
}

inline HRESULT PropVariantGetElem(__in REFPROPVARIANT propvarIn, __in ULONG iElem, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromPropVariantVectorElem(propvarIn, iElem, ppropvar);
}

inline HRESULT InitVariantFromBoolean(__in BOOL fVal, __out VARIANT *pvar)
{
    pvar->vt = VT_BOOL;
    pvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitVariantFromInt16(__in short iVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I2;
    pvar->iVal = iVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt16(__in USHORT uiVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI2;
    pvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt32(__in LONG lVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I4;
    pvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt32(__in ULONG ulVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI4;
    pvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt64(__in LONGLONG llVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I8;
    pvar->llVal = llVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt64(__in ULONGLONG ullVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI8;
    pvar->ullVal = ullVal;
    return S_OK;
}

inline HRESULT InitVariantFromDouble(__in DOUBLE dblVal, __out VARIANT *pvar)
{
    pvar->vt = VT_R8;
    pvar->dblVal = dblVal;
    return S_OK;
}

inline HRESULT InitVariantFromString(__in PCWSTR psz, __out VARIANT *pvar)
{
    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(psz);
    HRESULT hr =  pvar->bstrVal ? S_OK : (psz ? E_OUTOFMEMORY : E_INVALIDARG);
    if (FAILED(hr))
    {
        VariantInit(pvar);
    }
    return hr;
}

inline HRESULT InitVariantFromDispatch(__in_opt IDispatch* pdisp, __out VARIANT *pvar)
{
    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdisp;
    if (pvar->pdispVal)
    {
        (pvar->pdispVal)->AddRef();
    }
    return S_OK;
}

// Creates a VT_DATE variant
inline HRESULT InitVariantFromDosDateTime(__in WORD wDate, __in WORD wTime, __out VARIANT *pvar)
{
    pvar->vt = VT_DATE;
    return DosDateTimeToVariantTime(wDate, wTime, &pvar->date) ? S_OK : S_FALSE;
}

inline BOOL IsVarTypeFloat(__in VARTYPE vt)
{
    return (vt == VT_R4 || vt == VT_R8);
}

inline BOOL IsVariantArray(__in REFVARIANT var)
{
    return (var.vt & VT_ARRAY);
}

// if TRUE, you can use VariantToStringCast to obtain the string pointer
inline BOOL IsVariantString(__in REFVARIANT var)
{
    return (VariantToStringWithDefault(var, NULL) != NULL);
}

inline BOOL IsVarTypeNumber(__in VARTYPE vt)
{
    return IsVarTypeInteger(vt) || IsVarTypeFloat(vt);
}

inline BOOL IsVarTypeSignedInteger(__in VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeUnsignedInteger(__in VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeInteger(__in VARTYPE vt)
{
    return IsVarTypeSignedInteger(vt) || IsVarTypeUnsignedInteger(vt);
}

// Creates a VT_ARRAY | VT_UI1 variant.
inline HRESULT InitVariantFromGUIDAsBuffer(__in REFGUID guid, __out VARIANT *pvar)
{
    return InitVariantFromBuffer(&guid, sizeof(GUID), pvar);
}

// Handles int instead of LONG
inline HRESULT VariantToInt32(__in REFVARIANT varIn, __out int *piRet)
{
    return VariantToInt32(varIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT VariantToUInt32(__in REFVARIANT varIn, __out UINT *piRet)
{
    return VariantToUInt32(varIn, (ULONG*)piRet);
}

inline HRESULT VariantGetElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar)
{
    return InitVariantFromVariantArrayElem(varIn, iElem, pvar);
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PrSht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#endif


#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif
#endif // ifndef SNDMSG

#ifndef PSTMSG
#ifdef __cplusplus
#define PSTMSG ::PostMessage
#else
#define PSTMSG PostMessage
#endif
#endif // ifndef PSTMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK *LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA *ppsp);
typedef UINT (CALLBACK *LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT                0x00000000
#define PSP_DLGINDIRECT            0x00000001
#define PSP_USEHICON               0x00000002
#define PSP_USEICONID              0x00000004
#define PSP_USETITLE               0x00000008
#define PSP_RTLREADING             0x00000010

#define PSP_HASHELP                0x00000020
#define PSP_USEREFPARENT           0x00000040
#define PSP_USECALLBACK            0x00000080
#define PSP_PREMATURE              0x00000400

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 --------------
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
//-------------------------------------------
#endif
#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define PSP_USEFUSIONCONTEXT       0x00004000
#endif


#if (_WIN32_IE >= 0x0500)
#define PSPCB_ADDREF            0
#endif
#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

#ifdef _WIN32
typedef LPCDLGTEMPLATE PROPSHEETPAGE_RESOURCE;
#else
typedef const VOID* PROPSHEETPAGE_RESOURCE;
#endif

#define PROPSHEETPAGEA_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCSTR      pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCSTR       pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCSTR           pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKA pfnCallback;  \
    UINT             *pcRefParent; \

#define PROPSHEETPAGEW_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCWSTR     pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCWSTR      pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCWSTR          pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKW pfnCallback;  \
    UINT             *pcRefParent; \

#if _WIN32_WINNT >= 0x0600
#define  _PROPSHEETPAGEA_V4 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V4 _PROPSHEETPAGEW
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define  _PROPSHEETPAGEA_V3 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V3 _PROPSHEETPAGEW
#elif (_WIN32_IE >= 0x0400)
#define  _PROPSHEETPAGEA_V2 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V2 _PROPSHEETPAGEW
#else
#define  _PROPSHEETPAGEA_V1 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V1 _PROPSHEETPAGEW
#endif

typedef struct _PROPSHEETPAGEA_V1
{
    PROPSHEETPAGEA_V1_FIELDS
} PROPSHEETPAGEA_V1, *LPPROPSHEETPAGEA_V1;
typedef const PROPSHEETPAGEA_V1 *LPCPROPSHEETPAGEA_V1;

typedef struct _PROPSHEETPAGEA_V2
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEA_V2, *LPPROPSHEETPAGEA_V2;
typedef const PROPSHEETPAGEA_V2 *LPCPROPSHEETPAGEA_V2;

typedef struct _PROPSHEETPAGEA_V3
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEA_V3, *LPPROPSHEETPAGEA_V3;
typedef const PROPSHEETPAGEA_V3 *LPCPROPSHEETPAGEA_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEA_V4
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCSTR      pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEA_V4, *LPPROPSHEETPAGEA_V4;
typedef const PROPSHEETPAGEA_V4 *LPCPROPSHEETPAGEA_V4;
#endif

typedef struct _PROPSHEETPAGEW_V1
{
    PROPSHEETPAGEW_V1_FIELDS
} PROPSHEETPAGEW_V1, *LPPROPSHEETPAGEW_V1;
typedef const PROPSHEETPAGEW_V1 *LPCPROPSHEETPAGEW_V1;

typedef struct _PROPSHEETPAGEW_V2
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEW_V2, *LPPROPSHEETPAGEW_V2;
typedef const PROPSHEETPAGEW_V2 *LPCPROPSHEETPAGEW_V2;

typedef struct _PROPSHEETPAGEW_V3
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEW_V3, *LPPROPSHEETPAGEW_V3;
typedef const PROPSHEETPAGEW_V3 *LPCPROPSHEETPAGEW_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEW_V4
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE            hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCWSTR     pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEW_V4, *LPPROPSHEETPAGEW_V4;
typedef const PROPSHEETPAGEW_V4 *LPCPROPSHEETPAGEW_V4;
#endif

#define PROPSHEETPAGEA_V1_SIZE sizeof(PROPSHEETPAGEA_V1)
#define PROPSHEETPAGEW_V1_SIZE sizeof(PROPSHEETPAGEW_V1)

#define PROPSHEETPAGEA_V2_SIZE sizeof(PROPSHEETPAGEA_V2)
#define PROPSHEETPAGEW_V2_SIZE sizeof(PROPSHEETPAGEW_V2)

#define PROPSHEETPAGEA_V3_SIZE sizeof(PROPSHEETPAGEA_V3)
#define PROPSHEETPAGEW_V3_SIZE sizeof(PROPSHEETPAGEW_V3)

#if _WIN32_WINNT >= 0x0600
#define PROPSHEETPAGEA_V4_SIZE sizeof(PROPSHEETPAGEA_V4)
#define PROPSHEETPAGEW_V4_SIZE sizeof(PROPSHEETPAGEW_V4)
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW_LATEST;
#else
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW_LATEST;
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW;
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW;
#elif (_WIN32_IE >= 0x0400)
typedef    PROPSHEETPAGEA_V2    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V2    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V2  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V2  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V2 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V2 LPCPROPSHEETPAGEW;
#else
typedef    PROPSHEETPAGEA_V1    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V1    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V1  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V1  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V1 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V1 LPCPROPSHEETPAGEW;
#endif

#ifdef UNICODE
#define    PROPSHEETPAGE           PROPSHEETPAGEW
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEW_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEW_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEW_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEW_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEW_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEW_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEW_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEW_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEW_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEW_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEW_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEW_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEW_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEW_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEW_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEW_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEW_LATEST
#else
#define    PROPSHEETPAGE           PROPSHEETPAGEA
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEA_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEA_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEA_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEA_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEA_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEA_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEA_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEA_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEA_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEA_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEA_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEA_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEA_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEA_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEA_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEA_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEA_LATEST
#endif


//----- PropSheet Header related ---------

#define PSH_DEFAULT             0x00000000
#define PSH_PROPTITLE           0x00000001
#define PSH_USEHICON            0x00000002
#define PSH_USEICONID           0x00000004
#define PSH_PROPSHEETPAGE       0x00000008

#define PSH_WIZARDHASFINISH     0x00000010
#define PSH_WIZARD              0x00000020
#define PSH_USEPSTARTPAGE       0x00000040
#define PSH_NOAPPLYNOW          0x00000080

#define PSH_USECALLBACK         0x00000100
#define PSH_HASHELP             0x00000200
#define PSH_MODELESS            0x00000400
#define PSH_RTLREADING          0x00000800

#define PSH_WIZARDCONTEXTHELP   0x00001000

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 -----------
#if (_WIN32_IE < 0x0500)
#define PSH_WIZARD97            0x00002000
#else
#define PSH_WIZARD97            0x01000000
#endif
#define PSH_WATERMARK           0x00008000

#define PSH_USEHBMWATERMARK     0x00010000  // user pass in a hbmWatermark instead of pszbmWatermark
#define PSH_USEHPLWATERMARK     0x00020000  //
#define PSH_STRETCHWATERMARK    0x00040000  // stretchwatermark also applies for the header
#define PSH_HEADER              0x00080000

#define PSH_USEHBMHEADER        0x00100000
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
//----------------------------------------
#endif

#if (_WIN32_IE >= 0x0500)
//----- New flags for wizard-lite --------
#define PSH_WIZARD_LITE         0x00400000
#define PSH_NOCONTEXTHELP       0x02000000
//----------------------------------------
#endif


#if _WIN32_WINNT >= 0x0600
#define PSH_AEROWIZARD                          0x00004000

#define PSH_RESIZABLE                           0x04000000
#define PSH_HEADERBITMAP                        0x08000000
#define PSH_NOMARGIN                            0x10000000
#endif



typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

#define PROPSHEETHEADERA_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCSTR      pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCSTR          pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCSTR      pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEA ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;   

typedef struct _PROPSHEETHEADERA_V1
{
    PROPSHEETHEADERA_V1_FIELDS
} PROPSHEETHEADERA_V1, *LPPROPSHEETHEADERA_V1;
typedef const PROPSHEETHEADERA_V1 *LPCPROPSHEETHEADERA_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERA_V2
{
    PROPSHEETHEADERA_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERA_V2, *LPPROPSHEETHEADERA_V2;
typedef const PROPSHEETHEADERA_V2 *LPCPROPSHEETHEADERA_V2;
#endif

#define PROPSHEETHEADERW_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCWSTR     pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCWSTR         pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCWSTR     pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEW ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;  

typedef struct _PROPSHEETHEADERW_V1
{
    PROPSHEETHEADERW_V1_FIELDS
} PROPSHEETHEADERW_V1, *LPPROPSHEETHEADERW_V1;
typedef const PROPSHEETHEADERW_V1 *LPCPROPSHEETHEADERW_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERW_V2
{
    PROPSHEETHEADERW_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCWSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCWSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERW_V2, *LPPROPSHEETHEADERW_V2;
typedef const PROPSHEETHEADERW_V2 *LPCPROPSHEETHEADERW_V2;
#endif

#define PROPSHEETHEADERA_V1_SIZE sizeof(PROPSHEETHEADERA_V1)
#define PROPSHEETHEADERW_V1_SIZE sizeof(PROPSHEETHEADERW_V1)

#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADERA_V2_SIZE sizeof(PROPSHEETHEADERA_V2)
#define PROPSHEETHEADERW_V2_SIZE sizeof(PROPSHEETHEADERW_V2)
#endif

#if (_WIN32_IE >= 0x400)
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V2;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V2;
typedef    PROPSHEETHEADERA_V2      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V2      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V2      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V2      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V2      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V2      LPCPROPSHEETHEADERW;
#else
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V1;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V1;
typedef    PROPSHEETHEADERA_V1      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V1      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V1      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V1      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V1      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V1      LPCPROPSHEETHEADERW;
#endif


#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERW_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERW_V2_SIZE
#endif
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERA_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERA_V2_SIZE
#endif
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

#if (_WIN32_IE >= 0x560)
// PSCB_BUTTONPRESSED will be sent when the user clicks a button in the
// property dialog (OK, Cancel, Apply, or Close).  The message will be sent
// to PROPSHEETHEADER's pfnCallback if the PSH_USECALLBACK flag was specified.
// The LPARAM will be equal to one of the following based on the button pressed:
// This message is only supported on comctl32 v6.
// PSBTN_FINISH (Close), PSBTN_OK, PSBTN_APPLYNOW, or PSBTN_CANCEL

#define PSCB_BUTTONPRESSED 3
#endif  // _WIN32_IE >= 0x560


WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetA(LPCPROPSHEETHEADERA);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, *LPPSHNOTIFY;

#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)
#if (_WIN32_IE >= 0x0400)
#define PSN_GETOBJECT           (PSN_FIRST-10)
#endif // 0x0400
#if (_WIN32_IE >= 0x0500)
#define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
#define PSN_QUERYINITIALFOCUS   (PSN_FIRST-13)
#endif // 0x0500

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2
#define PSNRET_MESSAGEHANDLED       3

#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)(index), (LPARAM)(hpage))


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)(hpage))


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)(hpage))


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)(hwnd), 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)(hwnd), 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)


#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)(lpszText))


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)(dwFlags))


#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008

#define PSWIZBF_ELEVATIONREQUIRED   0x00000001

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SHOWWIZBUTTONS
#define PSWIZB_CANCEL           0x00000010
#endif // 0x0605


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)(iButton), 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)(id))


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)(lpszText))


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)(pMsg))

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define PSM_INSERTPAGE          (WM_USER + 119)
#define PropSheet_InsertPage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_INSERTPAGE, (WPARAM)(index), (LPARAM)(hpage))

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SETHEADERTITLE
#define PSWIZF_SETCOLOR         ((UINT)(-1))
#endif

#if (_WIN32_IE >= 0x0500)
#define PSM_SETHEADERTITLEA     (WM_USER + 125)
#define PSM_SETHEADERTITLEW     (WM_USER + 126)

#ifdef UNICODE
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEW
#else
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEA
#endif

#define PropSheet_SetHeaderTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERTITLE, (WPARAM)(index), (LPARAM)(lpszText))


#define PSM_SETHEADERSUBTITLEA     (WM_USER + 127)
#define PSM_SETHEADERSUBTITLEW     (WM_USER + 128)

#ifdef UNICODE
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEW
#else
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEA
#endif

#define PropSheet_SetHeaderSubTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERSUBTITLE, (WPARAM)(index), (LPARAM)(lpszText))

#define PSM_HWNDTOINDEX            (WM_USER + 129)
#define PropSheet_HwndToIndex(hDlg, hwnd) \
        (int)SNDMSG(hDlg, PSM_HWNDTOINDEX, (WPARAM)(hwnd), 0)

#define PSM_INDEXTOHWND            (WM_USER + 130)
#define PropSheet_IndexToHwnd(hDlg, i) \
        (HWND)SNDMSG(hDlg, PSM_INDEXTOHWND, (WPARAM)(i), 0)

#define PSM_PAGETOINDEX            (WM_USER + 131)
#define PropSheet_PageToIndex(hDlg, hpage) \
        (int)SNDMSG(hDlg, PSM_PAGETOINDEX, 0, (LPARAM)(hpage))

#define PSM_INDEXTOPAGE            (WM_USER + 132)
#define PropSheet_IndexToPage(hDlg, i) \
        (HPROPSHEETPAGE)SNDMSG(hDlg, PSM_INDEXTOPAGE, (WPARAM)(i), 0)

#define PSM_IDTOINDEX              (WM_USER + 133)
#define PropSheet_IdToIndex(hDlg, id) \
        (int)SNDMSG(hDlg, PSM_IDTOINDEX, 0, (LPARAM)(id))

#define PSM_INDEXTOID              (WM_USER + 134)
#define PropSheet_IndexToId(hDlg, i) \
        SNDMSG(hDlg, PSM_INDEXTOID, (WPARAM)(i), 0)

#define PSM_GETRESULT              (WM_USER + 135)
#define PropSheet_GetResult(hDlg) \
        SNDMSG(hDlg, PSM_GETRESULT, 0, 0)

#define PSM_RECALCPAGESIZES        (WM_USER + 136)
#define PropSheet_RecalcPageSizes(hDlg) \
        SNDMSG(hDlg, PSM_RECALCPAGESIZES, 0, 0)
#endif // 0x0500


#if _WIN32_WINNT >= 0x0600
// Only UNICODE
// These messages are only for Aero Wizard style wizards. The Wizard author
// needs to specify the PSH_AEROWIZARD flag in the dwFlags member of the PROPSHEETHEADER
// structure to get this behavior.

#define PSM_SETNEXTTEXTW          (WM_USER + 137)
#define PSM_SETNEXTTEXT           PSM_SETNEXTTEXTW

#define PropSheet_SetNextText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETNEXTTEXT, 0, (LPARAM)(lpszText))

#define PSWIZB_SHOW                     0
#define PSWIZB_RESTORE                  1


#define PSM_SHOWWIZBUTTONS              (WM_USER + 138)
#define PropSheet_ShowWizButtons(hDlg, dwFlag, dwButton) \
        PSTMSG(hDlg, PSM_SHOWWIZBUTTONS, (WPARAM)(dwFlag), (LPARAM)(dwButton))


#define PSM_ENABLEWIZBUTTONS            (WM_USER + 139)
#define PropSheet_EnableWizButtons(hDlg, dwState, dwMask) \
        PSTMSG(hDlg, PSM_ENABLEWIZBUTTONS, (WPARAM)(dwState), (LPARAM)(dwMask))


#define PSM_SETBUTTONTEXTW         (WM_USER + 140)
#define PSM_SETBUTTONTEXT          PSM_SETBUTTONTEXTW
#define PropSheet_SetButtonText(hDlg, dwButton, lpszText) \
        SNDMSG(hDlg, PSM_SETBUTTONTEXT, (WPARAM)(dwButton), (LPARAM)(lpszText))


#endif // 0x0600


#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif




#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "prsht.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PshPack4.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,4)
#else
#pragma pack(4)
#endif
#else
#pragma pack(4)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Provider.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

public:
    Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
    ~Provider();
    static BOOL initFailed();


protected:
    /* Override These Methods To Implement Your Provider */

    // This is the entrypoint for changes.
    // You are handed a changed instance.
    // If you can make the changes - do so.
    // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
    // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
    virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

    // entrypoint to delete an instance
    // examine the instance passed in, determine whether you can delete it
    virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

    // execute a method
    virtual HRESULT ExecMethod(const CInstance& cInstance, 
        __in const BSTR bstrMethodName, 
        __in CInstance *pInParams, 
        __out CInstance *pOutParams, 
        long lFlags = 0L);

    // find and create all instances of your class
    virtual HRESULT EnumerateInstances(__in MethodContext *pMethodContext, long lFlags = 0L);

    // you will be given an object with the key properties filled in
    // you need to fill in all of the rest of the properties, or
    // return WBEM_E_NOT_FOUND if the object doesn't exist.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags = 0L);

    // You will be given an object with the key properties filled in.
    // You can either fill in all the properties, or check the Query object
    // to see what properties are required.  If you don't implement this method, the
    // GetObject(CInstance, long) method will be called instead.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags, __in CFrameworkQuery &Query);

    // If a provider wants to process queries, they should override this
    virtual HRESULT ExecQuery(__in MethodContext *pMethodContext, 
        __in CFrameworkQuery& cQuery, 
        long lFlags = 0L);

    // flushes cache
    // only override if you allocate memory that could be flushed
    virtual void Flush(void);

    /* Helpers - Use These, Do Not Override */

    // allocate a new instance & return pointer to it
    // the memory is your responsibility to Release()
    // UNLESS you pass it off to Provider::Commit
    CInstance *CreateNewInstance(__in MethodContext *pMethodContext);

    // used to send your new instance back to the framework
    // set bCache to true to cache object 
    // !! caching is NOT IMPLEMENTED in this release !!
    // do not delete or release the pointer once committed.
    HRESULT Commit(__inout CInstance *pInstance, bool bCache = false);

    // Helper function for building a WBEM Object Path for a local Instance
    bool GetLocalInstancePath( const CInstance *pInstance, __out CHString& strPath );

    //   Builds a full instance path from a relative path
    CHString MakeLocalPath( const CHString &strRelPath );

    // Returns the computer name as a CHString.  Save yourself the os call,
    // since we've got it hanging around anyway.
    const CHString &GetLocalComputerName() {return s_strComputerName;}
    const CHString &GetNamespace() {return m_strNameSpace;}

    // sets the CreationClassName property to the name of this provider
    bool SetCreationClassName(__inout CInstance *pInstance);

    // accesses the name of the provider
    const CHString &GetProviderName() {return m_name;}

    // Flag validation constants
    enum FlagDefs
    {
        EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
        GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
        MethodFlags = WBEM_FLAG_SEND_STATUS,
        DeletionFlags = WBEM_FLAG_SEND_STATUS,
        PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
        QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
    };

    // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
    HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

    // you can override the following to support flags 
    // above and beyond those listed in FlagDefs above
    virtual HRESULT ValidateEnumerationFlags(long lFlags);
    virtual HRESULT ValidateGetObjFlags(long lFlags);
    virtual HRESULT ValidateMethodFlags(long lFlags);
    virtual HRESULT ValidateQueryFlags(long lFlags);
    virtual HRESULT ValidateDeletionFlags(long lFlags);
    virtual HRESULT ValidatePutInstanceFlags(long lFlags);

private:
    static BOOL initFailed_;

    IWbemServices       *m_pIMosProvider;    // provides instances
    CHString            m_name;             // name of this provider
    CHString            m_strNameSpace;     // name of this provider's namespace
    IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

    static CHString     s_strComputerName;  // Holds the computer name for building
    // instance paths.

    BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
    // pointer is available, and is called
    // by the framework entrypoint functions

    /* Interfaces For Use by the Framework         */
    HRESULT GetObject(  __in ParsedObjectPath *pParsedObjectPath, 
        __in MethodContext *pContext, long lFlags = 0L );

    HRESULT ExecuteQuery( __in MethodContext *pContext, 
        __in CFrameworkQuery &pQuery, 
        long lFlags = 0L);

    HRESULT CreateInstanceEnum( __in MethodContext *pContext, long lFlags = 0L );

    HRESULT PutInstance( __in IWbemClassObject __RPC_FAR *pInst,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT DeleteInstance( __in ParsedObjectPath *pParsedObjectPath,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT ExecMethod( __in ParsedObjectPath *pParsedObjectPath,
        __in BSTR bstrMethodName,
        long lFlags,
        __in CInstance *pInParams,
        __out CInstance *pOutParams,
        __in MethodContext *pContext );

    // Static helper function called by constructor to make sure the
    // computer name variable is properly initialized.
    static void WINAPI InitComputerName( void );

    // Sets an instance key from a parsed object path.
    BOOL SetKeyFromParsedObjectPath( __inout CInstance *pInstance, 
        __in ParsedObjectPath *pParsedObjectPath );

    IWbemClassObject *GetClassObjectInterface(__in MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PshPack2.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,2)
#else
#pragma pack(2)
#endif
#else
#pragma pack(2)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\prsht.inl ===
/* Copyright (c) 2001-2009, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1);

#if defined(UNICODE)

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageW
#define IsolationAwarePropertySheet IsolationAwarePropertySheetW

#else /* UNICODE */

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageA
#define IsolationAwarePropertySheet IsolationAwarePropertySheetA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEA constPropSheetPagePointer);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;

    const LPPROPSHEETPAGEA_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEA_LATEST)constPropSheetPagePointer;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageA");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEA_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEW constPropSheetPagePointer);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;

    const LPPROPSHEETPAGEW_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEW_LATEST)constPropSheetPagePointer;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageW");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEW_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HPROPSHEETPAGE unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DestroyPropertySheetPage");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        fResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERA unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetA");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        nResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERW unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetW");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        nResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comctl32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comctl32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comctl32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comctl32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreatePropertySheetPageA IsolationAwareCreatePropertySheetPageA
#define CreatePropertySheetPageW IsolationAwareCreatePropertySheetPageW
#define DestroyPropertySheetPage IsolationAwareDestroyPropertySheetPage
#define PropertySheetA IsolationAwarePropertySheetA
#define PropertySheetW IsolationAwarePropertySheetW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define LIST_MODULES_DEFAULT 0x0  // This is the default one app would get without any flag.
#define LIST_MODULES_32BIT   0x01  // list 32bit modules in the target process.
#define LIST_MODULES_64BIT   0x02  // list all 64bit modules. 32bit exe will be stripped off.

// list all the modules
#define LIST_MODULES_ALL   (LIST_MODULES_32BIT | LIST_MODULES_64BIT)

//
// Give teams a choice of using a downlevel version of psapi.h for an OS versions.
// Teams can set C_DEFINES=$(C_DEFINES) -DPSAPI_VERSION=1 for downlevel psapi
// on windows 7 and higher.  We found that test code needs this capability.
//
#ifndef PSAPI_VERSION
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define PSAPI_VERSION 2
#else
#define PSAPI_VERSION 1
#endif
#endif

#if (PSAPI_VERSION > 1)
#define EnumProcesses               K32EnumProcesses
#define EnumProcessModules          K32EnumProcessModules
#define EnumProcessModulesEx        K32EnumProcessModulesEx
#define GetModuleBaseNameA          K32GetModuleBaseNameA
#define GetModuleBaseNameW          K32GetModuleBaseNameW
#define GetModuleFileNameExA        K32GetModuleFileNameExA
#define GetModuleFileNameExW        K32GetModuleFileNameExW
#define GetModuleInformation        K32GetModuleInformation
#define EmptyWorkingSet             K32EmptyWorkingSet
#define QueryWorkingSet             K32QueryWorkingSet
#define QueryWorkingSetEx           K32QueryWorkingSetEx
#define InitializeProcessForWsWatch K32InitializeProcessForWsWatch
#define GetWsChanges                K32GetWsChanges
#define GetWsChangesEx              K32GetWsChangesEx
#define GetMappedFileNameW          K32GetMappedFileNameW
#define GetMappedFileNameA          K32GetMappedFileNameA
#define EnumDeviceDrivers           K32EnumDeviceDrivers
#define GetDeviceDriverBaseNameA    K32GetDeviceDriverBaseNameA
#define GetDeviceDriverBaseNameW    K32GetDeviceDriverBaseNameW
#define GetDeviceDriverFileNameA    K32GetDeviceDriverFileNameA
#define GetDeviceDriverFileNameW    K32GetDeviceDriverFileNameW
#define GetProcessMemoryInfo        K32GetProcessMemoryInfo
#define GetPerformanceInfo          K32GetPerformanceInfo
#define EnumPageFilesW              K32EnumPageFilesW
#define EnumPageFilesA              K32EnumPageFilesA
#define GetProcessImageFileNameA    K32GetProcessImageFileNameA
#define GetProcessImageFileNameW    K32GetProcessImageFileNameW
#endif

BOOL
WINAPI
EnumProcesses (
    __out_bcount(cb) DWORD * lpidProcess,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    __in  HANDLE hProcess,
    __out_bcount(cb) HMODULE *lphModule,
    __in  DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModulesEx(
    __in  HANDLE hProcess,
    __out_bcount(cb)  HMODULE *lphModule,
    __in  DWORD cb,
    __out  LPDWORD lpcbNeeded,
    __in  DWORD dwFilterFlag
    );

DWORD
WINAPI
GetModuleBaseNameA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpBaseName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    __in HANDLE hProcess,
    __in HMODULE hModule,
    __out LPMODULEINFO lpmodinfo,
    __in DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    __in HANDLE hProcess
    );

//
// Working set information structures. All non-specified bits are reserved.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   // unnamed struct
#pragma warning(disable:4214)   // bit fields other than int

typedef union _PSAPI_WORKING_SET_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Protection : 5;
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Shared : 1;
        ULONG_PTR Reserved : 3;
#if defined(_WIN64)
        ULONG_PTR VirtualPage : 52;
#else
        ULONG_PTR VirtualPage : 20;
#endif
    };
} PSAPI_WORKING_SET_BLOCK, *PPSAPI_WORKING_SET_BLOCK;

typedef struct _PSAPI_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    PSAPI_WORKING_SET_BLOCK WorkingSetInfo[1];
} PSAPI_WORKING_SET_INFORMATION, *PPSAPI_WORKING_SET_INFORMATION;

typedef union _PSAPI_WORKING_SET_EX_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Valid : 1;        // The following fields are valid only if this bit is set
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Win32Protection : 11;
        ULONG_PTR Shared : 1;
        ULONG_PTR Node : 6;
        ULONG_PTR Locked : 1;
        ULONG_PTR LargePage : 1;
    };
} PSAPI_WORKING_SET_EX_BLOCK, *PPSAPI_WORKING_SET_EX_BLOCK;

typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION, *PPSAPI_WORKING_SET_EX_INFORMATION;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4214)
#pragma warning(default:4201)
#endif

BOOL
WINAPI
QueryWorkingSet(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
QueryWorkingSetEx(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    __in HANDLE hProcess
    );

typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

typedef struct _PSAPI_WS_WATCH_INFORMATION_EX {
    PSAPI_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;    // Reserved
} PSAPI_WS_WATCH_INFORMATION_EX, *PPSAPI_WS_WATCH_INFORMATION_EX;

BOOL
WINAPI
GetWsChanges(
    __in HANDLE hProcess,
    __out_bcount(cb) PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    __in DWORD cb
    );

BOOL
WINAPI
GetWsChangesEx(
    __in HANDLE hProcess,
    __out_bcount_part(*cb, *cb) PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    __inout PDWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers (
    __out_bcount(cb) LPVOID *lpImageBase,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMANCE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMANCE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPSTR lpImageFileName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPWSTR lpImageFileName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PshPack1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,1)
#else
#pragma pack(1)
#endif
#else
#pragma pack(1)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Qos.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the Quality of Service structures and types used
    by Winsock applications.

WARNING:

    This api is deprecated and will be removed in a future release of Windows.
    Please use the QOS2.h api.

Revision History:

--*/

#ifndef __QOS_H_
#define __QOS_H_

#pragma once

/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */

typedef ULONG   SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC               0x00000000  /* No data in this 
                                                         * direction */
#define SERVICETYPE_BESTEFFORT              0x00000001  /* Best Effort */
#define SERVICETYPE_CONTROLLEDLOAD          0x00000002  /* Controlled Load */
#define SERVICETYPE_GUARANTEED              0x00000003  /* Guaranteed */

#define SERVICETYPE_NETWORK_UNAVAILABLE     0x00000004  /* Used to notify 
                                                         * change to user */
#define SERVICETYPE_GENERAL_INFORMATION     0x00000005  /* corresponds to 
                                                         * "General Parameters"
                                                         * defined by IntServ */
#define SERVICETYPE_NOCHANGE                0x00000006  /* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one */
#define SERVICETYPE_NONCONFORMING           0x00000009  /* Non-Conforming Traffic */
#define SERVICETYPE_NETWORK_CONTROL         0x0000000A  /* Network Control traffic */
#define SERVICETYPE_QUALITATIVE             0x0000000D  /* Qualitative applications */ 



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT                  0x80010000
#define SERVICE_CONTROLLEDLOAD              0x80020000
#define SERVICE_GUARANTEED                  0x80040000
#define SERVICE_QUALITATIVE                 0x80200000
/* **************************** ***** ************************************ */



/*
 * Flags to control the usage of RSVP on this flow.
 */

/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
#define SERVICE_NO_TRAFFIC_CONTROL   0x81000000


/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */

#define SERVICE_NO_QOS_SIGNALING   0x40000000




/*
 *  Flow Specifications for each direction of data flow.
 */
typedef struct _flowspec
{
    ULONG       TokenRate;              /* In Bytes/sec */
    ULONG       TokenBucketSize;        /* In Bytes */
    ULONG       PeakBandwidth;          /* In Bytes/sec */
    ULONG       Latency;                /* In microseconds */
    ULONG       DelayVariation;         /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;             /* In Bytes */
    ULONG       MinimumPolicedSize;     /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
#define QOS_NOT_SPECIFIED     0xFFFFFFFF

/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
#define   POSITIVE_INFINITY_RATE     0xFFFFFFFE



/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;  /* the length of object buffer INCLUDING 
                            * this header */

} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
#define   QOS_GENERAL_ID_BASE                      2000

#define   QOS_OBJECT_END_OF_LIST                   (0x00000001 + QOS_GENERAL_ID_BASE) 
          /* QOS_End_of_list structure passed */
#define   QOS_OBJECT_SD_MODE                       (0x00000002 + QOS_GENERAL_ID_BASE) 
          /* QOS_ShapeDiscard structure passed */
#define   QOS_OBJECT_SHAPING_RATE	           (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define   QOS_OBJECT_DESTADDR                      (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */

typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW      0
#define TC_NONCONF_SHAPE       1
#define TC_NONCONF_DISCARD     2
#define TC_NONCONF_BORROW_PLUS 3 // Not supported currently


/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */

typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#endif  /* __QOS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\qosobjs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qosobjs.h

Abstract:

    This module contains QoS object definitions.

--*/

#pragma once

#ifdef __cplusplus
extern  "C" {
#endif


#define QOS_MAX_OBJECT_STRING_LENGTH    256


//
// QoS objects supported by traffic control
//
#define QOS_TRAFFIC_GENERAL_ID_BASE 4000

#define QOS_OBJECT_DS_CLASS                    (0x00000001 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_DS_CLASS structure passed */
#define QOS_OBJECT_TRAFFIC_CLASS               (0x00000002 + QOS_TRAFFIC_GENERAL_ID_BASE) 
          /* QOS_Traffic class structure passed */
#define   QOS_OBJECT_DIFFSERV                  (0x00000003 + QOS_TRAFFIC_GENERAL_ID_BASE)
          /* QOS_DIFFSERV Structure */
#define QOS_OBJECT_TCP_TRAFFIC                 (0x00000004 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_TCP_TRAFFIC structure */
#define QOS_OBJECT_FRIENDLY_NAME               (0x00000005 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_FRIENDLY_NAME structure */
#define QOS_OBJECT_STARTING_RATE               (0x00000006 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_STARTING_RATE structure */


//
// This structure is used to associate a friendly name with the flow
// 

typedef struct _QOS_FRIENDLY_NAME {
    QOS_OBJECT_HDR ObjectHdr;
    WCHAR          FriendlyName[QOS_MAX_OBJECT_STRING_LENGTH];
} QOS_FRIENDLY_NAME, *LPQOS_FRIENDLY_NAME;

//
// This structure may carry an 802.1 TrafficClass parameter which 
// has been provided to the host by a layer 2 network, for example, 
// in an 802.1 extended RSVP RESV message. If this object is obtained
// from the network, hosts will stamp the MAC headers of corresponding
// transmitted packets, with the value in the object. Otherwise, hosts
// may select a value based on the standard Intserv mapping of 
// ServiceType to 802.1 TrafficClass.
//
//

typedef struct _QOS_TRAFFIC_CLASS {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            TrafficClass;

} QOS_TRAFFIC_CLASS, *LPQOS_TRAFFIC_CLASS;

//
// This structure may carry an DSField parameter which  has been provided to 
// the host by a layer 3 network, for example, in an extended RSVP RESV message. 
// If this object is obtained from the network, hosts will stamp the DS Field on the
// IP header of transmitted packets, with the value in the object. Otherwise, hosts
// may select a value based on the standard Intserv mapping of ServiceType to DS Field 
//

typedef struct _QOS_DS_CLASS {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG          DSField;

} QOS_DS_CLASS, *LPQOS_DS_CLASS;


//
// This structure is used to create DiffServ Flows. This creates flows in the packet scheduler
// and allows it to classify to packets based on a particular DS field. This structure takes
// a variable length array of QOS_DIFFSERV_RULE, where each DS field is specified by a 
// QOS_DIFFSERV_RULE
//
typedef struct _QOS_DIFFSERV {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG          DSFieldCount;
    UCHAR          DiffservRule[1];
} QOS_DIFFSERV, *LPQOS_DIFFSERV;

//
// The rule for a Diffserv DS codepoint. 
//
typedef struct _QOS_DIFFSERV_RULE {
    UCHAR InboundDSField;
    UCHAR ConformingOutboundDSField;
    UCHAR NonConformingOutboundDSField;
    UCHAR ConformingUserPriority;
    UCHAR NonConformingUserPriority;
} QOS_DIFFSERV_RULE, *LPQOS_DIFFSERV_RULE;

// 
// This structure is passed to indicate that the IP Precedence and UserPriority mappings for the flow
// have to be set to the system defaults for TCP traffic. If this object is passed, 
// the ServiceType ==> DSField mapping, ServiceType ==> UserPriorityMapping, QOS_OBJECT_DS_CLASS
// and QOS_OBJECT_TRAFFIC_CLASS will be ignored.
//

typedef struct _QOS_TCP_TRAFFIC {
    QOS_OBJECT_HDR ObjectHdr;
} QOS_TCP_TRAFFIC, *LPQOS_TCP_TRAFFIC;


typedef struct _QOS_STARTING_RATE {
    QOS_OBJECT_HDR ObjectHdr;
    ULONG StartingTokenRate;  // In bytes per second
    ULONG RampingTime;        // In Milliseconds
} QOS_STARTING_RATE, *LPQOS_STARTING_RATE;
    

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\QosPol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qospol.h - QOS policy elements

Abstract:

    This module defines QOS policy elements.

Revision History:

--*/

#ifndef __QOSPOL_H_
#define __QOSPOL_H_

#pragma once

#define PE_TYPE_APPID       3       // policy element contains Application Identity

// Policy Location attribute carries sub application attributes
#define PE_ATTRIB_TYPE_POLICY_LOCATOR            1

#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN         1
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN       2
#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN_ENC     3
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN_ENC   4


// Credentials attribute carries the application identity
#define PE_ATTRIB_TYPE_CREDENTIAL        2

#define CREDENTIAL_SUB_TYPE_ASCII_ID     1
#define CREDENTIAL_SUB_TYPE_UNICODE_ID   2
#define CREDENTIAL_SUB_TYPE_KERBEROS_TKT 3
#define CREDENTIAL_SUB_TYPE_X509_V3_CERT 4
#define CREDENTIAL_SUB_TYPE_PGP_CERT     5


// Identity Policy Element attribute structure
typedef struct _IDPE_ATTR {

    USHORT  PeAttribLength;
    
    UCHAR   PeAttribType;            // Use the #defines from above
    
    UCHAR   PeAttribSubType;        // Use the #defines from above
    
    UCHAR   PeAttribValue[4];
    
} IDPE_ATTR, *LPIDPE_ATTR;

#define IDPE_ATTR_HDR_LEN    (sizeof(USHORT)+sizeof(UCHAR)+sizeof(UCHAR))

#define RSVP_BYTE_MULTIPLE(x)       (((x+3) / 4) * 4)


#endif // __QOSPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\qmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for qmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qmgr_h__
#define __qmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBackgroundCopyJob1_FWD_DEFINED__
#define __IBackgroundCopyJob1_FWD_DEFINED__
typedef interface IBackgroundCopyJob1 IBackgroundCopyJob1;
#endif 	/* __IBackgroundCopyJob1_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_FWD_DEFINED__
#define __IEnumBackgroundCopyJobs1_FWD_DEFINED__
typedef interface IEnumBackgroundCopyJobs1 IEnumBackgroundCopyJobs1;
#endif 	/* __IEnumBackgroundCopyJobs1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyGroup_FWD_DEFINED__
#define __IBackgroundCopyGroup_FWD_DEFINED__
typedef interface IBackgroundCopyGroup IBackgroundCopyGroup;
#endif 	/* __IBackgroundCopyGroup_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_FWD_DEFINED__
#define __IEnumBackgroundCopyGroups_FWD_DEFINED__
typedef interface IEnumBackgroundCopyGroups IEnumBackgroundCopyGroups;
#endif 	/* __IEnumBackgroundCopyGroups_FWD_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_FWD_DEFINED__
#define __IBackgroundCopyCallback1_FWD_DEFINED__
typedef interface IBackgroundCopyCallback1 IBackgroundCopyCallback1;
#endif 	/* __IBackgroundCopyCallback1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_FWD_DEFINED__
#define __IBackgroundCopyQMgr_FWD_DEFINED__
typedef interface IBackgroundCopyQMgr IBackgroundCopyQMgr;
#endif 	/* __IBackgroundCopyQMgr_FWD_DEFINED__ */


#ifndef __BackgroundCopyQMgr_FWD_DEFINED__
#define __BackgroundCopyQMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackgroundCopyQMgr BackgroundCopyQMgr;
#else
typedef struct BackgroundCopyQMgr BackgroundCopyQMgr;
#endif /* __cplusplus */

#endif 	/* __BackgroundCopyQMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_qmgr_0000_0000 */
/* [local] */ 

// Background Copy QMgr Public Interface
#define  QM_NOTIFY_FILE_DONE         0x00000001
#define  QM_NOTIFY_JOB_DONE          0x00000002
#define  QM_NOTIFY_GROUP_DONE        0x00000004
#define  QM_NOTIFY_DISABLE_NOTIFY    0x00000040
#define  QM_NOTIFY_USE_PROGRESSEX    0x00000080
#define  QM_STATUS_FILE_COMPLETE     0x00000001
#define  QM_STATUS_FILE_INCOMPLETE   0x00000002
#define  QM_STATUS_JOB_COMPLETE      0x00000004
#define  QM_STATUS_JOB_INCOMPLETE    0x00000008
#define  QM_STATUS_JOB_ERROR         0x00000010
#define  QM_STATUS_JOB_FOREGROUND    0x00000020
#define  QM_STATUS_GROUP_COMPLETE    0x00000040
#define  QM_STATUS_GROUP_INCOMPLETE  0x00000080
#define  QM_STATUS_GROUP_SUSPENDED   0x00000100
#define  QM_STATUS_GROUP_ERROR       0x00000200
#define  QM_STATUS_GROUP_FOREGROUND  0x00000400
#define  QM_PROTOCOL_HTTP            1
#define  QM_PROTOCOL_FTP             2
#define  QM_PROTOCOL_SMB             3
#define  QM_PROTOCOL_CUSTOM          4
#define  QM_PROGRESS_PERCENT_DONE    1
#define  QM_PROGRESS_TIME_DONE       2
#define  QM_PROGRESS_SIZE_DONE       3
#define  QM_E_INVALID_STATE          0x81001001
#define  QM_E_SERVICE_UNAVAILABLE    0x81001002
#define  QM_E_DOWNLOADER_UNAVAILABLE 0x81001003
#define  QM_E_ITEM_NOT_FOUND         0x81001004


extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_s_ifspec;

#ifndef __IBackgroundCopyJob1_INTERFACE_DEFINED__
#define __IBackgroundCopyJob1_INTERFACE_DEFINED__

/* interface IBackgroundCopyJob1 */
/* [object][helpstring][uuid] */ 

typedef struct _FILESETINFO
    {
    BSTR bstrRemoteFile;
    BSTR bstrLocalFile;
    DWORD dwSizeHint;
    } 	FILESETINFO;


EXTERN_C const IID IID_IBackgroundCopyJob1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f5553c-2031-4629-bb18-2645a6970947")
    IBackgroundCopyJob1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CancelJob( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiles( 
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [out] */ __RPC__out DWORD *pdwFileCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_JobID( 
            /* [out] */ __RPC__out GUID *pguidJobID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyJob1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelJob )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiles )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileCount )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwFileCount);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_JobID )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out GUID *pguidJobID);
        
        END_INTERFACE
    } IBackgroundCopyJob1Vtbl;

    interface IBackgroundCopyJob1
    {
        CONST_VTBL struct IBackgroundCopyJob1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyJob1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyJob1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyJob1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyJob1_CancelJob(This)	\
    ( (This)->lpVtbl -> CancelJob(This) ) 

#define IBackgroundCopyJob1_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyJob1_GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries) ) 

#define IBackgroundCopyJob1_AddFiles(This,cFileCount,ppFileSet)	\
    ( (This)->lpVtbl -> AddFiles(This,cFileCount,ppFileSet) ) 

#define IBackgroundCopyJob1_GetFile(This,cFileIndex,pFileInfo)	\
    ( (This)->lpVtbl -> GetFile(This,cFileIndex,pFileInfo) ) 

#define IBackgroundCopyJob1_GetFileCount(This,pdwFileCount)	\
    ( (This)->lpVtbl -> GetFileCount(This,pdwFileCount) ) 

#define IBackgroundCopyJob1_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyJob1_get_JobID(This,pguidJobID)	\
    ( (This)->lpVtbl -> get_JobID(This,pguidJobID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyJob1_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyJobs1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyJobs1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8baeba9d-8f1c-42c4-b82c-09ae79980d25")
    IEnumBackgroundCopyJobs1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyJobs1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyJobs1Vtbl;

    interface IEnumBackgroundCopyJobs1
    {
        CONST_VTBL struct IEnumBackgroundCopyJobs1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyJobs1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyJobs1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyJobs1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyJobs1_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyJobs1_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyJobs1_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyJobs1_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyJobs1_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyGroup_INTERFACE_DEFINED__
#define __IBackgroundCopyGroup_INTERFACE_DEFINED__

/* interface IBackgroundCopyGroup */
/* [object][helpstring][uuid] */ 

typedef 
enum GROUPPROP
    {	GROUPPROP_PRIORITY	= 0,
	GROUPPROP_REMOTEUSERID	= 1,
	GROUPPROP_REMOTEUSERPWD	= 2,
	GROUPPROP_LOCALUSERID	= 3,
	GROUPPROP_LOCALUSERPWD	= 4,
	GROUPPROP_PROTOCOLFLAGS	= 5,
	GROUPPROP_NOTIFYFLAGS	= 6,
	GROUPPROP_NOTIFYCLSID	= 7,
	GROUPPROP_PROGRESSSIZE	= 8,
	GROUPPROP_PROGRESSPERCENT	= 9,
	GROUPPROP_PROGRESSTIME	= 10,
	GROUPPROP_DISPLAYNAME	= 11,
	GROUPPROP_DESCRIPTION	= 12
    } 	GROUPPROP;


EXTERN_C const IID IID_IBackgroundCopyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ded80a7-53ea-424f-8a04-17fea9adc4f5")
    IBackgroundCopyGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GroupID( 
            /* [out] */ __RPC__out GUID *pguidGroupID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateJob( 
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumJobs( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryNewJobInterface( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotificationPointer( 
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProp )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_GroupID )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out GUID *pguidGroupID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateJob )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *EnumJobs )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNewJobInterface )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotificationPointer )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        END_INTERFACE
    } IBackgroundCopyGroupVtbl;

    interface IBackgroundCopyGroup
    {
        CONST_VTBL struct IBackgroundCopyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyGroup_GetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> GetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_SetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> SetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyGroup_GetStatus(This,pdwStatus,pdwJobIndex)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwJobIndex) ) 

#define IBackgroundCopyGroup_GetJob(This,jobID,ppJob)	\
    ( (This)->lpVtbl -> GetJob(This,jobID,ppJob) ) 

#define IBackgroundCopyGroup_SuspendGroup(This)	\
    ( (This)->lpVtbl -> SuspendGroup(This) ) 

#define IBackgroundCopyGroup_ResumeGroup(This)	\
    ( (This)->lpVtbl -> ResumeGroup(This) ) 

#define IBackgroundCopyGroup_CancelGroup(This)	\
    ( (This)->lpVtbl -> CancelGroup(This) ) 

#define IBackgroundCopyGroup_get_Size(This,pdwSize)	\
    ( (This)->lpVtbl -> get_Size(This,pdwSize) ) 

#define IBackgroundCopyGroup_get_GroupID(This,pguidGroupID)	\
    ( (This)->lpVtbl -> get_GroupID(This,pguidGroupID) ) 

#define IBackgroundCopyGroup_CreateJob(This,guidJobID,ppJob)	\
    ( (This)->lpVtbl -> CreateJob(This,guidJobID,ppJob) ) 

#define IBackgroundCopyGroup_EnumJobs(This,dwFlags,ppEnumJobs)	\
    ( (This)->lpVtbl -> EnumJobs(This,dwFlags,ppEnumJobs) ) 

#define IBackgroundCopyGroup_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyGroup_QueryNewJobInterface(This,iid,pUnk)	\
    ( (This)->lpVtbl -> QueryNewJobInterface(This,iid,pUnk) ) 

#define IBackgroundCopyGroup_SetNotificationPointer(This,iid,pUnk)	\
    ( (This)->lpVtbl -> SetNotificationPointer(This,iid,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_InternalSetProp_Proxy( 
    __RPC__in IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);


void __RPC_STUB IBackgroundCopyGroup_InternalSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyGroups */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d993e603-4aa4-47c5-8665-c20d39c2ba4f")
    IEnumBackgroundCopyGroups : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyGroupsVtbl;

    interface IEnumBackgroundCopyGroups
    {
        CONST_VTBL struct IEnumBackgroundCopyGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyGroups_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyGroups_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyGroups_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyGroups_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyGroups_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyGroups_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyGroups_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyGroups_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_INTERFACE_DEFINED__
#define __IBackgroundCopyCallback1_INTERFACE_DEFINED__

/* interface IBackgroundCopyCallback1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyCallback1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("084f6593-3800-4e08-9b59-99fa59addf82")
    IBackgroundCopyCallback1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgressEx( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyCallback1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyCallback1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyCallback1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgressEx )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte);
        
        END_INTERFACE
    } IBackgroundCopyCallback1Vtbl;

    interface IBackgroundCopyCallback1
    {
        CONST_VTBL struct IBackgroundCopyCallback1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyCallback1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyCallback1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyCallback1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyCallback1_OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult)	\
    ( (This)->lpVtbl -> OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult) ) 

#define IBackgroundCopyCallback1_OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue)	\
    ( (This)->lpVtbl -> OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue) ) 

#define IBackgroundCopyCallback1_OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte)	\
    ( (This)->lpVtbl -> OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyCallback1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_INTERFACE_DEFINED__
#define __IBackgroundCopyQMgr_INTERFACE_DEFINED__

/* interface IBackgroundCopyQMgr */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyQMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16f41c69-09f5-41d2-8cd8-3c08c47bc8a8")
    IBackgroundCopyQMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateGroup( 
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGroups( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyQMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyQMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyQMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGroup )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGroups )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups);
        
        END_INTERFACE
    } IBackgroundCopyQMgrVtbl;

    interface IBackgroundCopyQMgr
    {
        CONST_VTBL struct IBackgroundCopyQMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyQMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyQMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyQMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyQMgr_CreateGroup(This,guidGroupID,ppGroup)	\
    ( (This)->lpVtbl -> CreateGroup(This,guidGroupID,ppGroup) ) 

#define IBackgroundCopyQMgr_GetGroup(This,groupID,ppGroup)	\
    ( (This)->lpVtbl -> GetGroup(This,groupID,ppGroup) ) 

#define IBackgroundCopyQMgr_EnumGroups(This,dwFlags,ppEnumGroups)	\
    ( (This)->lpVtbl -> EnumGroups(This,dwFlags,ppEnumGroups) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyQMgr_INTERFACE_DEFINED__ */



#ifndef __BackgroundCopyQMgr_LIBRARY_DEFINED__
#define __BackgroundCopyQMgr_LIBRARY_DEFINED__

/* library BackgroundCopyQMgr */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_BackgroundCopyQMgr;

EXTERN_C const CLSID CLSID_BackgroundCopyQMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("69AD4AEE-51BE-439b-A92C-86AE490E8B30")
BackgroundCopyQMgr;
#endif
#endif /* __BackgroundCopyQMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Stub( 
    __RPC__in IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\PshPack8.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,8)
#else
#pragma pack(8)
#endif
#else
#pragma pack(8)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RasDlg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasdlg.h

Abstract:

    Remote Access Common Dialog APIs

    These APIs live in RASDLG.DLL.

    The APIs in this header are added in Windows NT SUR and are not available
    in prior Windows NT or Windows 95 releases.
    
--*/

#ifndef _RASDLG_H_
#define _RASDLG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <ras.h>


/* RasPhonebookDlg API callback.
*/
typedef VOID (WINAPI* RASPBDLGFUNCW)( ULONG_PTR, DWORD, LPWSTR, LPVOID );
typedef VOID (WINAPI* RASPBDLGFUNCA)( ULONG_PTR, DWORD, LPSTR, LPVOID );

#define RASPBDEVENT_AddEntry    1
#define RASPBDEVENT_EditEntry   2
#define RASPBDEVENT_RemoveEntry 3
#define RASPBDEVENT_DialEntry   4
#define RASPBDEVENT_EditGlobals 5
#define RASPBDEVENT_NoUser      6
#define RASPBDEVENT_NoUserEdit  7

#define  RASNOUSER_SmartCard    0x00000001

/* Defines the information passed in the 4th argument of RASPBDLGFUNC on
** "NoUser" and "NoUserEdit" events.  Usage shown is for "NoUser".  For
** "NoUserEdit", the timeout is ignored and the three strings are INs.
*/
#define RASNOUSERW struct tagRASNOUSERW
RASNOUSERW
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT WCHAR szUserName[ UNLEN + 1 ];
    OUT WCHAR szPassword[ PWLEN + 1 ];
    OUT WCHAR szDomain[ DNLEN + 1 ];
};

#define RASNOUSERA struct tagRASNOUSERA
RASNOUSERA
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT CHAR  szUserName[ UNLEN + 1 ];
    OUT CHAR  szPassword[ PWLEN + 1 ];
    OUT CHAR  szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASNOUSER RASNOUSERW
#else
#define RASNOUSER RASNOUSERA
#endif

#define LPRASNOUSERW RASNOUSERW*
#define LPRASNOUSERA RASNOUSERA*
#define LPRASNOUSER  RASNOUSER*


/* RasPhonebookDlg API parameters.
*/
#define RASPBDFLAG_PositionDlg      0x00000001
#define RASPBDFLAG_ForceCloseOnDial 0x00000002
#define RASPBDFLAG_NoUser           0x00000010
#define RASPBDFLAG_UpdateDefaults   0x80000000

#define RASPBDLGW struct tagRASPBDLGW
RASPBDLGW
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCW pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#define RASPBDLGA struct tagRASPBDLGA
RASPBDLGA
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCA pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#ifdef UNICODE
#define RASPBDLG     RASPBDLGW
#define RASPBDLGFUNC RASPBDLGFUNCW
#else
#define RASPBDLG     RASPBDLGA
#define RASPBDLGFUNC RASPBDLGFUNCA
#endif

#define LPRASPBDLGW RASPBDLGW*
#define LPRASPBDLGA RASPBDLGA*
#define LPRASPBDLG  RASPBDLG*


/* RasEntryDlg API parameters.
*/
#define RASEDFLAG_PositionDlg    	0x00000001
#define RASEDFLAG_NewEntry       	0x00000002
#if (WINVER < 0x600)
#define RASEDFLAG_CloneEntry     	0x00000004
#endif // (WINVER < 0x600)
#define RASEDFLAG_NoRename       	0x00000008
#define RASEDFLAG_ShellOwned     	0x40000000
#define RASEDFLAG_NewPhoneEntry  	0x00000010
#define RASEDFLAG_NewTunnelEntry 	0x00000020
#if (WINVER < 0x600)
#define RASEDFLAG_NewDirectEntry 	0x00000040
#endif // (WINVER < 0x600)
#define RASEDFLAG_NewBroadbandEntry  	0x00000080
#define RASEDFLAG_InternetEntry      	0x00000100
#define RASEDFLAG_NAT                	0x00000200
#if (WINVER >= 0x600)
#define RASEDFLAG_IncomingConnection 	0x00000400
#endif

#define RASENTRYDLGW struct tagRASENTRYDLGW
RASENTRYDLGW
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT WCHAR szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define RASENTRYDLGA struct tagRASENTRYDLGA
RASENTRYDLGA
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT CHAR  szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#ifdef UNICODE
#define RASENTRYDLG RASENTRYDLGW
#else
#define RASENTRYDLG RASENTRYDLGA
#endif

#define LPRASENTRYDLGW RASENTRYDLGW*
#define LPRASENTRYDLGA RASENTRYDLGA*
#define LPRASENTRYDLG  RASENTRYDLG*


/* RasDialDlg API parameters.
*/
#define RASDDFLAG_PositionDlg 0x00000001
#define RASDDFLAG_NoPrompt    0x00000002
#define RASDDFLAG_LinkFailure 0x80000000

#define RASDIALDLG struct tagRASDIALDLG
RASDIALDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    IN  DWORD dwSubEntry;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define LPRASDIALDLG RASDIALDLG*


#if (WINVER >= 0x500)
typedef BOOL (WINAPI *RasCustomDialDlgFn) (
                            HINSTANCE hInstDll,
                            DWORD dwFlags,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPWSTR lpszPhoneNumber,
                            LPRASDIALDLG lpInfo,
                            PVOID pvInfo
                            );

typedef BOOL (WINAPI *RasCustomEntryDlgFn) (
                            HINSTANCE hInstDll,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPRASENTRYDLG lpInfo,
                            DWORD  dwFlags
                            );


#endif


/* RAS common dialog API prototypes.
*/
BOOL APIENTRY RasPhonebookDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, LPRASPBDLGA lpInfo );

BOOL APIENTRY RasPhonebookDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, LPRASPBDLGW lpInfo );

BOOL APIENTRY RasEntryDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, LPRASENTRYDLGA lpInfo );

BOOL APIENTRY RasEntryDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, LPRASENTRYDLGW lpInfo );

BOOL APIENTRY RasDialDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, __in_opt LPSTR lpszPhoneNumber,
    __inout LPRASDIALDLG lpInfo );

BOOL APIENTRY RasDialDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, __in_opt LPWSTR lpszPhoneNumber,
    __inout LPRASDIALDLG lpInfo );


#ifdef UNICODE
#define RasPhonebookDlg RasPhonebookDlgW
#define RasEntryDlg     RasEntryDlgW
#define RasDialDlg      RasDialDlgW
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgW
#endif
#else
#define RasPhonebookDlg RasPhonebookDlgA
#define RasEntryDlg     RasEntryDlgA
#define RasDialDlg      RasDialDlgA
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgA
#endif
#endif



#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RASDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RassHost.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasshost.h

Abstract:

    This header defines the interface between third party security
    DLLs and the RAS server.
    
--*/

#ifndef _RASSHOST_
#define _RASSHOST_

#if _MSC_VER > 1000
#pragma once
#endif

#include <mprapi.h>

typedef HANDLE  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;

    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h

    CHAR  UserName[UNLEN+1];        // Should always contain username if
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[MAX_DEVICE_NAME+1];


}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// The following entrypoints should be loaded by calling GetProcAddress from
// RasMan.lib
//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************
#pragma once

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingEnableW(HWND hwndParent, LPCWSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(__in_opt LPCSTR pszUsername, __in_opt LPCSTR pszURL, __in_opt LPCSTR pszRatingInfo,
    __in_bcount_opt(cbData) LPBYTE pData, DWORD cbData, __out_opt void **ppRatingDetails);
STDAPI RatingCheckUserAccessW(__in_opt LPCWSTR pszUsername, __in_opt LPCWSTR pszURL, __in_opt LPCWSTR pszRatingInfo,
    __in_bcount_opt(cbData) LPBYTE pData, DWORD cbData, __out_opt void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, __in_opt LPCSTR pszUsername, LPCSTR pszContentDescription, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialogW(HWND hDlg, __in_opt LPCWSTR pszUsername, LPCWSTR pszContentDescription, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, __in_opt LPCSTR pszUsername, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2W(HWND hDlg, __in_opt LPCWSTR pszUsername, __out void *pRatingDetails);
STDAPI RatingFreeDetails(__in_opt void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData,
    void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails),
    __out_opt HANDLE *phRatingObtainQuery);
STDAPI RatingObtainQueryW(LPCWSTR pszTargetUrl, DWORD dwUserData,
    void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCWSTR pszRating, void *lpvRatingDetails),
    __out_opt HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
STDAPI RatingSetupUIW(HWND hDlg, LPCWSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingAddToApprovedSites(HWND hDlg,
                                DWORD cbPasswordBlob,
                                __inout_bcount(cbPasswordBlob) BYTE *pbPasswordBlob,
                                __in LPCWSTR lpszUrl,
                                BOOL fAlwaysNever,
                                BOOL fSitePage,
                                BOOL fApprovedSitesEnforced);

STDAPI RatingClickedOnPRFInternal(HWND hWndOwner, HINSTANCE /*p_hInstance*/, __in LPSTR lpszFileName, int nShow);
STDAPI RatingClickedOnRATInternal(HWND hWndOwner, HINSTANCE /*p_hInstance*/, __in LPSTR lpszFileName, int nShow);

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
__inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, szSup, &cbSize) == ERROR_SUCCESS);
}

#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\qnetwork.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: QuartzNetTypeLib */

#ifndef _QuartzNetTypeLib_H_
#define _QuartzNetTypeLib_H_

DEFINE_GUID(LIBID_QuartzNetTypeLib,0x56A868B1L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IAMNetShowConfig,0xFA2AA8F1L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowConfig */
#undef INTERFACE
#define INTERFACE IAMNetShowConfig

DECLARE_INTERFACE_(IAMNetShowConfig, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowConfig methods */
    STDMETHOD(get_BufferingTime)(THIS_ double FAR* pBufferingTime) PURE;
    STDMETHOD(put_BufferingTime)(THIS_ double BufferingTime) PURE;
    STDMETHOD(get_UseFixedUDPPort)(THIS_ VARIANT_BOOL FAR* pUseFixedUDPPort) PURE;
    STDMETHOD(put_UseFixedUDPPort)(THIS_ VARIANT_BOOL UseFixedUDPPort) PURE;
    STDMETHOD(get_FixedUDPPort)(THIS_ long FAR* pFixedUDPPort) PURE;
    STDMETHOD(put_FixedUDPPort)(THIS_ long FixedUDPPort) PURE;
    STDMETHOD(get_UseHTTPProxy)(THIS_ VARIANT_BOOL FAR* pUseHTTPProxy) PURE;
    STDMETHOD(put_UseHTTPProxy)(THIS_ VARIANT_BOOL UseHTTPProxy) PURE;
    STDMETHOD(get_EnableAutoProxy)(THIS_ VARIANT_BOOL FAR* pEnableAutoProxy) PURE;
    STDMETHOD(put_EnableAutoProxy)(THIS_ VARIANT_BOOL EnableAutoProxy) PURE;
    STDMETHOD(get_HTTPProxyHost)(THIS_ BSTR FAR* pbstrHTTPProxyHost) PURE;
    STDMETHOD(put_HTTPProxyHost)(THIS_ BSTR bstrHTTPProxyHost) PURE;
    STDMETHOD(get_HTTPProxyPort)(THIS_ long FAR* pHTTPProxyPort) PURE;
    STDMETHOD(put_HTTPProxyPort)(THIS_ long HTTPProxyPort) PURE;
    STDMETHOD(get_EnableMulticast)(THIS_ VARIANT_BOOL FAR* pEnableMulticast) PURE;
    STDMETHOD(put_EnableMulticast)(THIS_ VARIANT_BOOL EnableMulticast) PURE;
    STDMETHOD(get_EnableUDP)(THIS_ VARIANT_BOOL FAR* pEnableUDP) PURE;
    STDMETHOD(put_EnableUDP)(THIS_ VARIANT_BOOL EnableUDP) PURE;
    STDMETHOD(get_EnableTCP)(THIS_ VARIANT_BOOL FAR* pEnableTCP) PURE;
    STDMETHOD(put_EnableTCP)(THIS_ VARIANT_BOOL EnableTCP) PURE;
    STDMETHOD(get_EnableHTTP)(THIS_ VARIANT_BOOL FAR* pEnableHTTP) PURE;
    STDMETHOD(put_EnableHTTP)(THIS_ VARIANT_BOOL EnableHTTP) PURE;
};

DEFINE_GUID(IID_IAMChannelInfo,0xFA2AA8F2L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMChannelInfo */
#undef INTERFACE
#define INTERFACE IAMChannelInfo

DECLARE_INTERFACE_(IAMChannelInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMChannelInfo methods */
    STDMETHOD(get_ChannelName)(THIS_ BSTR FAR* pbstrChannelName) PURE;
    STDMETHOD(get_ChannelDescription)(THIS_ BSTR FAR* pbstrChannelDescription) PURE;
    STDMETHOD(get_ChannelURL)(THIS_ BSTR FAR* pbstrChannelURL) PURE;
    STDMETHOD(get_ContactAddress)(THIS_ BSTR FAR* pbstrContactAddress) PURE;
    STDMETHOD(get_ContactPhone)(THIS_ BSTR FAR* pbstrContactPhone) PURE;
    STDMETHOD(get_ContactEmail)(THIS_ BSTR FAR* pbstrContactEmail) PURE;
};

DEFINE_GUID(IID_IAMNetworkStatus,0xFA2AA8F3L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetworkStatus */
#undef INTERFACE
#define INTERFACE IAMNetworkStatus

DECLARE_INTERFACE_(IAMNetworkStatus, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetworkStatus methods */
    STDMETHOD(get_ReceivedPackets)(THIS_ long FAR* pReceivedPackets) PURE;
    STDMETHOD(get_RecoveredPackets)(THIS_ long FAR* pRecoveredPackets) PURE;
    STDMETHOD(get_LostPackets)(THIS_ long FAR* pLostPackets) PURE;
    STDMETHOD(get_ReceptionQuality)(THIS_ long FAR* pReceptionQuality) PURE;
    STDMETHOD(get_BufferingCount)(THIS_ long FAR* pBufferingCount) PURE;
    STDMETHOD(get_IsBroadcast)(THIS_ VARIANT_BOOL FAR* pIsBroadcast) PURE;
    STDMETHOD(get_BufferingProgress)(THIS_ long FAR* pBufferingProgress) PURE;
};

typedef enum {
    AM_EXSEEK_CANSEEK = 1,
    AM_EXSEEK_CANSCAN = 2,
    AM_EXSEEK_MARKERSEEK = 4,
    AM_EXSEEK_SCANWITHOUTCLOCK = 8,
    AM_EXSEEK_NOSTANDARDREPAINT = 16,
    AM_EXSEEK_BUFFERING = 32,
    AM_EXSEEK_SENDS_VIDEOFRAMEREADY = 64
} AMExtendedSeekingCapabilities;

DEFINE_GUID(IID_IAMExtendedSeeking,0xFA2AA8F9L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedSeeking */
#undef INTERFACE
#define INTERFACE IAMExtendedSeeking

DECLARE_INTERFACE_(IAMExtendedSeeking, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedSeeking methods */
    STDMETHOD(get_ExSeekCapabilities)(THIS_ long FAR* pExCapabilities) PURE;
    STDMETHOD(get_MarkerCount)(THIS_ long FAR* pMarkerCount) PURE;
    STDMETHOD(get_CurrentMarker)(THIS_ long FAR* pCurrentMarker) PURE;
    STDMETHOD(GetMarkerTime)(THIS_ long MarkerNum, double FAR* pMarkerTime) PURE;
    STDMETHOD(GetMarkerName)(THIS_ long MarkerNum, BSTR FAR* pbstrMarkerName) PURE;
    STDMETHOD(put_PlaybackSpeed)(THIS_ double Speed) PURE;
    STDMETHOD(get_PlaybackSpeed)(THIS_ double FAR* pSpeed) PURE;
};

DEFINE_GUID(IID_IAMNetShowExProps,0xFA2AA8F5L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowExProps */
#undef INTERFACE
#define INTERFACE IAMNetShowExProps

DECLARE_INTERFACE_(IAMNetShowExProps, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowExProps methods */
    STDMETHOD(get_SourceProtocol)(THIS_ long FAR* pSourceProtocol) PURE;
    STDMETHOD(get_Bandwidth)(THIS_ long FAR* pBandwidth) PURE;
    STDMETHOD(get_ErrorCorrection)(THIS_ BSTR FAR* pbstrErrorCorrection) PURE;
    STDMETHOD(get_CodecCount)(THIS_ long FAR* pCodecCount) PURE;
    STDMETHOD(GetCodecInstalled)(THIS_ long CodecNum, VARIANT_BOOL FAR* pCodecInstalled) PURE;
    STDMETHOD(GetCodecDescription)(THIS_ long CodecNum, BSTR FAR* pbstrCodecDescription) PURE;
    STDMETHOD(GetCodecURL)(THIS_ long CodecNum, BSTR FAR* pbstrCodecURL) PURE;
    STDMETHOD(get_CreationDate)(THIS_ DATE FAR* pCreationDate) PURE;
    STDMETHOD(get_SourceLink)(THIS_ BSTR FAR* pbstrSourceLink) PURE;
};

DEFINE_GUID(IID_IAMExtendedErrorInfo,0xFA2AA8F6L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedErrorInfo */
#undef INTERFACE
#define INTERFACE IAMExtendedErrorInfo

DECLARE_INTERFACE_(IAMExtendedErrorInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedErrorInfo methods */
    STDMETHOD(get_HasError)(THIS_ VARIANT_BOOL FAR* pHasError) PURE;
    STDMETHOD(get_ErrorDescription)(THIS_ BSTR FAR* pbstrErrorDescription) PURE;
    STDMETHOD(get_ErrorCode)(THIS_ long FAR* pErrorCode) PURE;
};

DEFINE_GUID(IID_IAMMediaContent,0xFA2AA8F4L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMMediaContent */
#undef INTERFACE
#define INTERFACE IAMMediaContent

DECLARE_INTERFACE_(IAMMediaContent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent methods */
    STDMETHOD(get_AuthorName)(THIS_ BSTR FAR* pbstrAuthorName) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* pbstrTitle) PURE;
    STDMETHOD(get_Rating)(THIS_ BSTR FAR* pbstrRating) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_Copyright)(THIS_ BSTR FAR* pbstrCopyright) PURE;
    STDMETHOD(get_BaseURL)(THIS_ BSTR FAR* pbstrBaseURL) PURE;
    STDMETHOD(get_LogoURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_LogoIconURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_WatermarkURL)(THIS_ BSTR FAR* pbstrWatermarkURL) PURE;
    STDMETHOD(get_MoreInfoURL)(THIS_ BSTR FAR* pbstrMoreInfoURL) PURE;
    STDMETHOD(get_MoreInfoBannerImage)(THIS_ BSTR FAR* pbstrMoreInfoBannerImage) PURE;
    STDMETHOD(get_MoreInfoBannerURL)(THIS_ BSTR FAR* pbstrMoreInfoBannerURL) PURE;
    STDMETHOD(get_MoreInfoText)(THIS_ BSTR FAR* pbstrMoreInfoText) PURE;
};

DEFINE_GUID(IID_IAMMediaContent2,0xCE8F78C1L,0x74D9,0x11D2,0xB0,0x9D,0x00,0xA0,0xC9,0xA8,0x11,0x17);

/* Definition of interface: IAMMediaContent2 */
#undef INTERFACE
#define INTERFACE IAMMediaContent2

DECLARE_INTERFACE_(IAMMediaContent2, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent2 methods */
    STDMETHOD(get_MediaParameter)(THIS_ long EntryNum, BSTR bstrName, BSTR FAR* pbstrValue) PURE;
    STDMETHOD(get_MediaParameterName)(THIS_ long EntryNum, long Index, BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_PlaylistCount)(THIS_ long FAR* pNumberEntries) PURE;
};

DEFINE_GUID(IID_IAMNetShowPreroll,0xAAE7E4E2L,0x6388,0x11D1,0x8D,0x93,0x00,0x60,0x97,0xC9,0xA2,0xB2);

/* Definition of interface: IAMNetShowPreroll */
#undef INTERFACE
#define INTERFACE IAMNetShowPreroll

DECLARE_INTERFACE_(IAMNetShowPreroll, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowPreroll methods */
    STDMETHOD(put_Preroll)(THIS_ VARIANT_BOOL fPreroll) PURE;
    STDMETHOD(get_Preroll)(THIS_ VARIANT_BOOL FAR* pfPreroll) PURE;
};

DEFINE_GUID(IID_IDShowPlugin,0x4746B7C8L,0x700E,0x11D1,0xBE,0xCC,0x00,0xC0,0x4F,0xB6,0xE9,0x37);

/* Definition of interface: IDShowPlugin */
#undef INTERFACE
#define INTERFACE IDShowPlugin

DECLARE_INTERFACE_(IDShowPlugin, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDShowPlugin methods */
    STDMETHOD(get_URL)(THIS_ BSTR FAR* pURL) PURE;
    STDMETHOD(get_UserAgent)(THIS_ BSTR FAR* pUserAgent) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Qossp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the type of objects that can go into the 
    ProviderSpecific buffer in the QOS structure.

Revision History:

--*/

#ifndef __QOSSP_H_
#define __QOSSP_H_

#pragma once

/*
 * Definition of object Types
 *
 *
 * define the values for ObjectType above - RSVP Objects ids start at an 
 * offset from zero to allow for ATM objects that might be defined in the 
 * lower number range.
 */
#define   RSVP_OBJECT_ID_BASE         1000
#define   RSVP_OBJECT_STATUS_INFO     (0x00000000 + RSVP_OBJECT_ID_BASE)
          /* RSVP_STATUS_INFO structure passed */
#define   RSVP_OBJECT_RESERVE_INFO    (0x00000001 + RSVP_OBJECT_ID_BASE)
          /* RSVP_RESERVE_INFO structure passed */
#define   RSVP_OBJECT_ADSPEC          (0x00000002 + RSVP_OBJECT_ID_BASE)
          /* RSVP_ADSPEC structure passed */
#define   RSVP_OBJECT_POLICY_INFO     (0x00000003 + RSVP_OBJECT_ID_BASE)
          /* RSVP POLICY ELEMENT(S) retrieved */
#define   RSVP_OBJECT_FILTERSPEC_LIST (0x00000004 + RSVP_OBJECT_ID_BASE)
          /* RSVP SENDER LIST returned */


/* 
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef union _IN_ADDR_IPV4 {

    ULONG  Addr;
    UCHAR  AddrBytes[4];

} IN_ADDR_IPV4, *LPIN_ADDR_IPV4;

/*
 * IPV6 addressing for RSVP FILTERSPECS
 */
typedef struct _IN_ADDR_IPV6 {

    UCHAR  Addr[16];               //IPV6 address

} IN_ADDR_IPV6, *LPIN_ADDR_IPV6;

typedef const IN_ADDR_IPV6  *LPCIN_ADDR_IPV6;

/*
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef struct _RSVP_FILTERSPEC_V4 {

    IN_ADDR_IPV4    Address;
    USHORT          Unused;
    USHORT          Port;

} RSVP_FILTERSPEC_V4, *LPRSVP_FILTERSPEC_V4;

typedef struct _RSVP_FILTERSPEC_V6 {

    IN_ADDR_IPV6    Address;
    USHORT          UnUsed;
    USHORT          Port;

} RSVP_FILTERSPEC_V6, *LPRSVP_FILTERSPEC_V6;


typedef struct _RSVP_FILTERSPEC_V6_FLOW {

    IN_ADDR_IPV6    Address;
    UCHAR           UnUsed;
    UCHAR           FlowLabel[3];

} RSVP_FILTERSPEC_V6_FLOW, *LPRSVP_FILTERSPEC_V6_FLOW;

typedef struct _RSVP_FILTERSPEC_V4_GPI {

    IN_ADDR_IPV4    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V4_GPI, *LPRSVP_FILTERSPEC_V4_GPI;

typedef struct _RSVP_FILTERSPEC_V6_GPI {

    IN_ADDR_IPV6    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V6_GPI, *LPRSVP_FILTERSPEC_V6_GPI;


/*
 * FILTERSPEC TYPES used in making reservations.
 */
typedef enum {

        FILTERSPECV4 = 1,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END

} FilterType;

typedef struct _RSVP_FILTERSPEC {

    FilterType   Type;

    union {
        RSVP_FILTERSPEC_V4      FilterSpecV4;
        RSVP_FILTERSPEC_V6      FilterSpecV6;
        RSVP_FILTERSPEC_V6_FLOW FilterSpecV6Flow;
        RSVP_FILTERSPEC_V4_GPI  FilterSpecV4Gpi;
        RSVP_FILTERSPEC_V6_GPI  FilterSpecV6Gpi;
    };

} RSVP_FILTERSPEC, *LPRSVP_FILTERSPEC;

/*
 * FLOWDESCRIPTOR Structure used for specifying one or more
 * Filters per Flowspec.
 */
typedef struct _FLOWDESCRIPTOR {

    FLOWSPEC            FlowSpec;
    ULONG               NumFilters;
    LPRSVP_FILTERSPEC   FilterList;

} FLOWDESCRIPTOR, *LPFLOWDESCRIPTOR;

/*
 * RSVP_POLICY contains undefined policy data.  RSVP transports this
 * data on behalf of the Policy Control component.
 */
typedef struct _RSVP_POLICY {
    USHORT  Len;         /* total length of this element object */
    USHORT  Type;
    UCHAR   Info[4];
} RSVP_POLICY, *LPRSVP_POLICY;

typedef const RSVP_POLICY *LPCRSVP_POLICY;
#define RSVP_POLICY_HDR_LEN    ( sizeof(USHORT) + sizeof(USHORT) )

/*
 * RSVP_POLICY_INFO contains undefined policy element(s) retrieved from RSVP.  
 */
typedef struct _RSVP_POLICY_INFO  {

    QOS_OBJECT_HDR     ObjectHdr;
    ULONG              NumPolicyElement;         /* count of the 
                                                  * number of policy elements */
    RSVP_POLICY        PolicyElement[1];         /* a list of the policy 
                                                  * elements retrieved */

} RSVP_POLICY_INFO, *LPRSVP_POLICY_INFO;

/*
 * RSVP_RESERVE_INFO Structure used for storing RSVP specific
 * information for fine tuning interaction via the Winsock2
 * Generic QoS API via the provider specific buffer. This structure
 * includes the QOS_OBJECT_HDR structure directly
 */

typedef struct _RSVP_RESERVE_INFO {

    QOS_OBJECT_HDR      ObjectHdr;            /* type and length of this object */
    ULONG               Style;                /* RSVP Style (FF,WF,SE) */
    ULONG               ConfirmRequest;       /* Non Zero for Confirm Request (receive only) */
    LPRSVP_POLICY_INFO  PolicyElementList;    /* Points to the set of policy elements */
    ULONG               NumFlowDesc;          /* Number of FlowDesc */
    LPFLOWDESCRIPTOR    FlowDescList;         /* Points to the FlowDesc list */

} RSVP_RESERVE_INFO, *LPRSVP_RESERVE_INFO;

typedef const RSVP_RESERVE_INFO *LPCRSVP_RESERVE_INFO;

/*
 * definitions for the ulStyle in the previous structure
 */
#define RSVP_DEFAULT_STYLE            0x00000000
#define RSVP_WILDCARD_STYLE           0x00000001
#define RSVP_FIXED_FILTER_STYLE       0x00000002
#define RSVP_SHARED_EXPLICIT_STYLE    0x00000003

/*
 * RSVP_STATUS_INFO Structure used for storing RSVP specific
 * error of status indications.  This also serves as a header
 * for additional objects in the provider specific buffer when
 * interacting via Winsock2 Generic QoS API. This structure includes
 * the QOS_OBJECT_COUNT and QOS_OBJECT_HDR structures directly It is
 * expected to be the first structure in the provider specific structure
 * since it includes the QOS_OBJECT_COUNT
 */

typedef struct _RSVP_STATUS_INFO {

    QOS_OBJECT_HDR      ObjectHdr;      /* Object Hdr */
    ULONG               StatusCode;     /* Error or Status Information see 
                                         * Winsock2.h */
    ULONG               ExtendedStatus1;/* Provider specific status extension */
    ULONG               ExtendedStatus2;/* Provider specific status extension */

} RSVP_STATUS_INFO, *LPRSVP_STATUS_INFO;

typedef const RSVP_STATUS_INFO *LPCRSVP_STATUS_INFO;


/*
 * QOS_DestAddr structure -- used for WSAIoctl(SIO_SET_QOS) when we
 * do not want to issue a connect for a sending socket.  The destination
 * address is required so we can generate the session information for
 * RSVP signalling.
*/

typedef struct _QOS_DESTADDR {
    QOS_OBJECT_HDR ObjectHdr;                     /* Object header */
    const struct sockaddr *  SocketAddress;       /* Destination socket address */
    ULONG                    SocketAddressLength; /* Length of the address structure */
} QOS_DESTADDR, *LPQOS_DESTADDR;

typedef const QOS_DESTADDR * LPCQOS_DESTADDR;



/*
 * this structure defines the "General Characterization Parameters" contained in
 * the RSVP Adspec object
 */
typedef struct _AD_GENERAL_PARAMS{

    ULONG       IntServAwareHopCount;   /* number of hops that conform to
                                         * Integrated Services requirements */
    ULONG       PathBandwidthEstimate;  /* minimum bandwidth available from 
                                         * sender to receiver */
    ULONG       MinimumLatency;         /* sum of minimum latency of the packet
                                         * forwarding process in routers 
                                         * (in usec)*/
    ULONG       PathMTU;                /* max transmission unit end to end that
                                         * will not incur fragmentation */
    ULONG       Flags;                  /* used to hold break bits.*/

} AD_GENERAL_PARAMS, *LPAD_GENERAL_PARAMS;

/*
 * Minimum Latency may be set to this "undefined" value
 */
#define INDETERMINATE_LATENCY   0xFFFFFFFF;

/*
 * This Flag is used to indicate the existence of a network element not 
 * supporting  QoS control services somewhere in the data path. If this bit 
 * is set in the specific service override then it indicates that that
 * service was not supported at at least one hop.
 */
#define AD_FLAG_BREAK_BIT    0x00000001

/*
 * this structure describes the Guaranteed service parameters
 */
typedef struct _AD_GUARANTEED {

    ULONG       CTotal;
    ULONG       DTotal;
    ULONG       CSum;
    ULONG       DSum;

} AD_GUARANTEED, *LPAD_GUARANTEED;

/*
 * this structure describes the format of the parameter buffer that can be
 * included in the Service_Type structure below.  This structure allows an
 * application to include any valid Int Serv service parameter in the Buffer 
 * value, after providing the Int Serv parameter id in the ParameterId field.
 */
typedef struct _PARAM_BUFFER {

    ULONG   ParameterId;    /* Int Server parameter ID */
    ULONG   Length;         /* total length of this structure 
                             * ( 8 bytes + length of Buffer ) */
    UCHAR   Buffer[1];      /* Paramter itself */

} PARAM_BUFFER, *LPPARAM_BUFFER;

/*
 * this structure contains the service types supported
 */
typedef struct _CONTROL_SERVICE {

    /*
     * the length of this entire structure including the following buffer.  
     * This length value can be added to the ptr to the structure to get the ptr
     * to the next SERVICE_TYPE structure in the list, until the
     * NumberOfServices count has been exhausted.
     */
    ULONG               Length;

    SERVICETYPE         Service;
    AD_GENERAL_PARAMS   Overrides;

    /*
     * service specific information ( controlled load has no service specific 
     * info here )
     */
    union {
        AD_GUARANTEED   Guaranteed;
        PARAM_BUFFER    ParamBuffer[1];     /* allows for other services down 
                                             * the road */
    };

} CONTROL_SERVICE, *LPCONTROL_SERVICE;

/*
 * This structure defines the information which is carried in the Rsvp 
 * Adspec.  This Rsvp object typically indicates which service types are 
 * available ( Controlled Load and/or Guaranteed Service ), if a non-Rsvp
 * hop has been encountered by the Path message, and the minumum MTU along 
 * the path. The services array indicates which services are supported
 */
typedef struct _RSVP_ADSPEC  {

    QOS_OBJECT_HDR     ObjectHdr;
    AD_GENERAL_PARAMS  GeneralParams;      /* contains the general 
                                            * characterization paramters */
    ULONG              NumberOfServices;   /* count of the number of services */
    CONTROL_SERVICE    Services[1];        /* a list of the services 
                                            * supported/requested */

} RSVP_ADSPEC, *LPRSVP_ADSPEC;


//
// Opcode for the SIO_CHK_QOS ioctl
// (specific for the Microsoft QOS Service Provider
//
// Bascially:
//
// SIO_CHK_QOS = _WSAIORW(IOC_VENDOR,1)
//             = mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code
//    where
//         mIOC_IN     = 0x80000000
//         mIOC_OUT    = 0x40000000
//         mIOC_VENDOR = 0x04000000
//         mCOMPANY    = 0x18000000
//         ioctl_code  = 0x00000001
//         
// See WSAIoctl man page for details.
//

#define    mIOC_IN       0x80000000
#define    mIOC_OUT      0x40000000
#define    mIOC_VENDOR   0x04000000
#define    mCOMPANY      0x18000000
#define    ioctl_code    0x00000001

#define SIO_CHK_QOS   (mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code)

//
// The following may be specified in the input buffer 
// of the SIO_CHK_IOCTL ioctl call 
//

#define QOSSPBASE           50000

#define ALLOWED_TO_SEND_DATA  (QOSSPBASE+1)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define ABLE_TO_RECV_RSVP     (QOSSPBASE+2)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define LINE_RATE             (QOSSPBASE+3)     // query the interface capacity 
                                                //   -- result returned in the output buffer
                                                //      in kilo-bits per second

#define LOCAL_TRAFFIC_CONTROL (QOSSPBASE+4)     // check if Kernel Traffic Control is available or not
                                                //   -- 0 if not available
                                                //   -- 1 if avaiable
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define LOCAL_QOSABILITY      (QOSSPBASE+5)     // The followings are for 
                                                // the Discovery of Local QOSability
                                                //   -- 0 if no local QOS support
                                                //   -- 1 if local QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define END_TO_END_QOSABILITY (QOSSPBASE+6)     // The followings are for 
                                                // the Discovery of End-to-End QOSability
                                                //   -- 0 if no end-to-end QOS support
                                                //   -- 1 if end-to-end QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define INFO_NOT_AVAILABLE  0xFFFFFFFF          // used when LINE_RATE is not known


#define ANY_DEST_ADDR       0xFFFFFFFF          // for QOS_OBJECT_DEST_ADDR


// The followings are for Guaranteed_Service+Latency -> ISSLOW_Traffic_Class Mapping

#define MODERATELY_DELAY_SENSITIVE   0xFFFFFFFD  

#define HIGHLY_DELAY_SENSITIVE       0xFFFFFFFE

//
// QOSSP Error Code/Value
//

#define QOSSP_ERR_BASE                                 (QOSSPBASE+6000)

// No error
#define GQOS_NO_ERRORCODE                              (0)

#define GQOS_NO_ERRORVALUE                             (0)

// Unknown error
#define GQOS_ERRORCODE_UNKNOWN                         (0xFFFFFFFF)

#define GQOS_ERRORVALUE_UNKNOWN                        (0xFFFFFFFF)

// Admission (Resource) Error
#define GQOS_NET_ADMISSION                             (QOSSP_ERR_BASE+100)

#define GQOS_OTHER                                     (QOSSP_ERR_BASE+100+1)
#define GQOS_DELAYBND                                  (QOSSP_ERR_BASE+100+2)
#define GQOS_BANDWIDTH                                 (QOSSP_ERR_BASE+100+3)
#define GQOS_MTU                                       (QOSSP_ERR_BASE+100+4)
#define GQOS_FLOW_RATE                                 (QOSSP_ERR_BASE+100+5)
#define GQOS_PEAK_RATE                                 (QOSSP_ERR_BASE+100+6)
#define GQOS_AGG_PEAK_RATE                             (QOSSP_ERR_BASE+100+7)

// Policy Error
#define GQOS_NET_POLICY                                (QOSSP_ERR_BASE+200)

#define GQOS_POLICY_ERROR_UNKNOWN                      (QOSSP_ERR_BASE+200+0)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+1)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+2)
#define GQOS_POLICY_GLOBAL_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+3)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+4)
#define GQOS_POLICY_SUBNET_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+5)
#define GQOS_POLICY_SUBNET_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+6)
#define GQOS_POLICY_SUBNET_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+7)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+8)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+9)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+10)
#define GQOS_POLICY_GLOBAL_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+11)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+12)
#define GQOS_POLICY_SUBNET_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+13)
#define GQOS_POLICY_SUBNET_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+14) 
#define GQOS_POLICY_SUBNET_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+15)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+16)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+17)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+18)
#define GQOS_POLICY_GLOBAL_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+19)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+20)
#define GQOS_POLICY_SUBNET_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+21)
#define GQOS_POLICY_SUBNET_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+22)
#define GQOS_POLICY_SUBNET_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+23)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+24)

#define GQOS_POLICY_GLOBAL_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+25)
#define GQOS_POLICY_GLOBAL_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+26)
#define GQOS_POLICY_GLOBAL_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+27)
#define GQOS_POLICY_GLOBAL_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+28)
#define GQOS_POLICY_SUBNET_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+29)
#define GQOS_POLICY_SUBNET_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+30)
#define GQOS_POLICY_SUBNET_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+31)
#define GQOS_POLICY_SUBNET_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+32)

#define GQOS_POLICY_GLOBAL_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+33)
#define GQOS_POLICY_GLOBAL_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+34)
#define GQOS_POLICY_GLOBAL_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+35)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+36)
#define GQOS_POLICY_SUBNET_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+37)
#define GQOS_POLICY_SUBNET_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+38)
#define GQOS_POLICY_SUBNET_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+39)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+40)

#define GQOS_POLICY_GLOBAL_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+41)
#define GQOS_POLICY_GLOBAL_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+42)
#define GQOS_POLICY_GLOBAL_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+43)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+44)
#define GQOS_POLICY_SUBNET_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+45)
#define GQOS_POLICY_SUBNET_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+46)
#define GQOS_POLICY_SUBNET_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+47)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+48)

#define GQOS_POLICY_UNKNOWN_USER                       (QOSSP_ERR_BASE+200+49)
#define GQOS_POLICY_NO_PRIVILEGES                      (QOSSP_ERR_BASE+200+50)
#define GQOS_POLICY_EXPIRED_USER_TOKEN                 (QOSSP_ERR_BASE+200+51)
#define GQOS_POLICY_NO_RESOURCES                       (QOSSP_ERR_BASE+200+52)
#define GQOS_POLICY_PRE_EMPTED                         (QOSSP_ERR_BASE+200+53)
#define GQOS_POLICY_USER_CHANGED                       (QOSSP_ERR_BASE+200+54)
#define GQOS_POLICY_NO_ACCEPTS                         (QOSSP_ERR_BASE+200+55)
#define GQOS_POLICY_NO_MEMORY                          (QOSSP_ERR_BASE+200+56)
#define GQOS_POLICY_CRAZY_FLOWSPEC                     (QOSSP_ERR_BASE+200+57)

#define GQOS_POLICY_NO_MORE_INFO                       (QOSSP_ERR_BASE+200+58)
#define GQOS_POLICY_UNSUPPORTED_CREDENTIAL_TYPE        (QOSSP_ERR_BASE+200+59)
#define GQOS_POLICY_INSUFFICIENT_PRIVILEGES            (QOSSP_ERR_BASE+200+60)
#define GQOS_POLICY_EXPIRED_CREDENTIAL                 (QOSSP_ERR_BASE+200+61)
#define GQOS_POLICY_IDENTITY_CHANGED                   (QOSSP_ERR_BASE+200+62)
#define GQOS_POLICY_NO_QOS_PROVIDED                    (QOSSP_ERR_BASE+200+63)
#define GQOS_POLICY_DO_NOT_SEND                        (QOSSP_ERR_BASE+200+64)

#define GQOS_POLICY_ERROR_USERID                       (QOSSP_ERR_BASE+200+99)

// RSVP Error
#define GQOS_RSVP                                      (QOSSP_ERR_BASE+300)

#define GQOS_NO_PATH                                   (QOSSP_ERR_BASE+300+1)
#define GQOS_NO_SENDER                                 (QOSSP_ERR_BASE+300+2)
#define GQOS_BAD_STYLE                                 (QOSSP_ERR_BASE+300+3)
#define GQOS_UNKNOWN_STYLE                             (QOSSP_ERR_BASE+300+4)
#define GQOS_BAD_DSTPORT                               (QOSSP_ERR_BASE+300+5) 
#define GQOS_BAD_SNDPORT                               (QOSSP_ERR_BASE+300+6)
#define GQOS_AMBIG_FILTER                              (QOSSP_ERR_BASE+300+7)
#define GQOS_PREEMPTED                                 (QOSSP_ERR_BASE+300+8)
#define GQOS_UNKN_OBJ_CLASS                            (QOSSP_ERR_BASE+300+9)
#define GQOS_UNKNOWN_CTYPE                             (QOSSP_ERR_BASE+300+10)
#define GQOS_INVALID                                   (QOSSP_ERR_BASE+300+11)

// API Error
#define GQOS_API                                       (QOSSP_ERR_BASE+400)

#define GQOS_API_BADSEND                               (QOSSP_ERR_BASE+400+1) /* Sender addr not my interface */
#define GQOS_API_BADRECV                               (QOSSP_ERR_BASE+400+2) /* Recv addr not my interface */
#define GQOS_API_BADSPORT                              (QOSSP_ERR_BASE+400+3) /* Sport !=0 but Dport == 0 */

// TC System Error
#define GQOS_KERNEL_TC_SYS                             (QOSSP_ERR_BASE+500)

#define GQOS_TC_GENERIC                                (QOSSP_ERR_BASE+500+1)
#define GQOS_TC_INVALID                                (QOSSP_ERR_BASE+500+2)
#define GQOS_NO_MEMORY                                 (QOSSP_ERR_BASE+500+3)
#define GQOS_BAD_ADDRESSTYPE                           (QOSSP_ERR_BASE+500+4) 
#define GQOS_BAD_DUPLICATE                             (QOSSP_ERR_BASE+500+5)
#define GQOS_CONFLICT                                  (QOSSP_ERR_BASE+500+6)
#define GQOS_NOTREADY                                  (QOSSP_ERR_BASE+500+7)
#define GQOS_WOULDBLOCK                                (QOSSP_ERR_BASE+500+8)
#define GQOS_INCOMPATIBLE                              (QOSSP_ERR_BASE+500+9)
#define GQOS_BAD_SDMODE                                (QOSSP_ERR_BASE+500+10)
#define GQOS_BAD_QOSPRIORITY                           (QOSSP_ERR_BASE+500+11)
#define GQOS_BAD_TRAFFICCLASS                          (QOSSP_ERR_BASE+500+12)
#define GQOS_NO_SYS_RESOURCES                          (QOSSP_ERR_BASE+500+13)

// RSVP System Error
#define GQOS_RSVP_SYS                                  (QOSSP_ERR_BASE+600)

#define GQOS_OTHER_SYS                                 (QOSSP_ERR_BASE+600+1)
#define GQOS_MEMORY_SYS                                (QOSSP_ERR_BASE+600+2)
#define GQOS_API_SYS                                   (QOSSP_ERR_BASE+600+3)
#define GQOS_SETQOS_NO_LOCAL_APPS                      (QOSSP_ERR_BASE+600+4)

// TC Error
#define GQOS_KERNEL_TC                                 (QOSSP_ERR_BASE+700)

#define GQOS_CONFLICT_SERV                             (QOSSP_ERR_BASE+700+1)
#define GQOS_NO_SERV                                   (QOSSP_ERR_BASE+700+2)
#define GQOS_BAD_FLOWSPEC                              (QOSSP_ERR_BASE+700+3)
#define GQOS_BAD_TSPEC                                 (QOSSP_ERR_BASE+700+4)
#define GQOS_BAD_ADSPEC                                (QOSSP_ERR_BASE+700+5)

// GQOS API ERRORS

// WSAIoctl Error

#define GQOS_IOCTL_SYSTEMFAILURE                       (QOSSP_ERR_BASE+800+1)
#define GQOS_IOCTL_NOBYTESRETURNED                     (QOSSP_ERR_BASE+800+2)
#define GQOS_IOCTL_INVALIDSOCKET                       (QOSSP_ERR_BASE+800+3)
#define GQOS_IOCTL_INV_FUNCPTR                         (QOSSP_ERR_BASE+800+4)
#define GQOS_IOCTL_INV_OVERLAPPED                      (QOSSP_ERR_BASE+800+5)

// SIO_SET_QOS error

#define GQOS_SETQOS_BADINBUFFER                        (QOSSP_ERR_BASE+810+1)
#define GQOS_SETQOS_BADFLOWSPEC                        (QOSSP_ERR_BASE+810+2)
#define GQOS_SETQOS_COLLISION                          (QOSSP_ERR_BASE+810+3)
#define GQOS_SETQOS_BADPROVSPECBUF                     (QOSSP_ERR_BASE+810+4)
#define GQOS_SETQOS_ILLEGALOP                          (QOSSP_ERR_BASE+810+5)
#define GQOS_SETQOS_INVALIDADDRESS                     (QOSSP_ERR_BASE+810+6)
#define GQOS_SETQOS_OUTOFMEMORY                        (QOSSP_ERR_BASE+810+7)
#define GQOS_SETQOS_EXCEPTION                          (QOSSP_ERR_BASE+810+8)
#define GQOS_SETQOS_BADADDRLEN                         (QOSSP_ERR_BASE+810+9)
#define GQOS_SETQOS_NOSOCKNAME                         (QOSSP_ERR_BASE+810+10)
#define GQOS_SETQOS_IPTOSFAIL                          (QOSSP_ERR_BASE+810+11)
#define GQOS_SETQOS_OPENSESSIONFAIL                    (QOSSP_ERR_BASE+810+12)
#define GQOS_SETQOS_SENDFAIL                           (QOSSP_ERR_BASE+810+13)
#define GQOS_SETQOS_RECVFAIL                           (QOSSP_ERR_BASE+810+14)
#define GQOS_SETQOS_BADPOLICYOBJECT                    (QOSSP_ERR_BASE+810+15)
#define GQOS_SETQOS_UNKNOWNFILTEROBJ                   (QOSSP_ERR_BASE+810+16)
#define GQOS_SETQOS_BADFILTERTYPE                      (QOSSP_ERR_BASE+810+17)
#define GQOS_SETQOS_BADFILTERCOUNT                     (QOSSP_ERR_BASE+810+18)
#define GQOS_SETQOS_BADOBJLENGTH                       (QOSSP_ERR_BASE+810+19)
#define GQOS_SETQOS_BADFLOWCOUNT                       (QOSSP_ERR_BASE+810+20)
#define GQOS_SETQOS_UNKNOWNPSOBJ                       (QOSSP_ERR_BASE+810+21)
#define GQOS_SETQOS_BADPOLICYOBJ                       (QOSSP_ERR_BASE+810+22)
#define GQOS_SETQOS_BADFLOWDESC                        (QOSSP_ERR_BASE+810+23)
#define GQOS_SETQOS_BADPROVSPECOBJ                     (QOSSP_ERR_BASE+810+24)
#define GQOS_SETQOS_NOLOOPBACK                         (QOSSP_ERR_BASE+810+25)
#define GQOS_SETQOS_MODENOTSUPPORTED                   (QOSSP_ERR_BASE+810+26)
#define GQOS_SETQOS_MISSINGFLOWDESC                    (QOSSP_ERR_BASE+810+27)

// SIO_GET_QOS error

#define GQOS_GETQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+840+1)
#define GQOS_GETQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+840+2)
#define GQOS_GETQOS_EXCEPTION                          (QOSSP_ERR_BASE+840+3)
#define GQOS_GETQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+840+4)

// SIO_CHK_QOS error

#define GQOS_CHKQOS_BADINBUFFER                        (QOSSP_ERR_BASE+850+1)
#define GQOS_CHKQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+850+2)
#define GQOS_CHKQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+850+3)
#define GQOS_CHKQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+850+4)
#define GQOS_CHKQOS_BADPARAMETER                       (QOSSP_ERR_BASE+850+5)
#define GQOS_CHKQOS_EXCEPTION                          (QOSSP_ERR_BASE+850+6)

#endif  /* __QOSSP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\qos2.h ===
/*++

Copyright (c) 2004  Microsoft Corporation

Module Name:

    qos2.h

Abstract:

    This module contains QOS structures and function headers

--*/

#pragma once

#include <ws2tcpip.h>
#include <mstcpip.h>

//
// Support calls from C++
//
#if defined(__cplusplus)
    #define ExternC extern "C"
#else
    #define ExternC
#endif

//
// Each admitted flow has a unique Flow ID. This ID is valid only
// in the process which called QOSAddSocketToFlow() for that flow
// with the handle returned from QOSCreateHandle
//
typedef ULONG QOS_FLOWID, *PQOS_FLOWID;

//
// Definitions of various traffic types. Application identifies
// each flow as being of a certain type. This enables the QOS
// subsystem to apply user-specified per-type policies to flows
//
// QOSTrafficTypeBestEffort:
//      
//      This service type requests the same network priority to the traffic 
//      as regular traffic not associated to the qWave api. For home scenarios, 
//      this is DLNA class DLNAQOS_1.
//
// QOSTrafficTypeBackground:
//
//      This service type requests a network priority to the traffic lower than 
//      traffic of type QOSTrafficTypeBestEffort. For example, this service 
//      could be used for traffic of applications doing data backups. For home 
//      scenarios, this is DLNA class DLNAQOS_0.
//
// QOSTrafficTypeExcellentEffort:
//
//      This service type requests a network priority to the traffic higher than 
//      QOSTrafficTypeBestEffort. This service type should be used for data 
//      traffic that, although not A/V, is more important than normal end-user 
//      scenarios. For example, email traffic. This service type is not part of 
//      the DLNA specification.
//
// QOSTrafficTypeAudioVideo:
//
//      This service type should be used for A/V streaming scenarios such as 
//      MPEG2 streaming. For home scenarios, this is DLNA class DLNAQOS_2.
//
// QOSTrafficTypeVoice:
//
//      This service type should be used for realtime voice streams such as 
//      VoIP. This service type is not part of the DLNA specification.
//
// QOSTrafficTypeControl:
//
//      This service type should only be used for the most critical data. For 
//      example, you might use it for data carrying user inputs to an A/V 
//      experience, e.g. play, pause, FF, RW, etc. The A/V traffic however 
//      should use QOSTrafficTypeAudioVideo. For home scenarios, this is DLNA 
//      class DLNAQOS_3.
//
typedef enum _QOS_TRAFFIC_TYPE 
{
    QOSTrafficTypeBestEffort        = 0,
    QOSTrafficTypeBackground        = 1,
    QOSTrafficTypeExcellentEffort   = 2,
    QOSTrafficTypeAudioVideo        = 3,
    QOSTrafficTypeVoice             = 4,
    QOSTrafficTypeControl           = 5
} QOS_TRAFFIC_TYPE, *PQOS_TRAFFIC_TYPE;

//
// This enum lists the operations that may be given to the QOSSetFlow API.
//
// QOSSetTrafficType: 
//
//      Allows an application to change the traffic type of its 
//      flow. For example, this may be useful if you are alternating between 
//      best effort and other types.
//
//      This must be accompanied by a QOS_TRAFFIC_TYPE value.
//
// QOSSetOutgoingRate:
//
//      This allows an application to define the characteristics of the 
//      outgoing traffic on its flow. This may be used to shape the outgoing 
//      traffic or to create a contract linking packet marking to packet 
//      shaping. Such a contract is required for environments were policy uses 
//      admission control. The traffic type will not be respected until a 
//      shaping rate is in place.
//
//      Must be accompagnied by a QOS_FLOWRATE_OUTGOING structure.
//
// QOSSetOutgoingDSCPValue:
//
//      This allows an application to specify the precise DSCP value used in
//      outgoing traffic.  This setting is overriden if an adaptive flow 
//      requests prioritization on the same machine.  This setting requires
//      the calling application be a member of the Administrators or the
//      Network Configuration Operators group.  This setting can only be
//      applied to a non-adaptive flow.
//
//      Must be accompanied by a DWORD value representing the DSCP value to
//      use.  The value must be from 0 to 63 inclusive.
//
//      To revert the effect of setting a DSCP value, the caller should call
//      the QOSSetFlow API again with the operation value QOSSetTrafficType.
//
typedef enum _QOS_SET_FLOW
{
    QOSSetTrafficType           = 0,
    QOSSetOutgoingRate          = 1,
    QOSSetOutgoingDSCPValue     = 2
} QOS_SET_FLOW, *PQOS_SET_FLOW;

//
// This structure is returned by QOSQueryFlow and allows the application to
// verify what priority markings (or tags) are applied to its traffic. These
// values may change as the flow changes or policies get updated.
//
typedef struct _QOS_PACKET_PRIORITY
{
    ULONG   ConformantDSCPValue;    // the DSCP marking used for the flow's 
                                    // traffic that respects the flow rate 
                                    // specified

    ULONG   NonConformantDSCPValue; // the DSCP marking used for the flow's 
                                    // traffic that exceeds the flow rate 
                                    // specified. Applicable only if shaping 
                                    // behavior is set to 
                                    // QOSUseNonConformantMarkings

    ULONG   ConformantL2Value;      // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified

    ULONG   NonConformantL2Value;   // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified.
                                    // Applicable only if shaping behavior is 
                                    // set to QOSUseNonConformantMarkings
} QOS_PACKET_PRIORITY, *PQOS_PACKET_PRIORITY;

typedef struct _QOS_FLOW_FUNDAMENTALS
{
    BOOL    BottleneckBandwidthSet; // TRUE if the BottleneckBandwidth field
                                    // contains a value.
    UINT64  BottleneckBandwidth;    // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    AvailableBandwidthSet;  // TRUE if the AvailableBandwidth field
                                    // contains a value.
    UINT64  AvailableBandwidth;     // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    RTTSet;                 // TRUE if the RTT field
                                    // contains a value.
    UINT32  RTT;                    // RTT is in microseconds. 
} QOS_FLOW_FUNDAMENTALS, *PQOS_FLOW_FUNDAMENTALS;

typedef enum _QOS_FLOWRATE_REASON
{
    QOSFlowRateNotApplicable            = 0,
    QOSFlowRateContentChange            = 1,
    QOSFlowRateCongestion               = 2,
    QOSFlowRateHigherContentEncoding    = 3,
    QOSFlowRateUserCaused               = 4
} QOS_FLOWRATE_REASON, *PQOS_FLOWRATE_REASON;

//
// This enum is used to define the shaping behavior. Remember that, if policy
// demands admission control, packet priority is only applied through a contract 
// with the application. This enum allows you to define how the contract is 
// enforced.
//
// QOSShapeOnly: if the flow is set to shape only, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will be marked
// as best effort packets.
//
// QOSShapeAndMark: if the flow is set to shape, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will always 
// receive conformant priority values.
//
// QOSUseNonConformantMarkings: if the flow is set to use non conformant values,
// qWave will not enforce the flow rate requested. If sending a data packet 
// would exceed the flow rate, this packet will receive a priority value 
// indicating it is non-conformant. Such packets will receive default treatment -
// which is best effort - from network equipment. This may lead to lost packets
// and/or re-ordered packets.
//
typedef enum _QOS_SHAPING{
    QOSShapeOnly                        = 0,
    QOSShapeAndMark                     = 1,
    QOSUseNonConformantMarkings         = 2
} QOS_SHAPING, *PQOS_SHAPING;

#define QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH  0xFFFFFFFF

//
// This struct describes the information required by qWave to accept a flowrate
// from the application. We recommend that you read the description for
// QOS_ADD_OVERHEAD and QOS_SUBTRACT_OVERHEAD before using this structure.
//
// Bandwidth: the rate (in bits/s) you expect to send your traffic at. As a 
// warning, you should note that traffic on the network is measured at the IP 
// level and not at the application level. Thus, the rate you specify should 
// account for the IP and protocol headers. Although there are various ways
// to estimate this final rate, you may wish to use the QOS_ADD_OVERHEAD and
// QOS_SUBTRACT_OVERHEAD functions for these calculations.
//
// If you are unsure what bandwidth value you need but expect to use very little
// use QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH. The system will allocate you
// a small amount of bandwidth for your operations.
//
// ShapingBehavior: how the contract for admission control will be enforced
//
// Reason: if a rate change has occured, this reason should indicate why.
typedef struct _QOS_FLOWRATE_OUTGOING
{
    UINT64                  Bandwidth;      // In units of bits/s
    QOS_SHAPING             ShapingBehavior;// Shaping behavior
    QOS_FLOWRATE_REASON     Reason;         // Optional field for the 
                                            // application to indicate why it's 
                                            // changing a flow's data rate
} QOS_FLOWRATE_OUTGOING, *PQOS_FLOWRATE_OUTGOING;

//
// When using the enum QOSQueryOutgoingRate you should expect the returned rate
// to measure bandwidth at layer 3. If you wish to adjust this rate, based on 
// your application's characteristics, for the IP header and protocol header
// overhead, you should review the QOS_SUBTRACT_OVERHEAD inlined function.
typedef enum _QOS_QUERY_FLOW
{
    QOSQueryFlowFundamentals    = 0,
    QOSQueryPacketPriority      = 1,
    QOSQueryOutgoingRate        = 2
} QOS_QUERY_FLOW, *PQOS_QUERY_FLOW;

typedef enum _QOS_NOTIFY_FLOW
{
    QOSNotifyCongested          = 0,
    QOSNotifyUncongested        = 1,       
    QOSNotifyAvailable          = 2       
} QOS_NOTIFY_FLOW, *PQOS_NOTIFY_FLOW;

//
// The type for QOS protocol version numbers.
// For Vista, the version should be
// MajorVersion: 1
// MinorVersion: 0

typedef struct _QOS_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;
} QOS_VERSION, *PQOS_VERSION;

#define QOS_QUERYFLOW_FRESH         0x00000001
#define QOS_NON_ADAPTIVE_FLOW       0x00000002

__inline
INT
QOS_HEADER_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol
){
    UINT32 overhead;

    if (af == AF_INET)
        overhead = 20;                          // IPv4 header overhead in bytes
    else
        overhead = 40;                          // IPv6 header overhead in bytes

    if (protocol == IPPROTO_TCP)
        overhead += 20;                         // TCP header overhead in bytes
    else
        overhead += 8;                          // UDP header overhead in bytes

    return overhead;    
}


//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
//  The value 0 is an invalid parameter which will result in a division by 0.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, augmented by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_ADD_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (       dataRate                  )
    // returnRate = dataRate + ( -------------------- * overhead )
    //                         ( targetDataPacketSize            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize;
    d *= (double) dataRate;

    r = dataRate;
    r += (UINT64) d;

    return r;
}

//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and that the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, reduced by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_SUBTRACT_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (            dataRate                        )
    // returnRate = dataRate - ( ------------------------------- * overhead )
    //                         ( targetDataPacketSize + overhead            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize + overhead;
    d *= (double) dataRate;

    r = dataRate;
    r -= (UINT64) d;

    return r;
}

//
// Description:
//
//  API to initialize QOS subsystem. Every process intending to use
//  QOS must first make the QOSCreateHandle call.
//
//  The handle returned by this call is useful for performing
//  overlapped IO. For example, it can be associated with a
//  IOCP to receive overlapped completion notifications.
//
//  Although a single QOSHandle would be sufficient for most applications,
//  applications have the option of calling QOSCreateHandle multiple times
//  to obtain multiple handles
//
//      .Version        - Specifies what version of this API you wish to use.
//                        This parameter must be of type QOS_VERSION. For Vista
//                        the only valid value is 1.0
//
//      .QOSHandle      - On output, if the call is successful, this will return
//                        a file handle to the QOS subsystem. This handle should
//                        be closed with QOSCloseHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_SERVICE_DEPENDENCY_FAIL
//          One of the dependencies of the service is unavailable. The qWave
//          service could not be started.
//
//      ERROR_RESOURCE_DISABLED
//          One of the resources required by the service is unavailable. This 
//          error may be returned if the user has not enabled the firewall
//          exception for the qWave service. Please see the developer guidelines 
//          and MSFT firewall documentation for more details.
//
ExternC
BOOL
WINAPI
QOSCreateHandle(
    __in    PQOS_VERSION    Version,
    __out   PHANDLE         QOSHandle
);

//
// Description:
//
//  API to close a handle returned by QOSCreateHandle
//
//  When closing a handle, all flows added on this handle are immediately 
//  removed from the system. Any traffic going out a socket used to create these 
//  flows will no longer be marked. Moreover, any pending operations for these 
//  flows are completed with ERROR_ABORTED.
//
//  If any clients were tracked through this handle, the subsystem will continue
//  tracking these for some limited amount of time. This can be stopped by 
//  calling either QOSStopTrackingClient on this handle before closing it or 
//  through another handle once this one has been closed.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCloseHandle(
    __in    HANDLE         QOSHandle
);

//
// Description:
//
//  API to inform the QOS subsystem of the existence of a new client. 
//  The QOS subsystem will start gathering statistics about this client device. 
//  This call is NOT required to add a flow, but it is recommended for adaptive
//  flows.
//
//  Ideally, an application would make this API call as soon as it is aware of a 
//  possible client device with which it may need to create a QOS flow. By using
//  this call, you increase the likelihood that qWave will have gathered 
//  sufficient information on the network path to assist you when you attempt to
//  set the flow rate.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device. Note that a client 
//                        is identified strictly by it's IP address and address 
//                        family. A port number is not required and will be 
//                        ignored.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStartTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_HOST_UNREACHABLE
//          The qWave service was unable to communicate with the peer host to
//          run qWave experiments. This could be a sign that there is no 
//          qWave sink on the remote host or that a firewall is blocking 
//          communication.
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSStartTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to remove a client. The QOS subsystem will stop gathering statistics
//  about this client device. This call will only be accepted if 
//  QOSStartTrackingClient was previously called on the host. If a flow is 
//  currently in progress, this will not affect the flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStopTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSStopTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to enumerate all the existing flows. This call requires administrative 
//  rights. Through it the caller can obtain the list of current flow IDs on the 
//  system. Using QOSQueryFlow, one can then query the flows.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Size           - On input represents the size in bytes of the buffer. 
//                        On output, if successful, the amount of bytes copied 
//                        in the buffer. If the call fails with 
//                        ERROR_INSUFFICIENT_BUFFER, the parameter size will 
//                        indicate the minimum required buffer size.
//
//      .Buffer         - On output contains an array of QOS_FLOWID.
//
// Note: 
//
//  One cannot modify flows from another process.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DENIED
//          The caller does not have the administrator rights required 
//          to perform this call.
//
ExternC
BOOL
WINAPI
QOSEnumerateFlows(
    __in                HANDLE      QOSHandle,
    __inout             PULONG      Size,
    __out_bcount(*Size) PVOID       Buffer
);

//
// Description:
//
//  API to add a new flow. Note that the flow's traffic is not affected through
//  this call. There are two categories of applications that will use this api:
//  adaptive and non-adaptive. An adaptive application will make use of 
//  notifications and information in QOS_FLOW_FUNDAMENTALS to adapt to changing
//  network characteristics (such as congestion). qWAVE utilizes Link Layer
//  Topology Discovery (LLTD) QoS extensions for adaptive flows, which may be
//  present on the destination. A non-adaptive application either does not 
//  desire to adapt to changing network characteristics (priority marking and/or
//  throttling only), or is sending traffic to an endpoint that does not support
//  this capability as indicated by ERROR_NOT_SUPPORTED. For adaptive 
//  applications, the caller should immediately call QOSSetFlow with the 
//  QOSSetOutgoingRate parameter. Non-adaptive applications or applications 
//  creating non-adaptive flows should call this api with the 
//  QOS_NON_ADAPTIVE_FLOW flag set.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - The socket the application will use to source traffic. 
//                        ***See note below on Socket***
//
//      .DestAddr       - The destination address the application will send 
//                        traffic to. A  destination port must be specified. 
//                        This parameter is optional for connected sockets. See 
//                        the note below.
//
//      .TrafficType    - Describes the type of traffic your flow will be used 
//                        for. This parameter will be ignored when adding a 
//                        socket to an existing flow. 
//
//      .Flags          - Used to modify the behavior of the QOSAddSocketToFlow
//                        call. 
//                        ***See note below on Flags***
//
//      .FlowId         - On input *FlowId MUST be 0 to create a new flow. On 
//                        output, if the call is successful, a flow ID is 
//                        generated and placed in *FlowId. 
//
//                        If you are adding a socket to an existing flow, 
//                        *FlowId will be the flow ID of the existing flow.
//                        ***See note below on Flags***
//
// Note on Socket: 
//
//  If the app wishes to use a different interface to source its data
//  than the one favored by the routing table, it should bind its socket 
//  before calling QOSAddSocketToFlow.
//
// Note on the DestAddr parameter:
//
//  The DestAddr parameter is optional. Since the Qwave api must always 
//  know the destination host (and IP port) to which your traffic will be 
//  sent here are the ramifications:
//
//      1) If your socket is not connected, you MUST specify this parameter. 
//      2) If your socket is connected, you do not need to specify this 
//         parameter however, if you do, the destination host and port must 
//         match that use in the socket's connect call.
//      3) Since, for TCP, the connect call incurs a delay (dependent on  
//         network conditions and the peer host) you may start qWave experiments
//         beforehand. You would call QOSAddSocketToFlow passing in the  
//         application's peer IP address and port.
//
// Note on TrafficType: 
// 
//  Its worth noting that traffic types, if policy allows, will map to a 
//  protocol level tagging of your traffic. For example, the traffic types 
//  equivalent to DLNA may result in the DSCP markings specified in DLNA 
//  being applied. Whether marking is applied, and if so which value, is 
//  controlled by the policy system. In effect this is a request which may,
//  or may not, as appropriate for the network infrastructure, be honored.
//
//  Policy may also require that you run through some form of admission 
//  control and bind yourself to a contract. This is useful to prevent
//  applications from swamping the network. Such admission control will
//  rely on both your traffic type and the flow rate of your traffic. When 
//  possible, you should specify the flow rate of your application using the
//  QOSSetFlow call with the QOSSetOutgoingRate operation.
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSAddSocketToFlow.
//
//      QOS_NON_ADAPTIVE_FLOW - If specified, the QOS subsystem will not gather
//                              data about the network path for this flow. As a 
//                              result, APIs which rely on bandwidth estimation
//                              techniques will not be available. For example, 
//                              this would block QOSQueryFlow with 
//                              QOSQueryFlowFundamentals and QOSNotifyFlow with
//                              QOSNotifyCongested, QOSNotifyUncongested or
//                              QOSNotifyAvailable.
//
//                              An application should use this flag if it does
//                              not intent to adapt its flow to changes in the
//                              state of the network be it because of its
//                              scenario, type of network or capabilities of
//                              the receiving host.
//
//                              You can only add multiple sockets to the same 
//                              flow if the flow is not adaptive. You must also 
//                              specify this flag when you call to add a socket
//                              to an existing flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_CONNECTION_REFUSED
//          QOS could not connect to destination device. The remote host
//          rejected the connection.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSAddSocketToFlow(
    __in        HANDLE              QOSHandle,          
    __in        SOCKET              Socket,
    __in_opt    PSOCKADDR           DestAddr,
    __in        QOS_TRAFFIC_TYPE    TrafficType,
    __in_opt    DWORD               Flags,
    __inout     PQOS_FLOWID         FlowId
);

//
// Description:
//
//  API used by app to notify QOS subsystem that a previously admitted flow has 
//  been terminated by the app. QOS subsystem uses this call to update its 
//  internal information
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - Socket to be removed from the flow
//                        ***See note below on Socket***
//
//      .FlowId         - The flow which the app is interested in modifying. 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSRemoveSocketFromFlow call. This is currently 
//                        reserved for future use.
//
// Note: 
//
//  Closing a QOSHandle will automatically abort all pending operations issued 
//  on that QOSHandle. If the handle is closed while a QOSRemoveSocketFromFlow 
//  call is still in progress, the call will complete with 
//  ERROR_OPERATION_ABORTED. 
//
// Note on Socket: 
// 
//  Only flows created with the QOS_NON_ADAPTIVE_FLOW flag may have multiple
//  sockets added to the same flow. By passing a socket parameter in this
//  api call you can remove each of these individually. 
//
//  If you do not pass a socket, the flow will be destroyed.
//
//  If only one socket was attached to the flow, passing this socket as a 
//  parameter to this api and passing NULL as a socket are equivalent calls.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
ExternC
BOOL
WINAPI
QOSRemoveSocketFromFlow(
    __in        HANDLE              QOSHandle,
    __in_opt    SOCKET              Socket,
    __in        QOS_FLOWID          FlowId,
    __reserved  DWORD               Flags
);

//
// Description:
//
//  This API is used by the app to inform the QOS subsystem of change in a flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in modifying 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Operation      - What modification on the flow you are trying to 
//                        apply. This must be of the type QOS_SET_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to describe the modication.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSSetFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the content of the buffer passed in 
//  will differ. Here is the mapping:
//
//      QOSSetTrafficType           - QOS_TRAFFIC_TYPE
//      QOSSetOutgoingRate          - QOS_FLOWRATE_OUTGOING
//      QOSSetOutgoingDSCPValue     - DWORD
//
//  Specific to QOS_FLOWRATE_OUTGOING structure:
//
//      Bandwidth is defined as number of bits per second. It should include 
//      Layer 3 overhead (e.g. IPv4 header, UDP, etc.). You may want to use the 
//      macro QOS_ADD_OVERHEAD to help you estimate the overhead.
//
//      Using Bandwidth == 0 disables shaping and stops affecting the flow (e.g. 
//      the traffic is not marked anymore). MinPacketSize will be ignored.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NETWORK_BUSY
//          Indicates that the requested flow properties were not available
//          on this path. The network currently cannot support the 
//          characteristics you requested
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
//      ERROR_ACCESS_DENIED
//          The caller does not have the administrator rights required 
//          to perform this call.
//
ExternC
BOOL
WINAPI
QOSSetFlow(
    __in                HANDLE          QOSHandle,          
    __in                QOS_FLOWID      FlowId,             
    __in                QOS_SET_FLOW    Operation,
    __in                ULONG           Size,
    __in_bcount(Size)   PVOID           Buffer,  
    __reserved          DWORD           Flags,
    __out_opt           LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to query information about a flow. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        information about. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What information about the flow you are trying to 
//                        obtain. This must be of the type QOS_QUERY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. If the buffer 
//                        specified is too small, the call will fail with error
//                        ERROR_INSUFFICIENT_BUFFER and this parameter will 
//                        be updated the appropriate buffer size.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSQueryFlow call.
//                        ***See note below on Flags***
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the buffer passed in will differ.
//  Here is the mapping.
//
//      QOSQueryFlowFundamentals    - QOS_FLOW_FUNDAMENTALS
//
//      QOSQueryPacketPriority      - QOS_PACKET_PRIORITY
//
//                                    This structure will return the actual
//                                    priority markings applied to your traffic
//                                    by the QOS subsystem given your asks and
//                                    the policy subsystem.
//
//      QOSQueryOutgoingRate        - UINT64
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSQueryFlow.
//
//      QOS_QUERYFLOW_FRESH -   If specified, the QOS subsystem will only return 
//                              once fresh data is available. If fresh data is 
//                              unavailable, it will try to obtain such data. 
//                              If this is not possible, the call will fail 
//                              with ERROR_RETRY.
//
//                              This flag is only valid for 
//                              QOSQueryFlowFundamentals.
//                              Note, this parameter is ignored if the caller is
//                              not the owner of the flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_INSUFFICIENT_BUFFER
//          The buffer length, as specified through Size, is not sufficient
//          for the queried data. Size now contains the required size.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
ExternC
BOOL
WINAPI
QOSQueryFlow(
    __in                HANDLE              QOSHandle,
    __in                QOS_FLOWID          FlowId,
    __in                QOS_QUERY_FLOW      Operation,
    __inout             PULONG              Size,
    __out_bcount(*Size) PVOID               Buffer,  
    __in_opt            DWORD               Flags,
    __out_opt           LPOVERLAPPED        Overlapped
);

//
// Description:
//
//  API to receive notification of change of network characteristics.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        notifications on changes. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What notification about the flow you are trying to 
//                        obtain. This must be of the type QOS_NOTIFY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSNotifyFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
//
// Note on Operation:
//
//  The following notification may be supported.
//
//  1)  QOSNotifyCongested
//
//      QOSNotifyCongested will complete the operation when the network path
//      is congested. If the path is presently congested, the operation may 
//      complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyUncongested
//
//      QOSNotifyUncongested will complete the operation when the network path
//      is not congested. If the path is not presently congested, the operation 
//      may complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyAvailable
//
//      QOSNotifyAvailable will complete when available capacity is sufficient 
//      to allow an existing flow to be upgraded from its currently admitted
//      bandwidth to the specified bandwidth. This should be used to upgrade a 
//      transrated flow back to full bandwidth.
//      Requested bandwidth should include Layer 3 overhead. Please use the 
//      QOS_ADD_OVERHEAD function inlined in this header file as a starting 
//      point for your calculations.
//
//      The Buffer parameter should point to a UINT64 value with the requested
//      bandwidth. This value should be the target bandwidth of the flow.
//      For example, if your flow is using 3 Mb but you want to increase that 
//      by 2 Mb, the parameter Buffer should point to a UINT64 with the value
//      5 Mb.
//
//      UINT64    Requested bandwidth
//
//      The call will fail if the requested bandwidth is less than or equal 
//      to the bandwidth the flow is already using.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_ALREADY_EXISTS
//          There is already a request for notification of the same type pending
//          on this flow.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
ExternC
BOOL
WINAPI
QOSNotifyFlow(
    __in                        HANDLE          QOSHandle,
    __in                        QOS_FLOWID      FlowId,
    __in                        QOS_NOTIFY_FLOW Operation,
    __inout_opt                 PULONG          Size,
    __inout_bcount_opt(*Size)   PVOID           Buffer,
    __reserved                  DWORD           Flags,
    __out_opt                   LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to cancel a pending operation like QOSSetFlow.
// 
//  Closing a QOSHandle will automatically abort all pending
//  operations issued on that QOSHandle. If the handle is closed while
//  a QOSCancel call is still in progress, the call will complete 
//  with ERROR_OPERATION_ABORTED. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. This is the 
//                        OVERLAPPED structure used in the original operation.
//
// Note: 
//
//  The QOSCancel call must be made in the same process from
//  which the original to-be-cancelled call was made.
// 
// Return Values:
//
//  If the function can successfully initiate cancellation of the specified 
//  operation, the return value is nonzero. The cancelled operation completes 
//  via its completion mechanism and indicates ERROR_OPERATION_ABORTED as the 
//  completion code.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCancel(
    __in    HANDLE          QOSHandle,          
    __in    LPOVERLAPPED    Overlapped
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rdpencomapi_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rdpencomapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIDebug,0xaa1e42b5,0x496d,0x4ca4,0xa6,0x90,0x34,0x8d,0xcb,0x2e,0xc4,0xad);


MIDL_DEFINE_GUID(IID, LIBID_RDPCOMAPILib,0xCC802D05,0xAE07,0x4C15,0xB4,0x96,0xDB,0x9D,0x22,0xAA,0x0A,0x84);


MIDL_DEFINE_GUID(IID, DIID__IRDPSessionEvents,0x98a97042,0x6698,0x40e9,0x8e,0xfd,0xb3,0x20,0x09,0x90,0x00,0x4b);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplication,0x41e7a09d,0xeb7a,0x436e,0x93,0x5d,0x78,0x0c,0xa2,0x62,0x83,0x24);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIWindow,0xbeafe0f9,0xc77b,0x4933,0xba,0x9f,0xa2,0x4c,0xdd,0xcc,0x27,0xcf);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIWindowList,0x8a05ce44,0x715a,0x4116,0xa1,0x89,0xa1,0x18,0xf3,0x0a,0x07,0xbd);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplicationList,0xd4b4aeb3,0x22dc,0x4837,0xb3,0xb6,0x42,0xea,0x25,0x17,0x84,0x9a);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplicationFilter,0xd20f10ca,0x6637,0x4f06,0xb1,0xd5,0x27,0x7e,0xa7,0xe5,0x16,0x0d);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPISessionProperties,0x339b24f2,0x9bc0,0x4f16,0x9a,0xac,0xf1,0x65,0x43,0x3d,0x13,0xd4);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIInvitation,0x4fac1d43,0xfc51,0x45bb,0xb1,0xb4,0x2b,0x53,0xaa,0x56,0x2f,0xa3);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIInvitationManager,0x4722b049,0x92c3,0x4c2d,0x8a,0x65,0xf7,0x34,0x8f,0x64,0x4d,0xcf);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPITcpConnectionInfo,0xf74049a4,0x3d06,0x4028,0x81,0x93,0x0a,0x8c,0x29,0xbc,0x24,0x52);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendee,0xec0671b3,0x1b78,0x4b80,0xa4,0x64,0x91,0x32,0x24,0x75,0x43,0xe3);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendeeManager,0xba3a37e8,0x33da,0x4749,0x8d,0xa0,0x07,0xfa,0x34,0xda,0x79,0x44);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendeeDisconnectInfo,0xc187689f,0x447c,0x44a1,0x9c,0x14,0xff,0xfb,0xb3,0xb7,0xec,0x17);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIVirtualChannel,0x05e12f95,0x28b3,0x4c9a,0x87,0x80,0xd0,0x24,0x85,0x74,0xa1,0xe0);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIVirtualChannelManager,0x0d11c661,0x5d0d,0x4ee4,0x89,0xdf,0x21,0x66,0xae,0x1f,0xdf,0xed);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPISharingSession,0xeeb20886,0xe470,0x4cf6,0x84,0x2b,0x27,0x39,0xc0,0xec,0x5c,0xfb);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIViewer,0xc6bfcd38,0x8ce9,0x404d,0x8a,0xe8,0xf3,0x1d,0x00,0xc6,0x5c,0xb5);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPViewer,0x32be5ed2,0x5c86,0x480f,0xa9,0x14,0x0f,0xf8,0x88,0x5a,0x1b,0x3f);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSession,0x9B78F0E6,0x3E05,0x4A5B,0xB2,0xE8,0xE7,0x43,0xA8,0x95,0x6B,0x65);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPISessionProperties,0xdd7594ff,0xea2a,0x4c06,0x8f,0xdf,0x13,0x2d,0xe4,0x8b,0x65,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIInvitationManager,0x53d9c9db,0x75ab,0x4271,0x94,0x8a,0x4c,0x4e,0xb3,0x6a,0x8f,0x2b);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIInvitation,0x49174dc6,0x0731,0x4b5e,0x8e,0xe1,0x83,0xa6,0x3d,0x38,0x68,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendeeManager,0xd7b13a01,0xf7d4,0x42a6,0x85,0x95,0x12,0xfc,0x8c,0x24,0xe8,0x51);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendee,0x74f93bb5,0x755f,0x488e,0x8a,0x29,0x23,0x90,0x10,0x8a,0xef,0x55);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendeeDisconnectInfo,0xb47d7250,0x5bdb,0x405d,0xb4,0x87,0xca,0xad,0x9c,0x56,0xf4,0xf8);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplicationFilter,0xe35ace89,0xc7e8,0x427e,0xa4,0xf9,0xb9,0xda,0x07,0x28,0x26,0xbd);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplicationList,0x9e31c815,0x7433,0x4876,0x97,0xfb,0xed,0x59,0xfe,0x2b,0xaa,0x22);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplication,0xc116a484,0x4b25,0x4b9f,0x8a,0x54,0xb9,0x34,0xb0,0x6e,0x57,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIWindowList,0x9c21e2b8,0x5dd4,0x42cc,0x81,0xba,0x1c,0x09,0x98,0x52,0xe6,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIWindow,0x03cf46db,0xce45,0x4d36,0x86,0xed,0xed,0x28,0xb7,0x43,0x98,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPITcpConnectionInfo,0xbe49db3f,0xebb6,0x4278,0x8c,0xe0,0xd5,0x45,0x58,0x33,0xea,0xee);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Reason.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------
#if !defined SENTINEL_Reason
# define SENTINEL_Reason
#pragma once

// Reason flags

// Flags used by the various UIs.
#define SHTDN_REASON_FLAG_COMMENT_REQUIRED          0x01000000
#define SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED 0x02000000
#define SHTDN_REASON_FLAG_CLEAN_UI                  0x04000000
#define SHTDN_REASON_FLAG_DIRTY_UI                  0x08000000

// Flags that end up in the event log code.
#define SHTDN_REASON_FLAG_USER_DEFINED          0x40000000
#define SHTDN_REASON_FLAG_PLANNED               0x80000000

// Microsoft major reasons.
#define SHTDN_REASON_MAJOR_OTHER                0x00000000
#define SHTDN_REASON_MAJOR_NONE                 0x00000000
#define SHTDN_REASON_MAJOR_HARDWARE             0x00010000
#define SHTDN_REASON_MAJOR_OPERATINGSYSTEM      0x00020000
#define SHTDN_REASON_MAJOR_SOFTWARE             0x00030000
#define SHTDN_REASON_MAJOR_APPLICATION          0x00040000
#define SHTDN_REASON_MAJOR_SYSTEM               0x00050000
#define SHTDN_REASON_MAJOR_POWER                0x00060000
#define SHTDN_REASON_MAJOR_LEGACY_API           0x00070000

// Microsoft minor reasons.
#define SHTDN_REASON_MINOR_OTHER                0x00000000
#define SHTDN_REASON_MINOR_NONE                 0x000000ff
#define SHTDN_REASON_MINOR_MAINTENANCE          0x00000001
#define SHTDN_REASON_MINOR_INSTALLATION         0x00000002
#define SHTDN_REASON_MINOR_UPGRADE              0x00000003
#define SHTDN_REASON_MINOR_RECONFIG             0x00000004
#define SHTDN_REASON_MINOR_HUNG                 0x00000005
#define SHTDN_REASON_MINOR_UNSTABLE             0x00000006
#define SHTDN_REASON_MINOR_DISK                 0x00000007
#define SHTDN_REASON_MINOR_PROCESSOR            0x00000008
#define SHTDN_REASON_MINOR_NETWORKCARD          0x00000009
#define SHTDN_REASON_MINOR_POWER_SUPPLY         0x0000000a
#define SHTDN_REASON_MINOR_CORDUNPLUGGED        0x0000000b
#define SHTDN_REASON_MINOR_ENVIRONMENT          0x0000000c
#define SHTDN_REASON_MINOR_HARDWARE_DRIVER      0x0000000d
#define SHTDN_REASON_MINOR_OTHERDRIVER          0x0000000e
#define SHTDN_REASON_MINOR_BLUESCREEN           0x0000000F
#define SHTDN_REASON_MINOR_SERVICEPACK          0x00000010
#define SHTDN_REASON_MINOR_HOTFIX               0x00000011
#define SHTDN_REASON_MINOR_SECURITYFIX          0x00000012
#define SHTDN_REASON_MINOR_SECURITY             0x00000013
#define SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000014
#define SHTDN_REASON_MINOR_WMI                  0x00000015 
#define SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000016
#define SHTDN_REASON_MINOR_HOTFIX_UNINSTALL     0x00000017
#define SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000018
#define SHTDN_REASON_MINOR_MMC                  0x00000019
#define SHTDN_REASON_MINOR_SYSTEMRESTORE        0x0000001a
#define SHTDN_REASON_MINOR_TERMSRV              0x00000020
#define SHTDN_REASON_MINOR_DC_PROMOTION         0x00000021
#define SHTDN_REASON_MINOR_DC_DEMOTION          0x00000022

#define SHTDN_REASON_UNKNOWN                    SHTDN_REASON_MINOR_NONE
#define SHTDN_REASON_LEGACY_API                 (SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED)

// This mask cuts out UI flags.
#define SHTDN_REASON_VALID_BIT_MASK             0xc0ffffff

// Convenience flags.
#define PCLEANUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_CLEAN_UI)
#define UCLEANUI                (SHTDN_REASON_FLAG_CLEAN_UI)
#define PDIRTYUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_DIRTY_UI)
#define UDIRTYUI                (SHTDN_REASON_FLAG_DIRTY_UI)

/*
 * Maximum character lengths for reason name, description, problem id, and
 * comment respectively.
 */
#define MAX_REASON_NAME_LEN  64
#define MAX_REASON_DESC_LEN  256
#define MAX_REASON_BUGID_LEN 32
#define MAX_REASON_COMMENT_LEN  512
#define SHUTDOWN_TYPE_LEN 32

/*
 *	S.E.T. policy value
 *
 */
#define POLICY_SHOWREASONUI_NEVER				0
#define POLICY_SHOWREASONUI_ALWAYS				1
#define POLICY_SHOWREASONUI_WORKSTATIONONLY		2
#define POLICY_SHOWREASONUI_SERVERONLY			3


/*
 * Snapshot policy values
 */
#define SNAPSHOT_POLICY_NEVER            0
#define SNAPSHOT_POLICY_ALWAYS           1
#define SNAPSHOT_POLICY_UNPLANNED        2

/*
 * Maximue user defined reasons
 */
#define MAX_NUM_REASONS 256

#endif // !defined SENTINEL_Reason
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Query.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for query.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __query_h__
#define __query_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif 	/* __ISearchQueryHits_FWD_DEFINED__ */


#ifndef __IRowsetQueryStatus_FWD_DEFINED__
#define __IRowsetQueryStatus_FWD_DEFINED__
typedef interface IRowsetQueryStatus IRowsetQueryStatus;
#endif 	/* __IRowsetQueryStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "filter.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IQueryStructures_INTERFACE_DEFINED__
#define __IQueryStructures_INTERFACE_DEFINED__

/* interface IQueryStructures */
/* [unique][uuid] */ 

#define DBQUERYGUID  { 0x49691C90, \
                       0x7E17, 0x101A, \
                       0xA9, 0x1C, 0x08, 0x00, 0x2B, \
                       0x2E, 0xCD, 0xA9 } 
#define	DISPID_QUERY_RANKVECTOR	( 2 )

#define	DISPID_QUERY_RANK	( 3 )

#define	DISPID_QUERY_HITCOUNT	( 4 )

#define	DISPID_QUERY_WORKID	( 5 )

#define	DISPID_QUERY_ALL	( 6 )

#define	DISPID_QUERY_UNFILTERED	( 7 )

#define	DISPID_QUERY_REVNAME	( 8 )

#define	DISPID_QUERY_VIRTUALPATH	( 9 )

#define	DISPID_QUERY_LASTSEENTIME	( 10 )

#define	CQUERYDISPIDS	( 11 )

#define PSGUID_QUERY_METADATA { 0x624C9360, \
                                0x93D0, 0x11CF, \
                                0xA7, 0x87, 0x00, 0x00, 0x4C, \
                                0x75, 0x27, 0x52 } 
#define	DISPID_QUERY_METADATA_VROOTUSED	( 2 )

#define	DISPID_QUERY_METADATA_VROOTAUTOMATIC	( 3 )

#define	DISPID_QUERY_METADATA_VROOTMANUAL	( 4 )

#define	DISPID_QUERY_METADATA_PROPGUID	( 5 )

#define	DISPID_QUERY_METADATA_PROPDISPID	( 6 )

#define	DISPID_QUERY_METADATA_PROPNAME	( 7 )

#define	DISPID_QUERY_METADATA_STORELEVEL	( 8 )

#define	DISPID_QUERY_METADATA_PROPMODIFIABLE	( 9 )

#define	CQUERYMETADISPIDS	( 10 )

#define DBBMKGUID { 0xC8B52232L, \
                 0x5CF3, 0x11CE, \
                 {0xAD, 0xE5, 0x00, 0xAA, 0x00, \
                  0x44, 0x77, 0x3D } }
#define	PROPID_DBBMK_BOOKMARK	( 2 )

#define	PROPID_DBBMK_CHAPTER	( 3 )

#define	CDBBMKDISPIDS	( 8 )

#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define	PROPID_DBSELF_SELF	( 2 )

#define	CDBSELFDISPIDS	( 8 )

#define	CDBCOLDISPIDS	( 28 )

#define	CQUERYPROPERTY	( 64 )

#define PSGUID_CHARACTERIZATION { 0x560c36c0, \
                                  0x503a, 0x11cf, \
                                  0xba, 0xa1, 0x00, 0x00, \
                                  0x4c, 0x75, 0x2a, 0x9a } 
#define	QUERY_VALIDBITS	( 3 )

#define	RTNone	( 0 )

#define	RTAnd	( 1 )

#define	RTOr	( 2 )

#define	RTNot	( 3 )

#define	RTContent	( 4 )

#define	RTProperty	( 5 )

#define	RTProximity	( 6 )

#define	RTVector	( 7 )

#define	RTNatLanguage	( 8 )

typedef struct tagRESTRICTION RESTRICTION;

typedef struct tagNOTRESTRICTION
    {
    RESTRICTION *pRes;
    } 	NOTRESTRICTION;

typedef struct tagNODERESTRICTION
    {
    ULONG cRes;
    RESTRICTION **paRes;
    ULONG reserved;
    } 	NODERESTRICTION;

#define	VECTOR_RANK_MIN	( 0 )

#define	VECTOR_RANK_MAX	( 1 )

#define	VECTOR_RANK_INNER	( 2 )

#define	VECTOR_RANK_DICE	( 3 )

#define	VECTOR_RANK_JACCARD	( 4 )

typedef struct tagVECTORRESTRICTION
    {
    NODERESTRICTION Node;
    ULONG RankMethod;
    } 	VECTORRESTRICTION;

#define	GENERATE_METHOD_EXACT	( 0 )

#define	GENERATE_METHOD_PREFIXMATCH	( 1 )

#define	GENERATE_METHOD_STEMMED	( 2 )

typedef struct tagCONTENTRESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    ULONG ulGenerateMethod;
    } 	CONTENTRESTRICTION;

typedef struct tagNATLANGUAGERESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    } 	NATLANGUAGERESTRICTION;

#define	PRLT	( 0 )

#define	PRLE	( 1 )

#define	PRGT	( 2 )

#define	PRGE	( 3 )

#define	PREQ	( 4 )

#define	PRNE	( 5 )

#define	PRRE	( 6 )

#define	PRAllBits	( 7 )

#define	PRSomeBits	( 8 )

#define	PRAll	( 0x100 )

#define	PRAny	( 0x200 )

typedef struct tagPROPERTYRESTRICTION
    {
    ULONG rel;
    FULLPROPSPEC prop;
    PROPVARIANT prval;
    } 	PROPERTYRESTRICTION;


struct tagRESTRICTION
    {
    ULONG rt;
    ULONG weight;
    union _URes
        {
        NODERESTRICTION ar;
        NODERESTRICTION or;
        NODERESTRICTION pxr;
        VECTORRESTRICTION vr;
        NOTRESTRICTION nr;
        CONTENTRESTRICTION cr;
        NATLANGUAGERESTRICTION nlr;
        PROPERTYRESTRICTION pr;
         /* Empty union arm */ 
        } 	res;
    } ;
typedef struct tagCOLUMNSET
    {
    ULONG cCol;
    FULLPROPSPEC *aCol;
    } 	COLUMNSET;

#define	QUERY_SORTASCEND	( 0 )

#define	QUERY_SORTDESCEND	( 1 )

#define	QUERY_SORTXASCEND	( 2 )

#define	QUERY_SORTXDESCEND	( 3 )

#define	QUERY_SORTDEFAULT	( 4 )

typedef struct tagSORTKEY
    {
    FULLPROPSPEC propColumn;
    ULONG dwOrder;
    LCID locale;
    } 	SORTKEY;

typedef struct tagSORTSET
    {
    ULONG cCol;
    SORTKEY *aCol;
    } 	SORTSET;

#define	CATEGORIZE_UNIQUE	( 0 )

#define	CATEGORIZE_CLUSTER	( 1 )

#define	CATEGORIZE_BUCKETS	( 2 )

#define	BUCKET_LINEAR	( 0 )

#define	BUCKET_EXPONENTIAL	( 1 )

typedef struct tagBUCKETCATEGORIZE
    {
    ULONG cBuckets;
    ULONG Distribution;
    } 	BUCKETCATEGORIZE;

#define	CATEGORIZE_RANGE	( 3 )

typedef struct tagRANGECATEGORIZE
    {
    ULONG cRange;
    PROPVARIANT *aRangeBegin;
    } 	RANGECATEGORIZE;

typedef struct tagCATEGORIZATION
    {
    ULONG ulCatType;
    union 
        {
        ULONG cClusters;
        BUCKETCATEGORIZE bucket;
        RANGECATEGORIZE range;
         /* Empty union arm */ 
        } 	;
    COLUMNSET csColumns;
    } 	CATEGORIZATION;

typedef struct tagCATEGORIZATIONSET
    {
    ULONG cCat;
    CATEGORIZATION *aCat;
    } 	CATEGORIZATIONSET;

typedef unsigned long OCCURRENCE;

#define	OCC_INVALID	( 0xffffffff )

#define	MAX_QUERY_RANK	( 1000 )



extern RPC_IF_HANDLE IQueryStructures_v0_0_c_ifspec;
extern RPC_IF_HANDLE IQueryStructures_v0_0_s_ifspec;
#endif /* __IQueryStructures_INTERFACE_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchQueryHits * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchQueryHits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchQueryHits * This);
        
        SCODE ( STDMETHODCALLTYPE *Init )( 
            ISearchQueryHits * This,
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE *NextHitMoniker )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk);
        
        SCODE ( STDMETHODCALLTYPE *NextHitOffset )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchQueryHits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchQueryHits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchQueryHits_Init(This,pflt,ulFlags)	\
    ( (This)->lpVtbl -> Init(This,pflt,ulFlags) ) 

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)	\
    ( (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk) ) 

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)	\
    ( (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchQueryHits_INTERFACE_DEFINED__ */


#ifndef __IRowsetQueryStatus_INTERFACE_DEFINED__
#define __IRowsetQueryStatus_INTERFACE_DEFINED__

/* interface IRowsetQueryStatus */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IRowsetQueryStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7ac77ed-f8d7-11ce-a798-0020f8008024")
    IRowsetQueryStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusEx( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetQueryStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRowsetQueryStatus * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRowsetQueryStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRowsetQueryStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusEx )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal);
        
        END_INTERFACE
    } IRowsetQueryStatusVtbl;

    interface IRowsetQueryStatus
    {
        CONST_VTBL struct IRowsetQueryStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetQueryStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRowsetQueryStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRowsetQueryStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRowsetQueryStatus_GetStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus) ) 

#define IRowsetQueryStatus_GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal)	\
    ( (This)->lpVtbl -> GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRowsetQueryStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_query_0000_0003 */
/* [local] */ 

#include <indexsrv.h>


extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Ras.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ras.h

Abstract:

    Remote Access external API

    WINVER values in this file:
        WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
        WINVER = 0x400 = Windows 95, Windows98, Windows NT4 (default)
        WINVER > 0x400 = Windows NT4 enhancements
        WINVER = 0x500 = Windows 2000

--*/

#ifndef _RAS_H_
#define _RAS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)//nameless struct/union

#ifndef UNLEN
#include <lmcons.h>
#endif

// To use Quarantine APIs, applications should explicitly 
// define USES_RAS_QUARANTINE_APIS.
#ifdef USES_RAS_QUARANTINE_APIS
#include <naptypes.h>

#define RASNAP_ProbationTime            0x00000001

typedef struct _tagRasNapState
{
    DWORD          dwSize;
    DWORD          dwFlags;
    IsolationState isolationState;
    ProbationTime  probationTime;
} RASNAPSTATE, *LPRASNAPSTATE;
#endif // USES_RAS_QUARANTINE_APIS

#include <pshpack4.h>
#include <inaddr.h>
#include <in6addr.h>

/* RAS API Version
*/
#define RASAPIVERSION enum RASAPIVERSION
RASAPIVERSION
{
    RASAPIVERSION_500 = 1,
    RASAPIVERSION_501,
    RASAPIVERSION_600,
    RASAPIVERSION_601,
};

#define RASAPIVERSION_CURRENT   RASAPIVERSION_601

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#if (WINVER >= 0x600)

/* A RAS IPv4 address.
*/
typedef struct in_addr RASIPV4ADDR;

/* A RAS IPv6 address.
*/
typedef struct in6_addr RASIPV6ADDR;
#endif

#if (WINVER >= 0x601)

#define RASTUNNELENDPOINT_UNKNOWN      0
#define RASTUNNELENDPOINT_IPv4         1
#define RASTUNNELENDPOINT_IPv6         2

/* RAS Tunnel endpoint address
*/
#define RASTUNNELENDPOINT struct tagRASTUNNELENDPOINT
RASTUNNELENDPOINT
{
    DWORD dwType;
    union {
        RASIPV4ADDR ipv4;
        RASIPV6ADDR ipv6;
    };
};

#endif

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200
#define RAS_MaxReplyMessage   1024
#define RAS_MaxDnsSuffix      256

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*

#if (WINVER >= 0x501)
#define RASCF_AllUsers        0x00000001
#define RASCF_GlobalCreds     0x00000002
#define RASCF_OwnerKnown      0x00000004
#define RASCF_OwnerMatch      0x00000008

#define RASCF_IsOwner(rascFlags)    (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown | RASCF_OwnerMatch))
#define RASCF_IsNotOwner(rascFlags) (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown))
#endif

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED    0x1000
#define RASCS_DONE      0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,
#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,
#if (WINVER >= 0x601)
    RASCS_ApplySettings,
#endif
    
    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,
#if (WINVER >= 0x500)
    RASCS_InvokeEapUI,
#endif

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*

#if (WINVER >= 0x601)

#define RASCSS_DONE      0x2000

#define RASCONNSUBSTATE enum tagRASCONNSUBSTATE
RASCONNSUBSTATE
{
    RASCSS_None = 0,
    RASCSS_Dormant,
    RASCSS_Reconnecting,
    RASCSS_Reconnected = RASCSS_DONE,
};

#define LPRASCONNSUBSTATE RASCONNSUBSTATE*

#endif

/* Describes the status of a RAS connection.  (See RasGetConnectStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
#if (WINVER >= 0x601)
    RASTUNNELENDPOINT localEndPoint;
    RASTUNNELENDPOINT remoteEndPoint;
    RASCONNSUBSTATE   rasconnsubstate;
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
#if (WINVER >= 0x601)
    RASTUNNELENDPOINT localEndPoint;
    RASTUNNELENDPOINT remoteEndPoint;
    RASCONNSUBSTATE   rasconnsubstate;
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
#if (WINVER >= 0x601)
    DWORD dwIfIndex;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
#if (WINVER >= 0x601)
    DWORD dwIfIndex;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*

#if (WINVER >= 0x500)

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

#endif

#if (WINVER >= 0x601)
typedef struct tagRASDEVSPECIFICINFO
{
    DWORD   dwSize;
    BYTE   *pbDevSpecificInfo;
} RASDEVSPECIFICINFO, *PRASDEVSPECIFICINFO;


#endif

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD      dwSize;
    DWORD      dwfOptions;
    HWND       hwndParent;
    ULONG_PTR  reserved;
#if (WINVER >= 0x500)
    ULONG_PTR  reserved1;
    RASEAPINFO RasEapInfo;
#endif
#if (WINVER >= 0x601)
    BOOL                fSkipPppAuth;
    RASDEVSPECIFICINFO  RasDevSpecificInfo;
#endif 
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400
#define RDEOPT_Router                    0x00000800

#if (WINVER >= 0x500)
#define RDEOPT_CustomDial                0x00001000
#endif

#if (WINVER >= 0x501)
#define RDEOPT_UseCustomScripting        0x00002000
#endif

//
// This flag when set in the RASENTRYNAME structure
// indicates that the phonebook to which this entry
// belongs is a system phonebook.
//
#define REN_User                         0x00000000
#define REN_AllUsers                     0x00000001


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    //
    // If this flag is REN_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];
#endif
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
#endif

};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x500)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
#if (WINVER >= 0x600)
    RASP_PppIpv6 = 0x8057,   // To get Ipv6 projection information
#endif
#if (WINVER < 0x600) // SLIP
    RASP_Slip = 0x20000
#endif // (WINVER < 0x600) // SLIP
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/

#if (WINVER >= 0x500)

/* RASPPPIP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASIPO_VJ       0x00000001

#endif

#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*

/* Describes the results of a Ipv6 projection info
*/
#if (WINVER >= 0x600)

#define RASPPPIPV6 struct tagRASPPPIPV6
RASPPPIPV6
{
    DWORD dwSize;
    DWORD dwError;
    BYTE  bLocalInterfaceIdentifier[8];
    BYTE  bPeerInterfaceIdentifier[8];
    BYTE  bLocalCompressionProtocol[2];
    BYTE  bPeerCompressionProtocol[2];
};

#define LPRASPPPIPV6  RASPPPIPV6*
#endif
  

/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#if (WINVER >= 0x500)

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80
#define RASLCPAD_CHAP_MSV2    0x81

/* RASPPPLCP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASLCPO_PFC           0x00000001
#define RASLCPO_ACFC          0x00000002
#define RASLCPO_SSHF          0x00000004
#define RASLCPO_DES_56        0x00000008
#define RASLCPO_3_DES         0x00000010

#if (WINVER >= 0x600)
#define RASLCPO_AES_128       0x00000020
#define RASLCPO_AES_256       0x00000040
#endif /* WINVER >= 0x0600 */

#endif


#define RASPPPLCPW struct tagRASPPPLCPW
RASPPPLCPW
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    WCHAR szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};

#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    CHAR  szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};


#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#if (WINVER < 0x600) // SLIP

/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*

#endif // SLIP

#if (WINVER >= 0x500)

/* Describes the results of a PPP CCP (Compression Control Protocol)
projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC             0x00000006
#define RASCCPCA_STAC             0x00000005

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression       0x00000001
#define RASCCPO_HistoryLess       0x00000002
#define RASCCPO_Encryption56bit   0x00000010
#define RASCCPO_Encryption40bit   0x00000020
#define RASCCPO_Encryption128bit  0x00000040

#define RASPPPCCP struct tagRASPPPCCP
RASPPPCCP
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#define LPRASPPPCCP  RASPPPCCP*

#endif

/* 
** New Projection Information structure for PPP and IKEv2
** 
*/
#if (WINVER >= 0x601)

typedef struct _RASPPP_PROJECTION_INFO {

    // IPv4 Projection Parameters
    DWORD        dwIPv4NegotiationError;
    RASIPV4ADDR  ipv4Address;
    RASIPV4ADDR  ipv4ServerAddress;
    DWORD        dwIPv4Options;
    DWORD        dwIPv4ServerOptions;

    // IPv6 Projection Parameters
    DWORD        dwIPv6NegotiationError;
    BYTE         bInterfaceIdentifier[8];
    BYTE         bServerInterfaceIdentifier[8];

    // LCP Options
    BOOL         fBundled;
    BOOL         fMultilink;
    DWORD        dwAuthenticationProtocol;
    DWORD        dwAuthenticationData;
    DWORD        dwServerAuthenticationProtocol;
    DWORD        dwServerAuthenticationData;
    DWORD        dwEapTypeId;
    DWORD        dwServerEapTypeId;
    DWORD        dwLcpOptions;
    DWORD        dwLcpServerOptions;

    // CCP options
    DWORD        dwCcpError;
    DWORD        dwCcpCompressionAlgorithm;
    DWORD        dwCcpServerCompressionAlgorithm;
    DWORD        dwCcpOptions;
    DWORD        dwCcpServerOptions;
}
RASPPP_PROJECTION_INFO, *PRASPPP_PROJECTION_INFO;

/* RASIKEV2_PROJECTION_INFO 'dwFlags' values.
*/
#define RASIKEv2_FLAGS_MOBIKESUPPORTED     0x00000001
#define RASIKEv2_FLAGS_BEHIND_NAT          0x00000002
#define RASIKEv2_FLAGS_SERVERBEHIND_NAT    0x00000004

/* RASIKEV2_PROJECTION_INFO 'dwAuthenticatonProtocol' values.
*/
#define RASIKEv2_AUTH_MACHINECERTIFICATES  1
#define RASIKEv2_AUTH_EAP                  2

typedef struct _RASIKEV2_PROJECTION_INFO {

    // IPv4 Projection Parameters
    DWORD         dwIPv4NegotiationError;
    RASIPV4ADDR   ipv4Address;
    RASIPV4ADDR   ipv4ServerAddress;

    // IPv6 Projection Parameters
    DWORD         dwIPv6NegotiationError;
    RASIPV6ADDR   ipv6Address;
    RASIPV6ADDR   ipv6ServerAddress;
    DWORD         dwPrefixLength;

    // AUTH
    DWORD         dwAuthenticationProtocol;
    DWORD         dwEapTypeId;

    DWORD         dwFlags;
    DWORD         dwEncryptionMethod;

    DWORD         numIPv4ServerAddresses;
    RASIPV4ADDR*  ipv4ServerAddresses;
    DWORD         numIPv6ServerAddresses;
    RASIPV6ADDR*  ipv6ServerAddresses;
}
RASIKEV2_PROJECTION_INFO, *PRASIKEV2_PROJECTION_INFO;

typedef enum _RASPROJECTION_INFO_TYPE {

    PROJECTION_INFO_TYPE_PPP = 1,
    PROJECTION_INFO_TYPE_IKEv2,
}
RASPROJECTION_INFO_TYPE;

typedef struct _RAS_PROJECTION_INFO { 

    RASAPIVERSION             version;
    RASPROJECTION_INFO_TYPE   type;
    
    // Based on the connectionFlags, it should use appropriate projection info 
    union {
        RASPPP_PROJECTION_INFO     ppp;
        RASIKEV2_PROJECTION_INFO   ikev2;
    };
}
RAS_PROJECTION_INFO, *PRAS_PROJECTION_INFO;

#endif

/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( ULONG_PTR, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

#if (WINVER >= 0x500)

#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.

#endif

#define VS_Default      0   // default (PPTP for now)
#define VS_PptpOnly     1   // Only PPTP is attempted.
#define VS_PptpFirst    2   // PPTP is tried first.
#define VS_L2tpOnly     3   // Only L2TP is attempted.
#define VS_L2tpFirst    4   // L2TP is tried first.

#if (WINVER >= 0x600)
#define VS_SstpOnly     5   // Only SSTP is attempted
#define VS_SstpFirst    6   // SSTP is attempted first
#endif

#if (WINVER >= 0x601)
#define VS_Ikev2Only    7   // Only VPN Ikev2 is attempted
#define VS_Ikev2First   8   // VPN Ikev2 is attempted first
#endif

#if (WINVER >= 0x601)
#define VS_PptpSstp     12  // PPTP is attempted followed only by SSTP
#define VS_L2tpSstp     13  // L2TP is attempted followed only by SSTP
#define VS_Ikev2Sstp    14  // IKEv2 is attempted followed only by SSTP
#endif

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    CHAR        szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    CHAR        szPrerequisitePbk[MAX_PATH];

    CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif

#if (WINVER >= 0x600)
    //
    // PPP/IPv6
    //
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif

#if (WINVER >= 0x601)
    // Fields required for supporting static IPv6 address 
    // configuration for a vpn interface by the user 
    RASIPV6ADDR   ipv6addr;
    DWORD         dwIPv6PrefixLength;

    //
    // IKEv2 related
    DWORD         dwNetworkOutageTime;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    WCHAR       szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    WCHAR       szPrerequisitePbk[MAX_PATH];

    WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif

#if (WINVER >= 0x600)
    //
    // PPP/IPv6
    //
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif

#if (WINVER >= 0x601)
    //Fields required for supporting static IPv6 address 
    // configuration for a vpn interface by the user
    RASIPV6ADDR   ipv6addr;
    DWORD         dwIPv6PrefixLength;

    //
    // IKEv2 related
    DWORD         dwNetworkOutageTime;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000

#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

#if (WINVER >= 0x500)
#define RASEO_RequireEAP                0x00020000
#define RASEO_RequirePAP                0x00040000
#define RASEO_RequireSPAP               0x00080000
#define RASEO_Custom                    0x00100000

#define RASEO_PreviewPhoneNumber        0x00200000
#define RASEO_SharedPhoneNumbers        0x00800000
#define RASEO_PreviewUserPw             0x01000000
#define RASEO_PreviewDomain             0x02000000
#define RASEO_ShowDialingProgress       0x04000000
#define RASEO_RequireCHAP               0x08000000
#define RASEO_RequireMsCHAP             0x10000000
#define RASEO_RequireMsCHAP2            0x20000000
#define RASEO_RequireW95MSCHAP          0x40000000
#define RASEO_CustomScript              0x80000000
#endif

#if (WINVER >= 0x501)
//
// RASENTRY dwfOptions2 bit flags
//
#define RASEO2_SecureFileAndPrint       0x00000001
#define RASEO2_SecureClientForMSNet     0x00000002
#define RASEO2_DontNegotiateMultilink   0x00000004
#define RASEO2_DontUseRasCredentials    0x00000008
#define RASEO2_UsePreSharedKey          0x00000010
#define RASEO2_Internet                 0x00000020
#define RASEO2_DisableNbtOverIP         0x00000040
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#define RASEO2_ReconnectIfDropped       0x00000100
#define RASEO2_SharePhoneNumbers        0x00000200
#endif

#if (WINVER >= 0x600)
#define RASEO2_SecureRoutingCompartment     0x00000400
#define RASEO2_UseTypicalSettings           0x00000800
#define RASEO2_IPv6SpecificNameServers      0x00001000
#define RASEO2_IPv6RemoteDefaultGateway     0x00002000
#define RASEO2_RegisterIpWithDNS            0x00004000
#define RASEO2_UseDNSSuffixForRegistration  0x00008000
#define RASEO2_IPv4ExplicitMetric           0x00010000
#define RASEO2_IPv6ExplicitMetric           0x00020000
#define RASEO2_DisableIKENameEkuCheck       0x00040000
#endif

#if (WINVER >= 0x601)
#define RASEO2_DisableClassBasedStaticRoute 0x00080000
#define RASEO2_SpecificIPv6Addr             0x00100000
#define RASEO2_DisableMobility              0x00200000
#define RASEO2_RequireMachineCertificates   0x00400000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004
#if (WINVER >= 0x600)
#define RASNP_Ipv6                      0x00000008
#endif

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")
#define RASDT_Vpn                       TEXT("vpn")
#define RASDT_Pad                       TEXT("pad")
#define RASDT_Generic                   TEXT("GENERIC")
#define RASDT_Serial                    TEXT("SERIAL")
#define RASDT_FrameRelay                TEXT("FRAMERELAY")
#define RASDT_Atm                       TEXT("ATM")
#define RASDT_Sonet                     TEXT("SONET")
#define RASDT_SW56                      TEXT("SW56")
#define RASDT_Irda                      TEXT("IRDA")
#define RASDT_Parallel                  TEXT("PARALLEL")
#if (WINVER >= 0x501)
#define RASDT_PPPoE                     TEXT("PPPoE")
#endif


// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
#define RASET_Phone     1  // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       2  // Virtual private network

#if (WINVER < 0x600)
#define RASET_Direct    3  // Direct connect: serial, parallel
#endif // (WINVER < 0x600)

#define RASET_Internet  4  // BaseCamp internet
#if (WINVER >= 0x501)
#define RASET_Broadband 5  // Broadband
#endif

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x400)

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008
#define RASCN_Dormant           0x00000010
#define RASCN_ReConnection      0x00000020
#endif

#if (WINVER >= 0x401)
/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName           0x00000001
#define RASCM_Password           0x00000002
#define RASCM_Domain             0x00000004
#if (WINVER >= 501)
#define RASCM_DefaultCreds       0x00000008
#define RASCM_PreSharedKey       0x00000010
#define RASCM_ServerPreSharedKey 0x00000020
#define RASCM_DDMPreSharedKey    0x00000040
#endif

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)

#if (WINVER >= 0x500)

/* RasGetEapUserIdentity bit flags.
** These have the same values as the RAS_EAP_FLAG_ flags in raseapif.h
*/
#define RASEAPF_NonInteractive          0x00000002
#define RASEAPF_Logon                   0x00000004
#define RASEAPF_Preview                 0x00000008

/* RasGetEapUserIdentity structure.
*/
#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

#define LPRASEAPUSERIDENTITY  RASEAPUSERIDENTITY*

typedef DWORD (WINAPI *PFNRASGETBUFFER) (
                            PBYTE *ppBuffer,
                            PDWORD pdwSize
                            );

typedef DWORD (WINAPI *PFNRASFREEBUFFER) (
                            PBYTE pBufer);

typedef DWORD (WINAPI *PFNRASSENDBUFFER) (
                            HANDLE hPort,
                            PBYTE  pBuffer,
                            DWORD  dwSize
                            );

typedef DWORD (WINAPI *PFNRASRECEIVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize,
                            DWORD  dwTimeOut,
                            HANDLE hEvent
                            );

typedef DWORD (WINAPI *PFNRASRETRIEVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize
                            );

typedef  DWORD (WINAPI *RasCustomScriptExecuteFn) (
                            HANDLE hPort,
                            LPCWSTR lpszPhonebook,
                            LPCWSTR lpszEntryName,
                            PFNRASGETBUFFER pfnRasGetBuffer,
                            PFNRASFREEBUFFER pfnRasFreeBuffer,
                            PFNRASSENDBUFFER pfnRasSendBuffer,
                            PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
                            PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
                            HWND hWnd,
                            RASDIALPARAMS *pRasDialParams,
                            PVOID pvReserved
                            );

#endif // (WINVER >= 0x500)

#if (WINVER >= 0x0501)

#define RASCOMMSETTINGS struct tagRASCOMMSETTINGS
RASCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
};

typedef DWORD (WINAPI *PFNRASSETCOMMSETTINGS) (
                            HANDLE hPort,
                            RASCOMMSETTINGS *pRasCommSettings,
                            PVOID  pvReserved
                            );

#define RASCUSTOMSCRIPTEXTENSIONS struct tagRASCUSTOMSCRIPTEXTENSIONS
RASCUSTOMSCRIPTEXTENSIONS
{
    DWORD                 dwSize;
    PFNRASSETCOMMSETTINGS pfnRasSetCommSettings;
};

#endif


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( __in_opt LPRASDIALEXTENSIONS, __in_opt LPCSTR, __in LPRASDIALPARAMSA, __in DWORD,
                         __in_opt LPVOID, __out LPHRASCONN );

DWORD APIENTRY RasDialW( __in_opt LPRASDIALEXTENSIONS, __in_opt LPCWSTR, __in LPRASDIALPARAMSW, __in DWORD,
                         __in_opt LPVOID, __out LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( __inout_opt LPRASCONNA, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( __inout_opt LPRASCONNW, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumEntriesA( __in_opt LPCSTR, __in_opt LPCSTR, __inout_opt LPRASENTRYNAMEA, __inout LPDWORD,
                                __out LPDWORD );

DWORD APIENTRY RasEnumEntriesW( __in_opt LPCWSTR, __in_opt LPCWSTR, __inout_opt LPRASENTRYNAMEW, __inout LPDWORD,
                                __out LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( __in HRASCONN, __inout LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( __in HRASCONN, __inout LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( __in UINT ResourceId, __out_bcount(InBufSize) LPSTR lpszString, __in DWORD  InBufSize);

DWORD APIENTRY RasGetErrorStringW( __in UINT ResourceId, __out_bcount(InBufSize) LPWSTR lpszString, __in DWORD  InBufSize);

DWORD APIENTRY RasHangUpA( __in HRASCONN );

DWORD APIENTRY RasHangUpW( __in HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( __in HRASCONN, __in RASPROJECTION, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( __in HRASCONN, __in RASPROJECTION, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( __in HWND, __in_opt LPCSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( __in HWND, __in_opt LPCWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( __in HWND, __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasEditPhonebookEntryW( __in HWND, __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( __in_opt LPCSTR, __in LPRASDIALPARAMSA, __in BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( __in_opt LPCWSTR, __in LPRASDIALPARAMSW, __in BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( __in_opt LPCSTR, __inout LPRASDIALPARAMSA, __out LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( __in_opt LPCWSTR, __inout LPRASDIALPARAMSW, __out LPBOOL );

DWORD APIENTRY RasEnumDevicesA( __inout_opt LPRASDEVINFOA, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumDevicesW( __inout_opt LPRASDEVINFOW, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( __inout_opt LPRASCTRYINFOA, __inout LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( __inout_opt LPRASCTRYINFOW, __inout LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __inout_opt LPRASENTRYA, __inout LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __inout_opt LPRASENTRYW, __inout LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in LPRASENTRYA, __in DWORD, __in_opt LPBYTE, __in DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in LPRASENTRYW, __in DWORD, __in_opt LPBYTE, __in DWORD );

DWORD APIENTRY RasRenameEntryA( __in_opt LPCSTR, __in LPCSTR, __in LPCSTR );

DWORD APIENTRY RasRenameEntryW( __in_opt LPCWSTR, __in LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasDeleteEntryA( __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasDeleteEntryW( __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasValidateEntryNameA( __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasValidateEntryNameW( __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasConnectionNotificationA( __in HRASCONN, __in HANDLE, __in DWORD );

DWORD APIENTRY RasConnectionNotificationW( __in HRASCONN, __in HANDLE, __in DWORD );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( __in HRASCONN, __in DWORD, __out LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( __in HRASCONN, __in DWORD, __out LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( __in_opt LPCSTR, __in LPCSTR, __inout LPRASCREDENTIALSA );

DWORD APIENTRY RasGetCredentialsW( __in_opt LPCWSTR, __in LPCWSTR, __inout LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( __in_opt LPCSTR, __in LPCSTR, __in LPRASCREDENTIALSA, __in BOOL );

DWORD APIENTRY RasSetCredentialsW( __in_opt LPCWSTR, __in LPCWSTR, __in LPRASCREDENTIALSW, __in BOOL );

DWORD APIENTRY RasGetSubEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in DWORD,
                    __inout_opt  LPRASSUBENTRYA, __inout_opt LPDWORD, __out_opt  LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in DWORD,
                    __inout_opt LPRASSUBENTRYW, __inout_opt LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in DWORD, 
                    __in LPRASSUBENTRYA, __in DWORD, __in_opt  LPBYTE, __in DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in DWORD,
                    __in LPRASSUBENTRYW, __in DWORD, __in_opt  LPBYTE, __in DWORD );

DWORD APIENTRY RasGetAutodialAddressA( __in_opt LPCSTR, __in_opt LPDWORD, __inout_opt LPRASAUTODIALENTRYA,
                                       __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( __in_opt LPCWSTR, __in_opt LPDWORD, __inout_opt LPRASAUTODIALENTRYW,
                                       __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasSetAutodialAddressA( __in_opt   LPCSTR, __in DWORD, __in_opt   LPRASAUTODIALENTRYA,
                                       __in DWORD, __in DWORD );

DWORD APIENTRY RasSetAutodialAddressW( __in_opt   LPCWSTR, __in DWORD, __in_opt   LPRASAUTODIALENTRYW,
                                       __in DWORD, __in DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA(
    __inout_bcount_opt(*lpdwcbRasAutodialAddresses) LPSTR *lppRasAutodialAddresses,
    __inout  LPDWORD lpdwcbRasAutodialAddresses,
    __out    LPDWORD lpdwcRasAutodialAddresses);

DWORD APIENTRY RasEnumAutodialAddressesW(
    __inout_bcount_opt(*lpdwcbRasAutodialAddresses) LPWSTR *lppRasAutodialAddresses,
    __inout  LPDWORD lpdwcbRasAutodialAddresses,
    __out    LPDWORD lpdwcRasAutodialAddresses);

DWORD APIENTRY RasGetAutodialEnableA( __in DWORD, __out LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( __in DWORD, __out LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( __in DWORD, __in BOOL );

DWORD APIENTRY RasSetAutodialEnableW( __in DWORD, __in BOOL );

DWORD APIENTRY RasGetAutodialParamA( __in DWORD, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( __in DWORD, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( __in DWORD, __in LPVOID, __in DWORD );

DWORD APIENTRY RasSetAutodialParamW( __in DWORD, __in LPVOID, __in DWORD );

#endif

#if (WINVER >= 0x500)

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;


typedef DWORD (WINAPI *RasCustomHangUpFn) (
                            HRASCONN hRasConn
                            );

typedef DWORD (WINAPI *RasCustomDialFn) (
        HINSTANCE           hInstDll,
        LPRASDIALEXTENSIONS lpRasDialExtensions,
        LPCWSTR             lpszPhonebook,
        LPRASDIALPARAMS     lpRasDialParams,
        DWORD               dwNotifierType,
        LPVOID              lpvNotifier,
        LPHRASCONN          lphRasConn,
        DWORD               dwFlags
        );

typedef DWORD (WINAPI *RasCustomDeleteEntryNotifyFn) (
        LPCWSTR     lpszPhonebook,
        LPCWSTR     lpszEntry,
        DWORD       dwFlags );


#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002
#define RCD_Logon       0x00000004

DWORD APIENTRY RasInvokeEapUI( __in HRASCONN, __in DWORD, __in LPRASDIALEXTENSIONS, __in HWND);

DWORD APIENTRY RasGetLinkStatistics(__in HRASCONN hRasConn,
                                    __in DWORD dwSubEntry,
                                    __inout RAS_STATS *lpStatistics );

DWORD APIENTRY RasGetConnectionStatistics( __in HRASCONN hRasConn,
                                           __inout RAS_STATS *lpStatistics );

DWORD APIENTRY RasClearLinkStatistics(__in HRASCONN hRasConn,
                                      __in DWORD dwSubEntry);


DWORD APIENTRY RasClearConnectionStatistics( __in HRASCONN hRasConn );

DWORD APIENTRY RasGetEapUserDataA(
                   __in_opt HANDLE hToken,
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __out_opt BYTE   *pbEapData,
                   __inout DWORD *pdwSizeofEapData );


DWORD APIENTRY RasGetEapUserDataW(
                   __in_opt HANDLE  hToken,
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __out_opt BYTE    *pbEapData,
                   __inout DWORD *pdwSizeofEapData );

DWORD APIENTRY RasSetEapUserDataA(
                   __in_opt HANDLE hToken,
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __in BYTE   *pbEapData,
                   __in DWORD dwSizeofEapData );

DWORD APIENTRY RasSetEapUserDataW(
                   __in_opt HANDLE  hToken,
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __in BYTE    *pbEapData,
                   __in DWORD dwSizeofEapData );

DWORD APIENTRY RasGetCustomAuthDataA(
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __out_opt BYTE   *pbCustomAuthData,
                   __inout DWORD  *pdwSizeofCustomAuthData );


DWORD APIENTRY RasGetCustomAuthDataW(
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __out_opt BYTE    *pbCustomAuthData,
                   __inout DWORD   *pdwSizeofCustomAuthData );

DWORD APIENTRY RasSetCustomAuthDataA(
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __in BYTE   *pbCustomAuthData,
                   __in DWORD  dwSizeofCustomAuthData
                   );

DWORD APIENTRY RasSetCustomAuthDataW(
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __in BYTE    *pbCustomAuthData,
                   __in DWORD   dwSizeofCustomAuthData
                   );
DWORD APIENTRY RasGetEapUserIdentityW(
                   __in_opt LPCWSTR              pszPhonebook,
                   __in LPCWSTR                  pszEntry,
                   __in DWORD                    dwFlags,
                   __in HWND                     hwnd,
                   __out LPRASEAPUSERIDENTITYW*  ppRasEapUserIdentity
);
DWORD APIENTRY RasGetEapUserIdentityA(
                   __in_opt LPCSTR                   pszPhonebook,
                   __in LPCSTR                   pszEntry,
                   __in DWORD                    dwFlags,
                   __in HWND                     hwnd,
                   __out LPRASEAPUSERIDENTITYA*   ppRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityW(
                   __in LPRASEAPUSERIDENTITYW    pRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityA(
                   __in LPRASEAPUSERIDENTITYA    pRasEapUserIdentity
);
#endif

#if (WINVER >= 0x501)

DWORD APIENTRY  RasDeleteSubEntryA(
                __in_opt LPCSTR pszPhonebook,
                __in LPCSTR pszEntry,
                __in DWORD  dwSubentryId );

DWORD APIENTRY  RasDeleteSubEntryW(
                __in_opt LPCWSTR pszPhonebook,
                __in LPCWSTR pszEntry,
                __in DWORD   dwSubEntryId );


// To use Quarantine APIs, applications should explicitly 
// define USES_RAS_QUARANTINE_APIS.

#ifdef USES_RAS_QUARANTINE_APIS

DWORD APIENTRY
RasGetNapStatus(
        __in HRASCONN hRasconn,
        __out LPRASNAPSTATE pRasNapState);

#endif //USES_RAS_QUARANTINE_APIS

#endif

#if (WINVER >= 0x601)

/* Update an active RAS connection.Localendpoint if specified is used for performing 
/  mobike update.If not specified then dwIfIndex value is used for performing mobike.
/  (See RasUpdateConnection)
*/
#define RASUPDATECONN struct tagRASUPDATECONN
RASUPDATECONN
{
    RASAPIVERSION       version;
    DWORD               dwSize;
    DWORD 		dwFlags;
    DWORD               dwIfIndex;
    RASTUNNELENDPOINT   localEndPoint;
    RASTUNNELENDPOINT   remoteEndPoint;
};

#define LPRASUPDATECONN  RASUPDATECONN*

DWORD APIENTRY
RasUpdateConnection(
        __in HRASCONN        hrasconn,
        __in LPRASUPDATECONN lprasupdateconn);

/* Ras Projection information for PPP or IKEv2
*/
DWORD APIENTRY 
RasGetProjectionInfoEx( 
        __in HRASCONN              hrasconn, 
        __inout_opt PRAS_PROJECTION_INFO  pRasProjection,
        __inout LPDWORD               lpdwSize);

#endif

#ifdef UNICODE
#define RasDial                     RasDialW
#define RasEnumConnections          RasEnumConnectionsW
#define RasEnumEntries              RasEnumEntriesW
#define RasGetConnectStatus         RasGetConnectStatusW
#define RasGetErrorString           RasGetErrorStringW
#define RasHangUp                   RasHangUpW
#define RasGetProjectionInfo        RasGetProjectionInfoW
#define RasCreatePhonebookEntry     RasCreatePhonebookEntryW
#define RasEditPhonebookEntry       RasEditPhonebookEntryW
#define RasSetEntryDialParams       RasSetEntryDialParamsW
#define RasGetEntryDialParams       RasGetEntryDialParamsW
#define RasEnumDevices              RasEnumDevicesW
#define RasGetCountryInfo           RasGetCountryInfoW
#define RasGetEntryProperties       RasGetEntryPropertiesW
#define RasSetEntryProperties       RasSetEntryPropertiesW
#define RasRenameEntry              RasRenameEntryW
#define RasDeleteEntry              RasDeleteEntryW
#define RasValidateEntryName        RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataW
#define RasSetEapUserData           RasSetEapUserDataW
#define RasGetCustomAuthData        RasGetCustomAuthDataW
#define RasSetCustomAuthData        RasSetCustomAuthDataW
#define RasGetEapUserIdentity       RasGetEapUserIdentityW
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityW
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryW
#endif
#else
#define RasDial                     RasDialA
#define RasEnumConnections          RasEnumConnectionsA
#define RasEnumEntries              RasEnumEntriesA
#define RasGetConnectStatus         RasGetConnectStatusA
#define RasGetErrorString           RasGetErrorStringA
#define RasHangUp                   RasHangUpA
#define RasGetProjectionInfo        RasGetProjectionInfoA
#define RasCreatePhonebookEntry     RasCreatePhonebookEntryA
#define RasEditPhonebookEntry       RasEditPhonebookEntryA
#define RasSetEntryDialParams       RasSetEntryDialParamsA
#define RasGetEntryDialParams       RasGetEntryDialParamsA
#define RasEnumDevices              RasEnumDevicesA
#define RasGetCountryInfo           RasGetCountryInfoA
#define RasGetEntryProperties       RasGetEntryPropertiesA
#define RasSetEntryProperties       RasSetEntryPropertiesA
#define RasRenameEntry              RasRenameEntryA
#define RasDeleteEntry              RasDeleteEntryA
#define RasValidateEntryName        RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataA
#define RasSetEapUserData           RasSetEapUserDataA
#define RasGetCustomAuthData        RasGetCustomAuthDataA
#define RasSetCustomAuthData        RasSetCustomAuthDataA
#define RasGetEapUserIdentity       RasGetEapUserIdentityA
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityA
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryA
#endif
#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Raseapif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raseapif.h

Abstract:

    Defines interface between a third party authentication module
    and the Remote Access Service PPP engine.

--*/

#ifndef _RASEAPIF_
#define _RASEAPIF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0500)

//
// Defines used for installtion of EAP DLL
//
// Custom EAP DLL (ex. Name=Sample.dll, Type=(decimal 40) regsitry installation)
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Rasman\PPP\EAP\40)
//      Path                (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      ConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      InteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      IdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      FriendlyName        (REG_SZ) Sample EAP Protocol
//      RequireConfigUI     (REG_DWORD)     1
//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//

#define RAS_EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")

#define RAS_EAP_VALUENAME_PATH                  TEXT("Path")
#define RAS_EAP_VALUENAME_CONFIGUI              TEXT("ConfigUIPath")
#define RAS_EAP_VALUENAME_INTERACTIVEUI         TEXT("InteractiveUIPath")
#define RAS_EAP_VALUENAME_IDENTITY              TEXT("IdentityPath")
#define RAS_EAP_VALUENAME_FRIENDLY_NAME         TEXT("FriendlyName")
#define RAS_EAP_VALUENAME_DEFAULT_DATA          TEXT("ConfigData")
#define RAS_EAP_VALUENAME_REQUIRE_CONFIGUI      TEXT("RequireConfigUI")
#define RAS_EAP_VALUENAME_ENCRYPTION            TEXT("MPPEEncryptionSupported")
#define RAS_EAP_VALUENAME_INVOKE_NAMEDLG        TEXT("InvokeUsernameDialog")
#define RAS_EAP_VALUENAME_INVOKE_PWDDLG         TEXT("InvokePasswordDialog")
#define RAS_EAP_VALUENAME_CONFIG_CLSID          TEXT("ConfigCLSID")
#define RAS_EAP_VALUENAME_STANDALONE_SUPPORTED  TEXT("StandaloneSupported")
#define RAS_EAP_VALUENAME_ROLES_SUPPORTED       TEXT("RolesSupported")
#define RAS_EAP_VALUENAME_PER_POLICY_CONFIG     TEXT("PerPolicyConfig")
#define RAS_EAP_VALUENAME_ISTUNNEL_METHOD       TEXT("IsTunnelMethod")
#define RAS_EAP_VALUENAME_FILTER_INNERMETHODS   TEXT("FilterInnerMethods")


// Flags for RolesSupported.
#define RAS_EAP_ROLE_AUTHENTICATOR   0x00000001
#define RAS_EAP_ROLE_AUTHENTICATEE   0x00000002

//
// Following flags describe the hosting of EAP
// methods in PEAP or in EAP.  If this role is
// missing the default behavior is to show the
// EAP method in PEAP and in EAP.
//
#define RAS_EAP_ROLE_EXCLUDE_IN_EAP  0x00000004
#define RAS_EAP_ROLE_EXCLUDE_IN_PEAP 0x00000008
#define RAS_EAP_ROLE_EXCLUDE_IN_VPN  0x00000010

typedef enum _RAS_AUTH_ATTRIBUTE_TYPE_
{
    raatMinimum = 0,                // Undefined
    raatUserName,                   // Value field is a Pointer
    raatUserPassword,               // Value field is a Pointer
    raatMD5CHAPPassword,            // Value field is a Pointer
    raatNASIPAddress,               // Value field is a 32 bit integral value
    raatNASPort,                    // Value field is a 32 bit integral value
    raatServiceType,                // Value field is a 32 bit integral value
    raatFramedProtocol,             // Value field is a 32 bit integral value
    raatFramedIPAddress,            // Value field is a 32 bit integral value
    raatFramedIPNetmask,            // Value field is a 32 bit integral value
    raatFramedRouting = 10,         // Value field is a 32 bit integral value
    raatFilterId,                   // Value field is a Pointer
    raatFramedMTU,                  // Value field is a 32 bit integral value
    raatFramedCompression,          // Value field is a 32 bit integral value
    raatLoginIPHost,                // Value field is a 32 bit integral value
    raatLoginService,               // Value field is a 32 bit integral value
    raatLoginTCPPort,               // Value field is a 32 bit integral value
    raatUnassigned17,               // Undefined
    raatReplyMessage,               // Value field is a Pointer
    raatCallbackNumber,             // Value field is a Pointer
    raatCallbackId =20,             // Value field is a Pointer
    raatUnassigned21,               // Undefined
    raatFramedRoute,                // Value field is a Pointer
    raatFramedIPXNetwork,           // Value field is a 32 bit integral value
    raatState,                      // Value field is a Pointer
    raatClass,                      // Value field is a Pointer
    raatVendorSpecific,             // Value field is a Pointer
    raatSessionTimeout,             // Value field is a 32 bit integral value
    raatIdleTimeout,                // Value field is a 32 bit integral value
    raatTerminationAction,          // Value field is a 32 bit integral value
    raatCalledStationId = 30,       // Value field is a Pointer
    raatCallingStationId,           // Value field is a Pointer
    raatNASIdentifier,              // Value field is a Pointer
    raatProxyState,                 // Value field is a Pointer
    raatLoginLATService,            // Value field is a Pointer
    raatLoginLATNode,               // Value field is a Pointer
    raatLoginLATGroup,              // Value field is a Pointer
    raatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    raatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    raatFramedAppleTalkZone,        // Value field is a Pointer
    raatAcctStatusType = 40,        // Value field is a 32 bit integral value
    raatAcctDelayTime,              // Value field is a 32 bit integral value
    raatAcctInputOctets,            // Value field is a 32 bit integral value
    raatAcctOutputOctets,           // Value field is a 32 bit integral value
    raatAcctSessionId,              // Value field is a Pointer
    raatAcctAuthentic,              // Value field is a 32 bit integral value
    raatAcctSessionTime,            // Value field is a 32 bit integral value
    raatAcctInputPackets,           // Value field is a 32 bit integral value
    raatAcctOutputPackets,          // Value field is a 32 bit integral value
    raatAcctTerminateCause,         // Value field is a 32 bit integral value
    raatAcctMultiSessionId = 50,    // Value field is a Pointer
    raatAcctLinkCount,              // Value field is a 32 bit integral value
    raatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    raatMD5CHAPChallenge = 60,      // Value field is a Pointer
    raatNASPortType,                // Value field is a 32 bit integral value
    raatPortLimit,                  // Value field is a 32 bit integral value
    raatLoginLATPort,               // Value field is a Pointer
    raatTunnelType,                 // Value field is a 32 bit integral value
    raatTunnelMediumType,           // Value field is a 32 bit integral value
    raatTunnelClientEndpoint,       // Value field is a Pointer
    raatTunnelServerEndpoint,       // Value field is a Pointer
    raatARAPPassword = 70,          // Value field is a Pointer
    raatARAPFeatures,               // Value field is a Pointer
    raatARAPZoneAccess,             // Value field is a 32 bit integral value
    raatARAPSecurity,               // Value field is a 32 bit integral value
    raatARAPSecurityData,           // Value field is a Pointer
    raatPasswordRetry,              // Value field is a 32 bit integral value
    raatPrompt,                     // Value field is a 32 bit integral value
    raatConnectInfo,                // Value field is a Pointer
    raatConfigurationToken,         // Value field is a Pointer
    raatEAPMessage,                 // Value field is a Pointer
    raatSignature = 80,             // Value field is a Pointer
    raatARAPChallengeResponse = 84, // Value field is a Pointer
    raatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    raatNASIPv6Address = 95,
    raatFramedInterfaceId,
    raatFramedIPv6Prefix,
    raatLoginIPv6Host,
    raatFramedIPv6Route,
    raatFramedIPv6Pool,
    raatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    raatCertificateOID,             // Value field is a Pointer
    raatEAPConfiguration,           // Value field is a Pointer
    raatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    raatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    raatEAPTLV = 8102,              // Value field is a Pointer
    raatCredentialsChanged,         // Value field is a Integer with boolean semantics
    raatPeerId = 9000,              // Value field is a pointer
    raatServerId,                   // Value field is a pointer
    raatMethodId,                   // Value field is a pointer
    raatEMSK,                       // Value field is a pointer
    raatSessionId,                  // Value field is a pointer
    raatReserved = 0xFFFFFFFF       // Undefined

}RAS_AUTH_ATTRIBUTE_TYPE;


//
// VSA attribute ids for ARAP
//
#define  raatARAPChallenge              33
#define  raatARAPOldPassword            19
#define  raatARAPNewPassword            20
#define  raatARAPPasswordChangeReason   21

//
// Value is set to the 32 bit integral value or a pointer to data.
// 32 bit integral values should be in host format, not network format.
// Length for a 32 bit integral value can be 1, 2 or 4. The array of
// attributes must be terminated with an attribute of type raatMinimum.
//

typedef struct _RAS_AUTH_ATTRIBUTE
{
    RAS_AUTH_ATTRIBUTE_TYPE raaType;
    DWORD                   dwLength;
    __field_ecount(dwLength) PVOID                   Value;

}RAS_AUTH_ATTRIBUTE, *PRAS_AUTH_ATTRIBUTE;

//
// EAP packet codes from EAP spec.
//

#define EAPCODE_Request         1
#define EAPCODE_Response        2
#define EAPCODE_Success         3
#define EAPCODE_Failure         4

#define MAXEAPCODE              4

//
// Values of the fFlags field in PPP_EAP_INPUT
// These have the same values as the RASEAPF_ flags in ras.h
//

#define RAS_EAP_FLAG_ROUTER                 0x00000001  // This is a router
#define RAS_EAP_FLAG_NON_INTERACTIVE        0x00000002  // No UI should be displayed
#define RAS_EAP_FLAG_LOGON                  0x00000004  // The user data was
                                                        // obtained from Winlogon
#define RAS_EAP_FLAG_PREVIEW                0x00000008  // User has checked
                                                        // "Prompt for information
                                                        // before dialing"
#define RAS_EAP_FLAG_FIRST_LINK             0x00000010  // This is the first link
#define RAS_EAP_FLAG_MACHINE_AUTH           0x00000020  // Use the default machine cert
                                                        // or user cert based on the
                                                        // application logon context
#define RAS_EAP_FLAG_GUEST_ACCESS           0x00000040  // Request to provide guest
                                                        // access.
#define RAS_EAP_FLAG_8021X_AUTH             0x00000080  // Anything specific to 8021x
                                                        // to be done in TLS
#define RAS_EAP_FLAG_HOSTED_IN_PEAP         0x00000100  // This EAP Method is hosted
                                                        // in PEAP
#define RAS_EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200  // Indicates this is the
                                                        // first call after m/c
                                                        // resumed from hibernation.
#define RAS_EAP_FLAG_PEAP_UPFRONT           0x00000400  // Indicate peap is enabled
                                                        // at the beginning of IAS pipeline.
#define RAS_EAP_FLAG_ALTERNATIVE_USER_DB    0x00000800  // The user database is
                                                        // not active directory
#define RAS_EAP_FLAG_PEAP_FORCE_FULL_AUTH   0x00001000  // Indicate peap should not
                                                        //fast reconnect

#define RAS_EAP_FLAG_PRE_LOGON              0x00020000  // Pre logon scenario like PLAP


#define RAS_EAP_FLAG_RESERVED               0x00100000   // PEAP specific flag

#define RAS_EAP_FLAG_SAVE_CREDMAN           0x00200000   // Save credentials to CredMan

typedef struct _PPP_EAP_PACKET
{
    BYTE    Code;       // 1-Request, 2-Response, 3-Success, 4-Failure

    BYTE    Id;         // Id of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    Data[1];    // Data - First byte is Type for Request/Response

}PPP_EAP_PACKET, *PPPP_EAP_PACKET;

#define PPP_EAP_PACKET_HDR_LEN  ( sizeof( PPP_EAP_PACKET ) - 1 )

//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call.
//

typedef struct _PPP_EAP_INPUT
{
    //
    // Size of this structure
    //

    DWORD       dwSizeInBytes;

    //
    // The following five fields are valid only in RasEapBegin call
    //

    DWORD       fFlags;         // See RAS_EAP_FLAG_*

    BOOL        fAuthenticator; // Act as authenticator or authenticatee

    WCHAR *     pwszIdentity;   // Users's identity

    WCHAR *     pwszPassword;   // Client's account password. Only valid when
                                // fAuthenticator is FALSE.

    BYTE        bInitialId;     // Initial packet identifier. Must be used for
                                // the first EAP packet sent by the DLL and
                                // incremented by one for each subsequent
                                // request packet.

    //
    // During the RasEapBegin call on the authenticator side, pUserAttributes
    // contains the set of attributes for the currently dialed in user, e.g.,
    // the port used, NAS IP Address, etc.
    //
    // When the fAuthenticationComplete flag is TRUE, pUserAttributes contains
    // attributes (if any) returned by the authentication provider.
    //
    // This memory is not owned by the EAP DLL and should be treated as
    // read-only.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // The next two fields are used only if the EAP DLL is using the
    // currently configured authentication provider ex: RADIUS or Windows NT
    // domain authentication, and the fAuthenticator field above is set to
    // TRUE.
    //

    //
    // Indicates that the authenticator has completed authentication.
    // Ignore this field if an authentication provider is not being used.
    //

    BOOL                fAuthenticationComplete;

    //
    // Result of the authentication process by the authentication provider.
    // NO_ERROR indicates success, otherwise it is a value from winerror.h,
    // raserror.h or mprerror.h indicating failure reason.
    //

    DWORD               dwAuthResultCode;

    //
    // Valid only on the authenticatee side. This may be used on the
    // authenticatee side to impersonate the user being authenticated.
    //

    OPTIONAL HANDLE     hTokenImpersonateUser;

    //
    // This variable should be examined only by the authenticatee side.
    // The EAP specification states that the success packet may be lost and
    // since it is a non-acknowledged packet, reception of an NCP packet should
    // be interpreted as a success packet. This varable is set to TRUE in this
    // case only on the authenticatee side
    //

    BOOL                fSuccessPacketReceived;

    //
    // Will be set to TRUE only when the user dismissed the interactive
    // UI that was invoked by the EAP dll
    //

    BOOL                fDataReceivedFromInteractiveUI;

    //
    // Data received from the Interactive UI. Will be set to
    // non-NULL when fDataReceivedFromInteractiveUI is set to TRUE and
    // RasEapInvokeInteractiveUI returned non-NULL data. This buffer will be
    // freed by the PPP engine on return from the RasEapMakeMessage call. A
    // copy of this data should be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pDataFromInteractiveUI;

    //
    // Size in bytes of data pointed to by pInteractiveConnectionData. This may
    // be 0 if there was no data passed back by RasEapInvokeInteractiveUI.
    //

    DWORD               dwSizeOfDataFromInteractiveUI;

    //
    // Connection data received from the Config UI. Will be set to non-NULL
    // when the RasEapBegin call is made and the RasEapInvokeConfigUI
    // returned non-NULL data. This buffer will be freed by the PPP engine
    // on return from the RasEapBegin call. A copy of this data should
    // be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pConnectionData;

    //
    // Size in bytes of data pointed to by pConnectionData. This may be
    // 0 if there was no data passed back by the RasEapInvokeConfigUI call.
    //

    DWORD               dwSizeOfConnectionData;

    //
    // User data received from the Identity UI or Interactive UI. Will be set
    // to non-NULL when the RasEapBegin call is made if such data exists.
    // This buffer will be freed by the PPP engine on return from the
    // RasEapBegin call. A copy of this data should be made in the EAP Dll's
    // memory space.
    //

    __field_bcount(dwSizeOfUserData) OPTIONAL PBYTE      pUserData;

    //
    // Size in bytes of data pointed to by pUserData. This may be 0 if there
    // is no data.
    //

    DWORD               dwSizeOfUserData;

    //
    // Reserved.
    //

    HANDLE              hReserved;

}PPP_EAP_INPUT, *PPPP_EAP_INPUT;

typedef enum _PPP_EAP_ACTION
{
    //
    // These actions are provided by the EAP DLL as output from the
    // RasEapMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the EAP DLL's behalf, and eventually inform the engine that the
    // EAP DLL has finished authentication.
    //

    EAPACTION_NoAction,     // Be passive, i.e. listen without timeout (default)
    EAPACTION_Authenticate, // Invoke the back-end authenticator.
    EAPACTION_Done,         // End auth session, dwAuthResultCode is set
    EAPACTION_SendAndDone,  // As above but send message without timeout first
    EAPACTION_Send,         // Send message, don't timeout waiting for reply
    EAPACTION_SendWithTimeout, // Send message, timeout if reply not received
    EAPACTION_SendWithTimeoutInteractive,  // As above, but don't increment
                                           // retry count

	EAPACTION_IndicateTLV,		// Do not use
	EAPACTION_IndicateIdentity	// Do not use
}PPP_EAP_ACTION;

typedef struct _PPP_EAP_OUTPUT
{
    //
    // Size of this structure
    //

    DWORD                   dwSizeInBytes;

    //
    // Action that the PPP engine should take
    //

    PPP_EAP_ACTION          Action;

    //
    // dwAuthResultCode is valid only with an Action code of Done or
    // SendAndDone. Zero value indicates succesful authentication.
    // Non-zero indicates unsuccessful authentication with the value
    // indicating the reason for authentication failure.
    // Non-zero return codes should be only from winerror.h, raserror.h and
    // mprerror.h
    //

    DWORD                   dwAuthResultCode;

    //
    // When Action is EAPACTION_Authenticate, pUserAttributes may contain
    // additional attributes necessary to authenticate the user, e.g.,
    // User-Password. If no credentials are presented, the back-end
    // authenticator will assume the user is authentic and only retrieve
    // authorizations.
    //
    // When Action is EAPACTION_Done, EAPACTION_SendAndDone, or EAPACTION_Send,
    // pUserAttributes may contain additional attributes for the user. These
    // attributes will overwrite any attributes of the same type returned by
    // the back-end authenticator.
    //
    // It is up to the EAP DLL to free this memory in RasEapEnd call.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;
    //
    // Flag set to true will cause the RasEapInvokeInteractiveUI call to be
    // made.
    //

    BOOL                    fInvokeInteractiveUI;

    //
    // Pointer to context data, if any, to be sent to the UI. The EAP dll
    // is responsible for freeing this buffer in the RasEapEnd call or when
    // a response from the user for this invocation is obtained.
    //

    OPTIONAL PBYTE          pUIContextData;

    //
    // Size in bytes of the data pointed to by pUIContextData. Ignored if
    // pUIContextData is NULL
    //

    DWORD                   dwSizeOfUIContextData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pConnectionData should be saved in the phonebook. Only valid on
    // the authenticatee side.
    //

    BOOL                    fSaveConnectionData;

    //
    // If fSaveConnectionData above is true, the data pointed to by
    // pConnectionData will be saved in the phonebook. This data
    // must be freed by the DLL when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pConnectionData;

    //
    // Size, in bytes, of the data pointed to by pConnectionData
    //

    DWORD                   dwSizeOfConnectionData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pUserData should be saved in the registry for this user. Only valid
    // on the authenticatee side.
    //

    BOOL                    fSaveUserData;

    //
    // If fSaveUserData above is true, the data pointed to by pUserData will be
    // saved in the registry for this user. This data must be freed by the DLL
    // when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pUserData;

    //
    // Size, in bytes, of the data pointed to by pUserData
    //

    DWORD                   dwSizeOfUserData;

}PPP_EAP_OUTPUT, *PPPP_EAP_OUTPUT;

typedef struct _PPP_EAP_INFO
{
    //
    // Size of this structure
    //

    DWORD   dwSizeInBytes;

    DWORD   dwEapTypeId;

    //
    // Called to initialize/uninitialize this module. This will be called before
    // any other call is made. fInitialize will be TRUE iff the module has to be
    // initialized. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h
    //

    DWORD   (APIENTRY *RasEapInitialize)(   IN  BOOL        fInitialize );

    //
    // Called to get a context buffer for this EAP session and pass
    // initialization information. This will be called before any other
    // call is made, except RasEapInitialize. Must return errorcodes only from
    // winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapBegin)( OUT VOID **             ppWorkBuffer,
                                     IN  PPP_EAP_INPUT *     pPppEapInput );

    //
    // Called to free the context buffer for this EAP session.
    // Called after this session is completed successfully or not, provided
    // the RasEapBegin call for this EAP session returned successfully.
    // Must return errorcodes only from winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapEnd)(   IN  VOID *     pWorkBuffer );

    //
    // Called to process an incomming packet and/or send a packet.
    // cbSendPacket is the size in bytes of the buffer pointed to by
    // pSendPacket. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h. Error return code indicates an error occurance during the
    // authentication process.
    //

    DWORD   (APIENTRY *RasEapMakeMessage)(
                            IN  VOID*               pWorkBuf,
                            IN  PPP_EAP_PACKET*     pReceivePacket,
                            OUT PPP_EAP_PACKET*     pSendPacket,
                            IN  DWORD               cbSendPacket,
                            OUT PPP_EAP_OUTPUT*     pEapOutput,
                            IN  PPP_EAP_INPUT*      pEapInput );

}PPP_EAP_INFO, *PPPP_EAP_INFO;

//
// RasEapGetInfo should be exported by the 3rd party EAP dll installed in the
// registry via the Path value.
//

DWORD APIENTRY
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pEapInfo
);

//
// RasEapFreeMemory should be exported by the 3rd party EAP dlls installed in
// the registry via the InteractiveUIPath, ConfigUIPath, and IdentityPath
// values.
//

DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*           pMemory
);

//
// RasEapInvokeInteractiveUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the InteractiveUIPath
// value.
//

DWORD APIENTRY
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeOfUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
);

//
// RasEapInvokeConfigUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the ConfigUIPath value.
//

DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    OUT BYTE**          ppConnectionDataOut,
    OUT DWORD*          pdwSizeOfConnectionDataOut
);

//
// RasEapGetIdentity and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the IdentityPath value.
//

DWORD APIENTRY
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT __deref_out     WCHAR** ppwszIdentityOut
);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif // _RASEAPIF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RasError.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raserror.h

Abstract:

    RAS specific error codes
    
--*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
/*
 * An operation is pending.%0
 */

#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
/*
 * An invalid port handle was detected.%0
 */

#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
/*
 * The specified port is already open.%0
 */

#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
/*
 * The caller's buffer is too small.%0
 */

#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
/*
 * Incorrect information was specified.%0
 */

#if (WINVER < 0x600)
//
// The port information cannot be set.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
/*
 * %0
 */
#endif

#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
/*
 * The specified port is not connected.%0
 */

#if (WINVER < 0x600)
//
// An invalid event was detected.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_EVENT_INVALID                  (RASBASE+7)
/*
 * %0
 */
#endif

#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
/*
 * A device was specified that does not exist.%0
 */

#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
/*
 * A device type was specified that does not exist.%0
 */

#define ERROR_BUFFER_INVALID                 (RASBASE+10)
/*
 * An invalid buffer was specified.%0
 */

#if (WINVER < 0x600)
//
// A route was specified that is not available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
/*
 * %0
 */
#endif

#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
/*
 * A route was specified that is not allocated.%0
 */

#if (WINVER < 0x600)
//
// An invalid compression was specified.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
/*
 * %0
 */

//
// There were insufficient buffers available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
/*
 * %0
 */
#endif

#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
/*
 * The specified port was not found.%0
 */ 

#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
/*
 * An asynchronous request is pending.%0
 */

#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
/*
 * The modem (or other connecting device) is already disconnecting.%0
 */

#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
/*
 * The specified port is not open.%0
 */ 

#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
/*
 * A connection to the remote computer could not be established, so the port used for this connection was closed.%0
 */

#if (WINVER < 0x600)
//
//  No endpoints could be determined.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
/*
 * %0
 */
#endif

#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
/*
 * The system could not open the phone book file.%0
 */ 

#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
/*
 * The system could not load the phone book file.%0
 */

#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
/*
 * The system could not find the phone book entry for this connection.%0
 */

#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
/*
 * The system could not update the phone book file.%0
 */

#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
/*
 * The system found invalid information in the phone book file.%0
 */

#if (WINVER < 0x600)
//
// A string could not be loaded.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
/*
 * %0
 */
#endif

#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
/*
 * A key could not be found.%0
 */

#define ERROR_DISCONNECTION                  (RASBASE+28)
/*
 * The connection was terminated by the remote computer before it could be completed.%0
 */ 

#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
/*
 * The connection was closed by the remote computer.%0
 */

#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
/*
 * The modem (or other connecting device) was disconnected due to hardware failure.%0
 */

#define ERROR_USER_DISCONNECTION             (RASBASE+31)
/*
 * The user disconnected the modem (or other connecting device).%0
 */

#define ERROR_INVALID_SIZE                   (RASBASE+32)
/*
 * An incorrect structure size was detected.%0
 */

#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
/*
 * The modem (or other connecting device) is already in use or is not configured properly.%0 
 */

#if (WINVER < 0x600)
//
// Your computer could not be registered on the remote network.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
/*
 * %0
 */
#endif

#define ERROR_UNKNOWN                        (RASBASE+35)
/*
 * There was an unknown error.%0
 */

#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
/*
 * The device attached to the port is not the one expected.%0
 */

#if (WINVER < 0x600)
//
// A string was detected that could not be converted.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_BAD_STRING                     (RASBASE+37)
/*
 * %0
 */
#endif

#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
/*
 * The remote server is not responding in a timely fashion.%0
 */

#if (WINVER < 0x600)
//
// No asynchronous net is available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
/*
 * %0
 */

//
// An error has occurred involving NetBIOS.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
/*
 * %0
 */

//
// The server cannot allocate NetBIOS resources needed to support the client.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
/*
 * %0
 */

//
// One of your computer's NetBIOS names is already registered on the remote network.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
/*
 * %0
 */

//
// A network adapter at the server failed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
/*
 * %0
 */

//
// You will not receive network message popups.
//
// This error was obsoleted in the Windows Vista  release.
//
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
/*
 * %0
 */
#endif

#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
/*
 * There was an internal authentication error.%0
 */

#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
/*
 * The account is not permitted to log on at this time of day.%0
 */

#define ERROR_ACCT_DISABLED                  (RASBASE+47)
/*
 * The account is disabled.%0
 */

#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
/*
 * The password for this account has expired.%0
 */

#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
/*
 * The account does not have permission to dial in.%0
 */

#if (WINVER < 0x600)
//
// The remote access server is not responding.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
/*
 * %0
 */
#endif

#define ERROR_FROM_DEVICE                    (RASBASE+51)
/*
 * The modem (or other connecting device) has reported an error.%0
 */

#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
/*
 * There was an unrecognized response from the modem (or other connecting device).%0
 */

#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
/*
 * A macro required by the modem (or other connecting device) was not found in the device.INF file.%0
 */

#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
/*
 * A command or response in the device.INF file section refers to an undefined macro.%0
 */

#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
/*
 * The <message> macro was not found in the device.INF file section.%0
 */

#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
/*
 * The <defaultoff> macro in the device.INF file section contains an undefined macro.%0
 */

#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
/*
 * The device.INF file could not be opened.%0
 */

#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
/*
 * The device name in the device.INF or media.INI file is too long.%0
 */

#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
/*
 * The media.INI file refers to an unknown device name.%0
 */

#define ERROR_NO_RESPONSES                   (RASBASE+60)
/*
 * The device.INF file contains no responses for the command.%0
 */

#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
/*
 * The device.INF file is missing a command.%0
 */

#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
/*
 * There was an attempt to set a macro not listed in device.INF file section.%0
 */

#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
/*
 * The media.INI file refers to an unknown device type.%0
 */

#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
/*
 * The system has run out of memory.%0
 */

#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
/*
 * The modem (or other connecting device) is not properly configured.%0
 */

#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
/*
 * The modem (or other connecting device) is not functioning.%0
 */

#define ERROR_READING_INI_FILE               (RASBASE+67)
/*
 * The system was unable to read the media.INI file.%0
 */

#define ERROR_NO_CONNECTION                  (RASBASE+68)
/*
 * The connection was terminated.%0
 */

#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
/*
 * The usage parameter in the media.INI file is invalid.%0
 */

#define ERROR_READING_SECTIONNAME            (RASBASE+70)
/*
 * The system was unable to read the section name from the media.INI file.%0
 */

#define ERROR_READING_DEVICETYPE             (RASBASE+71)
/*
 * The system was unable to read the device type from the media.INI file.%0
 */

#define ERROR_READING_DEVICENAME             (RASBASE+72)
/*
 * The system was unable to read the device name from the media.INI file.%0
 */

#define ERROR_READING_USAGE                  (RASBASE+73)
/*
 * The system was unable to read the usage from the media.INI file.%0
 */

#if (WINVER < 0x600)
//
// The system was unable to read the maximum connection BPS rate from the media.INI file.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
/*
 * %0
 */

//
// The system was unable to read the maximum carrier connection speed from the media.INI file.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
/*
 * %0
 */
#endif

#define ERROR_LINE_BUSY                      (RASBASE+76)
/*
 * The phone line is busy.%0
 */

#define ERROR_VOICE_ANSWER                   (RASBASE+77)
/*
 * A person answered instead of a modem (or other connecting device).%0
 */

#define ERROR_NO_ANSWER                      (RASBASE+78)
/*
 * The remote computer did not respond. To make sure that the server can be reached, ping the remote computer.%0
 */

#define ERROR_NO_CARRIER                     (RASBASE+79)
/*
 * The system could not detect the carrier.%0
 */

#define ERROR_NO_DIALTONE                    (RASBASE+80)
/*
 * There was no dial tone.%0
 */

#if (WINVER < 0x600)
//
// The modem (or other connecting device) reported a general error.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IN_COMMAND                     (RASBASE+81)
/*
 * %0
 */

//
// There was an error in writing the section name.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
/*
 * %0
 */

//
// There was an error in writing the device type.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
/*
 * %0
 */

//
// There was an error in writing the device name.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
/*
 * %0
 */

//
// There was an error in writing the maximum connection speed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
/*
 * %0
 */

//
// There was an error in writing the maximum carrier speed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
/*
 * %0
 */

//
// There was an error in writing the usage.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_USAGE                  (RASBASE+87)
/*
 * %0
 */

//
// There was an error in writing the default-off.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
/*
 * %0
 */

//
// There was an error in reading the default-off.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
/*
 * %0
 */

//
// ERROR_EMPTY_INI_FILE
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
/*
 * %0
 */
#endif

#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
/*
 * The remote connection was denied because the user name and password combination you provided is not recognized, or the selected authentication protocol is not permitted on the remote access server.%0
 */

#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
/*
 * There was a hardware failure in the modem (or other connecting device).%0
 */

#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
/*
 * ERROR_NOT_BINARY_MACRO%0
 */

#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
/*
 * ERROR_DCB_NOT_FOUND%0
 */

#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
/*
 * The state machines are not started.%0
 */

#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
/*
 * The state machines are already started.%0
 */

#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
/*
 * The response looping did not complete.%0
 */

#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
/*
 * A response keyname in the device.INF file is not in the expected format.%0
 */

#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
/*
 * The modem (or other connecting device) response caused a buffer overflow.%0
 */

#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
/*
 * The expanded command in the device.INF file is too long.%0
 */

#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
/*
 * The modem moved to a connection speed not supported by the COM driver.%0
 */

#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
/*
 * Device response received when none expected.%0
 */

#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
/*
 * The connection needs information from you, but the application does not allow user interaction.%0
 */

#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
/*
 * The callback number is invalid.%0
 */

#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
/*
 * The authorization state is invalid.%0
 */

#if (WINVER < 0x600)
//
// ERROR_WRITING_INITBPS
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_INITBPS                (RASBASE+106)
/*
 * %0
 */
#endif

#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
/*
 * There was an error related to the X.25 protocol.%0
 */

#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
/*
 * The account has expired.%0
 */

#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
/*
 * There was an error changing the password on the domain.  The password might have been too short or might have matched a previously used password.%0
 */

#define ERROR_OVERRUN                        (RASBASE+110)
/*
 * Serial overrun errors were detected while communicating with the modem.%0
 */

#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
/*
 * The operation could not finish because it could not start the Remote Access Connection Manager service in time. Please try the operation again.%0
 */

#if (WINVER < 0x600)
//
// The two-way port is initializing.  Wait a few seconds and redial.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
/*
 * %0
 */
#endif

#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
/*
 * No active ISDN lines are available.%0
 */

#if (WINVER < 0x600)
//
// No ISDN channels are available to make the call.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
/*
 * %0
 */

//
// Too many errors occurred because of poor phone line quality.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
/*
 * %0
 */
#endif

#define ERROR_IP_CONFIGURATION               (RASBASE+116)
/*
 * The Remote Access Service IP configuration is unusable.%0
 */

#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
/*
 * No IP addresses are available in the static pool of Remote Access Service IP addresses.%0
 */

#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
/*
 * The connection was terminated because the remote computer did not respond in a timely manner.%0
 */

#if (WINVER < 0x600)
//
// The connection was terminated by the remote computer.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
/*
 * %0
 */
#endif

#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
/*
 * A connection to the remote computer could not be established.  You might need to change the network settings for this connection.%0
 */

#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
/*
 * A connection to the remote access server was not made because the remote access server did not respond.%0
 */

#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
/*
 * Invalid data was received from the remote computer.  This data was ignored.%0
 */

#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
/*
 * The phone number, including prefix and suffix, is too long.%0
 */

#if (WINVER < 0x600)
//
// The IPX protocol cannot dial out on the modem (or other connecting device) because this computer is not configured for dialing out (it is an IPX router).
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
/*
 * %0
 */

//
// The IPX protocol cannot dial in on the modem (or other connecting device) because this computer is not configured for dialing in (the IPX router is not installed).
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
/*
 * %0
 */
#endif

#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
/*
 * The IPX protocol cannot be used for dialing out on more than one modem (or other connecting device) at a time.%0
 */

#if (WINVER < 0x600)
//
// Cannot access TCPCFG.DLL.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
/*
 * %0
 */
#endif

#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
/*
 * The system cannot find an IP adapter.%0
 */

#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
/*
 * SLIP cannot be used unless the IP protocol is installed.%0
 */

#if (WINVER < 0x600)
//
// Computer registration is not complete.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
/*
 * %0
 */
#endif

#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
/*
 * The protocol is not configured.%0
 */

#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
/*
 *Your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
/*
 * A connection to the remote computer could not be completed.  You might need to adjust the protocols on this computer.%0
 */

#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
/*
 * The PPP link control protocol was terminated.%0
 */

#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
/*
 * The requested address was rejected by the server.%0
 */

#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
/*
 * The remote computer terminated the control protocol.%0
 */

#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
/*
 * Loopback was detected.%0
 */

#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
/*
 * The remote connection was not made because the remote access server did not assign an IP address.%0
 */

#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
/*
 * The authentication protocol required by the remote server cannot use the stored password.  Redial, entering the password explicitly.%0
 */

#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
/*
 * An invalid dialing rule was detected.%0
 */

#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
/*
 * The local computer does not support the required data encryption type.%0
 */

#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
/*
 * The remote computer does not support the required data encryption type.%0
 */

#if (WINVER < 0x600)
//
// The remote computer requires data encryption.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
/*
 * %0
 */

//
// The system cannot use the IPX network number assigned by the remote computer.  Additional information is provided in the event log.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
/*
 * %0
 */

//
// ERROR_INVALID_SMM
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_SMM                    (RASBASE+145)
/*
 * %0
 */

//
// ERROR_SMM_UNINITIALIZED
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
/*
 * %0
 */

//
// ERROR_NO_MAC_FOR_PORT
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
/*
 * %0
 */

//
// ERROR_SMM_TIMEOUT
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
/*
 * %0
 */
#endif


#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
/*
 * The destination address or phone number is either invalid or not present.%0
 */


#if (WINVER < 0x600)

//
// ERROR_WRONG_MODULE
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRONG_MODULE                   (RASBASE+150)
/*
 * %0
 */

//
// The callback number contains an invalid character.  Only the following 18 characters are allowed:  0 to 9, T, P, W, (, ), -, @, and space.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_CALLBACK_NUMBER        (RASBASE+151)
/*
 * %0
 */
#endif

#define ERROR_SCRIPT_SYNTAX                  (RASBASE+152)
/*
 * A syntax error was encountered while processing a script.%0
 */

#define ERROR_HANGUP_FAILED                  (RASBASE+153)
/*
 * The connection could not be disconnected because the user does not have the required permission to disconnect.%0
 */

#define ERROR_BUNDLE_NOT_FOUND               (RASBASE+154)
/*
 * The system could not find the multi-link bundle.%0
 */

#define ERROR_CANNOT_DO_CUSTOMDIAL           (RASBASE+155)
/*
 * The system cannot perform automated dial because this connection has a custom dialer specified.%0
 */ 

#define ERROR_DIAL_ALREADY_IN_PROGRESS       (RASBASE+156)
/*
 * This connection is already being dialed.%0
 */

#define ERROR_RASAUTO_CANNOT_INITIALIZE      (RASBASE+157)
/*
 * Remote Access Services could not be started automatically.  Additional information is provided in the event log.%0
 */

#if (WINVER < 0x600)
//
// Internet Connection Sharing is already enabled on the connection.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CONNECTION_ALREADY_SHARED      (RASBASE+158)
/*
 * %0
 */

//
// An error occurred while the existing Internet Connection Sharing settings were being changed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_CHANGE_FAILED          (RASBASE+159)
/*
 * %0
 */

//
// An error occurred while routing capabilities were being enabled.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_ROUTER_INSTALL         (RASBASE+160)
/*
 * %0
 */

//
// An error occurred while Internet Connection Sharing was being enabled for the connection.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARE_CONNECTION_FAILED        (RASBASE+161)
/*
 * %0
 */

//
// An error occurred while the local network was being configured for sharing.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_PRIVATE_INSTALL        (RASBASE+162)
/*
 * %0
 */

//
// Internet Connection Sharing cannot be enabled.  There is more than one LAN connection other than the connection to be shared.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_SHARE_CONNECTION        (RASBASE+163)
/*
 * %0
 */
#endif

#define ERROR_NO_SMART_CARD_READER           (RASBASE+164)
/*
 * No smart card reader is installed.%0
 */

#define ERROR_SHARING_ADDRESS_EXISTS         (RASBASE+165)
/*
 * Internet Connection Sharing cannot be enabled.  A LAN connection is already configured with the IP address that is required for automatic IP addressing.%0
 */

#define ERROR_NO_CERTIFICATE                 (RASBASE+166)
/*
 * A certificate could not be found.  Connections that use the L2TP protocol over IPSec require the installation of a machine certificate, also known as a computer certificate.%0
 */

#define ERROR_SHARING_MULTIPLE_ADDRESSES     (RASBASE+167)
/*
 * Internet Connection Sharing cannot be enabled.  The LAN connection selected as the private network has more than one IP address configured.  Please reconfigure the LAN connection with a single IP address before enabling Internet Connection Sharing.%0
 */

#define ERROR_FAILED_TO_ENCRYPT              (RASBASE+168)
/*
 * The connection attempt failed because of failure to encrypt data.%0
 */

#define ERROR_BAD_ADDRESS_SPECIFIED          (RASBASE+169)
/*
 * The specified destination is not reachable.%0
 */

#define ERROR_CONNECTION_REJECT              (RASBASE+170)
/*
 * The remote computer rejected the connection attempt.%0
 */

#define ERROR_CONGESTION                     (RASBASE+171)
/*
 * The connection attempt failed because the network is busy.%0
 */

#define ERROR_INCOMPATIBLE                   (RASBASE+172)
/*
 * The remote computer's network hardware is incompatible with the type of call requested.%0
 */

#define ERROR_NUMBERCHANGED                  (RASBASE+173)
/*
 * The connection attempt failed because the destination number has changed.%0
 */

#define ERROR_TEMPFAILURE                    (RASBASE+174)
/*
 * The connection attempt failed because of a temporary failure.  Try connecting again.%0
 */ 

#define ERROR_BLOCKED                        (RASBASE+175)
/*
 * The call was blocked by the remote computer.%0
 */

#define ERROR_DONOTDISTURB                   (RASBASE+176)
/*
 * The call could not be connected because the remote computer has invoked the Do Not Disturb feature.%0
 */

#define ERROR_OUTOFORDER                     (RASBASE+177)
/*
 * The connection attempt failed because the modem (or other connecting device) on the remote computer is out of order.%0
 */

#define ERROR_UNABLE_TO_AUTHENTICATE_SERVER  (RASBASE+178)
/*
 * It was not possible to verify the identity of the server.%0
 */

#if (WINVER < 0x600)
//
// To dial out using this connection you must use a smart card.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMART_CARD_REQUIRED            (RASBASE+179)
/*
 * %0
 */
#endif

#define ERROR_INVALID_FUNCTION_FOR_ENTRY     (RASBASE+180)
/*
 * An attempted function is not valid for this connection.%0
 */

#if (WINVER < 0x600)
//
// The connection requires a certificate, and no valid certificate was found.  For further assistance, click More Info or search Help and Support Center for this error number.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND  (RASBASE+181)
/*
 * %0
 */
#endif

#define ERROR_SHARING_RRAS_CONFLICT          (RASBASE+182)
/*
 * Internet Connection Sharing (ICS) and Internet Connection Firewall (ICF) cannot be enabled because Routing and Remote Access has been enabled on this computer.  To enable ICS or ICF, first disable Routing and Remote Access.  For more information about Routing and Remote Access, ICS, or ICF, see Help and Support.%0
 */

#define ERROR_SHARING_NO_PRIVATE_LAN         (RASBASE+183)
/*
 * Internet Connection Sharing cannot be enabled.  The LAN connection selected as the private network is either not present, or is disconnected from the network.  Please ensure that the LAN adapter is connected before enabling Internet Connection Sharing.%0
 */

#define ERROR_NO_DIFF_USER_AT_LOGON          (RASBASE+184)
/*
 * You cannot dial using this connection at logon time, because it is configured to use a user name different than the one on the smart card.  If you want to use it at logon time, you must configure it to use the user name on the smart card.%0
 */

#define ERROR_NO_REG_CERT_AT_LOGON           (RASBASE+185)
/*
 * You cannot dial using this connection at logon time, because it is not configured to use a smart card.  If you want to use it at logon time, you must edit the properties of this connection so that it uses a smart card.%0
 */

#define ERROR_OAKLEY_NO_CERT                 (RASBASE+186)
/*
 * The connection attempt failed because there is no valid machine certificate on your computer for security authentication.%0
 */

#define ERROR_OAKLEY_AUTH_FAIL               (RASBASE+187)
/*
 * The L2TP connection attempt failed because the security layer could not authenticate the remote computer.%0
 */

#define ERROR_OAKLEY_ATTRIB_FAIL             (RASBASE+188)
/*
 * The L2TP connection attempt failed because the security layer could not negotiate compatible parameters with the remote computer.%0
 */

#define ERROR_OAKLEY_GENERAL_PROCESSING      (RASBASE+189)
/*
 * The L2TP connection attempt failed because the security layer encountered a processing error during initial negotiations with the remote computer.%0
 */

#define ERROR_OAKLEY_NO_PEER_CERT            (RASBASE+190)
/*
 * The L2TP connection attempt failed because certificate validation of the remote computer failed.%0
 */

#define ERROR_OAKLEY_NO_POLICY               (RASBASE+191)
/*
 * The L2TP connection attempt failed because security policy for the connection was not found.%0
 */

#define ERROR_OAKLEY_TIMED_OUT               (RASBASE+192)
/*
 * The L2TP connection attempt failed because security negotiation timed out.%0
 */

#define ERROR_OAKLEY_ERROR                   (RASBASE+193)
/*
 * The L2TP connection attempt failed because an error occurred while negotiating security.%0
 */

#define ERROR_UNKNOWN_FRAMED_PROTOCOL        (RASBASE+194)
/*
 * The Framed Protocol RADIUS attribute for this user is not PPP.%0
 */

#define ERROR_WRONG_TUNNEL_TYPE              (RASBASE+195)
/*
 * The remote connection request was denied because the VPN tunnel type being used is not allowed.%0
 */

#define ERROR_UNKNOWN_SERVICE_TYPE           (RASBASE+196)
/*
 * The Service Type RADIUS attribute for this user is neither Framed nor Callback Framed.%0
 */

#define ERROR_CONNECTING_DEVICE_NOT_FOUND    (RASBASE+197)
/*
 * A connection to the remote access server was not made because the modem was not found.%0
 */

#define ERROR_NO_EAPTLS_CERTIFICATE          (RASBASE+198)
/*
 * A certificate could not be found that can be used with this Extensible Authentication Protocol.%0
 */

#define ERROR_SHARING_HOST_ADDRESS_CONFLICT  (RASBASE+199)
/*
 * Internet Connection Sharing (ICS) cannot be enabled due to an IP address conflict on the network.  ICS requires the host be configured to use 192.168.137.1.  Please ensure that no other client on the network is configured to use 192.168.137.1.%0
 */

#define ERROR_AUTOMATIC_VPN_FAILED           (RASBASE+200)
/*
 * The remote connection was not made because the attempted VPN tunnels failed. The VPN server might be unreachable. If this connection is attempting to use an L2TP/IPsec tunnel, the security parameters required for IPsec negotiation might not be configured properly.%0
 */

#define ERROR_VALIDATING_SERVER_CERT         (RASBASE+201)
/*
 * This connection is configured to validate the identity of the access server, but Windows cannot verify the digital certificate sent by the server.%0
 */

#define ERROR_READING_SCARD                  (RASBASE+202)
/*
 * The card supplied was not recognized.  Please check that the card is inserted correctly, and fits tightly.%0
 */

#define ERROR_INVALID_PEAP_COOKIE_CONFIG     (RASBASE+203)
/*
 * The PEAP configuration stored in the session cookie does not match the current session configuration.%0
 */

#define ERROR_INVALID_PEAP_COOKIE_USER       (RASBASE+204)
/*
 * The PEAP identity stored in the session cookie does not match the current identity.%0
 */

#define ERROR_INVALID_MSCHAPV2_CONFIG        (RASBASE+205)
/*
 * You cannot dial using this connection at logon time, because it is configured to use logged on user's credentials.%0
 */

//
// New Errors for Windows Vista
//
#define ERROR_VPN_GRE_BLOCKED                 (RASBASE+206)
/*
 * The VPN connection between your computer and the VPN server could not be completed. The most common cause for this failure is that at least one Internet device (for example, a firewall or a router) between your computer and the VPN server is not configured to allow Generic Routing Encapsulation (GRE) protocol packets. If the problem persists, contact your network administrator or Internet Service Provider.%0
 */

#define ERROR_VPN_DISCONNECT                 (RASBASE+207)
/*
 * The network connection between your computer and the VPN server was interrupted.  This can be caused by a problem in the VPN transmission and is commonly the result of internet latency or simply that your VPN server has reached capacity.  Please try to reconnect to the VPN server.  If this problem persists, contact the VPN administrator and analyze quality of network connectivity.%0
 */

#define ERROR_VPN_REFUSED                    (RASBASE+208)
/*
 * The network connection between your computer and the VPN server could not be established because the remote server refused the connection. This is typically caused by a mismatch between the server's configuration and your connection settings. Please contact the remote server's Administrator to verify the server configuration and your connection settings.%0
 */

#define ERROR_VPN_TIMEOUT                    (RASBASE+209)
/*
 * The network connection between your computer and the VPN server could not be established because the remote server is not responding. This could be because one of the network devices (e.g, firewalls, NAT, routers, etc) between your computer and the remote server is not configured to allow VPN connections. Please contact your Administrator or your service provider to determine which device may be causing the problem.%0
 */

#define ERROR_VPN_BAD_CERT                   (RASBASE+210)
/*
 * A network connection between your computer and the VPN server was started, but the VPN connection was not completed. This is typically caused by the use of an incorrect or expired certificate for authentication between the client and the server. Please contact your Administrator to ensure that the certificate being used for authentication is valid.%0
 */

#define ERROR_VPN_BAD_PSK                    (RASBASE+211)
/*
 * The network conection between your computer and the VPN server could not be established because the remote server is not responding.  This is typically caused by a pre-shared key problem between the client and server.  A pre-shared key is used to guarantee you are who you say you are in an IP Security (IPSec) communication cycle.  Please get the assistance of your administrator to determine where the pre-shared key problem is originating.%0
 */

#define ERROR_SERVER_POLICY                  (RASBASE+212)
/*
 *The connection was prevented because of a policy configured on your RAS/VPN server. Specifically, the authentication method used by the server to verify your username and password may not match the authentication method configured in your connection profile. Please contact the Administrator of the RAS server and notify them of this error.%0
 */

#define ERROR_BROADBAND_ACTIVE               (RASBASE+213)
/*
 * You have attempted to establish a second broadband connection while a previous broadband connection is already established using the same device or port. Please disconnect the earlier connection and then reestablish the connection.%0
 */

#define ERROR_BROADBAND_NO_NIC               (RASBASE+214)
/*
 * The underlying Ethernet connectivity required for the broadband connection was not found. Please install and enable the Ethernet adapter on your computer via the Network Connections folder before attempting this connection.%0
 */

#define ERROR_BROADBAND_TIMEOUT              (RASBASE+215)
/*
 * The broadband network conection could not be established on your computer because the remote server is not responding. This could be caused by an invalid value for the 'Service Name' field for this connection. Please contact your Internet Service Provider and inquire about the correct value for this field and update it in the Connection Properties.%0
 */

#define ERROR_FEATURE_DEPRECATED             (RASBASE+216)
/*
 * A feature or setting you have tried to enable is no longer supported by the remote access service.%0
 */

#define ERROR_CANNOT_DELETE                  (RASBASE+217)
/*
 * Cannot delete a connection while it is connected.%0
 */

#if (WINVER <= 0x600)

#define ERROR_RASQEC_RESOURCE_CREATION_FAILED (RASBASE+218)
/*
* The Network Access Protection (NAP) enforcement client could not create system resources for remote access connections. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_NAPAGENT_NOT_ENABLED    (RASBASE+219)
/*
* The Network Access Protection Agent (NAPAgent) service has been disabled or is not installed on this computer. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_NAPAGENT_NOT_CONNECTED  (RASBASE+220)
/*
* The Network Access Protection (NAP) enforcement client failed to register with the Network Access Protection Agent (NAPAgent) service. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_CONN_DOESNOTEXIST       (RASBASE+221)
/*
* The Network Access Protection (NAP) enforcement client was unable to process the request because the remote access connection does not exist. Retry the remote access connection. If the problem persists, make sure that you can connect to the Internet, and then contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_TIMEOUT                 (RASBASE+222)
/*
* The Network Access Protection (NAP) enforcement client did not respond. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#endif

#define ERROR_PEAP_CRYPTOBINDING_INVALID    (RASBASE+223)
/*
* Received Crypto-Binding TLV is invalid.%0
*/

#define ERROR_PEAP_CRYPTOBINDING_NOTRECEIVED   (RASBASE+224)
/*
* Crypto-Binding TLV is not received.%0
*/

#if (WINVER >= 0x600)

#define ERROR_INVALID_VPNSTRATEGY   (RASBASE+225)
/*
* The remote connection was not made because Point-to-Point Tunneling Protocol (PPTP) is incompatible with IPv6. Use any other tunneling protocol. %0
*/

#endif

#define ERROR_EAPTLS_CACHE_CREDENTIALS_INVALID   (RASBASE+226)
/*
* EAPTLS validation of the cached credentials failed. Please discard 
* cached credentials.
*/

#define ERROR_IPSEC_SERVICE_STOPPED                 (RASBASE+227)
/*
* The VPN connection cannot be completed because the 'IKE and AuthIP IPSec Keying Modules' service and/or the 'Base Filtering Engine' service is not running. These services are required to establish the connection. Please ensure that these services have been started before dialing the connection.
*/

#if (WINVER >= 0x600)

#define ERROR_IDLE_TIMEOUT               (RASBASE+228)
/*
 * The connection was terminated because of idle timeout.%0
 */

#define ERROR_LINK_FAILURE               (RASBASE+229)
/*
 * The modem (or other connecting device) was disconnected due to link failure.%0
 */

#define ERROR_USER_LOGOFF                (RASBASE+230)
/*
 * The connection was terminated because user logged off.%0
 */

#define ERROR_FAST_USER_SWITCH           (RASBASE+231)
/*
 * The connection was terminated because user switch happened.%0
 */

#define ERROR_HIBERNATION                 (RASBASE+232)
/*
 * The connection was terminated because of hibernation.%0
 */

#define ERROR_SYSTEM_SUSPENDED            (RASBASE+233)
/*
 * The connection was terminated because the system got suspended.%0
 */

#define ERROR_RASMAN_SERVICE_STOPPED      (RASBASE+234)
/*
 * The connection was terminated because Remote Access Connection manager stopped.%0
 */

#define ERROR_INVALID_SERVER_CERT         (RASBASE+235)
/*
* The L2TP connection attempt failed because the security layer could not authenticate the remote computer. This could be because one or more fields of the certificate presented by the remote server could not be validated as belonging to the target destination.
*/

#define ERROR_NOT_NAP_CAPABLE             (RASBASE+236)
/*
* The Network Access Protection (NAP) health state of the computer cannot be determined. Contact your administrator to verify that the NAP enforcement client is enabled, the NAP Agent service is running, and NAP is enforced in the Protected Extensible Authentication Protocol (PEAP) properties of the remote access connection.  
*/

#endif

#if (WINVER >= 0x601)

#define ERROR_INVALID_TUNNELID           (RASBASE+237)
/*
* Invalid Tunnel ID.%0
*/

#define ERROR_UPDATECONNECTION_REQUEST_IN_PROCESS    (RASBASE+238)
/*
* Another Update connection request is in progress. RAS allows only one Update Connection request at a time.%0
*/

#define ERROR_PROTOCOL_ENGINE_DISABLED    (RASBASE+239)
/*
* Negotiating using configured protocol is disable. Edit connection properties and select different protocol for negotiation and try again.%0
*/

#define ERROR_INTERNAL_ADDRESS_FAILURE    (RASBASE+240)
/*
 *  Internal address negotiation failed.%0
 */

#define ERROR_FAILED_CP_REQUIRED          (RASBASE+241)
/*
 * Client has to request a Internal IPv4 or IPv6 address.%0
 */

#define ERROR_TS_UNACCEPTABLE             (RASBASE+242)
/*
 *  Traffic Selectors negotiation failed.%0
 */

#define ERROR_MOBIKE_DISABLED             (RASBASE+243)
/*
* Mobility is disabled for this connection.
*/

#define ERROR_CANNOT_INITIATE_MOBIKE_UPDATE  (RASBASE+244)
/*
* The VPN Connection is still connecting or reauthenticating because of Quarantine state change. Initiate mobike update only when connection state is 'Connected'.
*/

#define ERROR_PEAP_SERVER_REJECTED_CLIENT_TLV           (RASBASE+245)
/*
* Server rejected client authentication, due unexpected TLV or value mismatch for a TLV.
*/

#define ERROR_INVALID_PREFERENCES           (RASBASE+246)
/*
* Either VPN Destination preference is not selected by the user or it is no longer valid. 
*/

#define ERROR_EAPTLS_SCARD_CACHE_CREDENTIALS_INVALID (RASBASE+247)
/*
* Cached smart card credential is invalid.
*/

#define ERROR_SSTP_COOKIE_SET_FAILURE             (RASBASE + 248)
/*
* VPN connection attempt failed due to internal error occurred while adding cookies to the Secure Socket Tunneling Protocol (SSTP). Please see the System Event Log for the detailed information.
*/
#define ERROR_INVALID_PEAP_COOKIE_ATTRIBUTES (RASBASE+249)
/*
* The PEAP inner method attributes stored in the cookie is invalid
*/

#define ERROR_EAP_METHOD_NOT_INSTALLED            (RASBASE+250)
/*
* The Extensible Authentication Protocol type required for authentication of the remote access connection is not installed on your computer. 
*/

#define ERROR_EAP_METHOD_DOES_NOT_SUPPORT_SSO     (RASBASE+251)
/*
* The Extensible Authentication Protocol type configured on the remote access connection does not support single sign-on. 
*/

#define ERROR_EAP_METHOD_OPERATION_NOT_SUPPORTED  (RASBASE+252)
/*
* The Extensible Authentication Protocol type configured on the remote access connection does not support the requested operation. 
*/

#define ERROR_EAP_USER_CERT_INVALID               (RASBASE+253)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is not valid. Ensure that the certificate used for authentication is valid. 
*/

#define ERROR_EAP_USER_CERT_EXPIRED               (RASBASE+254)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is expired. Renew the certificate. 
*/

#define ERROR_EAP_USER_CERT_REVOKED               (RASBASE+255)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is revoked. 
*/

#define ERROR_EAP_USER_CERT_OTHER_ERROR           (RASBASE+256)
/*
* The remote access connection completed, but authentication failed because of an error in the certificate that authenticates the client to the server. 
*/

#define ERROR_EAP_SERVER_CERT_INVALID             (RASBASE+257)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is not valid. 
*/

#define ERROR_EAP_SERVER_CERT_EXPIRED             (RASBASE+258)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is expired. 
*/

#define ERROR_EAP_SERVER_CERT_REVOKED             (RASBASE+259)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is revoked. 
*/

#define ERROR_EAP_SERVER_CERT_OTHER_ERROR         (RASBASE+260)
/*
* The remote access connection completed, but authentication failed because of an error in the certificate that the client uses to authenticate the server. 
*/

#define ERROR_EAP_USER_ROOT_CERT_NOT_FOUND        (RASBASE+261)
/*
* The remote access connection completed, but authentication failed because a trusted root certificate that validates the user certificate was not found in the Trusted Root Certification Authorities certificate store. 
*/

#define ERROR_EAP_USER_ROOT_CERT_INVALID          (RASBASE+262)
/*
* The remote access connection completed, but authentication failed because the trusted root certificate that is used to validate the user certificate is not valid. 
*/

#define ERROR_EAP_USER_ROOT_CERT_EXPIRED          (RASBASE+263)
/*
* The remote access connection completed, but authentication failed because the certificate in the Trusted Root Certification Authorities certificate store that authenticates the user certificate is expired. Renew the certificate. 
*/

#define ERROR_EAP_SERVER_ROOT_CERT_NOT_FOUND      (RASBASE+264)
/*
* The remote access connection completed, but authentication failed because a certificate that validates the server certificate was not found in the Trusted Root Certification Authorities certificate store.
*/

#define ERROR_EAP_SERVER_ROOT_CERT_INVALID        (RASBASE+265)
/*
* The remote zccess connection completed, but authentication failed because the certificate in the Trusted Root Certification Authorities certificate store that validates the server certificate is not valid. 
*/

#define ERROR_EAP_SERVER_ROOT_CERT_NAME_REQUIRED  (RASBASE+266)
/*
* The remote access connection completed, but authentication failed because the certificate on the server computer does not have a server name specified. 
*/

#define ERROR_PEAP_IDENTITY_MISMATCH (RASBASE+267)
/*
*    The PEAP outer identity is not same as the inner identity when identity privacy is turned OFF.
*/

#define ERROR_DNSNAME_NOT_RESOLVABLE (RASBASE+268)
/*
*    The remote connection was not made because the name of the remote access server did not resolve.
*/

#endif

#define RASBASEEND                        (RASBASE+268)

#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rectypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rectypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rectypes_h__
#define __rectypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rectypes_0000_0000 */
/* [local] */ 

#include "RecDefs.h"
#define SAFE_PARTIAL     1
#define BEST_COMPLETE    2
#define MAX_VENDORNAME   32
#define MAX_FRIENDLYNAME 64
#define MAX_LANGUAGES    64
#define CAC_FULL     0
#define CAC_PREFIX   1
#define CAC_RANDOM   2
#define ASYNC_RECO_INTERRUPTED               0x1     //when the process is interrupted
#define ASYNC_RECO_PROCESS_FAILED            0x2
#define ASYNC_RECO_ADDSTROKE_FAILED          0x4
#define ASYNC_RECO_SETCACMODE_FAILED         0x8
#define ASYNC_RECO_RESETCONTEXT_FAILED       0x10
#define ASYNC_RECO_SETGUIDE_FAILED           0x20
#define ASYNC_RECO_SETFLAGS_FAILED           0x40
#define ASYNC_RECO_SETFACTOID_FAILED         0x80
#define ASYNC_RECO_SETTEXTCONTEXT_FAILED     0x100
#define ASYNC_RECO_SETWORDLIST_FAILED        0x200
#define RF_DONTCARE              1L      // overrides all other ones if set
#define RF_OBJECT                2L      // if not set, this is a text recognizer
#define RF_FREE_INPUT            4L      // supports free input
#define RF_LINED_INPUT           8L      // supports simple guide structure with lines only
#define RF_BOXED_INPUT           16L     // supports boxed (guided) input
#define RF_CAC_INPUT             32L     // supports boxed Character Auto Completion
#define RF_RIGHT_AND_DOWN        64L     // used in western and FE languages
#define RF_LEFT_AND_DOWN         128L    // used in Hebrew and Arabic
#define RF_DOWN_AND_LEFT         256L    // used in most FE languages
#define RF_DOWN_AND_RIGHT        512L    // used in Chinese only
#define RF_ARBITRARY_ANGLE       1024L   // can read text written at arbitrary angles (mimio)
#define RF_LATTICE               2048L   // can return lattice in results
#define RF_ADVISEINKCHANGE       4096L   // advise ink change can interrupt process
#define RF_STROKEREORDER         8192L   // indicates that stroke order - spatial and temporal is handled
#define RF_PERSONALIZABLE        16384L  // Supports personalization
//                               32768L is reserved.
#define RF_PERFORMSLINEBREAKING  65536L  // Recognizer prefers to do the line breaking
#define RF_REQUIRESSEGMENTATIONBREAKING 131072L // Recognizer wants only segments of ink
#ifndef __RECOTYPES__
#define __RECOTYPES__
typedef struct tagRECO_GUIDE
    {
    int xOrigin;
    int yOrigin;
    int cxBox;
    int cyBox;
    int cxBase;
    int cyBase;
    int cHorzBox;
    int cVertBox;
    int cyMid;
    } 	RECO_GUIDE;

typedef struct tagRECO_ATTRS
    {
    DWORD dwRecoCapabilityFlags;
    WCHAR awcVendorName[ 32 ];
    WCHAR awcFriendlyName[ 64 ];
    WORD awLanguageId[ 64 ];
    } 	RECO_ATTRS;

typedef struct tagRECO_RANGE
    {
    ULONG iwcBegin;
    ULONG cCount;
    } 	RECO_RANGE;

typedef struct tagLINE_SEGMENT
    {
    POINT PtA;
    POINT PtB;
    } 	LINE_SEGMENT;

typedef struct tagLATTICE_METRICS
    {
    LINE_SEGMENT lsBaseline;
    short iMidlineOffset;
    } 	LATTICE_METRICS;

typedef 
enum enumLINE_METRICS
    {	LM_BASELINE	= 0,
	LM_MIDLINE	= 1,
	LM_ASCENDER	= 2,
	LM_DESCENDER	= 3
    } 	LINE_METRICS;

typedef 
enum enumCONFIDENCE_LEVEL
    {	CFL_STRONG	= 0,
	CFL_INTERMEDIATE	= 1,
	CFL_POOR	= 2
    } 	CONFIDENCE_LEVEL;

typedef 
enum enumALT_BREAKS
    {	ALT_BREAKS_SAME	= 0,
	ALT_BREAKS_UNIQUE	= 1,
	ALT_BREAKS_FULL	= 2
    } 	ALT_BREAKS;

typedef 
enum enumRECO_TYPE
    {	RECO_TYPE_WSTRING	= 0,
	RECO_TYPE_WCHAR	= 1
    } 	RECO_TYPE;

typedef struct tagRECO_LATTICE_PROPERTY
    {
    GUID guidProperty;
    USHORT cbPropertyValue;
    BYTE *pPropertyValue;
    } 	RECO_LATTICE_PROPERTY;

typedef struct tagRECO_LATTICE_PROPERTIES
    {
    ULONG cProperties;
    RECO_LATTICE_PROPERTY **apProps;
    } 	RECO_LATTICE_PROPERTIES;

typedef int RECO_SCORE;

typedef struct tagRECO_LATTICE_ELEMENT
    {
    RECO_SCORE score;
    WORD type;
    BYTE *pData;
    ULONG ulNextColumn;
    ULONG ulStrokeNumber;
    RECO_LATTICE_PROPERTIES epProp;
    } 	RECO_LATTICE_ELEMENT;

typedef struct tagRECO_LATTICE_COLUMN
    {
    ULONG key;
    RECO_LATTICE_PROPERTIES cpProp;
    ULONG cStrokes;
    ULONG *pStrokes;
    ULONG cLatticeElements;
    RECO_LATTICE_ELEMENT *pLatticeElements;
    } 	RECO_LATTICE_COLUMN;

typedef struct tagRECO_LATTICE
    {
    ULONG ulColumnCount;
    RECO_LATTICE_COLUMN *pLatticeColumns;
    ULONG ulPropertyCount;
    GUID *pGuidProperties;
    ULONG ulBestResultColumnCount;
    ULONG *pulBestResultColumns;
    ULONG *pulBestResultIndexes;
    } 	RECO_LATTICE;

typedef struct tagCHARACTER_RANGE
    {
    WCHAR wcLow;
    USHORT cChars;
    } 	CHARACTER_RANGE;

typedef struct tagCHARACTER_RANGE *PCHARACTER_RANGE;

#endif


extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\regbag.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for regbag.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __regbag_h__
#define __regbag_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICreatePropBagOnRegKey_FWD_DEFINED__
#define __ICreatePropBagOnRegKey_FWD_DEFINED__
typedef interface ICreatePropBagOnRegKey ICreatePropBagOnRegKey;
#endif 	/* __ICreatePropBagOnRegKey_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_regbag_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//--------------------------------------------------------------------------
#pragma once


extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_0000_v0_0_s_ifspec;

#ifndef __ICreatePropBagOnRegKey_INTERFACE_DEFINED__
#define __ICreatePropBagOnRegKey_INTERFACE_DEFINED__

/* interface ICreatePropBagOnRegKey */
/* [local][unique][helpstring][uuid][restricted][hidden][object] */ 


EXTERN_C const IID IID_ICreatePropBagOnRegKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A674B48-1F63-11d3-B64C-00C04F79498E")
    ICreatePropBagOnRegKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreatePropBagOnRegKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreatePropBagOnRegKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreatePropBagOnRegKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag);
        
        END_INTERFACE
    } ICreatePropBagOnRegKeyVtbl;

    interface ICreatePropBagOnRegKey
    {
        CONST_VTBL struct ICreatePropBagOnRegKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreatePropBagOnRegKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreatePropBagOnRegKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreatePropBagOnRegKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreatePropBagOnRegKey_Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag)	\
    ( (This)->lpVtbl -> Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreatePropBagOnRegKey_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\recdefs.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecDefs.h
//
//--------------------------------------------------------------------------


#ifndef __INC_RECDEFS_H
#define __INC_RECDEFS_H

// RECO FLAGS
#define RECOFLAG_WORDMODE		0x00000001
#define RECOFLAG_COERCE			0x00000002
#define RECOFLAG_SINGLESEG		0x00000004
#define RECOFLAG_PREFIXOK		0x00000008
#define RECOFLAG_LINEMODE		0x00000010
#define RECOFLAG_DISABLEPERSONALIZATION 0x00000020
#define RECOFLAG_AUTOSPACE		0x00000040

// Confidence constants
#define RECOCONF_LOWCONFIDENCE -1
#define RECOCONF_MEDIUMCONFIDENCE 0
#define RECOCONF_HIGHCONFIDENCE 1
#define RECOCONF_NOTSET    128

// Gesture ids
#define GESTURE_NULL                        0xf000
#define GESTURE_SCRATCHOUT                  0xf001
#define GESTURE_TRIANGLE                    0xf002
#define GESTURE_SQUARE                      0xf003
#define GESTURE_STAR                        0xf004
#define GESTURE_CHECK                       0xf005
#define GESTURE_INFINITY                    0xf006
#define GESTURE_CROSS                       0xf007
#define GESTURE_PARAGRAPH                   0xf008
#define GESTURE_SECTION                     0xf009
#define GESTURE_BULLET                      0xf00a
#define GESTURE_BULLET_CROSS                0xf00b
#define GESTURE_SQUIGGLE                    0xf00c
#define GESTURE_SWAP                        0xf00d
#define GESTURE_OPENUP                      0xf00e
#define GESTURE_CLOSEUP                     0xf00f
#define GESTURE_CURLICUE                    0xf010
#define GESTURE_DOUBLE_CURLICUE             0xf011
#define GESTURE_RECTANGLE                   0xf012
#define GESTURE_CIRCLE                      0xf020
#define GESTURE_DOUBLE_CIRCLE               0xf021
#define GESTURE_CIRCLE_TAP                  0xf022
#define GESTURE_CIRCLE_CIRCLE               0xf023
#define GESTURE_CIRCLE_CROSS                0xf025
#define GESTURE_CIRCLE_LINE_VERT            0xf026
#define GESTURE_CIRCLE_LINE_HORZ            0xf027
#define GESTURE_SEMICIRCLE_LEFT             0xf028
#define GESTURE_SEMICIRCLE_RIGHT            0xf029
#define GESTURE_CHEVRON_UP                  0xf030
#define GESTURE_CHEVRON_DOWN                0xf031
#define GESTURE_CHEVRON_LEFT                0xf032
#define GESTURE_CHEVRON_RIGHT               0xf033
#define GESTURE_ARROW_UP                    0xf038
#define GESTURE_ARROW_DOWN                  0xf039
#define GESTURE_ARROW_LEFT                  0xf03a
#define GESTURE_ARROW_RIGHT                 0xf03b
#define GESTURE_DOUBLE_ARROW_UP             0xf03c
#define GESTURE_DOUBLE_ARROW_DOWN           0xf03d
#define GESTURE_DOUBLE_ARROW_LEFT           0xf03e
#define GESTURE_DOUBLE_ARROW_RIGHT          0xf03f
#define GESTURE_UP_ARROW_LEFT               0xf040
#define GESTURE_UP_ARROW_RIGHT              0xf041
#define GESTURE_DOWN_ARROW_LEFT             0xf042
#define GESTURE_DOWN_ARROW_RIGHT            0xf043
#define GESTURE_LEFT_ARROW_UP               0xf044
#define GESTURE_LEFT_ARROW_DOWN             0xf045
#define GESTURE_RIGHT_ARROW_UP              0xf046
#define GESTURE_RIGHT_ARROW_DOWN            0xf047
#define GESTURE_UP                          0xf058
#define GESTURE_DOWN                        0xf059
#define GESTURE_LEFT                        0xf05a
#define GESTURE_RIGHT                       0xf05b
#define GESTURE_DIAGONAL_LEFTUP             0xf05c
#define GESTURE_DIAGONAL_RIGHTUP            0xf05d
#define GESTURE_DIAGONAL_LEFTDOWN           0xf05e
#define GESTURE_DIAGONAL_RIGHTDOWN          0xf05f
#define GESTURE_UP_DOWN                     0xf060
#define GESTURE_DOWN_UP                     0xf061
#define GESTURE_LEFT_RIGHT                  0xf062
#define GESTURE_RIGHT_LEFT                  0xf063
#define GESTURE_UP_LEFT_LONG                0xf064
#define GESTURE_UP_RIGHT_LONG               0xf065
#define GESTURE_DOWN_LEFT_LONG              0xf066
#define GESTURE_DOWN_RIGHT_LONG             0xf067
#define GESTURE_UP_LEFT                     0xf068
#define GESTURE_UP_RIGHT                    0xf069
#define GESTURE_DOWN_LEFT                   0xf06a
#define GESTURE_DOWN_RIGHT                  0xf06b
#define GESTURE_LEFT_UP                     0xf06c
#define GESTURE_LEFT_DOWN                   0xf06d
#define GESTURE_RIGHT_UP                    0xf06e
#define GESTURE_RIGHT_DOWN                  0xf06f
#define GESTURE_LETTER_A                    0xf080
#define GESTURE_LETTER_B                    0xf081
#define GESTURE_LETTER_C                    0xf082
#define GESTURE_LETTER_D                    0xf083
#define GESTURE_LETTER_E                    0xf084
#define GESTURE_LETTER_F                    0xf085
#define GESTURE_LETTER_G                    0xf086
#define GESTURE_LETTER_H                    0xf087
#define GESTURE_LETTER_I                    0xf088
#define GESTURE_LETTER_J                    0xf089
#define GESTURE_LETTER_K                    0xf08a
#define GESTURE_LETTER_L                    0xf08b
#define GESTURE_LETTER_M                    0xf08c
#define GESTURE_LETTER_N                    0xf08d
#define GESTURE_LETTER_O                    0xf08e
#define GESTURE_LETTER_P                    0xf08f
#define GESTURE_LETTER_Q                    0xf090
#define GESTURE_LETTER_R                    0xf091
#define GESTURE_LETTER_S                    0xf092
#define GESTURE_LETTER_T                    0xf093
#define GESTURE_LETTER_U                    0xf094
#define GESTURE_LETTER_V                    0xf095
#define GESTURE_LETTER_W                    0xf096
#define GESTURE_LETTER_X                    0xf097
#define GESTURE_LETTER_Y                    0xf098
#define GESTURE_LETTER_Z                    0xf099
#define GESTURE_DIGIT_0                     0xf09a
#define GESTURE_DIGIT_1                     0xf09b
#define GESTURE_DIGIT_2                     0xf09c
#define GESTURE_DIGIT_3                     0xf09d
#define GESTURE_DIGIT_4                     0xf09e
#define GESTURE_DIGIT_5                     0xf09f
#define GESTURE_DIGIT_6                     0xf0a0
#define GESTURE_DIGIT_7                     0xf0a1
#define GESTURE_DIGIT_8                     0xf0a2
#define GESTURE_DIGIT_9                     0xf0a3
#define GESTURE_EXCLAMATION                 0xf0a4
#define GESTURE_QUESTION                    0xf0a5
#define GESTURE_SHARP                       0xf0a6
#define GESTURE_DOLLAR                      0xf0a7
#define GESTURE_ASTERISK                    0xf0a8
#define GESTURE_PLUS                        0xf0a9
#define GESTURE_DOUBLE_UP                   0xf0b8
#define GESTURE_DOUBLE_DOWN                 0xf0b9
#define GESTURE_DOUBLE_LEFT                 0xf0ba
#define GESTURE_DOUBLE_RIGHT                0xf0bb
#define GESTURE_TRIPLE_UP                   0xf0bc
#define GESTURE_TRIPLE_DOWN                 0xf0bd
#define GESTURE_TRIPLE_LEFT                 0xf0be
#define GESTURE_TRIPLE_RIGHT                0xf0bf
#define GESTURE_BRACKET_OVER                0xf0e4
#define GESTURE_BRACKET_UNDER               0xf0e5
#define GESTURE_BRACKET_LEFT                0xf0e6
#define GESTURE_BRACKET_RIGHT               0xf0e7
#define GESTURE_BRACE_OVER                  0xf0e8
#define GESTURE_BRACE_UNDER                 0xf0e9
#define GESTURE_BRACE_LEFT                  0xf0ea
#define GESTURE_BRACE_RIGHT                 0xf0eb
#define GESTURE_TAP                         0xf0f0
#define GESTURE_DOUBLE_TAP                  0xf0f1
#define GESTURE_TRIPLE_TAP                  0xf0f2
#define GESTURE_QUAD_TAP                    0xf0f3
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Reconcil.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__

#if _MSC_VER > 1000
#pragma once
#endif

/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RecGuids.h ===
// Copyright (C) Microsoft Corporation, 1990-1999
#if _MSC_VER > 1000
#pragma once
#endif

/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RegStr.h ===
/*** regstr.h - Registry string definitions
 *
 *  This module contains public registry string definitions.
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *  Created     12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_REGSTR
#define _INC_REGSTR

#if _MSC_VER > 1000
#pragma once
#endif


/*** Public registry key names
 */

#define REGSTR_KEY_CLASS        TEXT("Class")      // under LOCAL_MACHINE
#define REGSTR_KEY_CONFIG       TEXT("Config")     // under LOCAL_MACHINE
#define REGSTR_KEY_ENUM         TEXT("Enum")       // under LOCAL_MACHINE
#define REGSTR_KEY_ROOTENUM     TEXT("Root")       // child of ENUM
#define REGSTR_KEY_BIOSENUM     TEXT("BIOS")       // child of ENUM
#define REGSTR_KEY_ACPIENUM     TEXT("ACPI")       // child of ENUM
#define REGSTR_KEY_PCMCIAENUM   TEXT("PCMCIA")     // child of ENUM
#define REGSTR_KEY_PCIENUM      TEXT("PCI")        // child of ENUM
#define REGSTR_KEY_VPOWERDENUM  TEXT("VPOWERD")    // child of ENUM
#ifndef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("ISAPnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("EISA")       // child of ENUM
#else // ifdef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("C98PnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("NESA")       // child of ENUM
#endif // ifdef NEC_98
#define REGSTR_KEY_LOGCONFIG    TEXT("LogConfig")  // child of enum\<enumerator>\<deviceid>\<instanceid>
#define REGSTR_KEY_SYSTEMBOARD  TEXT("*PNP0C01")   // child of enum\root
#define REGSTR_KEY_APM          TEXT("*PNP0C05")   // child of enum\root

#define REGSTR_KEY_INIUPDATE    TEXT("IniUpdate")
#define REG_KEY_INSTDEV         TEXT("Installed")  // child of hklm\class\classname (Win98-only)

#define REGSTR_KEY_DOSOPTCDROM  TEXT("CD-ROM")
#define REGSTR_KEY_DOSOPTMOUSE  TEXT("MOUSE")

#define REGSTR_KEY_KNOWNDOCKINGSTATES TEXT("Hardware Profiles")
#define REGSTR_KEY_DEVICEPARAMETERS   TEXT("Device Parameters")


/*** Public registry paths
 */

#define REGSTR_DEFAULT_INSTANCE          TEXT("0000")
#define REGSTR_PATH_MOTHERBOARD          REGSTR_KEY_SYSTEMBOARD TEXT("\\") REGSTR_DEFAULT_INSTANCE
#define REGSTR_PATH_SETUP                TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_DRIVERSIGN           TEXT("Software\\Microsoft\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN        TEXT("Software\\Microsoft\\Non-Driver Signing")
#define REGSTR_PATH_DRIVERSIGN_POLICY    TEXT("Software\\Policies\\Microsoft\\Windows NT\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN_POLICY TEXT("Software\\Policies\\Microsoft\\Windows NT\\Non-Driver Signing")
#define REGSTR_PATH_PIFCONVERT           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PIFConvert")
#define REGSTR_PATH_MSDOSOPTS            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSOptions")
#define REGSTR_PATH_NOSUGGMSDOS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NoMSDOSWarn")
#define REGSTR_PATH_NEWDOSBOX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSSpecialConfig")
#define REGSTR_PATH_RUNONCE              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define REGSTR_PATH_RUNONCEEX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define REGSTR_PATH_RUN                  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REGSTR_PATH_RUNSERVICESONCE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define REGSTR_PATH_RUNSERVICES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_PATH_PROPERTYSYSTEM       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PropertySystem")
#define REGSTR_PATH_DETECT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Detect")
#define REGSTR_PATH_APPPATHS             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_UNINSTALL            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REGSTR_PATH_REALMODENET          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net")
#define REGSTR_PATH_NETEQUIV             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Equivalent")
#define REGSTR_PATH_CVNETWORK            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network")
#define REGSTR_PATH_WMI_SECURITY         TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#define REGSTR_PATH_RELIABILITY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY   TEXT("Software\\Policies\\Microsoft\\Windows NT\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY_SHUTDOWNREASONUI TEXT("ShutdownReasonUI")
#define REGSTR_PATH_RELIABILITY_POLICY_SNAPSHOT         TEXT("Snapshot")
#define REGSTR_PATH_RELIABILITY_POLICY_REPORTSNAPSHOT   TEXT("ReportSnapshot")

#define REGSTR_PATH_REINSTALL            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall")
#define REGSTR_PATH_NT_CURRENTVERSION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#define REGSTR_PATH_VOLUMECACHE TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define REGSTR_VAL_DISPLAY      TEXT("display")


#define REGSTR_PATH_IDCONFIGDB  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB")
#define REGSTR_PATH_CRITICALDEVICEDATABASE  TEXT("System\\CurrentControlSet\\Control\\CriticalDeviceDatabase")
#define REGSTR_PATH_CLASS       TEXT("System\\CurrentControlSet\\Services\\Class")
#define REGSTR_PATH_DISPLAYSETTINGS TEXT("Display\\Settings")
#define REGSTR_PATH_FONTS           TEXT("Display\\Fonts")
#define REGSTR_PATH_ENUM        TEXT("Enum")
#define REGSTR_PATH_ROOT        TEXT("Enum\\Root")

#define REGSTR_PATH_CURRENTCONTROLSET TEXT("System\\CurrentControlSet")
#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum")
#define REGSTR_PATH_HWPROFILES  TEXT("System\\CurrentControlSet\\Hardware Profiles")
#define REGSTR_PATH_HWPROFILESCURRENT TEXT("System\\CurrentControlSet\\Hardware Profiles\\Current")
#define REGSTR_PATH_CLASS_NT    TEXT("System\\CurrentControlSet\\Control\\Class")
#define REGSTR_PATH_PER_HW_ID_STORAGE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage")

#define REGSTR_PATH_DEVICE_CLASSES TEXT("System\\CurrentControlSet\\Control\\DeviceClasses")

#define REGSTR_PATH_CODEVICEINSTALLERS TEXT("System\\CurrentControlSet\\Control\\CoDeviceInstallers")
#define REGSTR_PATH_BUSINFORMATION TEXT("System\\CurrentControlSet\\Control\\PnP\\BusInformation")

#define REGSTR_PATH_SERVICES    TEXT("System\\CurrentControlSet\\Services")
#define REGSTR_PATH_VXD         TEXT("System\\CurrentControlSet\\Services\\VxD")
#define REGSTR_PATH_IOS     TEXT("System\\CurrentControlSet\\Services\\VxD\\IOS")
#define REGSTR_PATH_VMM         TEXT("System\\CurrentControlSet\\Services\\VxD\\VMM")
#define REGSTR_PATH_VPOWERD     TEXT("System\\CurrentControlSet\\Services\\VxD\\VPOWERD")
#define REGSTR_PATH_VNETSUP     TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define REGSTR_PATH_NWREDIR     TEXT("System\\CurrentControlSet\\Services\\VxD\\NWREDIR")
#define REGSTR_PATH_NCPSERVER   TEXT("System\\CurrentControlSet\\Services\\NcpServer\\Parameters")
#define REGSTR_PATH_VCOMM       TEXT("System\\CurrentControlSet\\Services\\VxD\\VCOMM")

#define REGSTR_PATH_IOARB       TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IOArb")
#define REGSTR_PATH_ADDRARB     TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\AddrArb")
#define REGSTR_PATH_DMAARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\DMAArb")
#define REGSTR_PATH_IRQARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IRQArb")

#define REGSTR_PATH_CODEPAGE                            TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage")
#define REGSTR_PATH_FILESYSTEM                          TEXT("System\\CurrentControlSet\\Control\\FileSystem")
#define REGSTR_PATH_FILESYSTEM_NOVOLTRACK       TEXT("System\\CurrentControlSet\\Control\\FileSystem\\NoVolTrack")
#define REGSTR_PATH_CDFS                                        TEXT("System\\CurrentControlSet\\Control\\FileSystem\\CDFS")
#define REGSTR_PATH_WINBOOT                                 TEXT("System\\CurrentControlSet\\Control\\WinBoot")
#define REGSTR_PATH_INSTALLEDFILES                      TEXT("System\\CurrentControlSet\\Control\\InstalledFiles")
#define REGSTR_PATH_VMM32FILES                          TEXT("System\\CurrentControlSet\\Control\\VMM32Files")

//
// Reasonable Limit for Values Names
//
#define REGSTR_MAX_VALUE_LENGTH     256

//
// Values used by user mode Pnp Manager
//
#define REGSTR_KEY_DEVICE_PROPERTIES               TEXT("Properties")
#define REGSTR_VAL_SLOTNUMBER                      TEXT("SlotNumber")
#define REGSTR_VAL_ATTACHEDCOMPONENTS              TEXT("AttachedComponents")
#define REGSTR_VAL_BASEDEVICEPATH                  TEXT("BaseDevicePath")
#define REGSTR_VAL_SYSTEMBUSNUMBER                 TEXT("SystemBusNumber")
#define REGSTR_VAL_BUSDATATYPE                     TEXT("BusDataType")
#define REGSTR_VAL_INTERFACETYPE                   TEXT("InterfaceType")
#define REGSTR_VAL_SERVICE                         TEXT("Service")
#define REGSTR_VAL_DETECTSIGNATURE                 TEXT("DetectSignature")
#define REGSTR_VAL_CLASSGUID                       TEXT("ClassGUID")
#define REGSTR_VAL_INSTANCEIDENTIFIER              TEXT("InstanceIdentifier")
#define REGSTR_VAL_DUPLICATEOF                     TEXT("DuplicateOf")
#define REGSTR_VAL_STATUSFLAGS                     TEXT("StatusFlags")
#define REGSTR_VAL_DISABLECOUNT                    TEXT("DisableCount")
#define REGSTR_VAL_UNKNOWNPROBLEMS                 TEXT("UnknownProblem")
#define REGSTR_VAL_DOCKSTATE                       TEXT("DockState")
#define REGSTR_VAL_PREFERENCEORDER                 TEXT("PreferenceOrder")
#define REGSTR_VAL_USERWAITINTERVAL                TEXT("UserWaitInterval")
#define REGSTR_VAL_DEVICE_INSTANCE                 TEXT("DeviceInstance")
#define REGSTR_VAL_SYMBOLIC_LINK                   TEXT("SymbolicLink")
#define REGSTR_VAL_DEFAULT                         TEXT("Default")
#define REGSTR_VAL_LOWERFILTERS                    TEXT("LowerFilters")
#define REGSTR_VAL_UPPERFILTERS                    TEXT("UpperFilters")
#define REGSTR_VAL_LOCATION_INFORMATION            TEXT("LocationInformation")
#define REGSTR_VAL_UI_NUMBER                       TEXT("UINumber")
#define REGSTR_VAL_UI_NUMBER_DESC_FORMAT           TEXT("UINumberDescFormat")
#define REGSTR_VAL_CAPABILITIES                    TEXT("Capabilities")
#define REGSTR_VAL_DEVICE_TYPE                     TEXT("DeviceType")
#define REGSTR_VAL_DEVICE_CHARACTERISTICS          TEXT("DeviceCharacteristics")
#define REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR      TEXT("Security")
#define REGSTR_VAL_DEVICE_EXCLUSIVE                TEXT("Exclusive")
#define REGSTR_VAL_RESOURCE_PICKER_TAGS            TEXT("ResourcePickerTags")
#define REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS      TEXT("ResourcePickerExceptions")
#define REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE      TEXT("CustomPropertyCacheDate")
#define REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY       TEXT("CustomPropertyHwIdKey")
#define REGSTR_VAL_LAST_UPDATE_TIME                TEXT("LastUpdateTime")
#define REGSTR_VAL_CONTAINERID                     TEXT("ContainerID")

//
// Values used by kernel mode Pnp Manager
//
#define REGSTR_VALUE_DEVICE_OBJECT_NAME            TEXT("DeviceObjectName")
#define REGSTR_VALUE_DEVICE_SYMBOLIC_NAME          TEXT("DeviceSymbolicName")
#define REGSTR_VAL_EJECT_PRIORITY                  TEXT("EjectPriority")

//
// Values used by both kernel-mode and user-mode PnP Managers
//
#define REGSTR_KEY_CONTROL                         TEXT("Control")
#define REGSTR_VAL_ACTIVESERVICE                   TEXT("ActiveService")
#define REGSTR_VAL_LINKED                          TEXT("Linked")
#define REGSTR_VAL_PHYSICALDEVICEOBJECT            TEXT("PhysicalDeviceObject")
#define REGSTR_VAL_REMOVAL_POLICY                  TEXT("RemovalPolicy")

//
// Values under REGSTR_PATH_NT_CURRENTVERSION
//
#define REGSTR_VAL_CURRENT_VERSION  TEXT("CurrentVersion")
#define REGSTR_VAL_CURRENT_BUILD    TEXT("CurrentBuildNumber")
#define REGSTR_VAL_CURRENT_CSDVERSION TEXT("CSDVersion")
#define REGSTR_VAL_CURRENT_TYPE     TEXT("CurrentType")

//
// Values under REGSTR_PATH_DISPLAYSETTINGS
//

#define REGSTR_VAL_BITSPERPIXEL  TEXT("BitsPerPixel")
#define REGSTR_VAL_RESOLUTION    TEXT("Resolution")
#define REGSTR_VAL_DPILOGICALX   TEXT("DPILogicalX")
#define REGSTR_VAL_DPILOGICALY   TEXT("DPILogicalY")
#define REGSTR_VAL_DPIPHYSICALX  TEXT("DPIPhysicalX")
#define REGSTR_VAL_DPIPHYSICALY  TEXT("DPIPhysicalY")
#define REGSTR_VAL_REFRESHRATE   TEXT("RefreshRate")
#define REGSTR_VAL_DISPLAYFLAGS  TEXT("DisplayFlags")


// under HKEY_CURRENT_USER
#define REGSTR_PATH_CONTROLPANEL    TEXT("Control Panel")

// under HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROLSFOLDER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder")

//
// Entries under REGSTR_PATH_CODEPAGE
//

#define REGSTR_VAL_DOSCP        TEXT("OEMCP")
#define REGSTR_VAL_WINCP        TEXT("ACP")

#define REGSTR_PATH_DYNA_ENUM   TEXT("Config Manager\\Enum")

//
// Entries under REGSTR_PATH_DYNA_ENUM
//
#define REGSTR_VAL_HARDWARE_KEY TEXT("HardWareKey")
#define REGSTR_VAL_ALLOCATION   TEXT("Allocation")
#define REGSTR_VAL_PROBLEM      TEXT("Problem")
#define REGSTR_VAL_STATUS       TEXT("Status")

//
//  Used by address arbitrator
//
#define REGSTR_VAL_DONTUSEMEM   TEXT("DontAllocLastMem")

//
//  Entries under REGSTR_PATH_SETUP
//
#define REGSTR_VAL_SYSTEMROOT           TEXT("SystemRoot")
#define REGSTR_VAL_BOOTCOUNT            TEXT("BootCount")
#define REGSTR_VAL_REALNETSTART         TEXT("RealNetStart")
#define REGSTR_VAL_MEDIA                TEXT("MediaPath")
#define REGSTR_VAL_CONFIG               TEXT("ConfigPath")
#define REGSTR_VAL_DEVICEPATH           TEXT("DevicePath")      //default search path for .INFs
#define REGSTR_VAL_SRCPATH              TEXT("SourcePath")      //last source files path during setup.
#define REGSTR_VAL_DRIVERCACHEPATH      TEXT("DriverCachePath") //location of driver cache

#define REGSTR_VAL_OLDWINDIR            TEXT("OldWinDir")       //old windows location
#define REGSTR_VAL_SETUPFLAGS           TEXT("SetupFlags")      //flags that setup passes on after install.
#define REGSTR_VAL_REGOWNER             TEXT("RegisteredOwner")
#define REGSTR_VAL_REGORGANIZATION      TEXT("RegisteredOrganization")
#define REGSTR_VAL_LICENSINGINFO        TEXT("LicensingInfo")
#define REGSTR_VAL_OLDMSDOSVER          TEXT("OldMSDOSVer") // will be DOS ver < 7 (when Setup run)
#define REGSTR_VAL_FIRSTINSTALLDATETIME TEXT("FirstInstallDateTime") // will Win 95 install date-time

#define REGSTR_VAL_INSTALLTYPE          TEXT("InstallType")
//  Values for InstallType
#define IT_COMPACT          0x0000
#define IT_TYPICAL          0x0001
#define IT_PORTABLE         0x0002
#define IT_CUSTOM           0x0003

#define REGSTR_VAL_WRAPPER              TEXT("Wrapper")

#define REGSTR_KEY_RUNHISTORY           TEXT("RunHistory")
#define REGSTR_VAL_LASTALIVEINTERVAL    TEXT("TimeStampInterval")
#define REGSTR_VAL_DIRTYSHUTDOWN        TEXT("DirtyShutdown")
#define REGSTR_VAL_DIRTYSHUTDOWNTIME    TEXT("DirtyShutdownTime")
#define REGSTR_VAL_BT                   TEXT("6005BT")
#define REGSTR_VAL_LASTCOMPUTERNAME     TEXT("LastComputerName")
#define REGSTR_VAL_LASTALIVEBT          TEXT("LastAliveBT")
#define REGSTR_VAL_LASTALIVESTAMP       TEXT("LastAliveStamp")
#define REGSTR_VAL_LASTALIVESTAMPFORCED TEXT("LastAliveStampForced")
#define REGSTR_VAL_LASTALIVESTAMPINTERVAL   TEXT("LastAliveStampInterval")
#define REGSTR_VAL_LASTALIVESTAMPPOLICYINTERVAL TEXT("LastAliveStampPolicyInterval")
#define REGSTR_VAL_LASTALIVEUPTIME      TEXT("LastAliveUptime")
#define REGSTR_VAL_LASTALIVEPMPOLICY    TEXT("LastAlivePMPolicy")

#define REGSTR_VAL_REASONCODE           TEXT("ReasonCode")
#define REGSTR_VAL_COMMENT              TEXT("Comment")

#define REGSTR_VAL_SHUTDOWNREASON       TEXT("ShutdownReason")
#define REGSTR_VAL_SHUTDOWNREASON_CODE          TEXT("ShutdownReasonCode")
#define REGSTR_VAL_SHUTDOWNREASON_COMMENT       TEXT("ShutdownReasonComment")
#define REGSTR_VAL_SHUTDOWNREASON_PROCESS       TEXT("ShutdownReasonProcess")
#define REGSTR_VAL_SHUTDOWNREASON_USERNAME      TEXT("ShutdownReasonUserName")
#define REGSTR_VAL_SHOWREASONUI                 TEXT("ShutdownReasonUI")
#define REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED   TEXT("ShutdownIgnorePredefinedReasons")
#define REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT      TEXT("ShutdownStateSnapshot")


#define REGSTR_KEY_SETUP                TEXT("\\Setup")
#define REGSTR_VAL_BOOTDIR              TEXT("BootDir")
#define REGSTR_VAL_WINBOOTDIR           TEXT("WinbootDir")
#define REGSTR_VAL_WINDIR               TEXT("WinDir")

#define REGSTR_VAL_APPINSTPATH          TEXT("AppInstallPath")    // Used by install wizard

// Values for international startup disk
#define REGSTR_PATH_EBD          REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\EBD")
// Keys under REGSTR_KEY_EBD
#define REGSTR_KEY_EBDFILESLOCAL     TEXT("EBDFilesLocale")
#define REGSTR_KEY_EBDFILESKEYBOARD     TEXT("EBDFilesKeyboard")
#define REGSTR_KEY_EBDAUTOEXECBATLOCAL TEXT("EBDAutoexecBatLocale")
#define REGSTR_KEY_EBDAUTOEXECBATKEYBOARD TEXT("EBDAutoexecBatKeyboard")
#define REGSTR_KEY_EBDCONFIGSYSLOCAL   TEXT("EBDConfigSysLocale")
#define REGSTR_KEY_EBDCONFIGSYSKEYBOARD   TEXT("EBDConfigSysKeyboard")


// Values under REGSTR_PATH_DRIVERSIGN and REGSTR_PATH_NONDRIVERSIGN
#define REGSTR_VAL_POLICY                     TEXT("Policy")

// Values under REGSTR_PATH_DRIVERSIGN_POLICY and REGSTR_PATH_NONDRIVERSIGN_POLICY
#define REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY  TEXT("BehaviorOnFailedVerify")

// Types of driver signing policies (apply to both preference and policy values
// defined above)
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002

//
//  Entries under REGSTR_PATH_PIFCONVERT
//
#define REGSTR_VAL_MSDOSMODE            TEXT("MSDOSMode")
#define REGSTR_VAL_MSDOSMODEDISCARD     TEXT("Discard")

//
//  Entries under REGSTR_PATH_MSDOSOPTS (global settings)
//
#define REGSTR_VAL_DOSOPTGLOBALFLAGS    TEXT("GlobalFlags")
//  Flags for GlobalFlags
#define DOSOPTGF_DEFCLEAN   0x00000001L // Default action is clean config

//
//  Entries under REGSTR_PATH_MSDOSOPTS \ OptionSubkey
//
#define REGSTR_VAL_DOSOPTFLAGS          TEXT("Flags")
#define REGSTR_VAL_OPTORDER             TEXT("Order")
#define REGSTR_VAL_CONFIGSYS            TEXT("Config.Sys")
#define REGSTR_VAL_AUTOEXEC             TEXT("Autoexec.Bat")
#define REGSTR_VAL_STDDOSOPTION         TEXT("StdOption")
#define REGSTR_VAL_DOSOPTTIP            TEXT("TipText")

//  Flags for DOSOPTFLAGS
#define DOSOPTF_DEFAULT     0x00000001L // Default enabled for clean config
#define DOSOPTF_SUPPORTED   0x00000002L // Option actually supported
#define DOSOPTF_ALWAYSUSE   0x00000004L // Always use this option
#define DOSOPTF_USESPMODE   0x00000008L // Option puts machine in Prot Mode
#define DOSOPTF_PROVIDESUMB 0x00000010L // Can load drivers high
#define DOSOPTF_NEEDSETUP   0x00000020L // Need to configure option
#define DOSOPTF_INDOSSTART  0x00000040L // Suppored by DOSSTART.BAT
#define DOSOPTF_MULTIPLE    0x00000080L // Load multiple configuration lines

//
//  Flags returned by SUGetSetSetupFlags and in the registry
//
#define SUF_FIRSTTIME   0x00000001L // First boot into Win95.
#define SUF_EXPRESS     0x00000002L // User Setup via express mode (vs customize).
#define SUF_BATCHINF    0x00000004L // Setup using batch file (MSBATCH.INF).
#define SUF_CLEAN       0x00000008L // Setup was done to a clean directory.
#define SUF_INSETUP     0x00000010L // You're in Setup.
#define SUF_NETSETUP    0x00000020L // Doing a net (workstation) setup.
#define SUF_NETHDBOOT   0x00000040L // Workstation boots from local harddrive
#define SUF_NETRPLBOOT  0x00000080L // Workstation boots via RPL (vs floppy)
#define SUF_SBSCOPYOK   0x00000100L // Can copy to LDID_SHARED (SBS)

//
//  Entries under REGSTR_PATH_VMM
//
#define REGSTR_VAL_DOSPAGER     TEXT("DOSPager")
#define REGSTR_VAL_VXDGROUPS    TEXT("VXDGroups")

//
//  Entries under REGSTR_PATH_VPOWERD
//
#define REGSTR_VAL_VPOWERDFLAGS TEXT("Flags")
#define VPDF_DISABLEPWRMGMT         0x00000001  // Don't load device
#define VPDF_FORCEAPM10MODE         0x00000002  // Always go into 1.0 mode
#define VPDF_SKIPINTELSLCHECK       0x00000004  // Don't detect Intel SL chipset
#define VPDF_DISABLEPWRSTATUSPOLL   0x00000008  // Don't poll power status
#define VPDF_DISABLERINGRESUME      0x00000010  // Don't let the modem wake the machine (APM 1.2 only)
#define VPDF_SHOWMULTIBATT          0x00000020  // Show all batteries checkbox in power control panel

//
// Entries under REGSTR_PATH_BUSINFORMATION
//
#define BIF_SHOWSIMILARDRIVERS      0x00000001  // Show similar drivers instead of all class drivers in UI.
#define BIF_RAWDEVICENEEDSDRIVER    0x00000002  // RAW device needs a driver installed.

//
//  Entries under REGSTR_PATH_VNETSUP
//
#define REGSTR_VAL_WORKGROUP TEXT("Workgroup")
#define REGSTR_VAL_DIRECTHOST TEXT("DirectHost")
#define REGSTR_VAL_FILESHARING          TEXT("FileSharing")
#define REGSTR_VAL_PRINTSHARING         TEXT("PrintSharing")

//
//  Entries under REGSTR_PATH_NWREDIR
//
#define REGSTR_VAL_FIRSTNETDRIVE        TEXT("FirstNetworkDrive")
#define REGSTR_VAL_MAXCONNECTIONS       TEXT("MaxConnections")
#define REGSTR_VAL_APISUPPORT           TEXT("APISupport")
#define REGSTR_VAL_MAXRETRY             TEXT("MaxRetry")
#define REGSTR_VAL_MINRETRY             TEXT("MinRetry")
#define REGSTR_VAL_SUPPORTLFN           TEXT("SupportLFN")
#define REGSTR_VAL_SUPPORTBURST         TEXT("SupportBurst")
#define REGSTR_VAL_SUPPORTTUNNELLING    TEXT("SupportTunnelling")
#define REGSTR_VAL_FULLTRACE            TEXT("FullTrace")
#define REGSTR_VAL_READCACHING          TEXT("ReadCaching")
#define REGSTR_VAL_SHOWDOTS             TEXT("ShowDots")
#define REGSTR_VAL_GAPTIME              TEXT("GapTime")
#define REGSTR_VAL_SEARCHMODE           TEXT("SearchMode")
#define REGSTR_VAL_SHELLVERSION     TEXT("ShellVersion")
#define REGSTR_VAL_MAXLIP           TEXT("MaxLIP")
#define REGSTR_VAL_PRESERVECASE     TEXT("PreserveCase")
#define REGSTR_VAL_OPTIMIZESFN      TEXT("OptimizeSFN")

//
//  Entries under REGSTR_PATH_NCPSERVER
//
#define REGSTR_VAL_NCP_BROWSEMASTER     TEXT("BrowseMaster")
#define REGSTR_VAL_NCP_USEPEERBROWSING  TEXT("Use_PeerBrowsing")
#define REGSTR_VAL_NCP_USESAP           TEXT("Use_Sap")

//
// Entries under REGSTR_PATH_VCOMM
//

#define REGSTR_VAL_PCCARD_POWER         TEXT("EnablePowerManagement")

//
//  Entries under REGSTR_PATH_FILESYSTEM
//
#define REGSTR_VAL_WIN31FILESYSTEM              TEXT("Win31FileSystem")
#define REGSTR_VAL_PRESERVELONGNAMES            TEXT("PreserveLongNames")
#define REGSTR_VAL_DRIVEWRITEBEHIND             TEXT("DriveWriteBehind")
#define REGSTR_VAL_ASYNCFILECOMMIT              TEXT("AsyncFileCommit")
#define REGSTR_VAL_PATHCACHECOUNT               TEXT("PathCache")
#define REGSTR_VAL_NAMECACHECOUNT               TEXT("NameCache")
#define REGSTR_VAL_CONTIGFILEALLOC              TEXT("ContigFileAllocSize")
#define REGSTR_VAL_FREESPACERATIO               TEXT("FreeSpaceRatio")
#define REGSTR_VAL_VOLIDLETIMEOUT               TEXT("VolumeIdleTimeout")
#define REGSTR_VAL_BUFFIDLETIMEOUT              TEXT("BufferIdleTimeout")
#define REGSTR_VAL_BUFFAGETIMEOUT               TEXT("BufferAgeTimeout")
#define REGSTR_VAL_NAMENUMERICTAIL              TEXT("NameNumericTail")
#define REGSTR_VAL_READAHEADTHRESHOLD           TEXT("ReadAheadThreshold")
#define REGSTR_VAL_DOUBLEBUFFER                 TEXT("DoubleBuffer")
#define REGSTR_VAL_SOFTCOMPATMODE               TEXT("SoftCompatMode")
#define REGSTR_VAL_DRIVESPINDOWN                TEXT("DriveSpinDown")
#define REGSTR_VAL_FORCEPMIO                    TEXT("ForcePMIO")
#define REGSTR_VAL_FORCERMIO                    TEXT("ForceRMIO")
#define REGSTR_VAL_LASTBOOTPMDRVS               TEXT("LastBootPMDrvs")
#define REGSTR_VAL_ACSPINDOWNPREVIOUS           TEXT("ACSpinDownPrevious")
#define REGSTR_VAL_BATSPINDOWNPREVIOUS          TEXT("BatSpinDownPrevious")
#define REGSTR_VAL_VIRTUALHDIRQ                 TEXT("VirtualHDIRQ")
#define REGSTR_VAL_SRVNAMECACHECOUNT            TEXT("ServerNameCacheMax")
#define REGSTR_VAL_SRVNAMECACHE                 TEXT("ServerNameCache")
#define REGSTR_VAL_SRVNAMECACHENETPROV          TEXT("ServerNameCacheNumNets")
#define REGSTR_VAL_AUTOMOUNT                    TEXT("AutoMountDrives")
#define REGSTR_VAL_COMPRESSIONMETHOD            TEXT("CompressionAlgorithm")
#define REGSTR_VAL_COMPRESSIONTHRESHOLD         TEXT("CompressionThreshold")
#define REGSTR_VAL_ACDRIVESPINDOWN              TEXT("ACDriveSpinDown")
#define REGSTR_VAL_BATDRIVESPINDOWN             TEXT("BatDriveSpinDown")

//
//      Entries under REGSTR_PATH_FILESYSTEM_NOVOLTRACK
//
//      A sub-key under which a variable number of variable length structures are stored.
//
//      Each structure contains an offset followed by a number of pattern bytes.
//      The pattern in each structure is compared at the specified offset within
//      the boot record at the time a volume is mounted.  If any pattern in this
//      set of patterns matches a pattern already in the boot record, VFAT will not
//      write a volume tracking serial number in the OEM_SerialNum field of the
//      boot record on the volume being mounted.
//

//
//  Entries under REGSTR_PATH_CDFS
//
#define REGSTR_VAL_CDCACHESIZE  TEXT("CacheSize")       // Number of 2K cache sectors
#define REGSTR_VAL_CDPREFETCH   TEXT("Prefetch")        // Number of 2K cache sectors for prefetching
#define REGSTR_VAL_CDPREFETCHTAIL TEXT("PrefetchTail")// Number of LRU1 prefetch sectors
#define REGSTR_VAL_CDRAWCACHE   TEXT("RawCache")        // Number of 2352-byte cache sectors
#define REGSTR_VAL_CDEXTERRORS  TEXT("ExtendedErrors")// Return extended error codes
#define REGSTR_VAL_CDSVDSENSE   TEXT("SVDSense")        // 0=PVD, 1=Kanji, 2=Unicode
#define REGSTR_VAL_CDSHOWVERSIONS TEXT("ShowVersions")// Show file version numbers
#define REGSTR_VAL_CDCOMPATNAMES TEXT("MSCDEXCompatNames")// Disable Numeric Tails on long file names
#define REGSTR_VAL_CDNOREADAHEAD TEXT("NoReadAhead")    // Disable Read Ahead if set to 1

//
//      define values for IOS devices
//
#define REGSTR_VAL_SCSI TEXT("SCSI\\")
#define REGSTR_VAL_ESDI TEXT("ESDI\\")
#define REGSTR_VAL_FLOP TEXT("FLOP\\")

//
// define defs for IOS device types and values for IOS devices
//

#define REGSTR_VAL_DISK TEXT("GenDisk")
#define REGSTR_VAL_CDROM        TEXT("GenCD")
#define REGSTR_VAL_TAPE TEXT("TAPE")
#define REGSTR_VAL_SCANNER TEXT("SCANNER")
#define REGSTR_VAL_FLOPPY       TEXT("FLOPPY")

#define REGSTR_VAL_SCSITID TEXT("SCSITargetID")
#define REGSTR_VAL_SCSILUN TEXT("SCSILUN")
#define REGSTR_VAL_REVLEVEL TEXT("RevisionLevel")
#define REGSTR_VAL_PRODUCTID TEXT("ProductId")
#define REGSTR_VAL_PRODUCTTYPE TEXT("ProductType")
#define REGSTR_VAL_DEVTYPE TEXT("DeviceType")
#define REGSTR_VAL_REMOVABLE TEXT("Removable")
#define  REGSTR_VAL_CURDRVLET TEXT("CurrentDriveLetterAssignment")
#define REGSTR_VAL_USRDRVLET TEXT("UserDriveLetterAssignment")
#define REGSTR_VAL_SYNCDATAXFER TEXT("SyncDataXfer")
#define REGSTR_VAL_AUTOINSNOTE  TEXT("AutoInsertNotification")
#define REGSTR_VAL_DISCONNECT TEXT("Disconnect")
#define REGSTR_VAL_INT13 TEXT("Int13")
#define REGSTR_VAL_PMODE_INT13 TEXT("PModeInt13")
#define REGSTR_VAL_USERSETTINGS TEXT("AdapterSettings")
#define REGSTR_VAL_NOIDE TEXT("NoIDE")

// The foll. clase name definitions should be the same as in dirkdrv.inx and
// cdrom.inx
#define REGSTR_VAL_DISKCLASSNAME        TEXT("DiskDrive")
#define REGSTR_VAL_CDROMCLASSNAME       TEXT("CDROM")

// The foll. value determines whether a port driver should be force loaded
// or not.

#define REGSTR_VAL_FORCELOAD    TEXT("ForceLoadPD")

// The foll. value determines whether or not the FIFO is used on the Floppy
// controller.

#define REGSTR_VAL_FORCEFIFO    TEXT("ForceFIFO")
#define REGSTR_VAL_FORCECL              TEXT("ForceChangeLine")

//
// Generic CLASS Entries
//
#define REGSTR_VAL_NOUSECLASS       TEXT("NoUseClass")            // Don't include this class in PnP functions
#define REGSTR_VAL_NOINSTALLCLASS   TEXT("NoInstallClass")        // Don't include this class in New Device Wizard
#define REGSTR_VAL_NODISPLAYCLASS   TEXT("NoDisplayClass")        // Don't include this class in Device Manager
#define REGSTR_VAL_SILENTINSTALL    TEXT("SilentInstall")         // Always Silent Install devices of this class.
//
//  Class Names
//
#define REGSTR_KEY_PCMCIA_CLASS     TEXT("PCMCIA")              //child of PATH_CLASS
#define REGSTR_KEY_SCSI_CLASS       TEXT("SCSIAdapter")
#define REGSTR_KEY_PORTS_CLASS      TEXT("ports")
#define REGSTR_KEY_MEDIA_CLASS      TEXT("MEDIA")
#define REGSTR_KEY_DISPLAY_CLASS    TEXT("Display")
#define REGSTR_KEY_KEYBOARD_CLASS   TEXT("Keyboard")
#define REGSTR_KEY_MOUSE_CLASS      TEXT("Mouse")
#define REGSTR_KEY_MONITOR_CLASS    TEXT("Monitor")
#define REGSTR_KEY_MODEM_CLASS      TEXT("Modem")

//
//  Values under PATH_CLASS\PCMCIA
//
#define REGSTR_VAL_PCMCIA_OPT   TEXT("Options")
#define PCMCIA_OPT_HAVE_SOCKET  0x00000001l
//#define PCMCIA_OPT_ENABLED    0x00000002l
#define PCMCIA_OPT_AUTOMEM      0x00000004l
#define PCMCIA_OPT_NO_SOUND     0x00000008l
#define PCMCIA_OPT_NO_AUDIO     0x00000010l
#define PCMCIA_OPT_NO_APMREMOVE 0x00000020l

#define REGSTR_VAL_PCMCIA_MEM   TEXT("Memory")  // Card services shared mem range
#define PCMCIA_DEF_MEMBEGIN     0x000C0000      // default 0xC0000 - 0x00FFFFFF
#define PCMCIA_DEF_MEMEND       0x00FFFFFF      // (0 - 16meg)
#define PCMCIA_DEF_MEMLEN       0x00001000      // default 4k window

#define REGSTR_VAL_PCMCIA_ALLOC TEXT("AllocMemWin")     // PCCard alloced memory Window
#define REGSTR_VAL_PCMCIA_ATAD  TEXT("ATADelay")        // ATA device config start delay

#define REGSTR_VAL_PCMCIA_SIZ   TEXT("MinRegionSize") // Minimum region size
#define PCMCIA_DEF_MIN_REGION   0x00010000      // 64K minimum region size

// Values in LPTENUM keys
#define REGSTR_VAL_P1284MDL     TEXT("Model")
#define REGSTR_VAL_P1284MFG     TEXT("Manufacturer")

//
//  Values under PATH_CLASS\ISAPNP
//
#define REGSTR_VAL_ISAPNP               TEXT("ISAPNP")  // ISAPNP VxD name
#define REGSTR_VAL_ISAPNP_RDP_OVERRIDE  TEXT("RDPOverRide")     // ReadDataPort OverRide

//
//  Values under PATH_CLASS\PCI
//
#define REGSTR_VAL_PCI                  TEXT("PCI")             // PCI VxD name
#define REGSTR_PCI_OPTIONS              TEXT("Options") // Possible PCI options
#define REGSTR_PCI_DUAL_IDE             TEXT("PCIDualIDE")      // Dual IDE flag
#define PCI_OPTIONS_USE_BIOS            0x00000001l
#define PCI_OPTIONS_USE_IRQ_STEERING    0x00000002l

//
//  Values under PATH_CLASS\AGPxxxx
//
//  note:  These flags affect standard AGP capabilities,
//         and are set in agplib
//
#define AGP_FLAG_NO_1X_RATE             0x00000001l
#define AGP_FLAG_NO_2X_RATE             0x00000002l
#define AGP_FLAG_NO_4X_RATE             0x00000004l
#define AGP_FLAG_NO_8X_RATE             0x00000008l
#define AGP_FLAG_REVERSE_INITIALIZATION 0x00000080l

#define AGP_FLAG_NO_SBA_ENABLE          0x00000100l
#define AGP_FLAG_NO_FW_ENABLE           0x00000200l

//
// AGP flags > AGP_SPECIAL_TARGET are platform specific
//
#define AGP_FLAG_SPECIAL_TARGET         0x000FFFFFl
#define AGP_FLAG_SPECIAL_RESERVE        0x000F8000l

//
// Detection related values
//
#define REGSTR_KEY_CRASHES      TEXT("Crashes") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DANGERS      TEXT("Dangers") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DETMODVARS   TEXT("DetModVars")      // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_NDISINFO     TEXT("NDISInfo")        // key of netcard hw entry
#define REGSTR_VAL_PROTINIPATH  TEXT("ProtIniPath")     // protocol.ini path
#define REGSTR_VAL_RESOURCES    TEXT("Resources")       // resources of crash func.
#define REGSTR_VAL_CRASHFUNCS   TEXT("CrashFuncs")      // detfunc caused the crash
#define REGSTR_VAL_CLASS        TEXT("Class")   // device class
#define REGSTR_VAL_CLASSDESC    TEXT("ClassDesc")       // class description
#define REGSTR_VAL_DEVDESC      TEXT("DeviceDesc")      // device description
#define REGSTR_VAL_BOOTCONFIG   TEXT("BootConfig")      // detected configuration
#define REGSTR_VAL_DETFUNC      TEXT("DetFunc") // specifies detect mod/func.
#define REGSTR_VAL_DETFLAGS     TEXT("DetFlags")        // detection flags
#define REGSTR_VAL_COMPATIBLEIDS TEXT("CompatibleIDs") //value of enum\dev\inst
#define REGSTR_VAL_DETCONFIG    TEXT("DetConfig")       // detected configuration
#define REGSTR_VAL_VERIFYKEY    TEXT("VerifyKey")       // key used in verify mode
#define REGSTR_VAL_COMINFO      TEXT("ComInfo") // com info. for serial mouse
#define REGSTR_VAL_INFNAME      TEXT("InfName") // INF filename
#define REGSTR_VAL_CARDSPECIFIC TEXT("CardSpecific")    // Netcard specific info (WORD)
#define REGSTR_VAL_NETOSTYPE    TEXT("NetOSType")       // NetOS type associate w/ card
#define REGSTR_DATA_NETOS_NDIS  TEXT("NDIS")            // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_ODI   TEXT("ODI")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_IPX   TEXT("IPX")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_VAL_MFG      TEXT("Mfg")
#define REGSTR_VAL_SCAN_ONLY_FIRST      TEXT("ScanOnlyFirstDrive")      // used with IDE driver
#define REGSTR_VAL_SHARE_IRQ    TEXT("ForceIRQSharing") // used with IDE driver
#define REGSTR_VAL_NONSTANDARD_ATAPI    TEXT("NonStandardATAPI")        // used with IDE driver
#define REGSTR_VAL_IDE_FORCE_SERIALIZE  TEXT("ForceSerialization")      // used with IDE driver
#define REGSTR_VAL_MAX_HCID_LEN 1024            // Maximum hardware/compat ID len
#define REGSTR_VAL_HWREV            TEXT("HWRevision")
#define REGSTR_VAL_ENABLEINTS  TEXT("EnableInts")
//
// Bit values of REGSTR_VAL_DETFLAGS
//
#define REGDF_NOTDETIO          0x00000001      //cannot detect I/O resource
#define REGDF_NOTDETMEM         0x00000002      //cannot detect mem resource
#define REGDF_NOTDETIRQ         0x00000004      //cannot detect IRQ resource
#define REGDF_NOTDETDMA         0x00000008      //cannot detect DMA resource
#define REGDF_NOTDETALL         (REGDF_NOTDETIO | REGDF_NOTDETMEM | REGDF_NOTDETIRQ | REGDF_NOTDETDMA)
#define REGDF_NEEDFULLCONFIG    0x00000010      //stop devnode if lack resource
#define REGDF_GENFORCEDCONFIG   0x00000020      //also generate forceconfig
#define REGDF_NODETCONFIG       0x00008000      //don't write detconfig to reg.
#define REGDF_CONFLICTIO        0x00010000      //I/O res. in conflict
#define REGDF_CONFLICTMEM       0x00020000      //mem res. in conflict
#define REGDF_CONFLICTIRQ       0x00040000      //IRQ res. in conflict
#define REGDF_CONFLICTDMA       0x00080000      //DMA res. in conflict
#define REGDF_CONFLICTALL       (REGDF_CONFLICTIO | REGDF_CONFLICTMEM | REGDF_CONFLICTIRQ | REGDF_CONFLICTDMA)
#define REGDF_MAPIRQ2TO9        0x00100000      //IRQ2 has been mapped to 9
#define REGDF_NOTVERIFIED       0x80000000      //previous device unverified

//
//  Values in REGSTR_KEY_SYSTEMBOARD
//
#define REGSTR_VAL_APMBIOSVER           TEXT("APMBiosVer")
#define REGSTR_VAL_APMFLAGS             TEXT("APMFlags")
#define REGSTR_VAL_SLSUPPORT            TEXT("SLSupport")
#define REGSTR_VAL_MACHINETYPE          TEXT("MachineType")
#define REGSTR_VAL_SETUPMACHINETYPE TEXT("SetupMachineType")
#define REGSTR_MACHTYPE_UNKNOWN         TEXT("Unknown")
#define REGSTR_MACHTYPE_IBMPC           TEXT("IBM PC")
#define REGSTR_MACHTYPE_IBMPCJR         TEXT("IBM PCjr")
#define REGSTR_MACHTYPE_IBMPCCONV       TEXT("IBM PC Convertible")
#define REGSTR_MACHTYPE_IBMPCXT         TEXT("IBM PC/XT")
#define REGSTR_MACHTYPE_IBMPCXT_286     TEXT("IBM PC/XT 286")
#define REGSTR_MACHTYPE_IBMPCAT         TEXT("IBM PC/AT")
#define REGSTR_MACHTYPE_IBMPS2_25       TEXT("IBM PS/2-25")
#define REGSTR_MACHTYPE_IBMPS2_30_286   TEXT("IBM PS/2-30 286")
#define REGSTR_MACHTYPE_IBMPS2_30       TEXT("IBM PS/2-30")
#define REGSTR_MACHTYPE_IBMPS2_50       TEXT("IBM PS/2-50")
#define REGSTR_MACHTYPE_IBMPS2_50Z      TEXT("IBM PS/2-50Z")
#define REGSTR_MACHTYPE_IBMPS2_55SX     TEXT("IBM PS/2-55SX")
#define REGSTR_MACHTYPE_IBMPS2_60       TEXT("IBM PS/2-60")
#define REGSTR_MACHTYPE_IBMPS2_65SX     TEXT("IBM PS/2-65SX")
#define REGSTR_MACHTYPE_IBMPS2_70       TEXT("IBM PS/2-70")
#define REGSTR_MACHTYPE_IBMPS2_P70      TEXT("IBM PS/2-P70")
#define REGSTR_MACHTYPE_IBMPS2_70_80    TEXT("IBM PS/2-70/80")
#define REGSTR_MACHTYPE_IBMPS2_80       TEXT("IBM PS/2-80")
#define REGSTR_MACHTYPE_IBMPS2_90       TEXT("IBM PS/2-90")
#define REGSTR_MACHTYPE_IBMPS1          TEXT("IBM PS/1")
#define REGSTR_MACHTYPE_PHOENIX_PCAT    TEXT("Phoenix PC/AT Compatible")
#define REGSTR_MACHTYPE_HP_VECTRA       TEXT("HP Vectra")
#define REGSTR_MACHTYPE_ATT_PC          TEXT("AT&T PC")
#define REGSTR_MACHTYPE_ZENITH_PC       TEXT("Zenith PC")

#define REGSTR_VAL_APMMENUSUSPEND       TEXT("APMMenuSuspend")
#define APMMENUSUSPEND_DISABLED         0                   // always disabled
#define APMMENUSUSPEND_ENABLED          1                   // always enabled
#define APMMENUSUSPEND_UNDOCKED         2                   // enabled undocked
#define APMMENUSUSPEND_NOCHANGE     0x80        // bitflag - cannot change setting via UI

#define REGSTR_VAL_APMACTIMEOUT         TEXT("APMACTimeout")
#define REGSTR_VAL_APMBATTIMEOUT        TEXT("APMBatTimeout")
#define APMTIMEOUT_DISABLED             0

#define REGSTR_VAL_APMSHUTDOWNPOWER TEXT("APMShutDownPower")

#define REGSTR_VAL_BUSTYPE          TEXT("BusType")
#define REGSTR_VAL_CPU              TEXT("CPU")
#define REGSTR_VAL_NDP              TEXT("NDP")
#define REGSTR_VAL_PNPBIOSVER       TEXT("PnPBIOSVer")
#define REGSTR_VAL_PNPSTRUCOFFSET   TEXT("PnPStrucOffset")
#define REGSTR_VAL_PCIBIOSVER       TEXT("PCIBIOSVer")
#define REGSTR_VAL_HWMECHANISM      TEXT("HWMechanism")
#define REGSTR_VAL_LASTPCIBUSNUM    TEXT("LastPCIBusNum")
#define REGSTR_VAL_CONVMEM          TEXT("ConvMem")
#define REGSTR_VAL_EXTMEM           TEXT("ExtMem")
#define REGSTR_VAL_COMPUTERNAME     TEXT("ComputerName")
#define REGSTR_VAL_BIOSNAME         TEXT("BIOSName")
#define REGSTR_VAL_BIOSVERSION      TEXT("BIOSVersion")
#define REGSTR_VAL_BIOSDATE         TEXT("BIOSDate")
#define REGSTR_VAL_MODEL            TEXT("Model")
#define REGSTR_VAL_SUBMODEL         TEXT("Submodel")
#define REGSTR_VAL_REVISION         TEXT("Revision")

//
//  Values used in the LPT(ECP) device entry
//
#define REGSTR_VAL_FIFODEPTH            TEXT("FIFODepth")
#define REGSTR_VAL_RDINTTHRESHOLD       TEXT("RDIntThreshold")
#define REGSTR_VAL_WRINTTHRESHOLD       TEXT("WRIntThreshold")

//used in enum\xxx\<devname>\<instname>
#define REGSTR_VAL_PRIORITY     TEXT("Priority")
#define REGSTR_VAL_DRIVER       TEXT("Driver")          //
#define REGSTR_VAL_FUNCDESC     TEXT("FunctionDesc")            //
#define REGSTR_VAL_FORCEDCONFIG TEXT("ForcedConfig")            //
#define REGSTR_VAL_CONFIGFLAGS  TEXT("ConfigFlags")             // (binary ULONG)
#define REGSTR_VAL_CSCONFIGFLAGS TEXT("CSConfigFlags")  // (binary ULONG)

#define CONFIGFLAG_DISABLED             0x00000001      // Set if disabled
#define CONFIGFLAG_REMOVED              0x00000002      // Set if a present hardware enum device deleted
#define CONFIGFLAG_MANUAL_INSTALL       0x00000004      // Set if the devnode was manually installed
#define CONFIGFLAG_IGNORE_BOOT_LC       0x00000008      // Set if skip the boot config
#define CONFIGFLAG_NET_BOOT             0x00000010      // Load this devnode when in net boot
#define CONFIGFLAG_REINSTALL            0x00000020      // Redo install
#define CONFIGFLAG_FAILEDINSTALL        0x00000040      // Failed the install
#define CONFIGFLAG_CANTSTOPACHILD       0x00000080      // Can't stop/remove a single child
#define CONFIGFLAG_OKREMOVEROM          0x00000100      // Can remove even if rom.
#define CONFIGFLAG_NOREMOVEEXIT         0x00000200      // Don't remove at exit.
#define CONFIGFLAG_FINISH_INSTALL       0x00000400      // Complete install for devnode running 'raw'
#define CONFIGFLAG_NEEDS_FORCED_CONFIG  0x00000800      // This devnode requires a forced config
#if defined(REMOTE_BOOT)
#define CONFIGFLAG_NETBOOT_CARD         0x00001000      // This is the remote boot network card
#endif // defined(REMOTE_BOOT)
#define CONFIGFLAG_PARTIAL_LOG_CONF     0x00002000      // This device has a partial logconfig
#define CONFIGFLAG_SUPPRESS_SURPRISE    0x00004000      // Set if unsafe removals should be ignored
#define CONFIGFLAG_VERIFY_HARDWARE      0x00008000      // Set if hardware should be tested for logo failures
#define CONFIGFLAG_FINISHINSTALL_UI     0x00010000      // Show the finish install wizard pages for the installed device.
#define CONFIGFLAG_FINISHINSTALL_ACTION 0x00020000      // Call installer with DIF_FINISHINSTALL_ACTION in client context.

#define CSCONFIGFLAG_BITS               0x00000007      // OR of below bits
#define CSCONFIGFLAG_DISABLED           0x00000001      // Set if
#define CSCONFIGFLAG_DO_NOT_CREATE      0x00000002      // Set if
#define CSCONFIGFLAG_DO_NOT_START       0x00000004      // Set if

#define DMSTATEFLAG_APPLYTOALL      0x00000001  // Set if Apply To All check box is checked

//
// Special devnodes name
//
#define REGSTR_VAL_ROOT_DEVNODE         TEXT("HTREE\\ROOT\\0")
#define REGSTR_VAL_RESERVED_DEVNODE     TEXT("HTREE\\RESERVED\\0")
#define REGSTR_PATH_READDATAPORT        REGSTR_KEY_ISAENUM TEXT("\\ReadDataPort\\0")

//
// Multifunction definitions
//
#define REGSTR_PATH_MULTI_FUNCTION              TEXT("MF")
#define REGSTR_VAL_RESOURCE_MAP                 TEXT("ResourceMap")
#define REGSTR_PATH_CHILD_PREFIX                TEXT("Child")
#define NUM_RESOURCE_MAP                        256
#define REGSTR_VAL_MF_FLAGS                     TEXT("MFFlags")
#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

//
// EISA multi functions add-on
//
#ifndef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("EISARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("EISAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("EISAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("EISAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("EISASimulateInt15")
#else // ifdef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("NESARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("NESAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("NESAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("NESAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("NESASimulateInt15")
#endif // ifdef NEC_98
#define EISAFLAG_NO_IO_MERGE            0x00000001
#define EISAFLAG_SLOT_IO_FIRST          0x00000002
#define EISA_NO_MAX_FUNCTION            0xFF
#define NUM_EISA_RANGES                 4


//
//  Driver entries
//
#define REGSTR_VAL_DRVDESC      TEXT("DriverDesc")      // value of enum\dev\inst\DRV
#define REGSTR_VAL_DEVLOADER    TEXT("DevLoader")       // value of DRV
#define REGSTR_VAL_STATICVXD    TEXT("StaticVxD")       // value of DRV
#define REGSTR_VAL_PROPERTIES   TEXT("Properties")      // value of DRV
#define REGSTR_VAL_MANUFACTURER TEXT("Manufacturer")
#define REGSTR_VAL_EXISTS       TEXT("Exists")  // value of HCC\HW\ENUM\ROOT\dev\inst
#define REGSTR_VAL_CMENUMFLAGS  TEXT("CMEnumFlags")     // (binary ULONG)
#define REGSTR_VAL_CMDRIVFLAGS  TEXT("CMDrivFlags")     // (binary ULONG)
#define REGSTR_VAL_ENUMERATOR   TEXT("Enumerator")      // value of DRV
#define REGSTR_VAL_DEVICEDRIVER TEXT("DeviceDriver")    // value of DRV
#define REGSTR_VAL_PORTNAME     TEXT("PortName")        // VCOMM uses this for it's port names
#define REGSTR_VAL_INFPATH      TEXT("InfPath")
#define REGSTR_VAL_INFSECTION   TEXT("InfSection")
#define REGSTR_VAL_INFSECTIONEXT TEXT("InfSectionExt")
#define REGSTR_VAL_POLLING      TEXT("Polling")             // SCSI specific
#define REGSTR_VAL_DONTLOADIFCONFLICT TEXT("DontLoadIfConflict")  // SCSI specific
#define REGSTR_VAL_PORTSUBCLASS TEXT("PortSubClass")
#define REGSTR_VAL_NETCLEAN TEXT("NetClean") // Driver required for NetClean boot
#define REGSTR_VAL_IDE_NO_SERIALIZE TEXT("IDENoSerialize") // IDE specific
#define REGSTR_VAL_NOCMOSORFDPT TEXT("NoCMOSorFDPT")       // IDE specific
#define REGSTR_VAL_COMVERIFYBASE TEXT("COMVerifyBase")     // VCD specific
#define REGSTR_VAL_MATCHINGDEVID TEXT("MatchingDeviceId")
#define REGSTR_VAL_DRIVERDATE   TEXT("DriverDate")      // value of DRV
#define REGSTR_VAL_DRIVERDATEDATA TEXT("DriverDateData")// value of DRV
#define REGSTR_VAL_DRIVERVERSION TEXT("DriverVersion")  // value of DRV
#define REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE    TEXT("LocationInformationOverride")  // value of DRV


//
//  Driver keys
//
#define REGSTR_KEY_OVERRIDE     TEXT("Override")        // key under the software section

//used by CONFIGMG
#define REGSTR_VAL_CONFIGMG     TEXT("CONFIGMG")        // Config Manager VxD name
#define REGSTR_VAL_SYSDM        TEXT("SysDM")           // The device installer DLL
#define REGSTR_VAL_SYSDMFUNC    TEXT("SysDMFunc")       // The device installer DLL function
#define REGSTR_VAL_PRIVATE      TEXT("Private") // The private library
#define REGSTR_VAL_PRIVATEFUNC  TEXT("PrivateFunc")     // The private library function
#define REGSTR_VAL_DETECT       TEXT("Detect")  // The detection library
#define REGSTR_VAL_DETECTFUNC   TEXT("DetectFunc")      // The detection library function
#define REGSTR_VAL_ASKFORCONFIG TEXT("AskForConfig")    // The AskForConfig library
#define REGSTR_VAL_ASKFORCONFIGFUNC TEXT("AskForConfigFunc") // The AskForConfig library function
#define REGSTR_VAL_WAITFORUNDOCK TEXT("WaitForUndock")  // The WaitForUndock library
#define REGSTR_VAL_WAITFORUNDOCKFUNC TEXT("WaitForUndockFunc") // The WaitForUndock library function
#define REGSTR_VAL_REMOVEROMOKAY TEXT("RemoveRomOkay")  // The RemoveRomOkay library
#define REGSTR_VAL_REMOVEROMOKAYFUNC TEXT("RemoveRomOkayFunc") // The RemoveRomOkay library function

//used in IDCONFIGDB
#define REGSTR_VAL_CURCONFIG    TEXT("CurrentConfig")           //value of idconfigdb
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")            //value of idconfigdb
#define REGSTR_VAL_CURRENTCONFIG TEXT("CurrentConfig")  //value of idconfigdb
#define REGSTR_VAL_MAP          TEXT("Map")                     //value of idconfigdb
#define REGSTR_VAL_ID           TEXT("CurrentID")               //value of idconfigdb
#define REGSTR_VAL_DOCKED       TEXT("CurrentDockedState")      //value of idconfigdb
#define REGSTR_VAL_CHECKSUM     TEXT("CurrentChecksum") //value of idconfigdb
#define REGSTR_VAL_HWDETECT     TEXT("HardwareDetect")  //value of idconfigdb
#define REGSTR_VAL_INHIBITRESULTS TEXT("InhibitResults")        //value of idconfigdb

//used in HKEY_CURRENT_CONFIG
#define REGSTR_VAL_PROFILEFLAGS TEXT("ProfileFlags")    // value of HKEY_CURRENT_CONFIG

//used in PCMCIA
#define REGSTR_KEY_PCMCIA       TEXT("PCMCIA\\")        //PCMCIA dev ID prefix
#define REGSTR_KEY_PCUNKNOWN    TEXT("UNKNOWN_MANUFACTURER")    //PCMCIA dev ID manuf
#define REGSTR_VAL_PCSSDRIVER   TEXT("Driver")  //value of DRV
#define REGSTR_KEY_PCMTD        TEXT("MTD-")            //MTD dev ID component
#define REGSTR_VAL_PCMTDRIVER   TEXT("MTD")             //value of Mem Tech DRV

//used in hardware\enum\dev\inst by Device Installer
#define REGSTR_VAL_HARDWAREID    TEXT("HardwareID")      //value of enum\dev\inst

//value names under class brach REGSTR_KEY_CLASS + class name
// and for the drivers REGSTR_KEY_CLASS\classname\xxxx
#define REGSTR_VAL_INSTALLER          TEXT("Installer")         // 16-bit class installer module/entry point
#define REGSTR_VAL_INSTALLER_32       TEXT("Installer32")       // 32-bit class installer module/entry point
#define REGSTR_VAL_INSICON            TEXT("Icon")              // value of class\name
#define REGSTR_VAL_ENUMPROPPAGES      TEXT("EnumPropPages")     // For Class/Device Properties (16-bit)
#define REGSTR_VAL_ENUMPROPPAGES_32   TEXT("EnumPropPages32")   // For Class/Device Properties (32-bit)
#define REGSTR_VAL_BASICPROPERTIES    TEXT("BasicProperties")   // For CPL basic Properties (16-bit)
#define REGSTR_VAL_BASICPROPERTIES_32 TEXT("BasicProperties32") // For CPL basic Properties (32-bit)
#define REGSTR_VAL_COINSTALLERS_32    TEXT("CoInstallers32")    // Device-specific co-installer multi-sz list (32-bit)
#define REGSTR_VAL_PRIVATEPROBLEM     TEXT("PrivateProblem")    // For Handling Private Problems

// names used for display driver set information
#define REGSTR_KEY_CURRENT      TEXT("Current") // current mode information
#define REGSTR_KEY_DEFAULT      TEXT("Default") // default configuration
#define REGSTR_KEY_MODES        TEXT("Modes")   // modes subtree

#define REGSTR_VAL_MODE         TEXT("Mode")            // default mode
#define REGSTR_VAL_BPP          TEXT("BPP")             // bits per pixel
#define REGSTR_VAL_HRES         TEXT("HRes")            // horizontal resolution
#define REGSTR_VAL_VRES         TEXT("VRes")            // vertical resolution
#define REGSTR_VAL_FONTSIZE     TEXT("FontSize")        // used in default or override
#define REGSTR_VAL_DRV          TEXT("drv")             // the driver file
#define REGSTR_VAL_GRB          TEXT("grb")             // the grabber file
#define REGSTR_VAL_VDD          TEXT("vdd")             // vdds used here
#define REGSTR_VAL_VER          TEXT("Ver")
#define REGSTR_VAL_MAXRES       TEXT("MaxResolution") // max res for monitors
#define REGSTR_VAL_DPMS         TEXT("DPMS")            // DPMS enabled
#define REGSTR_VAL_RESUMERESET  TEXT("ResumeReset")   // need reset on resume

#define REGSTR_VAL_DESCRIPTION TEXT("Description")

// keys in fontsize tree
#define REGSTR_KEY_SYSTEM       TEXT("System")  // entries for system.ini
#define REGSTR_KEY_USER         TEXT("User")            // entries for win.ini
#define REGSTR_VAL_DPI          TEXT("dpi")             // dpi of fontsize

//
// Used by PCIC socket services
//
#define REGSTR_VAL_PCICOPTIONS  TEXT("PCICOptions")     // Binary DWORD.  IRQ mask in
                                                // low word.  # skts in high
#ifndef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x4EB8          // Default IRQ masks
#else // ifdef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x1468          // Default IRQ masks
#endif // ifdef NEC_98
#define PCIC_DEFAULT_NUMSOCKETS 0               // 0 = Automatic detection
#define REGSTR_VAL_PCICIRQMAP   TEXT("PCICIRQMap")      // Binary 16 byte IRQ map table

// names used for control panel entries
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define REGSTR_VAL_CUSTOMCOLORS TEXT("CustomColors")

#define REGSTR_PATH_SCREENSAVE          TEXT("Control Panel\\Desktop")
#define REGSTR_VALUE_USESCRPASSWORD TEXT("ScreenSaveUsePassword")
#define REGSTR_VALUE_SCRPASSWORD    TEXT("ScreenSave_Data")

#define REGSTR_VALUE_LOWPOWERTIMEOUT    TEXT("ScreenSaveLowPowerTimeout")
#define REGSTR_VALUE_POWEROFFTIMEOUT    TEXT("ScreenSavePowerOffTimeout")
#define REGSTR_VALUE_LOWPOWERACTIVE     TEXT("ScreenSaveLowPowerActive")
#define REGSTR_VALUE_POWEROFFACTIVE     TEXT("ScreenSavePowerOffActive")

// used for Windows applets
#define REGSTR_PATH_WINDOWSAPPLETS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")

//
// system tray.  Flag values defined in systrap.h
//
#define REGSTR_PATH_SYSTRAY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray")
#define REGSTR_VAL_SYSTRAYSVCS TEXT("Services")
#define REGSTR_VAL_SYSTRAYBATFLAGS TEXT("PowerFlags")
#define REGSTR_VAL_SYSTRAYPCCARDFLAGS TEXT("PCMCIAFlags")

//
// Used by system networking components to store per-user values.
// All keys here are under HKCU.
//
#define REGSTR_PATH_NETWORK_USERSETTINGS        TEXT("Network")

#define REGSTR_KEY_NETWORK_PERSISTENT           TEXT("\\Persistent")
#define REGSTR_KEY_NETWORK_RECENT               TEXT("\\Recent")
#define REGSTR_VAL_REMOTE_PATH                  TEXT("RemotePath")
#define REGSTR_VAL_USER_NAME                    TEXT("UserName")
#define REGSTR_VAL_PROVIDER_NAME                TEXT("ProviderName")
#define REGSTR_VAL_CONNECTION_TYPE              TEXT("ConnectionType")
#define REGSTR_VAL_UPGRADE                      TEXT("Upgrade")

#define REGSTR_KEY_LOGON TEXT("\\Logon")
#define REGSTR_VAL_MUSTBEVALIDATED  TEXT("MustBeValidated")
#define REGSTR_VAL_RUNLOGINSCRIPT       TEXT("ProcessLoginScript")

//
// NetworkProvider entries. These entries are under
// REGSTR_PATH_SERVICES\\xxx\\NetworkProvider
//
#define REGSTR_KEY_NETWORKPROVIDER TEXT("\\NetworkProvider")
#define REGSTR_PATH_NW32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\NWNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_PATH_MS32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\MSNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_VAL_AUTHENT_AGENT TEXT("AuthenticatingAgent")

//
// Entries under REGSTR_PATH_REALMODENET
//
#define REGSTR_VAL_PREFREDIR TEXT("PreferredRedir")
#define REGSTR_VAL_AUTOSTART TEXT("AutoStart")
#define REGSTR_VAL_AUTOLOGON TEXT("AutoLogon")
#define REGSTR_VAL_NETCARD TEXT("Netcard")
#define REGSTR_VAL_TRANSPORT TEXT("Transport")
#define REGSTR_VAL_DYNAMIC TEXT("Dynamic")
#define REGSTR_VAL_TRANSITION TEXT("Transition")
#define REGSTR_VAL_STATICDRIVE TEXT("StaticDrive")
#define REGSTR_VAL_LOADHI TEXT("LoadHi")
#define REGSTR_VAL_LOADRMDRIVERS TEXT("LoadRMDrivers")
#define REGSTR_VAL_SETUPN TEXT("SetupN")
#define REGSTR_VAL_SETUPNPATH TEXT("SetupNPath")

//
// Entries under REGSTR_PATH_CVNETWORK
//
#define REGSTR_VAL_WRKGRP_FORCEMAPPING TEXT("WrkgrpForceMapping")
#define REGSTR_VAL_WRKGRP_REQUIRED TEXT("WrkgrpRequired")

//
// NT-compatible place where the name of the currently logged-on user is stored.
//
#define REGSTR_PATH_CURRENT_CONTROL_SET TEXT("System\\CurrentControlSet\\Control")
#define REGSTR_VAL_CURRENT_USER                 TEXT("Current User")

// section where password providers are installed (each provider has subkey under this key)
#define REGSTR_PATH_PWDPROVIDER         TEXT("System\\CurrentControlSet\\Control\\PwdProvider")
#define REGSTR_VAL_PWDPROVIDER_PATH TEXT("ProviderPath")
#define REGSTR_VAL_PWDPROVIDER_DESC TEXT("Description")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWD TEXT("ChangePassword")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND TEXT("ChangePasswordHwnd")
#define REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS TEXT("GetPasswordStatus")
#define REGSTR_VAL_PWDPROVIDER_ISNP TEXT("NetworkProvider")
#define REGSTR_VAL_PWDPROVIDER_CHANGEORDER TEXT("ChangeOrder")

//
// Used by administrator configuration tool and various components who enforce
// policies.
//
#define REGSTR_PATH_POLICIES    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")

// used to control remote update of administrator policies
#define REGSTR_PATH_UPDATE              TEXT("System\\CurrentControlSet\\Control\\Update")
#define REGSTR_VALUE_ENABLE             TEXT("Enable")
#define REGSTR_VALUE_VERBOSE    TEXT("Verbose")
#define REGSTR_VALUE_NETPATH    TEXT("NetworkPath")
#define REGSTR_VALUE_DEFAULTLOC TEXT("UseDefaultNetLocation")

//
//      Entries under REGSTR_PATH_POLICIES
//
#define REGSTR_KEY_NETWORK              TEXT("Network")
#define REGSTR_KEY_SYSTEM               TEXT("System")
#define REGSTR_KEY_PRINTERS             TEXT("Printers")
#define REGSTR_KEY_WINOLDAPP            TEXT("WinOldApp")
#define REGSTR_KEY_EXPLORER             TEXT("Explorer")

// Explorer run policy
#define REGSTR_PATH_RUN_POLICY          REGSTR_PATH_POLICIES TEXT("\\Explorer\\Run")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("0") if value not present)
// policies under NETWORK key
#define REGSTR_VAL_NOFILESHARING                TEXT("NoFileSharing") // TEXT("1") prevents server from loading
#define REGSTR_VAL_NOPRINTSHARING               TEXT("NoPrintSharing")
#define REGSTR_VAL_NOFILESHARINGCTRL    TEXT("NoFileSharingControl") // TEXT("1") removes sharing ui
#define REGSTR_VAL_NOPRINTSHARINGCTRL   TEXT("NoPrintSharingControl")
#define REGSTR_VAL_HIDESHAREPWDS                TEXT("HideSharePwds") // TEXT("1") hides share passwords with asterisks
#define REGSTR_VAL_DISABLEPWDCACHING    TEXT("DisablePwdCaching") // TEXT("1") disables caching
#define REGSTR_VAL_ALPHANUMPWDS                 TEXT("AlphanumPwds") // TEXT("1") forces alphanumeric passwords
#define REGSTR_VAL_NETSETUP_DISABLE                     TEXT("NoNetSetup")
#define REGSTR_VAL_NETSETUP_NOCONFIGPAGE        TEXT("NoNetSetupConfigPage")
#define REGSTR_VAL_NETSETUP_NOIDPAGE            TEXT("NoNetSetupIDPage")
#define REGSTR_VAL_NETSETUP_NOSECURITYPAGE      TEXT("NoNetSetupSecurityPage")
#define REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE  TEXT("NoVirtMemPage")
#define REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE   TEXT("NoDevMgrPage")
#define REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       TEXT("NoConfigPage")
#define REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      TEXT("NoFileSysPage")
#define REGSTR_VAL_DISPCPL_NODISPCPL            TEXT("NoDispCPL")
#define REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE TEXT("NoDispBackgroundPage")
#define REGSTR_VAL_DISPCPL_NOSCRSAVPAGE TEXT("NoDispScrSavPage")
#define REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE TEXT("NoDispAppearancePage")
#define REGSTR_VAL_DISPCPL_NOSETTINGSPAGE TEXT("NoDispSettingsPage")
#define REGSTR_VAL_SECCPL_NOSECCPL                      TEXT("NoSecCPL")
#define REGSTR_VAL_SECCPL_NOPWDPAGE                     TEXT("NoPwdPage")
#define REGSTR_VAL_SECCPL_NOADMINPAGE           TEXT("NoAdminPage")
#define REGSTR_VAL_SECCPL_NOPROFILEPAGE         TEXT("NoProfilePage")
#define REGSTR_VAL_PRINTERS_HIDETABS            TEXT("NoPrinterTabs")
#define REGSTR_VAL_PRINTERS_NODELETE            TEXT("NoDeletePrinter")
#define REGSTR_VAL_PRINTERS_NOADD                       TEXT("NoAddPrinter")
#define REGSTR_VAL_WINOLDAPP_DISABLED           TEXT("Disabled")
#define REGSTR_VAL_WINOLDAPP_NOREALMODE         TEXT("NoRealMode")
#define REGSTR_VAL_NOENTIRENETWORK                      TEXT("NoEntireNetwork")
#define REGSTR_VAL_NOWORKGROUPCONTENTS          TEXT("NoWorkgroupContents")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("1") if value not present)
// policies under Policies\SYSTEM key
#define REGSTR_VAL_UNDOCK_WITHOUT_LOGON         TEXT("UndockWithoutLogon")

// REG_DWORD, 0=off, otherwise value is minimum # of chars to allow in password
#define REGSTR_VAL_MINPWDLEN                    TEXT("MinPwdLen")
// REG_DWORD, 0=off, otherwise value is # of days for pwd to expire
#define REGSTR_VAL_PWDEXPIRATION                TEXT("PwdExpiration")

#define REGSTR_VAL_WIN31PROVIDER                TEXT("Win31Provider") // REG_SZ

// policies under SYSTEM key
#define REGSTR_VAL_DISABLEREGTOOLS              TEXT("DisableRegistryTools")

#define REGSTR_PATH_WINLOGON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define REGSTR_VAL_LEGALNOTICECAPTION   TEXT("LegalNoticeCaption")      // REG_SZ
#define REGSTR_VAL_LEGALNOTICETEXT              TEXT("LegalNoticeText")         // REG_SZ
#define REGSTR_VAL_DRIVE_SPINDOWN               TEXT("NoDispSpinDown")
#define REGSTR_VAL_SHUTDOWN_FLAGS       	TEXT("ShutdownFlags")


#define REGSTR_VAL_RESTRICTRUN  TEXT("RestrictRun")
//
//  Entries in policy file.  (Won't be in local registry, only policy hive)
#define REGSTR_KEY_POL_USERS            TEXT("Users")
#define REGSTR_KEY_POL_COMPUTERS        TEXT("Computers")
#define REGSTR_KEY_POL_USERGROUPS       TEXT("UserGroups")
#define REGSTR_KEY_POL_DEFAULT          TEXT(".default")
#define REGSTR_KEY_POL_USERGROUPDATA TEXT("GroupData\\UserGroups\\Priority")

//
//      Entries for time zone information under LOCAL_MACHINE
//
#define REGSTR_PATH_TIMEZONE        TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation")
#define REGSTR_VAL_TZBIAS           TEXT("Bias")
#define REGSTR_VAL_TZDLTBIAS        TEXT("DaylightBias")
#define REGSTR_VAL_TZSTDBIAS        TEXT("StandardBias")
#define REGSTR_VAL_TZACTBIAS        TEXT("ActiveTimeBias")
#define REGSTR_VAL_TZDLTFLAG        TEXT("DaylightFlag")
#define REGSTR_VAL_TZSTDSTART       TEXT("StandardStart")
#define REGSTR_VAL_TZDLTSTART       TEXT("DaylightStart")
#define REGSTR_VAL_TZDLTNAME        TEXT("DaylightName")
#define REGSTR_VAL_TZSTDNAME        TEXT("StandardName")
#define REGSTR_VAL_TZNOCHANGESTART  TEXT("NoChangeStart")
#define REGSTR_VAL_TZNOCHANGEEND    TEXT("NoChangeEnd")
#define REGSTR_VAL_TZNOAUTOTIME     TEXT("DisableAutoDaylightTimeSet")

//
//      Entries for floating point processor existence under LOCAL_MACHINE
//
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor")
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR0 TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor\\0")


//
//      Entries for computer name under LOCAL_MACHINE
//
#define REGSTR_PATH_COMPUTRNAME TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
#define REGSTR_VAL_COMPUTRNAME TEXT("ComputerName")

//      Entry so that we force a reboot on shutdown / single instance dos app
#define REGSTR_PATH_SHUTDOWN TEXT("System\\CurrentControlSet\\Control\\Shutdown")
#define REGSTR_VAL_FORCEREBOOT     TEXT("ForceReboot")
#define REGSTR_VAL_SETUPPROGRAMRAN TEXT("SetupProgramRan")
#define REGSTR_VAL_DOES_POLLING    TEXT("PollingSupportNeeded")

//
//      Entries for known system DLLs under LOCAL_MACHINE
//
//      The VAL keys here are the actual DLL names (FOO.DLL)
//
#define REGSTR_PATH_KNOWNDLLS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs")
#define REGSTR_PATH_KNOWN16DLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\Known16DLLs")

//      Entries here for system dlls we need to version check in case overwritten
#define REGSTR_PATH_CHECKVERDLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckVerDLLs")
#define REGSTR_PATH_WARNVERDLLS  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\WarnVerDLLs")

//      Entries here for app ini files we (msgsrv32) need to hack
#define REGSTR_PATH_HACKINIFILE  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\HackIniFiles")

//      Keys here for bad applications we want to warn the user about before running
#define REGSTR_PATH_CHECKBADAPPS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps")

//      Keys here for applications we need to update
#define REGSTR_PATH_APPPATCH TEXT("System\\CurrentControlSet\\Control\\SessionManager\\AppPatches")

#define REGSTR_PATH_CHECKBADAPPS400 TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps400")

//
//      Entries for known system VxDs under LOCAL_MACHINE
//
//      The VAL keys here are the full path names of VxDs (c:\app\vapp.vxd)
//      It is suggested that the keynames be the same as the module name of
//      the VxD.
//      This section is used to dyna-load VxDs with
//      CreateFile(\\.\vxd_regstr_keyname).
//

#define REGSTR_PATH_KNOWNVXDS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownVxDs")

//
// Entries for values in uninstaller keys under REGSTR_PATH_UNINSTALL \ appname
//
#define REGSTR_VAL_UNINSTALLER_DISPLAYNAME     TEXT("DisplayName")
#define REGSTR_VAL_UNINSTALLER_COMMANDLINE     TEXT("UninstallString")

//
// Entries for values in uninstaller keys under REGSTR_PATH_REINSTALL \ instanceid
//
#define REGSTR_VAL_REINSTALL_DISPLAYNAME        TEXT("DisplayName")
#define REGSTR_VAL_REINSTALL_STRING             TEXT("ReinstallString")
#define REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS  TEXT("DeviceInstanceIds")

//
//      Entries for known per user settings: Under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DESKTOP     REGSTR_PATH_SCREENSAVE
#define REGSTR_PATH_MOUSE           TEXT("Control Panel\\Mouse")
#define REGSTR_PATH_KEYBOARD    TEXT("Control Panel\\Keyboard")
#define REGSTR_PATH_COLORS          TEXT("Control Panel\\Colors")
#define REGSTR_PATH_SOUND           TEXT("Control Panel\\Sound")
#define REGSTR_PATH_METRICS         TEXT("Control Panel\\Desktop\\WindowMetrics")
#define REGSTR_PATH_ICONS       TEXT("Control Panel\\Icons")
#define REGSTR_PATH_CURSORS     TEXT("Control Panel\\Cursors")
#define REGSTR_PATH_CHECKDISK   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive")
#define REGSTR_PATH_CHECKDISKSET    TEXT("Settings")
#define REGSTR_PATH_CHECKDISKUDRVS  TEXT("NoUnknownDDErrDrvs")
//
//  Entries under REGSTR_PATH_FAULT
//
#define REGSTR_PATH_FAULT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fault")
#define REGSTR_VAL_FAULT_LOGFILE        TEXT("LogFile")

//
//  Entries under REGSTR_PATH_AEDEBUG
//
#define REGSTR_PATH_AEDEBUG             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGSTR_VAL_AEDEBUG_DEBUGGER     TEXT("Debugger")
#define REGSTR_VAL_AEDEBUG_AUTO         TEXT("Auto")

//
//  Entries under REGSTR_PATH_GRPCONV
//
#define REGSTR_PATH_GRPCONV     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\GrpConv")

//
//  Entries under the RegItem key in a shell namespace
//
#define REGSTR_VAL_REGITEMDELETEMESSAGE TEXT("Removal Message")

//
//  Entries for the Drives Tools page
//
//  NOTE that these items are not recorded for removable drives. These
//  keys record X=DSKTLSYSTEMTIME where X is the drive letter. Since
//  these tools actually work on the disk in the drive, as opposed to
//  the drive itself, it is pointless to record them on a removable media
//  since if a different disk is inserted in the drive, the data is
//  meaningless.
//
#define REGSTR_PATH_LASTCHECK           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastCheck")
#define REGSTR_PATH_LASTOPTIMIZE        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastOptimize")
#define REGSTR_PATH_LASTBACKUP          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastBackup")
//
// The above 3 keys record with the registry value of the drive letter
// a SYSTEMTIME structure
//

//
// Entries under HKEY_LOCAL_MACHINE for Check Drive specific stuff
//
#define REGSTR_PATH_CHKLASTCHECK        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastCheck")
#define REGSTR_PATH_CHKLASTSURFAN       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastSurfaceAnalysis")

#ifndef _IN_KERNEL_

//
// The above 2 keys record the following binary structure which is
// a system time structure with the addition of a result code field.
// Note that the time part of REGSTR_PATH_CHKLASTCHECK is effectively
// identical to REGSTR_PATH_LASTCHECK under the explorer key
//
typedef struct _DSKTLSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wResult;
} DSKTLSYSTEMTIME, *PDSKTLSYSTEMTIME, *LPDSKTLSYSTEMTIME;

#endif

//
// The following are defines for the wResult field
//
#define DTRESULTOK      0       // Operation was successful, no errors
#define DTRESULTFIX     1       // Operation was successful, errors were found
                                //   but all were fixed.
#define DTRESULTPROB    2       // Operation was not successful or errors
                                //   were found and some or all were not fixed.
#define DTRESULTPART    3       // Operation was partially completed but was
                                //   terminated either by the user or an error.

//
//  Entries for persistent shares
//
#define REGSTR_KEY_SHARES             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\LanMan")
#define REGSTR_VAL_SHARES_FLAGS   TEXT("Flags")
#define REGSTR_VAL_SHARES_TYPE    TEXT("Type")
#define REGSTR_VAL_SHARES_PATH    TEXT("Path")
#define REGSTR_VAL_SHARES_REMARK  TEXT("Remark")
#define REGSTR_VAL_SHARES_RW_PASS TEXT("Parm1")
#define REGSTR_VAL_SHARES_RO_PASS TEXT("Parm2")

//
//      Entries for printer settings under LOCAL_MACHINE
//
#define REGSTR_PATH_PRINT           TEXT("System\\CurrentControlSet\\Control\\Print")
#define REGSTR_PATH_PRINTERS        TEXT("System\\CurrentControlSet\\Control\\Print\\Printers")
#define REGSTR_PATH_PROVIDERS       TEXT("System\\CurrentControlSet\\Control\\Print\\Providers")
#define REGSTR_PATH_MONITORS        TEXT("System\\CurrentControlSet\\Control\\Print\\Monitors")
#define REGSTR_PATH_ENVIRONMENTS    TEXT("System\\CurrentControlSet\\Control\\Print\\Environments")
#define REGSTR_VAL_START_ON_BOOT    TEXT("StartOnBoot")
#define REGSTR_VAL_PRINTERS_MASK    TEXT("PrintersMask")
#define REGSTR_VAL_DOS_SPOOL_MASK   TEXT("DOSSpoolMask")
#define REGSTR_KEY_CURRENT_ENV      TEXT("\\Windows 4.0")
#define REGSTR_KEY_DRIVERS          TEXT("\\Drivers")
#define REGSTR_KEY_PRINT_PROC       TEXT("\\Print Processors")

//
// Entries for MultiMedia under HKEY_CURRENT_USER
//
#define REGSTR_PATH_EVENTLABELS     TEXT("AppEvents\\EventLabels")
#define REGSTR_PATH_SCHEMES         TEXT("AppEvents\\Schemes")
#define REGSTR_PATH_APPS            REGSTR_PATH_SCHEMES TEXT("\\Apps")
#define REGSTR_PATH_APPS_DEFAULT    REGSTR_PATH_SCHEMES TEXT("\\Apps\\.Default")
#define REGSTR_PATH_NAMES           REGSTR_PATH_SCHEMES TEXT("\\Names")
#define REGSTR_PATH_MULTIMEDIA      REGSTR_PATH_SETUP TEXT("\\Multimedia")
#define REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("Software\\Microsoft\\Multimedia\\Audio")
#define REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\Images")

//
// Entries for MultiMedia under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_MEDIARESOURCES  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaResources")
#define REGSTR_PATH_MEDIAPROPERTIES REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaProperties")
#define REGSTR_PATH_PRIVATEPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PrivateProperties")
#define REGSTR_PATH_PUBLICPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PublicProperties")

// joysticks
#define REGSTR_PATH_JOYOEM           REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\OEM")
#define REGSTR_PATH_JOYCONFIG        REGSTR_PATH_MEDIARESOURCES TEXT("\\Joystick")
#define REGSTR_KEY_JOYCURR           TEXT("CurrentJoystickSettings")
#define REGSTR_KEY_JOYSETTINGS       TEXT("JoystickSettings")

// joystick values found under REGSTR_PATH_JOYCONFIG
#define REGSTR_VAL_JOYUSERVALUES     TEXT("JoystickUserValues")
#define REGSTR_VAL_JOYCALLOUT        TEXT("JoystickCallout")

// joystick values found under REGSTR_KEY_JOYCURR and REGSTR_KEY_JOYSETTINGS
#define REGSTR_VAL_JOYNCONFIG        TEXT("Joystick%dConfiguration")
#define REGSTR_VAL_JOYNOEMNAME       TEXT("Joystick%dOEMName")
#define REGSTR_VAL_JOYNOEMCALLOUT    TEXT("Joystick%dOEMCallout")

// joystick values found under keys under REGSTR_PATH_JOYOEM
#define REGSTR_VAL_JOYOEMCALLOUT        TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMNAME           TEXT("OEMName")
#define REGSTR_VAL_JOYOEMDATA           TEXT("OEMData")
#define REGSTR_VAL_JOYOEMXYLABEL        TEXT("OEMXYLabel")
#define REGSTR_VAL_JOYOEMZLABEL         TEXT("OEMZLabel")
#define REGSTR_VAL_JOYOEMRLABEL         TEXT("OEMRLabel")
#define REGSTR_VAL_JOYOEMPOVLABEL       TEXT("OEMPOVLabel")
#define REGSTR_VAL_JOYOEMULABEL         TEXT("OEMULabel")
#define REGSTR_VAL_JOYOEMVLABEL         TEXT("OEMVLabel")
#define REGSTR_VAL_JOYOEMTESTMOVEDESC   TEXT("OEMTestMoveDesc")
#define REGSTR_VAL_JOYOEMTESTBUTTONDESC TEXT("OEMTestButtonDesc")
#define REGSTR_VAL_JOYOEMTESTMOVECAP    TEXT("OEMTestMoveCap")
#define REGSTR_VAL_JOYOEMTESTBUTTONCAP  TEXT("OEMTestButtonCap")
#define REGSTR_VAL_JOYOEMTESTWINCAP     TEXT("OEMTestWinCap")
#define REGSTR_VAL_JOYOEMCALCAP         TEXT("OEMCalCap")
#define REGSTR_VAL_JOYOEMCALWINCAP      TEXT("OEMCalWinCap")
#define REGSTR_VAL_JOYOEMCAL1           TEXT("OEMCal1")
#define REGSTR_VAL_JOYOEMCAL2           TEXT("OEMCal2")
#define REGSTR_VAL_JOYOEMCAL3           TEXT("OEMCal3")
#define REGSTR_VAL_JOYOEMCAL4           TEXT("OEMCal4")
#define REGSTR_VAL_JOYOEMCAL5           TEXT("OEMCal5")
#define REGSTR_VAL_JOYOEMCAL6           TEXT("OEMCal6")
#define REGSTR_VAL_JOYOEMCAL7           TEXT("OEMCal7")
#define REGSTR_VAL_JOYOEMCAL8           TEXT("OEMCal8")
#define REGSTR_VAL_JOYOEMCAL9           TEXT("OEMCal9")
#define REGSTR_VAL_JOYOEMCAL10          TEXT("OEMCal10")
#define REGSTR_VAL_JOYOEMCAL11          TEXT("OEMCal11")
#define REGSTR_VAL_JOYOEMCAL12          TEXT("OEMCal12")

// Image values under REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")

//
// Entries for Device Installer under HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER
//
#define REGSTR_PATH_DEVICEINSTALLER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Device Installer")

//
// Entries for DIFX (Device Install Frameworks) under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_DIFX     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DIFX")


// Device Installer values found under REGSTR_PATH_DEVICEINSTALLER
#define REGSTR_VAL_SEARCHOPTIONS        TEXT("SearchOptions")

// BiosInfo defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_BIOSINFO            TEXT("System\\CurrentControlSet\\Control\\BiosInfo")

#else

#define REGSTR_PATH_BIOSINFO            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\BiosInfo"

#endif

// Pci Irq Routing registry defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_PCIIR               TEXT("System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting")
#define REGSTR_VAL_OPTIONS              TEXT("Options")
#define REGSTR_VAL_STAT                 TEXT("Status")
#define REGSTR_VAL_TABLE_STAT           TEXT("TableStatus")
#define REGSTR_VAL_MINIPORT_STAT        TEXT("MiniportStatus")

#else

#define REGSTR_PATH_PCIIR               L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting"
#define REGSTR_VAL_OPTIONS              L"Options"
#define REGSTR_VAL_STAT                 L"Status"
#define REGSTR_VAL_TABLE_STAT           L"TableStatus"
#define REGSTR_VAL_MINIPORT_STAT        L"MiniportStatus"

#endif

// Pci Irq Routing Option values.
#define PIR_OPTION_ENABLED                  0x00000001
#define PIR_OPTION_REGISTRY                 0x00000002
#define PIR_OPTION_MSSPEC                   0x00000004
#define PIR_OPTION_REALMODE                 0x00000008
#define PIR_OPTION_DEFAULT                  0x0000000f

// Pci Irq Routing Status values.
#define PIR_STATUS_ERROR                    0x00000000
#define PIR_STATUS_ENABLED                  0x00000001
#define PIR_STATUS_DISABLED                 0x00000002
#define PIR_STATUS_MAX                      0x00000003

#define PIR_STATUS_TABLE_REGISTRY           0x00000000
#define PIR_STATUS_TABLE_MSSPEC                     0x00000001
#define PIR_STATUS_TABLE_REALMODE                   0x00000002
#define PIR_STATUS_TABLE_NONE                   0x00000003
#define PIR_STATUS_TABLE_ERROR                      0x00000004
#define PIR_STATUS_TABLE_BAD                        0x00000005
#define PIR_STATUS_TABLE_SUCCESS            0x00000006
#define PIR_STATUS_TABLE_MAX                0x00000007

#define PIR_STATUS_MINIPORT_NORMAL                  0x00000000
#define PIR_STATUS_MINIPORT_COMPATIBLE      0x00000001
#define PIR_STATUS_MINIPORT_OVERRIDE        0x00000002
#define PIR_STATUS_MINIPORT_NONE                    0x00000003
#define PIR_STATUS_MINIPORT_ERROR                   0x00000004
#define PIR_STATUS_MINIPORT_NOKEY                   0x00000005
#define PIR_STATUS_MINIPORT_SUCCESS                 0x00000006
#define PIR_STATUS_MINIPORT_INVALID                 0x00000007
#define PIR_STATUS_MINIPORT_MAX             0x00000008

//
// entries for LastKnownGood
// each value name under this key is SubPath/File (note reversal of '\\' to '/')
// each value is an indication of post-processing to be done after files have been recovered
// LASTGOOD_OPERATION bits indicate the primary post-processing operation
// remaining bits may be used as flags (allocate flags from highest bits first)
// a value of 0 is the same as the value being omitted, ie, no post processing.
//

#define REGSTR_PATH_LASTGOOD            TEXT("System\\LastKnownGoodRecovery\\LastGood")
#define REGSTR_PATH_LASTGOODTMP         TEXT("System\\LastKnownGoodRecovery\\LastGood.Tmp")

#define LASTGOOD_OPERATION              0x000000FF // operation to perform
#define LASTGOOD_OPERATION_NOPOSTPROC   0x00000000 // no post-processing
#define LASTGOOD_OPERATION_DELETE       0x00000001 // Delete file during recovery

#endif  //_INC_REGSTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rdpencomapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rdpencomapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rdpencomapi_h__
#define __rdpencomapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRDPSRAPIDebug_FWD_DEFINED__
#define __IRDPSRAPIDebug_FWD_DEFINED__
typedef interface IRDPSRAPIDebug IRDPSRAPIDebug;
#endif 	/* __IRDPSRAPIDebug_FWD_DEFINED__ */


#ifndef ___IRDPSessionEvents_FWD_DEFINED__
#define ___IRDPSessionEvents_FWD_DEFINED__
typedef interface _IRDPSessionEvents _IRDPSessionEvents;
#endif 	/* ___IRDPSessionEvents_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplication_FWD_DEFINED__
#define __IRDPSRAPIApplication_FWD_DEFINED__
typedef interface IRDPSRAPIApplication IRDPSRAPIApplication;
#endif 	/* __IRDPSRAPIApplication_FWD_DEFINED__ */


#ifndef __IRDPSRAPIWindow_FWD_DEFINED__
#define __IRDPSRAPIWindow_FWD_DEFINED__
typedef interface IRDPSRAPIWindow IRDPSRAPIWindow;
#endif 	/* __IRDPSRAPIWindow_FWD_DEFINED__ */


#ifndef __IRDPSRAPIWindowList_FWD_DEFINED__
#define __IRDPSRAPIWindowList_FWD_DEFINED__
typedef interface IRDPSRAPIWindowList IRDPSRAPIWindowList;
#endif 	/* __IRDPSRAPIWindowList_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplicationList_FWD_DEFINED__
#define __IRDPSRAPIApplicationList_FWD_DEFINED__
typedef interface IRDPSRAPIApplicationList IRDPSRAPIApplicationList;
#endif 	/* __IRDPSRAPIApplicationList_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplicationFilter_FWD_DEFINED__
#define __IRDPSRAPIApplicationFilter_FWD_DEFINED__
typedef interface IRDPSRAPIApplicationFilter IRDPSRAPIApplicationFilter;
#endif 	/* __IRDPSRAPIApplicationFilter_FWD_DEFINED__ */


#ifndef __IRDPSRAPISessionProperties_FWD_DEFINED__
#define __IRDPSRAPISessionProperties_FWD_DEFINED__
typedef interface IRDPSRAPISessionProperties IRDPSRAPISessionProperties;
#endif 	/* __IRDPSRAPISessionProperties_FWD_DEFINED__ */


#ifndef __IRDPSRAPIInvitation_FWD_DEFINED__
#define __IRDPSRAPIInvitation_FWD_DEFINED__
typedef interface IRDPSRAPIInvitation IRDPSRAPIInvitation;
#endif 	/* __IRDPSRAPIInvitation_FWD_DEFINED__ */


#ifndef __IRDPSRAPIInvitationManager_FWD_DEFINED__
#define __IRDPSRAPIInvitationManager_FWD_DEFINED__
typedef interface IRDPSRAPIInvitationManager IRDPSRAPIInvitationManager;
#endif 	/* __IRDPSRAPIInvitationManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__
#define __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__
typedef interface IRDPSRAPITcpConnectionInfo IRDPSRAPITcpConnectionInfo;
#endif 	/* __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendee_FWD_DEFINED__
#define __IRDPSRAPIAttendee_FWD_DEFINED__
typedef interface IRDPSRAPIAttendee IRDPSRAPIAttendee;
#endif 	/* __IRDPSRAPIAttendee_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeManager_FWD_DEFINED__
#define __IRDPSRAPIAttendeeManager_FWD_DEFINED__
typedef interface IRDPSRAPIAttendeeManager IRDPSRAPIAttendeeManager;
#endif 	/* __IRDPSRAPIAttendeeManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
#define __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
typedef interface IRDPSRAPIAttendeeDisconnectInfo IRDPSRAPIAttendeeDisconnectInfo;
#endif 	/* __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannel_FWD_DEFINED__
#define __IRDPSRAPIVirtualChannel_FWD_DEFINED__
typedef interface IRDPSRAPIVirtualChannel IRDPSRAPIVirtualChannel;
#endif 	/* __IRDPSRAPIVirtualChannel_FWD_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__
#define __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__
typedef interface IRDPSRAPIVirtualChannelManager IRDPSRAPIVirtualChannelManager;
#endif 	/* __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPISharingSession_FWD_DEFINED__
#define __IRDPSRAPISharingSession_FWD_DEFINED__
typedef interface IRDPSRAPISharingSession IRDPSRAPISharingSession;
#endif 	/* __IRDPSRAPISharingSession_FWD_DEFINED__ */


#ifndef __IRDPSRAPIViewer_FWD_DEFINED__
#define __IRDPSRAPIViewer_FWD_DEFINED__
typedef interface IRDPSRAPIViewer IRDPSRAPIViewer;
#endif 	/* __IRDPSRAPIViewer_FWD_DEFINED__ */


#ifndef __RDPViewer_FWD_DEFINED__
#define __RDPViewer_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPViewer RDPViewer;
#else
typedef struct RDPViewer RDPViewer;
#endif /* __cplusplus */

#endif 	/* __RDPViewer_FWD_DEFINED__ */


#ifndef __RDPSession_FWD_DEFINED__
#define __RDPSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSession RDPSession;
#else
typedef struct RDPSession RDPSession;
#endif /* __cplusplus */

#endif 	/* __RDPSession_FWD_DEFINED__ */


#ifndef __RDPSRAPISessionProperties_FWD_DEFINED__
#define __RDPSRAPISessionProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPISessionProperties RDPSRAPISessionProperties;
#else
typedef struct RDPSRAPISessionProperties RDPSRAPISessionProperties;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPISessionProperties_FWD_DEFINED__ */


#ifndef __RDPSRAPIInvitationManager_FWD_DEFINED__
#define __RDPSRAPIInvitationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIInvitationManager RDPSRAPIInvitationManager;
#else
typedef struct RDPSRAPIInvitationManager RDPSRAPIInvitationManager;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIInvitationManager_FWD_DEFINED__ */


#ifndef __RDPSRAPIInvitation_FWD_DEFINED__
#define __RDPSRAPIInvitation_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIInvitation RDPSRAPIInvitation;
#else
typedef struct RDPSRAPIInvitation RDPSRAPIInvitation;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIInvitation_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendeeManager_FWD_DEFINED__
#define __RDPSRAPIAttendeeManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendeeManager RDPSRAPIAttendeeManager;
#else
typedef struct RDPSRAPIAttendeeManager RDPSRAPIAttendeeManager;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendeeManager_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendee_FWD_DEFINED__
#define __RDPSRAPIAttendee_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendee RDPSRAPIAttendee;
#else
typedef struct RDPSRAPIAttendee RDPSRAPIAttendee;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendee_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
#define __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendeeDisconnectInfo RDPSRAPIAttendeeDisconnectInfo;
#else
typedef struct RDPSRAPIAttendeeDisconnectInfo RDPSRAPIAttendeeDisconnectInfo;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplicationFilter_FWD_DEFINED__
#define __RDPSRAPIApplicationFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplicationFilter RDPSRAPIApplicationFilter;
#else
typedef struct RDPSRAPIApplicationFilter RDPSRAPIApplicationFilter;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplicationFilter_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplicationList_FWD_DEFINED__
#define __RDPSRAPIApplicationList_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplicationList RDPSRAPIApplicationList;
#else
typedef struct RDPSRAPIApplicationList RDPSRAPIApplicationList;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplicationList_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplication_FWD_DEFINED__
#define __RDPSRAPIApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplication RDPSRAPIApplication;
#else
typedef struct RDPSRAPIApplication RDPSRAPIApplication;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplication_FWD_DEFINED__ */


#ifndef __RDPSRAPIWindowList_FWD_DEFINED__
#define __RDPSRAPIWindowList_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIWindowList RDPSRAPIWindowList;
#else
typedef struct RDPSRAPIWindowList RDPSRAPIWindowList;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIWindowList_FWD_DEFINED__ */


#ifndef __RDPSRAPIWindow_FWD_DEFINED__
#define __RDPSRAPIWindow_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIWindow RDPSRAPIWindow;
#else
typedef struct RDPSRAPIWindow RDPSRAPIWindow;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIWindow_FWD_DEFINED__ */


#ifndef __RDPSRAPITcpConnectionInfo_FWD_DEFINED__
#define __RDPSRAPITcpConnectionInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPITcpConnectionInfo RDPSRAPITcpConnectionInfo;
#else
typedef struct RDPSRAPITcpConnectionInfo RDPSRAPITcpConnectionInfo;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPITcpConnectionInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rdpencomapi_0000_0000 */
/* [local] */ 

#define	DISPID_RDPSRAPI_METHOD_OPEN	( 100 )

#define	DISPID_RDPSRAPI_METHOD_CLOSE	( 101 )

#define	DISPID_RDPSRAPI_METHOD_SETSHAREDRECT	( 102 )

#define	DISPID_RDPSRAPI_METHOD_GETSHAREDRECT	( 103 )

#define	DISPID_RDPSRAPI_METHOD_VIEWERCONNECT	( 104 )

#define	DISPID_RDPSRAPI_METHOD_VIEWERDISCONNECT	( 105 )

#define	DISPID_RDPSRAPI_METHOD_TERMINATE_CONNECTION	( 106 )

#define	DISPID_RDPSRAPI_METHOD_CREATE_INVITATION	( 107 )

#define	DISPID_RDPSRAPI_METHOD_REQUEST_CONTROL	( 108 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_CREATE	( 109 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_SEND_DATA	( 110 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_SET_ACCESS	( 111 )

#define	DISPID_RDPSRAPI_METHOD_PAUSE	( 112 )

#define	DISPID_RDPSRAPI_METHOD_RESUME	( 113 )

#define	DISPID_RDPSRAPI_METHOD_SHOW_WINDOW	( 114 )

#define	DISPID_RDPSRAPI_METHOD_REQUEST_COLOR_DEPTH_CHANGE	( 115 )

#define	DISPID_RDPSRAPI_METHOD_STARTREVCONNECTLISTENER	( 116 )

#define	DISPID_RDPSRAPI_METHOD_CONNECTTOCLIENT	( 117 )

#define	DISPID_RDPSRAPI_PROP_DISPIDVALUE	( 200 )

#define	DISPID_RDPSRAPI_PROP_ID	( 201 )

#define	DISPID_RDPSRAPI_PROP_SESSION_PROPERTIES	( 202 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEES	( 203 )

#define	DISPID_RDPSRAPI_PROP_INVITATIONS	( 204 )

#define	DISPID_RDPSRAPI_PROP_INVITATION	( 205 )

#define	DISPID_RDPSRAPI_PROP_CHANNELMANAGER	( 206 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETNAME	( 207 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETFLAGS	( 208 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETPRIORITY	( 209 )

#define	DISPID_RDPSRAPI_PROP_WINDOWID	( 210 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION	( 211 )

#define	DISPID_RDPSRAPI_PROP_WINDOWSHARED	( 212 )

#define	DISPID_RDPSRAPI_PROP_WINDOWNAME	( 213 )

#define	DISPID_RDPSRAPI_PROP_APPNAME	( 214 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION_FILTER	( 215 )

#define	DISPID_RDPSRAPI_PROP_WINDOW_LIST	( 216 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION_LIST	( 217 )

#define	DISPID_RDPSRAPI_PROP_APPFILTER_ENABLED	( 218 )

#define	DISPID_RDPSRAPI_PROP_APPFILTERENABLED	( 219 )

#define	DISPID_RDPSRAPI_PROP_SHARED	( 220 )

#define	DISPID_RDPSRAPI_PROP_INVITATIONITEM	( 221 )

#define	DISPID_RDPSRAPI_PROP_DBG_CLX_CMDLINE	( 222 )

#define	DISPID_RDPSRAPI_PROP_APPFLAGS	( 223 )

#define	DISPID_RDPSRAPI_PROP_WNDFLAGS	( 224 )

#define	DISPID_RDPSRAPI_PROP_PROTOCOL_TYPE	( 225 )

#define	DISPID_RDPSRAPI_PROP_LOCAL_PORT	( 226 )

#define	DISPID_RDPSRAPI_PROP_LOCAL_IP	( 227 )

#define	DISPID_RDPSRAPI_PROP_PEER_PORT	( 228 )

#define	DISPID_RDPSRAPI_PROP_PEER_IP	( 229 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEE_FLAGS	( 230 )

#define	DISPID_RDPSRAPI_PROP_CONINFO	( 231 )

#define	DISPID_RDPSRAPI_PROP_CONNECTION_STRING	( 232 )

#define	DISPID_RDPSRAPI_PROP_GROUP_NAME	( 233 )

#define	DISPID_RDPSRAPI_PROP_PASSWORD	( 234 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEELIMIT	( 235 )

#define	DISPID_RDPSRAPI_PROP_REVOKED	( 236 )

#define	DISPID_RDPSRAPI_PROP_DISCONNECTED_STRING	( 237 )

#define	DISPID_RDPSRAPI_PROP_USESMARTSIZING	( 238 )

#define	DISPID_RDPSRAPI_PROP_SESSION_COLORDEPTH	( 239 )

#define	DISPID_RDPSRAPI_PROP_REASON	( 240 )

#define	DISPID_RDPSRAPI_PROP_CODE	( 241 )

#define	DISPID_RDPSRAPI_PROP_CTRL_LEVEL	( 242 )

#define	DISPID_RDPSRAPI_PROP_REMOTENAME	( 243 )

#define	DISPID_RDPSRAPI_PROP_COUNT	( 244 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_CONNECTED	( 301 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_DISCONNECTED	( 302 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_UPDATE	( 303 )

#define	DISPID_RDPSRAPI_EVENT_ON_ERROR	( 304 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_CONNECTED	( 305 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_DISCONNECTED	( 306 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_AUTHENTICATED	( 307 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_CONNECTFAILED	( 308 )

#define	DISPID_RDPSRAPI_EVENT_ON_CTRLLEVEL_CHANGE_REQUEST	( 309 )

#define	DISPID_RDPSRAPI_EVENT_ON_GRAPHICS_STREAM_PAUSED	( 310 )

#define	DISPID_RDPSRAPI_EVENT_ON_GRAPHICS_STREAM_RESUMED	( 311 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_JOIN	( 312 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_LEAVE	( 313 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_DATARECEIVED	( 314 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_SENDCOMPLETED	( 315 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_OPEN	( 316 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_CLOSE	( 317 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_UPDATE	( 318 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_OPEN	( 319 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_CLOSE	( 320 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_UPDATE	( 321 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPFILTER_UPDATE	( 322 )

#define	DISPID_RDPSRAPI_EVENT_ON_SHARED_RECT_CHANGED	( 323 )

#define	DISPID_RDPSRAPI_EVENT_ON_FOCUSRELEASED	( 324 )

#define	DISPID_RDPSRAPI_EVENT_ON_SHARED_DESKTOP_SETTINGS_CHANGED	( 325 )



extern RPC_IF_HANDLE __MIDL_itf_rdpencomapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdpencomapi_0000_0000_v0_0_s_ifspec;

#ifndef __IRDPSRAPIDebug_INTERFACE_DEFINED__
#define __IRDPSRAPIDebug_INTERFACE_DEFINED__

/* interface IRDPSRAPIDebug */
/* [unique][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa1e42b5-496d-4ca4-a690-348dcb2ec4ad")
    IRDPSRAPIDebug : public IUnknown
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CLXCmdLine( 
            /* [in] */ __RPC__in BSTR CLXCmdLine) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CLXCmdLine( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLXCmdLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIDebug * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CLXCmdLine )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [in] */ __RPC__in BSTR CLXCmdLine);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLXCmdLine )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLXCmdLine);
        
        END_INTERFACE
    } IRDPSRAPIDebugVtbl;

    interface IRDPSRAPIDebug
    {
        CONST_VTBL struct IRDPSRAPIDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIDebug_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIDebug_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIDebug_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIDebug_put_CLXCmdLine(This,CLXCmdLine)	\
    ( (This)->lpVtbl -> put_CLXCmdLine(This,CLXCmdLine) ) 

#define IRDPSRAPIDebug_get_CLXCmdLine(This,pCLXCmdLine)	\
    ( (This)->lpVtbl -> get_CLXCmdLine(This,pCLXCmdLine) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIDebug_INTERFACE_DEFINED__ */



#ifndef __RDPCOMAPILib_LIBRARY_DEFINED__
#define __RDPCOMAPILib_LIBRARY_DEFINED__

/* library RDPCOMAPILib */
/* [version][uuid] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0001
    {	CTRL_LEVEL_MIN	= 0,
	CTRL_LEVEL_INVALID	= 0,
	CTRL_LEVEL_NONE	= 1,
	CTRL_LEVEL_VIEW	= 2,
	CTRL_LEVEL_INTERACTIVE	= 3,
	CTRL_LEVEL_MAX	= 3
    } 	CTRL_LEVEL;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0002
    {	ATTENDEE_DISCONNECT_REASON_MIN	= 0,
	ATTENDEE_DISCONNECT_REASON_APP	= 0,
	ATTENDEE_DISCONNECT_REASON_ERR	= 1,
	ATTENDEE_DISCONNECT_REASON_CLI	= 2,
	ATTENDEE_DISCONNECT_REASON_MAX	= 2
    } 	ATTENDEE_DISCONNECT_REASON;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0003
    {	CHANNEL_PRIORITY_LO	= 0,
	CHANNEL_PRIORITY_MED	= ( CHANNEL_PRIORITY_LO + 1 ) ,
	CHANNEL_PRIORITY_HI	= ( CHANNEL_PRIORITY_MED + 1 ) 
    } 	CHANNEL_PRIORITY;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0004
    {	CHANNEL_FLAGS_LEGACY	= 0x1,
	CHANNEL_FLAGS_UNCOMPRESSED	= 0x2
    } 	CHANNEL_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0005
    {	CHANNEL_ACCESS_ENUM_NONE	= 0,
	CHANNEL_ACCESS_ENUM_SENDRECEIVE	= ( CHANNEL_ACCESS_ENUM_NONE + 1 ) 
    } 	CHANNEL_ACCESS_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0006
    {	CONST_MAX_CHANNEL_MESSAGE_SIZE	= 1024,
	CONST_MAX_CHANNEL_NAME_LEN	= 8,
	CONST_MAX_LEGACY_CHANNEL_MESSAGE_SIZE	= 409600,
	CONST_ATTENDEE_ID_EVERYONE	= -1,
	CONST_ATTENDEE_ID_HOST	= 0,
	CONST_CONN_INTERVAL	= 50
    } 	RDPENCOMAPI_CONSTANTS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0007
    {	ATTENDEE_FLAGS_LOCAL	= 1
    } 	RDPENCOMAPI_ATTENDEE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0008
    {	WND_FLAG_PRIVILEGED	= 1
    } 	RDPSRAPI_WND_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0009
    {	APP_FLAG_PRIVILEGED	= 1
    } 	RDPSRAPI_APP_FLAGS;



EXTERN_C const IID LIBID_RDPCOMAPILib;

#ifndef ___IRDPSessionEvents_DISPINTERFACE_DEFINED__
#define ___IRDPSessionEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IRDPSessionEvents */
/* [uuid] */ 


EXTERN_C const IID DIID__IRDPSessionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("98a97042-6698-40e9-8efd-b3200990004b")
    _IRDPSessionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IRDPSessionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _IRDPSessionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _IRDPSessionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _IRDPSessionEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _IRDPSessionEventsVtbl;

    interface _IRDPSessionEvents
    {
        CONST_VTBL struct _IRDPSessionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IRDPSessionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IRDPSessionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IRDPSessionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IRDPSessionEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _IRDPSessionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _IRDPSessionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _IRDPSessionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IRDPSessionEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplication_INTERFACE_DEFINED__
#define __IRDPSRAPIApplication_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplication */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41e7a09d-eb7a-436e-935d-780ca2628324")
    IRDPSRAPIApplication : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindowList) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shared( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shared( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Windows )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindowList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Shared )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Shared )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags);
        
        END_INTERFACE
    } IRDPSRAPIApplicationVtbl;

    interface IRDPSRAPIApplication
    {
        CONST_VTBL struct IRDPSRAPIApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplication_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplication_get_Windows(This,pWindowList)	\
    ( (This)->lpVtbl -> get_Windows(This,pWindowList) ) 

#define IRDPSRAPIApplication_get_Id(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Id(This,pRetVal) ) 

#define IRDPSRAPIApplication_get_Shared(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Shared(This,pRetVal) ) 

#define IRDPSRAPIApplication_put_Shared(This,NewVal)	\
    ( (This)->lpVtbl -> put_Shared(This,NewVal) ) 

#define IRDPSRAPIApplication_get_Name(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pRetVal) ) 

#define IRDPSRAPIApplication_get_Flags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplication_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIWindow_INTERFACE_DEFINED__
#define __IRDPSRAPIWindow_INTERFACE_DEFINED__

/* interface IRDPSRAPIWindow */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("beafe0f9-c77b-4933-ba9f-a24cddcc27cf")
    IRDPSRAPIWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shared( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shared( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Show( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Shared )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Shared )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags);
        
        END_INTERFACE
    } IRDPSRAPIWindowVtbl;

    interface IRDPSRAPIWindow
    {
        CONST_VTBL struct IRDPSRAPIWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIWindow_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIWindow_get_Id(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Id(This,pRetVal) ) 

#define IRDPSRAPIWindow_get_Application(This,pApplication)	\
    ( (This)->lpVtbl -> get_Application(This,pApplication) ) 

#define IRDPSRAPIWindow_get_Shared(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Shared(This,pRetVal) ) 

#define IRDPSRAPIWindow_put_Shared(This,NewVal)	\
    ( (This)->lpVtbl -> put_Shared(This,NewVal) ) 

#define IRDPSRAPIWindow_get_Name(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pRetVal) ) 

#define IRDPSRAPIWindow_Show(This)	\
    ( (This)->lpVtbl -> Show(This) ) 

#define IRDPSRAPIWindow_get_Flags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIWindow_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIWindowList_INTERFACE_DEFINED__
#define __IRDPSRAPIWindowList_INTERFACE_DEFINED__

/* interface IRDPSRAPIWindowList */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIWindowList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a05ce44-715a-4116-a189-a118f30a07bd")
    IRDPSRAPIWindowList : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindow **pWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIWindowListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIWindowList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIWindowList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIWindowList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindow **pWindow);
        
        END_INTERFACE
    } IRDPSRAPIWindowListVtbl;

    interface IRDPSRAPIWindowList
    {
        CONST_VTBL struct IRDPSRAPIWindowListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIWindowList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIWindowList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIWindowList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIWindowList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIWindowList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIWindowList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIWindowList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIWindowList_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIWindowList_get_Item(This,item,pWindow)	\
    ( (This)->lpVtbl -> get_Item(This,item,pWindow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIWindowList_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplicationList_INTERFACE_DEFINED__
#define __IRDPSRAPIApplicationList_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplicationList */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplicationList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d4b4aeb3-22dc-4837-b3b6-42ea2517849a")
    IRDPSRAPIApplicationList : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplicationList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplicationList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplicationList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication);
        
        END_INTERFACE
    } IRDPSRAPIApplicationListVtbl;

    interface IRDPSRAPIApplicationList
    {
        CONST_VTBL struct IRDPSRAPIApplicationListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplicationList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplicationList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplicationList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplicationList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplicationList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplicationList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplicationList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplicationList_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIApplicationList_get_Item(This,item,pApplication)	\
    ( (This)->lpVtbl -> get_Item(This,item,pApplication) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplicationList_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__
#define __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplicationFilter */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplicationFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d20f10ca-6637-4f06-b1d5-277ea7e5160d")
    IRDPSRAPIApplicationFilter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Applications( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationList **pApplications) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindows) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplicationFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplicationFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplicationFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Applications )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationList **pApplications);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Windows )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindows);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        END_INTERFACE
    } IRDPSRAPIApplicationFilterVtbl;

    interface IRDPSRAPIApplicationFilter
    {
        CONST_VTBL struct IRDPSRAPIApplicationFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplicationFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplicationFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplicationFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplicationFilter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplicationFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplicationFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplicationFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplicationFilter_get_Applications(This,pApplications)	\
    ( (This)->lpVtbl -> get_Applications(This,pApplications) ) 

#define IRDPSRAPIApplicationFilter_get_Windows(This,pWindows)	\
    ( (This)->lpVtbl -> get_Windows(This,pWindows) ) 

#define IRDPSRAPIApplicationFilter_get_Enabled(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Enabled(This,pRetVal) ) 

#define IRDPSRAPIApplicationFilter_put_Enabled(This,NewVal)	\
    ( (This)->lpVtbl -> put_Enabled(This,NewVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPISessionProperties_INTERFACE_DEFINED__
#define __IRDPSRAPISessionProperties_INTERFACE_DEFINED__

/* interface IRDPSRAPISessionProperties */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPISessionProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("339b24f2-9bc0-4f16-9aac-f165433d13d4")
    IRDPSRAPISessionProperties : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Property( 
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [in] */ VARIANT newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPISessionPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPISessionProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPISessionProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPISessionProperties * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Property )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Property )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [in] */ VARIANT newVal);
        
        END_INTERFACE
    } IRDPSRAPISessionPropertiesVtbl;

    interface IRDPSRAPISessionProperties
    {
        CONST_VTBL struct IRDPSRAPISessionPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPISessionProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPISessionProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPISessionProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPISessionProperties_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPISessionProperties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPISessionProperties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPISessionProperties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPISessionProperties_get_Property(This,PropertyName,pVal)	\
    ( (This)->lpVtbl -> get_Property(This,PropertyName,pVal) ) 

#define IRDPSRAPISessionProperties_put_Property(This,PropertyName,newVal)	\
    ( (This)->lpVtbl -> put_Property(This,PropertyName,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPISessionProperties_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIInvitation_INTERFACE_DEFINED__
#define __IRDPSRAPIInvitation_INTERFACE_DEFINED__

/* interface IRDPSRAPIInvitation */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIInvitation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fac1d43-fc51-45bb-b1b4-2b53aa562fa3")
    IRDPSRAPIInvitation : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AttendeeLimit( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AttendeeLimit( 
            /* [in] */ long NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Revoked( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Revoked( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIInvitationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIInvitation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIInvitation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIInvitation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionString )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupName )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Password )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttendeeLimit )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttendeeLimit )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ long NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Revoked )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Revoked )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        END_INTERFACE
    } IRDPSRAPIInvitationVtbl;

    interface IRDPSRAPIInvitation
    {
        CONST_VTBL struct IRDPSRAPIInvitationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIInvitation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIInvitation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIInvitation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIInvitation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIInvitation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIInvitation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIInvitation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIInvitation_get_ConnectionString(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_ConnectionString(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_GroupName(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_GroupName(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_Password(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_Password(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_AttendeeLimit(This,pRetVal)	\
    ( (This)->lpVtbl -> get_AttendeeLimit(This,pRetVal) ) 

#define IRDPSRAPIInvitation_put_AttendeeLimit(This,NewVal)	\
    ( (This)->lpVtbl -> put_AttendeeLimit(This,NewVal) ) 

#define IRDPSRAPIInvitation_get_Revoked(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Revoked(This,pRetVal) ) 

#define IRDPSRAPIInvitation_put_Revoked(This,NewVal)	\
    ( (This)->lpVtbl -> put_Revoked(This,NewVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIInvitation_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__
#define __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIInvitationManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIInvitationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4722b049-92c3-4c2d-8a65-f7348f644dcf")
    IRDPSRAPIInvitationManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInvitation( 
            /* [in] */ __RPC__in BSTR bstrAuthString,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ long AttendeeLimit,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIInvitationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIInvitationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIInvitationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIInvitationManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CreateInvitation )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in BSTR bstrAuthString,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ long AttendeeLimit,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation);
        
        END_INTERFACE
    } IRDPSRAPIInvitationManagerVtbl;

    interface IRDPSRAPIInvitationManager
    {
        CONST_VTBL struct IRDPSRAPIInvitationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIInvitationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIInvitationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIInvitationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIInvitationManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIInvitationManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIInvitationManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIInvitationManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIInvitationManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIInvitationManager_get_Item(This,item,ppInvitation)	\
    ( (This)->lpVtbl -> get_Item(This,item,ppInvitation) ) 

#define IRDPSRAPIInvitationManager_get_Count(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Count(This,pRetVal) ) 

#define IRDPSRAPIInvitationManager_CreateInvitation(This,bstrAuthString,bstrGroupName,bstrPassword,AttendeeLimit,ppInvitation)	\
    ( (This)->lpVtbl -> CreateInvitation(This,bstrAuthString,bstrGroupName,bstrPassword,AttendeeLimit,ppInvitation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__
#define __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__

/* interface IRDPSRAPITcpConnectionInfo */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPITcpConnectionInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f74049a4-3d06-4028-8193-0a8c29bc2452")
    IRDPSRAPITcpConnectionInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__out long *plProtocol) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalPort( 
            /* [retval][out] */ __RPC__out long *plPort) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalIP( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsrLocalIP) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PeerPort( 
            /* [retval][out] */ __RPC__out long *plPort) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PeerIP( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPITcpConnectionInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plProtocol);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPort )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plPort);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalIP )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsrLocalIP);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeerPort )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plPort);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeerIP )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIP);
        
        END_INTERFACE
    } IRDPSRAPITcpConnectionInfoVtbl;

    interface IRDPSRAPITcpConnectionInfo
    {
        CONST_VTBL struct IRDPSRAPITcpConnectionInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPITcpConnectionInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPITcpConnectionInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPITcpConnectionInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPITcpConnectionInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPITcpConnectionInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPITcpConnectionInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPITcpConnectionInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPITcpConnectionInfo_get_Protocol(This,plProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,plProtocol) ) 

#define IRDPSRAPITcpConnectionInfo_get_LocalPort(This,plPort)	\
    ( (This)->lpVtbl -> get_LocalPort(This,plPort) ) 

#define IRDPSRAPITcpConnectionInfo_get_LocalIP(This,pbsrLocalIP)	\
    ( (This)->lpVtbl -> get_LocalIP(This,pbsrLocalIP) ) 

#define IRDPSRAPITcpConnectionInfo_get_PeerPort(This,plPort)	\
    ( (This)->lpVtbl -> get_PeerPort(This,plPort) ) 

#define IRDPSRAPITcpConnectionInfo_get_PeerIP(This,pbstrIP)	\
    ( (This)->lpVtbl -> get_PeerIP(This,pbstrIP) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendee_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendee_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendee */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec0671b3-1b78-4b80-a464-9132247543e3")
    IRDPSRAPIAttendee : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pId) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoteName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ControlLevel( 
            /* [retval][out] */ __RPC__out CTRL_LEVEL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ControlLevel( 
            /* [in] */ CTRL_LEVEL pNewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitation( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TerminateConnection( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out long *plFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectivityInfo( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendee * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out long *pId);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteName )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlLevel )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out CTRL_LEVEL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ControlLevel )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ CTRL_LEVEL pNewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitation )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *TerminateConnection )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out long *plFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectivityInfo )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeVtbl;

    interface IRDPSRAPIAttendee
    {
        CONST_VTBL struct IRDPSRAPIAttendeeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendee_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendee_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendee_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendee_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendee_get_Id(This,pId)	\
    ( (This)->lpVtbl -> get_Id(This,pId) ) 

#define IRDPSRAPIAttendee_get_RemoteName(This,pVal)	\
    ( (This)->lpVtbl -> get_RemoteName(This,pVal) ) 

#define IRDPSRAPIAttendee_get_ControlLevel(This,pVal)	\
    ( (This)->lpVtbl -> get_ControlLevel(This,pVal) ) 

#define IRDPSRAPIAttendee_put_ControlLevel(This,pNewVal)	\
    ( (This)->lpVtbl -> put_ControlLevel(This,pNewVal) ) 

#define IRDPSRAPIAttendee_get_Invitation(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitation(This,ppVal) ) 

#define IRDPSRAPIAttendee_TerminateConnection(This)	\
    ( (This)->lpVtbl -> TerminateConnection(This) ) 

#define IRDPSRAPIAttendee_get_Flags(This,plFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,plFlags) ) 

#define IRDPSRAPIAttendee_get_ConnectivityInfo(This,ppVal)	\
    ( (This)->lpVtbl -> get_ConnectivityInfo(This,ppVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendee_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendeeManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendeeManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba3a37e8-33da-4749-8da0-07fa34da7944")
    IRDPSRAPIAttendeeManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long id,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendeeManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendeeManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendeeManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ long id,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **ppItem);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeManagerVtbl;

    interface IRDPSRAPIAttendeeManager
    {
        CONST_VTBL struct IRDPSRAPIAttendeeManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendeeManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendeeManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendeeManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendeeManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendeeManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendeeManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendeeManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendeeManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIAttendeeManager_get_Item(This,id,ppItem)	\
    ( (This)->lpVtbl -> get_Item(This,id,ppItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendeeDisconnectInfo */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendeeDisconnectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c187689f-447c-44a1-9c14-fffbb3b7ec17")
    IRDPSRAPIAttendeeDisconnectInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendee( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Reason( 
            /* [retval][out] */ __RPC__out ATTENDEE_DISCONNECT_REASON *pReason) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Code( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeDisconnectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendee )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Reason )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__out ATTENDEE_DISCONNECT_REASON *pReason);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Code )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeDisconnectInfoVtbl;

    interface IRDPSRAPIAttendeeDisconnectInfo
    {
        CONST_VTBL struct IRDPSRAPIAttendeeDisconnectInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendeeDisconnectInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendeeDisconnectInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendeeDisconnectInfo_get_Attendee(This,retval)	\
    ( (This)->lpVtbl -> get_Attendee(This,retval) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_get_Reason(This,pReason)	\
    ( (This)->lpVtbl -> get_Reason(This,pReason) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_get_Code(This,pVal)	\
    ( (This)->lpVtbl -> get_Code(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__
#define __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__

/* interface IRDPSRAPIVirtualChannel */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIVirtualChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05e12f95-28b3-4c9a-8780-d0248574a1e0")
    IRDPSRAPIVirtualChannel : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SendData( 
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ long lAttendeeId,
            /* [in] */ unsigned long ChannelSendFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAccess( 
            /* [in] */ long lAttendeeId,
            /* [in] */ CHANNEL_ACCESS_ENUM AccessType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out long *plFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ __RPC__out CHANNEL_PRIORITY *pPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIVirtualChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIVirtualChannel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIVirtualChannel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIVirtualChannel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SendData )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ long lAttendeeId,
            /* [in] */ unsigned long ChannelSendFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAccess )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ long lAttendeeId,
            /* [in] */ CHANNEL_ACCESS_ENUM AccessType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__out long *plFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__out CHANNEL_PRIORITY *pPriority);
        
        END_INTERFACE
    } IRDPSRAPIVirtualChannelVtbl;

    interface IRDPSRAPIVirtualChannel
    {
        CONST_VTBL struct IRDPSRAPIVirtualChannelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIVirtualChannel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIVirtualChannel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIVirtualChannel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIVirtualChannel_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIVirtualChannel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIVirtualChannel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIVirtualChannel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIVirtualChannel_SendData(This,bstrData,lAttendeeId,ChannelSendFlags)	\
    ( (This)->lpVtbl -> SendData(This,bstrData,lAttendeeId,ChannelSendFlags) ) 

#define IRDPSRAPIVirtualChannel_SetAccess(This,lAttendeeId,AccessType)	\
    ( (This)->lpVtbl -> SetAccess(This,lAttendeeId,AccessType) ) 

#define IRDPSRAPIVirtualChannel_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRDPSRAPIVirtualChannel_get_Flags(This,plFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,plFlags) ) 

#define IRDPSRAPIVirtualChannel_get_Priority(This,pPriority)	\
    ( (This)->lpVtbl -> get_Priority(This,pPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__
#define __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIVirtualChannelManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIVirtualChannelManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d11c661-5d0d-4ee4-89df-2166ae1fdfed")
    IRDPSRAPIVirtualChannelManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **pChannel) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateVirtualChannel( 
            /* [in] */ __RPC__in BSTR bstrChannelName,
            /* [in] */ CHANNEL_PRIORITY Priority,
            /* [in] */ unsigned long ChannelFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **ppChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIVirtualChannelManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **pChannel);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CreateVirtualChannel )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in BSTR bstrChannelName,
            /* [in] */ CHANNEL_PRIORITY Priority,
            /* [in] */ unsigned long ChannelFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **ppChannel);
        
        END_INTERFACE
    } IRDPSRAPIVirtualChannelManagerVtbl;

    interface IRDPSRAPIVirtualChannelManager
    {
        CONST_VTBL struct IRDPSRAPIVirtualChannelManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIVirtualChannelManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIVirtualChannelManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIVirtualChannelManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIVirtualChannelManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIVirtualChannelManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIVirtualChannelManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIVirtualChannelManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIVirtualChannelManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIVirtualChannelManager_get_Item(This,item,pChannel)	\
    ( (This)->lpVtbl -> get_Item(This,item,pChannel) ) 

#define IRDPSRAPIVirtualChannelManager_CreateVirtualChannel(This,bstrChannelName,Priority,ChannelFlags,ppChannel)	\
    ( (This)->lpVtbl -> CreateVirtualChannel(This,bstrChannelName,Priority,ChannelFlags,ppChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPISharingSession_INTERFACE_DEFINED__
#define __IRDPSRAPISharingSession_INTERFACE_DEFINED__

/* interface IRDPSRAPISharingSession */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPISharingSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eeb20886-e470-4cf6-842b-2739c0ec5cfb")
    IRDPSRAPISharingSession : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorDepth( 
            /* [in] */ long colorDepth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorDepth( 
            /* [retval][out] */ __RPC__out long *pColorDepth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendees( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitations( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationFilter( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualChannelManager( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectToClient( 
            /* [in] */ __RPC__in BSTR bstrConnectionString) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDesktopSharedRect( 
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDesktopSharedRect( 
            /* [out] */ __RPC__out long *pleft,
            /* [out] */ __RPC__out long *ptop,
            /* [out] */ __RPC__out long *pright,
            /* [out] */ __RPC__out long *pbottom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPISharingSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPISharingSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorDepth )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ long colorDepth);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorDepth )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__out long *pColorDepth);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendees )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitations )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationFilter )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualChannelManager )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ConnectToClient )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetDesktopSharedRect )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetDesktopSharedRect )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [out] */ __RPC__out long *pleft,
            /* [out] */ __RPC__out long *ptop,
            /* [out] */ __RPC__out long *pright,
            /* [out] */ __RPC__out long *pbottom);
        
        END_INTERFACE
    } IRDPSRAPISharingSessionVtbl;

    interface IRDPSRAPISharingSession
    {
        CONST_VTBL struct IRDPSRAPISharingSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPISharingSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPISharingSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPISharingSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPISharingSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPISharingSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPISharingSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPISharingSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPISharingSession_Open(This)	\
    ( (This)->lpVtbl -> Open(This) ) 

#define IRDPSRAPISharingSession_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IRDPSRAPISharingSession_put_ColorDepth(This,colorDepth)	\
    ( (This)->lpVtbl -> put_ColorDepth(This,colorDepth) ) 

#define IRDPSRAPISharingSession_get_ColorDepth(This,pColorDepth)	\
    ( (This)->lpVtbl -> get_ColorDepth(This,pColorDepth) ) 

#define IRDPSRAPISharingSession_get_Properties(This,ppVal)	\
    ( (This)->lpVtbl -> get_Properties(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_Attendees(This,ppVal)	\
    ( (This)->lpVtbl -> get_Attendees(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_Invitations(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitations(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_ApplicationFilter(This,ppVal)	\
    ( (This)->lpVtbl -> get_ApplicationFilter(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_VirtualChannelManager(This,ppVal)	\
    ( (This)->lpVtbl -> get_VirtualChannelManager(This,ppVal) ) 

#define IRDPSRAPISharingSession_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IRDPSRAPISharingSession_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRDPSRAPISharingSession_ConnectToClient(This,bstrConnectionString)	\
    ( (This)->lpVtbl -> ConnectToClient(This,bstrConnectionString) ) 

#define IRDPSRAPISharingSession_SetDesktopSharedRect(This,left,top,right,bottom)	\
    ( (This)->lpVtbl -> SetDesktopSharedRect(This,left,top,right,bottom) ) 

#define IRDPSRAPISharingSession_GetDesktopSharedRect(This,pleft,ptop,pright,pbottom)	\
    ( (This)->lpVtbl -> GetDesktopSharedRect(This,pleft,ptop,pright,pbottom) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPISharingSession_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIViewer_INTERFACE_DEFINED__
#define __IRDPSRAPIViewer_INTERFACE_DEFINED__

/* interface IRDPSRAPIViewer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIViewer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6bfcd38-8ce9-404d-8ae8-f31d00c65cb5")
    IRDPSRAPIViewer : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrPassword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendees( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitations( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationFilter( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualChannelManager( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SmartSizing( 
            /* [in] */ VARIANT_BOOL vbSmartSizing) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SmartSizing( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvbSmartSizing) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RequestControl( 
            /* [in] */ CTRL_LEVEL CtrlLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DisconnectedText( 
            /* [in] */ __RPC__in BSTR bstrDisconnectedText) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DisconnectedText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisconnectedText) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RequestColorDepthChange( 
            /* [in] */ long Bpp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartReverseConnectListener( 
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReverseConnectString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIViewerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIViewer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendees )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitations )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationFilter )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualChannelManager )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SmartSizing )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ VARIANT_BOOL vbSmartSizing);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmartSizing )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvbSmartSizing);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RequestControl )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ CTRL_LEVEL CtrlLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisconnectedText )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrDisconnectedText);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisconnectedText )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisconnectedText);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RequestColorDepthChange )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ long Bpp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StartReverseConnectListener )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReverseConnectString);
        
        END_INTERFACE
    } IRDPSRAPIViewerVtbl;

    interface IRDPSRAPIViewer
    {
        CONST_VTBL struct IRDPSRAPIViewerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIViewer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIViewer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIViewer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIViewer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIViewer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIViewer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIViewer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIViewer_Connect(This,bstrConnectionString,bstrName,bstrPassword)	\
    ( (This)->lpVtbl -> Connect(This,bstrConnectionString,bstrName,bstrPassword) ) 

#define IRDPSRAPIViewer_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IRDPSRAPIViewer_get_Attendees(This,ppVal)	\
    ( (This)->lpVtbl -> get_Attendees(This,ppVal) ) 

#define IRDPSRAPIViewer_get_Invitations(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitations(This,ppVal) ) 

#define IRDPSRAPIViewer_get_ApplicationFilter(This,ppVal)	\
    ( (This)->lpVtbl -> get_ApplicationFilter(This,ppVal) ) 

#define IRDPSRAPIViewer_get_VirtualChannelManager(This,ppVal)	\
    ( (This)->lpVtbl -> get_VirtualChannelManager(This,ppVal) ) 

#define IRDPSRAPIViewer_put_SmartSizing(This,vbSmartSizing)	\
    ( (This)->lpVtbl -> put_SmartSizing(This,vbSmartSizing) ) 

#define IRDPSRAPIViewer_get_SmartSizing(This,pvbSmartSizing)	\
    ( (This)->lpVtbl -> get_SmartSizing(This,pvbSmartSizing) ) 

#define IRDPSRAPIViewer_RequestControl(This,CtrlLevel)	\
    ( (This)->lpVtbl -> RequestControl(This,CtrlLevel) ) 

#define IRDPSRAPIViewer_put_DisconnectedText(This,bstrDisconnectedText)	\
    ( (This)->lpVtbl -> put_DisconnectedText(This,bstrDisconnectedText) ) 

#define IRDPSRAPIViewer_get_DisconnectedText(This,pbstrDisconnectedText)	\
    ( (This)->lpVtbl -> get_DisconnectedText(This,pbstrDisconnectedText) ) 

#define IRDPSRAPIViewer_RequestColorDepthChange(This,Bpp)	\
    ( (This)->lpVtbl -> RequestColorDepthChange(This,Bpp) ) 

#define IRDPSRAPIViewer_get_Properties(This,ppVal)	\
    ( (This)->lpVtbl -> get_Properties(This,ppVal) ) 

#define IRDPSRAPIViewer_StartReverseConnectListener(This,bstrConnectionString,bstrUserName,bstrPassword,pbstrReverseConnectString)	\
    ( (This)->lpVtbl -> StartReverseConnectListener(This,bstrConnectionString,bstrUserName,bstrPassword,pbstrReverseConnectString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIViewer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RDPViewer;

#ifdef __cplusplus

class DECLSPEC_UUID("32be5ed2-5c86-480f-a914-0ff8885a1b3f")
RDPViewer;
#endif

EXTERN_C const CLSID CLSID_RDPSession;

#ifdef __cplusplus

class DECLSPEC_UUID("9B78F0E6-3E05-4A5B-B2E8-E743A8956B65")
RDPSession;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPISessionProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("dd7594ff-ea2a-4c06-8fdf-132de48b6510")
RDPSRAPISessionProperties;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIInvitationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("53d9c9db-75ab-4271-948a-4c4eb36a8f2b")
RDPSRAPIInvitationManager;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIInvitation;

#ifdef __cplusplus

class DECLSPEC_UUID("49174dc6-0731-4b5e-8ee1-83a63d3868fa")
RDPSRAPIInvitation;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendeeManager;

#ifdef __cplusplus

class DECLSPEC_UUID("d7b13a01-f7d4-42a6-8595-12fc8c24e851")
RDPSRAPIAttendeeManager;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendee;

#ifdef __cplusplus

class DECLSPEC_UUID("74f93bb5-755f-488e-8a29-2390108aef55")
RDPSRAPIAttendee;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendeeDisconnectInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("b47d7250-5bdb-405d-b487-caad9c56f4f8")
RDPSRAPIAttendeeDisconnectInfo;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplicationFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("e35ace89-c7e8-427e-a4f9-b9da072826bd")
RDPSRAPIApplicationFilter;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplicationList;

#ifdef __cplusplus

class DECLSPEC_UUID("9e31c815-7433-4876-97fb-ed59fe2baa22")
RDPSRAPIApplicationList;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("c116a484-4b25-4b9f-8a54-b934b06e57fa")
RDPSRAPIApplication;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIWindowList;

#ifdef __cplusplus

class DECLSPEC_UUID("9c21e2b8-5dd4-42cc-81ba-1c099852e6fa")
RDPSRAPIWindowList;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIWindow;

#ifdef __cplusplus

class DECLSPEC_UUID("03cf46db-ce45-4d36-86ed-ed28b74398bf")
RDPSRAPIWindow;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPITcpConnectionInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("be49db3f-ebb6-4278-8ce0-d5455833eaee")
RDPSRAPITcpConnectionInfo;
#endif
#endif /* __RDPCOMAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RefPtrCo.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();
    TRefPointerCollection(const TRefPointerCollection& trpc);

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::CRefPointerCollection
//              Copy constructor
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection(
    const TRefPointerCollection& trpc)
{
    Copy(trpc);	
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( CHeap_Exception& )
            {
    	        EndWrite() ;
                throw;
            }
            catch ( CFramework_Exception& e_FR )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( CHeap_Exception& )
    {
    	EndWrite() ;
        throw;
    }
    catch ( CFramework_Exception& e_FR )
    {
        EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( CHeap_Exception& )
    {
    	EndWrite() ;
        throw;
    }
    catch ( CFramework_Exception& e_FR )
    {
        EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\recapis.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecApis.h
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include "tpcshrd.h"
#include "RecTypes.h"

#ifndef __HRECOALT__
#define __HRECOALT__
DECLARE_HANDLE(HRECOALT); // definition of a handle for the alternate
#endif

#ifndef __HRECOCONTEXT__
#define __HRECOCONTEXT__
DECLARE_HANDLE(HRECOCONTEXT); // definition of a handle for the reco context
#endif

#ifndef __HRECOGNIZER__
#define __HRECOGNIZER__
DECLARE_HANDLE(HRECOGNIZER); // definition of a handle for the recognizer
#endif

#ifndef __HRECOLATTICE__
#define __HRECOLATTICE__
DECLARE_HANDLE(HRECOLATTICE); // definition of a handle for the lattice
#endif

#ifndef __HRECOWORDLIST__
#define __HRECOWORDLIST__
DECLARE_HANDLE(HRECOWORDLIST); // definition of a handle for the lattice
#endif

typedef HRESULT (*PfnRecoCallback)(DWORD, LPBYTE, HRECOCONTEXT);


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

////////////////////////
// IRecognizer
////////////////////////
HRESULT WINAPI CreateRecognizer(CLSID *pCLSID, HRECOGNIZER *phrec);
HRESULT WINAPI DestroyRecognizer(HRECOGNIZER hrec);
HRESULT WINAPI GetRecoAttributes(HRECOGNIZER hrec, RECO_ATTRS* pRecoAttrs);
HRESULT WINAPI CreateContext(HRECOGNIZER hrec, HRECOCONTEXT *phrc);
HRESULT WINAPI DestroyContext(HRECOCONTEXT hrc);
HRESULT WINAPI GetResultPropertyList(HRECOGNIZER hrec, ULONG* pPropertyCount, GUID*pPropertyGuid);
HRESULT WINAPI GetPreferredPacketDescription(HRECOGNIZER hrec, PACKET_DESCRIPTION* pPacketDescription);
HRESULT WINAPI GetUnicodeRanges(HRECOGNIZER hrec, ULONG *pcRanges, CHARACTER_RANGE *pcr);

////////////////////////
// IRecoContext
////////////////////////
HRESULT WINAPI AddStroke(HRECOCONTEXT hrc, const PACKET_DESCRIPTION* pPacketDesc, ULONG cbPacket, const BYTE *pPacket, const XFORM *pXForm);
HRESULT WINAPI GetBestResultString(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount_opt (*pcSize) WCHAR* pwcBestResult);
HRESULT WINAPI DestroyAlternate(HRECOALT hrcalt);
HRESULT WINAPI SetGuide(HRECOCONTEXT hrc, const RECO_GUIDE* pGuide, ULONG iIndex);
HRESULT WINAPI GetGuide(HRECOCONTEXT hrc, RECO_GUIDE* pGuide, ULONG *piIndex);
HRESULT WINAPI AdviseInkChange(HRECOCONTEXT hrc, BOOL bNewStroke);
HRESULT WINAPI SetCACMode(HRECOCONTEXT hrc, int iMode);
HRESULT WINAPI EndInkInput(HRECOCONTEXT hrc);
HRESULT WINAPI CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc);
HRESULT WINAPI ResetContext(HRECOCONTEXT hrc);
HRESULT WINAPI Process(HRECOCONTEXT hrc, BOOL *pbPartialProcessing);
HRESULT WINAPI SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR *pwcFactoid);
HRESULT WINAPI SetFlags(HRECOCONTEXT hrc, DWORD dwFlags);
HRESULT WINAPI GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice);
HRESULT WINAPI SetTextContext(HRECOCONTEXT hrc, ULONG cwcBefore, __ecount(cwcBefore) const WCHAR *pwcBefore, ULONG cwcAfter, __ecount(cwcAfter) const WCHAR *pwcAfter);
HRESULT WINAPI GetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG *pcRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI SetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG cRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI GetContextPropertyList(HRECOCONTEXT hrc, ULONG *pcProperties, GUID *pPropertyGUIDS);
HRESULT WINAPI GetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG *pcbSize, BYTE *pProperty);
HRESULT WINAPI SetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG cbSize, BYTE *pProperty);
HRESULT WINAPI IsStringSupported(HRECOCONTEXT hrc, ULONG wcString, const WCHAR *pwcString);
HRESULT WINAPI SetWordList(HRECOCONTEXT hrc, HRECOWORDLIST hwl);
HRESULT WINAPI GetContextPreferenceFlags(HRECOCONTEXT hrc, DWORD *pdwContextPreferenceFlags);
HRESULT WINAPI GetRightSeparator(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount(*pcSize) OPTIONAL WCHAR* pwcRightSeparator);
HRESULT WINAPI GetLeftSeparator(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount(*pcSize) OPTIONAL WCHAR* pwcLeftSeparator);

////////////////////////
// IRecoWordList
////////////////////////
HRESULT WINAPI DestroyWordList(HRECOWORDLIST hwl);
HRESULT WINAPI AddWordsToWordList(HRECOWORDLIST hwl, __nullnullterminated WCHAR * pwcWords);
HRESULT WINAPI MakeWordList(HRECOGNIZER hrec, __nullnullterminated WCHAR *pBuffer, HRECOWORDLIST *phwl);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\REND.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rend.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rend_h__
#define __rend_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __IEnumDialableAddrs_FWD_DEFINED__
#define __IEnumDialableAddrs_FWD_DEFINED__
typedef interface IEnumDialableAddrs IEnumDialableAddrs;
#endif 	/* __IEnumDialableAddrs_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __IEnumDirectoryObject_FWD_DEFINED__
#define __IEnumDirectoryObject_FWD_DEFINED__
typedef interface IEnumDirectoryObject IEnumDirectoryObject;
#endif 	/* __IEnumDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __IEnumDirectory_FWD_DEFINED__
#define __IEnumDirectory_FWD_DEFINED__
typedef interface IEnumDirectory IEnumDirectory;
#endif 	/* __IEnumDirectory_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __Rendezvous_FWD_DEFINED__
#define __Rendezvous_FWD_DEFINED__

#ifdef __cplusplus
typedef class Rendezvous Rendezvous;
#else
typedef struct Rendezvous Rendezvous;
#endif /* __cplusplus */

#endif 	/* __Rendezvous_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rend_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */
#define	IDISPDIROBJECT	( 0x10000 )

#define	IDISPDIROBJCONFERENCE	( 0x20000 )

#define	IDISPDIROBJUSER	( 0x30000 )

#define	IDISPDIRECTORY	( 0x10000 )

#define	IDISPILSCONFIG	( 0x20000 )

typedef 
enum DIRECTORY_TYPE
    {	DT_NTDS	= 1,
	DT_ILS	= 2
    } 	DIRECTORY_TYPE;

typedef 
enum DIRECTORY_OBJECT_TYPE
    {	OT_CONFERENCE	= 1,
	OT_USER	= 2
    } 	DIRECTORY_OBJECT_TYPE;

typedef 
enum RND_ADVERTISING_SCOPE
    {	RAS_LOCAL	= 1,
	RAS_SITE	= 2,
	RAS_REGION	= 3,
	RAS_WORLD	= 4
    } 	RND_ADVERTISING_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0000_v0_0_s_ifspec;

#ifndef __ITDirectoryObjectConference_INTERFACE_DEFINED__
#define __ITDirectoryObjectConference_INTERFACE_DEFINED__

/* interface ITDirectoryObjectConference */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1029E5D-CB5B-11D0-8D59-00C04FD91AC0")
    ITDirectoryObjectConference : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppProtocol) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Originator( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppOriginator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Originator( 
            /* [in] */ __RPC__in BSTR pOriginator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdvertisingScope( 
            /* [retval][out] */ __RPC__out RND_ADVERTISING_SCOPE *pAdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AdvertisingScope( 
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUrl) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ __RPC__in BSTR pUrl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR pDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEncrypted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEncrypted) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsEncrypted( 
            /* [in] */ VARIANT_BOOL fEncrypted) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE Date) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ DATE Date) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObjectConference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObjectConference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppProtocol);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Originator )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppOriginator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Originator )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pOriginator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdvertisingScope )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out RND_ADVERTISING_SCOPE *pAdvertisingScope);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AdvertisingScope )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Url )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUrl);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pUrl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEncrypted )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEncrypted);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsEncrypted )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ VARIANT_BOOL fEncrypted);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        END_INTERFACE
    } ITDirectoryObjectConferenceVtbl;

    interface ITDirectoryObjectConference
    {
        CONST_VTBL struct ITDirectoryObjectConferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectConference_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObjectConference_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObjectConference_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObjectConference_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObjectConference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObjectConference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObjectConference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObjectConference_get_Protocol(This,ppProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,ppProtocol) ) 

#define ITDirectoryObjectConference_get_Originator(This,ppOriginator)	\
    ( (This)->lpVtbl -> get_Originator(This,ppOriginator) ) 

#define ITDirectoryObjectConference_put_Originator(This,pOriginator)	\
    ( (This)->lpVtbl -> put_Originator(This,pOriginator) ) 

#define ITDirectoryObjectConference_get_AdvertisingScope(This,pAdvertisingScope)	\
    ( (This)->lpVtbl -> get_AdvertisingScope(This,pAdvertisingScope) ) 

#define ITDirectoryObjectConference_put_AdvertisingScope(This,AdvertisingScope)	\
    ( (This)->lpVtbl -> put_AdvertisingScope(This,AdvertisingScope) ) 

#define ITDirectoryObjectConference_get_Url(This,ppUrl)	\
    ( (This)->lpVtbl -> get_Url(This,ppUrl) ) 

#define ITDirectoryObjectConference_put_Url(This,pUrl)	\
    ( (This)->lpVtbl -> put_Url(This,pUrl) ) 

#define ITDirectoryObjectConference_get_Description(This,ppDescription)	\
    ( (This)->lpVtbl -> get_Description(This,ppDescription) ) 

#define ITDirectoryObjectConference_put_Description(This,pDescription)	\
    ( (This)->lpVtbl -> put_Description(This,pDescription) ) 

#define ITDirectoryObjectConference_get_IsEncrypted(This,pfEncrypted)	\
    ( (This)->lpVtbl -> get_IsEncrypted(This,pfEncrypted) ) 

#define ITDirectoryObjectConference_put_IsEncrypted(This,fEncrypted)	\
    ( (This)->lpVtbl -> put_IsEncrypted(This,fEncrypted) ) 

#define ITDirectoryObjectConference_get_StartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_StartTime(This,pDate) ) 

#define ITDirectoryObjectConference_put_StartTime(This,Date)	\
    ( (This)->lpVtbl -> put_StartTime(This,Date) ) 

#define ITDirectoryObjectConference_get_StopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_StopTime(This,pDate) ) 

#define ITDirectoryObjectConference_put_StopTime(This,Date)	\
    ( (This)->lpVtbl -> put_StopTime(This,Date) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObjectConference_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObjectUser_INTERFACE_DEFINED__
#define __ITDirectoryObjectUser_INTERFACE_DEFINED__

/* interface ITDirectoryObjectUser */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6F-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObjectUser : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPPhonePrimary( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IPPhonePrimary( 
            /* [in] */ __RPC__in BSTR pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObjectUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObjectUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IPPhonePrimary )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IPPhonePrimary )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in BSTR pName);
        
        END_INTERFACE
    } ITDirectoryObjectUserVtbl;

    interface ITDirectoryObjectUser
    {
        CONST_VTBL struct ITDirectoryObjectUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectUser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObjectUser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObjectUser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObjectUser_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObjectUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObjectUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObjectUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObjectUser_get_IPPhonePrimary(This,ppName)	\
    ( (This)->lpVtbl -> get_IPPhonePrimary(This,ppName) ) 

#define ITDirectoryObjectUser_put_IPPhonePrimary(This,pName)	\
    ( (This)->lpVtbl -> put_IPPhonePrimary(This,pName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObjectUser_INTERFACE_DEFINED__ */


#ifndef __IEnumDialableAddrs_INTERFACE_DEFINED__
#define __IEnumDialableAddrs_INTERFACE_DEFINED__

/* interface IEnumDialableAddrs */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDialableAddrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D70-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDialableAddrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDialableAddrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDialableAddrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnum);
        
        END_INTERFACE
    } IEnumDialableAddrsVtbl;

    interface IEnumDialableAddrs
    {
        CONST_VTBL struct IEnumDialableAddrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDialableAddrs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDialableAddrs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDialableAddrs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDialableAddrs_Next(This,celt,ppElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched) ) 

#define IEnumDialableAddrs_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDialableAddrs_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDialableAddrs_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDialableAddrs_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObject_INTERFACE_DEFINED__
#define __ITDirectoryObject_INTERFACE_DEFINED__

/* interface ITDirectoryObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6E-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectType( 
            /* [retval][out] */ __RPC__out DIRECTORY_OBJECT_TYPE *pObjectType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddrs( 
            /* [in] */ long dwAddressType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDialableAddrs( 
            /* [in] */ DWORD dwAddressType,
            /* [out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnumDialableAddrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppSecDes) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SecurityDescriptor( 
            /* [in] */ __RPC__in_opt IDispatch *pSecDes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObject * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectType )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__out DIRECTORY_OBJECT_TYPE *pObjectType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in BSTR pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddrs )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ long dwAddressType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDialableAddrs )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ DWORD dwAddressType,
            /* [out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnumDialableAddrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityDescriptor )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppSecDes);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SecurityDescriptor )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in_opt IDispatch *pSecDes);
        
        END_INTERFACE
    } ITDirectoryObjectVtbl;

    interface ITDirectoryObject
    {
        CONST_VTBL struct ITDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObject_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObject_get_ObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> get_ObjectType(This,pObjectType) ) 

#define ITDirectoryObject_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITDirectoryObject_put_Name(This,pName)	\
    ( (This)->lpVtbl -> put_Name(This,pName) ) 

#define ITDirectoryObject_get_DialableAddrs(This,dwAddressType,pVariant)	\
    ( (This)->lpVtbl -> get_DialableAddrs(This,dwAddressType,pVariant) ) 

#define ITDirectoryObject_EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)	\
    ( (This)->lpVtbl -> EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs) ) 

#define ITDirectoryObject_get_SecurityDescriptor(This,ppSecDes)	\
    ( (This)->lpVtbl -> get_SecurityDescriptor(This,ppSecDes) ) 

#define ITDirectoryObject_put_SecurityDescriptor(This,pSecDes)	\
    ( (This)->lpVtbl -> put_SecurityDescriptor(This,pSecDes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectoryObject_INTERFACE_DEFINED__
#define __IEnumDirectoryObject_INTERFACE_DEFINED__

/* interface IEnumDirectoryObject */
/* [unique][restricted][hidden][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06C9B64A-306D-11D1-9774-00C04FD91AC0")
    IEnumDirectoryObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITDirectoryObject **pVal,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITDirectoryObject **pVal,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryObjectVtbl;

    interface IEnumDirectoryObject
    {
        CONST_VTBL struct IEnumDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDirectoryObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDirectoryObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDirectoryObject_Next(This,celt,pVal,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pVal,pcFetched) ) 

#define IEnumDirectoryObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDirectoryObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDirectoryObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __ITILSConfig_INTERFACE_DEFINED__
#define __ITILSConfig_INTERFACE_DEFINED__

/* interface ITILSConfig */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITILSConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D72-6CFF-11d1-AFF7-00C04FC31FEE")
    ITILSConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ __RPC__out long *pPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ long Port) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITILSConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITILSConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITILSConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITILSConfig * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITILSConfig * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            __RPC__in ITILSConfig * This,
            /* [retval][out] */ __RPC__out long *pPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ long Port);
        
        END_INTERFACE
    } ITILSConfigVtbl;

    interface ITILSConfig
    {
        CONST_VTBL struct ITILSConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITILSConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITILSConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITILSConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITILSConfig_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITILSConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITILSConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITILSConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITILSConfig_get_Port(This,pPort)	\
    ( (This)->lpVtbl -> get_Port(This,pPort) ) 

#define ITILSConfig_put_Port(This,Port)	\
    ( (This)->lpVtbl -> put_Port(This,Port) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITILSConfig_INTERFACE_DEFINED__ */


#ifndef __ITDirectory_INTERFACE_DEFINED__
#define __ITDirectory_INTERFACE_DEFINED__

/* interface ITDirectory */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6C-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectory : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryType( 
            /* [retval][out] */ __RPC__out DIRECTORY_TYPE *pDirectoryType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDynamic( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDynamic) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultObjectTTL( 
            /* [retval][out] */ __RPC__out long *pTTL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultObjectTTL( 
            /* [in] */ long TTL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableAutoRefresh( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ __RPC__in BSTR pDomainName,
            /* [in] */ __RPC__in BSTR pUserName,
            /* [in] */ __RPC__in BSTR pPassword,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModifyDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnumObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryType )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out DIRECTORY_TYPE *pDirectoryType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDynamic )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDynamic);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultObjectTTL )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out long *pTTL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultObjectTTL )( 
            __RPC__in ITDirectory * This,
            /* [in] */ long TTL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableAutoRefresh )( 
            __RPC__in ITDirectory * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in ITDirectory * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Bind )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in BSTR pDomainName,
            /* [in] */ __RPC__in BSTR pUserName,
            /* [in] */ __RPC__in BSTR pPassword,
            /* [in] */ long lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ModifyDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryObjects )( 
            __RPC__in ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDirectoryObjects )( 
            __RPC__in ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnumObject);
        
        END_INTERFACE
    } ITDirectoryVtbl;

    interface ITDirectory
    {
        CONST_VTBL struct ITDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectory_get_DirectoryType(This,pDirectoryType)	\
    ( (This)->lpVtbl -> get_DirectoryType(This,pDirectoryType) ) 

#define ITDirectory_get_DisplayName(This,pName)	\
    ( (This)->lpVtbl -> get_DisplayName(This,pName) ) 

#define ITDirectory_get_IsDynamic(This,pfDynamic)	\
    ( (This)->lpVtbl -> get_IsDynamic(This,pfDynamic) ) 

#define ITDirectory_get_DefaultObjectTTL(This,pTTL)	\
    ( (This)->lpVtbl -> get_DefaultObjectTTL(This,pTTL) ) 

#define ITDirectory_put_DefaultObjectTTL(This,TTL)	\
    ( (This)->lpVtbl -> put_DefaultObjectTTL(This,TTL) ) 

#define ITDirectory_EnableAutoRefresh(This,fEnable)	\
    ( (This)->lpVtbl -> EnableAutoRefresh(This,fEnable) ) 

#define ITDirectory_Connect(This,fSecure)	\
    ( (This)->lpVtbl -> Connect(This,fSecure) ) 

#define ITDirectory_Bind(This,pDomainName,pUserName,pPassword,lFlags)	\
    ( (This)->lpVtbl -> Bind(This,pDomainName,pUserName,pPassword,lFlags) ) 

#define ITDirectory_AddDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> AddDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_ModifyDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> ModifyDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_RefreshDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> RefreshDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_DeleteDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> DeleteDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)	\
    ( (This)->lpVtbl -> get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant) ) 

#define ITDirectory_EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)	\
    ( (This)->lpVtbl -> EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectory_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectory_INTERFACE_DEFINED__
#define __IEnumDirectory_INTERFACE_DEFINED__

/* interface IEnumDirectory */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6D-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDirectory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) ITDirectory **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectory **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) ITDirectory **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDirectory * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectory **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryVtbl;

    interface IEnumDirectory
    {
        CONST_VTBL struct IEnumDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDirectory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDirectory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDirectory_Next(This,celt,ppElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched) ) 

#define IEnumDirectory_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDirectory_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDirectory_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDirectory_INTERFACE_DEFINED__ */


#ifndef __ITRendezvous_INTERFACE_DEFINED__
#define __ITRendezvous_INTERFACE_DEFINED__

/* interface ITRendezvous */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITRendezvous;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6B-6CFF-11d1-AFF7-00C04FC31FEE")
    ITRendezvous : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDirectories( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDefaultDirectories( 
            /* [out] */ __RPC__deref_out_opt IEnumDirectory **ppEnumDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectory( 
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectory **ppDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectoryObject( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectoryObject **ppDirectoryObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRendezvousVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITRendezvous * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITRendezvous * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITRendezvous * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRendezvous * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultDirectories )( 
            __RPC__in ITRendezvous * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDefaultDirectories )( 
            __RPC__in ITRendezvous * This,
            /* [out] */ __RPC__deref_out_opt IEnumDirectory **ppEnumDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectory )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectory **ppDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryObject )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectoryObject **ppDirectoryObject);
        
        END_INTERFACE
    } ITRendezvousVtbl;

    interface ITRendezvous
    {
        CONST_VTBL struct ITRendezvousVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRendezvous_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITRendezvous_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITRendezvous_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITRendezvous_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITRendezvous_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITRendezvous_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITRendezvous_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITRendezvous_get_DefaultDirectories(This,pVariant)	\
    ( (This)->lpVtbl -> get_DefaultDirectories(This,pVariant) ) 

#define ITRendezvous_EnumerateDefaultDirectories(This,ppEnumDirectory)	\
    ( (This)->lpVtbl -> EnumerateDefaultDirectories(This,ppEnumDirectory) ) 

#define ITRendezvous_CreateDirectory(This,DirectoryType,pName,ppDir)	\
    ( (This)->lpVtbl -> CreateDirectory(This,DirectoryType,pName,ppDir) ) 

#define ITRendezvous_CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)	\
    ( (This)->lpVtbl -> CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITRendezvous_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rend_0000_0009 */
/* [local] */ 



/***************************************************************/
/* Rend constants -- defined here for C apps                   */
/* The subsequent definitions that MIDL generates from the     */
/* module declaration are not used. The module declaration is  */
/* retained, however, so that the constants show up in the     */
/* type library.                                               */
/***************************************************************/

#define RENDBIND_AUTHENTICATE       0x00000001
#define RENDBIND_DEFAULTDOMAINNAME  0x00000002
#define RENDBIND_DEFAULTUSERNAME    0x00000004
#define RENDBIND_DEFAULTPASSWORD    0x00000008
/* this is just the previous three |'ed together for convenience. */
#define RENDBIND_DEFAULTCREDENTIALS 0x0000000e

#define __RendConstants_MODULE_DEFINED__

/***************************************************************/
/* end of rend constants section                               */
/***************************************************************/




extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0009_v0_0_s_ifspec;


#ifndef __RENDLib_LIBRARY_DEFINED__
#define __RENDLib_LIBRARY_DEFINED__

/* library RENDLib */
/* [helpstring][version][uuid] */ 








EXTERN_C const IID LIBID_RENDLib;

EXTERN_C const CLSID CLSID_Rendezvous;

#ifdef __cplusplus

class DECLSPEC_UUID("F1029E5B-CB5B-11D0-8D59-00C04FD91AC0")
Rendezvous;
#endif


#ifndef __RendConstants_MODULE_DEFINED__
#define __RendConstants_MODULE_DEFINED__


/* module RendConstants */
/* [helpstring][dllname][uuid] */ 

const long RENDBIND_AUTHENTICATE	=	0x1;

const long RENDBIND_DEFAULTDOMAINNAME	=	0x2;

const long RENDBIND_DEFAULTUSERNAME	=	0x4;

const long RENDBIND_DEFAULTPASSWORD	=	0x8;

const long RENDBIND_DEFAULTCREDENTIALS	=	0xe;

#endif /* __RendConstants_MODULE_DEFINED__ */
#endif /* __RENDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RichOle.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ringtonedeviceservice.h ===
/*
 *  RingtoneDeviceService.h
 *
 *  Contains declarations for the Ringtone Device Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _RINGTONEDEVICESERVICE_H_
#define _RINGTONEDEVICESERVICE_H_

#include <DeviceServices.h>
#include <MessageDeviceService.h>


/*****************************************************************************/
/*  Ringtone Service Info                                                    */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_Ringtones,
    0xd0eace0e, 0x707d, 0x4106, 0x8d, 0x38, 0x4f, 0x56, 0xe, 0x6a, 0x9f, 0x8e);

#define NAME_RingtonesSvc                   L"Ringtones"
#define TYPE_RingtonesSvc                   DEVSVCTYPE_DEFAULT


/*****************************************************************************/
/*  Ringtone Service Properties                                              */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_RingtonesSvc,
    0x7d05d925, 0x32e6, 0x4790, 0x92, 0x05, 0x54, 0x76, 0x4b, 0xb3, 0xcb, 0x74);

/*  PKEY_RingtonesSvc_DefaultRingtone
 *
 *  Indicates the objectID of the default ringtone for incoming calls
 *
 *  Type: UInt32
 *  Form: ObjectID
 */

DEFINE_DEVSVCPROPKEY(PKEY_RingtonesSvc_DefaultRingtone,
    0x7d05d925, 0x32e6, 0x4790, 0x92, 0x05, 0x54, 0x76, 0x4b, 0xb3, 0xcb, 0x74,
    2);

#define NAME_RingtonesSvc_DefaultRingtone   L"DefaultRingtone"


/*****************************************************************************/
/*  Ringtone Service Object Properties                                       */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_RingtonesObj,
    0x8d943c78, 0x2c7d, 0x4c74, 0x94, 0x5a, 0x42, 0xd8, 0x3c, 0xb5, 0x8b, 0x5a);

#endif  /* _RINGTONEDEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Rpc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC ) && !defined(_KRPCENV_)
/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AMD64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;

// NTSTATUS is also long, so this definition is valid
// for both user mode and kernel mode
typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#endif

#define __RPC_FAR

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_) && !defined(_KRPCENV_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#if !defined(_KRPCENV_)
#include <rpcnsi.h>
#endif // _KRPCENV_
#include <rpcnterr.h>
#include <excpt.h>
#if !defined(_KRPCENV_)
#include <winerror.h>
#endif // _KRPCENV_

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// rpcasync.h is now RPC_NO_WINDOWS_H aware, but we can't start including it always
// as it does still require windef.h which could clash with another header.
//
// Parsing of the below test:
// don't include rpcasync.h if either RPC_NO_WINDOWS_H or __RPC_MAC__ is set, except that setting
// RPC_NEED_RPCASYNC_H overrides RPC_NO_WINDOWS_H.
// In any case, if _KRPCENV_ is set, include rpcasync.h regardless of any of the above being set.
#if ((!defined( RPC_NO_WINDOWS_H ) || defined(RPC_NEED_RPCASYNC_H)) && !defined(__RPC_MAC__)) || defined(_KRPCENV_)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H et al.

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rendezvoussession_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rendezvoussession.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_RendezvousSessionLib,0xEFD856A4,0x5A85,0x4A1B,0xAD,0xD5,0x2E,0xAD,0xAC,0xE6,0xF6,0xA2);


MIDL_DEFINE_GUID(IID, IID_IRendezvousSession,0x9BA4B1DD,0x8B0C,0x48B7,0x9E,0x7C,0x2F,0x25,0x85,0x7C,0x8D,0xF5);


MIDL_DEFINE_GUID(IID, DIID_DRendezvousSessionEvents,0x3FA19CF8,0x64C4,0x4F53,0xAE,0x60,0x63,0x5B,0x38,0x06,0xEC,0xA6);


MIDL_DEFINE_GUID(IID, IID_IRendezvousApplication,0x4F4D070B,0xA275,0x49FB,0xB1,0x0D,0x8E,0xC2,0x63,0x87,0xB5,0x0D);


MIDL_DEFINE_GUID(CLSID, CLSID_RendezvousApplication,0x0B7E019A,0xB5DE,0x47fa,0x89,0x66,0x90,0x82,0xF8,0x2F,0xB1,0x92);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Resapi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    resapi.h

Abstract:

    This module defines the interface exported by Windows Clusters resources.

Revision History:

--*/

#ifndef _RESAPI_DEFINES_
#define _RESAPI_DEFINES_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <winsvc.h>
#include <clusapi.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT

//
// Definitions for entrypoints exported by a resource DLL.
//
#define STARTUP_ROUTINE "Startup"

#define CLRES_V1_FUNCTION_SIZE   sizeof(CLRES_V1_FUNCTIONS)
#define CLRES_VERSION_V1_00    0x100

#define CLRES_V1_FUNCTION_TABLE( _Name,                     \
                                 _Version,                  \
                                 _Prefix,                   \
                                 _Arbitrate,                \
                                 _Release,                  \
                                 _ResControl,               \
                                 _ResTypeControl            \
                                 )                          \
CLRES_FUNCTION_TABLE _Name = { CLRES_V1_FUNCTION_SIZE,      \
                               _Version,                    \
                               _Prefix##Open,               \
                               _Prefix##Close,              \
                               _Prefix##Online,             \
                               _Prefix##Offline,            \
                               _Prefix##Terminate,          \
                               _Prefix##LooksAlive,         \
                               _Prefix##IsAlive,            \
                               _Arbitrate,                  \
                               _Release,                    \
                               _ResControl,                 \
                               _ResTypeControl }

#endif // ifndef _RESAPI_DEFINES_

#ifndef _RESAPI_
#define _RESAPI_

//
// Define a RESID
//

typedef PVOID RESID;

//
// Define a RESOURCE_HANDLE
//

typedef HANDLE   RESOURCE_HANDLE;

//
// Define the Resource Status structure.
//

#define ClusterResourceCannotComeOnlineOnThisNode ( CLUSTER_RESOURCE_STATE ) ( ClusterResourcePending - 1 )
#define ClusterResourceCannotComeOnlineOnAnyNode  ( CLUSTER_RESOURCE_STATE ) ( ClusterResourcePending - 2 )

typedef struct RESOURCE_STATUS {
    CLUSTER_RESOURCE_STATE  ResourceState;
    DWORD           CheckPoint;
    DWORD           WaitHint;
    HANDLE          EventHandle;
} RESOURCE_STATUS, *PRESOURCE_STATUS;


#define ResUtilInitializeResourceStatus( _resource_status_ ) \
    ZeroMemory( _resource_status_, sizeof(RESOURCE_STATUS) )

//
// Define Resource DLL callback method for updating the state of a resource.
//

typedef
DWORD
(_stdcall *PSET_RESOURCE_STATUS_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

//
// Define Resource DLL callback method for notifying that a quorum
// resource DLL failed to hold the quorum resource.
//
typedef
VOID
(_stdcall *PQUORUM_RESOURCE_LOST) (
    IN RESOURCE_HANDLE Resource
    );

//
// Define Resource DLL callback method for logging events.
//
typedef enum LOG_LEVEL {
    LOG_INFORMATION,
    LOG_WARNING,
    LOG_ERROR,
    LOG_SEVERE
} LOG_LEVEL, *PLOG_LEVEL;

typedef
VOID
(_stdcall *PLOG_EVENT_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    );

typedef
RESID
(_stdcall *POPEN_ROUTINE) (
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

typedef
VOID
(_stdcall *PCLOSE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PONLINE_ROUTINE) (
    IN RESID Resource,
    IN OUT LPHANDLE EventHandle
    );

typedef
DWORD
(_stdcall *POFFLINE_ROUTINE) (
    IN RESID Resource
    );

typedef
VOID
(_stdcall *PTERMINATE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PIS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PLOOKS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PARBITRATE_ROUTINE) (
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    );

typedef
DWORD
(_stdcall *PRELEASE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PRESOURCE_CONTROL_ROUTINE) (
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef
DWORD
(_stdcall *PRESOURCE_TYPE_CONTROL_ROUTINE) (
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef enum _RESOURCE_EXIT_STATE {
    ResourceExitStateContinue,
    ResourceExitStateTerminate,
    ResourceExitStateMax
} RESOURCE_EXIT_STATE;


//***************************************************************
//
// Define the Function Table Format
//
//***************************************************************

//
// Version 1 Resource DLL Interface definition
//
typedef struct CLRES_V1_FUNCTIONS {
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PIS_ALIVE_ROUTINE IsAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
} CLRES_V1_FUNCTIONS, *PCLRES_V1_FUNCTIONS;

//
// Resource DLL Function Table definition
//
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLRES_FUNCTION_TABLE {
    DWORD   TableSize;
    DWORD   Version;
    union {
        CLRES_V1_FUNCTIONS V1Functions;
    } DUMMYUNIONNAME;
} CLRES_FUNCTION_TABLE, *PCLRES_FUNCTION_TABLE;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union
#endif

//
// Define the Resource DLL Startup routine. This is the only routine
// that should be exported from a resource DLL.
//

//
// Calculate the byte offset of a field in a structure of type type.
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

//
// large ints need more space than what was originally allocated.
//
typedef struct RESUTIL_LARGEINT_DATA {
    LARGE_INTEGER   Default;
    LARGE_INTEGER   Minimum;
    LARGE_INTEGER   Maximum;
} RESUTIL_LARGEINT_DATA, *PRESUTIL_LARGEINT_DATA;

typedef struct RESUTIL_ULARGEINT_DATA {
    ULARGE_INTEGER  Default;
    ULARGE_INTEGER  Minimum;
    ULARGE_INTEGER  Maximum;
} RESUTIL_ULARGEINT_DATA, *PRESUTIL_ULARGEINT_DATA;

typedef struct RESUTIL_FILETIME_DATA {
    FILETIME  Default;
    FILETIME  Minimum;
    FILETIME  Maximum;
} RESUTIL_FILETIME_DATA, *PRESUTIL_FILETIME_DATA;

//
// Property list structures and functions
//
typedef struct RESUTIL_PROPERTY_ITEM {
    LPWSTR  Name;               // Property name
    LPWSTR  KeyName;            // Name of value in cluster database
    DWORD   Format;             // Format: REG_SZ, REG_DWORD, etc.
    union {
        DWORD_PTR               DefaultPtr;
        DWORD                   Default;     // Default value
        LPVOID                  lpDefault;
        PRESUTIL_LARGEINT_DATA  LargeIntData;
        PRESUTIL_ULARGEINT_DATA ULargeIntData;
        PRESUTIL_FILETIME_DATA  FileTimeData;
    } DUMMYUNIONNAME;
    DWORD   Minimum;            // Minimum value
    DWORD   Maximum;            // Maximum value
    DWORD   Flags;              // Flags for this item
#define RESUTIL_PROPITEM_READ_ONLY  0x00000001  // Property is read-only
#define RESUTIL_PROPITEM_REQUIRED   0x00000002  // Property is required
#define RESUTIL_PROPITEM_SIGNED     0x00000004  // Numeric property is signed (defaults to unsigned)

    DWORD   Offset;             // Byte offset to value in parameter block
                                //   Assumes MULTI_SZ and BINARY parameters
                                //   are LPWSTRs followed by DWORDs for length
} RESUTIL_PROPERTY_ITEM, *PRESUTIL_PROPERTY_ITEM;


typedef
DWORD
(_stdcall *PSTARTUP_ROUTINE) (
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

//
// Define layout of shared memory used for tracking Resource Monitor state.
//
typedef enum RESOURCE_MONITOR_STATE {
    RmonInitializing,
    RmonIdle,
    RmonStartingResource,
    RmonInitializingResource,
    RmonOnlineResource,
    RmonOfflineResource,
    RmonShutdownResource,
    RmonDeletingResource,
    RmonIsAlivePoll,
    RmonLooksAlivePoll,
    RmonArbitrateResource,
    RmonReleaseResource,
    RmonResourceControl,
    RmonResourceTypeControl,
    RmonTerminateResource,
    RmonDeadlocked
} RESOURCE_MONITOR_STATE;

typedef struct MONITOR_STATE {
    LARGE_INTEGER LastUpdate;
    RESOURCE_MONITOR_STATE State;
    HANDLE ActiveResource;
    BOOL   ResmonStop;
} MONITOR_STATE, *PMONITOR_STATE;


//
// Resource Utility Routines
//

DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_START_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    );

typedef DWORD
(WINAPI * PRESUTIL_STOP_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_SERVICE)(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_STOP_SERVICE)(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    );

typedef DWORD
(WINAPI * PRESUTIL_CREATE_DIRECTORY_TREE)(
    IN LPCWSTR pszPath
    );

BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    );

typedef BOOL
(WINAPI * PRESUTIL_IS_PATH_VALID)(
    IN LPCWSTR pszPath
    );

DWORD
WINAPI
ResUtilEnumProperties(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_PROPERTIES)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilEnumPrivateProperties(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_PRIVATE_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetAllProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_ALL_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPrivateProperties(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PRIVATE_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTY_SIZE)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilGetProperty(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    __deref_inout_bcount_part(*pcbOutPropertyItemSize, *pcbOutPropertyItemSize) PVOID *pOutPropertyItem,
    __inout LPDWORD pcbOutPropertyItemSize
    );

typedef
__success( return == ERROR_SUCCESS )
DWORD
(WINAPI * PRESUTIL_GET_PROPERTY)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    __deref_inout_bcount_part(*pcbOutPropertyItemSize, *pcbOutPropertyItemSize) PVOID *pOutPropertyItem,
    __inout LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ResUtilVerifyPropertyTable(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_PROPERTY_TABLE)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTable(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_TABLE)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_TABLE_EX)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_PARAMETER_BLOCK_EX)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetUnknownProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_UNKNOWN_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out LPBYTE pOutParams,
    __in BOOL bCheckForRequiredProperties,
    __deref_out_opt LPWSTR * pszNameOfPropInError
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES_TO_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES_TO_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part_opt(*pcbOutPropertyListSize, *pcbBytesReturned ) PVOID  pOutPropertyList,
    __inout LPDWORD pcbOutPropertyListSize,
    __in const LPBYTE pInParams,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_PROPERTY_LIST_FROM_PARAMETER_BLOCK)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part_opt(*pcbOutPropertyListSize, *pcbBytesReturned ) PVOID  pOutPropertyList,
    __inout LPDWORD pcbOutPropertyListSize,
    __in const LPBYTE pInParams,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

typedef DWORD
(WINAPI * PRESUTIL_DUP_PARAMETER_BLOCK)(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

typedef void
(WINAPI * PRESUTIL_FREE_PARAMETER_BLOCK)(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ADD_UNKNOWN_PROPERTIES)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    __in HKEY hkeyClusterKey,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PRIVATE_PROPERTY_LIST)(
    __in HKEY hkeyClusterKey,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_PRIVATE_PROPERTY_LIST)(
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

PWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    );

typedef PWSTR
(WINAPI * PRESUTIL_DUP_STRING)(
    IN LPCWSTR pszInString
    );

DWORD
WINAPI
ResUtilGetBinaryValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_BINARY_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize
    );

LPWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

typedef LPWSTR
(WINAPI * PRESUTIL_GET_SZ_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

LPWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

typedef LPWSTR
(WINAPI * PRESUTIL_GET_EXPAND_SZ_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

FORCEINLINE
DWORD
WINAPI_INLINE
ResUtilGetMultiSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize
    )
{
    return ResUtilGetBinaryValue( hkeyClusterKey, pszValueName, (LPBYTE *) ppszOutValue, pcbOutValueSize );
}

DWORD
WINAPI
ResUtilGetDwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out LPDWORD pdwOutValue,
    __in DWORD dwDefaultValue
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_DWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out LPDWORD pdwOutValue,
    __in DWORD dwDefaultValue
    );

DWORD
WINAPI
ResUtilGetQwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out PULONGLONG pqwOutValue,
    __in ULONGLONG qwDefaultValue
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_QWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out PULONGLONG pqwOutValue,
    __in ULONGLONG qwDefaultValue
    );

DWORD
WINAPI
ResUtilSetBinaryValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) const LPBYTE pbNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_inout_bcount_full(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __inout LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_BINARY_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) const LPBYTE pbNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_inout_bcount_full(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __inout LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __deref_opt_inout LPWSTR *ppszOutString
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __deref_opt_inout LPWSTR *ppszOutString
    );

DWORD
WINAPI
ResUtilSetExpandSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __inout_opt LPWSTR *ppszOutString
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_EXPAND_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __inout_opt LPWSTR *ppszOutString
    );

DWORD
WINAPI
ResUtilSetMultiSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) LPCWSTR pszNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_out_bcount_full(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __inout_opt LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_MULTI_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) LPCWSTR pszNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_out_bcount_full(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __inout_opt LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_DWORD_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

DWORD
WINAPI
ResUtilSetQwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in ULONGLONG qwNewValue,
    __inout_opt PULONGLONG pqwOutValue
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_QWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in ULONGLONG qwNewValue,
    __inout_opt PULONGLONG pqwOutValue
    );

DWORD
WINAPI
ResUtilGetBinaryProperty(
    __deref_out_bcount(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_BINARY pValueStruct,
    __in_bcount_opt( cbOldValueSize ) const LPBYTE pbOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_BINARY_PROPERTY)(
    __deref_out_bcount(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_BINARY pValueStruct,
    __in_bcount_opt( cbOldValueSize ) const LPBYTE pbOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetSzProperty(
    __deref_out LPWSTR *ppszOutValue,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_opt LPCWSTR pszOldValue,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_SZ_PROPERTY)(
    __deref_out LPWSTR *ppszOutValue,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_opt LPCWSTR pszOldValue,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetMultiSzProperty(
    __deref_out_bcount(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_bcount_opt(cbOldValueSize) LPCWSTR pszOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_MULTI_SZ_PROPERTY)(
    __deref_out_bcount(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_bcount_opt(cbOldValueSize) LPCWSTR pszOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_DWORD_PROPERTY)(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetLongProperty(
    OUT LPLONG plOutValue,
    IN const PCLUSPROP_LONG pValueStruct,
    IN LONG lOldValue,
    IN LONG lMinimum,
    IN LONG lMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_LONG_PROPERTY)(
    OUT LPLONG plOutValue,
    IN const PCLUSPROP_LONG pValueStruct,
    IN LONG lOldValue,
    IN LONG lMinimum,
    IN LONG lMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetFileTimeProperty(
    OUT LPFILETIME pftOutValue,
    IN const PCLUSPROP_FILETIME pValueStruct,
    IN FILETIME ftOldValue,
    IN FILETIME ftMinimum,
    IN FILETIME ftMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_FILETIME_PROPERTY)(
    OUT LPFILETIME pftOutValue,
    IN const PCLUSPROP_FILETIME pValueStruct,
    IN FILETIME ftOldValue,
    IN FILETIME ftMinimum,
    IN FILETIME ftMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    __in HRESOURCE hResource
    );

typedef LPVOID
(WINAPI * PRESUTIL_GET_ENVIRONMENT_WITH_NET_NAME)(
    __in HRESOURCE hResource
    );

DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    );

typedef DWORD
(WINAPI * PRESUTIL_FREE_ENVIRONMENT)(
    IN LPVOID lpEnvironment
    );

LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );

typedef LPWSTR
(WINAPI * PRESUTIL_EXPAND_ENVIRONMENT_STRINGS)(
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
ResUtilSetResourceServiceEnvironment(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_RESOURCE_SERVICE_ENVIRONMENT)(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilRemoveResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_REMOVE_RESOURCE_SERVICE_ENVIRONMENT)(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

DWORD
WINAPI
ResUtilSetResourceServiceStartParameters(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_RESOURCE_SERVICE_START_PARAMETERS)(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilFindSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_EXPAND_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_EXPANDED_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindDwordProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPDWORD pdwPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_DWORD_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ResUtilFindBinaryProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out_bcount_full(*pcbPropertyValueSize) LPBYTE *pbPropertyValue,
    __out_opt LPDWORD pcbPropertyValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_BINARY_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out_bcount_full(*pcbPropertyValueSize) LPBYTE *pbPropertyValue,
    __out_opt LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindMultiSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_out_bcount_full(*pcbPropertyValueSize) LPWSTR *pszPropertyValue,
    __out LPDWORD pcbPropertyValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_MULTI_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_out_bcount_full(*pcbPropertyValueSize) LPWSTR *pszPropertyValue,
    __out LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindLongProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPLONG plPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_LONG_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPLONG plPropertyValue
    );

DWORD
WINAPI
ResUtilFindFileTimeProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPFILETIME pftPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_FILETIME_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPFILETIME pftPropertyValue
    );


//
// Common worker thread routines that allow a pending operation to
// be cancelled with CORRECT synchronization.
//
typedef struct CLUS_WORKER {
    HANDLE hThread;
    BOOL Terminate;
} CLUS_WORKER, *PCLUS_WORKER;

typedef DWORD (WINAPI *PWORKER_START_ROUTINE)(
    PCLUS_WORKER pWorker,
    LPVOID lpThreadParameter
    );

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUS_WORKER_CREATE)(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    );

typedef BOOL
(WINAPI * PCLUSAPIClusWorkerCheckTerminate)(
    IN PCLUS_WORKER lpWorker
    );

VOID
WINAPI
ClusWorkerTerminate(
    __in PCLUS_WORKER lpWorker
    );

typedef VOID
(WINAPI * PCLUSAPI_CLUS_WORKER_TERMINATE)(
    __in PCLUS_WORKER lpWorker
    );


//Define enumerate resource callback function. This gets called for each resource enumerated
//by ResUtilEnumResources
typedef   DWORD (*LPRESOURCE_CALLBACK)( HRESOURCE, HRESOURCE , PVOID );
typedef   DWORD (*LPRESOURCE_CALLBACK_EX)( HCLUSTER, HRESOURCE, HRESOURCE , PVOID );


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


typedef BOOL
(WINAPI * PRESUTIL_RESOURCES_EQUAL)(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );


typedef BOOL
(WINAPI * PRESUTIL_RESOURCE_TYPES_EQUAL)(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );

BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

typedef BOOL
(WINAPI * PRESUTIL_IS_RESOURCE_CLASS_EQUAL)(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_RESOURCES)(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_RESOURCES_EX)(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY)(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY_BY_NAME)(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY_BY_CLASS)(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_NAME_DEPENDENCY)(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilGetResourceDependentIPAddressProps(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchAddress, *pcchAddress) LPWSTR pszAddress,
    __inout DWORD *pcchAddress,
    __out_ecount_part(*pcchSubnetMask, *pcchSubnetMask) LPWSTR pszSubnetMask,
    __inout DWORD *pcchSubnetMask,
    __out_ecount_part(*pcchNetwork, *pcchNetwork) LPWSTR pszNetwork,
    __inout DWORD *pcch_Network
    );

typedef
__success( return == ERROR_SUCCESS )
DWORD
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENTIP_ADDRESS_PROPS)(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchAddress, *pcchAddress) LPWSTR pszAddress,
    __inout DWORD *pcchAddress,
    __out_ecount_part(*pcchSubnetMask, *pcchSubnetMask) LPWSTR pszSubnetMask,
    __inout DWORD *pcchSubnetMask,
    __out_ecount_part(*pcchNetwork, *pcchNetwork) LPWSTR pszNetwork,
    __inout DWORD *pcchNetwork
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilFindDependentDiskResourceDriveLetter(
    __in HCLUSTER hCluster,              // handle to cluster
    __in HRESOURCE hResource,            // handle to resource to query for dependencies
    __out_ecount_part(*pcchDriveLetter, *pcchDriveLetter) LPWSTR pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    __inout DWORD * pcchDriveLetter      // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

typedef
__success( return == ERROR_SUCCESS ) DWORD
(WINAPI * PRESUTIL_FIND_DEPENDENT_DISK_RESOURCE_DRIVE_LETTER)(
    __in HCLUSTER hCluster,              // handle to cluster
    __in HRESOURCE hResource,            // handle to resource to query for dependencies
    __out_ecount_part(*pcchDriveLetter, *pcchDriveLetter) LPWSTR pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    __inout DWORD *pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    __in DWORD dwServicePid,
    __in BOOL bOffline,
    __out PDWORD pdwResourceState,
    __in PLOG_EVENT_ROUTINE pfnLogEvent,
    __in RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_TERMINATE_SERVICE_PROCESS_FROM_RES_DLL)(
    __in DWORD dwServicePid,
    __in BOOL bOffline,
    __out PDWORD pdwResourceState,
    __in PLOG_EVENT_ROUTINE pfnLogEvent,
    __in RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilGetPropertyFormats(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbPropertyFormatListSize, *pcbBytesReturned) PVOID pOutPropertyFormatList,
    __in DWORD cbPropertyFormatListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTY_FORMATS)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbPropertyFormatListSize, *pcbBytesReturned) PVOID pOutPropertyFormatList,
    __in DWORD cbPropertyFormatListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );


DWORD
WINAPI
ResUtilGetCoreClusterResources(
    __in HCLUSTER hCluster,
    __out HRESOURCE *phClusterNameResource,
    __out HRESOURCE *phClusterIPAddressResource,
    __out HRESOURCE *phClusterQuorumResource
    );


typedef DWORD
(WINAPI * PRESUTIL_GET_CORE_CLUSTER_RESOURCES)(
    __in HCLUSTER hCluster,
    __out HRESOURCE *phClusterNameResource,
    __out HRESOURCE *phClusterIPAddressResource,
    __out HRESOURCE *phClusterQuorumResource
    );

DWORD
WINAPI
ResUtilGetResourceName(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchResourceNameInOut, *pcchResourceNameInOut) PWSTR pszResourceName,
    __inout DWORD *pcchResourceNameInOut
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_RESOURCE_NAME)(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchResourceNameInOut, *pcchResourceNameInOut) PWSTR pszResourceName,
    __inout DWORD *pcchResourceNameInOut
    );

typedef enum _CLUSTER_ROLE {
    ClusterRoleDHCP,
    ClusterRoleDTC,
    ClusterRoleFileServer,
    ClusterRoleGenericApplication,
    ClusterRoleGenericScript,
    ClusterRoleGenericService,
    ClusterRoleISCSINameServer,
    ClusterRoleMSMQ,
    ClusterRoleNFS,
    ClusterRolePrintServer,
    ClusterRoleStandAloneNamespaceServer,
    ClusterRoleVolumeShadowCopyServiceTask,
    ClusterRoleWINS,
} CLUSTER_ROLE;

typedef enum _CLUSTER_ROLE_STATE {
    ClusterRoleUnknown = -1,
    ClusterRoleClustered,
    ClusterRoleUnclustered
} CLUSTER_ROLE_STATE;

__success(return >= 0) // != ClusterRoleUnknown
CLUSTER_ROLE_STATE
WINAPI
ResUtilGetClusterRoleState(
    __in HCLUSTER       hCluster,
    __in CLUSTER_ROLE   eClusterRole
    );

// TODO: should we implement versioning here like ClusApi - maybe overkill for now.
BOOL
WINAPI
ClusterIsPathOnSharedVolume(
    __in LPCWSTR lpszPathName
);

typedef BOOL
(WINAPI * PCLUSTER_IS_PATH_ON_SHARED_VOLUME)(
    __in LPCWSTR lpszPathName
    );

BOOL
WINAPI
ClusterGetVolumePathName(
    __in   LPCWSTR lpszFileName,
    __out  LPWSTR lpszVolumePathName,
    __in   DWORD cchBufferLength
    );

typedef BOOL
(WINAPI * PCLUSTER_GET_VOLUME_PATH_NAME)(
    __in   LPCWSTR lpszFileName,
    __out  LPWSTR lpszVolumePathName,
    __in   DWORD cchBufferLength
    );

BOOL
WINAPI
ClusterGetVolumeNameForVolumeMountPoint(
    __in   LPCWSTR lpszVolumeMountPoint,
    __out  LPWSTR lpszVolumeName,
    __in   DWORD cchBufferLength
    );

typedef BOOL
(WINAPI * PCLUSTER_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT)(
    __in   LPCWSTR lpszVolumeMountPoint,
    __out  LPWSTR lpszVolumeName,
    __in   DWORD cchBufferLength
    );

DWORD
WINAPI
ClusterPrepareSharedVolumeForBackup(
    __in LPCWSTR lpszFileName,
    __out LPWSTR lpszVolumePathName,
    __inout LPDWORD lpcchVolumePathName,
    __out LPWSTR lpszVolumeName,
    __inout LPDWORD lpcchVolumeName
    );

typedef DWORD
(WINAPI * PCLUSTER_PREPARE_SHARED_VOLUME_FOR_BACKUP)(
    __in LPCWSTR lpszFileName,
    __out LPWSTR lpszVolumePathName,
    __inout LPDWORD lpcchVolumePathName,
    __out LPWSTR lpszVolumeName,
    __inout LPDWORD lpcchVolumeName
    );

DWORD
WINAPI
ClusterClearBackupStateForSharedVolume(
    __in LPCWSTR lpszVolumePathName
    );

typedef DWORD
(WINAPI * PCLUSTER_CLEAR_BACKUP_STATE_FOR_SHARED_VOLUME)(
    __in LPCWSTR lpszVolumePathName
    );

#ifdef __cplusplus
}
#endif


#endif // ifdef _RESAPI_DEFINES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rendezvoussession.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rendezvoussession.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rendezvoussession_h__
#define __rendezvoussession_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRendezvousSession_FWD_DEFINED__
#define __IRendezvousSession_FWD_DEFINED__
typedef interface IRendezvousSession IRendezvousSession;
#endif 	/* __IRendezvousSession_FWD_DEFINED__ */


#ifndef __DRendezvousSessionEvents_FWD_DEFINED__
#define __DRendezvousSessionEvents_FWD_DEFINED__
typedef interface DRendezvousSessionEvents DRendezvousSessionEvents;
#endif 	/* __DRendezvousSessionEvents_FWD_DEFINED__ */


#ifndef __IRendezvousApplication_FWD_DEFINED__
#define __IRendezvousApplication_FWD_DEFINED__
typedef interface IRendezvousApplication IRendezvousApplication;
#endif 	/* __IRendezvousApplication_FWD_DEFINED__ */


#ifndef __RendezvousApplication_FWD_DEFINED__
#define __RendezvousApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class RendezvousApplication RendezvousApplication;
#else
typedef struct RendezvousApplication RendezvousApplication;
#endif /* __cplusplus */

#endif 	/* __RendezvousApplication_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rendezvoussession_0000_0000 */
/* [local] */ 

#define	DISPID_EVENT_ON_STATE_CHANGED	( 5 )

#define	DISPID_EVENT_ON_TERMINATION	( 6 )

#define	DISPID_EVENT_ON_CONTEXT_DATA	( 7 )

#define	DISPID_EVENT_ON_SEND_ERROR	( 8 )



extern RPC_IF_HANDLE __MIDL_itf_rendezvoussession_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rendezvoussession_0000_0000_v0_0_s_ifspec;


#ifndef __RendezvousSessionLib_LIBRARY_DEFINED__
#define __RendezvousSessionLib_LIBRARY_DEFINED__

/* library RendezvousSessionLib */
/* [helpstring][version][uuid] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_rendezvoussession_0000_0000_0001
    {	RSS_UNKNOWN	= 0,
	RSS_READY	= ( RSS_UNKNOWN + 1 ) ,
	RSS_INVITATION	= ( RSS_READY + 1 ) ,
	RSS_ACCEPTED	= ( RSS_INVITATION + 1 ) ,
	RSS_CONNECTED	= ( RSS_ACCEPTED + 1 ) ,
	RSS_CANCELLED	= ( RSS_CONNECTED + 1 ) ,
	RSS_DECLINED	= ( RSS_CANCELLED + 1 ) ,
	RSS_TERMINATED	= ( RSS_DECLINED + 1 ) 
    } 	RENDEZVOUS_SESSION_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rendezvoussession_0000_0000_0002
    {	RSF_NONE	= 0,
	RSF_INVITER	= 0x1,
	RSF_INVITEE	= 0x2,
	RSF_ORIGINAL_INVITER	= 0x4,
	RSF_REMOTE_LEGACYSESSION	= 0x8,
	RSF_REMOTE_WIN7SESSION	= 0x10
    } 	RENDEZVOUS_SESSION_FLAGS;


EXTERN_C const IID LIBID_RendezvousSessionLib;

#ifndef __IRendezvousSession_INTERFACE_DEFINED__
#define __IRendezvousSession_INTERFACE_DEFINED__

/* interface IRendezvousSession */
/* [unique][oleautomation][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRendezvousSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA4B1DD-8B0C-48B7-9E7C-2F25857C8DF5")
    IRendezvousSession : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RENDEZVOUS_SESSION_STATE *pSessionState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RemoteUser( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out LONG *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendContextData( 
            /* [in] */ __RPC__in BSTR bstrData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in BSTR bstrAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRendezvousSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRendezvousSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRendezvousSession * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__out RENDEZVOUS_SESSION_STATE *pSessionState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteUser )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__out LONG *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SendContextData )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in BSTR bstrAppData);
        
        END_INTERFACE
    } IRendezvousSessionVtbl;

    interface IRendezvousSession
    {
        CONST_VTBL struct IRendezvousSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRendezvousSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRendezvousSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRendezvousSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRendezvousSession_get_State(This,pSessionState)	\
    ( (This)->lpVtbl -> get_State(This,pSessionState) ) 

#define IRendezvousSession_get_RemoteUser(This,bstrUserName)	\
    ( (This)->lpVtbl -> get_RemoteUser(This,bstrUserName) ) 

#define IRendezvousSession_get_Flags(This,pFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pFlags) ) 

#define IRendezvousSession_SendContextData(This,bstrData)	\
    ( (This)->lpVtbl -> SendContextData(This,bstrData) ) 

#define IRendezvousSession_Terminate(This,hr,bstrAppData)	\
    ( (This)->lpVtbl -> Terminate(This,hr,bstrAppData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRendezvousSession_INTERFACE_DEFINED__ */


#ifndef __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__
#define __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__

/* dispinterface DRendezvousSessionEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DRendezvousSessionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3FA19CF8-64C4-4F53-AE60-635B3806ECA6")
    DRendezvousSessionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DRendezvousSessionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DRendezvousSessionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DRendezvousSessionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DRendezvousSessionEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DRendezvousSessionEventsVtbl;

    interface DRendezvousSessionEvents
    {
        CONST_VTBL struct DRendezvousSessionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DRendezvousSessionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DRendezvousSessionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DRendezvousSessionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DRendezvousSessionEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DRendezvousSessionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DRendezvousSessionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DRendezvousSessionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IRendezvousApplication_INTERFACE_DEFINED__
#define __IRendezvousApplication_INTERFACE_DEFINED__

/* interface IRendezvousApplication */
/* [unique][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IRendezvousApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F4D070B-A275-49FB-B10D-8EC26387B50D")
    IRendezvousApplication : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRendezvousSession( 
            /* [in] */ __RPC__in_opt IUnknown *pRendezvousSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRendezvousApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRendezvousApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRendezvousApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRendezvousApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRendezvousSession )( 
            __RPC__in IRendezvousApplication * This,
            /* [in] */ __RPC__in_opt IUnknown *pRendezvousSession);
        
        END_INTERFACE
    } IRendezvousApplicationVtbl;

    interface IRendezvousApplication
    {
        CONST_VTBL struct IRendezvousApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRendezvousApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRendezvousApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRendezvousApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRendezvousApplication_SetRendezvousSession(This,pRendezvousSession)	\
    ( (This)->lpVtbl -> SetRendezvousSession(This,pRendezvousSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRendezvousApplication_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RendezvousApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("0B7E019A-B5DE-47fa-8966-9082F82FB192")
RendezvousApplication;
#endif
#endif /* __RendezvousSessionLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0/4.0 public definitions
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_
#pragma once

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value
//		Version 1.0		0x0100	
//		Version 2.0		0x0200	
//		Version 2.1		0x0210	
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

#define MSFTEDIT_CLASS		L"RICHEDIT50W"
// NOTE:  MSFTEDIT.DLL only registers MSFTEDIT_CLASS.  If an application wants
// to use the following Richedit classes, it needs to load the riched20.dll.
// Otherwise, CreateWindow with RICHEDIT_CLASS would fail.
// This also applies to any dialog that uses RICHEDIT_CLASS, 

// RichEdit 2.0 Window Class 
// On Windows CE, avoid possible conflicts on Win95
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	//----------------------MACPORT 
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	// MACPORT change 
#endif // MACPORT  

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif // UNICODE 
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif // _RICHEDIT_VER >= 0x0200 

// RichEdit messages 

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_UNICHAR
#define WM_UNICHAR				0x0109
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

// RichEdit 2.0 messages 
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

// enum for use with EM_GET/SETTEXTMODE 
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	// Default behavior 
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	// Default behavior 
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	// Default behavior 
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

// East Asia specific messages 
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

// RE3.0 FE messages 
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

// BiDi specific messages 
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

// Extended edit style specific messages 
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

// Extended edit style masks 
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS			8	// (obsolete)
#define SES_EMULATE10			16	// (obsolete)
#define	SES_USECRLF			32	// (obsolete)
#define SES_NOXLTSYMBOLRANGE		32
#define SES_USEAIMM			64
#define SES_NOIME			128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384
#define SES_DRAFTMODE			32768

#define	SES_USECTF				0x0010000
#define SES_HIDEGRIDLINES		0x0020000
#define SES_USEATFONT			0x0040000
#define SES_CUSTOMLOOK			0x0080000
#define SES_LBSCROLLNOTIFY		0x0100000
#define SES_CTFALLOWEMBED		0x0200000
#define SES_CTFALLOWSMARTTAG	0x0400000
#define SES_CTFALLOWPROOFING	0x0800000

// Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS 
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// High completes comp string when aborting, low cancels
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080
#define IMF_NORTFFONTSUBSTITUTE 0x0400


// Values for EM_GETIMECOMPMODE 
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004
#define ICM_CTF					0x0005

// Options for EM_SETTYPOGRAPHYOPTIONS 
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2
#define TO_DISABLECUSTOMTEXTOUT	4
#define TO_ADVANCEDLAYOUT		8

// Pegasus outline mode messages (RE 3.0) 

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)
#define EM_GETVIEWKIND			(WM_USER + 226)
#define EM_SETVIEWKIND			(WM_USER + 227)

// RichEdit 4.0 messages
#define EM_GETPAGE				(WM_USER + 228)
#define EM_SETPAGE				(WM_USER + 229)
#define EM_GETHYPHENATEINFO		(WM_USER + 230)
#define EM_SETHYPHENATEINFO		(WM_USER + 231)
#define EM_GETPAGEROTATE		(WM_USER + 235)
#define EM_SETPAGEROTATE		(WM_USER + 236)
#define EM_GETCTFMODEBIAS		(WM_USER + 237)
#define EM_SETCTFMODEBIAS		(WM_USER + 238)
#define EM_GETCTFOPENSTATUS		(WM_USER + 240)
#define EM_SETCTFOPENSTATUS		(WM_USER + 241)
#define EM_GETIMECOMPTEXT		(WM_USER + 242)
#define EM_ISIME				(WM_USER + 243)
#define EM_GETIMEPROPERTY		(WM_USER + 244)

// These messages control what rich edit does when it comes accross
// OLE objects during RTF stream in.  Normally rich edit queries the client
// application only after OleLoad has been called.  With these messages it is possible to
// set the rich edit control to a mode where it will query the client application before
// OleLoad is called
#define EM_GETQUERYRTFOBJ		(WM_USER + 269)
#define EM_SETQUERYRTFOBJ		(WM_USER + 270)

// EM_SETPAGEROTATE wparam values
#define EPR_0					0		// Text flows left to right and top to bottom
#define EPR_270					1		// Text flows top to bottom and right to left
#define EPR_180					2		// Text flows right to left and bottom to top
#define	EPR_90					3		// Text flows bottom to top and left to right

// EM_SETCTFMODEBIAS wparam values
#define CTFMODEBIAS_DEFAULT					0x0000
#define CTFMODEBIAS_FILENAME				0x0001
#define CTFMODEBIAS_NAME					0x0002
#define CTFMODEBIAS_READING					0x0003
#define CTFMODEBIAS_DATETIME				0x0004
#define CTFMODEBIAS_CONVERSATION			0x0005
#define CTFMODEBIAS_NUMERIC					0x0006
#define CTFMODEBIAS_HIRAGANA				0x0007
#define CTFMODEBIAS_KATAKANA				0x0008
#define CTFMODEBIAS_HANGUL					0x0009
#define CTFMODEBIAS_HALFWIDTHKATAKANA		0x000A
#define CTFMODEBIAS_FULLWIDTHALPHANUMERIC	0x000B
#define CTFMODEBIAS_HALFWIDTHALPHANUMERIC	0x000C

// EM_SETIMEMODEBIAS lparam values
#define IMF_SMODE_PLAURALCLAUSE	0x0001
#define IMF_SMODE_NONE			0x0002

// EM_GETIMECOMPTEXT wparam structure
typedef struct _imecomptext {
	LONG	cb;			// count of bytes in the output buffer.
	DWORD	flags;		// value specifying the composition string type.
						//	Currently only support ICT_RESULTREADSTR
} IMECOMPTEXT;
#define ICT_RESULTREADSTR		1

// Outline mode wparam values
#define EMO_EXIT                0       // Enter normal mode,  lparam ignored
#define EMO_ENTER               1       // Enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        //  promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        //  promote/demote current selection
                                        //  by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        //  -> expands selection to level
                                        //  indicated in LOWORD(lparam)
                                        //  LOWORD(lparam) = -1/+1 corresponds
                                        //  to collapse/expand button presses
                                        //  in winword (other values are
                                        //  equivalent to having pressed these
                                        //  buttons more than once)
                                        //  HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        //  -> expands whole document to
                                        //  indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        //  selection up/down by indicated amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1

#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2
#define VM_PAGE					9		// Screen page view (not print layout)

// New notifications 
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			// PenWin specific 
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			// East Asia specific 
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d
#define EN_PAGECHANGE			0x070e
#define EN_LOWFIRTF				0x070f
#define EN_ALIGNLTR				0x0710			// BiDi specific notification
#define EN_ALIGNRTL				0x0711			// BiDi specific notification

// Event notification masks 
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020
#define ENM_PAGECHANGE			0x00000040
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		// PenWin specific 
#define ENM_IMECHANGE			0x00800000		// Used by RE1.0 compatibility
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000
#define ENM_LOWFIRTF			0x08000000


// New edit control styles 
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
// Same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value 
#define ES_SELECTIONBAR			0x01000000
// Same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop 
#define ES_NOOLEDRAGDROP		0x00000008

// New edit control extended style 
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		// Not supported in RE 2.0/3.0 
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

// These flags are used in FE Windows 
#define ES_VERTICAL				0x00400000		// Not supported in RE 2.0/3.0 
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

// Edit control options 
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		// FE specific 


// ECO operations 
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

// New word break function actions 
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

// East Asia specific flags 
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

// East Asia specific flags 
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

// Word break flags (used with WB_CLASSIFY) 
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


// Data types 

#ifdef _WIN32
// Extended edit word break proc (character set aware) 
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

// All character format measurements are in twips 
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif // UNICODE 
#else
#define CHARFORMAT CHARFORMATA
#endif // _RICHEDIT_VER >= 0x0200 

// CHARFORMAT2 structure 

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

#else	// regular C-style  

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
} CHARFORMAT2A;

#endif // C++ 

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


// CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor

// CHARFORMAT masks 
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020			// Exchange hyperlink extension 
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

// CHARFORMAT effects 
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000			// NOTE: this corresponds to 
											// CFM_COLOR, which controls it 
// Masks and effects defined for CHARFORMAT2 -- an (*) indicates
// that the data is stored by RichEdit 2.0/3.0, but not displayed
#define CFM_SMALLCAPS		0x0040			// (*)	
#define	CFM_ALLCAPS			0x0080			// Displayed by 3.0	
#define	CFM_HIDDEN			0x0100			// Hidden by 3.0 
#define	CFM_OUTLINE			0x0200			// (*)	
#define	CFM_SHADOW			0x0400			// (*)	
#define	CFM_EMBOSS			0x0800			// (*)	
#define	CFM_IMPRINT			0x1000			// (*)	
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		// Many displayed by 3.0 
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		// Displayed by 3.0	
#define CFM_KERNING			0x00100000		// (*)	
#define CFM_STYLE			0x00080000		// (*)	
#define CFM_ANIMATION		0x00040000		// (*)	
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		// Superscript and subscript are 
#define CFE_SUPERSCRIPT		0x00020000		//  mutually exclusive			 

#define CFM_SUBSCRIPT		(CFE_SUBSCRIPT | CFE_SUPERSCRIPT)
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

// CHARFORMAT "ALL" masks
#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

// CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
// CFM_BACKCOLOR, respectively, which control them
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

// Underline types. RE 1.0 displays only CFU_UNDERLINE
#define CFU_CF1UNDERLINE	0xFF	// Map charformat's bit underline to CF2
#define CFU_INVERT			0xFE	// For IME composition fake a selection
#define CFU_UNDERLINETHICKLONGDASH		18	// (*) display as dash
#define CFU_UNDERLINETHICKDOTTED		17	// (*) display as dot
#define CFU_UNDERLINETHICKDASHDOTDOT	16	// (*) display as dash dot dot
#define CFU_UNDERLINETHICKDASHDOT		15	// (*) display as dash dot
#define CFU_UNDERLINETHICKDASH			14	// (*) display as dash
#define CFU_UNDERLINELONGDASH			13	// (*) display as dash
#define CFU_UNDERLINEHEAVYWAVE			12	// (*) display as wave
#define CFU_UNDERLINEDOUBLEWAVE			11	// (*) display as wave
#define CFU_UNDERLINEHAIRLINE			10	// (*) display as single	
#define CFU_UNDERLINETHICK				9
#define CFU_UNDERLINEWAVE				8
#define	CFU_UNDERLINEDASHDOTDOT			7
#define	CFU_UNDERLINEDASHDOT			6
#define	CFU_UNDERLINEDASH				5
#define	CFU_UNDERLINEDOTTED				4
#define	CFU_UNDERLINEDOUBLE				3	// (*) display as single
#define CFU_UNDERLINEWORD				2	// (*) display as single	
#define CFU_UNDERLINE					1
#define CFU_UNDERLINENONE				0

#define yHeightCharPtsMost 1638

// EM_SETCHARFORMAT wParam masks 
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000	// Set default charformat or paraformat
#define SCF_ALL				0x0004	// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008	// Modifier for SCF_SELECTION; says that
									//  format came from a toolbar, etc., and
									//  hence UI formatting rules should be
									//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010	// Associate fontname with bCharSet (one
									//  possible for each of Western, ME, FE,
									//  Thai)
#define SCF_NOKBUPDATE		0x0020	// Do not update KB layput for this change
									//  even if autokeyboard is on
#define SCF_ASSOCIATEFONT2	0x0040	// Associate plane-2 (surrogate) font

typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif // UNICODE 
#else
#define TEXTRANGE	TEXTRANGEA
#endif // _RICHEDIT_VER >= 0x0200 

typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		// User value passed to callback as first parameter 
	DWORD	  dwError;		// Last error 
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;

// Stream formats. Flags are all in low word, since high word
// gives possible codepage choice. 
#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		// Write only 
#define SF_TEXTIZED		0x0004		// Write only 

#define SF_UNICODE		0x0010		// Unicode file (UCS2 little endian) 
#define SF_USECODEPAGE	0x0020		// CodePage given by high word 
#define SF_NCRFORNONASCII 0x40		// Output /uN for nonASCII 
#define	SFF_WRITEXTRAPAR  0x80		// Output \par at end

// Flag telling stream operations to operate on selection only 
// EM_STREAMIN  replaces current selection 
// EM_STREAMOUT streams out current selection 
#define SFF_SELECTION	0x8000

// Flag telling stream operations to ignore some FE control words 
// having to do with FE word breaking and horiz vs vertical text. 
// Not used in RichEdit 2.0 and later	
#define SFF_PLAINRTF	0x4000

// Flag telling file stream output (SFF_SELECTION flag not set) to persist 
// \viewscaleN control word. 
#define SFF_PERSISTVIEWSCALE 0x2000

// Flag telling file stream input with SFF_SELECTION flag not set not to 
// close the document 
#define SFF_KEEPDOCINFO	0x1000

// Flag telling stream operations to output in Pocket Word format 
#define SFF_PWD			0x0800

// 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN 
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif	// UNICODE 
#else
#define FINDTEXT	FINDTEXTA
#endif // _RICHEDIT_VER >= 0x0200 

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // UNICODE 
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // _RICHEDIT_VER >= 0x0200 


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

// All paragraph measurements are in twips 

#define MAX_TAB_STOPS 32
#define lDefaultTab 720
#define MAX_TABLE_CELLS 63

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			// Vertical spacing before para
	LONG	dySpaceAfter;			// Vertical spacing after para
	LONG	dyLineSpacing;			// Line spacing depending on Rule
	SHORT	sStyle;					// Style handle
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	bOutlineLevel;			// Outline level
	WORD	wShadingWeight;			// Shading in hundredths of a per cent
	WORD	wShadingStyle;			// Nibble 0: style, 1: cfpat, 2: cbpat
	WORD	wNumberingStart;		// Starting value for numbering
	WORD	wNumberingStyle;		// Alignment, roman/arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet FirstIndent & 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half pts)
	WORD	wBorders;				// Border styles (nibble/border)
};

#else	// Regular C-style	

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			// Vertical spacing before para			
	LONG	dySpaceAfter;			// Vertical spacing after para			
	LONG	dyLineSpacing;			// Line spacing depending on Rule		
	SHORT	sStyle;					// Style handle							
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)	
	BYTE	bOutlineLevel;			// Outline Level						
	WORD	wShadingWeight;			// Shading in hundredths of a per cent	
	WORD	wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	wNumberingStart;		// Starting value for numbering				
	WORD	wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)	
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	wBorders;				// Border styles (nibble/border)		
} PARAFORMAT2;

#endif // C++	


// PARAFORMAT mask values 
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

// PARAFORMAT 2.0 masks and effects 
#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	// (*)	
#define PFM_SHADING				0x00001000	// (*)	
#define PFM_NUMBERINGSTYLE		0x00002000	// RE 3.0	
#define PFM_NUMBERINGTAB		0x00004000	// RE 3.0	
#define PFM_NUMBERINGSTART		0x00008000	// RE 3.0	

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	// (*)	
#define PFM_KEEPNEXT			0x00040000	// (*)	
#define PFM_PAGEBREAKBEFORE		0x00080000	// (*)	
#define PFM_NOLINENUMBER		0x00100000	// (*)	
#define PFM_NOWIDOWCONTROL		0x00200000	// (*)	
#define PFM_DONOTHYPHEN			0x00400000	// (*)	
#define PFM_SIDEBYSIDE			0x00800000	// (*)	
#define PFM_TABLE				0x40000000	// RE 3.0 
#define PFM_TEXTWRAPPINGBREAK	0x20000000	// RE 3.0 
#define PFM_TABLEROWDELIMITER	0x10000000	// RE 4.0 

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	// RE 3.0 
#define PFM_OUTLINELEVEL		0x02000000	// RE 3.0 
#define PFM_BOX					0x04000000	// RE 3.0 
#define PFM_RESERVED2			0x08000000	// RE 4.0 


// PARAFORMAT "ALL" masks
#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

// Note: PARAFORMAT has no effects (BiDi RichEdit 1.0 does have PFE_RTLPARA)
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE | PFM_TABLEROWDELIMITER)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	// (*)	
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	// (*)	
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	// (*)	
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	// (*)	
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	// (*)	
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	// (*)	
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	// (*)	
#define PFE_TEXTWRAPPINGBREAK	(PFM_TEXTWRAPPINGBREAK>>16) // (*)	

// The following four effects are read only
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	// (+)	
#define PFE_BOX					(PFM_BOX			 >> 16)	// (+)	
#define PFE_TABLE				(PFM_TABLE			 >> 16)	// Inside table row. RE 3.0 
#define PFE_TABLEROWDELIMITER	(PFM_TABLEROWDELIMITER>>16)	// Table row start. RE 4.0 

// PARAFORMAT numbering options 
#define PFN_BULLET		1		// tomListBullet

// PARAFORMAT2 wNumbering options 
#define PFN_ARABIC		2		// tomListNumberAsArabic:   0, 1, 2,	...
#define PFN_LCLETTER	3		// tomListNumberAsLCLetter: a, b, c,	...
#define	PFN_UCLETTER	4		// tomListNumberAsUCLetter: A, B, C,	...
#define	PFN_LCROMAN		5		// tomListNumberAsLCRoman:  i, ii, iii,	...
#define	PFN_UCROMAN		6		// tomListNumberAsUCRoman:  I, II, III,	...

// PARAFORMAT2 wNumberingStyle options 
#define PFNS_PAREN		0x000	// default, e.g.,				  1)	
#define	PFNS_PARENS		0x100	// tomListParentheses/256, e.g., (1)	
#define PFNS_PERIOD		0x200	// tomListPeriod/256, e.g.,		  1.	
#define PFNS_PLAIN		0x300	// tomListPlain/256, e.g.,		  1		
#define PFNS_NONUMBER	0x400	// Used for continuation w/o number

#define PFNS_NEWNUMBER	0x8000	// Start new number with wNumberingStart		
								// (can be combined with other PFNS_xxx)
// PARAFORMAT alignment options 
#define PFA_LEFT			 1
#define PFA_RIGHT			 2
#define PFA_CENTER			 3

// PARAFORMAT2 alignment options 
#define	PFA_JUSTIFY			 4	// New paragraph-alignment option 2.0 (*) 
#define PFA_FULL_INTERWORD	 4	// These are supported in 3.0 with advanced
#define PFA_FULL_INTERLETTER 5	//  typography enabled
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8


// Notification structures 
#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  // !WM_NOTIFY 

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;


#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

// Used with IRichEditOleCallback::GetContextMenu, this flag will be
// passed as a "selection type".  It indicates that a context menu for
// a right-mouse drag drop should be generated.  The IOleObject parameter
// will really be the IDataObject for the drop
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

typedef struct _enlowfirtf
{
    NMHDR nmhdr;
	char *szControl;
} ENLOWFIRTF;

// PenWin specific 
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

// East Asia specific 
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

// East Asia specific 
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


// Clipboard formats - use as parameter to RegisterClipboardFormat() 
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

// Paste Special 
typedef struct _repastespecial
{
	DWORD		dwAspect;
	DWORD_PTR	dwParam;
} REPASTESPECIAL;

//	UndoName info 
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5,
	UID_AUTOCORRECT = 6
} UNDONAMEID;

// Flags for the SETEXTEX data structure 
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2
#define ST_NEWCHARS 	4

// EM_SETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _settextex
{
	DWORD	flags;			// Flags (see the ST_XXX defines)			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
} SETTEXTEX;

// Flags for the GETEXTEX data structure 
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2
#define GT_RAWTEXT		4
#define GT_NOHIDDENTEXT	8

// EM_GETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _gettextex
{
	DWORD	cb;				// Count of bytes in the string				
	DWORD	flags;			// Flags (see the GT_XXX defines			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
	LPCSTR	lpDefaultChar;	// Replacement for unmappable chars			
	LPBOOL	lpUsedDefChar;	// Pointer to flag set when def char used	
} GETTEXTEX;

// Flags for the GETTEXTLENGTHEX data structure							
#define GTL_DEFAULT		0	// Do default (return # of chars)		
#define GTL_USECRLF		1	// Compute answer using CRLFs for paragraphs
#define GTL_PRECISE		2	// Compute a precise answer					
#define GTL_CLOSE		4	// Fast computation of a "close" answer		
#define GTL_NUMCHARS	8	// Return number of characters			
#define GTL_NUMBYTES	16	// Return number of _bytes_				

// EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg 
typedef struct _gettextlengthex
{
	DWORD	flags;			// Flags (see GTL_XXX defines)				
	UINT	codepage;		// Code page for translation (CP_ACP for default,
							//  1200 for Unicode)							
} GETTEXTLENGTHEX;
	
// BiDi specific features 
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

// BIDIOPTIONS masks 
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOM_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOM_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOM_CONTEXTREADING		0x0008	// Context reading order 
#define BOM_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOM_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// BIDIOPTIONS effects 
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOE_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOE_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOE_CONTEXTREADING		0x0008	// Context reading order 
#define BOE_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOE_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// Additional EM_FINDTEXT[EX] flags 
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
// UNICODE embedding character 
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif // WCH_EMBEDDING 
		
// khyph - Kind of hyphenation
typedef enum tagKHYPH
{
	khyphNil,				// No Hyphenation
	khyphNormal,			// Normal Hyphenation
	khyphAddBefore,			// Add letter before hyphen
	khyphChangeBefore,		// Change letter before hyphen
	khyphDeleteBefore,		// Delete letter before hyphen
	khyphChangeAfter,		// Change letter after hyphen
	khyphDelAndChange		// Delete letter before hyphen and change
							//  letter preceding hyphen
} KHYPH;

typedef struct hyphresult
{
	KHYPH khyph;			// Kind of hyphenation
	long  ichHyph;			// Character which was hyphenated
	WCHAR chHyph;			// Depending on hyphenation type, character added, changed, etc.
} HYPHRESULT;

void WINAPI HyphenateProc(__in WCHAR *pszWord, LANGID langid, long ichExceed, HYPHRESULT *phyphresult);
typedef struct tagHyphenateInfo
{
	SHORT cbSize;			// Size of HYPHENATEINFO structure
	SHORT dxHyphenateZone;	// If a space character is closer to the margin
							//  than this value, don't hyphenate (in TWIPs)
	void (WINAPI* pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
} HYPHENATEINFO;

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  // __cplusplus 

#endif // !_RICHEDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RestartManager.h ===
////////////////////////////////////////////////////////////////////////
//
//  RestartManager.h --  Header for RestartManager API
//
//  Copyright (c) Microsoft Corp.  All rights reserverd.
//
////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Macros and Types

// RM_SESSION_KEY_LEN - size in bytes of binary session key
#define RM_SESSION_KEY_LEN  sizeof(GUID)
// CCH_RM_SESSION_KEY - character count of text-encoded session key
#define CCH_RM_SESSION_KEY  RM_SESSION_KEY_LEN*2
// CCH_RM_MAX_APP_NAME - maximum character count of application friendly name
#define CCH_RM_MAX_APP_NAME 255
// CCH_RM_MAX_SVC_NAME - maximum character count of service short name
#define CCH_RM_MAX_SVC_NAME 63
// Uninitialized value for TS Session ID
#define RM_INVALID_TS_SESSION -1
// Uninitialized value for Process ID
#define RM_INVALID_PROCESS -1

typedef enum _RM_APP_TYPE {
    RmUnknownApp = 0,   // Application type cannot be classified in
                        // known categories
    RmMainWindow = 1,   // Application is a windows application that
                        // displays a top-level window
    RmOtherWindow = 2,  // Application is a windows app but does not
                        // display a top-level window
    RmService = 3,      // Application is an NT service
    RmExplorer = 4,     // Application is Explorer
    RmConsole = 5,      // Application is Console application
    RmCritical = 1000   // Application is critical system process
                        // where a reboot is required to restart
} RM_APP_TYPE;

typedef enum _RM_SHUTDOWN_TYPE {
    RmForceShutdown = 0x1,          // Force app shutdown
    RmShutdownOnlyRegistered = 0x10 // Only shudown apps if all apps
                                    // registered for restart
} RM_SHUTDOWN_TYPE;

typedef enum _RM_APP_STATUS {
    RmStatusUnknown = 0x0,          // Application in unknown state 
                                    // or state not important
    RmStatusRunning = 0x1,          // Application is currently running
    RmStatusStopped = 0x2,          // Application stopped by Restart Manager
    RmStatusStoppedOther = 0x4,     // Application detected stopped 
                                    // by outside action
    RmStatusRestarted = 0x8,        // Application restarted by Restart Manager
    RmStatusErrorOnStop = 0x10,     // An error occurred when stopping
                                    // this application
    RmStatusErrorOnRestart = 0x20,  // An error occurred when restarting
                                    // this application
    RmStatusShutdownMasked = 0x40,  // Shutdown action masked by filer
    RmStatusRestartMasked = 0x80    // Restart action masked by filter
} RM_APP_STATUS;

typedef enum _RM_REBOOT_REASON {
    RmRebootReasonNone = 0x0,               // Reboot not required
    RmRebootReasonPermissionDenied = 0x1,   // Current user does not have
                                            // permission to shut down
                                            // one or more detected processes
    RmRebootReasonSessionMismatch = 0x2,    // One or more processes are
                                            // running in another TS session.
    RmRebootReasonCriticalProcess = 0x4,    // A critical process has been
                                            // detected
    RmRebootReasonCriticalService = 0x8,    // A critical service has been
                                            // detected
    RmRebootReasonDetectedSelf = 0x10       // The current process has been
                                            // detected
} RM_REBOOT_REASON;

typedef struct _RM_UNIQUE_PROCESS {
    DWORD dwProcessId;              // PID
    FILETIME ProcessStartTime;      // Process creation time
} RM_UNIQUE_PROCESS, *PRM_UNIQUE_PROCESS;

typedef struct _RM_PROCESS_INFO{
    RM_UNIQUE_PROCESS Process;      // Unique process identification
    WCHAR strAppName[CCH_RM_MAX_APP_NAME+1];    // Application friendly name
    WCHAR strServiceShortName[CCH_RM_MAX_SVC_NAME+1];   // Service short name,
                                                        // if applicable
    RM_APP_TYPE ApplicationType;    // Application type
    ULONG AppStatus;                // Bit mask of application status
    DWORD TSSessionId;              // Terminal Service session ID of 
                                    // process (-1 if n/a)
    BOOL bRestartable;              // Is application restartable?
} RM_PROCESS_INFO, *PRM_PROCESS_INFO;

typedef enum _RM_FILTER_TRIGGER
{
    RmFilterTriggerInvalid = 0,         // Invalid value
    RmFilterTriggerFile,                // Filter is triggered by EXE name
    RmFilterTriggerProcess,             // Filter is triggered by PID/create time
    RmFilterTriggerService              // Filter is triggered by service short name
} RM_FILTER_TRIGGER;

typedef enum _RM_FILTER_ACTION {
    RmInvalidFilterAction = 0,          // Invalid value
    RmNoRestart = 1,                    // Prevent restart of application
    RmNoShutdown = 2                    // Prevent shutdown and restart of
                                        // application
} RM_FILTER_ACTION;

typedef struct _RM_FILTER_INFO
{
    RM_FILTER_ACTION FilterAction;      // Filter action
    RM_FILTER_TRIGGER FilterTrigger;    // Filter trigger
    DWORD cbNextOffset;                 // Bytes to next structure
    union
    {
        LPWSTR strFilename;             // When RmFilterTrigger == RmFilterTriggerFile,
                                        // this contains the filename this filter applies to
        RM_UNIQUE_PROCESS Process;      // When RmFilterTrigger == RmFilterTriggerProcess,
                                        // this contains the process this filter applies to
        LPWSTR strServiceShortName;     // When RmFilterTrigger == RmFilterTriggerService,
                                        // this contians the service name this filter applies to
    };
} RM_FILTER_INFO, *PRM_FILTER_INFO;

typedef void (*RM_WRITE_STATUS_CALLBACK)( __in UINT nPercentComplete );

// Functions

// Function: RmStartSession
// Purpose: Begins a Restart Manager session as the Conductor
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
DWORD WINAPI
RmStartSession(
    __out DWORD *pSessionHandle,
    __reserved DWORD dwSessionFlags,
    __out_ecount(CCH_RM_SESSION_KEY+1) WCHAR strSessionKey[]);

// Function: RmJoinSession
// Purpose: Joins an existing Restart Manager session as a Subordinate
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
DWORD WINAPI
RmJoinSession(
    __out DWORD *pSessionHandle,
    __in_ecount(CCH_RM_SESSION_KEY+1) const WCHAR strSessionKey[]);

// Function: RmEndSession
// Purpose: Terminates and cleans up an existing session.
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmEndSession( __in DWORD dwSessionHandle );

// Function: RmRegisterResources
// Purpose: Called if error is encountered. Installer
//          must pass in all files to be updated 
//          that may prevent the install from completing. Processes
//          passed in array are forced to stop/start. Services short
//          names passed in array are stopped (along with dependencies
//          and restarted.
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRegisterResources(
    __in DWORD dwSessionHandle,
    __in UINT nFiles,
    __in_ecount_opt(nFiles) LPCWSTR rgsFileNames[],
    __in UINT nApplications,
    __in_ecount_opt(nApplications) RM_UNIQUE_PROCESS rgApplications[],
    __in UINT nServices,
    __in_ecount_opt(nServices) LPCWSTR rgsServiceNames[]);

// Function: RmGetList
// Purpose: Gets the list of applications affected by registered
//          resources and their current status.
// Returns: An array of RM_PROCESS_INFO structs containing a list of
//          all applications affected by registered items, the number
//          of structs needed to retreive all application information,
//          the number of structs that were populated, and a series
//          of flags describing why a reboot will be necessary.
// Error Codes:
//        ERROR_MORE_DATA
//            Buffer is not large enough for all information.
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmGetList(
    __in DWORD dwSessionHandle,
    __out UINT *pnProcInfoNeeded,
    __inout UINT *pnProcInfo,
    __inout_ecount_opt(*pnProcInfo) RM_PROCESS_INFO rgAffectedApps[],
    __out LPDWORD lpdwRebootReasons );

// Function: RmShutdown
// Purpose: Initiates application shutdown sequence.
// Error Codes:
//        ERROR_FAIL_NOACTION_REBOOT
//            One or more of the affected applications requires a reboot
//            to be shut down.
//        ERROR_FAIL_SHUTDOWN
//            There was an error shuting down some application(s).
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmShutdown(
    __in DWORD dwSessionHandle,
    __in ULONG lActionFlags,
    __in_opt RM_WRITE_STATUS_CALLBACK fnStatus);

// Function: RmRestart
// Purpose: Applications automatically shutdown by RmShutdown() 
//          and are registered for restart or are services are restarted.
// Error Codes:
//        ERROR_FAIL_NOACTION_REBOOT
//            One or more of the affected applications requires a reboot
//            to be shut down.
//        ERROR_FAIL_SHUTDOWN
//            There was an error shuting down some application(s).
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRestart(
        __in DWORD dwSessionHandle,
        __reserved DWORD dwRestartFlags,
        __in_opt RM_WRITE_STATUS_CALLBACK fnStatus);

// Function: RmCancelCurrentTask()
// Purpose: Notifies Restart Manager to cancel the task it is performing
//          as soon as possible.
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmCancelCurrentTask(
        __in DWORD dwSessionHandle);

// Function: RmAddFilter()
// Purpose: Adds a filter for process module (ie. executable name), process ID,
//          or service short name to prevent Restart Manager from performing
//          the specified action on the process(es) or service noted. 
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmAddFilter(
        __in DWORD dwSessionHandle,
        __in_opt LPCWSTR strModuleName,
        __in_opt RM_UNIQUE_PROCESS *pProcess,
        __in_opt LPCWSTR strServiceShortName,
        __in RM_FILTER_ACTION FilterAction );

// Function: RmRemoveFilter()
// Purpose: Removes a previously added filter for process module
//          (ie. executable name), process ID, or service short name
//          enabling all Restart Manager actions on the process(es)
//          or service noted. 
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRemoveFilter(
        __in DWORD dwSessionHandle,
        __in_opt LPCWSTR strModuleName,
        __in_opt RM_UNIQUE_PROCESS *pProcess,
        __in_opt LPCWSTR strServiceShortName );

// Function: RmGetFilterList()
// Purpose: Writes a set of currenly applied filters
//          to a caller-allocated buffer.
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmGetFilterList(
        __in DWORD dwSessionHandle,
        __out_bcount_opt(cbFilterBuf) PBYTE pbFilterBuf,
        __in DWORD cbFilterBuf,
        __out LPDWORD cbFilterBufNeeded );

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcDce.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

#include <specstrings.h>

typedef __nullterminated unsigned char __RPC_FAR * RPC_CSTR;

#if defined(RPC_USE_NATIVE_WCHAR) && defined(_NATIVE_WCHAR_T_DEFINED)
typedef __nullterminated wchar_t __RPC_FAR * RPC_WSTR;
typedef __nullterminated const wchar_t * RPC_CWSTR;
#else
typedef __nullterminated unsigned short __RPC_FAR * RPC_WSTR;
typedef __nullterminated const unsigned short * RPC_CWSTR;
#endif

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                 0x4
#define RPC_C_RPCHTTP_USE_LOAD_BALANCE  0x8

#if (NTDDI_VERSION < NTDDI_VISTA)
// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport (deprecated for Vista)
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Falcon/Rpc options are deprecated from Vista
#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// Client: RpcBindingSetOption() values for the Falcon/RPC transport (some are deprecated from Vista)

#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#endif // (NTDDI_VERSION < NTDDI_VISTA)

#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11

#if (NTDDI_VERSION <= NTDDI_WIN2K)
#define RPC_C_OPT_MAX_OPTIONS            12

#elif (NTDDI_VERSION <= NTDDI_WS03)
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_MAX_OPTIONS            14

#else
#define RPC_C_OPT_TRANS_SEND_BUFFER_SIZE 5
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_TRUST_PEER             14
#define RPC_C_OPT_ASYNC_BLOCK            15
#define RPC_C_OPT_OPTIMIZE_TIME          16
#define RPC_C_OPT_MAX_OPTIONS            17

#endif // (NTDDI_VERSION <= NTDDI_WIN2K)

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    __in UUID __RPC_FAR * ObjectUuid,
    __out UUID __RPC_FAR * TypeUuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

__success(return == 0) /*RPC_S_OK*/
typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    __in RPC_IF_HANDLE  InterfaceUuid,
    __in void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    __in void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    __in RPC_BINDING_HANDLE SourceBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    __inout RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption ( 
    __in RPC_BINDING_HANDLE hBinding,
    __in unsigned long      option,
    __in ULONG_PTR          optionValue 
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption (
    __in  RPC_BINDING_HANDLE hBinding,
    __in  unsigned long      option,
    __out ULONG_PTR         *pOptionValue 
    );

/* client */

#if !defined(_KRPCENV_)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (    
    __in RPC_CSTR StringBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    __in RPC_WSTR StringBinding,        
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    __in RPC_CSTR StringBinding    
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_ */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    __in void *ContextHandle,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    __in RPC_BINDING_HANDLE Binding,
    __out UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    __in RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    __in RPC_BINDING_HANDLE Binding,
    __in UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel (
    __in  unsigned long AuthnSvc,
    __in unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    __deref_inout RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#if !defined(_KRPCENV_)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    __in_opt RPC_WSTR ObjUuid,
    __in_opt RPC_WSTR ProtSeq,    
    __in_opt RPC_WSTR NetworkAddr,
    __in_opt RPC_WSTR Endpoint,
    __in_opt RPC_WSTR Options,
    __deref_opt_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    __in RPC_WSTR StringBinding,    
    __deref_opt_out RPC_WSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_WSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkOptions
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_ */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    __inout RPC_CSTR __RPC_FAR * String    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    __inout RPC_WSTR __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    __deref_inout RPC_CSTR __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    __in RPC_IF_HANDLE RpcIfHandle,
    __out RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    __in RPC_CSTR Protseq     
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    __in RPC_WSTR Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    __in RPC_CSTR Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    __in long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    __deref_out RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    __deref_out RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    __deref_out RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    __in UUID __RPC_FAR * ObjUuid,
    __out_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    __in RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    __in UUID __RPC_FAR * ObjUuid,
    __in_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    __deref_inout RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    __deref_inout RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    __deref_inout RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    __deref_out RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __deref_out RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    __in unsigned int MinimumCallThreads,
    __in unsigned int MaxCalls,
    __in unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in_opt RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID * MgrTypeUuid,
    __in_opt RPC_MGR_EPV * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in unsigned int MaxRpcSize,
    __in_opt RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in unsigned int WaitForCallsToComplete
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIfEx (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in int RundownContextHandles
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    __inout RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    __in unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    __deref_inout RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_WSTR __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT                        0x0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH                    0x1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC                   0x2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY                  0x4

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE        0x8
#define RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT                 0x10
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_C_QOS_CAPABILITIES_SCHANNEL_FULL_AUTH_IDENTITY   0x20
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_DPA          17
#define RPC_C_AUTHN_MSN          18
#if (NTDDI_VERSION >= WINXP)
#define RPC_C_AUTHN_DIGEST       21
#endif // (NTDDI_VERSION >= WINXP)
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_C_AUTHN_KERNEL         20
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#define RPC_C_AUTHN_NEGO_EXTENDER 30
#define RPC_C_AUTHN_PKU2U         31

#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) MAXUINT_PTR)

#define RPC_C_SECURITY_QOS_VERSION      1L
#define RPC_C_SECURITY_QOS_VERSION_1    1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  __field_bcount((UserLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  __field_bcount((DomainLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_bcount((PasswordLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define _AUTH_IDENTITY_A_DEFINED
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  __field_ecount(UserLength+1) unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  __field_ecount(DomainLength+1) unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_ecount(PasswordLength+1) unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define RPC_C_SECURITY_QOS_VERSION_2 2L

#define RPC_C_AUTHN_INFO_TYPE_HTTP                  1

#define RPC_C_HTTP_AUTHN_TARGET_SERVER              1
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_C_HTTP_AUTHN_TARGET_PROXY               2
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001
#define RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002
#define RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004
#define RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008
#define RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010
#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_HTTP_AUTHN_SCHEME_CERT       0x00010000
// 0x00020000 & 0x00040000 are reserved
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#define RPC_C_HTTP_FLAG_USE_SSL                     1
#define RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME       2
#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_HTTP_FLAG_IGNORE_CERT_CN_INVALID      8
#endif // (NTDDI_VERSION >= NTDDI_WS03)
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
#define RPC_C_HTTP_FLAG_ENABLE_CERT_REVOCATION_CHECK 16
#endif // (NTDDI_VERSION >= NTDDI_VISTASP1)


typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_W *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_A *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
{
    RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
    RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
{
    RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
    RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _RPC_SECURITY_QOS_V2_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;

typedef struct _RPC_SECURITY_QOS_V2_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_SECURITY_QOS_VERSION_3 3L

typedef struct _RPC_SECURITY_QOS_V3_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;

typedef struct _RPC_SECURITY_QOS_V3_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_SECURITY_QOS_VERSION_4 4L

typedef struct _RPC_SECURITY_QOS_V4_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_W, *PRPC_SECURITY_QOS_V4_W;

typedef struct _RPC_SECURITY_QOS_V4_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_A, *PRPC_SECURITY_QOS_V4_A;

#endif // NTDDI_WINXP
#endif // _AUTH_IDENTITY_DEFINED 
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= WINXP)

#ifdef UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_W
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_W
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_W

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_W

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V3 RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V3 PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V3 _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_W
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_W
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_W
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_W
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_W
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#else // UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_A
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_A
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_A

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_A

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V3 RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V3 PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V3 _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_A
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_A
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_A
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_A
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_A
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_PROTSEQ_TCP                             (0x1)
#define RPC_PROTSEQ_NMP                             (0x2)
#define RPC_PROTSEQ_LRPC                            (0x3)
#define RPC_PROTSEQ_HTTP                            (0x4)

#define RPC_BHT_OBJECT_UUID_VALID                   (0x1)

#define RPC_BHO_NONCAUSAL                           (0x1)
#define RPC_BHO_DONTLINGER                          (0x2)
#define RPC_BHO_EXCLUSIVE_AND_GUARANTEED            (0x4)

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned short *NetworkAddress;
    unsigned short *StringEndpoint;
    union
    {
        unsigned short *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_W, *PRPC_BINDING_HANDLE_TEMPLATE_V1_W;

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned char *NetworkAddress;
    unsigned char *StringEndpoint;
    union
    {
        unsigned char *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_A, *PRPC_BINDING_HANDLE_TEMPLATE_V1_A;

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_W {
    unsigned long Version;
    unsigned short *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_W, *PRPC_BINDING_HANDLE_SECURITY_V1_W;

#ifdef _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_A {
    unsigned long Version;
    unsigned char *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_A *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_A, *PRPC_BINDING_HANDLE_SECURITY_V1_A;

#endif // _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_OPTIONS_V1 {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ComTimeout;
    unsigned long CallTimeout;
} RPC_BINDING_HANDLE_OPTIONS_V1, *PRPC_BINDING_HANDLE_OPTIONS_V1;

#ifdef UNICODE

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_W
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_W
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_W

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_W
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_W
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_W

#else

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_A
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_A
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_A

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_A
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_A
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_A

#endif // !UNICODE

#ifdef _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateA (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_A * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_A * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#endif // _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateW (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_W * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_W * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#ifdef UNICODE
#define RpcBindingCreate RpcBindingCreateW
#else /* UNICODE */
#define RpcBindingCreate RpcBindingCreateA
#endif /* UNICODE */

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingGetTrainingContextHandle (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out void ** ContextHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerInqBindingHandle (
    __out RPC_BINDING_HANDLE * Binding
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef enum _RPC_HTTP_REDIRECTOR_STAGE
{
    RPCHTTP_RS_REDIRECT = 1,
    RPCHTTP_RS_ACCESS_1,
    RPCHTTP_RS_SESSION,
    RPCHTTP_RS_ACCESS_2,
    RPCHTTP_RS_INTERFACE
} RPC_HTTP_REDIRECTOR_STAGE;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    __in RPC_HTTP_REDIRECTOR_STAGE RedirectorStage,
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServerPort,
    __in_opt RPC_WSTR RemoteUser,
    __in_opt RPC_WSTR AuthType,
    __inout void __RPC_FAR * ResourceUuid,
    __inout void __RPC_FAR * SessionId,
    __in_opt void __RPC_FAR * Interface,
    __in_opt void __RPC_FAR * Reserved,
    __in unsigned long Flags,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerName,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerPort
    );
    
#else

typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    __in unsigned short __RPC_FAR *ServerName,
    __in unsigned short __RPC_FAR *ServerPort,
    __in unsigned char __RPC_FAR *RemoteUser,
    __out unsigned short __RPC_FAR **NewServerName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

typedef void
(__RPC_USER * RPC_HTTP_PROXY_FREE_STRING) (
    __in RPC_WSTR String
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) 

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    void
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQos
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in_opt unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in_opt  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS * SecurityQOS
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in RPC_WSTR ServerPrincName,
    __in unsigned long KeyVer,
    __deref_out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY 
RpcServerCompleteSecurityCallback(
    __in RPC_BINDING_HANDLE BindingHandle,
    __in RPC_STATUS Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoA (
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoW (
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExW
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExA
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientEx (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in unsigned char __RPC_FAR * ServerPrincName,
    __in unsigned long KeyVer,
    __out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfo (
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt OPTIONAL void __RPC_FAR * Arg
    );

#endif /* RPC_UNICODE_SUPPORTED */

#if (NTDDI_VERSION >= NTDDI_WINXP)
#if !defined(_M_IA64)
typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;
#endif 
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingServerFromClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

RPCRTAPI
DECLSPEC_NORETURN
void
RPC_ENTRY
RpcRaiseException (
    __in RPC_STATUS exception
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcTestCancel(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerTestCancel (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThread(
    __in void * Thread
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThreadEx(
    __in void * Thread,
    __in long Timeout
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreate (
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateSequential (
    __out UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringA (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringW (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_WSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringW (
    __in_opt RPC_WSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToString (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromString (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
signed int
RPC_ENTRY
UuidCompare (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateNil (
    __out UUID __RPC_FAR * NilUuid
    );

RPCRTAPI
int
RPC_ENTRY
UuidEqual (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
unsigned short
RPC_ENTRY
UuidHash (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
int
RPC_ENTRY
UuidIsNil (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplace (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegister (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpUnregister(
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector
    );

#define DCE_C_ERROR_STRING_LEN 256

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextA (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextW (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_WSTR ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqText (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqBegin (
    __in OPTIONAL RPC_BINDING_HANDLE EpBinding,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR * IfId,
    __in_opt unsigned long VersOption,
    __in_opt UUID __RPC_FAR * ObjectUuid,
    __out RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqDone (
    __inout RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextA (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextW (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Annotation
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNext (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpUnregister (
    __in_opt RPC_BINDING_HANDLE EpBinding,
    __in RPC_IF_ID __RPC_FAR * IfId,
    __in RPC_BINDING_HANDLE Binding,
    __in_opt UUID __RPC_FAR * ObjectUuid
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    __in RPC_BINDING_HANDLE ClientBinding,
    __in unsigned long RequestedMgmtOperation,
    __out RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    __in RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
RPCRTAPI
int
RPC_ENTRY
RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

#define RPC_IF_AUTOLISTEN                   0x0001
#define RPC_IF_OLE                          0x0002
#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY      0x0004
#define RPC_IF_ALLOW_SECURE_ONLY            0x0008
#define RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH 0x0010
#define RPC_IF_ALLOW_LOCAL_ONLY             0x0020
#define RPC_IF_SEC_NO_CACHE                 0x0040
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_IF_SEC_CACHE_PER_PROC           0x0080
#define RPC_IF_ASYNC_CALLBACK               0x0100
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_FW_IF_FLAG_DCOM                 0x0001
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcDceP.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS
RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE
};

typedef void
RPC_ENTRY RPC_ADDRESS_CHANGE_FN(
                        IN void * arg
                        );

/*
*  New context handle flavors.
*/
#define RPC_CONTEXT_HANDLE_DEFAULT_GUARD    ((void *)(ULONG_PTR)0xFFFFF00D)

#define RPC_CONTEXT_HANDLE_DEFAULT_FLAGS    0x00000000UL
#define RPC_CONTEXT_HANDLE_FLAGS            0x30000000UL
#define RPC_CONTEXT_HANDLE_SERIALIZE        0x10000000UL
#define RPC_CONTEXT_HANDLE_DONT_SERIALIZE   0x20000000UL
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_TYPE_STRICT_CONTEXT_HANDLE      0x40000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPCFLG_HAS_GUARANTEE        0x00000010UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */
#define RPC_BUFFER_ASYNC            0x00008000 /* used by async rpc */
#define RPC_BUFFER_NONOTIFY         0x00010000 /* used by async pipes */


#define RPCFLG_MESSAGE              0x01000000UL
#define RPCFLG_AUTO_COMPLETE        0x08000000UL
#define RPCFLG_LOCAL_CALL           0x10000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_NON_NDR              0x80000000UL

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define RPCFLG_HAS_MULTI_SYNTAXES   0x02000000UL
#define RPCFLG_HAS_CALLBACK         0x04000000UL
#endif // (NTDDI_VERSION >= NTDDI_WXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
// These two bits will hold the combination of 
// anonymous/admin/authenticate/mixed mode
#define RPCFLG_ACCESSIBILITY_BIT1   0x00100000UL
#define RPCFLG_ACCESSIBILITY_BIT2   0x00200000UL
#define RPCFLG_ACCESS_LOCAL         0x00400000UL

// This goes to MIDL_STUB_DESC only
#define NDR_CUSTOM_OR_DEFAULT_ALLOCATOR 0x10000000UL
#define NDR_DEFAULT_ALLOCATOR           0x20000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_FLAGS_VALID_BIT 0x00008000

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    LONG_PTR                          Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER   InterfaceId;
    RPC_SYNTAX_IDENTIFIER   TransferSyntax;
    PRPC_DISPATCH_TABLE     DispatchTable;
    unsigned int            RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT   RpcProtseqEndpoint;
    ULONG_PTR               Reserved;
    void const __RPC_FAR *  InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

#if (NTDDI_VERSION >= NTDDI_WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN UUID * ObjectUuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReallocPipeBuffer (
    __in PRPC_MESSAGE Message,
    __in_bound unsigned int NewSize
    );

typedef void * I_RPC_MUTEX;

RPCRTAPI
void
RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetExtendedError (
    void
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetAssociationContext (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPCRTAPI
void *
RPC_ENTRY
I_RpcGetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void * ServerContextList
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short **StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContextKeyInfo (
    __in_opt RPC_BINDING_HANDLE Binding,
    __inout void *KeyInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    __in RPC_BINDING_HANDLE Binding,
    __out RPC_CSTR WireId
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqMarshalledTargetInfo (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned long * MarshalledTargetInfoSize,
    __deref_out_bcount(* MarshalledTargetInfoSize) RPC_CSTR * MarshalledTargetInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    );
#endif // (NTDDI_VERSION >= WINXP)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );


#ifdef UNICODE
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameW
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2W
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2W
#else
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameA
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2A
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2A
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in void __RPC_FAR *SecurityDescriptor,
    __in void *Policy
    );
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartService (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint,
    __in RPC_IF_HANDLE IfSpec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_WSTR __RPC_FAR *DynamicEndpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#ifdef UNICODE
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointW
#else
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointA
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerCheckClientRestriction (
    IN RPC_BINDING_HANDLE Context
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define TRANSPORT_TYPE_CN        0x01
#define TRANSPORT_TYPE_DG        0x02
#define TRANSPORT_TYPE_LPC       0x04
#define TRANSPORT_TYPE_WMSG      0x08

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN OPTIONAL RPC_BINDING_HANDLE BindingHandle,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT int *pfFirstCall
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCreateNP (
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServiceName,
    __in RPC_WSTR NetworkOptions,
    __out RPC_BINDING_HANDLE *Binding
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION  * pForwardFunction
    );

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    );

#if (NTDDI_VERSION >= WINXP)
/* The return buffer will contain SOCKADDR_IN for IPv4 */
#define RPC_P_ADDR_FORMAT_TCP_IPV4      1

/* The return buffer will contain SOCKADDR_STORAGE for IPv6 */
#define RPC_P_ADDR_FORMAT_TCP_IPV6      2

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqLocalConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqRemoteConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSessionStrictContextHandle (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcTurnOnEEInfoPropagation (
    void
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );

typedef
void
(*RPCLT_PDU_FILTER_FUNC) (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN int fDatagram
    );

typedef
void
(__cdecl *RPC_SETFILTER_FUNC) (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    );

#ifndef WINNT
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartListening(
    void * hWnd
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStopListening(
    void
    );

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void * hWnd,
    IN void * Context,
    IN OPTIONAL void * hSyncEvent
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn,
    IN unsigned long ServerTid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSetThreadParams(
    IN int fClientFree,
    IN OPTIONAL void *Context,
    IN OPTIONAL void * hWndClient
    );

RPCRTAPI
unsigned int
RPC_ENTRY
I_RpcWindowProc(
    IN void * hWnd,
    IN unsigned int Message,
    IN unsigned int wParam,
    IN unsigned long lParam
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    __in RPC_CSTR Protseq,
    __in RPC_CSTR Endpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif
#endif // WINNT

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#if (NTDDI_VERSION >= NTDDI_WS03)

#define RPC_C_OPT_SESSION_ID                (6)
#define RPC_C_OPT_COOKIE_AUTH                  (7)
#define RPC_C_OPT_RESOURCE_TYPE_UUID        (8)

typedef struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR
{
    unsigned long BufferSize;   // Length of the buffer in bytes
    __field_bcount(BufferSize) char *Buffer;               // Zero-terminated string
} RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;

typedef struct _RDR_CALLOUT_STATE
{
    // LastError is used for debugging only - don't use it for processing
    RPC_STATUS LastError;
    void *LastEEInfo;

    RPC_HTTP_REDIRECTOR_STAGE LastCalledStage;

    // the information accumulated throughout the stages
    unsigned short *ServerName;   // Allocated with MemAllocate
    unsigned short *ServerPort;   // Allocated with MemAllocate
    unsigned short *RemoteUser;   // Allocated with MemAllocate
    unsigned short *AuthType;     // Allocated with MemAllocate
    unsigned char ResourceTypePresent;
    unsigned char SessionIdPresent;
    unsigned char InterfacePresent;
    UUID ResourceType;
    UUID SessionId;
    RPC_SYNTAX_IDENTIFIER Interface;
    void *CertContext;            // Contains PCCERT_CONTEXT if cert is used for authentication. 
                                  // NULL otherwise. If allocated, CertFreeCertificateContext 
                                  // needs to be called on it when done
} RDR_CALLOUT_STATE;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyIsValidMachineFn)
        (
        __in RPC_WSTR Machine,
        __in RPC_WSTR DotMachine,
        __in unsigned long PortNumber        
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientAddressFn)
        (
        IN void *Context,
        OUT char *Buffer,
        OUT unsigned long *BufferLength
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetConnectionTimeoutFn)
        (
        OUT unsigned long *ConnectionTimeout
        );

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcPerformCalloutFn) 
    (
    IN void *Context,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN RPC_HTTP_REDIRECTOR_STAGE Stage
    );

typedef void
(RPC_ENTRY *I_RpcFreeCalloutStateFn)
    (
    IN RDR_CALLOUT_STATE *CallOutState
    );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientSessionAndResourceUUID)
        (
        __in void *Context,
        __out_opt int *SessionIdPresent,
        __out_opt UUID *SessionId,
        __out int *ResourceIdPresent,
        __out UUID *ResourceId
        );

#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyFilterIfFn) 
    (
    __in void *Context,
    __in UUID *IfUuid,
    __in unsigned short IfMajorVersion,
    __out int *fAllow
    );

typedef enum RpcProxyPerfCounters
{
    RpcCurrentUniqueUser = 1,    //Current Number of Unique Users
    RpcBackEndConnectionAttempts, // Number of Back-End Connection Attempts per Second
    RpcBackEndConnectionFailed, // Number of Failed Back-End Connection Attempts per Second
    RpcRequestsPerSecond, //RPC/HTTP Requests per Second
    RpcIncomingConnections, //Current Number of Incoming RPC over HTTP Connections
    RpcIncomingBandwidth, // Total Incoming Bandwidth from Back-End Servers
    RpcOutgoingBandwidth, // Total Outgoing Bandwidth to Back-End Servers
    RpcAttemptedLbsDecisions, // Attempted RPC Load Balancing Decisions per Second
    RpcFailedLbsDecisions, // Failed RPC Load Balancing Decisions per Second
    RpcAttemptedLbsMessages, //Attempted RPC Load Balancing Broker Requests per Second
    RpcFailedLbsMessages, // Failed RPC Load Balancing Broker Requests per Second
    RpcLastCounter 
} RpcPerfCounters;

typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterFn)
    (
    __in RpcPerfCounters Counter,
    __in int ModifyTrend,
    __in unsigned long Size
    );

 typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterBackendServerFn)
    (
    __in unsigned short* MachineName,
    __in int IsConnectEvent
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_PROXY_CONNECTION_TYPE_IN_PROXY    0
#define RPC_PROXY_CONNECTION_TYPE_OUT_PROXY   1

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
    I_RpcPerformCalloutFn PerformCalloutFn;
    I_RpcFreeCalloutStateFn FreeCalloutStateFn;
    I_RpcProxyGetClientSessionAndResourceUUID GetClientSessionAndResourceUUIDFn;
#if (NTDDI_VERSION >= NTDDI_VISTA)
    I_RpcProxyFilterIfFn ProxyFilterIfFn;
    I_RpcProxyUpdatePerfCounterFn RpcProxyUpdatePerfCounterFn;
    I_RpcProxyUpdatePerfCounterBackendServerFn RpcProxyUpdatePerfCounterBackendServerFn;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN unsigned short *MinConnTimeout,
    IN void *ConnectionParameter,
    IN OPTIONAL RDR_CALLOUT_STATE *CallOutState, 
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
    
#else

typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)
        
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_WS03)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReplyToClientWithStatus (
    IN void *ConnectionParameter,
    IN RPC_STATUS RpcStatus
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcRecordCalloutFailure (
    IN RPC_STATUS RpcStatus,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN unsigned short *DllName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WIN7)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMgmtEnableDedicatedThreadPool (
    );
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcAsync.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_KRPCENV_)

#include <ntddk.h>

#endif // _KRPCENV_

#if defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_)

// We've gotta have windef.h--can't live without it.

#include <windef.h>

#endif // RPC_NO_WINDOWS_H || _KRPCENV_


#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
#if !defined(_KRPCENV_)
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
#endif
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect,
    RpcClientCancel
    } RPC_ASYNC_EVENT;
    
#else // (NTDDI_VERSION >= NTDDI_VISTA)

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect
    } RPC_ASYNC_EVENT;    
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

struct _RPC_ASYNC_STATE;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;

typedef union _RPC_ASYNC_NOTIFICATION_INFO {
#if !defined(_KRPCENV_)
    //
    // Notification by APC
    //
    struct {
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        HANDLE hThread;
        } APC;


#if !defined(RPC_NO_WINDOWS_H) || defined (_WINBASE_)

    //
    // Notification by IO completion port
    //
    struct {
        HANDLE hIOPort;
        DWORD dwNumberOfBytesTransferred;
        DWORD_PTR dwCompletionKey;
        LPOVERLAPPED lpOverlapped;
        } IOC;

#endif // !RPC_NO_WINDOWS_H || _WINBASE_
#if !defined(RPC_NO_WINDOWS_H)
    //
    // Notification by window message
    //
    struct {
        HWND hWnd;
        UINT Msg;
        } HWND;

#endif // RPC_NO_WINDOWS_H
#endif // _KRPCENV_


    #if !defined(_KRPCENV_)
    //
    // Notification by event
    //
    HANDLE hEvent;
    #else   // _KRPCENV_
    //
    // Notification by event
    //
    PKEVENT Event;
    #endif  // _KRPCENV_

    //
    // Notification by callback function
    //
    // This option is available only to OLE
    //
    PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
} RPC_ASYNC_NOTIFICATION_INFO, *PRPC_ASYNC_NOTIFICATION_INFO;

typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    RPC_ASYNC_NOTIFICATION_INFO u;

    LONG_PTR Reserved[4];
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    __out_bcount(Size) PRPC_ASYNC_STATE pAsync,
    __in unsigned int     Size
    );

#if !defined(_KRPCENV_)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    __in PRPC_ASYNC_STATE pAsync
    ) ;
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    __in PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __out_opt void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in BOOL fAbort
    ) ;

#if (NTDDI_VERSION >= NTDDI_WINXP)

// EEINFO needs k-mode or needs winbase.h
#if !defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_) || defined(_WINBASE_)

typedef enum tagExtendedErrorParamTypes
{
    eeptAnsiString = 1,
    eeptUnicodeString,
    eeptLongVal,
    eeptShortVal,
    eeptPointerVal,
    eeptNone,
    eeptBinary
} ExtendedErrorParamTypes;

#define MaxNumberOfEEInfoParams    4
#define RPC_EEINFO_VERSION         1

typedef struct tagBinaryParam
{
    void *Buffer;
    short Size;
} BinaryParam;

typedef struct tagRPC_EE_INFO_PARAM
{
    ExtendedErrorParamTypes ParameterType;
    union
        {
        LPSTR AnsiString;
        LPWSTR UnicodeString;
        long LVal;
        short SVal;
        ULONGLONG PVal;
        BinaryParam BVal;
        } u;
} RPC_EE_INFO_PARAM;

#define EEInfoPreviousRecordsMissing     1
#define EEInfoNextRecordsMissing         2
#define EEInfoUseFileTime                4

#define EEInfoGCCOM                     11
#if (NTDDI_VERSION >= NTDDI_WS03)
#define EEInfoGCFRS                     12
#endif // (NTDDI_VERSION >= NTDDI_WS03)

typedef struct tagRPC_EXTENDED_ERROR_INFO
{
    ULONG Version;
    LPWSTR ComputerName;
    ULONG ProcessID;
    union
        {
#if !defined(_KRPCENV_)
        SYSTEMTIME SystemTime;
        FILETIME FileTime;
#else    // _KRPCENV_
        LARGE_INTEGER KernelTime;
#endif   // _KRPCENV_
        } u;
    ULONG GeneratingComponent;
    ULONG Status;
    USHORT DetectionLocation;
    USHORT Flags;
    int NumberOfParameters;
    RPC_EE_INFO_PARAM Parameters[MaxNumberOfEEInfoParams];
} RPC_EXTENDED_ERROR_INFO;

typedef struct tagRPC_ERROR_ENUM_HANDLE
{
    ULONG Signature;
    void *CurrentPos;
    void *Head;
} RPC_ERROR_ENUM_HANDLE;

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in BOOL CopyStrings, 
    __out RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __out int *Records
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __deref_out_bcount(*BlobSize) PVOID *ErrorBlob, 
    __out size_t *BlobSize
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    __in_bcount(BlobSize) PVOID ErrorBlob, 
    __in size_t BlobSize, 
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    __in RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    );

#endif // !RPC_NO_WINDOWS_H || _KRPCENV_ || _WINBASE_

#if !defined(_KRPCENV_)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCleanupThread (
    __in DWORD dwTimeout
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcGetAuthorizationContextForClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __in BOOL ImpersonateOnReturn,
    __in_opt PVOID Reserved1,
    __in_opt PLARGE_INTEGER pExpirationTime,
    __in LUID Reserved2,
    __in DWORD Reserved3,
    __in_opt PVOID Reserved4,
    __out PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcFreeAuthorizationContext (
    __deref PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockExclusive (
    __in_opt RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockShared (
    __in RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum tagRpcLocalAddressFormat
{
    rlafInvalid = 0,
    rlafIPv4,
    rlafIPv6
} RpcLocalAddressFormat;

typedef struct _RPC_CALL_LOCAL_ADDRESS_V1
{
    unsigned int Version;
    void *Buffer;
    unsigned long BufferSize;
    RpcLocalAddressFormat AddressFormat;
} RPC_CALL_LOCAL_ADDRESS_V1, *PRPC_CALL_LOCAL_ADDRESS_V1;

#define RPC_CALL_ATTRIBUTES_VERSION                         (2)

#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (0x02)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (0x04)
#define RPC_QUERY_CALL_LOCAL_ADDRESS                        (0x08)
#define RPC_QUERY_CLIENT_PID                                (0x10)
#define RPC_QUERY_IS_CLIENT_LOCAL                           (0x20)
#define RPC_QUERY_NO_AUTH_REQUIRED                          (0x40)
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) )
#define RPC_CALL_ATTRIBUTES_VERSION                         (1)
#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (2)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (4)
#endif // ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) )

typedef struct tagRPC_CALL_ATTRIBUTES_V1_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_W;

typedef struct tagRPC_CALL_ATTRIBUTES_V1_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_A;

#if (NTDDI_VERSION >= NTDDI_VISTA)
// CallStatus bit fields
#define RPC_CALL_STATUS_CANCELLED          0x01
#define RPC_CALL_STATUS_DISCONNECTED       0x02

typedef enum tagRpcCallType
{
    rctInvalid = 0,
    rctNormal,
    rctTraining,
    rctGuaranteed
} RpcCallType;

typedef enum tagRpcCallClientLocality
{
    rcclInvalid = 0,
    rcclLocal,
    rcclRemote,
    rcclClientUnknownLocality
} RpcCallClientLocality;


typedef struct tagRPC_CALL_ATTRIBUTES_V2_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    RpcCallClientLocality IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;	// one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;        
} RPC_CALL_ATTRIBUTES_V2_W;
    
typedef struct tagRPC_CALL_ATTRIBUTES_V2_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    unsigned long IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;	// one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;    
} RPC_CALL_ATTRIBUTES_V2_A;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

#ifdef UNICODE
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_W
#if (NTDDI_VERSION >= NTDDI_VISTA)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesW
#else
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_A
#if (NTDDI_VERSION >= NTDDI_VISTA)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES;
#else 
typedef RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
// can be used as flags in a bitmask too
typedef enum _RPC_NOTIFICATIONS
{
    RpcNotificationCallNone = 0,
    RpcNotificationClientDisconnect = 1,
    RpcNotificationCallCancel = 2      // internal for Windows
} RPC_NOTIFICATIONS;

#define RpcNotificationCallStatusChange    RpcNotificationClientDisconnect

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerSubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __in RPC_NOTIFICATION_TYPES NotificationType,
    __in RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerUnsubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __out unsigned long *NotificationsQueued
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#endif // _KRPCENV_
 
#if (NTDDI_VERSION >= NTDDI_VISTA)  
RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingBind (
    __in_opt PRPC_ASYNC_STATE pAsync,
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec    
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingUnbind (
    __in RPC_BINDING_HANDLE Binding
    );

#if !defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_) || defined(_WINBASE_)

#define RPC_DE_USE_CURRENT_EEINFO              (1)

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcDiagnoseError (
    __in RPC_BINDING_HANDLE BindingHandle, 
    __in RPC_IF_HANDLE IfSpec, 
    __in RPC_STATUS RpcStatus, 
    __in_opt RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in ULONG Options,
    __in_opt HWND ParentWindow
    );

#endif // !RPC_NO_WINDOWS_H || _KRPCENV_ || _WINBASE_

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#endif // (NTDDI_VERSION >= NTDDI_WINXP)
//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    __in  PRPC_MESSAGE Message,
    __in  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    __in PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

#if (NTDDI_VERSION >= NTDDI_WXP)
int 
RPC_ENTRY
I_RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_WXP)

#ifdef __cplusplus
}
#endif

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#endif /* __RPCASYNC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Routprot.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    routprot.h

Abstract:
    Include file for Routing Protocol inteface to Router Managers

--*/


#ifndef _ROUTPROT_H_
#define _ROUTPROT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include "stm.h"

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#pragma warning(disable:4200)

#include <nldef.h>
#include <in6addr.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Supported functionality flags                                            //
//                                                                          //
// ROUTING 		            Imports Routing Table Manager APIs      //
// SERVICES		            Exports Service Table Manager APIs      //
// DEMAND_UPDATE_ROUTES     IP and IPX RIP support for Autostatic           //
// DEMAND_UPDATE_SERVICES   IPX support for Autostatic                      //
// ADD_ALL_INTERFACES       Adds all interfaces, even if no info is present //
// MULTICAST                Supports multicast                              //
// POWER                    Power Manageable                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RF_ROUTING 		        0x00000001
#define RF_DEMAND_UPDATE_ROUTES 0x00000004
#define RF_ADD_ALL_INTERFACES   0x00000010
#define RF_MULTICAST            0x00000020
#define RF_POWER                0x00000040

#if MPR50
#define MS_ROUTER_VERSION       0x00000500
#else
#error Router version not defined
#endif

typedef enum _ROUTING_PROTOCOL_EVENTS
{
    ROUTER_STOPPED,              // Result is empty
    SAVE_GLOBAL_CONFIG_INFO,     // Result is empty
    SAVE_INTERFACE_CONFIG_INFO,  // Result is interface index
                                 // for which config info is to be saved.
    UPDATE_COMPLETE,             // Result is UPDATE_COMPLETE_MESSAGE structure
}ROUTING_PROTOCOL_EVENTS;


typedef enum _NET_INTERFACE_TYPE
{
    PERMANENT,
    DEMAND_DIAL,
    LOCAL_WORKSTATION_DIAL,
    REMOTE_WORKSTATION_DIAL
} NET_INTERFACE_TYPE;

//
// Interface Receive Types
//

#define IR_PROMISCUOUS                  0
#define IR_PROMISCUOUS_MULTICAST        1

typedef struct _SUPPORT_FUNCTIONS
{
    union
    {
        ULONGLONG   _Align8;

        struct
        {
            DWORD   dwVersion;
            DWORD   dwReserved;
        };
    };

    //
    // Function called by routing protocol to initiate demand dial connection
    //

    OUT DWORD
    (WINAPI *DemandDialRequest)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex
        ) ;

    //
    // Can be called to set the interface's receive capability
    // See IR_Xxx values above
    //

    OUT DWORD
    (WINAPI *SetInterfaceReceiveType)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex,
        IN      DWORD           InterfaceReceiveType,
        IN      BOOL            bActivate
        );

    //
    // Must be called by every protocol to set the route preference
    // and perform other validation
    //

    OUT DWORD
    (WINAPI *ValidateRoute)(
        IN      DWORD           ProtocolId,
        IN      PVOID           RouteInfo,
        IN      PVOID           DestAddress OPTIONAL
        );


    //
    // The following entrypoints are provided as a way for getting
    // information that spans components
    //

    OUT DWORD
    (WINAPI *MIBEntryCreate)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryDelete)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntrySet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetFirst)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetNext)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    //
    // Can be called to get the router ID value
    //

    OUT DWORD
    (WINAPI *GetRouterId)(VOID);

    OUT BOOL
    (WINAPI *HasMulticastBoundary)(
        IN      DWORD           dwIfIndex,
        IN      DWORD           dwGroupAddress
        );

} SUPPORT_FUNCTIONS, *PSUPPORT_FUNCTIONS ;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All IP Protocols must use the protocol ids defined in the range below.   //
// Protocols not identified below can use any unassigned number BELOW       //
// 0xffff0000                                                               //
//                                                                          //
// NOTE: These numbers have been chosen to coincide with MIB-II protocol    //
// numbers. Allocation should not be arbitrary.                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// See nldef.h for the IANA assigned values of PROTO_IP_*.
//

//
// The multicast protocol IDs
//

#define PROTO_IP_MSDP        9
#define PROTO_IP_IGMP       10
#define PROTO_IP_BGMP       11

//
// The IPRTRMGR_PID is 10000 // 0x00002710
//

#define PROTO_IP_VRRP               112
#define PROTO_IP_BOOTP              9999    // 0x0000270F

//included for DHCPv6 Relay Agent
#define PROTO_IPV6_DHCP 			999	    // 0x000003E7

#define PROTO_IP_NT_AUTOSTATIC      10002   // 0x00002712
#define PROTO_IP_DNS_PROXY          10003   // 0x00002713
#define PROTO_IP_DHCP_ALLOCATOR     10004   // 0x00002714
#define PROTO_IP_NAT                10005   // 0x00002715
#define PROTO_IP_NT_STATIC          10006   // 0x00002716
#define PROTO_IP_NT_STATIC_NON_DOD  10007   // 0x00002717
#define PROTO_IP_DIFFSERV           10008   // 0x00002718
#define PROTO_IP_MGM                10009   // 0x00002719
#define PROTO_IP_ALG                10010   // 0x0000271A
#define PROTO_IP_H323               10011   // 0x0000271B
#define PROTO_IP_FTP                10012   // 0x0000271C
#define PROTO_IP_DTP                10013   // 0x0000271D


// For all future development, the following macro must be used to generate
// Ids
//

//
//  Type            -   2 bits
//  Vendor          -  14 bits
//  ProtocolId      -  16 bits
//

#define PROTOCOL_ID(Type, VendorId, ProtocolId) \
    (((Type & 0x03)<<30)|((VendorId & 0x3FFF)<<16)|(ProtocolId & 0xFFFF))

//
//  |----|----|----|----|----|----|----|----|
//   Ty*** Vendor Id *** StandardProtocolId
//

#define TYPE_FROM_PROTO_ID(X)       (((X) >> 30) & 0x03)
#define VENDOR_FROM_PROTO_ID(X)     (((X) >> 16) & 0x3FFF)
#define PROTO_FROM_PROTO_ID(X)      ((X) & 0xFFFF)

//
// Types MS0 and MS1 are Microsoft Reserved
// A protocol that supports both unicast and multicast should use type
// MCAST
//

#define PROTO_TYPE_UCAST            0
#define PROTO_TYPE_MCAST            1
#define PROTO_TYPE_MS0              2
#define PROTO_TYPE_MS1              3

#define PROTO_VENDOR_MS0            0x0000
#define PROTO_VENDOR_MS1            0x137   // 311
#define PROTO_VENDOR_MS2            0x3FFF


#define MS_IPV6_DHCP                 \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IPV6_DHCP)

// included for IPV6 DHCP
#define MS_IP_BOOTP                 \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_BOOTP)
    
#define MS_IP_RIP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_RIP)

#define MS_IP_OSPF                  \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_OSPF)

#define MS_IP_BGP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS1, PROTO_IP_BGP)

#define MS_IP_IGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_IGMP)

#define MS_IP_BGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_BGMP)

#define MS_IP_MSDP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_MSDP)

#define MS_IP_DNS_PROXY             \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DNS_PROXY)

#define MS_IP_DHCP_ALLOCATOR        \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DHCP_ALLOCATOR)

#define MS_IP_NAT                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_NAT)

#define MS_IP_DIFFSERV              \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DIFFSERV)

#define MS_IP_MGM                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_MGM)

#define MS_IP_VRRP                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_VRRP)

#define MS_IP_DTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DTP)

#define MS_IP_H323                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_H323)

#define MS_IP_FTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_FTP)

#define MS_IP_ALG                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_ALG)

//
// All IPX Protocols must use the protocol ids defined in the range below.
// Protocols not identified below can use any unassigned number greater than
// IPX_PROTOCOL_BASE.
//

#define IPX_PROTOCOL_BASE   0x0001ffff
#define IPX_PROTOCOL_RIP    IPX_PROTOCOL_BASE + 1



typedef struct _UPDATE_COMPLETE_MESSAGE
{
    ULONG	InterfaceIndex;
    ULONG	UpdateType;	       // DEMAND_UPDATE_ROUTES, DEMAND_UPDATE_SERVICES
    ULONG	UpdateStatus;	   // NO_ERROR if successfull

}   UPDATE_COMPLETE_MESSAGE, *PUPDATE_COMPLETE_MESSAGE;

//
//  Message returned in Result parameter to GET_EVENT_MESSAGE api call.
//  UpdateCompleteMessage   returned for UPDATE_COMPLETE message
//  InterfaceIndex          returned for SAVE_INTERFACE_CONFIG_INFO message
//

typedef union _MESSAGE
{
    UPDATE_COMPLETE_MESSAGE UpdateCompleteMessage;
    DWORD                   InterfaceIndex;

}   MESSAGE, *PMESSAGE;

//
// Routing Interface Status types
//

#define RIS_INTERFACE_ADDRESS_CHANGE            0
#define RIS_INTERFACE_ENABLED                   1
#define RIS_INTERFACE_DISABLED                  2
#define RIS_INTERFACE_MEDIA_PRESENT             3
#define RIS_INTERFACE_MEDIA_ABSENT              4



//
// IP Adapter Binding Info
// This is the information associated with an ADDRESS_ARRIVAL event
// An address arrival may have AddressCount == 0, this implies a unnumbered
// interface
//

typedef struct IP_LOCAL_BINDING
{
    DWORD   Address;
    DWORD   Mask;
}IP_LOCAL_BINDING, *PIP_LOCAL_BINDING;

typedef struct IPV6_LOCAL_BINDING
{
    IN6_ADDR    Address;
    DWORD    PrefixLength;
}IPV6_LOCAL_BINDING, *PIPV6_LOCAL_BINDING;

typedef struct	IP_ADAPTER_BINDING_INFO
{
    ULONG               AddressCount;
    DWORD               RemoteAddress;
    ULONG               Mtu;
    ULONGLONG           Speed;
    __field_ecount(AddressCount) IP_LOCAL_BINDING    Address[0];
}IP_ADAPTER_BINDING_INFO, *PIP_ADAPTER_BINDING_INFO;


#define SIZEOF_IP_BINDING(X)                                \
    (FIELD_OFFSET(IP_ADAPTER_BINDING_INFO,Address[0]) +     \
     ((X) * sizeof(IP_LOCAL_BINDING)))

typedef struct  IPV6_ADAPTER_BINDING_INFO
{
    ULONG                   AddressCount;
    IN6_ADDR                RemoteAddress;
    ULONG                   Mtu;
    ULONGLONG               Speed;
    __field_ecount(AddressCount) IPV6_LOCAL_BINDING      Address[0];
}IPV6_ADAPTER_BINDING_INFO, *PIPV6_ADAPTER_BINDING_INFO;

#define SIZEOF_IPV6_BINDING(X)                                \
    (FIELD_OFFSET(IPV6_ADAPTER_BINDING_INFO,Address[0]) +     \
     ((X) * sizeof(IPV6_LOCAL_BINDING)))


typedef
DWORD
(WINAPI * PSTART_PROTOCOL) (
    IN HANDLE 	            NotificationEvent,
    IN PSUPPORT_FUNCTIONS   SupportFunctions,
    IN LPVOID               GlobalInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PSTART_COMPLETE) (
    VOID
    );

typedef
DWORD
(WINAPI * PSTOP_PROTOCOL) (
    VOID
    );

typedef
DWORD
(WINAPI * PADD_INTERFACE) (
    IN LPWSTR               InterfaceName,
    IN ULONG	            InterfaceIndex,
    IN NET_INTERFACE_TYPE   InterfaceType,
    IN DWORD                MediaType,
    IN WORD                 AccessType,
    IN WORD                 ConnectionType,
    IN PVOID	            InterfaceInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PDELETE_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PGET_EVENT_MESSAGE) (
    OUT ROUTING_PROTOCOL_EVENTS  *Event,
    OUT MESSAGE                  *Result
    );

typedef
DWORD
(WINAPI * PGET_INTERFACE_INFO) (
    IN      ULONG	InterfaceIndex,
    IN      PVOID   InterfaceInfo,
    IN  OUT PULONG  BufferSize,
    OUT     PULONG	StructureVersion,
    IN      PULONG	StructureSize,
    OUT     PULONG	StructureCount
    );

typedef
DWORD
(WINAPI * PSET_INTERFACE_INFO) (
    IN ULONG	InterfaceIndex,
    IN PVOID	InterfaceInfo,
    IN ULONG    StructureVersion,
    IN ULONG    StructureSize,
    IN ULONG    StructureCount
    );

typedef
DWORD
(WINAPI * PINTERFACE_STATUS) (
    IN ULONG	InterfaceIndex,
    IN BOOL     InterfaceActive,
    IN DWORD    StatusType,
    IN PVOID	StatusInfo
    );

typedef
DWORD
(WINAPI * PQUERY_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PSET_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PGET_GLOBAL_INFO) (
    IN     PVOID 	GlobalInfo,
    IN OUT PULONG   BufferSize,
    OUT    PULONG	StructureVersion,
    OUT    PULONG   StructureSize,
    OUT    PULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PSET_GLOBAL_INFO) (
    IN  PVOID 	GlobalInfo,
    IN  ULONG	StructureVersion,
    IN  ULONG   StructureSize,
    IN  ULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PDO_UPDATE_ROUTES) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PMIB_CREATE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_DELETE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET) (
    IN ULONG 	InputDataSize,
    IN PVOID	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_FIRST) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID   OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_NEXT) (
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET_TRAP_INFO) (
    IN  HANDLE  Event,
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_TRAP_INFO) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI *PCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

typedef
DWORD
(WINAPI *PDISCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

//
// InterfaceFlags used with the GetNeighbors() call below
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_PIM_FLAG      0x04
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

typedef
DWORD
(WINAPI *PGET_NEIGHBORS) (
    IN     DWORD  InterfaceIndex,
    IN     PDWORD NeighborList,
    IN OUT PDWORD NeighborListSize,
       OUT PBYTE  InterfaceFlags
    );

//
// StatusCode values used with the GetMfeStatus() call below.
// The protocol should return the highest-valued one that applies.
//

#define MFE_NO_ERROR          0 // none of the below events
#define MFE_REACHED_CORE      1 // this router is an RP/core for the group

//
// StatusCode values set by oif owner only
//

#define MFE_OIF_PRUNED        5 // no downstream receivers exist on oif

//
// StatusCode values set by iif owner only
//

#define MFE_PRUNED_UPSTREAM   4 // a prune was send upstream
#define MFE_OLD_ROUTER       11 // upstream nbr doesn't support mtrace

//
// StatusCode values which are used only by the Router Manager itself:
//

#define MFE_NOT_FORWARDING    2 // not fwding for an unspecified reason
#define MFE_WRONG_IF          3 // mtrace received on iif
#define MFE_BOUNDARY_REACHED  6 // iif or oif is admin scope boundary
#define MFE_NO_MULTICAST      7 // oif is not multicast-enabled
#define MFE_IIF               8 // mtrace arrived on iif
#define MFE_NO_ROUTE          9 // router has no route that matches
#define MFE_NOT_LAST_HOP     10 // router is not the proper last-hop router
#define MFE_PROHIBITED       12 // mtrace is administratively prohibited
#define MFE_NO_SPACE         13 // not enough room in packet

typedef
DWORD
(WINAPI *PGET_MFE_STATUS) (
    IN     DWORD  InterfaceIndex,
    IN     DWORD  GroupAddress,
    IN     DWORD  SourceAddress,
    OUT    PBYTE  StatusCode
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the structure passed between the router manager and a protocol   //
// upon registration.                                                       //
//                                                                          //
// IN OUT DWORD dwVersion                                                   //
// This is filled by the router manager to indicate the version it supports.//
// The DLL MUST set this to the version that the protocol will support.     //
//                                                                          //
// IN DWORD dwProtocolId                                                    //
// This the protocol the router manager is expecting the DLL to register.   //
// If the DLL does not support this protocol, it MUST return                //
// ERROR_NOT_SUPPORTED                                                      //
// A DLL will be called once for every protocol it supports                 //
//                                                                          //
// IN OUT DWORD fSupportedFunctionality                                     //
// These are the flags denoting the functionality the router manager        //
// supports. The DLL MUST reset this to the functionality that it supports. //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MPR50_ROUTING_CHARACTERISTICS
{
    DWORD               dwVersion;
    DWORD               dwProtocolId;
    DWORD               fSupportedFunctionality;

    PSTART_PROTOCOL     pfnStartProtocol;
    PSTART_COMPLETE     pfnStartComplete;
    PSTOP_PROTOCOL      pfnStopProtocol;
    PGET_GLOBAL_INFO    pfnGetGlobalInfo;
    PSET_GLOBAL_INFO    pfnSetGlobalInfo;
    PQUERY_POWER        pfnQueryPower;
    PSET_POWER          pfnSetPower;

    PADD_INTERFACE      pfnAddInterface;
    PDELETE_INTERFACE   pfnDeleteInterface;
    PINTERFACE_STATUS   pfnInterfaceStatus;
    PGET_INTERFACE_INFO pfnGetInterfaceInfo;
    PSET_INTERFACE_INFO pfnSetInterfaceInfo;

    PGET_EVENT_MESSAGE  pfnGetEventMessage;

    PDO_UPDATE_ROUTES   pfnUpdateRoutes;

    PCONNECT_CLIENT     pfnConnectClient;
    PDISCONNECT_CLIENT  pfnDisconnectClient;

    PGET_NEIGHBORS      pfnGetNeighbors;
    PGET_MFE_STATUS     pfnGetMfeStatus;

    PMIB_CREATE         pfnMibCreateEntry;
    PMIB_DELETE         pfnMibDeleteEntry;
    PMIB_GET            pfnMibGetEntry;
    PMIB_SET            pfnMibSetEntry;
    PMIB_GET_FIRST      pfnMibGetFirstEntry;
    PMIB_GET_NEXT       pfnMibGetNextEntry;
    PMIB_SET_TRAP_INFO  pfnMibSetTrapInfo;
    PMIB_GET_TRAP_INFO  pfnMibGetTrapInfo;

}MPR50_ROUTING_CHARACTERISTICS;

#if MPR50
typedef MPR50_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
#endif

typedef MPR_ROUTING_CHARACTERISTICS *PMPR_ROUTING_CHARACTERISTICS;


//
// All routing protocols must export the following entry point.
// The router manager calls this function to allow the routing
// protocol to register
//

#define REGISTER_PROTOCOL_ENTRY_POINT           RegisterProtocol
#define REGISTER_PROTOCOL_ENTRY_POINT_STRING    "RegisterProtocol"

typedef
DWORD
(WINAPI * PREGISTER_PROTOCOL) (
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );


#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#pragma warning(default:4201)
#endif

#endif      // _ROUTPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcNsi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

#if _MSC_VER > 1000
#pragma once
#endif

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_ALL_ELTS RPC_C_PROFILE_ALL_ELT
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );


RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#endif

/* Server PnP APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#endif

/* Client APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );
#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_CSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_CSTR __RPC_FAR *MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_WSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_WSTR __RPC_FAR *MemberName
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_CSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_CSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_CSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_CSTR __RPC_FAR *Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_WSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_WSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_WSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_WSTR __RPC_FAR *Annotation
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_CSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_WSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW
#define RpcNsBindingExportPnP RpcNsBindingExportPnPW
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA
#define RpcNsBindingExportPnP RpcNsBindingExportPnPA
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPA
#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcNsip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

RPCNSAPI
void
RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsServerBindSearch(
    void
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsClientBindSearch(
    void
    );

RPCNSAPI
void
RPC_ENTRY
I_NsClientBindDone(
    void
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcNdr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with Windows 2000/XP build 1700+


#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 500 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#include <pshpack8.h>
#include <basetsd.h>
#if !defined(_KRPCENV_)
#include <rpcnsip.h>
#endif

#include <rpcsal.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
#define NDR_IBM_FLOAT                   (unsigned long)0X00000300L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x601 <= _WIN32_WINNT)
#define TARGET_IS_NT61_OR_LATER                   1
#else
#define TARGET_IS_NT61_OR_LATER                   0
#endif

#if (0x600 <= _WIN32_WINNT)
#define TARGET_IS_NT60_OR_LATER                   1
#else
#define TARGET_IS_NT60_OR_LATER                   0
#endif

#if (0x501 <= _WIN32_WINNT)
#define TARGET_IS_NT51_OR_LATER                   1
#else
#define TARGET_IS_NT51_OR_LATER                   0
#endif

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef byte cs_byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef __RPC_WIN64__
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

__bcount_opt(size)
void  * __RPC_USER MIDL_user_allocate(size_t size);
void             __RPC_USER MIDL_user_free( __inout void  * );

__bcount_opt(size)
void * __RPC_USER I_RpcDefaultAllocate(
         handle_t bh, size_t size, void * (* RealAlloc)(size_t) );

void __RPC_USER I_RpcDefaultFree(
         handle_t bh, void *, void (*RealFree)(void *) );


#define RPC_VAR_ENTRY __cdecl


/* winnt only */
#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void  * NDR_CCONTEXT;

typedef struct
    {
    void  * pad[2];
    void  * userContext;
    }  * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER  * NDR_RUNDOWN)(void  * context);

typedef void (__RPC_USER  * NDR_NOTIFY_ROUTINE)(void);
typedef void (__RPC_USER  * NDR_NOTIFY2_ROUTINE)(boolean flag);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE,  * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    __in NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    __in  NDR_CCONTEXT    CContext,
    __out void  *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall2 (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    __in  NDR_SCONTEXT    CContext,
    __out void          * pBuff,
    __in  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    __in  void          * pBuff,
    __in  unsigned long   DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshallEx (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  NDR_SCONTEXT        CContext,
    __out void              * pBuff,
    __in  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall2 (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  NDR_SCONTEXT        CContext,
    __out void              * pBuff,
    __in  NDR_RUNDOWN         userRunDownIn,
    __in  void              * CtxGuard,
    __in unsigned long        Flags
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshallEx (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  void              * pBuff,
    __in  unsigned long       DataRepresentation
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall2(
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  void              * pBuff,
    __in  unsigned long       DataRepresentation,
    __in  void              * CtxGuard,
    __in unsigned long        Flags
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    __in void  *  * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char  *  *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.

// RKK64
// these appear to be used in fossils inside MIDL
#define _midl_fa2( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+1) & ~0x1))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+3) & ~0x3))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+7) & ~0x7))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

// RKK64
// these appear to be used in fossils inside MIDL
#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)


// end of unused

#define NdrFieldOffset(s,f)     (LONG_PTR)(& (((s  *)0)->f))
#define NdrFieldPad(s,f,p,t)    ((unsigned long)(NdrFieldOffset(s,f) - NdrFieldOffset(s,p)) - sizeof(t))

#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) || \
                   (RpcExceptionCode() == RPC_S_INVALID_BOUND) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char  *    RPC_BUFPTR;
typedef unsigned long       RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER  * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE  * );

typedef const unsigned char  * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long              Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long  *  BufferConformanceMark;
    unsigned long  *  BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long  *  MaxCountArray;
    unsigned long  *  OffsetArray;
    unsigned long  *  ActualCountArray;
    } ARRAY_INFO,  *PARRAY_INFO;


typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;
typedef struct _NDR_CORRELATION_INFO *PNDR_CORRELATION_INFO;

/*
 * MIDL Stub Message
 */

typedef const unsigned char  * PFORMAT_STRING;
typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

struct NDR_ALLOC_ALL_NODES_CONTEXT;
struct NDR_POINTER_QUEUE_STATE;
struct _NDR_PROC_CONTEXT;

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE            RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char       *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char       *   BufferStart;
    unsigned char       *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char       *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long           BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long           MemorySize;

    /* Pointer to user memory. */
    unsigned char       *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    unsigned char           IsClient;
    unsigned char           Pad;
    unsigned short          uFlags2;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                     ReuseBuffer;

    /* Hold the context for allocate all nodes */
    struct NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext;
    struct NDR_POINTER_QUEUE_STATE     *pPointerQueueState;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                     IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char       *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char           CorrDespIncrement;

    unsigned char           uFlags;
    unsigned short          UniquePtrCount;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    ULONG_PTR               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long           Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long           ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void  *             ( __RPC_API * pfnAllocate)( size_t );
    void                    ( __RPC_API * pfnFree)(void  *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char       *   StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char       *   pPresentedType;
    unsigned char       *   pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC  * StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES  * FullPtrXlatTables;
    unsigned long                   FullPtrRefId;

    unsigned long                   PointerLength;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;
    int                             fHasExtensions    :1;
    int                             fHasNewCorrDesc   :1;
    int                             fIsIn             :1;
    int                             fIsOut            :1;
    int                             fIsOicf           :1;
    int                             fBufferValid      :1;
    int                             fHasMemoryValidateCallback: 1;
    int                             fInFree             :1;
    int                             fNeedMCCP         :1;
    int                             fUnused           :3;
    int                             fUnused2          :16;


    unsigned long                   dwDestContext;
    void  *                         pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer    *   pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;
    unsigned long           *       SizePtrCountArray;
    unsigned long           *       SizePtrOffsetArray;
    unsigned long           *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void                    *       pArgQueue;

    unsigned long                   dwStubPhase;

    void                    *       LowStackMark;

    /*
     *  Async message pointer, correlation data - NT 5.0 features.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;
    PNDR_CORRELATION_INFO           pCorrInfo;
    unsigned char *                 pCorrMemory;

    void *                          pMemoryList;

    /*
     *  Reserved fields up to this point present since the 3.50 release.
     *  Reserved fields below were introduced for Windows 2000 release.
     *  (but not used).
     */

    /*
     * International character support information - NT 5.1 feature.
     */
#if (NTDDI_VERSION >= NTDDI_WIN2K )

    INT_PTR                         pCSInfo;

    unsigned char *                 ConformanceMark;
    unsigned char *                 VarianceMark;

#if defined(IA64)
    void                   *        BackingStoreLowMark;
#else
    INT_PTR                         Unused;
#endif

    struct _NDR_PROC_CONTEXT *      pContext;

    /*
     *  Reserved fields up to this point present since Windows 2000 release.
     *  Fields added for NT5.1
     *
     *  pUserMarshalList is used to keep a linked list of nodes pointing to 
     *  marshalled data to be freed.  This list can contain (as the name
     *  implies) User Marshalled data, but also can contain Interface Pointer
     *  data.   
     */

    void *                             ContextHandleHash;
    void *                             pUserMarshalList;
    INT_PTR                         Reserved51_3;
    INT_PTR                         Reserved51_4;
    INT_PTR                         Reserved51_5;


    /*
     *  Reserved fields up to this point present since NT5.1 release.
     */
#endif // (NTDDI_VERSION >= NTDDI_WIN2K )
    } MIDL_STUB_MESSAGE,  *PMIDL_STUB_MESSAGE;


typedef  struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE,   *PMIDL_STUB_MESSAGE;

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void  *
        ( __RPC_API * GENERIC_BINDING_ROUTINE)
        (void  *);
typedef void
        ( __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void  *, unsigned char  *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR,  *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void  *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO,  *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void ( __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE,  *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
( __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long  *,
     unsigned long,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  * ,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  *,
     void  * );

typedef void ( __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long  *,
     void  * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

#define USER_MARSHAL_CB_SIGNATURE 'USRC'

typedef enum _USER_MARSHAL_CB_TYPE
{
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE
} USER_MARSHAL_CB_TYPE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long           Flags;
    PMIDL_STUB_MESSAGE      pStubMsg;
    PFORMAT_STRING          pReserve;
    unsigned long           Signature;
    USER_MARSHAL_CB_TYPE    CBType;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pTypeFormat;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC              0x0100  /* aux flag: in an [async] call */
#define USER_CALL_NEW_CORRELATION_DESC  0x0200

typedef struct _MALLOC_FREE_STRUCT
    {
    void  *     ( __RPC_USER * pfnAllocate)(size_t);
    void        ( __RPC_USER * pfnFree)(void  *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * International character support definitions
 */

typedef enum _IDL_CS_CONVERT
    {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT
    } IDL_CS_CONVERT;

typedef void
( __RPC_USER * CS_TYPE_NET_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulLocalBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulNetworkBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_LOCAL_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulNetworkBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulLocalBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_TO_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     void               *   pLocalData,
     unsigned long          ulLocalDataLength,
     byte               *   pNetworkData,
     unsigned long      *   pulNetworkDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_FROM_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     byte               *   pNetworkData,
     unsigned long          ulNetworkDataLength,
     unsigned long          ulLocalBufferSize,
     void               *   pLocalData,
     unsigned long      *   pulLocalDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TAG_GETTING_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

void __RPC_USER
RpcCsGetTags(
     RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
    {
    CS_TYPE_NET_SIZE_ROUTINE    pfnNetSize;
    CS_TYPE_TO_NETCS_ROUTINE    pfnToNetCs;
    CS_TYPE_LOCAL_SIZE_ROUTINE  pfnLocalSize;
    CS_TYPE_FROM_NETCS_ROUTINE  pfnFromNetCs;
    } NDR_CS_SIZE_CONVERT_ROUTINES;

typedef struct _NDR_CS_ROUTINES
    {
    NDR_CS_SIZE_CONVERT_ROUTINES   *pSizeConvertRoutines;
    CS_TAG_GETTING_ROUTINE         *pTagGettingRoutines;
    } NDR_CS_ROUTINES;

typedef struct _NDR_EXPR_DESC
{
    const unsigned short * pOffset;
    PFORMAT_STRING  pFormatExpr;
} NDR_EXPR_DESC;
/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {
    void  *    RpcInterfaceInformation;

    void  *    ( __RPC_API * pfnAllocate)(size_t);
    void       ( __RPC_API * pfnFree)(void  *);

    union
        {
        handle_t  *             pAutoHandle;
        handle_t  *             pPrimitiveHandle;
        PGENERIC_BINDING_INFO   pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN  *                    apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR  *   aGenericBindingRoutinePairs;
    const EXPR_EVAL  *                      apfnExprEval;
    const XMIT_ROUTINE_QUINTUPLE  *         aXmitQuintuple;

    const unsigned char  *                  pFormatTypes;

    int                                     fCheckBounds;

    /* Ndr library version. */
    unsigned long                           Version;

    MALLOC_FREE_STRUCT  *                   pMallocFreeStruct;

    long                                    MIDLVersion;

    const COMM_FAULT_OFFSETS  *    CommFaultOffsets;

    // New fields for version 3.0+
    const USER_MARSHAL_ROUTINE_QUADRUPLE  * aUserMarshalQuadruple;

    // Notify routines - added for NT5, MIDL 5.0
    const NDR_NOTIFY_ROUTINE  *             NotifyRoutineTable;

    /*
     * Reserved for future use.
     */

    ULONG_PTR                               mFlags;

    // International support routines - added for 64bit post NT5
    const NDR_CS_ROUTINES *                 CsRoutineTables;

    void *                                  ProxyServerInfo;
    const NDR_EXPR_DESC *               pExprInfo;

    // Fields up to now present in win2000 release.

    } MIDL_STUB_DESC;


typedef const MIDL_STUB_DESC  * PMIDL_STUB_DESC;

typedef void  * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if defined(_MSC_EXTENSIONS)
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif
#endif
#endif /* _MSC_EXTENSIONS */

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void ( __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

#ifndef _MANAGED
typedef long ( __RPC_API * SERVER_ROUTINE)();
#else
typedef long ( __RPC_API * SERVER_ROUTINE)(void);
#endif

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC                     pStubDesc;
    const SERVER_ROUTINE     *          DispatchTable;
    PFORMAT_STRING                      ProcString;
    const unsigned short *              FmtStringOffset;
    const STUB_THUNK *                  ThunkTable;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

#undef _MIDL_STUBLESS_PROXY_INFO

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short            *   FormatStringOffset;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO  * PMIDL_STUBLESS_PROXY_INFO;

/*
 *  Multiple transfer syntax information.
 */
typedef struct _MIDL_SYNTAX_INFO
{
RPC_SYNTAX_IDENTIFIER               TransferSyntax;
RPC_DISPATCH_TABLE *                DispatchTable;
PFORMAT_STRING                      ProcString;
const unsigned short *              FmtStringOffset;
PFORMAT_STRING                      TypeString;
const void           *              aUserMarshalQuadruple;
ULONG_PTR                           pReserved1;
ULONG_PTR                           pReserved2;
} MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

typedef unsigned short * PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void  *         Pointer;
    LONG_PTR        Simple;
    } CLIENT_CALL_RETURN;

// BUGBUG: can we get rid of this defintion altogether, just leave void * here?
typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

typedef struct _FULL_PTR_XLAT_TABLES
{
    void * RefIdToPointer;
    void * PointerToRefId;
    unsigned long           NextRefId;   
    XLAT_SIDE               XlatSide;
} FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    __in RPC_CLIENT_INTERFACE * pInf,
    __out unsigned long       * pCount,
    __out MIDL_SYNTAX_INFO   ** pArr );


RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    __in RPC_SERVER_INTERFACE * pInf,
    __out unsigned long       * pCount,
    __out MIDL_SYNTAX_INFO   ** pArr,
    __out unsigned long       * pPreferSyntaxIndex);

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsTagMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT            ContextHandle,
    int                     fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine,
    PFORMAT_STRING          pFormat
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void  *                 pMemory,
    unsigned long           CacheSize,
    unsigned long           flags
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT        *   pContextHandle,
    RPC_BINDING_HANDLE      BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

/* New context handle flavors */

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrContextHandleInitialize(
    __in  PMIDL_STUB_MESSAGE  pStubMsg,
    __in  PFORMAT_STRING      pFormat
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextNewUnmarshall(
    __in  PMIDL_STUB_MESSAGE  pStubMsg,
    __in  PFORMAT_STRING      pFormat
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrContextHandleMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );


/* cs_char things */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    long                    NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long *         pFlags,
    unsigned char *         pBuffer,
    unsigned char           FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pBufferEnd
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pBufferEnd,
    RPC_BINDING_HANDLE  *   pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE      pStubMsg,
    RPC_VERSION *           pVersion );


/*
 * Interpreter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

// Raw RPC only
RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

// old dcom async scheme
RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

// async uuid
RPCRTAPI
long
RPC_ENTRY
NdrDcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    PMIDL_STUB_MESSAGE          pStubMsg,
    PMIDL_STUB_DESC             pStubDescriptor,
    PFORMAT_STRING              pFormat,
    void  *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    void  *    pThis, //Converted to struct IRpcStubBuffer
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PMIDL_STUB_MESSAGE          pStubMsg,
    PFORMAT_STRING              pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned long  *            pCommStatus,
    unsigned long  *            pFaultStatus,
    RPC_STATUS                  Status
    );



/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void  * RPC_SS_THREAD_HANDLE;

typedef void  * __RPC_API
RPC_CLIENT_ALLOC (
    __in size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    __in void  * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSsAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    __in void  * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    __in RPC_CLIENT_ALLOC  * ClientAlloc,
    __in RPC_CLIENT_FREE   * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    __in RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    __in RPC_CLIENT_ALLOC     * ClientAlloc,
    __in RPC_CLIENT_FREE      * ClientFree,
    __out RPC_CLIENT_ALLOC *  * OldClientAlloc,
    __out RPC_CLIENT_FREE  *  * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSmAllocate (
    __in  size_t          Size,
    __out RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    __in  void        *   pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    __in void         * * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    __in void         *   NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    __out RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    __in RPC_CLIENT_ALLOC * ClientAlloc,
    __in RPC_CLIENT_FREE  * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    __in RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    __in RPC_CLIENT_ALLOC     *   ClientAlloc,
    __in RPC_CLIENT_FREE      *   ClientFree,
    __out RPC_CLIENT_ALLOC    * * OldClientAlloc,
    __out RPC_CLIENT_FREE     * * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSmClientAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    __in void  * NodeToFree
    );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    __in void  * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );


RPCRTAPI
void  *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void  *                 ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void  *
RPC_ENTRY
NdrOleAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    __in void  * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * VC COM support 
 ****************************************************************************/

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_UUID(x) __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define MIDL_INTERFACE(x)   struct DECLSPEC_UUID(x) DECLSPEC_NOVTABLE

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID DECLSPEC_SELECTANY itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif

/****************************************************************************
 * UserMarshal information
 ****************************************************************************/

typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
{
    void *                      Buffer;
    unsigned long               BufferSize;
    void *(__RPC_API * pfnAllocate)(size_t);
    void (__RPC_API * pfnFree)(void *);
    struct IRpcChannelBuffer *  pRpcChannelBuffer;
    ULONG_PTR                   Reserved[5];
} NDR_USER_MARSHAL_INFO_LEVEL1;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif

typedef struct _NDR_USER_MARSHAL_INFO
{
    unsigned long InformationLevel;
    union {
        NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
    } DUMMYUNIONNAME;
} NDR_USER_MARSHAL_INFO;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    __in unsigned long        *   pFlags,
    __in unsigned long            InformationLevel,
    __out NDR_USER_MARSHAL_INFO * pMarshalInfo
    );

/****************************************************************************
 * 64bit APIs
 ****************************************************************************/
RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            __in struct IRpcStubBuffer* pStub,
            __inout RPC_SERVER_INTERFACE *pServerIf );

/*
 * Interpreter calls
 */
CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
Ndr64AsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

/* async uuid */
RPCRTAPI
long
RPC_ENTRY
Ndr64DcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall3 (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE                pRpcMsg
    );


RPCRTAPI
void
RPC_ENTRY
NdrServerCall3(
    PRPC_MESSAGE                pRpcMsg
    );


/* [partial_ignore] functions*/
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory,
    PFORMAT_STRING              pFormat
    );


void RPC_ENTRY
RpcUserFree( handle_t AsyncHandle, void * pBuffer );

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RTInfo.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rtinfo.h

Abstract:
	Definitions of information block structuers used to exchange
	information in router API

--*/

#ifndef __ROUTING_RTINFO_H__
#define __ROUTING_RTINFO_H__

#if _MSC_VER > 1000
#pragma once
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Information is passed to and from the Router Managers using a set of     //
// RTR_TOC_ENTRY structures. These structures are encapsulated by an        //
// RTR_INFO_BLOCK_HEADER.                                                   //
// The general structure of this is:                                        //
//                                                                          //
//           ---    |-----------------------|   ---                         //
//            |     |                       |    |                          //
//            |     | RTR_INFO_BLOCK_HEADER |    |                          //
//            |     |                       |    |                          //
//            |     | TocEntriesCount = N   |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[0]      |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |<------  Associated Data     |    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     Z                       Z    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[N-1]    |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |     |   Associated Data  ------->|                          //
//            |     |                       |    |                          //
//           ---    |-----------------------|    |                          //
//                  |  Data for TocEntry[0] |    |                          //
//                  |-----------------------|    |                          //
//                  Z                       Z    |                          //
//                  |-----------------------|   ---                         //
//                  | Data for TocEntry[N-1]|                               //
//                  |-----------------------|                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each of the blocks of data must begin at a quadword aligned boundary. To //
// get QUADWORD alignment, use the following macros.                        //
//                                                                          //
// The block of data pointed to by an InfoBlock MUST be aligned.            //
// Use the alignment macro when writing the data portion  into an infobase. //
// This implies that for each ALIGN_POINTER operation done on a chunk       //
// of memory, the requested allocation must be ALIGN_SIZE greater           //
// than what is actually required (to be on the safe side)                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define ALIGN_SIZE      0x00000008
#define ALIGN_SHIFT     (ALIGN_SIZE - 0x00000001)       // 0x00000007
#define ALIGN_MASK_POINTER  (~(UINT_PTR)ALIGN_SHIFT)    // 0xfffffff8
#define ALIGN_MASK_LENGTH   (~ALIGN_SHIFT)              // 0xfffffff8
#define ALIGN_MASK          (~ALIGN_SHIFT)              // 0xfffffff8


#define ALIGN_POINTER(ptr) {                                    \
    (ptr) = (PVOID)((DWORD_PTR)(ptr) + ALIGN_SHIFT);            \
    (ptr) = (PVOID)((DWORD_PTR)(ptr) & ALIGN_MASK_POINTER);     \
}

#define ALIGN_LENGTH(length) {                                  \
    (length) = (DWORD)((length) + ALIGN_SHIFT);                 \
    (length) = (DWORD)((length) & ALIGN_MASK_LENGTH);           \
}


#define IS_ALIGNED(ptr)  (((UINT_PTR)(ptr) & ALIGN_SHIFT) == 0x00000000)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Table of Contents Entry 	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each entry describes a structure type, location within the information   //
// block and number of entries of the same type.                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _RTR_TOC_ENTRY
{
    ULONG	    InfoType;	// Info structure type
    ULONG	    InfoSize;	// Size of the info structure
    ULONG	    Count;		// How many info structures of this type
    ULONG	    Offset;		// Offset of the first structure, from the start
							// of the info block header.
}RTR_TOC_ENTRY, *PRTR_TOC_ENTRY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Info Block Header        	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All Router information blocks start with this header                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RTR_INFO_BLOCK_VERSION	1

typedef struct _RTR_INFO_BLOCK_HEADER
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    __field_ecount(TocEntriesCount) RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;

//
// PVOID
// GetInfoFromTocEntry(
//                     IN PRTR_INFO_BLOCK_HEADER pInfoHdr,
//                     IN PRTR_TOC_ENTRY         pToc
//                     )
//

#define GetInfoFromTocEntry(hdr,toc)            \
    (((toc)->Offset < (hdr)->Size) ? ((PVOID)(((PBYTE)(hdr)) + (toc)->Offset)) : NULL)

#endif //__ROUTING_RTINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcNtErr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnterr.h

Abstract:

    Rpc Error Codes from the compiler and runtime

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#if !defined(_KRPCENV_)

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY
#define RPC_S_ASYNC_CALL_PENDING          ERROR_IO_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL           ERROR_NONE_MAPPED
#define RPC_S_TIMEOUT                     ERROR_TIMEOUT
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_S_NOT_ENOUGH_QUOTA            ERROR_NOT_ENOUGH_QUOTA
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER
#define RPC_X_PIPE_APP_MEMORY             ERROR_OUTOFMEMORY
#define RPC_X_INVALID_PIPE_OPERATION      RPC_X_WRONG_PIPE_ORDER

#else   // _KRPCENV_

#define RPC_S_OK                            STATUS_SUCCESS

#if defined(RPC_S_INVALID_STRING_BINDING)
#undef RPC_S_INVALID_STRING_BINDING
#endif
#define RPC_S_INVALID_STRING_BINDING        RPC_NT_INVALID_STRING_BINDING

#if defined(RPC_S_WRONG_KIND_OF_BINDING)
#undef RPC_S_WRONG_KIND_OF_BINDING
#endif
#define RPC_S_WRONG_KIND_OF_BINDING         RPC_NT_WRONG_KIND_OF_BINDING

#if defined(RPC_S_INVALID_BINDING)
#undef RPC_S_INVALID_BINDING
#endif
#define RPC_S_INVALID_BINDING               RPC_NT_INVALID_BINDING

#if defined(RPC_S_PROTSEQ_NOT_SUPPORTED)
#undef RPC_S_PROTSEQ_NOT_SUPPORTED
#endif
#define RPC_S_PROTSEQ_NOT_SUPPORTED         RPC_NT_PROTSEQ_NOT_SUPPORTED

#if defined(RPC_S_INVALID_RPC_PROTSEQ)
#undef RPC_S_INVALID_RPC_PROTSEQ
#endif
#define RPC_S_INVALID_RPC_PROTSEQ           RPC_NT_INVALID_RPC_PROTSEQ

#if defined(RPC_S_INVALID_STRING_UUID)
#undef RPC_S_INVALID_STRING_UUID
#endif
#define RPC_S_INVALID_STRING_UUID           RPC_NT_INVALID_STRING_UUID

#if defined(RPC_S_INVALID_ENDPOINT_FORMAT)
#undef RPC_S_INVALID_ENDPOINT_FORMAT
#endif
#define RPC_S_INVALID_ENDPOINT_FORMAT       RPC_NT_INVALID_ENDPOINT_FORMAT

#if defined(RPC_S_INVALID_NET_ADDR)
#undef RPC_S_INVALID_NET_ADDR
#endif
#define RPC_S_INVALID_NET_ADDR              RPC_NT_INVALID_NET_ADDR

#if defined(RPC_S_NO_ENDPOINT_FOUND)
#undef RPC_S_NO_ENDPOINT_FOUND
#endif
#define RPC_S_NO_ENDPOINT_FOUND             RPC_NT_NO_ENDPOINT_FOUND

#if defined(RPC_S_INVALID_TIMEOUT)
#undef RPC_S_INVALID_TIMEOUT
#endif
#define RPC_S_INVALID_TIMEOUT               RPC_NT_INVALID_TIMEOUT

#if defined(RPC_S_OBJECT_NOT_FOUND)
#undef RPC_S_OBJECT_NOT_FOUND
#endif
#define RPC_S_OBJECT_NOT_FOUND              RPC_NT_OBJECT_NOT_FOUND

#if defined(RPC_S_ALREADY_REGISTERED)
#undef RPC_S_ALREADY_REGISTERED
#endif
#define RPC_S_ALREADY_REGISTERED            RPC_NT_ALREADY_REGISTERED

#if defined(RPC_S_TYPE_ALREADY_REGISTERED)
#undef RPC_S_TYPE_ALREADY_REGISTERED
#endif
#define RPC_S_TYPE_ALREADY_REGISTERED       RPC_NT_TYPE_ALREADY_REGISTERED

#if defined(RPC_S_ALREADY_LISTENING)
#undef RPC_S_ALREADY_LISTENING
#endif
#define RPC_S_ALREADY_LISTENING             RPC_NT_ALREADY_LISTENING

#if defined(RPC_S_NO_PROTSEQS_REGISTERED)
#undef RPC_S_NO_PROTSEQS_REGISTERED
#endif
#define RPC_S_NO_PROTSEQS_REGISTERED        RPC_NT_NO_PROTSEQS_REGISTERED

#if defined(RPC_S_NOT_LISTENING)
#undef RPC_S_NOT_LISTENING
#endif
#define RPC_S_NOT_LISTENING                 RPC_NT_NOT_LISTENING

#if defined(RPC_S_UNKNOWN_MGR_TYPE)
#undef RPC_S_UNKNOWN_MGR_TYPE
#endif
#define RPC_S_UNKNOWN_MGR_TYPE              RPC_NT_UNKNOWN_MGR_TYPE

#if defined(RPC_S_UNKNOWN_IF)
#undef RPC_S_UNKNOWN_IF
#endif
#define RPC_S_UNKNOWN_IF                    RPC_NT_UNKNOWN_IF

#if defined(RPC_S_NO_BINDINGS)
#undef RPC_S_NO_BINDINGS
#endif
#define RPC_S_NO_BINDINGS                   RPC_NT_NO_BINDINGS

#if defined(RPC_S_NO_MORE_BINDINGS)
#undef RPC_S_NO_MORE_BINDINGS
#endif
#define RPC_S_NO_MORE_BINDINGS              RPC_NT_NO_MORE_BINDINGS

#if defined(RPC_S_NO_PROTSEQS)
#undef RPC_S_NO_PROTSEQS
#endif
#define RPC_S_NO_PROTSEQS                   RPC_NT_NO_PROTSEQS

#if defined(RPC_S_CANT_CREATE_ENDPOINT)
#undef RPC_S_CANT_CREATE_ENDPOINT
#endif
#define RPC_S_CANT_CREATE_ENDPOINT          RPC_NT_CANT_CREATE_ENDPOINT

#if defined(RPC_S_OUT_OF_RESOURCES)
#undef RPC_S_OUT_OF_RESOURCES
#endif
#define RPC_S_OUT_OF_RESOURCES              RPC_NT_OUT_OF_RESOURCES

#if defined(RPC_S_SERVER_UNAVAILABLE)
#undef RPC_S_SERVER_UNAVAILABLE
#endif
#define RPC_S_SERVER_UNAVAILABLE            RPC_NT_SERVER_UNAVAILABLE

#if defined(RPC_S_SERVER_TOO_BUSY)
#undef RPC_S_SERVER_TOO_BUSY
#endif
#define RPC_S_SERVER_TOO_BUSY               RPC_NT_SERVER_TOO_BUSY

#if defined(RPC_S_INVALID_NETWORK_OPTIONS)
#undef RPC_S_INVALID_NETWORK_OPTIONS
#endif
#define RPC_S_INVALID_NETWORK_OPTIONS       RPC_NT_INVALID_NETWORK_OPTIONS

#if defined(RPC_S_NO_CALL_ACTIVE)
#undef RPC_S_NO_CALL_ACTIVE
#endif
#define RPC_S_NO_CALL_ACTIVE                RPC_NT_NO_CALL_ACTIVE

#if defined(RPC_S_CALL_FAILED)
#undef RPC_S_CALL_FAILED
#endif
#define RPC_S_CALL_FAILED                   RPC_NT_CALL_FAILED

#if defined(RPC_S_CALL_CANCELLED)
#undef RPC_S_CALL_CANCELLED
#endif
#define RPC_S_CALL_CANCELLED                RPC_NT_CALL_CANCELLED

#if defined(RPC_S_CALL_FAILED_DNE)
#undef RPC_S_CALL_FAILED_DNE
#endif
#define RPC_S_CALL_FAILED_DNE               RPC_NT_CALL_FAILED_DNE

#if defined(RPC_S_PROTOCOL_ERROR)
#undef RPC_S_PROTOCOL_ERROR
#endif
#define RPC_S_PROTOCOL_ERROR                RPC_NT_PROTOCOL_ERROR

#if defined(RPC_S_UNSUPPORTED_TRANS_SYN)
#undef RPC_S_UNSUPPORTED_TRANS_SYN
#endif
#define RPC_S_UNSUPPORTED_TRANS_SYN         RPC_NT_UNSUPPORTED_TRANS_SYN

#if defined(RPC_S_SERVER_OUT_OF_MEMORY)
#undef RPC_S_SERVER_OUT_OF_MEMORY
#endif
#define RPC_S_SERVER_OUT_OF_MEMORY          STATUS_INSUFF_SERVER_RESOURCES

#if defined(RPC_S_UNSUPPORTED_TYPE)
#undef RPC_S_UNSUPPORTED_TYPE
#endif
#define RPC_S_UNSUPPORTED_TYPE              RPC_NT_UNSUPPORTED_TYPE

#if defined(RPC_S_INVALID_TAG)
#undef RPC_S_INVALID_TAG
#endif
#define RPC_S_INVALID_TAG                   RPC_NT_INVALID_TAG

#if defined(RPC_S_INVALID_BOUND)
#undef RPC_S_INVALID_BOUND
#endif
#define RPC_S_INVALID_BOUND                 RPC_NT_INVALID_BOUND

#if defined(RPC_S_NO_ENTRY_NAME)
#undef RPC_S_NO_ENTRY_NAME
#endif
#define RPC_S_NO_ENTRY_NAME                 RPC_NT_NO_ENTRY_NAME

#if defined(RPC_S_INVALID_NAME_SYNTAX)
#undef RPC_S_INVALID_NAME_SYNTAX
#endif
#define RPC_S_INVALID_NAME_SYNTAX           RPC_NT_INVALID_NAME_SYNTAX

#if defined(RPC_S_UNSUPPORTED_NAME_SYNTAX)
#undef RPC_S_UNSUPPORTED_NAME_SYNTAX
#endif
#define RPC_S_UNSUPPORTED_NAME_SYNTAX       RPC_NT_UNSUPPORTED_NAME_SYNTAX

#if defined(RPC_S_UUID_NO_ADDRESS)
#undef RPC_S_UUID_NO_ADDRESS
#endif
#define RPC_S_UUID_NO_ADDRESS               RPC_NT_UUID_NO_ADDRESS

#if defined(RPC_S_DUPLICATE_ENDPOINT)
#undef RPC_S_DUPLICATE_ENDPOINT
#endif
#define RPC_S_DUPLICATE_ENDPOINT            RPC_NT_DUPLICATE_ENDPOINT

#if defined(RPC_S_UNKNOWN_AUTHN_TYPE)
#undef RPC_S_UNKNOWN_AUTHN_TYPE
#endif
#define RPC_S_UNKNOWN_AUTHN_TYPE            RPC_NT_UNKNOWN_AUTHN_TYPE

#if defined(RPC_S_MAX_CALLS_TOO_SMALL)
#undef RPC_S_MAX_CALLS_TOO_SMALL
#endif
#define RPC_S_MAX_CALLS_TOO_SMALL           RPC_NT_MAX_CALLS_TOO_SMALL

#if defined(RPC_S_STRING_TOO_LONG)
#undef RPC_S_STRING_TOO_LONG
#endif
#define RPC_S_STRING_TOO_LONG               RPC_NT_STRING_TOO_LONG

#if defined(RPC_S_PROTSEQ_NOT_FOUND)
#undef RPC_S_PROTSEQ_NOT_FOUND
#endif
#define RPC_S_PROTSEQ_NOT_FOUND             RPC_NT_PROTSEQ_NOT_FOUND

#if defined(RPC_S_PROCNUM_OUT_OF_RANGE)
#undef RPC_S_PROCNUM_OUT_OF_RANGE
#endif
#define RPC_S_PROCNUM_OUT_OF_RANGE          RPC_NT_PROCNUM_OUT_OF_RANGE

#if defined(RPC_S_BINDING_HAS_NO_AUTH)
#undef RPC_S_BINDING_HAS_NO_AUTH
#endif
#define RPC_S_BINDING_HAS_NO_AUTH           RPC_NT_BINDING_HAS_NO_AUTH

#if defined(RPC_S_UNKNOWN_AUTHN_SERVICE)
#undef RPC_S_UNKNOWN_AUTHN_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHN_SERVICE         RPC_NT_UNKNOWN_AUTHN_SERVICE

#if defined(RPC_S_UNKNOWN_AUTHN_LEVEL)
#undef RPC_S_UNKNOWN_AUTHN_LEVEL
#endif
#define RPC_S_UNKNOWN_AUTHN_LEVEL           RPC_NT_UNKNOWN_AUTHN_LEVEL

#if defined(RPC_S_INVALID_AUTH_IDENTITY)
#undef RPC_S_INVALID_AUTH_IDENTITY
#endif
#define RPC_S_INVALID_AUTH_IDENTITY         RPC_NT_INVALID_AUTH_IDENTITY

#if defined(RPC_S_UNKNOWN_AUTHZ_SERVICE)
#undef RPC_S_UNKNOWN_AUTHZ_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHZ_SERVICE         RPC_NT_UNKNOWN_AUTHZ_SERVICE

#if defined(EPT_S_INVALID_ENTRY)
#undef EPT_S_INVALID_ENTRY
#endif
#define EPT_S_INVALID_ENTRY                 EPT_NT_INVALID_ENTRY

#if defined(EPT_S_CANT_PERFORM_OP)
#undef EPT_S_CANT_PERFORM_OP
#endif
#define EPT_S_CANT_PERFORM_OP               EPT_NT_CANT_PERFORM_OP

#if defined(EPT_S_NOT_REGISTERED)
#undef EPT_S_NOT_REGISTERED
#endif
#define EPT_S_NOT_REGISTERED                EPT_NT_NOT_REGISTERED

#if defined(RPC_S_NOTHING_TO_EXPORT)
#undef RPC_S_NOTHING_TO_EXPORT
#endif
#define RPC_S_NOTHING_TO_EXPORT             RPC_NT_NOTHING_TO_EXPORT

#if defined(RPC_S_INCOMPLETE_NAME)
#undef RPC_S_INCOMPLETE_NAME
#endif
#define RPC_S_INCOMPLETE_NAME               RPC_NT_INCOMPLETE_NAME

#if defined(RPC_S_INVALID_VERS_OPTION)
#undef RPC_S_INVALID_VERS_OPTION
#endif
#define RPC_S_INVALID_VERS_OPTION           RPC_NT_INVALID_VERS_OPTION

#if defined(RPC_S_NO_MORE_MEMBERS)
#undef RPC_S_NO_MORE_MEMBERS
#endif
#define RPC_S_NO_MORE_MEMBERS               RPC_NT_NO_MORE_MEMBERS

#if defined(RPC_S_NOT_ALL_OBJS_UNEXPORTED)
#undef RPC_S_NOT_ALL_OBJS_UNEXPORTED
#endif
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED       RPC_NT_NOT_ALL_OBJS_UNEXPORTED

#if defined(RPC_S_INTERFACE_NOT_FOUND)
#undef RPC_S_INTERFACE_NOT_FOUND
#endif
#define RPC_S_INTERFACE_NOT_FOUND           RPC_NT_INTERFACE_NOT_FOUND

#if defined(RPC_S_ENTRY_ALREADY_EXISTS)
#undef RPC_S_ENTRY_ALREADY_EXISTS
#endif
#define RPC_S_ENTRY_ALREADY_EXISTS          RPC_NT_ENTRY_ALREADY_EXISTS

#if defined(RPC_S_ENTRY_NOT_FOUND)
#undef RPC_S_ENTRY_NOT_FOUND
#endif
#define RPC_S_ENTRY_NOT_FOUND               RPC_NT_ENTRY_NOT_FOUND

#if defined(RPC_S_NAME_SERVICE_UNAVAILABLE)
#undef RPC_S_NAME_SERVICE_UNAVAILABLE
#endif
#define RPC_S_NAME_SERVICE_UNAVAILABLE      RPC_NT_NAME_SERVICE_UNAVAILABLE

#if defined(RPC_S_INVALID_NAF_ID)
#undef RPC_S_INVALID_NAF_ID
#endif
#define RPC_S_INVALID_NAF_ID                RPC_NT_INVALID_NAF_ID

#if defined(RPC_S_CANNOT_SUPPORT)
#undef RPC_S_CANNOT_SUPPORT
#endif
#define RPC_S_CANNOT_SUPPORT                RPC_NT_CANNOT_SUPPORT

#if defined(RPC_S_NO_CONTEXT_AVAILABLE)
#undef RPC_S_NO_CONTEXT_AVAILABLE
#endif
#define RPC_S_NO_CONTEXT_AVAILABLE          RPC_NT_NO_CONTEXT_AVAILABLE

#if defined(RPC_S_INTERNAL_ERROR)
#undef RPC_S_INTERNAL_ERROR
#endif
#define RPC_S_INTERNAL_ERROR                RPC_NT_INTERNAL_ERROR

#if defined(RPC_S_ZERO_DIVIDE)
#undef RPC_S_ZERO_DIVIDE
#endif
#define RPC_S_ZERO_DIVIDE                   RPC_NT_ZERO_DIVIDE

#if defined(RPC_S_ADDRESS_ERROR)
#undef RPC_S_ADDRESS_ERROR
#endif
#define RPC_S_ADDRESS_ERROR                 RPC_NT_ADDRESS_ERROR

#if defined(RPC_S_FP_DIV_ZERO)
#undef RPC_S_FP_DIV_ZERO
#endif
#define RPC_S_FP_DIV_ZERO                   RPC_NT_FP_DIV_ZERO

#if defined(RPC_S_FP_UNDERFLOW)
#undef RPC_S_FP_UNDERFLOW
#endif
#define RPC_S_FP_UNDERFLOW                  RPC_NT_FP_UNDERFLOW

#if defined(RPC_S_FP_OVERFLOW)
#undef RPC_S_FP_OVERFLOW
#endif
#define RPC_S_FP_OVERFLOW                   RPC_NT_FP_OVERFLOW

#if defined(RPC_S_PROXY_ACCESS_DENIED)
#undef RPC_S_PROXY_ACCESS_DENIED
#endif
#define RPC_S_PROXY_ACCESS_DENIED           RPC_NT_PROXY_ACCESS_DENIED

#if defined(RPC_X_NO_MORE_ENTRIES)
#undef RPC_X_NO_MORE_ENTRIES
#endif
#define RPC_X_NO_MORE_ENTRIES               RPC_NT_NO_MORE_ENTRIES

#if defined(RPC_X_SS_CHAR_TRANS_OPEN_FAIL)
#undef RPC_X_SS_CHAR_TRANS_OPEN_FAIL
#endif
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL       RPC_NT_SS_CHAR_TRANS_OPEN_FAIL

#if defined(RPC_X_SS_CHAR_TRANS_SHORT_FILE)
#undef RPC_X_SS_CHAR_TRANS_SHORT_FILE
#endif
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE      RPC_NT_SS_CHAR_TRANS_SHORT_FILE

#if defined(RPC_X_SS_IN_NULL_CONTEXT)
#undef RPC_X_SS_IN_NULL_CONTEXT
#endif
#define RPC_X_SS_IN_NULL_CONTEXT            RPC_NT_SS_IN_NULL_CONTEXT

#if defined(RPC_X_SS_CONTEXT_MISMATCH)
#undef RPC_X_SS_CONTEXT_MISMATCH
#endif
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH

#if defined(RPC_X_SS_CONTEXT_DAMAGED)
#undef RPC_X_SS_CONTEXT_DAMAGED
#endif
#define RPC_X_SS_CONTEXT_DAMAGED            RPC_NT_SS_CONTEXT_DAMAGED

#if defined(RPC_X_SS_HANDLES_MISMATCH)
#undef RPC_X_SS_HANDLES_MISMATCH
#endif
#define RPC_X_SS_HANDLES_MISMATCH           RPC_NT_SS_HANDLES_MISMATCH

#if defined(RPC_X_SS_CANNOT_GET_CALL_HANDLE)
#undef RPC_X_SS_CANNOT_GET_CALL_HANDLE
#endif
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE     RPC_NT_SS_CANNOT_GET_CALL_HANDLE

#if defined(RPC_X_NULL_REF_POINTER)
#undef RPC_X_NULL_REF_POINTER
#endif
#define RPC_X_NULL_REF_POINTER              RPC_NT_NULL_REF_POINTER

#if defined(RPC_X_ENUM_VALUE_OUT_OF_RANGE)
#undef RPC_X_ENUM_VALUE_OUT_OF_RANGE
#endif
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE       RPC_NT_ENUM_VALUE_OUT_OF_RANGE

#if defined(RPC_X_BYTE_COUNT_TOO_SMALL)
#undef RPC_X_BYTE_COUNT_TOO_SMALL
#endif
#define RPC_X_BYTE_COUNT_TOO_SMALL          RPC_NT_BYTE_COUNT_TOO_SMALL

#if defined(RPC_X_BAD_STUB_DATA)
#undef RPC_X_BAD_STUB_DATA
#endif
#define RPC_X_BAD_STUB_DATA                 RPC_NT_BAD_STUB_DATA

#if defined(RPC_S_CALL_IN_PROGRESS)
#undef RPC_S_CALL_IN_PROGRESS
#endif
#define RPC_S_CALL_IN_PROGRESS              RPC_NT_CALL_IN_PROGRESS

#if defined(RPC_S_GROUP_MEMBER_NOT_FOUND)
#undef RPC_S_GROUP_MEMBER_NOT_FOUND
#endif
#define RPC_S_GROUP_MEMBER_NOT_FOUND        RPC_NT_GROUP_MEMBER_NOT_FOUND

#if defined(EPT_S_CANT_CREATE)
#undef EPT_S_CANT_CREATE
#endif
#define EPT_S_CANT_CREATE                   EPT_NT_CANT_CREATE

#if defined(RPC_S_INVALID_OBJECT)
#undef RPC_S_INVALID_OBJECT
#endif
#define RPC_S_INVALID_OBJECT                RPC_NT_INVALID_OBJECT

#if defined(RPC_S_INVALID_ASYNC_HANDLE)
#undef RPC_S_INVALID_ASYNC_HANDLE
#endif
#define RPC_S_INVALID_ASYNC_HANDLE          RPC_NT_INVALID_ASYNC_HANDLE

#if defined(RPC_S_INVALID_ASYNC_CALL)
#undef RPC_S_INVALID_ASYNC_CALL
#endif
#define RPC_S_INVALID_ASYNC_CALL            RPC_NT_INVALID_ASYNC_CALL

#if defined(RPC_X_PIPE_CLOSED)
#undef RPC_X_PIPE_CLOSED
#endif
#define RPC_X_PIPE_CLOSED                   RPC_NT_PIPE_CLOSED

#if defined(RPC_X_PIPE_EMPTY)
#undef RPC_X_PIPE_EMPTY
#endif
#define RPC_X_PIPE_EMPTY                    RPC_NT_PIPE_EMPTY

#if defined(RPC_X_PIPE_DISCIPLINE_ERROR)
#undef RPC_X_PIPE_DISCIPLINE_ERROR
#endif
#define RPC_X_PIPE_DISCIPLINE_ERROR         RPC_NT_PIPE_DISCIPLINE_ERROR

#define RPC_S_INVALID_ARG                   STATUS_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY                 STATUS_NO_MEMORY
#define RPC_S_OUT_OF_THREADS                STATUS_NO_MEMORY
#define RPC_S_INVALID_LEVEL                 STATUS_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL              STATUS_BUFFER_TOO_SMALL
#define RPC_S_INVALID_SECURITY_DESC         STATUS_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED                 STATUS_ACCESS_DENIED
#define RPC_S_ASYNC_CALL_PENDING            STATUS_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL             STATUS_NONE_MAPPED
#define RPC_S_NOT_ENOUGH_QUOTA              STATUS_QUOTA_EXCEEDED
#define RPC_X_NO_MEMORY                     STATUS_NO_MEMORY
#define RPC_X_INVALID_BOUND                 RPC_NT_INVALID_BOUND
#define RPC_X_INVALID_TAG                   RPC_NT_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE          RPC_NT_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH
#define RPC_X_INVALID_BUFFER                STATUS_INVALID_BUFFER_SIZE
#define RPC_X_PIPE_APP_MEMORY               STATUS_NO_MEMORY

#endif  // _KRPCENV_

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Rpcsal.h ===
/****************************************************************\
*                                                                *
* rpcsal.h - markers for documenting the semantics of RPC APIs   *
*                                                                *
* Version 1.0                                                    *
*                                                                *
* Copyright (c) 2004 Microsoft Corporation. All rights reserved. *
*                                                                *
\****************************************************************/

// -------------------------------------------------------------------------------
// Introduction
//
// rpcsal.h provides a set of annotations to describe how RPC functions use their
// parameters - the assumptions it makes about them, adn the guarantees it makes 
// upon finishing.  These annotations are similar to those found in specstrings.h,
// but are designed to be used by the MIDL compiler when it generates annotations
// enabled header files.
//
// IDL authors do not need to annotate their functions declarations.  The MIDL compiler
// will interpret the IDL directives and use one of the annotations contained 
// in this header.  This documentation is intended to help those trying to  understand 
// the MIDL-generated header files or those who maintain their own copies of these files.
//
// -------------------------------------------------------------------------------
// Differences between rpcsal.h and specstrings.h
// 
// There are a few important differences between the annotations found in rpcsal.h and
// those in specstrings.h:
// 
// 1. [in] parameters are not marked as read-only.  They may be used for scratch space 
// at the server and changes will not affect the client.
// 2. String versions of each macro alleviates the need for a special type definition
//
// -------------------------------------------------------------------------------
// Interpreting RPC Annotations
//
// These annotations are interpreted precisely in the same way as those in specstrings.h.  
// Please refer to that header for information related to general usage in annotations. 
//
// To construct an RPC annotation, concatenate the appropriate value from each category
// along with a leading __RPC_.  A typical annotation looks like "__RPC__in_string".
//
// |----------------------------------------------------------------------------------|
// | RPC Annotations                                                                  |
// |------------|------------|---------|--------|----------|----------|---------------|
// |   Level    |   Usage    |  Size   | Output | Optional |  String  |  Parameters   |
// |------------|------------|---------|--------|----------|----------|---------------|
// | <>         | <>         | <>      | <>     | <>       | <>       | <>            |
// | _deref     | _in        | _ecount | _full  | _opt     | _string  | (size)        |
// | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
// |            | _inout     |         |        |          |          |               |
// |            |            |         |        |          |          |               |
// |------------|------------|---------|--------|----------|----------|---------------|
//
// Level: Describes the buffer pointer's level of indirection from the parameter or
//          return value 'p'.
//
// <>         : p is the buffer pointer.
// _deref     : *p is the buffer pointer. p must not be NULL.
// _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
//                the annotation is ignored.
//
// Usage: Describes how the function uses the buffer.
//
// <>     : The buffer is not accessed. If used on the return value or with _deref, the
//            function will provide the buffer, and it will be uninitialized at exit.
//            Otherwise, the caller must provide the buffer. This should only be used
//            for alloc and free functions.
// _in    : The function will only read from the buffer. The caller must provide the
//            buffer and initialize it. Cannot be used with _deref.
// _out   : The function will only write to the buffer. If used on the return value or
//            with _deref, the function will provide the buffer and initialize it.
//            Otherwise, the caller must provide the buffer, and the function will
//            initialize it.
// _inout : The function may freely read from and write to the buffer. The caller must
//            provide the buffer and initialize it. If used with _deref, the buffer may
//            be reallocated by the function.
//
// Size: Describes the total size of the buffer. This may be less than the space actually
//         allocated for the buffer, in which case it describes the accessible amount.
//
// <>      : No buffer size is given. If the type specifies the buffer size (such as
//             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
//             element long. Must be used with _in, _out, or _inout.
// _ecount : The buffer size is an explicit element count.
// _bcount : The buffer size is an explicit byte count.
//
// Output: Describes how much of the buffer will be initialized by the function. For
//           _inout buffers, this also describes how much is initialized at entry. Omit this
//           category for _in buffers; they must be fully initialized by the caller.
//
// <>    : The type specifies how much is initialized. For instance, a function initializing
//           an LPWSTR must NULL-terminate the string.
// _full : The function initializes the entire buffer.
// _part : The function initializes part of the buffer, and explicitly indicates how much.
//
// Optional: Describes if the buffer itself is optional.
//
// <>   : The pointer to the buffer must not be NULL.
// _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.
//
// String: Describes if the buffer is NULL terminated
//
// <>      : The buffer is not assumed to be NULL terminated
// _string : The buffer is assumed to be NULL terminated once it has been initialized
//
// Parameters: Gives explicit counts for the size and length of the buffer.
//
// <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
// (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
// (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
//                   and _bcount_part.
//
// Notes:
//
// 1. Specifying two buffer annotations on a single parameter results in unspecified behavior
//    (e.g. __RPC__in_bcount(5) __RPC__out_bcount(6)
// 
// 2. The size of the buffer and the amount that has been initialized are separate concepts.  
//    Specify the size using _ecount or _bcount.  Specify the amount that is initialized using 
//    _full, _part, or _string.  As a special case, a single element buffer does not need 
//    _ecount, _bcount, _full, or _part
// 
// 3. The count may be less than the total size of the buffer in which case it describes the 
//    accessible portion. 
// 
// 4. "__RPC__opt" and "__RPC_deref" are not valid annotations.
// 
// 5. The placement of _opt when using _deref is important:
//      __RPC__deref_opt_...      : Input may be NULL
//      __RPC__deref_..._opt      : Output may be NULL
//      __RPC__deref_opt_..._opt  : Both input and output may be NULL
//

#pragma once

#include <specstrings.h>

#ifndef __RPCSAL_H_VERSION__
#define __RPCSAL_H_VERSION__        ( 100 )
#endif // __RPCSAL_H_VERSION__

#ifdef __REQUIRED_RPCSAL_H_VERSION__
    #if ( __RPCSAL_H_VERSION__ < __REQUIRED_RPCSAL_H_VERSION__ )
        #error incorrect <rpcsal.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#ifdef  __cplusplus
extern "C" {
#endif  // #ifdef __cplusplus

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)


// [in]
#define __RPC__in                                   __pre __valid
#define __RPC__in_string                            __RPC__in   __pre __nullterminated
#define __RPC__in_ecount(size)                      __RPC__in __pre __elem_readableTo(size)
#define __RPC__in_ecount_full(size)                 __RPC__in_ecount(size)
#define __RPC__in_ecount_full_string(size)          __RPC__in_ecount_full(size) __pre __nullterminated
#define __RPC__in_ecount_part(size, length)         __RPC__in_ecount(length) __pre __elem_writableTo(size)
#define __RPC__in_ecount_full_opt(size)             __RPC__in_ecount_full(size) __pre __exceptthat  __maybenull
#define __RPC__in_ecount_full_opt_string(size)      __RPC__in_ecount_full_opt(size) __pre __nullterminated
#define __RPC__in_ecount_part_opt(size, length)     __RPC__in_ecount_part(size, length) __pre __exceptthat __maybenull
#define __RPC__in_xcount(size)                      __RPC__in __pre __elem_readableTo(size)
#define __RPC__in_xcount_full(size)                 __RPC__in_ecount(size)
#define __RPC__in_xcount_full_string(size)          __RPC__in_ecount_full(size) __pre __nullterminated
#define __RPC__in_xcount_part(size, length)         __RPC__in_ecount(length) __pre __elem_writableTo(size)
#define __RPC__in_xcount_full_opt(size)             __RPC__in_ecount_full(size) __pre __exceptthat  __maybenull
#define __RPC__in_xcount_full_opt_string(size)      __RPC__in_ecount_full_opt(size) __pre __nullterminated
#define __RPC__in_xcount_part_opt(size, length)     __RPC__in_ecount_part(size, length) __pre __exceptthat __maybenull


#define __RPC__deref_in                             __RPC__in __deref __notnull 
#define __RPC__deref_in_string                      __RPC__in   __pre __deref __nullterminated
#define __RPC__deref_in_opt                         __RPC__deref_in __deref __exceptthat __maybenull
#define __RPC__deref_in_opt_string                  __RPC__deref_in_opt __pre __deref __nullterminated
#define __RPC__deref_opt_in                         __RPC__in __exceptthat __maybenull 
#define __RPC__deref_opt_in_string                  __RPC__deref_opt_in __pre __deref __nullterminated 
#define __RPC__deref_opt_in_opt                     __RPC__deref_opt_in  __pre __deref __exceptthat __maybenull
#define __RPC__deref_opt_in_opt_string              __RPC__deref_opt_in_opt  __pre __deref __nullterminated
#define __RPC__deref_in_ecount(size)                __RPC__in __pre __deref __elem_readableTo(size)
#define __RPC__deref_in_ecount_part(size, length)   __RPC__deref_in_ecount(size)  __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_ecount_full(size)           __RPC__deref_in_ecount_part(size, size)
#define __RPC__deref_in_ecount_full_opt(size)       __RPC__deref_in_ecount_full(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_full_opt_string(size) __RPC__deref_in_ecount_full_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_full_string(size)    __RPC__deref_in_ecount_full(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_opt(size)            __RPC__deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_opt_string(size)     __RPC__deref_in_ecount_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_part_opt(size, length) __RPC__deref_in_ecount_opt(size) __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_xcount(size)                __RPC__in __pre __deref __elem_readableTo(size)
#define __RPC__deref_in_xcount_part(size, length)   __RPC__deref_in_ecount(size)  __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_xcount_full(size)           __RPC__deref_in_ecount_part(size, size)
#define __RPC__deref_in_xcount_full_opt(size)       __RPC__deref_in_ecount_full(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_xcount_full_opt_string(size) __RPC__deref_in_ecount_full_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_full_string(size)    __RPC__deref_in_ecount_full(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_opt(size)            __RPC__deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_xcount_opt_string(size)     __RPC__deref_in_ecount_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_part_opt(size, length) __RPC__deref_in_ecount_opt(size) __pre __deref __elem_readableTo(length)

// [out]
#define __RPC__out                                  __out
#define __RPC__out_ecount(size)                     __out_ecount(size)  __post  __elem_writableTo(size)
#define __RPC__out_ecount_string(size)              __RPC__out_ecount(size) __post __nullterminated
#define __RPC__out_ecount_part(size, length)        __RPC__out_ecount(size)  __post  __elem_readableTo(length)
#define __RPC__out_ecount_full(size)                __RPC__out_ecount_part(size, size)
#define __RPC__out_ecount_full_string(size)         __RPC__out_ecount_full(size) __post  __nullterminated
#define __RPC__out_xcount(size)                     __out
#define __RPC__out_xcount_string(size)              __RPC__out __post __nullterminated
#define __RPC__out_xcount_part(size, length)        __RPC__out
#define __RPC__out_xcount_full(size)                __RPC__out
#define __RPC__out_xcount_full_string(size)         __RPC__out __post __nullterminated

// [in,out] 
#define __RPC__inout                                __inout
#define __RPC__inout_string                         __RPC__inout  __pre __nullterminated __post __nullterminated
#define __RPC__inout_ecount(size)                   __inout_ecount(size)
#define __RPC__inout_ecount_part(size, length)      __inout_ecount_part(size, length)
#define __RPC__inout_ecount_full(size)              __RPC__inout_ecount_part(size, size)
#define __RPC__inout_ecount_full_string(size)       __RPC__inout_ecount_full(size) __pre __nullterminated __post __nullterminated
#define __RPC__inout_xcount(size)                   __inout
#define __RPC__inout_xcount_part(size, length)      __inout
#define __RPC__inout_xcount_full(size)              __RPC__inout
#define __RPC__inout_xcount_full_string(size)       __RPC__inout __pre __nullterminated __post __nullterminated

// [in,unique] 
#define __RPC__in_opt                               __RPC__in __pre __exceptthat __maybenull
#define __RPC__in_opt_string                        __RPC__in_opt   __pre __nullterminated
#define __RPC__in_ecount_opt(size)                  __RPC__in_ecount(size) __pre __exceptthat __maybenull
#define __RPC__in_ecount_opt_string(size)           __RPC__in_ecount_opt(size) __pre __nullterminated
#define __RPC__in_xcount_opt(size)                  __RPC__in_ecount(size) __pre __exceptthat __maybenull
#define __RPC__in_xcount_opt_string(size)           __RPC__in_ecount_opt(size) __pre __nullterminated

// [in,out,unique] 
#define __RPC__inout_opt                            __inout_opt
#define __RPC__inout_opt_string                     __RPC__inout_opt  __pre __nullterminated
#define __RPC__inout_ecount_opt(size)               __inout_ecount_opt(size)
#define __RPC__inout_ecount_part_opt(size, length)  __inout_ecount_part_opt(size, length)
#define __RPC__inout_ecount_full_opt(size)          __RPC__inout_ecount_part_opt(size, size)
#define __RPC__inout_ecount_full_opt_string(size)   __RPC__inout_ecount_full_opt(size)  __pre __nullterminated __post __nullterminated
#define __RPC__inout_xcount_opt(size)               __inout_opt
#define __RPC__inout_xcount_part_opt(size, length)  __inout_opt
#define __RPC__inout_xcount_full_opt(size)          __RPC__inout_opt
#define __RPC__inout_xcount_full_opt_string(size)   __RPC__inout_opt __pre __nullterminated __post __nullterminated

// [out] **
#define __RPC__deref_out                            __deref_out
#define __RPC__deref_out_string                     __RPC__deref_out    __post __deref __nullterminated
// Removed "__post __deref __exceptthat __maybenull" so return values from QueryInterface and the like can be trusted without an explicit NULL check.
// This is a temporary fix until midl.exe can be rev'd to produce more accurate annotations.
#define __RPC__deref_out_opt                        __RPC__deref_out
#define __RPC__deref_out_opt_string                 __RPC__deref_out_opt  __post __deref __nullterminated __pre __deref __null
#define __RPC__deref_out_ecount(size)               __deref_out_ecount(size) __post __deref __elem_writableTo(size)
#define __RPC__deref_out_ecount_part(size, length)  __RPC__deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __RPC__deref_out_ecount_full(size)          __RPC__deref_out_ecount_part(size,size)
#define __RPC__deref_out_ecount_full_string(size)   __RPC__deref_out_ecount_full(size) __post __deref __nullterminated
#define __RPC__deref_out_xcount(size)               __deref_out __post __deref
#define __RPC__deref_out_xcount_part(size, length)  __RPC__deref_out __post __deref
#define __RPC__deref_out_xcount_full(size)          __RPC__deref_out
#define __RPC__deref_out_xcount_full_string(size)   __RPC__deref_out __post __deref __nullterminated

// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout                          __deref_inout
#define __RPC__deref_inout_string                   __RPC__deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_inout_opt                      __deref_inout_opt
#define __RPC__deref_inout_opt_string               __RPC__deref_inout_opt __deref __nullterminated 
#define __RPC__deref_inout_ecount_opt(size)         __deref_inout_ecount_opt(size)
#define __RPC__deref_inout_ecount_part_opt(size, length) __deref_inout_ecount_part_opt(size , length)
#define __RPC__deref_inout_ecount_full_opt(size)    __RPC__deref_inout_ecount_part_opt(size, size)
#define __RPC__deref_inout_ecount_full(size)        __deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size) __RPC__deref_inout_ecount_full(size) __post __deref __nullterminated
#define __RPC__deref_inout_ecount_full_opt_string(size) __RPC__deref_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_inout_xcount_opt(size)         __deref_inout_opt
#define __RPC__deref_inout_xcount_part_opt(size, length) __deref_inout_opt
#define __RPC__deref_inout_xcount_full_opt(size)    __RPC__deref_inout_opt
#define __RPC__deref_inout_xcount_full(size)        __deref_inout
#define __RPC__deref_inout_xcount_full_string(size) __RPC__deref_inout __post __deref __nullterminated
#define __RPC__deref_inout_xcount_full_opt_string(size) __RPC__deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated


// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout                          __deref_opt_inout
#define __RPC__deref_opt_inout_ecount(size)             __deref_opt_inout_ecount(size)
#define __RPC__deref_opt_inout_string                   __RPC__deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_part(size, length) __deref_opt_inout_ecount_part(size, length)
#define __RPC__deref_opt_inout_ecount_full(size)        __deref_opt_inout_ecount_full(size)
#define __RPC__deref_opt_inout_ecount_full_string(size)  __RPC__deref_opt_inout_ecount_full(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_xcount_part(size, length) __deref_opt_inout
#define __RPC__deref_opt_inout_xcount_full(size)        __deref_opt_inout
#define __RPC__deref_opt_inout_xcount_full_string(size)  __RPC__deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated


// We don't need to specify __pre __deref __exceptthat __maybenull : this is default behavior. While this might not hold in SAL 1.1 syntax, SAL team 
// believes it's OK. We can revisit if SAL 1.1 can survive. 
#define __RPC__deref_out_ecount_opt(size)               __RPC__out_ecount(size) __post __deref __exceptthat __maybenull __pre __deref __null 
#define __RPC__deref_out_ecount_part_opt(size, length)  __RPC__deref_out_ecount_part(size, length) __post __deref __exceptthat __maybenull __pre __deref __null
#define __RPC__deref_out_ecount_full_opt(size)          __RPC__deref_out_ecount_part_opt(size, size) __pre __deref __null
#define __RPC__deref_out_ecount_full_opt_string(size)   __RPC__deref_out_ecount_part_opt(size, size) __post __deref __nullterminated __pre __deref __null
#define __RPC__deref_out_xcount_opt(size)               __RPC__out __post __deref __exceptthat __maybenull __pre __deref __null 
#define __RPC__deref_out_xcount_part_opt(size, length)  __RPC__deref_out __post __deref __exceptthat __maybenull __pre __deref __null
#define __RPC__deref_out_xcount_full_opt(size)          __RPC__deref_out_opt __pre __deref __null
#define __RPC__deref_out_xcount_full_opt_string(size)   __RPC__deref_out_opt __post __deref __nullterminated __pre __deref __null

#define __RPC__deref_opt_inout_opt                      __deref_opt_inout_opt
#define __RPC__deref_opt_inout_opt_string               __RPC__deref_opt_inout_opt __pre __deref __nullterminated  __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_opt(size)         __deref_opt_inout_ecount_opt(size)  
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) __deref_opt_inout_ecount_part_opt(size, length)
#define __RPC__deref_opt_inout_ecount_full_opt(size)    __RPC__deref_opt_inout_ecount_part_opt(size, size)
#define __RPC__deref_opt_inout_ecount_full_opt_string(size)  __RPC__deref_opt_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_xcount_opt(size)         __deref_opt_inout_opt  
#define __RPC__deref_opt_inout_xcount_part_opt(size, length) __deref_opt_inout_opt
#define __RPC__deref_opt_inout_xcount_full_opt(size)    __RPC__deref_opt_inout_opt
#define __RPC__deref_opt_inout_xcount_full_opt_string(size)  __RPC__deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated

#define __RPC_full_pointer                              __maybenull 
#define __RPC_unique_pointer                            __maybenull
#define __RPC_ref_pointer                               __notnull
#define __RPC_string                                    __nullterminated

#define __RPC__range(min,max)                           __range(min,max)
#define __RPC__in_range(min,max)                        __in_range(min,max)

#else   // not prefast

#define __RPC__range(min,max)
#define __RPC__in_range(min,max)

#define __RPC__in           
#define __RPC__in_string
#define __RPC__in_opt_string
#define __RPC__in_ecount(size) 
#define __RPC__in_ecount_full(size)
#define __RPC__in_ecount_full_string(size)
#define __RPC__in_ecount_part(size, length)
#define __RPC__in_ecount_full_opt(size)
#define __RPC__in_ecount_full_opt_string(size)
#define __RPC__inout_ecount_full_opt_string(size)
#define __RPC__in_ecount_part_opt(size, length)
#define __RPC__in_xcount(size) 
#define __RPC__in_xcount_full(size)
#define __RPC__in_xcount_full_string(size)
#define __RPC__in_xcount_part(size, length)
#define __RPC__in_xcount_full_opt(size)
#define __RPC__in_xcount_full_opt_string(size)
#define __RPC__inout_xcount_full_opt_string(size)
#define __RPC__in_xcount_part_opt(size, length)

#define __RPC__deref_in 
#define __RPC__deref_in_string
#define __RPC__deref_in_opt
#define __RPC__deref_in_opt_string
#define __RPC__deref_opt_in
#define __RPC__deref_opt_in_string
#define __RPC__deref_opt_in_opt
#define __RPC__deref_opt_in_opt_string
#define __RPC__deref_in_ecount(size) 
#define __RPC__deref_in_ecount_part(size, length) 
#define __RPC__deref_in_ecount_full(size) 
#define __RPC__deref_in_ecount_full_opt(size)
#define __RPC__deref_in_ecount_full_string(size)
#define __RPC__deref_in_ecount_full_opt_string(size)
#define __RPC__deref_in_ecount_opt(size) 
#define __RPC__deref_in_ecount_opt_string(size)
#define __RPC__deref_in_ecount_part_opt(size, length) 
#define __RPC__deref_in_xcount(size) 
#define __RPC__deref_in_xcount_part(size, length) 
#define __RPC__deref_in_xcount_full(size) 
#define __RPC__deref_in_xcount_full_opt(size)
#define __RPC__deref_in_xcount_full_string(size)
#define __RPC__deref_in_xcount_full_opt_string(size)
#define __RPC__deref_in_xcount_opt(size) 
#define __RPC__deref_in_xcount_opt_string(size)
#define __RPC__deref_in_xcount_part_opt(size, length) 

// [out]
#define __RPC__out     
#define __RPC__out_ecount(size) 
#define __RPC__out_ecount_part(size, length) 
#define __RPC__out_ecount_full(size)
#define __RPC__out_ecount_full_string(size)
#define __RPC__out_xcount(size) 
#define __RPC__out_xcount_part(size, length) 
#define __RPC__out_xcount_full(size)
#define __RPC__out_xcount_full_string(size)

// [in,out] 
#define __RPC__inout                                   
#define __RPC__inout_string
#define __RPC__opt_inout
#define __RPC__inout_ecount(size)                     
#define __RPC__inout_ecount_part(size, length)    
#define __RPC__inout_ecount_full(size)          
#define __RPC__inout_ecount_full_string(size)          
#define __RPC__inout_xcount(size)                     
#define __RPC__inout_xcount_part(size, length)    
#define __RPC__inout_xcount_full(size)          
#define __RPC__inout_xcount_full_string(size)          

// [in,unique] 
#define __RPC__in_opt       
#define __RPC__in_ecount_opt(size)   
#define __RPC__in_xcount_opt(size)   


// [in,out,unique] 
#define __RPC__inout_opt    
#define __RPC__inout_opt_string    
#define __RPC__inout_ecount_opt(size)  
#define __RPC__inout_ecount_part_opt(size, length) 
#define __RPC__inout_ecount_full_opt(size)     
#define __RPC__inout_ecount_full_string(size)
#define __RPC__inout_xcount_opt(size)  
#define __RPC__inout_xcount_part_opt(size, length) 
#define __RPC__inout_xcount_full_opt(size)     
#define __RPC__inout_xcount_full_string(size)

// [out] **
#define __RPC__deref_out   
#define __RPC__deref_out_string
#define __RPC__deref_out_opt 
#define __RPC__deref_out_opt_string
#define __RPC__deref_out_ecount(size) 
#define __RPC__deref_out_ecount_part(size, length) 
#define __RPC__deref_out_ecount_full(size)  
#define __RPC__deref_out_ecount_full_string(size)
#define __RPC__deref_out_xcount(size) 
#define __RPC__deref_out_xcount_part(size, length) 
#define __RPC__deref_out_xcount_full(size)  
#define __RPC__deref_out_xcount_full_string(size)


// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout    
#define __RPC__deref_inout_string
#define __RPC__deref_inout_opt 
#define __RPC__deref_inout_opt_string
#define __RPC__deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size)
#define __RPC__deref_inout_ecount_opt(size) 
#define __RPC__deref_inout_ecount_part_opt(size, length) 
#define __RPC__deref_inout_ecount_full_opt(size) 
#define __RPC__deref_inout_ecount_full_opt_string(size) 
#define __RPC__deref_inout_xcount_full(size)
#define __RPC__deref_inout_xcount_full_string(size)
#define __RPC__deref_inout_xcount_opt(size) 
#define __RPC__deref_inout_xcount_part_opt(size, length) 
#define __RPC__deref_inout_xcount_full_opt(size) 
#define __RPC__deref_inout_xcount_full_opt_string(size) 

// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout  
#define __RPC__deref_opt_inout_string
#define __RPC__deref_opt_inout_ecount(size)     
#define __RPC__deref_opt_inout_ecount_part(size, length) 
#define __RPC__deref_opt_inout_ecount_full(size) 
#define __RPC__deref_opt_inout_ecount_full_string(size)
#define __RPC__deref_opt_inout_xcount(size)     
#define __RPC__deref_opt_inout_xcount_part(size, length) 
#define __RPC__deref_opt_inout_xcount_full(size) 
#define __RPC__deref_opt_inout_xcount_full_string(size)

#define __RPC__deref_out_ecount_opt(size) 
#define __RPC__deref_out_ecount_part_opt(size, length) 
#define __RPC__deref_out_ecount_full_opt(size) 
#define __RPC__deref_out_ecount_full_opt_string(size)
#define __RPC__deref_out_xcount_opt(size) 
#define __RPC__deref_out_xcount_part_opt(size, length) 
#define __RPC__deref_out_xcount_full_opt(size) 
#define __RPC__deref_out_xcount_full_opt_string(size)

#define __RPC__deref_opt_inout_opt      
#define __RPC__deref_opt_inout_opt_string
#define __RPC__deref_opt_inout_ecount_opt(size)   
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
#define __RPC__deref_opt_inout_ecount_full_opt(size) 
#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 
#define __RPC__deref_opt_inout_xcount_opt(size)   
#define __RPC__deref_opt_inout_xcount_part_opt(size, length) 
#define __RPC__deref_opt_inout_xcount_full_opt(size) 
#define __RPC__deref_opt_inout_xcount_full_opt_string(size) 

#define __RPC_full_pointer  
#define __RPC_unique_pointer
#define __RPC_ref_pointer
#define __RPC_string                               


#endif

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RpcProxy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs.

Compiler switches:

    -DREGISTER_PROXY_DLL
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DENTRY_PREFIX=<prefix>
        String to be prepended on all the DllGetClassObject etc routines
        in dlldata.c.  This includes: DllGetClassObject, DllCanUnloadNow
        and DllMain, DllRegisterServer, and DllUnregisterServer.

    -DNT35_STRICT
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with NT5 beta1+ env from build #1700 on.

#ifndef __RPCPROXY_H_VERSION__
#define __RPCPROXY_H_VERSION__      ( 475 )
#endif // __RPCPROXY_H_VERSION__

#if !defined(_KRPCENV_)

#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define __midl_proxy

#ifdef __REQUIRED_RPCPROXY_H_VERSION__
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif

// If this is the first file included __RPC_WIN64__ is not defined yet.
#if defined(_M_IA64) || defined(_M_AMD64)
#include <pshpack8.h>
#endif

#include <basetsd.h>

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if defined(WIN32) || defined(_M_AMD64)

//We need to define REFIID, REFCLSID, REFGUID, & REFFMTID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#if defined(__cplusplus)
extern "C"
{
#endif

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int __stdcall IIDLookupRtn( const IID * pIID, int * pIndex );
typedef IIDLookupRtn * PIIDLookup;

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4610) // struct can never be instantiated - user defined constructor required
#pragma warning(disable:4510) // default constructor could not be generated
#pragma warning(disable:4512) // assignment operator could not be generated
#endif

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList  *pStubVtblList;
    const PCInterfaceName *         pNamesArray;
    const IID **                    pDelegatedIIDs;
    const PIIDLookup                pIIDLookupRtn;
    unsigned short                  TableSize;
    unsigned short                  TableVersion;
    const IID **                    pAsyncIIDLookup;
    LONG_PTR                        Filler2;
    LONG_PTR                        Filler3;
    LONG_PTR                        Filler4;
}ProxyFileInfo;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

// Macro used for ANSI compatible stubs.

#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void *Vtbl[ n ];                  \
}

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
#if defined( _MSC_VER )
    void *Vtbl[];
#else
    void *Vtbl[1];
#endif
} CInterfaceProxyVtbl;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif

typedef
void
(__RPC_STUB * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer          *   This,
    IRpcChannelBuffer       *   _pRpcChannelBuffer,
    PRPC_MESSAGE                _pRpcMessage,
    DWORD *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID               *   piid;
    const MIDL_SERVER_INFO  *   pServerInfo;
    unsigned long               DispatchTableCount;
    const PRPC_STUB_FUNCTION *  pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader        header;
    IRpcStubBufferVtbl          Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl  *   lpVtbl;
    long                            RefCount;
    const ProxyFileInfo **          pProxyFileList;
    long                            Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

RPCRTAPI
void
RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

RPCRTAPI
void
RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitializePartial(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer,
    unsigned long       RequestedBufferSize);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

RPCRTAPI
void
RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer,
    PMIDL_STUB_MESSAGE  pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrStubErrorHandler(
    DWORD               dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer  *   This,
    REFIID              riid,
    void            **  ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *    This,
    IPSFactoryBuffer *  pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *    This,
    IUnknown *          pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *    This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer  *   This,
    RPCOLEMESSAGE   *   pRpcMsg,
    IRpcChannelBuffer * pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer  *   This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer  *   This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer  *   This,
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer  *   This,
    void *pv);

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);
void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction3(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction4(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction5(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction6(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction7(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction8(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction9(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction10(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction11(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction12(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction13(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction14(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction15(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction16(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction17(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction18(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction19(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction20(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction21(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction22(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction23(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction24(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction25(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction26(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction27(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction28(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction29(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction30(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction31(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction32(void);

#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease

#define CStdAsyncStubBuffer_METHODS              0,0,0,0,0,0,0,0,0,0
#define CStdAsyncStubBuffer_DELEGATING_METHODS   0,0,0,0,0,0,0,0,0,0

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    result = name##_CHECK_IID( split );               \
    if ( result > 0 )                                 \
        { low = sz - split; }                         \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )      \
        result = name##_CHECK_IID( low + split );  \
        if ( result >= 0 )                         \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )  \
    low = low + 1;                                     \
    if (low >= sz)                                     \
        goto not_found_label;                          \
    result = name##_CHECK_IID( low );                  \
    if (result)                                        \
        goto not_found_label;                          \
    found_label: (index) = low; return 1;              \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

// if the user specified a routine prefix, pick it up...
//     if not, add nothing

#ifndef ENTRY_PREFIX

#ifndef DllMain
#define DISABLE_THREAD_LIBRARY_CALLS(x) DisableThreadLibraryCalls(x)
#endif

#define ENTRY_PREFIX
#define DLLREGISTERSERVER_ENTRY DllRegisterServer
#define DLLUNREGISTERSERVER_ENTRY DllUnregisterServer
#define DLLMAIN_ENTRY DllMain

#define DLLGETCLASSOBJECT_ENTRY DllGetClassObject
#define DLLCANUNLOADNOW_ENTRY DllCanUnloadNow

#else   // ENTRY_PREFIX

#define __rpc_macro_expand2(a, b) a##b
#define __rpc_macro_expand(a, b) __rpc_macro_expand2(a,b)
#define DLLREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllRegisterServer)
#define DLLUNREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllUnregisterServer)
#define DLLMAIN_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllMain)

#define DLLGETCLASSOBJECT_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllGetClassObject)
#define DLLCANUNLOADNOW_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllCanUnloadNow)

#endif  // ENTRY_PREFIX

#ifndef DISABLE_THREAD_LIBRARY_CALLS
#define DISABLE_THREAD_LIBRARY_CALLS(x)
#endif

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
*************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        UNREFERENCED_PARAMETER(lpvReserved); \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            { \
            hProxyDll = hinstDLL; \
            DISABLE_THREAD_LIBRARY_CALLS(hinstDLL); \
            } \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID



#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DLLGETCLASSOBJECT_ENTRY ( \
     __in REFCLSID rclsid, \
     __in REFIID riid, \
     __deref_out void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DLLCANUNLOADNOW_ENTRY()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }


#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#if defined(__cplusplus)
} // extern "C"
#endif

#endif // WIN32 or _WIN64_

#if defined(_M_IA64) || defined(_M_AMD64)
#include <poppack.h>
#endif

#endif // __RPCPROXY_H__

#endif // _KRPCENV_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RTSCOM_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rtscom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TPCRTSLib,0xA76A6D34,0xA06D,0x43e1,0x8C,0x05,0x0C,0x56,0xD3,0x6F,0x46,0x2E);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus,0xA8BB5D22,0x3144,0x4a7b,0x93,0xCD,0xF3,0x4A,0x16,0xBE,0x51,0x3A);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus2,0xB5F2A6CD,0x3179,0x4a3e,0xB9,0xC4,0xBB,0x58,0x65,0x96,0x2B,0xE2);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus3,0xD70230A3,0x6986,0x4051,0xB5,0x7A,0x1C,0xF6,0x9F,0x4D,0x9D,0xB5);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylusSynchronization,0xAA87EAB8,0xAB4A,0x4cea,0xB5,0xCB,0x46,0xD8,0x4C,0x6A,0x25,0x09);


MIDL_DEFINE_GUID(IID, IID_IStrokeBuilder,0xA5FD4E2D,0xC44B,0x4092,0x91,0x77,0x26,0x09,0x05,0xEB,0x67,0x2B);


MIDL_DEFINE_GUID(IID, IID_IStylusPlugin,0xA81436D8,0x4757,0x4fd1,0xA1,0x85,0x13,0x3F,0x97,0xC6,0xC5,0x45);


MIDL_DEFINE_GUID(IID, IID_IStylusSyncPlugin,0xA157B174,0x482F,0x4d71,0xA3,0xF6,0x3A,0x41,0xDD,0xD1,0x1B,0xE9);


MIDL_DEFINE_GUID(IID, IID_IStylusAsyncPlugin,0xA7CCA85A,0x31BC,0x4cd2,0xAA,0xDC,0x32,0x89,0xA3,0xAF,0x11,0xC8);


MIDL_DEFINE_GUID(IID, IID_IDynamicRenderer,0xA079468E,0x7165,0x46f9,0xB7,0xAF,0x98,0xAD,0x01,0xA9,0x30,0x09);


MIDL_DEFINE_GUID(IID, IID_IGestureRecognizer,0xAE9EF86B,0x7054,0x45e3,0xAE,0x22,0x31,0x74,0xDC,0x88,0x11,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_RealTimeStylus,0xE26B366D,0xF998,0x43ce,0x83,0x6F,0xCB,0x6D,0x90,0x44,0x32,0xB0);


MIDL_DEFINE_GUID(CLSID, CLSID_DynamicRenderer,0xECD32AEA,0x746F,0x4dcb,0xBF,0x68,0x08,0x27,0x57,0xFA,0xFF,0x18);


MIDL_DEFINE_GUID(CLSID, CLSID_GestureRecognizer,0xEA30C654,0xC62C,0x441f,0xAC,0x00,0x95,0xF9,0xA1,0x96,0x78,0x2C);


MIDL_DEFINE_GUID(CLSID, CLSID_StrokeBuilder,0xE810CEE7,0x6E51,0x4cb0,0xAA,0x3A,0x0B,0x98,0x5B,0x70,0xDA,0xF7);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rpcssl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       rpcssl.h
//
//  Contents:   prototypes for RemoteProcedure Call API functions
//              that use types from wincrypt.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef RPC_UNICODE_SUPPORTED

#ifdef UNICODE
#define RpcCertGeneratePrincipalName RpcCertGeneratePrincipalNameW
#else /* UNICODE */
#define RpcCertGeneratePrincipalName RpcCertGeneratePrincipalNameA
#endif /* UNICODE */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalNameW(
    __in PCCERT_CONTEXT Context,
    __in DWORD Flags,
    __deref_out RPC_WSTR *pBuffer
    );


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalNameA(
    __in PCCERT_CONTEXT       Context,
    __in DWORD                Flags,
    __deref_out RPC_CSTR *    pBuffer
    );

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalName(
    __in PCCERT_CONTEXT Context,
    __in DWORD Flags,
    __deref_out RPC_CSTR *pBuffer
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\rtcerr.h ===
/*****************************************************************************
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* Module Name:
*
*    rtcerr.mc
*
* Abstract:
*
*    Error Messages for RTC Core API
*
*****************************************************************************/
// Possible error codes from SIP interfaces
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SIP_STATUS_CODE         0xEF
#define FACILITY_RTC_INTERFACE           0xEE
#define FACILITY_PINT_STATUS_CODE        0xF0


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_RTC_ERROR        0x2


//
// MessageId: RTC_E_SIP_CODECS_DO_NOT_MATCH
//
// MessageText:
//
// No matching codecs with peer
//
#define RTC_E_SIP_CODECS_DO_NOT_MATCH    ((HRESULT)0x80EE0000L)

//
// MessageId: RTC_E_SIP_STREAM_PRESENT
//
// MessageText:
//
// Parsing SIP failed
// The stream to be started is already present
//
#define RTC_E_SIP_STREAM_PRESENT         ((HRESULT)0x80EE0001L)

//
// MessageId: RTC_E_SIP_STREAM_NOT_PRESENT
//
// MessageText:
//
// The stream to be stopped is not present
//
#define RTC_E_SIP_STREAM_NOT_PRESENT     ((HRESULT)0x80EE0002L)

//
// MessageId: RTC_E_SIP_NO_STREAM
//
// MessageText:
//
// No stream is active
//
#define RTC_E_SIP_NO_STREAM              ((HRESULT)0x80EE0003L)

//
// MessageId: RTC_E_SIP_PARSE_FAILED
//
// MessageText:
//
// Parsing SIP failed
//
#define RTC_E_SIP_PARSE_FAILED           ((HRESULT)0x80EE0004L)

//
// MessageId: RTC_E_SIP_HEADER_NOT_PRESENT
//
// MessageText:
//
// The SIP header is not present in the message
//
#define RTC_E_SIP_HEADER_NOT_PRESENT     ((HRESULT)0x80EE0005L)

//
// MessageId: RTC_E_SDP_NOT_PRESENT
//
// MessageText:
//
// SDP is not present in the SIP message
//
#define RTC_E_SDP_NOT_PRESENT            ((HRESULT)0x80EE0006L)

//
// MessageId: RTC_E_SDP_PARSE_FAILED
//
// MessageText:
//
// Parsing SDP failed
//
#define RTC_E_SDP_PARSE_FAILED           ((HRESULT)0x80EE0007L)

//
// MessageId: RTC_E_SDP_UPDATE_FAILED
//
// MessageText:
//
// SDP does not match the previous one
//
#define RTC_E_SDP_UPDATE_FAILED          ((HRESULT)0x80EE0008L)

//
// MessageId: RTC_E_SDP_MULTICAST
//
// MessageText:
//
// Multicast is not supported
//
#define RTC_E_SDP_MULTICAST              ((HRESULT)0x80EE0009L)

//
// MessageId: RTC_E_SDP_CONNECTION_ADDR
//
// MessageText:
//
// Media does not contain connection address
//
#define RTC_E_SDP_CONNECTION_ADDR        ((HRESULT)0x80EE000AL)

//
// MessageId: RTC_E_SDP_NO_MEDIA
//
// MessageText:
//
// No media is available for the session
//
#define RTC_E_SDP_NO_MEDIA               ((HRESULT)0x80EE000BL)

//
// MessageId: RTC_E_SIP_TIMEOUT
//
// MessageText:
//
// SIP Transaction timed out
//
#define RTC_E_SIP_TIMEOUT                ((HRESULT)0x80EE000CL)

//
// MessageId: RTC_E_SDP_FAILED_TO_BUILD
//
// MessageText:
//
// Failed to build SDP blob
//
#define RTC_E_SDP_FAILED_TO_BUILD        ((HRESULT)0x80EE000DL)

//
// MessageId: RTC_E_SIP_INVITE_TRANSACTION_PENDING
//
// MessageText:
//
// Currently processing another INVITE transaction
//
#define RTC_E_SIP_INVITE_TRANSACTION_PENDING ((HRESULT)0x80EE000EL)

//
// MessageId: RTC_E_SIP_AUTH_HEADER_SENT
//
// MessageText:
//
// Authorization header was sent in a previous request
//
#define RTC_E_SIP_AUTH_HEADER_SENT       ((HRESULT)0x80EE000FL)

//
// MessageId: RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The Authentication type requested is not supported
//
#define RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED ((HRESULT)0x80EE0010L)

//
// MessageId: RTC_E_SIP_AUTH_FAILED
//
// MessageText:
//
// Authentication Failed
//
#define RTC_E_SIP_AUTH_FAILED            ((HRESULT)0x80EE0011L)

//
// MessageId: RTC_E_INVALID_SIP_URL
//
// MessageText:
//
// The SIP URL is not valid
//
#define RTC_E_INVALID_SIP_URL            ((HRESULT)0x80EE0012L)

//
// MessageId: RTC_E_DESTINATION_ADDRESS_LOCAL
//
// MessageText:
//
// The Destination Address belongs to the local machine
//
#define RTC_E_DESTINATION_ADDRESS_LOCAL  ((HRESULT)0x80EE0013L)

//
// MessageId: RTC_E_INVALID_ADDRESS_LOCAL
//
// MessageText:
//
// The Local Address is invalid, check the profile
//
#define RTC_E_INVALID_ADDRESS_LOCAL      ((HRESULT)0x80EE0014L)

//
// MessageId: RTC_E_DESTINATION_ADDRESS_MULTICAST
//
// MessageText:
//
// The Destination Address is a multicast address
//
#define RTC_E_DESTINATION_ADDRESS_MULTICAST ((HRESULT)0x80EE0015L)

//
// MessageId: RTC_E_INVALID_PROXY_ADDRESS
//
// MessageText:
//
// The Proxy Address is not valid
//
#define RTC_E_INVALID_PROXY_ADDRESS      ((HRESULT)0x80EE0016L)

//
// MessageId: RTC_E_SIP_TRANSPORT_NOT_SUPPORTED
//
// MessageText:
//
// The Transport specified is not supported
//
#define RTC_E_SIP_TRANSPORT_NOT_SUPPORTED ((HRESULT)0x80EE0017L)

// SIP internal error codes
//
// MessageId: RTC_E_SIP_NEED_MORE_DATA
//
// MessageText:
//
// Need more data for parsing a whole SIP message
//
#define RTC_E_SIP_NEED_MORE_DATA         ((HRESULT)0x80EE0018L)

//
// MessageId: RTC_E_SIP_CALL_DISCONNECTED
//
// MessageText:
//
// The Call has been disconnected
//
#define RTC_E_SIP_CALL_DISCONNECTED      ((HRESULT)0x80EE0019L)

//
// MessageId: RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT
//
// MessageText:
//
// The Request destination address is not known
//
#define RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT ((HRESULT)0x80EE001AL)

//
// MessageId: RTC_E_SIP_UDP_SIZE_EXCEEDED
//
// MessageText:
//
// The sip message size is greater than the UDP message size allowed
//
#define RTC_E_SIP_UDP_SIZE_EXCEEDED      ((HRESULT)0x80EE001BL)

//
// MessageId: RTC_E_SIP_SSL_TUNNEL_FAILED
//
// MessageText:
//
// Cannot establish SSL tunnel to Http proxy
//
#define RTC_E_SIP_SSL_TUNNEL_FAILED      ((HRESULT)0x80EE001CL)

//
// MessageId: RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT
//
// MessageText:
//
// Timeout during SSL Negotiation
//
#define RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT ((HRESULT)0x80EE001DL)

//
// MessageId: RTC_E_SIP_STACK_SHUTDOWN
//
// MessageText:
//
// Sip Stack is already shutdown
//
#define RTC_E_SIP_STACK_SHUTDOWN         ((HRESULT)0x80EE001EL)

// media error codes
//
// MessageId: RTC_E_MEDIA_CONTROLLER_STATE
//
// MessageText:
//
// Operation not allowed in current media controller state
//
#define RTC_E_MEDIA_CONTROLLER_STATE     ((HRESULT)0x80EE001FL)

//
// MessageId: RTC_E_MEDIA_NEED_TERMINAL
//
// MessageText:
//
// Can not find device
//
#define RTC_E_MEDIA_NEED_TERMINAL        ((HRESULT)0x80EE0020L)

//
// MessageId: RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// Audio device is not available
//
#define RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE ((HRESULT)0x80EE0021L)

//
// MessageId: RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// Video device is not available
//
#define RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE ((HRESULT)0x80EE0022L)

//
// MessageId: RTC_E_START_STREAM
//
// MessageText:
//
// Can not start stream
//
#define RTC_E_START_STREAM               ((HRESULT)0x80EE0023L)

//
// MessageId: RTC_E_MEDIA_AEC
//
// MessageText:
//
// Failed to enable acoustic echo cancellation
//
#define RTC_E_MEDIA_AEC                  ((HRESULT)0x80EE0024L)

// Core error codes
//
// MessageId: RTC_E_CLIENT_NOT_INITIALIZED
//
// MessageText:
//
// Client not initialized
//
#define RTC_E_CLIENT_NOT_INITIALIZED     ((HRESULT)0x80EE0025L)

//
// MessageId: RTC_E_CLIENT_ALREADY_INITIALIZED
//
// MessageText:
//
// Client already initialized
//
#define RTC_E_CLIENT_ALREADY_INITIALIZED ((HRESULT)0x80EE0026L)

//
// MessageId: RTC_E_CLIENT_ALREADY_SHUT_DOWN
//
// MessageText:
//
// Client already shut down
//
#define RTC_E_CLIENT_ALREADY_SHUT_DOWN   ((HRESULT)0x80EE0027L)

//
// MessageId: RTC_E_PRESENCE_NOT_ENABLED
//
// MessageText:
//
// Presence not enabled
//
#define RTC_E_PRESENCE_NOT_ENABLED       ((HRESULT)0x80EE0028L)

//
// MessageId: RTC_E_INVALID_SESSION_TYPE
//
// MessageText:
//
// Invalid session type
//
#define RTC_E_INVALID_SESSION_TYPE       ((HRESULT)0x80EE0029L)

//
// MessageId: RTC_E_INVALID_SESSION_STATE
//
// MessageText:
//
// Invalid session state
//
#define RTC_E_INVALID_SESSION_STATE      ((HRESULT)0x80EE002AL)

//
// MessageId: RTC_E_NO_PROFILE
//
// MessageText:
//
// No valid profile for this operation
//
#define RTC_E_NO_PROFILE                 ((HRESULT)0x80EE002BL)

//
// MessageId: RTC_E_LOCAL_PHONE_NEEDED
//
// MessageText:
//
// A local phone number is needed
//
#define RTC_E_LOCAL_PHONE_NEEDED         ((HRESULT)0x80EE002CL)

//
// MessageId: RTC_E_NO_DEVICE
//
// MessageText:
//
// No preferred device
//
#define RTC_E_NO_DEVICE                  ((HRESULT)0x80EE002DL)

//
// MessageId: RTC_E_INVALID_PROFILE
//
// MessageText:
//
// Invalid profile
//
#define RTC_E_INVALID_PROFILE            ((HRESULT)0x80EE002EL)

//
// MessageId: RTC_E_PROFILE_NO_PROVISION
//
// MessageText:
//
// No provision tag in profile
//
#define RTC_E_PROFILE_NO_PROVISION       ((HRESULT)0x80EE002FL)

//
// MessageId: RTC_E_PROFILE_NO_KEY
//
// MessageText:
//
// No profile key
//
#define RTC_E_PROFILE_NO_KEY             ((HRESULT)0x80EE0030L)

//
// MessageId: RTC_E_PROFILE_NO_NAME
//
// MessageText:
//
// No profile name
//
#define RTC_E_PROFILE_NO_NAME            ((HRESULT)0x80EE0031L)

//
// MessageId: RTC_E_PROFILE_NO_USER
//
// MessageText:
//
// No user tag in profile
//
#define RTC_E_PROFILE_NO_USER            ((HRESULT)0x80EE0032L)

//
// MessageId: RTC_E_PROFILE_NO_USER_URI
//
// MessageText:
//
// No user URI in profile
//
#define RTC_E_PROFILE_NO_USER_URI        ((HRESULT)0x80EE0033L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER
//
// MessageText:
//
// No server tag in profile
//
#define RTC_E_PROFILE_NO_SERVER          ((HRESULT)0x80EE0034L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER_ADDRESS
//
// MessageText:
//
// Server tag missing address in profile
//
#define RTC_E_PROFILE_NO_SERVER_ADDRESS  ((HRESULT)0x80EE0035L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER_PROTOCOL
//
// MessageText:
//
// Server tag missing protocol in profile
//
#define RTC_E_PROFILE_NO_SERVER_PROTOCOL ((HRESULT)0x80EE0036L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_PROTOCOL
//
// MessageText:
//
// Invalid server protocol in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_PROTOCOL ((HRESULT)0x80EE0037L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD
//
// MessageText:
//
// Invalid server authentication method in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD ((HRESULT)0x80EE0038L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_ROLE
//
// MessageText:
//
// Invalid server role in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_ROLE ((HRESULT)0x80EE0039L)

//
// MessageId: RTC_E_PROFILE_MULTIPLE_REGISTRARS
//
// MessageText:
//
// Multiple registrar servers in profile
//
#define RTC_E_PROFILE_MULTIPLE_REGISTRARS ((HRESULT)0x80EE003AL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION
//
// MessageText:
//
// Invalid session tag in profile
//
#define RTC_E_PROFILE_INVALID_SESSION    ((HRESULT)0x80EE003BL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION_PARTY
//
// MessageText:
//
// Invalid session party in profile
//
#define RTC_E_PROFILE_INVALID_SESSION_PARTY ((HRESULT)0x80EE003CL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION_TYPE
//
// MessageText:
//
// Invalid session type in profile
//
#define RTC_E_PROFILE_INVALID_SESSION_TYPE ((HRESULT)0x80EE003DL)

//
// MessageId: RTC_E_OPERATION_WITH_TOO_MANY_PARTICIPANTS
//
// MessageText:
//
// The operation failed because of too many participants in the session
//
#define RTC_E_OPERATION_WITH_TOO_MANY_PARTICIPANTS ((HRESULT)0x80EE003EL)

//
// MessageId: RTC_E_BASIC_AUTH_SET_TLS
//
// MessageText:
//
// Must set transport to TLS if Basic Auth is allowed
//
#define RTC_E_BASIC_AUTH_SET_TLS         ((HRESULT)0x80EE003FL)

//
// MessageId: RTC_E_SIP_HIGH_SECURITY_SET_TLS
//
// MessageText:
//
// Must set transport to TLS if high security mode is needed
//
#define RTC_E_SIP_HIGH_SECURITY_SET_TLS  ((HRESULT)0x80EE0040L)

//
// MessageId: RTC_S_ROAMING_NOT_SUPPORTED
//
// MessageText:
//
// Server does not support this type of roaming
//
#define RTC_S_ROAMING_NOT_SUPPORTED      ((HRESULT)0x00EE0041L)

//
// MessageId: RTC_E_PROFILE_SERVER_UNAUTHORIZED
//
// MessageText:
//
// Server address does not match an authorized domain in profile
//
#define RTC_E_PROFILE_SERVER_UNAUTHORIZED ((HRESULT)0x80EE0042L)

//
// MessageId: RTC_E_DUPLICATE_REALM
//
// MessageText:
//
// Duplicate realm exists in an enabled profile
//
#define RTC_E_DUPLICATE_REALM            ((HRESULT)0x80EE0043L)

//
// MessageId: RTC_E_POLICY_NOT_ALLOW
//
// MessageText:
//
// Current policy settings do not allow this action
//
#define RTC_E_POLICY_NOT_ALLOW           ((HRESULT)0x80EE0044L)

//
// MessageId: RTC_E_PORT_MAPPING_UNAVAILABLE
//
// MessageText:
//
// Port mapping can not be obtained from the port manager
//
#define RTC_E_PORT_MAPPING_UNAVAILABLE   ((HRESULT)0x80EE0045L)

//
// MessageId: RTC_E_PORT_MAPPING_FAILED
//
// MessageText:
//
// Port mapping failure returned from the port manager
//
#define RTC_E_PORT_MAPPING_FAILED        ((HRESULT)0x80EE0046L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_COMPATIBLE
//
// MessageText:
//
// The local and remote security levels are not compatible.
//
#define RTC_E_SECURITY_LEVEL_NOT_COMPATIBLE ((HRESULT)0x80EE0047L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_DEFINED
//
// MessageText:
//
// The security level is not defined
//
#define RTC_E_SECURITY_LEVEL_NOT_DEFINED ((HRESULT)0x80EE0048L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_SUPPORTED_BY_PARTICIPANT
//
// MessageText:
//
// Participant could not support the requested security level
//
#define RTC_E_SECURITY_LEVEL_NOT_SUPPORTED_BY_PARTICIPANT ((HRESULT)0x80EE0049L)

//
// MessageId: RTC_E_DUPLICATE_BUDDY
//
// MessageText:
//
// Buddy already exists
//
#define RTC_E_DUPLICATE_BUDDY            ((HRESULT)0x80EE004AL)

//
// MessageId: RTC_E_DUPLICATE_WATCHER
//
// MessageText:
//
// Watcher already exists
//
#define RTC_E_DUPLICATE_WATCHER          ((HRESULT)0x80EE004BL)

//
// MessageId: RTC_E_MALFORMED_XML
//
// MessageText:
//
// Malformed XML
//
#define RTC_E_MALFORMED_XML              ((HRESULT)0x80EE004CL)

//
// MessageId: RTC_E_ROAMING_OPERATION_INTERRUPTED
//
// MessageText:
//
// Roaming operation interrupted. It may succeed or fail.
//
#define RTC_E_ROAMING_OPERATION_INTERRUPTED ((HRESULT)0x80EE004DL)

//
// MessageId: RTC_E_ROAMING_FAILED
//
// MessageText:
//
// Roaming session failed
//
#define RTC_E_ROAMING_FAILED             ((HRESULT)0x80EE004EL)

//
// MessageId: RTC_E_INVALID_BUDDY_LIST
//
// MessageText:
//
// Buddy list is invalid
//
#define RTC_E_INVALID_BUDDY_LIST         ((HRESULT)0x80EE004FL)

//
// MessageId: RTC_E_INVALID_ACL_LIST
//
// MessageText:
//
// ACL list is invalid
//
#define RTC_E_INVALID_ACL_LIST           ((HRESULT)0x80EE0050L)

//
// MessageId: RTC_E_NO_GROUP
//
// MessageText:
//
// Group does not exist
//
#define RTC_E_NO_GROUP                   ((HRESULT)0x80EE0051L)

//
// MessageId: RTC_E_DUPLICATE_GROUP
//
// MessageText:
//
// Group already exists
//
#define RTC_E_DUPLICATE_GROUP            ((HRESULT)0x80EE0052L)

//
// MessageId: RTC_E_TOO_MANY_GROUPS
//
// MessageText:
//
// Max number of groups has been reached
//
#define RTC_E_TOO_MANY_GROUPS            ((HRESULT)0x80EE0053L)

//
// MessageId: RTC_E_NO_BUDDY
//
// MessageText:
//
// Buddy does not exist
//
#define RTC_E_NO_BUDDY                   ((HRESULT)0x80EE0054L)

//
// MessageId: RTC_E_NO_WATCHER
//
// MessageText:
//
// Watcher does not exist
//
#define RTC_E_NO_WATCHER                 ((HRESULT)0x80EE0055L)

//
// MessageId: RTC_E_NO_REALM
//
// MessageText:
//
// No realm is set
//
#define RTC_E_NO_REALM                   ((HRESULT)0x80EE0056L)

//
// MessageId: RTC_E_NO_TRANSPORT
//
// MessageText:
//
// Server can not be specified without a transport protocol
//
#define RTC_E_NO_TRANSPORT               ((HRESULT)0x80EE0057L)

//
// MessageId: RTC_E_NOT_EXIST
//
// MessageText:
//
// The required item does not exist
//
#define RTC_E_NOT_EXIST                  ((HRESULT)0x80EE0058L)

//
// MessageId: RTC_E_INVALID_PREFERENCE_LIST
//
// MessageText:
//
// Preference list is invalid
//
#define RTC_E_INVALID_PREFERENCE_LIST    ((HRESULT)0x80EE0059L)

//
// MessageId: RTC_E_MAX_PENDING_OPERATIONS
//
// MessageText:
//
// Maximum number of pending operations reached
//
#define RTC_E_MAX_PENDING_OPERATIONS     ((HRESULT)0x80EE005AL)

//
// MessageId: RTC_E_TOO_MANY_RETRIES
//
// MessageText:
//
// Too many attempts to resend a request
//
#define RTC_E_TOO_MANY_RETRIES           ((HRESULT)0x80EE005BL)

//
// MessageId: RTC_E_INVALID_PORTRANGE
//
// MessageText:
//
// Invalid port range
//
#define RTC_E_INVALID_PORTRANGE          ((HRESULT)0x80EE005CL)

//
// MessageId: RTC_E_SIP_CALL_CONNECTION_NOT_ESTABLISHED
//
// MessageText:
//
// Call connection has not been established
//
#define RTC_E_SIP_CALL_CONNECTION_NOT_ESTABLISHED ((HRESULT)0x80EE005DL)

//
// MessageId: RTC_E_SIP_ADDITIONAL_PARTY_IN_TWO_PARTY_SESSION
//
// MessageText:
//
// Adding additional parties to two party session failed
//
#define RTC_E_SIP_ADDITIONAL_PARTY_IN_TWO_PARTY_SESSION ((HRESULT)0x80EE005EL)

//
// MessageId: RTC_E_SIP_PARTY_ALREADY_IN_SESSION
//
// MessageText:
//
// Party already exists in session
//
#define RTC_E_SIP_PARTY_ALREADY_IN_SESSION ((HRESULT)0x80EE005FL)

//
// MessageId: RTC_E_SIP_OTHER_PARTY_JOIN_IN_PROGRESS
//
// MessageText:
//
// Join operation is in progress for another party
//
#define RTC_E_SIP_OTHER_PARTY_JOIN_IN_PROGRESS ((HRESULT)0x80EE0060L)

//
// MessageId: RTC_E_INVALID_OBJECT_STATE
//
// MessageText:
//
// Object state does not allow to perform this operation
//
#define RTC_E_INVALID_OBJECT_STATE       ((HRESULT)0x80EE0061L)

//
// MessageId: RTC_E_PRESENCE_ENABLED
//
// MessageText:
//
// Presence is enabled
//
#define RTC_E_PRESENCE_ENABLED           ((HRESULT)0x80EE0062L)

//
// MessageId: RTC_E_ROAMING_ENABLED
//
// MessageText:
//
// Roaming is enabled
//
#define RTC_E_ROAMING_ENABLED            ((HRESULT)0x80EE0063L)

//
// MessageId: RTC_E_SIP_TLS_INCOMPATIBLE_ENCRYPTION
//
// MessageText:
//
// Incompatible TLS encryption
//
#define RTC_E_SIP_TLS_INCOMPATIBLE_ENCRYPTION ((HRESULT)0x80EE0064L)

//
// MessageId: RTC_E_SIP_INVALID_CERTIFICATE
//
// MessageText:
//
// Invalid certificate
//
#define RTC_E_SIP_INVALID_CERTIFICATE    ((HRESULT)0x80EE0065L)

//
// MessageId: RTC_E_SIP_DNS_FAIL
//
// MessageText:
//
// DNS lookup fails
//
#define RTC_E_SIP_DNS_FAIL               ((HRESULT)0x80EE0066L)

//
// MessageId: RTC_E_SIP_TCP_FAIL
//
// MessageText:
//
// Fails to make a TCP connection
//
#define RTC_E_SIP_TCP_FAIL               ((HRESULT)0x80EE0067L)

//
// MessageId: RTC_E_TOO_SMALL_EXPIRES_VALUE
//
// MessageText:
//
// Expires value received from the server is too small
//
#define RTC_E_TOO_SMALL_EXPIRES_VALUE    ((HRESULT)0x80EE0068L)

//
// MessageId: RTC_E_SIP_TLS_FAIL
//
// MessageText:
//
// Fails to make a TLS connection
//
#define RTC_E_SIP_TLS_FAIL               ((HRESULT)0x80EE0069L)

//
// MessageId: RTC_E_NOT_PRESENCE_PROFILE
//
// MessageText:
//
// A presence profile must be used
//
#define RTC_E_NOT_PRESENCE_PROFILE       ((HRESULT)0x80EE006AL)

//
// MessageId: RTC_E_SIP_INVITEE_PARTY_TIMEOUT
//
// MessageText:
//
// Invitee connection fails
//
#define RTC_E_SIP_INVITEE_PARTY_TIMEOUT  ((HRESULT)0x80EE006BL)

//
// MessageId: RTC_E_SIP_AUTH_TIME_SKEW
//
// MessageText:
//
// Authentication failure because of time skew between client and server
//
#define RTC_E_SIP_AUTH_TIME_SKEW         ((HRESULT)0x80EE006CL)

//
// MessageId: RTC_E_INVALID_REGISTRATION_STATE
//
// MessageText:
//
// Invalid registration state
//
#define RTC_E_INVALID_REGISTRATION_STATE ((HRESULT)0x80EE006DL)

//
// MessageId: RTC_E_MEDIA_DISABLED
//
// MessageText:
//
// Media is disabled
//
#define RTC_E_MEDIA_DISABLED             ((HRESULT)0x80EE006EL)

//
// MessageId: RTC_E_MEDIA_ENABLED
//
// MessageText:
//
// Media is enabled
//
#define RTC_E_MEDIA_ENABLED              ((HRESULT)0x80EE006FL)

//
// MessageId: RTC_E_REFER_NOT_ACCEPTED
//
// MessageText:
//
// Refer has not been accepted
//
#define RTC_E_REFER_NOT_ACCEPTED         ((HRESULT)0x80EE0070L)

//
// MessageId: RTC_E_REFER_NOT_ALLOWED
//
// MessageText:
//
// Refer operation is not allowed in this session
//
#define RTC_E_REFER_NOT_ALLOWED          ((HRESULT)0x80EE0071L)

//
// MessageId: RTC_E_REFER_NOT_EXIST
//
// MessageText:
//
// Refer session does not exist or has finished
//
#define RTC_E_REFER_NOT_EXIST            ((HRESULT)0x80EE0072L)

//
// MessageId: RTC_E_SIP_HOLD_OPERATION_PENDING
//
// MessageText:
//
// Currently an hold operation is pending
//
#define RTC_E_SIP_HOLD_OPERATION_PENDING ((HRESULT)0x80EE0073L)

//
// MessageId: RTC_E_SIP_UNHOLD_OPERATION_PENDING
//
// MessageText:
//
// Currently an unhold operation is pending
//
#define RTC_E_SIP_UNHOLD_OPERATION_PENDING ((HRESULT)0x80EE0074L)

//
// MessageId: RTC_E_MEDIA_SESSION_NOT_EXIST
//
// MessageText:
//
// Media session does not exist
//
#define RTC_E_MEDIA_SESSION_NOT_EXIST    ((HRESULT)0x80EE0075L)

//
// MessageId: RTC_E_MEDIA_SESSION_IN_HOLD
//
// MessageText:
//
// Media session is in hold
//
#define RTC_E_MEDIA_SESSION_IN_HOLD      ((HRESULT)0x80EE0076L)

//
// MessageId: RTC_E_ANOTHER_MEDIA_SESSION_ACTIVE
//
// MessageText:
//
// Another media session is active
//
#define RTC_E_ANOTHER_MEDIA_SESSION_ACTIVE ((HRESULT)0x80EE0077L)

//
// MessageId: RTC_E_MAX_REDIRECTS
//
// MessageText:
//
// Too many redirects
//
#define RTC_E_MAX_REDIRECTS              ((HRESULT)0x80EE0078L)

//
// MessageId: RTC_E_REDIRECT_PROCESSING_FAILED
//
// MessageText:
//
// Processing redirect failed
//
#define RTC_E_REDIRECT_PROCESSING_FAILED ((HRESULT)0x80EE0079L)

//
// MessageId: RTC_E_LISTENING_SOCKET_NOT_EXIST
//
// MessageText:
//
// Listening socket does not exist
//
#define RTC_E_LISTENING_SOCKET_NOT_EXIST ((HRESULT)0x80EE007AL)

//
// MessageId: RTC_E_INVALID_LISTEN_SOCKET
//
// MessageText:
//
// Specified address and port is invalid
//
#define RTC_E_INVALID_LISTEN_SOCKET      ((HRESULT)0x80EE007BL)

//
// MessageId: RTC_E_PORT_MANAGER_ALREADY_SET
//
// MessageText:
//
// Port manager already set
//
#define RTC_E_PORT_MANAGER_ALREADY_SET   ((HRESULT)0x80EE007CL)

//
// MessageId: RTC_E_SECURITY_LEVEL_ALREADY_SET
//
// MessageText:
//
// The security level has already been set for this Media type can and can not be changed
//
#define RTC_E_SECURITY_LEVEL_ALREADY_SET ((HRESULT)0x80EE007DL)

//
// MessageId: RTC_E_UDP_NOT_SUPPORTED
//
// MessageText:
//
// This feature is not supported when one of the server in profile has UDP transport
//
#define RTC_E_UDP_NOT_SUPPORTED          ((HRESULT)0x80EE007EL)

//
// MessageId: RTC_E_SIP_REFER_OPERATION_PENDING
//
// MessageText:
//
// Currently a refer operation is pending
//
#define RTC_E_SIP_REFER_OPERATION_PENDING ((HRESULT)0x80EE007FL)

//
// MessageId: RTC_E_PLATFORM_NOT_SUPPORTED
//
// MessageText:
//
// This operation is not supported on this Windows Platform.
//
#define RTC_E_PLATFORM_NOT_SUPPORTED     ((HRESULT)0x80EE0080L)

//
// MessageId: RTC_E_SIP_PEER_PARTICIPANT_IN_MULTIPARTY_SESSION
//
// MessageText:
//
// A peer participant cannot be added to a multiparty session
//
#define RTC_E_SIP_PEER_PARTICIPANT_IN_MULTIPARTY_SESSION ((HRESULT)0x80EE0081L)

//
// MessageId: RTC_E_NOT_ALLOWED
//
// MessageText:
//
// This action is not allowed
//
#define RTC_E_NOT_ALLOWED                ((HRESULT)0x80EE0082L)

//
// MessageId: RTC_E_REGISTRATION_DEACTIVATED
//
// MessageText:
//
// The user is being moved
//
#define RTC_E_REGISTRATION_DEACTIVATED   ((HRESULT)0x80EE0083L)

//
// MessageId: RTC_E_REGISTRATION_REJECTED
//
// MessageText:
//
// The user's account was disabled or deleted or the SIP URI changed
//
#define RTC_E_REGISTRATION_REJECTED      ((HRESULT)0x80EE0084L)

//
// MessageId: RTC_E_REGISTRATION_UNREGISTERED
//
// MessageText:
//
// The user was logged out because the user logged in elsewhere
//
#define RTC_E_REGISTRATION_UNREGISTERED  ((HRESULT)0x80EE0085L)

// Error codes from SIP status codes
//
// MessageId: RTC_E_STATUS_INFO_TRYING
//
// MessageText:
//
// Trying
//
#define RTC_E_STATUS_INFO_TRYING         ((HRESULT)0x00EF0064L)

//
// MessageId: RTC_E_STATUS_INFO_RINGING
//
// MessageText:
//
// Ringing
//
#define RTC_E_STATUS_INFO_RINGING        ((HRESULT)0x00EF00B4L)

//
// MessageId: RTC_E_STATUS_INFO_CALL_FORWARDING
//
// MessageText:
//
// Call Is Being Forwarded
//
#define RTC_E_STATUS_INFO_CALL_FORWARDING ((HRESULT)0x00EF00B5L)

//
// MessageId: RTC_E_STATUS_INFO_QUEUED
//
// MessageText:
//
// Queued
//
#define RTC_E_STATUS_INFO_QUEUED         ((HRESULT)0x00EF00B6L)

//
// MessageId: RTC_E_STATUS_SESSION_PROGRESS
//
// MessageText:
//
// Session Progress
//
#define RTC_E_STATUS_SESSION_PROGRESS    ((HRESULT)0x00EF00B7L)

//
// MessageId: RTC_E_STATUS_SUCCESS
//
// MessageText:
//
// OK
//
#define RTC_E_STATUS_SUCCESS             ((HRESULT)0x00EF00C8L)

//
// MessageId: RTC_E_STATUS_REDIRECT_MULTIPLE_CHOICES
//
// MessageText:
//
// Multiple Choices
//
#define RTC_E_STATUS_REDIRECT_MULTIPLE_CHOICES ((HRESULT)0x80EF012CL)

//
// MessageId: RTC_E_STATUS_REDIRECT_MOVED_PERMANENTLY
//
// MessageText:
//
// Moved Permanently
//
#define RTC_E_STATUS_REDIRECT_MOVED_PERMANENTLY ((HRESULT)0x80EF012DL)

//
// MessageId: RTC_E_STATUS_REDIRECT_MOVED_TEMPORARILY
//
// MessageText:
//
// Moved Temporarily
//
#define RTC_E_STATUS_REDIRECT_MOVED_TEMPORARILY ((HRESULT)0x80EF012EL)

//
// MessageId: RTC_E_STATUS_REDIRECT_SEE_OTHER
//
// MessageText:
//
// See Other
//
#define RTC_E_STATUS_REDIRECT_SEE_OTHER  ((HRESULT)0x80EF012FL)

//
// MessageId: RTC_E_STATUS_REDIRECT_USE_PROXY
//
// MessageText:
//
// Use Proxy
//
#define RTC_E_STATUS_REDIRECT_USE_PROXY  ((HRESULT)0x80EF0131L)

//
// MessageId: RTC_E_STATUS_REDIRECT_ALTERNATIVE_SERVICE
//
// MessageText:
//
// Alternative Service
//
#define RTC_E_STATUS_REDIRECT_ALTERNATIVE_SERVICE ((HRESULT)0x80EF017CL)

//
// MessageId: RTC_E_STATUS_CLIENT_BAD_REQUEST
//
// MessageText:
//
// Bad Request
//
#define RTC_E_STATUS_CLIENT_BAD_REQUEST  ((HRESULT)0x80EF0190L)

//
// MessageId: RTC_E_STATUS_CLIENT_UNAUTHORIZED
//
// MessageText:
//
// Unauthorized
//
#define RTC_E_STATUS_CLIENT_UNAUTHORIZED ((HRESULT)0x80EF0191L)

//
// MessageId: RTC_E_STATUS_CLIENT_PAYMENT_REQUIRED
//
// MessageText:
//
// Payment Required
//
#define RTC_E_STATUS_CLIENT_PAYMENT_REQUIRED ((HRESULT)0x80EF0192L)

//
// MessageId: RTC_E_STATUS_CLIENT_FORBIDDEN
//
// MessageText:
//
// Forbidden
//
#define RTC_E_STATUS_CLIENT_FORBIDDEN    ((HRESULT)0x80EF0193L)

//
// MessageId: RTC_E_STATUS_CLIENT_NOT_FOUND
//
// MessageText:
//
// Not Found
//
#define RTC_E_STATUS_CLIENT_NOT_FOUND    ((HRESULT)0x80EF0194L)

//
// MessageId: RTC_E_STATUS_CLIENT_METHOD_NOT_ALLOWED
//
// MessageText:
//
// Method Not Allowed
//
#define RTC_E_STATUS_CLIENT_METHOD_NOT_ALLOWED ((HRESULT)0x80EF0195L)

//
// MessageId: RTC_E_STATUS_CLIENT_NOT_ACCEPTABLE
//
// MessageText:
//
// Not Acceptable
//
#define RTC_E_STATUS_CLIENT_NOT_ACCEPTABLE ((HRESULT)0x80EF0196L)

//
// MessageId: RTC_E_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED
//
// MessageText:
//
// Proxy Authentication Required
//
#define RTC_E_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED ((HRESULT)0x80EF0197L)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_TIMEOUT
//
// MessageText:
//
// Request Timeout
//
#define RTC_E_STATUS_CLIENT_REQUEST_TIMEOUT ((HRESULT)0x80EF0198L)

//
// MessageId: RTC_E_STATUS_CLIENT_CONFLICT
//
// MessageText:
//
// Conflict
//
#define RTC_E_STATUS_CLIENT_CONFLICT     ((HRESULT)0x80EF0199L)

//
// MessageId: RTC_E_STATUS_CLIENT_GONE
//
// MessageText:
//
// Gone
//
#define RTC_E_STATUS_CLIENT_GONE         ((HRESULT)0x80EF019AL)

//
// MessageId: RTC_E_STATUS_CLIENT_LENGTH_REQUIRED
//
// MessageText:
//
// Length Required
//
#define RTC_E_STATUS_CLIENT_LENGTH_REQUIRED ((HRESULT)0x80EF019BL)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE
//
// MessageText:
//
// Request Entity Too Large
//
#define RTC_E_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE ((HRESULT)0x80EF019DL)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_URI_TOO_LARGE
//
// MessageText:
//
// Request-URI Too Long
//
#define RTC_E_STATUS_CLIENT_REQUEST_URI_TOO_LARGE ((HRESULT)0x80EF019EL)

//
// MessageId: RTC_E_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE
//
// MessageText:
//
// Unsupported Media Type
//
#define RTC_E_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE ((HRESULT)0x80EF019FL)

//
// MessageId: RTC_E_STATUS_CLIENT_BAD_EXTENSION
//
// MessageText:
//
// Bad Extension
//
#define RTC_E_STATUS_CLIENT_BAD_EXTENSION ((HRESULT)0x80EF01A4L)

//
// MessageId: RTC_E_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE
//
// MessageText:
//
// Temporarily Unavailable
//
#define RTC_E_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE ((HRESULT)0x80EF01E0L)

//
// MessageId: RTC_E_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST
//
// MessageText:
//
// Call Leg/Transaction Does Not Exist
//
#define RTC_E_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST ((HRESULT)0x80EF01E1L)

//
// MessageId: RTC_E_STATUS_CLIENT_LOOP_DETECTED
//
// MessageText:
//
// Loop Detected
//
#define RTC_E_STATUS_CLIENT_LOOP_DETECTED ((HRESULT)0x80EF01E2L)

//
// MessageId: RTC_E_STATUS_CLIENT_TOO_MANY_HOPS
//
// MessageText:
//
// Too Many Hops
//
#define RTC_E_STATUS_CLIENT_TOO_MANY_HOPS ((HRESULT)0x80EF01E3L)

//
// MessageId: RTC_E_STATUS_CLIENT_ADDRESS_INCOMPLETE
//
// MessageText:
//
// Address Incomplete
//
#define RTC_E_STATUS_CLIENT_ADDRESS_INCOMPLETE ((HRESULT)0x80EF01E4L)

//
// MessageId: RTC_E_STATUS_CLIENT_AMBIGUOUS
//
// MessageText:
//
// Ambiguous
//
#define RTC_E_STATUS_CLIENT_AMBIGUOUS    ((HRESULT)0x80EF01E5L)

//
// MessageId: RTC_E_STATUS_CLIENT_BUSY_HERE
//
// MessageText:
//
// Busy Here
//
#define RTC_E_STATUS_CLIENT_BUSY_HERE    ((HRESULT)0x80EF01E6L)

//
// MessageId: RTC_E_STATUS_REQUEST_TERMINATED
//
// MessageText:
//
// Request Terminated
//
#define RTC_E_STATUS_REQUEST_TERMINATED  ((HRESULT)0x80EF01E7L)

//
// MessageId: RTC_E_STATUS_NOT_ACCEPTABLE_HERE
//
// MessageText:
//
// Not Acceptable Here
//
#define RTC_E_STATUS_NOT_ACCEPTABLE_HERE ((HRESULT)0x80EF01E8L)

//
// MessageId: RTC_E_STATUS_SERVER_INTERNAL_ERROR
//
// MessageText:
//
// Server Internal Error
//
#define RTC_E_STATUS_SERVER_INTERNAL_ERROR ((HRESULT)0x80EF01F4L)

//
// MessageId: RTC_E_STATUS_SERVER_NOT_IMPLEMENTED
//
// MessageText:
//
// Not Implemented
//
#define RTC_E_STATUS_SERVER_NOT_IMPLEMENTED ((HRESULT)0x80EF01F5L)

//
// MessageId: RTC_E_STATUS_SERVER_BAD_GATEWAY
//
// MessageText:
//
// Bad Gateway
//
#define RTC_E_STATUS_SERVER_BAD_GATEWAY  ((HRESULT)0x80EF01F6L)

//
// MessageId: RTC_E_STATUS_SERVER_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Service Unavailable
//
#define RTC_E_STATUS_SERVER_SERVICE_UNAVAILABLE ((HRESULT)0x80EF01F7L)

//
// MessageId: RTC_E_STATUS_SERVER_SERVER_TIMEOUT
//
// MessageText:
//
// Server Time-out
//
#define RTC_E_STATUS_SERVER_SERVER_TIMEOUT ((HRESULT)0x80EF01F8L)

//
// MessageId: RTC_E_STATUS_SERVER_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// Version Not Supported
//
#define RTC_E_STATUS_SERVER_VERSION_NOT_SUPPORTED ((HRESULT)0x80EF01F9L)

//
// MessageId: RTC_E_STATUS_GLOBAL_BUSY_EVERYWHERE
//
// MessageText:
//
// Busy Everywhere
//
#define RTC_E_STATUS_GLOBAL_BUSY_EVERYWHERE ((HRESULT)0x80EF0258L)

//
// MessageId: RTC_E_STATUS_GLOBAL_DECLINE
//
// MessageText:
//
// Decline
//
#define RTC_E_STATUS_GLOBAL_DECLINE      ((HRESULT)0x80EF025BL)

//
// MessageId: RTC_E_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE
//
// MessageText:
//
// Does Not Exist Anywhere
//
#define RTC_E_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE ((HRESULT)0x80EF025CL)

//
// MessageId: RTC_E_STATUS_GLOBAL_NOT_ACCEPTABLE
//
// MessageText:
//
// Not Acceptable
//
#define RTC_E_STATUS_GLOBAL_NOT_ACCEPTABLE ((HRESULT)0x80EF025EL)

// Error codes from PINT status codes
//
// MessageId: RTC_E_PINT_STATUS_REJECTED_BUSY
//
// MessageText:
//
// Busy
//
#define RTC_E_PINT_STATUS_REJECTED_BUSY  ((HRESULT)0x80F00005L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_NO_ANSWER
//
// MessageText:
//
// No Answer
//
#define RTC_E_PINT_STATUS_REJECTED_NO_ANSWER ((HRESULT)0x80F00006L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_ALL_BUSY
//
// MessageText:
//
// All Busy
//
#define RTC_E_PINT_STATUS_REJECTED_ALL_BUSY ((HRESULT)0x80F00007L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_PL_FAILED
//
// MessageText:
//
// Primary Leg Failed
//
#define RTC_E_PINT_STATUS_REJECTED_PL_FAILED ((HRESULT)0x80F00008L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_SW_FAILED
//
// MessageText:
//
// Switch Failed
//
#define RTC_E_PINT_STATUS_REJECTED_SW_FAILED ((HRESULT)0x80F00009L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_CANCELLED
//
// MessageText:
//
// Cancelled
//
#define RTC_E_PINT_STATUS_REJECTED_CANCELLED ((HRESULT)0x80F0000AL)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_BADNUMBER
//
// MessageText:
//
// Bad Number
//
#define RTC_E_PINT_STATUS_REJECTED_BADNUMBER ((HRESULT)0x80F0000BL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RrasCfg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Fri Nov 20 18:57:15 1998
 */
/* Compiler settings for rrascfg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rrascfg_h__
#define __rrascfg_h__

/* Forward Declarations */ 

#ifndef __IRouterProtocolConfig_FWD_DEFINED__
#define __IRouterProtocolConfig_FWD_DEFINED__
typedef interface IRouterProtocolConfig IRouterProtocolConfig;
#endif 	/* __IRouterProtocolConfig_FWD_DEFINED__ */


#ifndef __IAuthenticationProviderConfig_FWD_DEFINED__
#define __IAuthenticationProviderConfig_FWD_DEFINED__
typedef interface IAuthenticationProviderConfig IAuthenticationProviderConfig;
#endif 	/* __IAuthenticationProviderConfig_FWD_DEFINED__ */


#ifndef __IAccountingProviderConfig_FWD_DEFINED__
#define __IAccountingProviderConfig_FWD_DEFINED__
typedef interface IAccountingProviderConfig IAccountingProviderConfig;
#endif 	/* __IAccountingProviderConfig_FWD_DEFINED__ */


#ifndef __IEAPProviderConfig_FWD_DEFINED__
#define __IEAPProviderConfig_FWD_DEFINED__
typedef interface IEAPProviderConfig IEAPProviderConfig;
#endif 	/* __IEAPProviderConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "wtypes.h"
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_rrascfg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// RRasCfg.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
 
typedef BYTE __RPC_FAR *PBYTE;



extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_s_ifspec;

#ifndef __IRouterProtocolConfig_INTERFACE_DEFINED__
#define __IRouterProtocolConfig_INTERFACE_DEFINED__

/* interface IRouterProtocolConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IRouterProtocolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB16-D706-11D0-A37B-00C04FC9DA04")
    IRouterProtocolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRouterProtocolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        END_INTERFACE
    } IRouterProtocolConfigVtbl;

    interface IRouterProtocolConfig
    {
        CONST_VTBL struct IRouterProtocolConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRouterProtocolConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRouterProtocolConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRouterProtocolConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRouterProtocolConfig_AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#define IRouterProtocolConfig_RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_AddProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_AddProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_RemoveProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_RemoveProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRouterProtocolConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0011 */
/* [local] */ 

#define DeclareIRouterProtocolConfigMembers(IPURE) \
	STDMETHOD(AddProtocol)(THIS_ LPCOLESTR pszMachineName,\
					   DWORD dwTransportId,\
					   DWORD dwProtocolId,\
					   HWND hWnd,\
					   DWORD dwFlags,\
					   IUnknown *pRouter,\
					   ULONG_PTR uReserved1) IPURE;\
	STDMETHOD(RemoveProtocol)(THIS_ LPCOLESTR pszMachineName,\
						 DWORD dwTransportId,\
						 DWORD dwProtocolId,\
						 HWND hWnd,\
						 DWORD dwFlags,\
						 IUnknown *pRouter,\
						 ULONG_PTR uReserved2) IPURE;\
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_s_ifspec;

#ifndef __IAuthenticationProviderConfig_INTERFACE_DEFINED__
#define __IAuthenticationProviderConfig_INTERFACE_DEFINED__

/* interface IAuthenticationProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAuthenticationProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB17-D706-11D0-A37B-00C04FC9DA04")
    IAuthenticationProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticationProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAuthenticationProviderConfigVtbl;

    interface IAuthenticationProviderConfig
    {
        CONST_VTBL struct IAuthenticationProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticationProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticationProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticationProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticationProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAuthenticationProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAuthenticationProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Initialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Uninitialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Configure_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Activate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Deactivate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticationProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0013 */
/* [local] */ 

#define DeclareIAuthenticationProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	 \
	STDMETHOD(Configure)(THIS_ \
							ULONG_PTR uConnectionParam, \
							HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_s_ifspec;

#ifndef __IAccountingProviderConfig_INTERFACE_DEFINED__
#define __IAccountingProviderConfig_INTERFACE_DEFINED__

/* interface IAccountingProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAccountingProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB18-D706-11D0-A37B-00C04FC9DA04")
    IAccountingProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountingProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAccountingProviderConfigVtbl;

    interface IAccountingProviderConfig
    {
        CONST_VTBL struct IAccountingProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountingProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountingProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountingProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountingProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAccountingProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAccountingProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAccountingProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAccountingProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Initialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Uninitialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Configure_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Activate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Deactivate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountingProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0015 */
/* [local] */ 

#define DeclareIAccountingProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	STDMETHOD(Configure)(THIS_ \
						ULONG_PTR uConnectionParam, \
						HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_s_ifspec;

#ifndef __IEAPProviderConfig_INTERFACE_DEFINED__
#define __IEAPProviderConfig_INTERFACE_DEFINED__

/* interface IEAPProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IEAPProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB19-D706-11D0-A37B-00C04FC9DA04")
    IEAPProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServerInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeCredentialsUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEAPProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServerInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeCredentialsUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);
        
        END_INTERFACE
    } IEAPProviderConfigVtbl;

    interface IEAPProviderConfig
    {
        CONST_VTBL struct IEAPProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEAPProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEAPProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEAPProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEAPProviderConfig_Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)

#define IEAPProviderConfig_Uninitialize(This,dwEapTypeId,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,dwEapTypeId,uConnectionParam)

#define IEAPProviderConfig_ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)	\
    (This)->lpVtbl -> ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)

#define IEAPProviderConfig_RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)	\
    (This)->lpVtbl -> RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)

#define IEAPProviderConfig_RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)	\
    (This)->lpVtbl -> RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Initialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwEapTypeId,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IEAPProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Uninitialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IEAPProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_ServerInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IEAPProviderConfig_ServerInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeCredentialsUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
    /* [in] */ DWORD dwSizeOfUserDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeCredentialsUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEAPProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0017 */
/* [local] */ 

#define DeclareIEAPProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
		LPCOLESTR 	pszMachineName, \
 	DWORD       dwEapTypeId, \
		ULONG_PTR*	puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam) IPURE; \
	STDMETHOD(ServerInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
		HWND 		hWnd, \
		ULONG_PTR 	dwRes1, \
		ULONG_PTR 	dwRes2) IPURE; \
 STDMETHOD(RouterInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND        hwndParent, \
 	DWORD       dwFlags, \
 	BYTE* 		pConnectionDataIn, \
 	DWORD		dwSizeOfConnectionDataIn, \
 	BYTE**		ppConnectionDataOut, \
 	DWORD*		pdwSizeOfConnectionDataOut) IPURE; \
 STDMETHOD(RouterInvokeCredentialsUI)(THIS_  \
 	DWORD   	dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND    	hwndParent, \
 	DWORD   	dwFlags, \
 	BYTE*   	pConnectionDataIn, \
 	DWORD   	dwSizeOfConnectionDataIn, \
 	BYTE*   	pUserDataIn, \
 	DWORD   	dwSizeOfUserDataIn, \
 	BYTE**  	ppUserDataOut, \
 	DWORD*  	pdwSizeOfUserDataOut) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\RtmV2.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rtmv2.h

Abstract:
    Interface for Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  01-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_RTMv2_H__
#define __ROUTING_RTMv2_H__

#pragma once

#include <in6addr.h>

#ifdef __cplusplus
extern "C"
{
#endif

//
// General Constants defined by the API
//

// Max addr size for an address family
#define RTM_MAX_ADDRESS_SIZE         16

//
// Supported Route Table Views
//
#define RTM_MAX_VIEWS                 32

#define RTM_VIEW_ID_UCAST              0
#define RTM_VIEW_ID_MCAST              1

#define RTM_VIEW_MASK_SIZE          0x20

#define RTM_VIEW_MASK_NONE    0x00000000
#define RTM_VIEW_MASK_ANY     0x00000000

#define RTM_VIEW_MASK_UCAST   0x00000001
#define RTM_VIEW_MASK_MCAST   0x00000002

#define RTM_VIEW_MASK_ALL     0xFFFFFFFF

// Identifies a particular view
typedef INT   RTM_VIEW_ID, *PRTM_VIEW_ID;

// Set of views expressed as a mask
typedef DWORD RTM_VIEW_SET, *PRTM_VIEW_SET;


//
// Profile returned during registration
//
typedef struct _RTM_REGN_PROFILE
{
    UINT            MaxNextHopsInRoute; // Max. number of equal cost nexthops
                                        // in a route, & Max. number of local
                                        // nexthops in any one remote nexthop

    UINT            MaxHandlesInEnum;   // Max. handles returned in one call to
                                        // RtmGetEnumDests, RtmGetChangedDests,
                                        // RtmGetEnumRoutes,RtmGetRoutesInElist

    RTM_VIEW_SET    ViewsSupported;     // Views supported by this addr family

    UINT            NumberOfViews;      // Number of views (# 1s in above mask)
}
RTM_REGN_PROFILE, *PRTM_REGN_PROFILE;


//
// Handles pointing to RTMv2 blocks
//
typedef HANDLE      RTM_ENTITY_HANDLE,
                   *PRTM_ENTITY_HANDLE,
                    RTM_DEST_HANDLE,
                   *PRTM_DEST_HANDLE,
                    RTM_ROUTE_HANDLE,
                   *PRTM_ROUTE_HANDLE,
                    RTM_NEXTHOP_HANDLE,
                   *PRTM_NEXTHOP_HANDLE,
                    RTM_ENUM_HANDLE,
                   *PRTM_ENUM_HANDLE,
                    RTM_ROUTE_LIST_HANDLE,
                   *PRTM_ROUTE_LIST_HANDLE,
                    RTM_NOTIFY_HANDLE,
                   *PRTM_NOTIFY_HANDLE;

//
// Network Address struct for any
// address family that works with
// only contiguous address masks
//
typedef struct _RTM_NET_ADDRESS
{
    USHORT AddressFamily;                  // Type of this net address (IPv4..)

    USHORT NumBits;                        // Number of leading bits in prefix

    UCHAR  AddrBits[RTM_MAX_ADDRESS_SIZE]; // Array of bits that form prefix
}
RTM_NET_ADDRESS, *PRTM_NET_ADDRESS;


//
// IPv4 macros to work on addresses
//

#define RTM_IPV4_MAKE_NET_ADDRESS(NetAddress, Addr, Len)           \
        RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)


#define RTM_CHECK_NTH_BIT(Value, N, Len)                           \
        if ((Value) & (1 << (N)))                                  \
        {                                                          \
            (Len) += (N); (Value) <<= (N);                         \
        }                                                          \

#define RTM_IPV4_LEN_FROM_MASK(Len, Mask)                          \
        {                                                          \
            ULONG _Temp_ = ntohl(Mask);                            \
                                                                   \
            (Len) = 0;                                             \
                                                                   \
            RTM_CHECK_NTH_BIT(_Temp_, 16, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  8, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  4, (Len));                  \
                                                                   \
            while (_Temp_)                                         \
            {                                                      \
                (Len) +=  1; _Temp_ <<=  1;                        \
            }                                                      \
        }                                                          \

#define RTM_IPV4_MASK_FROM_LEN(Len)                                \
        ((Len) ? htonl(~0 << (32 - (Len))): 0);                    \


#define RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)           \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (NetAddress)->NumBits  = (USHORT) (Len);                   \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \

#define RTM_IPV4_GET_ADDR_AND_LEN(Addr, Len, NetAddress)           \
        (Len) = (NetAddress)->NumBits;                             \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \


#define RTM_IPV4_SET_ADDR_AND_MASK(NetAddress, Addr, Mask)         \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \
        RTM_IPV4_LEN_FROM_MASK((NetAddress)->NumBits, Mask)

#define RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, NetAddress)         \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \
        (Mask) = RTM_IPV4_MASK_FROM_LEN((NetAddress)->NumBits);    \

//
// IPv6 Helper functions on addresss
//

DWORD
RtmConvertNetAddressToIpv6AddressAndLength(
    IN  PRTM_NET_ADDRESS         pNetAddress,
    OUT PIN6_ADDR                pAddress,
    OUT PDWORD                   pLength,
    IN  DWORD                    dwAddressSize
    );

DWORD
RtmConvertIpv6AddressAndLengthToNetAddress(
    OUT  PRTM_NET_ADDRESS         pNetAddress,
    IN   IN6_ADDR                 Address,
    IN   DWORD                    dwLength,
    IN   DWORD                    dwAddressSize
    );

//
// IPv6 macros to work on addresses
//
#define IPV6_ADDRESS_LEN_IN_BYTES     16

#define RTM_IPV6_MAKE_NET_ADDRESS(NetAddress, Addr, Len)           \
        RTM_IPV6_SET_ADDR_AND_LEN(NetAddress, Addr, Len)

#define RTM_IPV6_SET_ADDR_AND_LEN(NetAddress, Addr, Len)           \
        (NetAddress)->AddressFamily = AF_INET6;                    \
        (RtmConvertIpv6AddressAndLengthToNetAddress(NetAddress, Addr, Len, IPV6_ADDRESS_LEN_IN_BYTES)) \

#define RTM_IPV6_GET_ADDR_AND_LEN(Addr, Len, NetAddress)           \
        (RtmConvertNetAddressToIpv6AddressAndLength(NetAddress, Addr, Len, IPV6_ADDRESS_LEN_IN_BYTES)) \

//
// This structure encapsulates info
// used in comparing any two routes
// [Preference is impt than metric]
//
typedef struct _RTM_PREF_INFO
{
    ULONG               Metric;         // Routing protocol specific metric
    ULONG               Preference;     // Determined by the router policy
}
RTM_PREF_INFO, *PRTM_PREF_INFO;


//
// List of nexthops used for equal
// cost path in a route or nexthop
//
typedef struct _RTM_NEXTHOP_LIST
{
    USHORT              NumNextHops;    // Num of equal cost next hops in list
    RTM_NEXTHOP_HANDLE  NextHops[1];    // NumNextHops num of next hop handles
}
RTM_NEXTHOP_LIST, *PRTM_NEXTHOP_LIST;


//
// Structure used to exchange dest
// information with RTM entities
//
typedef struct _RTM_DEST_INFO
{
    RTM_DEST_HANDLE     DestHandle;       // Handle to the destination

    RTM_NET_ADDRESS     DestAddress;      // Destination network Address

    FILETIME            LastChanged;      // Last time dest was modified

    RTM_VIEW_SET        BelongsToViews;   // View that dest belongs too

    UINT                NumberOfViews;    // Number of view info slots
    struct
    {
        RTM_VIEW_ID         ViewId;       // View ID for this view info block
        UINT                NumRoutes;    // Number of routes,
        RTM_ROUTE_HANDLE    Route;        // Best route with matching criteria
        RTM_ENTITY_HANDLE   Owner;        // Best Route's Owner,
        DWORD               DestFlags;    // Best Route's Flags, and
        RTM_ROUTE_HANDLE    HoldRoute;    // Holddown route,
    }                   ViewInfo[1];      // in each one of the supported views
}
RTM_DEST_INFO, *PRTM_DEST_INFO;

//
// Macros useful in working on dests
//
#define RTM_BASIC_DEST_INFO_SIZE                                         \
    FIELD_OFFSET(RTM_DEST_INFO, ViewInfo)

#define RTM_DEST_VIEW_INFO_SIZE                                          \
    (sizeof(RTM_DEST_INFO) - RTM_BASIC_DEST_INFO_SIZE)

#define RTM_SIZE_OF_DEST_INFO(NumViews)                                  \
    (RTM_BASIC_DEST_INFO_SIZE + (NumViews) * RTM_DEST_VIEW_INFO_SIZE)

//
// Destination Flags
//
#define RTM_DEST_FLAG_NATURAL_NET   0x01
#define RTM_DEST_FLAG_FWD_ENGIN_ADD 0x02
#define RTM_DEST_FLAG_DONT_FORWARD  0x04

//
// Structure used to exchange route
// information with RTM entities
//
typedef struct _RTM_ROUTE_INFO
{
    //
    // Information that the owner can
    // directly access for read only
    //

    RTM_DEST_HANDLE     DestHandle;       // Handle to owning destination

    RTM_ENTITY_HANDLE   RouteOwner;       // Entity the owns this route

    RTM_NEXTHOP_HANDLE  Neighbour;        // Neighbour we learnt route from

    UCHAR               State;            // See RTM_ROUTE_STATE_* below

    //
    // Information that the owner can
    // directly access for read/write
    //

    UCHAR 