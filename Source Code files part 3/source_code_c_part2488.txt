| msg.message==WM_PAINTICON) {
			iface->TranslateAndDispatchMAXMessage(msg);
			}
		}
	return TRUE;
	}

 
int  ACubicDlg::Progress(int done, int total) {
	if (!CheckWindowMessages(hPanel)) 
	   return RENDPROG_ABORT;
	else 
		return RENDPROG_CONTINUE;
	}

BOOL ACubicDlg::KeyAtCurTime(int id) { return theTex->pblock->KeyFrameAtTime(id,ip->GetTime()); }

void ACubicDlg::LoadDialog(BOOL draw) {
	if (theTex) {
		Interval valid;
		theTex->Update(curTime,valid);
		sizeSpin->SetValue(theTex->size,FALSE);
		blurSpin->SetValue(theTex->blur,FALSE);
		blurOffSpin->SetValue(theTex->blurOff,FALSE);
		nthSpin->SetValue(theTex->nth,FALSE);
		nearSpin->SetValue(theTex->nearRange,FALSE);
		farSpin->SetValue(theTex->farRange,FALSE);

		sizeSpin->SetKeyBrackets(KeyAtCurTime(PB_SIZE));
		blurSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUR));
		blurOffSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUROFF));
		nearSpin->SetKeyBrackets(KeyAtCurTime(PB_NEAR));
		farSpin->SetKeyBrackets(KeyAtCurTime(PB_FAR));
		
		CheckRadioButton( hPanel, IDC_FIRST_ONLY, IDC_EVERY_NTH, IDC_FIRST_ONLY+theTex->do_nth);
		StuffOutName();
		SetCheckBox(hPanel, IDC_ACUBE_BLUR, theTex->applyBlur);
		SetCheckBox(hPanel, IDC_USE_ENVMAP, theTex->useEnvMap);
		for (int i=0; i<6; i++) StuffDlgName(i);
		SetUseFile(theTex->useFile);
		MaybeEnablePick();
		}
	}

void ACubicDlg::SetThing(ReferenceTarget *m) {
	ip->EndPickMode();
	assert (m->ClassID()==acubicClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
	if (theTex) theTex->paramDlg = NULL;
	theTex = (ACubic *)m;
	if (theTex) theTex->paramDlg = this;
	LoadDialog(TRUE);
	}


void ACubicDlg::StuffDlgName(int i) {
	TSTR fname;
	TSTR fullName = theTex->fileNames[i];
	SplitPathFile(fullName,NULL,&fname);
	iFile[i]->SetText(fname);
	//SetDlgItemText(hPanel, fileButtonID[i], fname);
	}

void ACubicDlg::StuffOutName() {
	TSTR fname;
	TSTR fullName = theTex->biOutFile.Name();
	SplitPathFile(fullName,NULL,&fname);
	SetDlgItemText(hPanel, IDC_CUBE_OUTFILE_NAME, fname);
	}
 
void ACubicDlg::BrowseInFile(int id) {
	int iside = SideFromID(id);
	theTex->biInFile.SetName(theTex->fileNames[iside].data());
	BOOL silent = TheManager->SetSilentMode(TRUE);
	int res = TheManager->SelectFileInputEx(&theTex->biInFile,hPanel,getCubeName(iside));
	TheManager->SetSilentMode(silent);
	if (res) {
		TSTR fullName = theTex->biInFile.Name();
		TSTR path;
		TSTR file;
		TSTR ext;
		if (theTex->fileNames[iside]==fullName) 
			goto done;
		theTex->fileNames[iside] = fullName;
		StuffDlgName(iside);
		SplitFilename(fullName,&path, &file, &ext);
		int n = file.Length();
		if (n>=3) {
			TSTR suf = file.Substr(n-3,3);
			suf.toUpper();
			if (_tcscmp(suffixes[iside],suf)==0) {
				file = file.Substr(0,n-3);
				for (int i=0; i<6; i++) {
					fullName.printf(_T("%s\\%s%s%s"),path.data(),file.data(),suffixes[i],ext.data());
					theTex->fileNames[i] = fullName;
					StuffDlgName(i);
					if (theTex->useFile) {
						theTex->FreeMaps();
						theTex->NotifyChanged();
						}
					}
				}
			else {
				theTex->fileNames[iside] = fullName;
				StuffDlgName(iside);
				}
			}
		}
done:
	theTex->biInFile.SetName(_T(""));
	}



void ACubicDlg::BrowseOutFile() {
	BOOL silent = TheManager->SetSilentMode(TRUE);
	int res = TheManager->SelectFileOutput(&theTex->biOutFile,hPanel,GetString(IDS_DS_SELECT_UPFILE));
	TheManager->SetSilentMode(silent);
	if (res) {
		TSTR fullName = theTex->biOutFile.Name();
		TSTR path;
		TSTR file;
		TSTR ext;
		SplitFilename(fullName,&path, &file, &ext);
		int n = file.Length();
		if (n>=3) {
			TSTR suf = file.Substr(n-3,3);
			suf.toUpper();
			if (_tcscmp(suffixes[0],suf)!=0) {
				for (int i=1; i<6; i++) {
					if (_tcscmp(suffixes[i],suf)==0) {
						file = file.Substr(0,n-3);
						break;
						}
					}
				file += suffixes[0];
				}
			}
		else {
			file += suffixes[0];
			}
		fullName.printf(_T("%s\\%s%s"),path.data(),file.data(),ext.data());
		theTex->biOutFile.SetName(fullName);
		StuffOutName();
		}
	}


int ACubicDlg::FindFileFromHWND(HWND hw) {
	for (int i=0; i<6; i++) {
		if (hw == iFile[i]->GetHwnd()) return i;
		}	
	return -1;
	}


ReferenceTarget *ACubicDlg::GetInstance(HWND hwnd, POINT p, SClass_ID type) {
	DADBitmapCarrier *bmc = GetDADBitmapCarrier();
	int i = FindFileFromHWND(hwnd);
	if (i<0) return NULL;
	bmc->SetName(theTex->fileNames[i]);
	return bmc;
	}

void ACubicDlg::Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
	if (dropThis->SuperClassID()!=BITMAPDAD_CLASS_ID) 
		return;
	int i = FindFileFromHWND(hwnd);
	if (i<0) return;
	DADBitmapCarrier *bmc = (DADBitmapCarrier *)dropThis;
	theTex->fileNames[i] = bmc->GetName();
	StuffDlgName(i);
	}
*/


//-----------------------------------------------------------------------------
//  ACubic
//-----------------------------------------------------------------------------

class ACubicAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t);    // set from v
};



static ACubicAccessor acubic_accessor;


static ParamBlockDesc2 acubic_param_blk ( acubic_params, _T("parameters"),  0, &acubicCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_AUTO_CUBIC, IDS_DS_ACUBIC_PARAMS, 0, 0, NULL, 
	// params
	acubic_size,	_T("size"),   TYPE_INT,			P_ANIMATABLE,	IDS_RB_SIZE,
		p_default,		100,
		p_range,		1, 5000,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_ACUBE_SIZE_EDIT, IDC_ACUBE_SIZE_SPIN, 1.0f, 
		end,
	acubic_blur,	_T("blur"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_BLUR,
		p_default,		1.f,
		p_range,		0.f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_ACUBE_BLUR_EDIT, IDC_ACUBE_BLUR_SPIN, .01f, 
		end,
	acubic_bluroffset,	_T("blurOffset"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_BLUROFFS,
		p_default,		0.f,
		p_range,		0.f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_ACUBE_BLUOFF_EDIT, IDC_ACUBE_BLUROFF_SPIN, .001f, 
		end,
	acubic_near,	_T("near"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_FALLNEAR,
		p_default,		0.f,
		p_range,		0.0f,10000.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_ACUBE_NEAR_EDIT, IDC_ACUBE_NEAR_SPIN, 1.0f, 
		p_dim, 			stdWorldDim,
		end,

	acubic_far,		_T("far"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_FALLFAR,
		p_default,		500.f,
		p_range,		0.0f,10000.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_ACUBE_FAR_EDIT, IDC_ACUBE_FAR_SPIN, 1.0f, 
		p_dim, 			stdWorldDim,
		end,

	acubic_source, _T("source"), TYPE_INT,				0,			IDS_PW_SOURCE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_CUBESRC_AUTO, IDC_CUBESRC_FILE,
		p_accessor,		&acubic_accessor,
		end,

	acubic_useatmospheric,	_T("useAtmosphericMap"), TYPE_BOOL,			0,		IDS_PW_USEATMOSPHERIC,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_USE_ENVMAP,
		p_accessor,		&acubic_accessor,
		end,
	acubic_applyblur,	_T("apply"), TYPE_BOOL,			0,		IDS_PW_APPLY,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_ACUBE_BLUR,
		p_accessor,		&acubic_accessor,
		end,

	acubic_frametype, _T("frametype"), TYPE_INT,				0,			IDS_PW_FRAMETYPE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_FIRST_ONLY, IDC_EVERY_NTH,
		end,

	acubic_nthframe,		_T("nthframe"),   TYPE_INT,			0,	IDS_PW_NTHFRAME,
		p_default,		1,
		p_range,		1,1000,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_ACUBE_NTH_EDIT, IDC_ACUBE_NTH_SPIN, 1.0f, 
		end,

	acubic_bitmap_names,	_T("bitmapName"),   TYPE_STRING_TAB,		6,	0,	IDS_DS_BITMAP,
		p_enabled,		FALSE,
//		p_ui, 			TYPE_BITMAPBUTTON, IDC_FILE_UP,IDC_FILE_DN,IDC_FILE_LF,IDC_FILE_RT,IDC_FILE_FR,IDC_FILE_BK,
		end,

	acubic_outputname,		_T("outputname"),   TYPE_STRING,			0,	IDS_PW_OUTPUTNAME,
		end,

	end
);



class ACubicDlgProc;

void ACubicAccessor::Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
{
ACubic* p = (ACubic*)owner;
switch (id)
	{
/*
	case acubic_camera:
		{

		if (v.r!= NULL)
			{
			INode *node =  (INode*) v.r;
			ObjectState os = node->EvalWorldState(t);
			if (os.obj->SuperClassID()==CAMERA_CLASS_ID) 
				{
				CameraState cs;
				Interval iv;
				CameraObject *cam = (CameraObject *)os.obj;
				cam->EvalCameraState(t,iv,&cs);
				p->SetNearRange(cs.nearRange,t);
				p->SetFarRange(cs.farRange,t);
				}
//			Interval iv;
//			p->pblock->SetValue(acubic_camera,t,NULL);
			}
		v.r = NULL;
		break;
		}
	case acubic_node:
		{
		if (v.r!= NULL)
			{
			p->RenderCubicMap((INode*)v.r);
//			Interval iv;
//			p->pblock->SetValue(acubic_node,t,NULL);
			p->pblock->RefDeleted(acubic_node);
			}
		v.r = NULL;
		break;
		}
*/
	case acubic_source:
		{
		if (v.i == 0)
			{
			if (p->pblock != NULL)
				{
				p->useFile = FALSE;
				p->UpdateInterface(FALSE);
				}
			}
		else
			{
			if (p->pblock != NULL)
				{
				p->useFile = TRUE;
				p->UpdateInterface(TRUE);
				}
			}
		break;
		}

	}
}



#define NPARAMS 5
#define ACUBIC_VERSION 4


// Version 1 desc
static ParamBlockDescID pbdesc1[] = {
	{ TYPE_INT, NULL, TRUE,acubic_size }, 	// size
	{ TYPE_FLOAT, NULL, TRUE,acubic_blur } 	// blur
	};

// Version 2 desc
static ParamBlockDescID pbdesc2[] = {
	{ TYPE_INT, NULL, TRUE,acubic_size }, 	// size
	{ TYPE_FLOAT, NULL, TRUE,acubic_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,acubic_bluroffset } 	// blurOffs
	};


static ParamBlockDescID pbdesc[] = {
	{ TYPE_INT,  NULL,  TRUE,acubic_size }, 	// size
	{ TYPE_FLOAT, NULL, TRUE,acubic_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,acubic_bluroffset }, 	// blurOffs
	{ TYPE_FLOAT, NULL, TRUE,acubic_near },	// near
	{ TYPE_FLOAT, NULL, TRUE,acubic_far } 	// far
	};


static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc1,2,1),	// Version 1 params
	ParamVersionDesc(pbdesc2,3,2),	// Version 2 params
	ParamVersionDesc(pbdesc, 5,3),	// Version 2 params
	};
#define NUM_OLDVERSIONS	3



static int fileButtonID[6]={IDC_FILE_UP,IDC_FILE_DN,IDC_FILE_LF,IDC_FILE_RT,IDC_FILE_FR,IDC_FILE_BK};
static int SideFromID(int id) {
	for (int i=0; i<6; i++) if (fileButtonID[i]==id) return i;
	return 0;
	}



class PickControlNode : 
		public PickObjectProc
//		public PickModeCallback
		 {
	public:				
		ACubic *theTex;
		BOOL pickCam;
		HWND hWnd;
		PickControlNode() {theTex=NULL;}
//		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL Pick(INode *node);		
		void EnterMode();
		void ExitMode();		
		BOOL Filter(INode *node);
	};


BOOL PickControlNode::Filter(INode *node)
	{
	if (pickCam)
		{
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID()==CAMERA_CLASS_ID) 
			return TRUE;
		return FALSE;
		}

	else return TRUE;
/*	node->BeginDependencyTest();
	mod->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) {		
		return FALSE;
	} else {
		return TRUE;
		}
*/
	}
/*
BOOL PickControlNode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	if (ip->PickNode(hWnd,m,this)) {
		return TRUE;
	} else {
		return FALSE;
		}
	}
*/
BOOL PickControlNode::Pick(INode *node)
	{

	if (node) {
		if (pickCam)
			{
			ObjectState os = node->EvalWorldState(GetCOREInterface()->GetTime());
			if (os.obj->SuperClassID()==CAMERA_CLASS_ID) 
				{
				CameraState cs;
				Interval iv;
				CameraObject *cam = (CameraObject *)os.obj;
				cam->EvalCameraState(GetCOREInterface()->GetTime(),iv,&cs);
				theTex->SetNearRange(cs.nearRange,GetCOREInterface()->GetTime());
				theTex->SetFarRange(cs.farRange,GetCOREInterface()->GetTime());
				}
			}
		else
			{
			theTex->RenderCubicMap(node);

			}


		}
	return TRUE;
	}

void PickControlNode::EnterMode()
	{
	ICustButton *iBut ;
	if(pickCam)
		iBut = GetICustButton(GetDlgItem(hWnd,IDC_ACUBE_PICKCAM));
	else iBut = GetICustButton(GetDlgItem(hWnd,IDC_CUBE_PICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void PickControlNode::ExitMode()
	{
	ICustButton *iBut ;
	if(pickCam)
		iBut = GetICustButton(GetDlgItem(hWnd,IDC_ACUBE_PICKCAM));
	else iBut = GetICustButton(GetDlgItem(hWnd,IDC_CUBE_PICK));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}

static PickControlNode thePickMode;


//dialog stuff to get the Set Ref button
class ACubicDlgProc : public ParamMap2UserDlgProc, public DADMgr {
//public ParamMapUserDlgProc {
	public:
		HWND hPanel;
		ACubic *theTex;		
		ICustButton *iFile[6];
		ICustButton *oFile; // mjm - 1.26.99
//		ICustButton *iPick;
		ICustButton *iPick,*iCamPick;

		BOOL camPick;


		ACubicDlgProc(ACubic *m) {
			theTex = m;
			for (int i=0; i<6; i++) {
				iFile[i] = NULL;	
				}
			oFile = NULL; // mjm - 1.26.99
			iPick = NULL;
			iCamPick = NULL;

			}		
		~ACubicDlgProc() {
			Destroy();
			}

		void Destroy() { 
			if (theTex->ip)
				theTex->ip->EndPickMode();
			if (iPick)
				ReleaseICustButton(iPick);	
			iPick = NULL; 
			if (iCamPick)
				ReleaseICustButton(iCamPick);	
			iCamPick = NULL; 

			for (int i=0; i<6; i++) {
				if (iFile)
					ReleaseICustButton(iFile[i]);
				iFile[i] = NULL;	
				}
			if (oFile) ReleaseICustButton(oFile); // mjm - 1.26.99
			oFile = NULL; // mjm - 1.26.99
			}


		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void BrowseOutFile();
		void StuffOutName();
		void BrowseInFile(int id);

		void StuffDlgName(int i);
		int FindFileFromHWND(HWND hw);


		void SetUseFile(BOOL onOff);
		void MaybeEnablePick(); 

		void DeleteThis() {delete this;}





		// DADMgr methods
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return BITMAPDAD_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
			if (hfrom==hto) return FALSE;
			return (type==BITMAPDAD_CLASS_ID)?1:0;
			}
		int SlotOwner() { return OWNER_MTL_TEX;	}
	    ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		BOOL  LetMeHandleLocalDAD() { return 0; } 

		void SetThing(ReferenceTarget *m) {
			theTex = (ACubic*)m;
//			ReloadDialog();
			}


	};



void ACubicDlgProc::StuffDlgName(int i) {
	TSTR fname;
	TSTR fullName = theTex->fileNames[i];
	SplitPathFile(fullName,NULL,&fname);
	iFile[i]->SetText(fname);
	//SetDlgItemText(hPanel, fileButtonID[i], fname);
	}


int ACubicDlgProc::FindFileFromHWND(HWND hw) {
	if (hw == oFile->GetHwnd())
		return NUM_SRC_FILES; // outfile

	for (int i=0; i<NUM_SRC_FILES; i++)
	{
		if (hw == iFile[i]->GetHwnd())
			return i; // one of the infiles
	}
	return -1; // no file
}


ReferenceTarget *ACubicDlgProc::GetInstance(HWND hwnd, POINT p, SClass_ID type)
{
	DADBitmapCarrier *bmc = GetDADBitmapCarrier();
	int i = FindFileFromHWND(hwnd);
	if (i<0)
		return NULL;
// mjm - begin - 2.2.99
	else if (i == NUM_SRC_FILES) // outfile
	{
		TCHAR *name;
		theTex->pblock->GetValue(acubic_outputname,0,name,FOREVER);
		TSTR nameStr = name;
		bmc->SetName(nameStr);
	}
	else // one of the infiles
// mjm - end
		bmc->SetName(theTex->fileNames[i]);
	return bmc;
}

void ACubicDlgProc::Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
	if (dropThis->SuperClassID()!=BITMAPDAD_CLASS_ID) 
		return;
	int i = FindFileFromHWND(hwnd);
	if (i<0)
		return;
// mjm - begin - 2.2.99
	else if (i == NUM_SRC_FILES) // outfile
	{
		DADBitmapCarrier *bmc = (DADBitmapCarrier *)dropThis;
		theTex->pblock->SetValue(acubic_outputname,0,bmc->GetName());
		StuffOutName();
	}
	else // one of the infiles
// mjm - end
	{
		DADBitmapCarrier *bmc = (DADBitmapCarrier *)dropThis;
		theTex->fileNames[i] = bmc->GetName();
		StuffDlgName(i);
	}
}



void ACubicDlgProc::StuffOutName() {
	TSTR fname;
	TCHAR *name;
	Interval iv;
	theTex->pblock->GetValue(acubic_outputname,0,name,iv);
//	TSTR fullName = theTex->biOutFile.Name();
	TSTR fullName = name;
	SplitPathFile(fullName,NULL,&fname);
	oFile->SetText(fname); // mjm - 1.26.99
//	SetDlgItemText(hPanel, IDC_CUBE_OUTFILE_NAME, fname); // mjm - 1.26.99
	}
 


void ACubicDlgProc::BrowseOutFile() {
	BOOL silent = TheManager->SetSilentMode(TRUE);
	int res = TheManager->SelectFileOutput(&theTex->biOutFile,hPanel,GetString(IDS_DS_SELECT_UPFILE));
	TheManager->SetSilentMode(silent);
	if (res) {
		TSTR fullName = theTex->biOutFile.Name();
		TSTR path;
		TSTR file;
		TSTR ext;
		SplitFilename(fullName,&path, &file, &ext);
		int n = file.Length();
		if (n>=3) {
			TSTR suf = file.Substr(n-3,3);
			suf.toUpper();
			if (_tcscmp(suffixes[0],suf)!=0) {
				for (int i=1; i<6; i++) {
					if (_tcscmp(suffixes[i],suf)==0) {
						file = file.Substr(0,n-3);
						break;
						}
					}
				file += suffixes[0];
				}
			}
		else {
			file += suffixes[0];
			}
		fullName.printf(_T("%s\\%s%s"),path.data(),file.data(),ext.data());
		theTex->biOutFile.SetName(fullName);
		theTex->pblock->SetValue(acubic_outputname,0,fullName);
		StuffOutName();
		theTex->UpdateInterface(theTex->useFile);
		}
	}

void ACubicDlgProc::BrowseInFile(int id) {
	int iside = SideFromID(id);
	theTex->biInFile.SetName(theTex->fileNames[iside].data());
	BOOL silent = TheManager->SetSilentMode(TRUE);
	int res = TheManager->SelectFileInputEx(&theTex->biInFile,hPanel,GetString(IDS_ACUBIC_SELECT_INPUT_FILE));
//	int res = TheManager->SelectFileInputEx(&theTex->biInFile,hPanel,getCubeName(iside));
	TheManager->SetSilentMode(silent);
	if (res) {
		TSTR fullName = theTex->biInFile.Name();
		TSTR path;
		TSTR file;
		TSTR ext;
		if (theTex->fileNames[iside]==fullName) 
			goto done;
		theTex->fileNames[iside] = fullName;
		theTex->pblock->SetValue(acubic_bitmap_names,0,fullName,iside);
		StuffDlgName(iside);
		SplitFilename(fullName,&path, &file, &ext);
		int n = file.Length();
		if (n>=3) {
			TSTR suf = file.Substr(n-3,3);
			suf.toUpper();
			if (_tcscmp(suffixes[iside],suf)==0) {
				file = file.Substr(0,n-3);
				for (int i=0; i<6; i++) {
					fullName.printf(_T("%s\\%s%s%s"),path.data(),file.data(),suffixes[i],ext.data());
					theTex->fileNames[i] = fullName;
					theTex->pblock->SetValue(acubic_bitmap_names,0,fullName,i);
					StuffDlgName(i);
					if (theTex->useFile) {
						theTex->FreeMaps();
						theTex->NotifyChanged();
						}
					}
				}
			else {
				theTex->fileNames[iside] = fullName;
				theTex->pblock->SetValue(acubic_bitmap_names,0,fullName,iside);
				StuffDlgName(iside);
				}
			}
		}
done:
	theTex->biInFile.SetName(_T(""));
	}



BOOL ACubicDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	hPanel = hWnd;
	switch (msg) {

		case WM_INITDIALOG:
			{

			iPick = GetICustButton(GetDlgItem(hWnd,IDC_CUBE_PICK));
			iPick->SetType(CBT_CHECK);
			iPick->SetHighlightColor(GREEN_WASH);

			iCamPick = GetICustButton(GetDlgItem(hWnd,IDC_ACUBE_PICKCAM));
			iCamPick->SetType(CBT_CHECK);
			iCamPick->SetHighlightColor(GREEN_WASH);

			for (int i=0; i<6; i++) {
				iFile[i] = GetICustButton(GetDlgItem(hWnd,fileButtonID[i]));
				iFile[i]->SetDADMgr(this);
				}

			oFile = GetICustButton( GetDlgItem(hWnd,IDC_CUBE_OUTFILE_NAME) ); // mjm - 1.26.99
			oFile->SetDADMgr(this);

			for (i=0; i<6; i++) 
				StuffDlgName(i);
			StuffOutName();

			return TRUE;
			}
			break;

		case WM_DESTROY:
			Destroy();
			break;


		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_FILE_UP:
				case IDC_FILE_DN:
				case IDC_FILE_LF:
				case IDC_FILE_RT:
				case IDC_FILE_FR:
				case IDC_FILE_BK:
					{
					BrowseInFile(LOWORD(wParam));
					break;
					}

				case IDC_CUBE_RELOAD:
					{
					theTex->FreeMaps();
					theTex->NotifyChanged();

//					check->SwapInputs();
					break;
					}

				case IDC_CUBE_OUTFILE_NAME:
					{
					BrowseOutFile();
					break;
					}
				case IDC_ACUBE_PICKCAM:
					{
					theTex->ip->EndPickMode();
					thePickMode.hWnd  = hWnd;					
					thePickMode.pickCam  = TRUE;					
					thePickMode.theTex = theTex;
					theTex->ip->SetPickMode(&thePickMode);
					break;
					}
				case IDC_CUBE_PICK:
					{
					theTex->ip->EndPickMode();
					thePickMode.hWnd  = hWnd;					
					thePickMode.pickCam  = FALSE;					
					thePickMode.theTex = theTex;
					theTex->ip->SetPickMode(&thePickMode);
					break;
					}

				}
			break;
		}
	return FALSE;
	}

void ACubicDlgProc::SetUseFile(BOOL onOff) {

	// AUTO STUFF
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_AUTO_GRP), !onOff);
//	EnableWindow(GetDlgItem(hPanel,IDC_FIRST_ONLY), !onOff);
//	EnableWindow(GetDlgItem(hPanel,IDC_EVERY_NTH), !onOff);

	IParamMap2 *map = theTex->pblock->GetMap();
	map->Enable(acubic_nthframe, !onOff);
	map->Enable(acubic_frametype, !onOff);
	map->Enable(acubic_nthframe, !onOff);

//	if (onOff) nthSpin->Disable(); else nthSpin->Enable();

	//FILE STUFF
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_RELOAD), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FILE_GRP), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FILE_GRP2), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_OUTFILE), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_OUTFILE_NAME), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_UP), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_DN), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_LF), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_RT), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_BK), onOff);
	EnableWindow(GetDlgItem(hPanel,IDC_CUBE_FR), onOff);

	for (int i=0; i<6; i++) 
		iFile[i]->Enable(onOff);
	oFile->Enable(onOff); // mjm - 1.26.99
	MaybeEnablePick();
	}

void ACubicDlgProc::MaybeEnablePick() {
	if (!theTex->useFile) {
		IParamMap2 *map = theTex->pblock->GetMap();
//		map->Enable(acubic_node, FALSE);
		iPick->Enable(FALSE);
		return;
		}
	TCHAR *name=NULL;
	Interval iv;
	theTex->pblock->GetValue(acubic_outputname,0,name,iv);
//	if (_tcslen(theTex->biOutFile.Name())>0) 
	if ((name) && (_tcslen(name)>0) )
		{
		IParamMap2 *map = theTex->pblock->GetMap();
//		map->Enable(acubic_node, TRUE);
		iPick->Enable(TRUE);
		}
	else 
		{
		IParamMap2 *map = theTex->pblock->GetMap();
		iPick->Enable(FALSE);
//		map->Enable(acubic_node, FALSE);
		}
	}


void ACubic::UpdateInterface(BOOL on)
{
ACubicDlgProc *paramDlg =  (ACubicDlgProc*)acubic_param_blk.GetUserDlgProc();
if (paramDlg)
	paramDlg->SetUseFile(on);
}


void ACubic::Init() {
	nth = 1;
	do_nth = TRUE;
	useFile = FALSE;
	inMedit= FALSE;
	applyBlur = TRUE;
	useEnvMap = TRUE;
//	ReplaceReference( 0, CreateParameterBlock( pbdesc, NPARAMS, ACUBIC_VERSION) );	
	ivalid.SetEmpty();
	SetSize(100, TimeValue(0));
	SetBlur(1.0f, TimeValue(0));
	SetBlurOffset(.0f, TimeValue(0));
	SetNearRange(0.0f,0);
	SetFarRange(500.0f,0);
	}

void ACubic::Reset() {
	Init();
	acubicCD.Reset(this, TRUE);	// reset all pb2's
	}

void ACubic::SetUseFile(BOOL onOff) {
	useFile = onOff;
	if (!useFile) FreeMaps();
	}

void ACubic::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}



ACubic::ACubic() {
//	InitializeCriticalSection(&csect);
//	paramDlg = NULL;
	ip = NULL;
	pblock = NULL;
	maps = NULL;
	acubicCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

RefTargetHandle ACubic::Clone(RemapDir &remap) {
	ACubic *mnew = new ACubic();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->do_nth = do_nth;
	mnew->applyBlur = applyBlur;
	mnew->ivalid.SetEmpty();	
	mnew->biInFile = biInFile;
	mnew->biOutFile = biOutFile;
	mnew->useFile = useFile;
	mnew->useEnvMap = useEnvMap;
//	for (int i=0; i<6; i++) mnew->fileNames[i]= fileNames[i]; 
	return (RefTargetHandle)mnew;
	}

ParamDlg* ACubic::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
//	ACubicDlg *dm = new ACubicDlg(hwMtlEdit, imp, this);
//	dm->LoadDialog(TRUE);	
//	paramDlg = dm;
//	return dm;	
	// create the rollout dialogs
	ip = imp;
	IAutoMParamDlg* masterDlg = acubicCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	acubic_param_blk.SetUserDlgProc(new ACubicDlgProc(this));
	BOOL on;
	Interval iv;
	pblock->GetValue(acubic_source,0,on,iv);
	UpdateInterface(on);
	return masterDlg;


	}

void ACubic::Update(TimeValue t, Interval& valid) {		

//	pblock->SetValue(acubic_node,t,(INode *) NULL);
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( acubic_size, t, size, ivalid );
		pblock->GetValue( acubic_blur, t, blur, ivalid );
		pblock->GetValue( acubic_bluroffset, t, blurOff, ivalid );
		pblock->GetValue( acubic_near, t, nearRange, ivalid );
		pblock->GetValue( acubic_far, t, farRange, ivalid );

		pblock->GetValue( acubic_nthframe, t, nth, ivalid );
		pblock->GetValue( acubic_applyblur, t, applyBlur, ivalid );
		pblock->GetValue( acubic_frametype, t, do_nth, ivalid );

		pblock->GetValue( acubic_useatmospheric, t, useEnvMap, ivalid );
		pblock->GetValue( acubic_source, t, useFile, ivalid );
		

		for (int i = 0 ; i < 6; i++)
			{
			TCHAR *name;
			pblock->GetValue( acubic_bitmap_names,t,name,ivalid,i);
			fileNames[i] = name;
			}	

		}
	valid &= ivalid;
	}

void ACubic::FreeMaps() {
	CubicMap *cm,*nxtcm;
	for (cm = maps; cm!=NULL; cm = nxtcm) {
		nxtcm = cm->next;
	   	delete cm;		
		}
	maps = NULL;
	}

static void ACubicMsg(const TCHAR* msg) {
	if (GetCOREInterface()->IsNetServer()) {
		// Obsolete GG: 01/29/99
		// GetCOREInterface()->NetLog(_T("%s: %s \n"), GetString(IDS_DS_REFL_ERROR),msg);
		GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,NULL,_T("%s: %s"),GetString(IDS_DS_REFL_ERROR),msg);
	} else 
		MessageBox(NULL, msg, GetString(IDS_DS_REFL_ERROR), MB_TASKMODAL);
	}

static void ACubicNotSquareMsg(const TCHAR* name) {
	if (name==NULL) return;
	TCHAR msg[256];
	wsprintf(msg,GetString(IDS_DS_NOT_SQUARE), name);
	ACubicMsg(msg);
	}

static void ACubicWrongSizeMsg(const TCHAR* name) {
	if (name==NULL) return;
	TCHAR msg[256];
	wsprintf(msg,GetString(IDS_DS_WRONG_SIZE), name);
	ACubicMsg(msg);
	}

int ACubic::LoadMapFiles(TimeValue t) {
	unsigned short status;
//	if (useFile||inMedit) {
	if (useFile) {
		BOOL silent = TheManager->SetSilentMode(TRUE);
		BOOL calcBlur = FALSE;
		if (maps==NULL) {
			maps = new CubicMap;
			maps->tossMapsWhenBlur = FALSE;
			}
		SetCursor(LoadCursor(NULL,IDC_WAIT));

//		PBBitmap *bp;
//		pblock->GetValue( acubic_bitmaps,t,bp,ivalid,i);

		biInFile.SetCurrentFrame(t/GetTicksPerFrame());
		int mapSize = -1;
		for (int i=0; i<6; i++) {	
//			PBBitmap *bp;
//			pblock->GetValue( acubic_bitmaps,t,bp,ivalid,i);
//			if (bp != NULL)
				{
//				biInFile = bp->bi;
			biInFile.SetName(fileNames[i]);
			if (maps->bitmap[i]==NULL) {
//					maps->bitmap[i] = bp->bm;

				maps->bitmap[i] = TheManager->Load(&biInFile,&status);
					calcBlur = TRUE;
					}
				if (maps->bitmap[i]!=NULL) {
					int w = maps->bitmap[i]->Width();
					int h = maps->bitmap[i]->Height();
					if (w!=h) {
						ACubicNotSquareMsg(fileNames[i]);
//						ACubicNotSquareMsg(bp->bi.Name());
						FreeMaps();
						fileNames[i] = _T("");
						pblock->SetValue(acubic_bitmap_names,0,fileNames[i],i);
						ACubicDlgProc *paramDlg =  (ACubicDlgProc*)acubic_param_blk.GetUserDlgProc();
						if (paramDlg)
							paramDlg->StuffDlgName(i);
						goto bail;
						}
					if (mapSize<0) mapSize = w; 
					else {
						if (mapSize!=w) {
//							ACubicWrongSizeMsg(bp->bi.Name());
							ACubicWrongSizeMsg(fileNames[i]);
							FreeMaps();
							goto bail;
							}
						}
					if (maps->bitmap[i]->Storage()->bi.CurrentFrame()!=biInFile.CurrentFrame()) {
						status = maps->bitmap[i]->GoTo(&biInFile);
						if (status!=BMMRES_SINGLEFRAME)
							calcBlur = TRUE;
						}
					}
				}
			}
		maps->size = mapSize;
		if (applyBlur) {
			if (calcBlur||!maps->blurmap) 
				maps->BuildBlurMap();
			}
		else 
			maps->FreeBlurMap();
		bail:
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		TheManager->SetSilentMode(silent);
		}
	return 1;
	}

void ACubic::SetSize(int s, TimeValue t) { 
	size = s; 
	pblock->SetValue( acubic_size, t, s);
	}

void ACubic::SetApplyBlur(BOOL onoff) { 
	if (applyBlur==onoff) return;
	applyBlur = onoff; 
	if (useFile&&maps) {
		if (applyBlur) {
			SetCursor(LoadCursor(NULL,IDC_WAIT));
			maps->BuildBlurMap();
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			}
		else 
			maps->FreeBlurMap();
		}
	}

void ACubic::SetBlur(float f, TimeValue t) { 
	blur = f; 
	pblock->SetValue( acubic_blur, t, f);
	}

void ACubic::SetBlurOffset(float f, TimeValue t) { 
	blurOff = f; 
	pblock->SetValue( acubic_bluroffset, t, f);
	}

void ACubic::SetNearRange(float f, TimeValue t) { 
	nearRange = f; 
	pblock->SetValue( acubic_near, t, f);
	}

void ACubic::SetFarRange(float f, TimeValue t) { 
	farRange = f; 
	pblock->SetValue( acubic_far, t, f);
	}

RefTargetHandle ACubic::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		default: return NULL;
		}
	}

void ACubic::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		}
	}
	 
Animatable* ACubic::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}

TSTR ACubic::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));
		default: return TSTR("");		
		}
	}

int  ACubic::GetOutFileName(TSTR &fullname, TSTR &fname, int i) {
	TSTR path;
	TSTR ext;
	TSTR upname;// = biOutFile.Name();
	Interval iv;
	TCHAR *tname;
	pblock->GetValue(acubic_outputname,0,tname,iv);
	upname = tname;
	if (upname.Length()==0) return 0;
	SplitFilename(upname,&path, &fname, &ext);
	int n = fname.Length();
	///assert(n>=3);
	fname = fname.Substr(0,n-3);
	fname += suffixes[i];
	TSTR fullName;
	fullname.printf(_T("%s\\%s%s"),path.data(),fname.data(),ext.data());
	return 1;
	}

int ACubic::WriteBM(Bitmap *bm, TCHAR *name) {
	TSTR upname = biOutFile.Name();
	biOutFile.SetName(name);
	if (bm->OpenOutput(&biOutFile) != BMMRES_SUCCESS) goto bail;
	if (bm->Write(&biOutFile,BMM_SINGLEFRAME) != BMMRES_SUCCESS) 
		goto bail;
	bm->Close(&biOutFile);
	biOutFile.SetName(upname);
	return 1;

	bail:
	biOutFile.SetName(upname);
	return 0;
	}


void ACubic::RenderCubicMap(INode *node)
	{
	int res;
	BOOL success = 0;
	TSTR fname,fullname;

	if (size<=0) 
		return;
	Interface *ip = GetCOREInterface();
	BOOL wasHid = node->IsNodeHidden();
	node->Hide(TRUE);

	// Create a blank bitmap
	Bitmap *bm = NULL;
	biOutFile.SetWidth(size);
	biOutFile.SetHeight(size);
	biOutFile.SetType(BMM_TRUE_64);
	biOutFile.SetAspect(1.0f);
	biOutFile.SetCurrentFrame(0);
	bm = TheManager->Create(&biOutFile);

	Matrix3 nodeTM = node->GetNodeTM(ip->GetTime());
	Matrix3 tm;	
	INode* root = ip->GetRootNode();		
	bm->Display(GetString(IDS_DS_ACUBIC_NAME));

	// NEW WAY
	ViewParams vp;
	vp.projType = PROJ_PERSPECTIVE;
	vp.hither = .001f;
	vp.yon = 1.0e30f;
	vp.fov = PI/2.0f;
	vp.nearRange = nearRange;
	vp.farRange = farRange;
	BOOL saveUseEnvMap = ip->GetUseEnvironmentMap();
	ip->SetUseEnvironmentMap(useEnvMap);

	res = ip->OpenCurRenderer(&vp); 
	for (int i=0; i<6; i++) {
		tm = TMForView(i);
		tm.PreTranslate(-nodeTM.GetTrans()); 
		vp.affineTM = tm;
		if (!GetOutFileName(fullname,fname,i)) 
			goto fail;
		bm->SetWindowTitle(fname);
		res = ip->CurRendererRenderFrame(ip->GetTime(),bm,NULL,1.0f,&vp);
		if (!res) 
			goto fail;
		if (!WriteBM(bm, fullname)) goto fail;
		}
	success = 1;
	fail:
	ip->CloseCurRenderer();	
	ip->SetUseEnvironmentMap(saveUseEnvMap);

	bm->DeleteThis();
	node->Hide(wasHid);
	if (success) {
		for (i=0; i<6; i++) {
			GetOutFileName(fullname,fname,i);
			fileNames[i] = fullname; 

			
			biOutFile.SetName(fullname);
			pblock->SetValue( acubic_bitmap_names,ip->GetTime(), fullname,i);
//			fileNames[i] = bp->bi.Name();
			ACubicDlgProc *paramDlg =  (ACubicDlgProc*)acubic_param_blk.GetUserDlgProc();

//			GetUserDlgProc(ParamBlockDesc2* pbd);
			if (paramDlg) paramDlg->StuffDlgName(i);
			}
		if (useFile) {
			FreeMaps();
			NotifyChanged();
			}
		}
	}


static int nameID[] = {IDS_DS_MAPSIZE, IDS_DS_BLUR, IDS_DS_BLUROFFS, IDS_DS_NEARRANGE, IDS_DS_FARRANGE };

RefResult ACubic::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			if (hTarget == pblock)
				{
				ivalid.SetEmpty();
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				acubic_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

//			ivalid.SetEmpty();
//			if (paramDlg) 
//				paramDlg->Invalidate();
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_SIZE: 
				case PB_BLUR: 
				case PB_BLUROFF: 
					gpd->dim = defaultDim; break;
				case PB_NEAR: 
				case PB_FAR: 
					gpd->dim = stdWorldDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = TSTR(GetString(nameID[gpn->index]));
			return REF_STOP; 
			}
*/
		}
	return(REF_SUCCEED);
	}


inline Point2 CompUV(float x, float y, float z) {
	return Point2( 0.5f*(x/z+1.0f), 0.5f*(y/z+1.0f));
	}


// Compute TM to transform points from World coords to Camera coords
// for each of the 6 views.
Matrix3 TMForView( int i) {
	Matrix3 m;
	m.IdentityMatrix();
	switch (i) {
		case VIEW_UP:    // looking UP
			m.RotateX(-PI);	
			break;
		case VIEW_DN:    // looking down (top view)
			break;
		case VIEW_LF: 	 // looking to left
			m.RotateX(-.5f*PI);	
			m.RotateY(-.5f*PI);
			break;
		case VIEW_RT:     // looking to right
			m.RotateX(-.5f*PI);	
			m.RotateY(+.5f*PI);
			break;
		case VIEW_FR:       // looking to front (back view)
			m.RotateX(-.5f*PI);	
			m.RotateY(PI);
			break;
		case VIEW_BK:         // looking to back
			m.RotateX(-.5f*PI);	
			break;
		}
	return m;
	}

int ACubic::DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime) {
	if (!do_nth) {
		if (t!=mapTime) return 0;  // only do it on first frame.
		}
	if (nth==1) return 1;   // need every one
	TimeValue del = abs(t - mapTime);
	if (del==0) return 1; // repeated iterations on a frame are ok
	if (fieldRender) del*=2;
	return  (del>=nth*GetTicksPerFrame())?1:0;
	}

CubicMap *ACubic::FindMap(int nodeNum) {
	CubicMap *cm;
	for (cm=maps; cm!=NULL; cm = cm->next)
		if (cm->nodeID==nodeNum) return cm;
	return NULL;
	}

int ACubic::BuildMaps(TimeValue t, RenderMapsContext &rmc) {
	if (useFile) return 1;
	RenderGlobalContext *gc = rmc.GetGlobalContext();
	if (gc){
		if (gc->inMtlEdit&&(gc->envMap==NULL)) return 1;
		}
	SubRendParams srp;
	rmc.GetSubRendParams(srp);
	CubicMap *cm = FindMap(rmc.NodeRenderID());
	if (cm&&!DoThisFrame(t,srp.fieldRender,cm->mapTime))
		return 1;
	INode *node = rmc.GetNode();
	Matrix3 tm = node->GetNodeTM(t);
	Point3 pos = tm.GetRow(3); //nodes world position
	ViewParams vp;
	vp.projType = PROJ_PERSPECTIVE;
	vp.hither = .001f;
	vp.yon = 1.0e30f;
	vp.fov = PI/2.0f;
	vp.nearRange = nearRange;
	vp.farRange = farRange;

	srp.devWidth = size;
	srp.devHeight = size;
	srp.devAspect = 1.0f;
	srp.xmin = srp.ymin = 0;
	srp.xmax = srp.ymax = size;
	srp.xorg =srp.yorg = 0;
	srp.fieldRender = 0;
	srp.rendType = RENDTYPE_NORMAL;
	srp.doEnvMap = useEnvMap;
	srp.doingMirror = FALSE;
	if (cm==NULL) {
		cm = new CubicMap;
		cm->nodeID = rmc.NodeRenderID();
		cm->next = maps;
		maps = cm;
		}
	cm->mapTime = t;
	if (cm->AllocMaps(size)) {
		if (gc&&gc->inMtlEdit) 
			SetCursor(LoadCursor(NULL,IDC_WAIT));
		for (int i=0; i<6; i++) {	
			tm = TMForView(i);
			tm.PreTranslate(-pos); 
			vp.affineTM = tm;
			if (!rmc.Render(cm->bitmap[i], vp, srp, 0)) {
				cm->FreeMaps();
				return 0;
				}
#ifdef DBG
			cm->bitmap[i]->Display(getCubeName(i), BMM_UR);
			MessageBox(NULL, getCubeName(i), _T(" Auto Cubic Test"), MB_OK|MB_ICONEXCLAMATION);
			cm->bitmap[i]->UnDisplay();
#endif
			}
		if (gc&&gc->inMtlEdit) 
			SetCursor(LoadCursor(NULL,IDC_ARROW));
		}

	if (applyBlur) {
		cm->BuildBlurMap();
		}
	return 1;
	}

static BMM_Color_64 black64 = {0,0,0,0};

// The "canonical" view is looking in the -z direction,
// with x to the right, y up, i.e. VIEW_DN,
// other views are mapped into this canonical rep

BMM_Color_64 CubicMap::Sample(Point3 v) {
	float wx,wy,wz;
	Color rcol;
	Bitmap *refmap=NULL;
	Point3 rv;
	Point2 uv;
	wx = (float)fabs(v.x);  wy = (float)fabs(v.y);  wz = (float)fabs(v.z); 
	if (wx>=wy && wx>=wz) {
		if(v.x<0) {	refmap = bitmap[VIEW_LF];	uv = CompUV(-v.y, -v.z,  v.x);	}
		else	  { refmap = bitmap[VIEW_RT];   uv = CompUV( v.y, -v.z, -v.x);	}
		}
	else
	if(wy>=wx && wy>=wz) {
		if(v.y>0) { refmap = bitmap[VIEW_BK];	uv = CompUV( -v.x, -v.z, -v.y);	}
		else {  	refmap = bitmap[VIEW_FR];	uv = CompUV(  v.x, -v.z,  v.y); }
		}
	else
	if(wz>=wx && wz>=wy) {
		if(v.z<0) {	refmap = bitmap[VIEW_DN];	uv = CompUV( -v.x, -v.y,  v.z);	}
		else     {	refmap = bitmap[VIEW_UP];	uv = CompUV( -v.x,  v.y, -v.z);	}
		}

	if (refmap==NULL) return black64;
	int x = (int)(frac(uv.x)*(float)size);
	int y = (int)(frac(1.0f-uv.y)*(float)size);
	BMM_Color_64 c;
	//refmap->GetPixels(x,y,1,&c);
	refmap->GetLinearPixels(x,y,1,&c);
	return c;
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);
			   
static void whoa() {}

RGBA ACubic::EvalColor(ShadeContext& sc) {
	CubicMap *cm=NULL;
	IPoint2 sp = sc.ScreenCoord();
	if (sp.x==128&&sp.y==106)
		whoa();
//	if (sc.InMtlEditor()&&!useFile) {
//		EnterCriticalSection(&csect);
//		if (!maps) {
//			inMedit = 1;
//			LoadMapFiles(sc.CurTime());
//			inMedit = 0;
//			}
//		LeaveCriticalSection(&csect);
//		cm = maps;
//		}
//	else {
		if (useFile) {
			cm = maps;
			}
		else {
			if (gbufID) sc.SetGBufferID(gbufID);
			int id = sc.NodeID();
			cm = FindMap(id);
			}
//		}

	if (cm) {
		Point3 V = sc.VectorTo(sc.V(),REF_WORLD);
		if (applyBlur&&cm->blurmap) {
			BMM_Color_64 c;
			Point2 uv, duv;
			ComputeSphereCoords(V,uv,duv);
			duv *= (blur*sc.Curve());
			duv.x += blurOff;
			duv.y += blurOff;
			cm->blurmap->GetFiltered(uv.x,uv.y,duv.x,duv.y,&c);
			return c;
			}
		else 
			return cm->Sample(V);
		}
	return Color(0,0,0);
	}

float ACubic::EvalMono(ShadeContext& sc) {
	return Intens(EvalColor(sc));
	}

Point3 ACubic::EvalNormalPerturb(ShadeContext& sc) {
	return Point3(0,0,0);
	}

#define MTL_HDR_CHUNK 0x4000
#define DONT_DO_NTH_CHUNK 0x1000
#define NTH_CHUNK 0x1001
#define DONT_APPLY_BLUR_CHUNK 0x1002
#define DONT_USE_ENV_CHUNK 0x1003
#define USE_FILE_CHUNK 0x1004
#define NAME_CHUNK 0x1010
#define ACUBE_IO_IN_CHUNK 0x1020
#define ACUBE_IO_OUT_CHUNK 0x1030
#define PARAM2_CHUNK 0x1040

IOResult ACubic::Save(ISave *isave) { 
	IOResult res;
//	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
/*
	if (!do_nth) {
		isave->BeginChunk(DONT_DO_NTH_CHUNK);
		isave->EndChunk();
		}
	if (!applyBlur) {
		isave->BeginChunk(DONT_APPLY_BLUR_CHUNK);
		isave->EndChunk();
		}
	if (!useEnvMap) {
		isave->BeginChunk(DONT_USE_ENV_CHUNK);
		isave->EndChunk();
		}
	if (useFile) {
		isave->BeginChunk(USE_FILE_CHUNK);
		isave->EndChunk();
		}
	for (int i=0; i<6; i++) {
		if (fileNames[i].Length()>0) {
			isave->BeginChunk(NAME_CHUNK+i);
			isave->WriteWString(fileNames[i]);
			isave->EndChunk();
			}
		}
	isave->BeginChunk(NTH_CHUNK);
	isave->Write(&nth,sizeof(nth),&nb);			
	isave->EndChunk();

	isave->BeginChunk(ACUBE_IO_IN_CHUNK);
	biInFile.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(ACUBE_IO_OUT_CHUNK);
	biOutFile.Save(isave);
	isave->EndChunk();
*/

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

	return IO_OK;
	}	

class ACubicPostLoad : public PostLoadCallback {
	public:
		ACubic *cube;
		BOOL Param1;
		ACubicPostLoad(ACubic *b, BOOL p) {cube=b; Param1 = p;}
		void proc(ILoad *iload) {
			if (cube->pblock->GetVersion()!=ACUBIC_VERSION) {
				switch (cube->pblock->GetVersion()) {
					case 1:
//						cube->ReplaceReference(0,
//							UpdateParameterBlock(
//								pbdesc1, 2, cube->pblock,
//								pbdesc,  5, ACUBIC_VERSION));
						iload->SetObsolete();
						cube->SetNearRange(0.0f,0);
						cube->SetFarRange(500.0f,0);
						break;
					case 2:
//						cube->ReplaceReference(0,
//							UpdateParameterBlock(
//								pbdesc2, 3, cube->pblock,
//								pbdesc,  5, ACUBIC_VERSION));
						iload->SetObsolete();
						cube->SetNearRange(0.0f,0);
						cube->SetFarRange(500.0f,0);
						break;
					default:
						if (Param1)
							{
							TimeValue t = 0;
							cube->pblock->SetValue( acubic_frametype, t, cube->do_nth);
							cube->pblock->SetValue( acubic_applyblur, t, cube->applyBlur);
							cube->pblock->SetValue( acubic_useatmospheric, t, cube->useEnvMap);
							cube->pblock->SetValue( acubic_source, t, cube->useFile);
							cube->pblock->SetValue( acubic_nthframe, t, cube->nth);


							TSTR nm = cube->biOutFile.Name();
							cube->pblock->SetValue( acubic_outputname,t,nm);
							for (int i = 0 ; i < 6; i++)
								{
								cube->pblock->SetValue( acubic_bitmap_names,t,cube->fileNames[i],i);
								}	

							}
//						assert(0);
						break;
					}
				}
			//waitPostLoad--;
			delete this;
			}
	};

IOResult ACubic::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	int cid;
	BOOL Param1 = TRUE;
//	TSTR fileNames[6];    // source files


	while (IO_OK==(res=iload->OpenChunk())) {
		switch(cid=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case DONT_DO_NTH_CHUNK:
				do_nth = FALSE;
				break;
			case DONT_APPLY_BLUR_CHUNK:
				applyBlur = FALSE;
				break;
			case DONT_USE_ENV_CHUNK:
				useEnvMap = FALSE;
				break;
			case USE_FILE_CHUNK:
				useFile = TRUE;
				break;
			case NTH_CHUNK:
				iload->Read(&nth,sizeof(nth),&nb);			
				break;
			case NAME_CHUNK+0:
			case NAME_CHUNK+1:
			case NAME_CHUNK+2:
			case NAME_CHUNK+3:
			case NAME_CHUNK+4:
			case NAME_CHUNK+5:
				{
				TCHAR *buf;
				if (IO_OK==iload->ReadWStringChunk(&buf)) 
					fileNames[cid-NAME_CHUNK] = buf;
				}
				break;
			case ACUBE_IO_IN_CHUNK:
				res = biInFile.Load(iload);
				break;
			case ACUBE_IO_OUT_CHUNK:
				res = biOutFile.Load(iload);
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &acubic_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new ACubicPostLoad(this,Param1));
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\motionC\rotmc.cpp ===
/**********************************************************************
 *<
	FILE: rotMC.cpp

	DESCRIPTION: Rotation motion capture controller

	CREATED BY: Rolf Berteig

	HISTORY: October 30, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "motion.h"
#include "mmanager.h"


static Class_ID rotmcControlClassID(ROT_MOTION_CLASS_ID,0); 

class RotationMC : public MCControl {
	public:
		MCDeviceBinding *bind[3];
		Point3 base;
		int sampleCount;
		Point3 *data;

		RotationMC();
		Class_ID ClassID() {return rotmcControlClassID;}  
		SClass_ID SuperClassID() {return CTRL_ROTATION_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_ROTMC);}
		ParamDimension* GetParamDimension(int i) {return stdAngleDim;}
		RefTargetHandle Clone(RemapDir& remap);

		int NumDeviceBindings() {return 3;}
		MCDeviceBinding *GetDeviceBinding(int i) {return bind[i];}
		void SetDeviceBinding(int i,MCDeviceBinding *b) {bind[i]=b;}
		void GetValueLive(TimeValue t,void *val, GetSetMethod method);
		void BeginCapture(Interval record,TimeValue sampSize);
		void EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat);
		void Capture(Interval record,TimeValue t,int sample);
		void BeginLive(TimeValue t);

		void EditTrackParams(
			TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
			HWND hParent, IObjParam *ip, DWORD flags);
	};


//--- Class Descriptor -----------------------------------------------

class RotMCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new RotationMC;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_ROTMC);}
	SClass_ID		SuperClassID() {return CTRL_ROTATION_CLASS_ID;}
	Class_ID		ClassID() {return rotmcControlClassID;}
	const TCHAR* 	Category() {return _T("");}
	};
static RotMCClassDesc rotmcCD;
ClassDesc* GetRotMotionDesc() {return &rotmcCD;}


//--- RotationMC methods ----------------------------------------------

RotationMC::RotationMC()
	{
	ReplaceReference(0,CreateInterpRotation());
	bind[0] = bind[1] = bind[2] = NULL;
	base = Point3(0,0,0);
	data = NULL;
	}

RefTargetHandle RotationMC::Clone(RemapDir& remap)
	{
	RotationMC *c = new RotationMC;
	c->MCControlClone(this,remap);
	return c;
	}

void RotationMC::EditTrackParams(
		TimeValue t, ParamDimensionBase *dim, TCHAR *pname, 
		HWND hParent, IObjParam *ip, DWORD flags)
	{
	GenMCParamDlg *dlg = new GenMCParamDlg(this,IDD_MC_ROTATION);
	dlg->DoWindow(hParent, pname);
	}

void RotationMC::GetValueLive(TimeValue t,void *val, GetSetMethod method)
	{
	Point3 pt = base;
	for (int i=0; i<3; i++) if (bind[i]) pt[i] += DegToRad(bind[i]->Eval(t));
	Quat q;
	EulerToQuat(pt,q);
	if (method==CTRL_ABSOLUTE) {		
		*((Quat*)val) = q;
	} else {
		Matrix3 *tm = (Matrix3*)val;		
		PreRotateMatrix(*tm,q);		
		}
	}
									  
void RotationMC::BeginCapture(Interval record,TimeValue sampSize)
	{
	// Set the base point to the controller value at the start time.
	Quat q;
	cont->GetValue(record.Start(),&q,FOREVER,CTRL_ABSOLUTE);	
	QuatToEuler(q,base);

	// Allocate a data buffer
	sampleCount = record.Duration()/sampSize + 1;
	data = new Point3[sampleCount];
	for (int i=0; i<sampleCount; i++) data[i] = Point3(0,0,0);
	}

void RotationMC::Capture(Interval record,TimeValue t,int sample)
	{
	assert(sample>=0 && sample<sampleCount);	
	Point3 pt = base;
	for (int i=0; i<3; i++) if (bind[i]) pt[i] += DegToRad(bind[i]->Eval(t));
	data[sample] = pt;	
	}
  
void RotationMC::EndCapture(Interval record,TimeValue sampSize, KeyReduceStatus *stat) 
	{		
	// Clear any keys out of the record interval
	cont->DeleteTime(record,TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);

	// Make keys out of the data
	SuspendAnimate();
	AnimateOn();	
	for (int i=0; i<sampleCount; i++) {
		TimeValue t = record.Start() + i * sampSize;
		Quat q;				
		EulerToQuat(data[i],q);
		cont->SetValue(t,&q,1,CTRL_ABSOLUTE);
		if (i%UPDATE_RATE==0) if (stat->Progress(i)!=KEYREDUCE_CONTINUE) goto abort;
		}	

abort:
	ResumeAnimate();
	delete[] data;
	base = Point3(0,0,0);
	}

void RotationMC::BeginLive(TimeValue t)
	{
	// Set the base point to the controller value at the start time.
	Quat q;
	cont->GetValue(t,&q,FOREVER,CTRL_ABSOLUTE);	
	QuatToEuler(q,base);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\cmtl.cpp ===
/**********************************************************************
 *<
	FILE: cmtl.cpp

	DESCRIPTION:  Composite material (Top-Bottom material)

	CREATED BY: Dan Silva

	HISTORY: 12/2/98 Updated to Param Block 2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"		   
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

#define NSUBMTLS 2

static Class_ID cmtlClassID(CMTL_CLASS_ID,0);
// Parameter block indices


class CMtl: public Mtl {
	// Animatable parameters
	Interval ivalid;
	Mtl* subMtl[NSUBMTLS];
	Mtl* useSubMtl[NSUBMTLS];

	IMtlParams *ip;

	public:
		BOOL Param1;
		BOOL mtlOn[NSUBMTLS];
		BOOL useLocalCoords;
		float thresh;
		IParamBlock2 *pblock;
		float width;

		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}		
		void SetThresh(float v, TimeValue t);
		void SetWidth(float v, TimeValue t);
		float GetThresh() { return thresh; }
		float GetWidth() { return width; }

		Mtl *UseMtl();
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);

		CMtl();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void SwapInputs();
		void Init();
		void Reset();
		void CMtl::UpdateUseMtls();
		void SetMtlOn(int i, BOOL onOff);
		Interval Validity(TimeValue t);
		void NotifyChanged();

		Class_ID ClassID() {	return cmtlClassID; }
		SClass_ID SuperClassID() { return MATERIAL_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_TOPBOTTOM); }  
		void CMtl::Fixup();  //TEMPORARY
			

		void DeleteThis() { delete this; }	

		// Methods to access sub-materials of meta-materials
	   	int NumSubMtls() { return NSUBMTLS; }
		Mtl* GetSubMtl(int i) { return subMtl[i]; }
		void SetSubMtl(int i, Mtl *m);
		TSTR GetSubMtlSlotName(int i);

		int NumSubs() { return NSUBMTLS+1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return NSUBMTLS+1;  }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};


int numCMtls = 0;
class CMtlClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new CMtl; }
	const TCHAR *	ClassName() { return  GetString(IDS_DS_TOPBOTTOM_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return MATERIAL_CLASS_ID; }
	Class_ID 		ClassID() { return cmtlClassID; }
	const TCHAR* 	Category() { return _T("");  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("topBottomMat"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static CMtlClassDesc cMtlCD;

ClassDesc* GetCMtlDesc() { 
	return &cMtlCD;  
	}


//dialog stuff to get the Set Ref button
class CMtlDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		CMtl *cmtl;		
		CMtlDlgProc(CMtl *m) {cmtl = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};



BOOL CMtlDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_CMTL_SWAP:
					{
					cmtl = (CMtl*)map->GetParamBlock()->GetOwner(); 
					cmtl->SwapInputs();
					cmtl->UpdateUseMtls();
					}
				break;
				}
			break;
		}
	return FALSE;
	}

//-----------------------------------------------------------------------------
//  CMtl
//-----------------------------------------------------------------------------

enum { topbottom_params, };  // pblock ID
// topbottom_params param IDs
enum 
{ 
	topbottom_map1, topbottom_map2,		
	topbottom_map1_on, topbottom_map2_on, // main grad params 
	topbottom_blend,
	topbottom_position,
	topbottom_space,

};

// per instance gradient block
static ParamBlockDesc2 topbottom_param_blk ( topbottom_params, _T("parameters"),  0, &cMtlCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_CMTL, IDS_DS_TB_PARAMS, 0, 0, NULL, 
	// params

	topbottom_map1,		_T("topMaterial"),		TYPE_MTL,			P_OWNERS_REF,	IDS_DS_TOP,
		p_refno,		1,
		p_submtlno,		0,		
		p_ui,			TYPE_MTLBUTTON, IDC_TOP_MTL,
		end,
	topbottom_map2,		_T("bottomMaterial"),		TYPE_MTL,			P_OWNERS_REF,	IDS_DS_BOTTOM,
		p_refno,		2,
		p_submtlno,		1,		
		p_ui,			TYPE_MTLBUTTON, IDC_BOT_MTL,
		end,

	topbottom_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MTL_ON1,
		end,
	topbottom_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MTL_ON2,
		end,

	topbottom_blend,	_T("blend"), TYPE_FLOAT,			P_ANIMATABLE,				IDS_DS_BLEND,
		p_default,		0.0f,
		p_range,		0.0f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_CMTL_W_EDIT, IDC_CMTL_W_SPIN, 1.0f, 
		end,
	topbottom_position,	_T("position"), TYPE_FLOAT,			P_ANIMATABLE,				IDS_PW_POSITION,
		p_default,		50.0f,
		p_range,		0.0f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_CMTL_Y_EDIT, IDC_CMTL_Y_SPIN, 1.0f, 
		end,
	topbottom_space, _T("coordinates"), TYPE_INT,				0,				IDS_PW_COORDINATES,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_CMTL_WORLD, IDC_CMTL_LOCAL,
		end,

	end
);



static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,topbottom_position },   // thresh
	{ TYPE_FLOAT, NULL, TRUE,topbottom_blend } };   // blend

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,2,0),	
	};

void CMtl::Init() {
	ivalid.SetEmpty();
	ReplaceReference(1,NewDefaultStdMat());
	ReplaceReference(2,NewDefaultStdMat());
	GetCOREInterface()->AssignNewName(subMtl[0]);
	GetCOREInterface()->AssignNewName(subMtl[1]);

	thresh = 0.0f;
	width = .05f;
	useLocalCoords = FALSE;
	mtlOn[0] = mtlOn[1] = 1;
	}

void CMtl::Reset() {
	cMtlCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

void CMtl::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

CMtl::CMtl() {
	Param1 = FALSE;
	subMtl[0] = subMtl[1] = NULL;
	useSubMtl[0] = useSubMtl[1] = NULL;
	mtlOn[0] = mtlOn[1] = FALSE;
	pblock = NULL;
	cMtlCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	}

void CMtl::SwapInputs() {
	Mtl *tmp = subMtl[0];
	subMtl[0] = subMtl[1];
	subMtl[1] = tmp;

//	pblock->SwapControllers(topbottom_map1,0,topbottom_map2,0);
	topbottom_param_blk.InvalidateUI(topbottom_map1);
	topbottom_param_blk.InvalidateUI(topbottom_map2);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("topMaterial"), mr_reftarg, this, mr_prop, _T("bottomMaterial"), mr_reftarg, this);
	ip->MtlChanged();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

Mtl *CMtl::UseMtl() {
	Mtl* m = NULL;
	for (int i=0; i<NSUBMTLS; i++) if (subMtl[i]) { m = subMtl[i]; break; }
	return m;
	}

// These allow the real-time renderer to display a material appearance.
// Just use the "Top material"
Color CMtl::GetAmbient(int mtlNum, BOOL backFace) { 
	return UseMtl()?UseMtl()->GetAmbient(mtlNum,backFace):Color(0,0,0);
	}		
Color CMtl::GetDiffuse(int mtlNum, BOOL backFace){ 
	return UseMtl()?UseMtl()->GetDiffuse(mtlNum,backFace):Color(0,0,0);
	}				
Color CMtl::GetSpecular(int mtlNum, BOOL backFace){
	return UseMtl()?UseMtl()->GetSpecular(mtlNum,backFace):Color(0,0,0);
	}		
float CMtl::GetXParency(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}
float CMtl::GetShininess(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}		
float CMtl::GetShinStr(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}
float CMtl::WireSize(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->WireSize(mtlNum,backFace):0.0f;
	}


RefTargetHandle CMtl::Clone(RemapDir &remap) {
	CMtl *mnew = new CMtl();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->thresh = thresh;
	mnew->width = width;
	mnew->ivalid.SetEmpty();	
	mnew->useLocalCoords = useLocalCoords;
	for (int i = 0; i<NSUBMTLS; i++) {
		if (subMtl[i])
			mnew->ReplaceReference(i+1,remap.CloneRef(subMtl[i]));
		mnew->mtlOn[i] = mtlOn[i];
		}
	return (RefTargetHandle)mnew;
	}

	
ParamDlg* CMtl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	ip = imp;
	IAutoMParamDlg* masterDlg = cMtlCD.CreateParamDlgs(hwMtlEdit, imp, this);
	topbottom_param_blk.SetUserDlgProc(new CMtlDlgProc(this));
	return masterDlg;
	}

void CMtl::UpdateUseMtls() {
	for (int i=0; i<NSUBMTLS; i++) 
		useSubMtl[i] = mtlOn[i]?subMtl[i]:NULL;
	}

void CMtl::SetMtlOn(int i, BOOL onOff) {
	mtlOn[i] = onOff;
	useSubMtl[i] = mtlOn[i]?subMtl[i]:NULL;
	}

void CMtl::Update(TimeValue t, Interval& valid) {		
	if (Param1)
		{
		pblock->SetValue(topbottom_map1_on,t,mtlOn[0]);
		pblock->SetValue(topbottom_map2_on,t,mtlOn[1]);
		pblock->SetValue(topbottom_space,t,useLocalCoords);
		pblock->RescaleParam(topbottom_position, 0, 50.0f);
		pblock->RescaleParam(topbottom_blend, 0, 100.0f);

		float th;
		pblock->GetValue( topbottom_position, t, th, ivalid );
		th += 50;
		pblock->SetValue(topbottom_position,t,th);



		topbottom_param_blk.InvalidateUI(topbottom_position);
		topbottom_param_blk.InvalidateUI(topbottom_blend);

		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();


		pblock->GetValue( topbottom_position, t, thresh, ivalid );
		thresh = (thresh)/50.0f-1.0f;
		pblock->GetValue(topbottom_space,t,useLocalCoords,ivalid);

		pblock->GetValue( topbottom_blend, t, width, ivalid );
		width = width * 0.01f;

		pblock->GetValue(topbottom_map1_on,t,mtlOn[0],ivalid);
		pblock->GetValue(topbottom_map2_on,t,mtlOn[1],ivalid);
		for (int i=0; i<NSUBMTLS; i++) {
			if (subMtl[i]) 
				subMtl[i]->Update(t,ivalid);
			useSubMtl[i] = mtlOn[i]?subMtl[i]:NULL;
			}
		}
	valid &=ivalid;
	}

Interval CMtl::Validity(TimeValue t) {
	Interval valid;
	Update(t,valid);
	return ivalid;
	}

void CMtl::SetThresh(float v, TimeValue t) {
	thresh = v;
	pblock->SetValue( topbottom_blend, t, v);
	NotifyChanged();
	}

void CMtl::SetWidth(float v, TimeValue t) {
	width = v;
	pblock->SetValue( topbottom_position, t, v);
	NotifyChanged();
	}

RefTargetHandle CMtl::GetReference(int i) {
	if (i==0)
		return pblock ;
	else 
		return subMtl[i-1];
	}

void CMtl::SetReference(int i, RefTargetHandle rtarg) {
	if (i==0)
		pblock = (IParamBlock2 *)rtarg;
	else 
		subMtl[i-1] = (Mtl *)rtarg;
	}

void CMtl::SetSubMtl(int i, Mtl *m) {
	ReplaceReference(i+1,m);				  
	UpdateUseMtls();

	if (i==0)
		{
		topbottom_param_blk.InvalidateUI(topbottom_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		topbottom_param_blk.InvalidateUI(topbottom_map2);
		ivalid.SetEmpty();
		}

	}

TSTR CMtl::GetSubMtlSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_TOP)); 
		case 1:  return TSTR(GetString(IDS_DS_BOTTOM)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* CMtl::SubAnim(int i) {
	if (i==0) return pblock;
	else  return subMtl[i-1]; 
	}

TSTR CMtl::SubAnimName(int i) {
	if (i==0) return TSTR(GetString(IDS_DS_PARAMETERS));		
	else 
		return GetSubMtlTVName(i-1);
	}

RefResult CMtl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				topbottom_param_blk.InvalidateUI(changing_param);
				}

			break;
		}
	return(REF_SUCCEED);
	}


inline void Clamp(Color &c) {
	if (c.r > 1.0f) c.r = 1.0f;
	if (c.g > 1.0f) c.g = 1.0f;
	if (c.b > 1.0f) c.b = 1.0f;
	}
static Color black(0,0,0);

void CMtl::Shade(ShadeContext& sc) {
	Point3 N = sc.Normal();
	if (gbufID) sc.SetGBufferID(gbufID);
	if (useLocalCoords) 
		N = sc.VectorTo(N, REF_OBJECT);
	else 
		N = sc.VectorTo(N, REF_WORLD);
	if (N.z>thresh+width) {
		if (useSubMtl[0]) useSubMtl[0]->Shade(sc);
		}
	else if (N.z<thresh-width) {
		if (useSubMtl[1]) useSubMtl[1]->Shade(sc);
		}
	else {
		float b = (N.z-thresh+width)/(2.0f*width);
		ShadeOutput out0;
		if (useSubMtl[0]) {
			useSubMtl[0]->Shade(sc);
			out0 = sc.out;
			}
		else out0.Reset();
		sc.ResetOutput();
		if (useSubMtl[1]) {
			useSubMtl[1]->Shade(sc);
			}
		sc.out.MixIn(out0,1.0f-b);
		}
	}

void CMtl::Fixup() {	
	// Old style: have to fix up the references since they changed.
	SetReference(2,GetReference(1));
	SetReference(1,GetReference(0));
	SetReference(0,NULL);
//	ReplaceReference( 0, CreateParameterBlock( pbdesc, 2 ) );	
	SetThresh(thresh,0);
	SetWidth(width,0);
	}

#define CMTL_YTHRESH_CHUNK 0x1111
#define CMTL_YWIDTH_CHUNK 0x1112
#define MTL_HDR_CHUNK 0x4000
#define CMTL_USE_LOCAL 0x4120
#define MTLOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1020

IOResult CMtl::Save(ISave *isave) { 
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}	
	  
class CMtlCB: public PostLoadCallback {
	CMtl *mtl;
	public:
		CMtlCB(CMtl *m) { mtl = m; }
		void proc(ILoad *iload) {
			mtl->Fixup();
			delete this;
			}
	};



//watje
class TopBottomPostLoadCallback:public  PostLoadCallback
{
public:
	CMtl      *s;
	int Param1;
	TopBottomPostLoadCallback(CMtl *r, BOOL b) {s=r;Param1 = b;}
	void proc(ILoad *iload);
};

void TopBottomPostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		TimeValue t  = 0;
		s->pblock->SetValue(topbottom_map1_on,t,s->mtlOn[0]);
		s->pblock->SetValue(topbottom_map2_on,t,s->mtlOn[1]);
		s->pblock->SetValue(topbottom_space,t,s->useLocalCoords);

		}
	delete this;
}


IOResult CMtl::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	int id;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case CMTL_YTHRESH_CHUNK:
				res = iload->Read(&thresh,sizeof(float), &nb);
				iload->SetObsolete();
				iload->RegisterPostLoadCallback(new CMtlCB(this));
				break;
			case CMTL_YWIDTH_CHUNK:
				res = iload->Read(&width,sizeof(float), &nb);
				break;
			case CMTL_USE_LOCAL:
				useLocalCoords = TRUE;
				break;
			case MTLOFF_CHUNK+0:
			case MTLOFF_CHUNK+1:
				mtlOn[id-MTLOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;; 
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &topbottom_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

//	iload->RegisterPostLoadCallback(new TopBottomPostLoadCallback(this,Param1));

	return IO_OK;
                                                      
	}

float CMtl::EvalDisplacement(ShadeContext& sc) {
	Point3 N = sc.Normal();
	N = (useLocalCoords)?sc.VectorTo(N, REF_OBJECT):sc.VectorTo(N, REF_WORLD);
	if (N.z>thresh+width) {
		return useSubMtl[0]? useSubMtl[0]->EvalDisplacement(sc):0.0f;
		}
	else if (N.z<thresh-width) {
		return useSubMtl[1]? useSubMtl[1]->EvalDisplacement(sc):0.0f;
		}
	else {
		float b = (N.z-thresh+width)/(2.0f*width);
		float d0 = 0.0f;
		float d1 = 0.0f;
		if (useSubMtl[0]) {
			d0 = useSubMtl[0]->EvalDisplacement(sc);
			}
		if (useSubMtl[1]) {
			d1 = useSubMtl[1]->EvalDisplacement(sc);
			}
		return b*d0 + (1.0f-b)*d1;
//		sc.out.MixIn(out0,1.0f-b);
		}
	}


Interval CMtl::DisplacementValidity(TimeValue t) {
	Interval iv;
	iv.SetInfinite();
	if (useSubMtl[0]) 	
		iv &= useSubMtl[0]->DisplacementValidity(t);		
	if (useSubMtl[1]) 	
		iv &= useSubMtl[1]->DisplacementValidity(t);		
	return iv;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\composite_material.cpp ===
/**********************************************************************
 *<
	FILE: composite_material.cpp

	DESCRIPTION:  A compistes mulitple materials

	CREATED BY: Peter Watje

	HISTORY:10/4/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

static Class_ID compositematClassID(0x61dc0cd7, 0x13640af6);

#define PB_REF		0

// IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { compmat_params, };  // pblock ID

// compmat_params param IDs

enum 
{ 
	compmat_mtls,
	compmat_type, 
	compmat_map_on, 
	compmat_amount
};


class CompositeMat : public Mtl {	
	public:
		IParamBlock2 *pblock2; 	// ref #0
		float currentAmount;
		int currentMtl;
		int currentType;
		Interval ivalid;

		CompositeMat(BOOL loading);
		void NotifyChanged() {NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
		Mtl *UseMtl();

		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}				
		
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSelfIllumColor(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);
				
		IAutoMParamDlg* masterDlg;
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		
		Class_ID ClassID() {return compositematClassID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_PW_COMPOSITE_MATERIAL);}  

		void DeleteThis() {delete this;}	

		// Methods to access sub-materials of meta-materials
		//fix this 

		int NumSubMtls() {return pblock2->Count(compmat_mtls);}  //how to handle this ??????
		Mtl* GetSubMtl(int i) {
								Mtl *sm1 = NULL;
								Interval iv;
								pblock2->GetValue(compmat_mtls,0,sm1,iv,i);
								return sm1;
								}
		void SetSubMtl(int i, Mtl *m) {
	
								if ((i!= 0) || (m!=NULL))  //watje 3-18-99 to prevent the base material from getting nulled
									pblock2->SetValue(compmat_mtls,0,m,i);
								}
		TSTR GetSubMtlSlotName(int i);

//		BOOL IsMultiMtl() { return TRUE; }

		// Methods to access sub texture maps of material or texmap
		int NumSubTexmaps() {return 0;}
		Texmap* GetSubTexmap(int i) {return NULL;}
		void SetSubTexmap(int i, Texmap *m) {	}

		int NumSubs() {return 1;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// direct ParamBlock access
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock
		// From ref
 		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		// IO
		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload); 
	};


class CompositeMatClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new CompositeMat(loading);}
	const TCHAR *	ClassName() {return GetString(IDS_PW_COMPOSITE_MATERIAL);}
	SClass_ID		SuperClassID() {return MATERIAL_CLASS_ID;}
	Class_ID 		ClassID() {return compositematClassID;}
	const TCHAR* 	Category() {return _T("");}
	const TCHAR*	InternalName() { return _T("composite"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};
static CompositeMatClassDesc compositematCD;
ClassDesc* GetCompositeMatDesc() {return &compositematCD;}


class CompositeMatPBAccessor : public PBAccessor
{
public:
void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t);    // set from v
void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval &valid);    // set from v

TSTR GetLocalName(ReferenceMaker* owner, ParamID id, int tabIndex);


};


void CompositeMatPBAccessor::Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		CompositeMat* p = (CompositeMat*)owner;
		switch (id)
		{
		case compmat_amount:
			{
			int f = v.f;
			int type ;
			Interval iv;
			p->pblock2->GetValue(compmat_type,t,type,iv,tabIndex);
			if (type == 2)
				{
				if (v.f > 100.0f) v.f = 100.f;
				}


			break;
			}


		}
	}


void CompositeMatPBAccessor::Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval &valid)    // set from v
	{
		CompositeMat* p = (CompositeMat*)owner;
		switch (id)
		{
		case compmat_amount:
			{
			int f = v.f;
			int type ;
			Interval iv;
			p->pblock2->GetValue(compmat_type,t,type,iv,tabIndex);
			if (type == 2)
				{
				if (v.f > 100.0f) v.f = 100.f;
				}


			break;
			}


		}
	}


TSTR CompositeMatPBAccessor::GetLocalName(ReferenceMaker* owner, ParamID id, int tabIndex)
{
	CompositeMat* p = (CompositeMat*)owner;
	TSTR out;
	switch (id)
		{
		case compmat_amount:
			{
			out.printf(_T("%s %d"),GetString(IDS_PW_AMOUNT),tabIndex+1);
			break;
			}
		case compmat_mtls:
			{
			TSTR name;
			Mtl *sm1 = NULL;
			Interval iv;
			if ((p) && (p->pblock2)) p->pblock2->GetValue(compmat_mtls,0,sm1,iv,tabIndex);
			name = sm1->GetFullName();

			if (tabIndex == 0)
				{
				out.printf(_T("%s: %s"),GetString(IDS_PW_BASE),name);
				}
			else
				{
				out.printf(_T("%s %d: %s"),GetString(IDS_RB_MATERIAL2),tabIndex,name);
				}
			break;
			}
		}
	return out;

}


static CompositeMatPBAccessor compositeMat_accessor;



// per instance compmat block
static ParamBlockDesc2 compmat_param_blk ( compmat_params, _T("parameters"),  0, &compositematCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PB_REF, 
	//rollout
	IDD_COMPOSITE_MAT, IDS_PW_COMPOSITE_MATERIAL_PARAMS, 0, 0, NULL, 
	// params
	compmat_mtls,		_T("materialList"),	TYPE_MTL_TAB, 10,   P_SUBANIM|P_COMPUTED_NAME,	IDS_RB_MATERIAL2,	
		p_submtlno,		0,
		p_ui,			TYPE_MTLBUTTON, IDC_COMPMAT_MAT1, IDC_COMPMAT_MAT2, IDC_COMPMAT_MAT3,  IDC_COMPMAT_MAT4, 
										IDC_COMPMAT_MAT5, IDC_COMPMAT_MAT6,  IDC_COMPMAT_MAT7, 
										IDC_COMPMAT_MAT8, IDC_COMPMAT_MAT9, IDC_COMPMAT_MAT10, 
		p_accessor,		&compositeMat_accessor,
		end,

	compmat_type,		_T("mixType"),	TYPE_INT_TAB,	9,0,	IDS_PW_TYPE,
		p_default,		0,
		end,



	compmat_map_on,	_T("mapEnables"), TYPE_BOOL_TAB, 9, 0, IDS_MAPENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1, IDC_MAPON2, IDC_MAPON3, IDC_MAPON4, IDC_MAPON5,
											IDC_MAPON6, IDC_MAPON7, IDC_MAPON8, IDC_MAPON9,
		end,

	compmat_amount,  _T("amount"),		TYPE_FLOAT_TAB, 	9,P_ANIMATABLE|P_COMPUTED_NAME|P_TV_SHOW_ALL,	IDS_PW_AMOUNT, 
		p_default, 		100.0f,	
		p_range, 		0.00f, 200.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, 
						IDC_COMPMAP_AMOUNT1,IDC_COMPMAP_AMOUNTSPIN1,
						IDC_COMPMAP_AMOUNT2,IDC_COMPMAP_AMOUNTSPIN2,
						IDC_COMPMAP_AMOUNT3,IDC_COMPMAP_AMOUNTSPIN3,
						IDC_COMPMAP_AMOUNT4,IDC_COMPMAP_AMOUNTSPIN4,
						IDC_COMPMAP_AMOUNT5,IDC_COMPMAP_AMOUNTSPIN5,
						IDC_COMPMAP_AMOUNT6,IDC_COMPMAP_AMOUNTSPIN6,
						IDC_COMPMAP_AMOUNT7,IDC_COMPMAP_AMOUNTSPIN7,
						IDC_COMPMAP_AMOUNT8,IDC_COMPMAP_AMOUNTSPIN8,
						IDC_COMPMAP_AMOUNT9,IDC_COMPMAP_AMOUNTSPIN9,
//						IDC_COMPMAP_AMOUNT10,IDC_COMPMAP_AMOUNTSPIN10,
						 SPIN_AUTOSCALE, 
		p_accessor,		&compositeMat_accessor,
		end, 



	end
	);

//dialog stuff to get the Set Ref button
class CompMatDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		ICustButton *iABut[9];
		ICustButton *iSBut[9];
		ICustButton *iMBut[9];
		CompositeMat *mat;		
		CompMatDlgProc(CompositeMat *m);
		~CompMatDlgProc();
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void ReloadDialog();
		Class_ID ClassID() {return compositematClassID;}
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)mat; }

	};

CompMatDlgProc::CompMatDlgProc(CompositeMat *m)
		{
		mat = m;
		for (int i=0; i<9; i++) 
			{
			iABut[i] = NULL; 
			iSBut[i] = NULL; 
			iMBut[i] = NULL; 
			}

		}		

CompMatDlgProc::~CompMatDlgProc()
		{
		for (int i=0; i<9; i++) 
			{
			ReleaseICustButton(iABut[i]);
			ReleaseICustButton(iSBut[i]);
			ReleaseICustButton(iMBut[i]);
			iABut[i] = NULL; 
			iSBut[i] = NULL; 
			iMBut[i] = NULL; 
			}
		

		}		

void CompMatDlgProc::SetThing(ReferenceTarget *m) {
	mat = (CompositeMat*)m;
	ReloadDialog();
	}
void CompMatDlgProc::ReloadDialog()
	{
	for (int i = 0; i< 9;i++)
		{
		Interval iv;
		int type;
		mat->pblock2->GetValue(compmat_type,0,type,iv,i);
//		type =0;
		if (type == 0)
			{
			iABut[i]->SetCheck(TRUE);
			iSBut[i]->SetCheck(FALSE);
			iMBut[i]->SetCheck(FALSE);
			}
		else if (type == 1)
			{
			iABut[i]->SetCheck(FALSE);
			iSBut[i]->SetCheck(TRUE);
			iMBut[i]->SetCheck(FALSE);
			}
		else 
			{
			iABut[i]->SetCheck(FALSE);
			iSBut[i]->SetCheck(FALSE);
			iMBut[i]->SetCheck(TRUE);
///need to limit UI button
//			m->pblock();
			}
		}

	}


BOOL CompMatDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	int a = -1;
	int s = -1;
	int m = -1;
	switch (msg) {
		case WM_INITDIALOG: {

//			mod->hParams = hWnd;
			iABut[0] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A1));
			iABut[1] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A2));
			iABut[2] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A3));
			iABut[3] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A4));
			iABut[4] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A5));
			iABut[5] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A6));
			iABut[6] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A7));
			iABut[7] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A8));
			iABut[8] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A9));
//			iABut[9] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_A10));

			iSBut[0] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S1));
			iSBut[1] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S2));
			iSBut[2] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S3));
			iSBut[3] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S4));
			iSBut[4] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S5));
			iSBut[5] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S6));
			iSBut[6] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S7));
			iSBut[7] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S8));
			iSBut[8] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S9));
//			iSBut[9] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_S10));
			
			iMBut[0] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M1));
			iMBut[1] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M2));
			iMBut[2] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M3));
			iMBut[3] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M4));
			iMBut[4] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M5));
			iMBut[5] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M6));
			iMBut[6] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M7));
			iMBut[7] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M8));
			iMBut[8] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M9));
//			iMBut[9] = GetICustButton(GetDlgItem(hWnd,IDC_COMPMAT_M10));


			for (int i = 0; i< 9;i++)
				{
				iABut[i]->SetType(CBT_CHECK);
				iABut[i]->SetHighlightColor(GREEN_WASH);

				iSBut[i]->SetType(CBT_CHECK);
				iSBut[i]->SetHighlightColor(GREEN_WASH);

				iMBut[i]->SetType(CBT_CHECK);
				iMBut[i]->SetHighlightColor(GREEN_WASH);

				Interval iv;
				int type;
				mat->pblock2->GetValue(compmat_type,0,type,iv,i);
//				type =0;
				if (type == 0)
					{
					iABut[i]->SetCheck(TRUE);
					iSBut[i]->SetCheck(FALSE);
					iMBut[i]->SetCheck(FALSE);
					}
				else if (type == 1)
					{
					iABut[i]->SetCheck(FALSE);
					iSBut[i]->SetCheck(TRUE);
					iMBut[i]->SetCheck(FALSE);

					}
				else 
					{
					iABut[i]->SetCheck(FALSE);
					iSBut[i]->SetCheck(FALSE);
					iMBut[i]->SetCheck(TRUE);
					}
				}
			break;
			}
/*
		case WM_PAINT:
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
*/

		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_COMPMAT_A1: a = 0;break;
				case IDC_COMPMAT_A2: a = 1;break;
				case IDC_COMPMAT_A3: a = 2;break;
				case IDC_COMPMAT_A4: a = 3;break;
				case IDC_COMPMAT_A5: a = 4;break;
				case IDC_COMPMAT_A6: a = 5;break;
				case IDC_COMPMAT_A7: a = 6;break;
				case IDC_COMPMAT_A8: a = 7;break;
				case IDC_COMPMAT_A9: a = 8;break;
//				case IDC_COMPMAT_A10:a = 9;break;
				case IDC_COMPMAT_S1: s = 0;	break;
				case IDC_COMPMAT_S2: s = 1;	break;
				case IDC_COMPMAT_S3: s = 2;	break;
				case IDC_COMPMAT_S4: s = 3;	break;
				case IDC_COMPMAT_S5: s = 4;	break;
				case IDC_COMPMAT_S6: s = 5;	break;
				case IDC_COMPMAT_S7: s = 6;	break;
				case IDC_COMPMAT_S8: s = 7;	break;
				case IDC_COMPMAT_S9: s = 8;	break;
//				case IDC_COMPMAT_S10:s = 9;	break;
				case IDC_COMPMAT_M1: m = 0;	break;
				case IDC_COMPMAT_M2: m = 1;	break;
				case IDC_COMPMAT_M3: m = 2;	break;
				case IDC_COMPMAT_M4: m = 3;	break;
				case IDC_COMPMAT_M5: m = 4;	break;
				case IDC_COMPMAT_M6: m = 5;	break;
				case IDC_COMPMAT_M7: m = 6;	break;
				case IDC_COMPMAT_M8: m = 7;	break;
				case IDC_COMPMAT_M9: m = 8;	break;
//				case IDC_COMPMAT_M10:m = 9;	break;
				
				}
			if (a != -1)
				{
				mat->pblock2->SetValue(compmat_type,0,0,a);
				iABut[a]->SetCheck(TRUE);
				iSBut[a]->SetCheck(FALSE);
				iMBut[a]->SetCheck(FALSE);
				}
			else if (s != -1)
				{
				mat->pblock2->SetValue(compmat_type,0,1,s);
				iABut[s]->SetCheck(FALSE);
				iSBut[s]->SetCheck(TRUE);
				iMBut[s]->SetCheck(FALSE);
				}
			else if (m != -1)
				{
				mat->pblock2->SetValue(compmat_type,0,2,m);
				iABut[m]->SetCheck(FALSE);
				iSBut[m]->SetCheck(FALSE);
				iMBut[m]->SetCheck(TRUE);
				compmat_param_blk.InvalidateUI(compmat_amount,m);


				}

			break;


		}
	return FALSE;
	}


//-------------------------------------------------------------------


CompositeMat::CompositeMat(BOOL loading)
	{	
	pblock2 = NULL;
//	dlg = NULL;
//	sub1 = sub2 = NULL;	
//	map = NULL;
	ivalid.SetEmpty();
//	for (int i=0; i<3; i++) 
//		mapOn[i] = 1;
	if (!loading) {
		compositematCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
		pblock2->DefineParamAlias(_T("baseMaterial"), compmat_mtls, 0);  // JBW 5/24/99, add alias for base material to support macroRecording
		Init();
		}
	}

void CompositeMat::Init()
	{
	ivalid.SetEmpty();
	Mtl *sm1 = NULL;
	Interval iv;
	pblock2->GetValue(compmat_mtls,0,sm1,iv,0);
	if (sm1 == NULL) 
//		pblock2->SetValue(compmat_mtls,0,m,i);
		pblock2->SetValue(compmat_mtls,0, (Mtl*)GetStdMtl2Desc()->Create(),0);
	}

void CompositeMat::Reset()
	{
	compositematCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	CompMatDlgProc *parmDlg = (CompMatDlgProc *) compmat_param_blk.GetUserDlgProc();
	if (parmDlg) parmDlg->ReloadDialog();
//watje 3-22-99 set the name of the first material
	Mtl *m = NULL;;
	Interval iv;
	pblock2->GetValue(compmat_mtls,0,m,iv,0);
	if (m) m->SetName(GetString(IDS_PW_BASE));

	}

Mtl *CompositeMat::UseMtl() 
	{

	Mtl *m = NULL;;
	Interval iv;
	pblock2->GetValue(compmat_mtls,0,m,iv,0);
	return m;

	}

Color CompositeMat::GetAmbient(int mtlNum, BOOL backFace) { 
	return UseMtl()?UseMtl()->GetAmbient(mtlNum,backFace):Color(0,0,0);
	}		
Color CompositeMat::GetDiffuse(int mtlNum, BOOL backFace){ 
	return UseMtl()?UseMtl()->GetDiffuse(mtlNum,backFace):Color(0,0,0);
	}				
Color CompositeMat::GetSpecular(int mtlNum, BOOL backFace){
	return UseMtl()?UseMtl()->GetSpecular(mtlNum,backFace):Color(0,0,0);
	}		
Color CompositeMat::GetSelfIllumColor(int mtlNum, BOOL backFace){
	return UseMtl()?UseMtl()->GetSpecular(mtlNum,backFace):Color(0,0,0);
	}		

float CompositeMat::GetXParency(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}
float CompositeMat::GetShininess(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}		
float CompositeMat::GetShinStr(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}

float CompositeMat::WireSize(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->WireSize(mtlNum,backFace):0.0f;
	}
		
ParamDlg* CompositeMat::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	masterDlg = compositematCD.CreateParamDlgs(hwMtlEdit, imp, this);
	compmat_param_blk.SetUserDlgProc(new CompMatDlgProc(this));
//	dlg = new CompositeMatDlg(hwMtlEdit, imp, this);
	return masterDlg;
	}

TSTR CompositeMat::GetSubMtlSlotName(int i) {
	TSTR name;
	if (i== 0)
		name.printf("%s",GetString(IDS_PW_BASE));
	else name.printf("%s %d",GetString(IDS_PW_MAT),i);
	return name;
	}


static Color black(0,0,0);

void CompositeMat::Shade(ShadeContext& sc) {

	Mtl *sm1 = NULL;
//	Mtl *sm2 = NULL;
//	float amount1, amount2;
	int id =0; 
	float gamount;
	if (gbufID) 
		{
		sc.SetGBufferID(gbufID);
		id = gbufID;
		}

//	ShadeOutput fout;
	
	Interval iv;
	int first = 1;
	ShadeOutput out1;
	
	for (int i = 0; i < 10; i++)
		{
		BOOL enabled;
		float amount;
		if (i==0) enabled = 1;
		else pblock2->GetValue(compmat_map_on,sc.CurTime(),enabled,iv,i-1);
		if (enabled)
			{
			pblock2->GetValue(compmat_mtls,sc.CurTime(),sm1,iv,i);
			if (sm1 != NULL) 
				{
				if (i==0) amount = 100.f;
				else pblock2->GetValue(compmat_amount,sc.CurTime(),amount,iv,i-1);
				amount = amount*0.01f;
				int type;
				if (i==0) type = 2;
				else pblock2->GetValue(compmat_type,sc.CurTime(),type,iv,i-1);

				if (first ==1)
					{
					first = 0;
					sm1->Shade(sc);
					out1 = sc.out;
					if (type == 0)
						{
						out1.t.r += 1.0f-amount;
						out1.t.g += 1.0f-amount;
						out1.t.b += 1.0f-amount;
						out1.c *= amount;

						if (out1.t.r > 1.0f) out1.t.r = 1.0f;
						if (out1.t.g > 1.0f) out1.t.g = 1.0f;
						if (out1.t.b > 1.0f) out1.t.b = 1.0f;
						if (out1.t.r < 0.0f) out1.t.r = 0.0f;
						if (out1.t.g < 0.0f) out1.t.g = 0.0f;
						if (out1.t.b < 0.0f) out1.t.b = 0.0f;


						}
					out1.ior *= amount;

					gamount = 1.0f-(out1.t.r + out1.t.g + out1.t.b)/3.0f;
					}
				else
					{
//					pblock2->GetValue(compmat_mtls,sc.CurTime(),sm2,iv,i);
//sc.out.ior = s*a.ior + f*ior;
//if (f<=0.5f) gbufId = a.gbufId;
					sc.ResetOutput();
					sm1->Shade(sc);
					ShadeOutput out2 = sc.out;

					if (type == 0)  // addative
						{
						out2.t.r += 1.0f-amount;
						out2.t.g += 1.0f-amount;
						out2.t.b += 1.0f-amount;
						out2.c *= amount;

						if (out2.t.r > 1.0f) out2.t.r = 1.0f;
						if (out2.t.g > 1.0f) out2.t.g = 1.0f;
						if (out2.t.b > 1.0f) out2.t.b = 1.0f;
						if (out2.t.r < 0.0f) out2.t.r = 0.0f;
						if (out2.t.g < 0.0f) out2.t.g = 0.0f;
						if (out2.t.b < 0.0f) out2.t.b = 0.0f;


						out2.ior *= amount;

						float f1 = 1.0f-(out1.t.r + out1.t.g + out1.t.b)/3.0f; 
						float f2 = 1.0f-(out2.t.r + out2.t.g + out2.t.b)/3.0f; 
//						out2.c *= amount;

						out1.c =  out1.c *(1.0f-f2) + out2.c * (f1); 
						out1.t =  out1.t- (1.0f-out2.t);
						out1.ior = out1.ior + out2.ior;
						if (f2 > gamount)
							{
							gamount = f2;
							out1.gbufId = out1.gbufId;
							}
						if (out1.t.r > 1.0f) out1.t.r = 1.0f;
						if (out1.t.g > 1.0f) out1.t.g = 1.0f;
						if (out1.t.b > 1.0f) out1.t.b = 1.0f;
						if (out1.t.r < 0.0f) out1.t.r = 0.0f;
						if (out1.t.g < 0.0f) out1.t.g = 0.0f;
						if (out1.t.b < 0.0f) out1.t.b = 0.0f;


						}
					else if (type == 1) // subtractive
						{
						out2.t.r += 1.0f-amount;
						out2.t.g += 1.0f-amount;
						out2.t.b += 1.0f-amount;
						out2.c *= amount;

						if (out2.t.r > 1.0f) out2.t.r = 1.0f;
						if (out2.t.g > 1.0f) out2.t.g = 1.0f;
						if (out2.t.b > 1.0f) out2.t.b = 1.0f;
						if (out2.t.r < 0.0f) out2.t.r = 0.0f;
						if (out2.t.g < 0.0f) out2.t.g = 0.0f;
						if (out2.t.b < 0.0f) out2.t.b = 0.0f;


						out2.ior *= amount;

						float f1 = 1.0f-(out1.t.r + out1.t.g + out1.t.b)/3.0f; 
						float f2 = 1.0f-(out2.t.r + out2.t.g + out2.t.b)/3.0f; 
//						out2.c *= amount;

						out1.c =  out1.c *(1.0f-f2) - out2.c * f1; 
						out1.t =  out1.t- (1.0f-out2.t);
						out1.ior = out1.ior + out2.ior;
						if (f2 > gamount)
							{
							gamount = f2;
							out1.gbufId = out1.gbufId;
							}
						if (out1.t.r > 1.0f) out1.t.r = 1.0f;
						if (out1.t.g > 1.0f) out1.t.g = 1.0f;
						if (out1.t.b > 1.0f) out1.t.b = 1.0f;
						if (out1.t.r < 0.0f) out1.t.r = 0.0f;
						if (out1.t.g < 0.0f) out1.t.g = 0.0f;
						if (out1.t.b < 0.0f) out1.t.b = 0.0f;
						}
					else //mix
						{
						out1.MixIn(out2,1.0f-amount);
						}

					}


				}
			}
		}
	sc.out = out1;

/*
	if (sm1 != NULL) sm1->Shade(sc);
	return;
	if ((sm1) && (sm2))
		{
		sc.ResetOutput();
		sm1->Shade(sc);
		ShadeOutput out1 = sc.out;
		sc.ResetOutput();
		sm2->Shade(sc);
		ShadeOutput out2 = sc.out;
		float f1 = 1.0f-(out1.t.r + out1.t.g + out1.t.b)/3.0f; 
		float f2 = 1.0f-(out2.t.r + out2.t.g + out2.t.b)/3.0f; 
		sc.out.c =  out1.c *(1.0f-f2) + out2.c * f1; 
		sc.out.t =  out1.t- out2.t;

//		if (sc.out.t.r > 1.0f) sc.out.t.r = 1.0f;
//		if (sc.out.t.g > 1.0f) sc.out.t.g = 1.0f;
//		if (sc.out.t.b > 1.0f) sc.out.t.b = 1.0f;
//		if (sc.out.t.r < 0.0f) sc.out.t.r = 0.0f;
//		if (sc.out.t.g < 0.0f) sc.out.t.g = 0.0f;
//		if (sc.out.t.b < 0.0f) sc.out.t.b = 0.0f;

//sc.out.ior = s*a.ior + f*ior;
//if (f<=0.5f) gbufId = a.gbufId;
		
		}
*/
	}

void CompositeMat::Update(TimeValue t, Interval& valid)
	{	
	ivalid = FOREVER;
	for (int i = 0; i < 10; i++)
		{
		Mtl *sub;
		float u;
		pblock2->GetValue(compmat_mtls,t,sub,valid,i);
		if (sub != NULL)
			{
			valid &= sub->Validity(t);
			if (i != 9)
				pblock2->GetValue(compmat_amount,t,u,valid,i);
			}
		}
	valid &= ivalid;
	}

Interval CompositeMat::Validity(TimeValue t)
	{
	Interval valid = FOREVER;		
	for (int i = 0; i < 10; i++)
		{
		Mtl *sub;
		float u;
		pblock2->GetValue(compmat_mtls,t,sub,valid,i);
		if (sub != NULL)
			{
			valid &= sub->Validity(t);
			if (i != 9)
				pblock2->GetValue(compmat_amount,t,u,valid,i);
			}
		}
//	pblock2->GetValue(compmat_type,t,currentType,ivalid);

	return valid;
	}

Animatable* CompositeMat::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock2;
		default: return NULL;
		}
	}

TSTR CompositeMat::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_DS_PARAMETERS);
		default: return _T("");
		}
	}

RefTargetHandle CompositeMat::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock2;
		default: return NULL;
		}
	}

void CompositeMat::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock2 = (IParamBlock2*)rtarg; break;
		}
	}

RefTargetHandle CompositeMat::Clone(RemapDir &remap)
	{
	CompositeMat *mtl = new CompositeMat(FALSE);
	*((MtlBase*)mtl) = *((MtlBase*)this);  // copy superclass stuff
	mtl->ReplaceReference(PB_REF,remap.CloneRef(pblock2));
	return mtl;
	}

RefResult CompositeMat::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (hTarget == pblock2)
				{
				ivalid.SetEmpty();
				compmat_param_blk.InvalidateUI();
				// NotifyChanged();  //DS this is redundant
				}
			else
				{
				ivalid.SetEmpty();
				NotifyChanged();
				}
			break;
			
		}
	return REF_SUCCEED;
	}


//
// Note: ALL Materials and texmaps must have a Save and Load to save and load
// the MtlBase info.
#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define VER_CHUNK 0x1010

IOResult CompositeMat::Save(ISave *isave) { 
	IOResult res;
	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	int ver = 2;
	isave->BeginChunk(VER_CHUNK);
	isave->Write(&ver,sizeof(ver),&nb);			
	isave->EndChunk();

	return IO_OK;
	}	
	  

//watje
class CompositeMatPostLoadCallback:public  PostLoadCallback
{
public:
	CompositeMat      *s;
	CompositeMatPostLoadCallback(CompositeMat *r) {s=r;}
	void proc(ILoad *iload);
};


void CompositeMatPostLoadCallback::proc(ILoad *iload)
{
	if (s->pblock2->Count(compmat_type) == 10)
		s->pblock2->Delete(compmat_type, 0,1);
	if (s->pblock2->Count(compmat_map_on) == 10)
		s->pblock2->Delete(compmat_map_on, 0,1);
	if (s->pblock2->Count(compmat_amount) == 10)
		s->pblock2->Delete(compmat_amount, 0,1);

//	( checker_map1_on, 0, s->mapOn[0]);
//	s->pblock->SetValue( checker_map2_on, 0, s->mapOn[1]);

	delete this;

}
 



IOResult CompositeMat::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	IOResult res;
	int ver = 1;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case VER_CHUNK:
				iload->Read(&ver,sizeof(ver),&nb);			
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	if (ver == 1)
		{
		CompositeMatPostLoadCallback* checkerplcb = new CompositeMatPostLoadCallback(this);
		iload->RegisterPostLoadCallback(checkerplcb);

		}

	return IO_OK;
	}


float CompositeMat::EvalDisplacement(ShadeContext& sc) {

	int first = 1;
	float disp = 0.0f;
	Interval iv;
	Mtl *sm1 = NULL;
	for (int i = 0; i < 10; i++)
		{
		BOOL enabled;
		float amount;
		if (i==0) enabled = 1;
		else pblock2->GetValue(compmat_map_on,sc.CurTime(),enabled,iv,i-1);
		if (enabled)
			{
			pblock2->GetValue(compmat_mtls,sc.CurTime(),sm1,iv,i);

			if (sm1 != NULL) 
				{
				if (i==0) amount = 100.f;
				else pblock2->GetValue(compmat_amount,sc.CurTime(),amount,iv,i-1);

				amount = amount*0.01f;
				int type;
				if (i==0) type = 0;
				else pblock2->GetValue(compmat_type,sc.CurTime(),type,iv,i-1);
				if (first ==1)
					{
					float d2 = sm1->EvalDisplacement(sc);
					disp = d2;

					}
				else
					{
					if (type == 0)  // addative
						{
						float d2 = sm1->EvalDisplacement(sc);
						disp += d2;

						}
					else if (type == 1) // subtractive
						{
						float d2 = sm1->EvalDisplacement(sc);
						disp -= d2;

						}
					else //mix
						{
						float d2 = sm1->EvalDisplacement(sc);
						disp = (1.0f-amount)*disp + amount*d2;
						}

					}


				}
			}
		}

/*
	Mtl *sm1 = mapOn[0]?sub1:NULL;
	Mtl *sm2 = mapOn[1]?sub2:NULL;
	Texmap *mp = mapOn[2]?map:NULL;
	
	float mix = mp ? mp->EvalMono(sc) : u;
	if (mp && useCurve) mix = mixCurve(mix);
	if (mix<0.0001f) {
		return (sm1)?sm1->EvalDisplacement(sc):0.0f;
	} else
	if (mix>0.9999f) {
		return (sm2)?sm2->EvalDisplacement(sc):0.0f;
	} else {
		if (sm1) {
			float d = sm1->EvalDisplacement(sc);
			if(sm2) {
				float d2 = sm2->EvalDisplacement(sc);
				d = (1.0f-mix)*d + mix*d2;
				}
			return d;
			}
		else {
			if (sm2) 
				return sm2->EvalDisplacement(sc);
			}
		}
*/
	return disp;
	}

Interval CompositeMat::DisplacementValidity(TimeValue t) {
	Interval iv;
	iv.SetInfinite();
	Mtl *sm1 = NULL;

	for (int i = 0; i < 10; i++)
		{
		BOOL enabled;
		if (i==0) enabled = 1;
		else pblock2->GetValue(compmat_map_on,t,enabled,iv,i-1);

		if (enabled)
			{
			pblock2->GetValue(compmat_mtls,t,sm1,iv,i);
			if (sm1 != NULL) 
				{
				iv &= sm1->DisplacementValidity(t);		

				}
			}
		}

/*
	Mtl *sm1 = mapOn[0]?sub1:NULL;
	Mtl *sm2 = mapOn[1]?sub2:NULL;
	Texmap *mp = mapOn[2]?map:NULL;
	if (sm1) 	
		iv &= sm1->DisplacementValidity(t);		
	if (sm2) 	
		iv &= sm2->DisplacementValidity(t);		
	if (mp) { 	
		Interval ivm;
		ivm.SetInfinite();
		mp->Update(t,ivm);
		iv &= ivm;
		}
*/
	return iv;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\bmtex.cpp ===
/**********************************************************************
 *<
	FILE: BMTEX.CPP

	DESCRIPTION: BMTEX 2D Texture map.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include <bmmlib.h>
#include "texutil.h"
#include "iparamm2.h"
#include "macrorec.h"
#include "notify.h"

extern HINSTANCE hInstance;

// ParamBlock entries
/*
#define PB_CLIPU	0
#define PB_CLIPV	1
#define PB_CLIPW	2
#define PB_CLIPH	3
#define PB_JITTER   4
#define NPARAMS 5
*/
// Image filtering types
#define FILTER_PYR     0
#define FILTER_SAT     1
#define FILTER_NADA	   2

// Alpha source types
#define ALPHA_FILE 	0
#define ALPHA_RGB	2
#define ALPHA_NONE	3

// End conditions:
#define END_LOOP     0
#define END_PINGPONG 1
#define END_HOLD     2

#define NCOLS 0

#define UVGEN_REF 0
#define PBLOCK_REF 1 
#define TEXOUT_REF 2
#define PBLOCKTIME_REF 3 

class BMTex;
class BMTexDlg;

static Class_ID bmTexClassID(BMTEX_CLASS_ID,0);
static AColor black(0.0f,0.0f,0.0f,0.0f);
#if 0
static void LoadFailedMsg(const TCHAR* name) {
	if (name==NULL) return;
	TCHAR msg[128];
	wsprintf(msg,GetString(IDS_DS_FILE_NOT_FOUND), name);
	MessageBox(NULL, msg, GetString(IDS_DS_BITMAP_TEXTURE_ERR), MB_TASKMODAL);
	}
#endif

static void InvalidNameMsg(const TCHAR* name) {
	if (name==NULL) return;
	TCHAR msg[128];
	wsprintf(msg,_T("Invalid File Name: %s"), name);
	MessageBox(NULL, msg, GetString(IDS_DS_BITMAP_TEXTURE_ERR), MB_TASKMODAL);
	}

// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs, bmtex_time
enum { bmtex_params,bmtex_time};  // pblock ID

enum 
{ 
	bmtex_clipu,bmtex_clipv,bmtex_clipw,bmtex_cliph,
	bmtex_jitter,bmtex_usejitter,
	bmtex_apply,bmtex_crop_place,
	bmtex_filtering,
	bmtex_monooutput,
	bmtex_rgboutput,
	bmtex_alphasource,
	bmtex_premultalpha,
	bmtex_bitmap,
	bmtex_coords,	 // access for UVW mapping
	bmtex_output,	 //output window
	bmtex_filename   // bitmap filename virtual parameter, JBW 2/23/99
};


enum 
{ 
	bmtex_start,bmtex_playbackrate, bmtex_endcondition
};





//------------------------------------------------------------------------
// BMSampler
//------------------------------------------------------------------------

class BMSampler: public MapSampler {
	Bitmap *bm;
	BMTex *tex;
	int alphaSource;
	float u0,v0,u1,v1,ufac,vfac,ujit,vjit;
	int bmw,bmh,clipx, clipy, cliph;
	float fclipw,fcliph, fbmh, fbmw;
	public:
		BMSampler() { bm = NULL; ufac = vfac = 0.0f; }
		void Init(BMTex *bmt);
		int PlaceUV(ShadeContext& sc, float &u, float &v, int iu, int iv);
		void PlaceUVFilter(ShadeContext& sc, float &u, float &v, int iu, int iv);
		AColor Sample(ShadeContext& sc, float u,float v);
		AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv);
//		float SampleMono(ShadeContext& sc, float u,float v);
//		float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv);
	} ;

//------------------------------------------------------------------------
// BM\AlphaSampler
//------------------------------------------------------------------------
class BMAlphaSampler: public MapSampler {
	Bitmap *bm;
	BMTex *tex;
	float u0,v0,u1,v1,ufac,vfac,ujit,vjit;
	int bmw,bmh,clipx, clipy, cliph;
	float fclipw,fcliph, fbmh, fbmw;
	public:
		BMAlphaSampler() { bm = NULL; ufac = vfac = fbmw = fbmh = 0.0f; }
		void Init(BMTex *bmt);
		int PlaceUV(ShadeContext &sc, float &u, float &v, int iu, int iv);
		void  PlaceUVFilter(ShadeContext &sc, float &u, float &v, int iu, int iv);
		AColor Sample(ShadeContext& sc, float u,float v) { return AColor(0,0,0,0);}
		AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv) { return AColor(0,0,0,0);}
		float SampleMono(ShadeContext& sc, float u,float v);
		float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv);
	} ;



//------------------------------------------------------------------------
// BMCropper
//------------------------------------------------------------------------
class BMCropper:public CropCallback {
	BMTexDlg *dlg;
	BMTex *tex;
	BOOL mode;
	float u0,v0,w0,h0;
	public:
	float GetInitU() { return u0; }
	float GetInitV() { return v0; }
	float GetInitW() { return w0; }
	float GetInitH() { return h0; }
	BOOL GetInitMode() { return mode; }
	void SetValues(float u, float v, float w, float h, BOOL md);
	void OnClose();
	void Init(BMTexDlg *tx, TimeValue t);
	};

//------------------------------------------------------------------------
// BMTexDlg
//------------------------------------------------------------------------

//class BMTexDlg: public ParamDlg , public DADMgr{
class BMTexDlg: public ParamMap2UserDlgProc , public DADMgr{
	friend class BMCropper;
	public:
		HWND hwmedit;	 // window handle of the materials editor dialog
		IMtlParams *ip;
		BMTex *theBMTex;	 // current BMTex being edited.
		HWND hPanel; // Rollup pane
//		HWND hTime; // Time Rollup pane
		TimeValue curTime; 
//		ICustButton *iName;
		BOOL valid;
		BOOL isActive;
		BOOL cropping;
		BMCropper cropper;

		//-----------------------------
		BMTexDlg(HWND hwMtlEdit, IMtlParams *imp, BMTex *m); 
		~BMTexDlg();

		// inherited from ParamMap2UserDlgProc
		void Update(TimeValue t);
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		

//		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
		BOOL TimeProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
		void HandleNameButton();
		void LoadDialog(BOOL draw);  // stuff params into dialog
		void ReloadDialog();
		void BMNameChanged();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void ActivateDlg(BOOL onOff) {}
		void StuffBMNameField(HWND hwndDlg);
		void EnableAlphaButtons(BOOL isNew=FALSE);
		void EnableViewImage();
		void Invalidate() { valid = FALSE;	InvalidateRect(hPanel,NULL,0); }
		BOOL KeyAtCurTime(int id);
		void ShowCropImage();
		void RemoveCropImage();

		// methods inherited from ParamDlg:
		Class_ID ClassID() {return bmTexClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theBMTex; }
		void DeleteThis() { delete this;  }	


		// DADMgr methods
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p) { return BITMAPDAD_CLASS_ID; }
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
			if (hfrom==hto) return FALSE;
			return (type==BITMAPDAD_CLASS_ID)?1:0;
			}
		int SlotOwner() { return OWNER_MTL_TEX;	}
	    ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		BOOL  LetMeHandleLocalDAD() { return 0; } 

	};

class BMTexNotify: public BitmapNotify {
	public:
	BMTex *tex;
	void SetTex(BMTex *tx) { tex  = tx; }
	int Changed(ULONG flags);
	};

class BMTexPostLoad;

//--------------------------------------------------------------
// BMTex: A 2D texture map
//--------------------------------------------------------------

class BMTex: public BitmapTex {
	friend class BMTexPostLoad;
	friend class BMTexDlg;
	friend class BMTexDlgProc;
	friend class BMSampler;
	friend class BMAlphaSampler;
	friend class BMCropper;

	static ParamDlg* uvGenDlg;	
	static ParamDlg* texoutDlg;

	UVGen *uvGen;		   // ref #0

	
	TextureOutput *texout; // ref #2

	BMTexNotify bmNotify;
	TexHandle *texHandle;
	Interval ivalid;
	BMSampler mysamp;
	BMAlphaSampler alphasamp;
	public:
		BOOL isParm2;

		float pbRate;
		TimeValue startTime;
		BOOL applyCrop;
		BOOL loading;
		BOOL loadingOld;
		BOOL placeImage;
		BOOL randPlace;
		BOOL fileNotFound;
		int filterType;
		int alphaSource;
		int rollScroll;
		int endCond;
		int alphaAsMono;
		int alphaAsRGB;
		float clipu, clipv, clipw, cliph, jitter;
		BOOL premultAlpha;
		BOOL isNew;
		BOOL loadFailed; 
		BOOL inRender;
		int texTime;
		Interval texValid;
		Interval clipValid;
		float rumax,rumin,rvmax,rvmin;


		IParamBlock2 *pblock;   // ref #1
		IParamBlock2 *pblockTime;   // ref #3
		static BMTexDlg *paramDlg;
		PBBitmap *bitmapPB;
		BitmapInfo bi;
		TSTR bmName; // for loading old files only
		Bitmap *thebm;

		BMTex();
		~BMTex();
		IMtlParams *ip;
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }
		TSTR GetFullName();

		void SetOutputLevel(TimeValue t, float v) {texout->SetOutputLevel(t,v); }
		void SetFilterType(int ft);
		void SetAlphaSource(int as);
		void SetEndCondition(int endcond);
//		void SetEndCondition(int endcond) { 
//            #ifndef DESIGN_VER
//			pblockTime->SetValue( bmtex_endcondition, 0, endcond);		
//			endCond = endcond; 
//			ParamID changedParam = pblock->LastNotifyParamID();
//			bmtex_time_param_blk.InvalidateUI(changedParam);
//            #endif // DESIGN_VER
//			}
		void SetAlphaAsMono(BOOL onoff) { 
			pblock->SetValue( bmtex_monooutput, 0, onoff);		
			alphaAsMono = onoff; 
			}
		void SetAlphaAsRGB(BOOL onoff) { 
			pblock->SetValue( bmtex_rgboutput, 0, onoff);		
			alphaAsRGB = onoff; 
			}
		void SetPremultAlpha(BOOL onoff) { 
			pblock->SetValue( bmtex_premultalpha, 0, onoff);		
			premultAlpha = onoff; 
			}
		void SetMapName(TCHAR *name) { 
			if (name) {
				bi.SetName(name); 
				PBBitmap bt(bi);
				pblock->SetValue(bmtex_bitmap, 0, &bt);
				FreeBitmap();
				fileNotFound = FALSE;
				if (paramDlg)
					ReloadBitmap();
				if (TestMtlFlag(MTL_TEX_DISPLAY_ENABLED)) {
					if (ip)
						ip->MtlChanged();
					}
				}
			}
			void SetPlaybackRate(float r); 
			void SetStartTime(TimeValue t);

/****
		void SetStartTime(TimeValue t) {
            #ifndef DESIGN_VER
			pblockTime->SetValue( bmtex_start, 0, t);		
			startTime = t; 
            #endif // DESIGN_VER
			}
		void SetPlaybackRate(float r) { 
            #ifndef DESIGN_VER
			pblockTime->SetValue( bmtex_playbackrate, 0, r);		
			pbRate = r; 
            #endif // DESIGN_VER
			}
****/
		void SetClipU(TimeValue t, float f);
		void SetClipV(TimeValue t, float f) ;
		void SetClipW(TimeValue t, float f) ;
		void SetClipH(TimeValue t, float f) ;
		void SetJitter(TimeValue t, float f);

		int GetFilterType() { return filterType; }
		int GetAlphaSource() { return alphaSource; }
		int GetEndCondition() { return endCond; }
		BOOL GetAlphaAsMono(BOOL onoff) { return alphaAsMono; }
		BOOL GetAlphaAsRGB(BOOL onoff) { return alphaAsRGB; }
		BOOL GetPremultAlpha(BOOL onoff) { return premultAlpha; }
		TCHAR *GetMapName() {
			UpdateBIName(); // CCJ 4/27/99
			return (TCHAR *)bi.Name();
			}
		TimeValue GetStartTime() { return startTime; }
		float GetPlaybackRate() { return pbRate; }
		StdUVGen* GetUVGen() { return (StdUVGen*)uvGen; }
		TextureOutput* GetTexout() { return texout; }
		Bitmap *GetBitmap(TimeValue t) { LoadBitmap(t); 	return thebm; }
	    float GetClipU(TimeValue t) { 	
	    	return pblock->GetFloat( bmtex_clipu, t); 	
	    	}
	    float GetClipV(TimeValue t) { 							
	    	return pblock->GetFloat( bmtex_clipv, t); 
			}
	    float GetClipW(TimeValue t) { 
			return pblock->GetFloat( bmtex_clipw, t); 
			}
	    float GetClipH(TimeValue t) { 
			return pblock->GetFloat( bmtex_cliph, t); 
			}
	    float GetJitter(TimeValue t) { 
			return pblock->GetFloat( bmtex_jitter, t); 
			}
		void StuffCropValues(); // stuff new values into the cropping VFB
		void EnableStuff();
		void UpdateBIName() {
			pblock->GetValue( bmtex_bitmap, 0,bitmapPB, clipValid );
			if (bitmapPB != NULL)   
				bi = bitmapPB->bi;	  //DS 2/24/99
			else bi.SetName(_T(""));   // DS 3/23/99
			}

		void UpdtSampler() {
			mysamp.Init(this);
			alphasamp.Init(this);
			}

		void NotifyChanged();
		void FreeBitmap();
 		BMMRES LoadBitmap(TimeValue t, BOOL quiet=TRUE, BOOL reload=FALSE);
		int CalcFrame(TimeValue t);
		void ScaleBitmapBumpAmt(float f);
		void ReloadBitmap();
/*
		void UpdateTexture()
			{
			ReloadBitmap();
			NotifyChanged();
			if (ip != NULL)	ip->MtlChanged();
//			UpdateMtlDisplay(); // redraw viewports
//			return 1;
			}

*/
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		void DiscardTexHandle();

		BOOL SupportTexDisplay() { return TRUE; }
		void ActivateTexDisplay(BOOL onoff);
		DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker);
		void GetUVTransform(Matrix3 &uvtrans) { uvGen->GetUVTransform(uvtrans); }
		int GetTextureTiling() { return  uvGen->GetTextureTiling(); }
		int GetUVWSource() { return uvGen->GetUVWSource(); }
		int GetMapChannel () { return uvGen->GetMapChannel(); }
		UVGen *GetTheUVGen() { return uvGen; }
					
		int RenderBegin(TimeValue t, ULONG flags) {	
			inRender = TRUE;
			return 1; 	
			}
		int RenderEnd(TimeValue t) { 	
			inRender = FALSE;	
			return 1; 	
			}
		int LoadMapFiles(TimeValue t) {	LoadBitmap(t,1,1);	return 1;	}
		void RenderBitmap(TimeValue t, Bitmap *bm, float scale3D, BOOL filter);

		Class_ID ClassID() {	return bmTexClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_BITMAP); }  
		void DeleteThis() { delete this; }	

		// Requirements
		ULONG LocalRequirements(int subMtlNum) {
			return uvGen->Requirements(subMtlNum); 
			}

		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			uvGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		int NumSubs() { return 4; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }
		void InitSlotType(int sType) { if (uvGen) uvGen->InitSlotType(sType); }

		// From ref
		int NumRefs() { return 4; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int RemapRefOnLoad(int iref); 

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// From Animatable
		void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) {
			UpdateBIName(); // DS 2/24/99
			bi.EnumAuxFiles(nameEnum,flags);
			}
		int SetProperty(ULONG id, void *data);
		void FreeAllBitmaps() { 
			FreeBitmap(); 
			}

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 2; }					// return number of ParamBlocks in this instance

		IParamBlock2* GetParamBlock(int i) { 
										if (i == 0) return pblock; 
											else if (i == 1) return pblockTime; 
											else return NULL;			 } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) 
													{if (pblock->ID() == id) return pblock ;
													 else if (pblockTime->ID() == id) return pblockTime ;
													else return  NULL; } // return id'd ParamBlock

//		{ return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

//watje pops up a bitmap loader dlg
		BitmapLoadDlg();
//watje forces the bitmap to reload and view to be redrawn
		ReloadBitmapAndUpdate();



	};

ParamDlg* BMTex::uvGenDlg;	
ParamDlg* BMTex::texoutDlg;
BMTexDlg* BMTex::paramDlg;

//------------------------------------------------------------------------
// BMSampler -- Methods
//------------------------------------------------------------------------
void BMSampler::Init(BMTex *bmt) {
	 bm = bmt->thebm; 
	 tex = bmt; 
	 alphaSource = bmt->alphaSource; 
	 if (bm) {
		u0 = tex->clipu;
		v0 = tex->clipv;
		u1 = tex->clipu + ufac;
		v1 = tex->clipv + vfac;
		ufac= tex->clipw;
		vfac = tex->cliph;
		bmw = bm->Width();
		bmh = bm->Height();
		fbmw = float(bmw/*-1*/);  // DS 4/23/99
		fbmh = float(bmh/*-1*/);  // DS 4/23/99
		clipx = int(tex->clipu*fbmw);
		clipy = int(tex->clipv*fbmh);
		fclipw = tex->clipw*fbmw;
		fcliph = tex->cliph*fbmh;
		cliph = int(fcliph);
		ujit = tex->jitter*(1.0f-ufac);
		vjit = tex->jitter*(1.0f-vfac);
		}
	 }


static inline void Jitter(ShadeContext &sc, float ujit, float vjit, float &ru, float &rv, int iu, int iv) {
//	srand(((sc.uTile+593)*14693+(sc.vTile+4991)*2517)&0x7fff);
	srand(((iu+593)*14693+(iv+967)*29517)&0x7fff);
	int urnd = rand()&0x7fff;
	rand();	 // these extra calls seem to make the pattern more random
	rand();	 // these extra calls seem to make the pattern more random
	int vrnd = rand()&0x7fff;
	ru = ujit*float(urnd)/float(32767.0f);
	rv = vjit*float(vrnd)/float(32767.0f);
	}

int BMSampler::PlaceUV(ShadeContext &sc, float &u, float &v, int iu, int iv) {
	if (tex->randPlace) {
		float ru,rv;
		Jitter(sc,ujit,vjit,ru,rv,iu,iv);
		if (u<ru||v<rv||u>ru+ufac||v>rv+vfac) return 0;
		// note jitter ignores u0,v0, effectively setting them to zero
		u = (u-ru)/ufac;
		v = (v-rv)/vfac;  
		}
	else {
		if (u<u0||v<v0||u>u1||v>v1) return 0;
		u = (u-u0)/ufac;
		v = (v-v0)/vfac;
		}
	return 1;
	}

void BMSampler::PlaceUVFilter(ShadeContext &sc, float &u, float &v, int iu, int iv) {
	if (tex->randPlace) {
		float ru,rv;
		Jitter(sc,ujit,vjit,ru,rv,iu,iv);
		// note jitter ignores u0,v0, effectively setting them to zero
		u = (u-ru)/ufac;
		v = (v-rv)/vfac;
		}
	else {
		u = (u-u0)/ufac;
		v = (v-v0)/vfac;
		}
	}

AColor BMSampler::Sample(ShadeContext& sc, float u,float v) {
	BMM_Color_64 c;
	int x,y;
	float fu,fv;
	fu = frac(u);
	fv = 1.0f-frac(v);
	if (tex->applyCrop) {
		if (tex->placeImage) {
			if (!PlaceUV(sc,fu, fv, int(u), int(v))) return black;
			x = (int)(fu*fbmw);
			y = (int)(fv*fbmh);
			}
		else {
			x = mod(clipx + (int)(fu*fclipw),bmw);
			y = mod(clipy + (int)(fv*fcliph),bmh);
			}
		}
	else {
		x = (int)(fu*fbmw);
		y = (int)(fv*fbmh);
		}
	bm->GetLinearPixels(x,y,1,&c);
	switch(alphaSource) {
		case ALPHA_NONE:  c.a = 0xffff; break;
		case ALPHA_RGB:   c.a = (c.r+c.g+c.b)/3; break;
		//  TBD
		// XPCOL needs to be handled in bitmap for filtering. 
		// Need to open a bitmap with this property.
		//	case ALPHA_XPCOL:  break; 
		}
	return c;
	}


AColor BMSampler::SampleFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	BMM_Color_64 c;
	float fu,fv;
	fu = frac(u);
	fv = 1.0f-frac(v);
	if (tex->applyCrop) {
		if (tex->placeImage) {
			PlaceUVFilter(sc,fu, fv, int(u), int(v));
			du /= ufac;
			dv /= vfac;
			float du2 = 0.5f*du;
			float ua = fu-du2;
			float ub = fu+du2;
			if (ub<=0.0f||ua>=1.0f) return black;
			float dv2 = 0.5f*dv;
			float va = fv-dv2;
			float vb = fv+du2;
			if (vb<=0.0f||va>=1.0f) return black;
			BOOL clip = 0;
			if (ua<0.0f) { ua=0.0f; clip = 1; }
			if (ub>1.0f) { ub=1.0f;	clip = 1; }
			if (va<0.0f) { va=0.0f;	clip = 1; }
			if (vb>1.0f) { vb=1.0f;	clip = 1; }
			bm->GetFiltered(fu,fv,du,dv,&c);
			switch(alphaSource) {
				case ALPHA_NONE:  c.a = 0xffff; break;
				case ALPHA_RGB:   c.a = (c.r+c.g+c.b)/3; break;
				}
			AColor ac(c);
			if (clip) {
				float f = ((ub-ua)/du) * ((vb-va)/dv);
				ac *= f;
				}
			return ac;
			}
		else {
			fu = (u0 + ufac*fu);
			fv = (v0 + vfac*fv);
			du *= ufac;
			dv *= vfac;
			bm->GetFiltered(fu,fv,du,dv,&c);
			}
		}

	else 
		bm->GetFiltered(fu,fv,du,dv,&c);
	switch(alphaSource) {
		case ALPHA_NONE:  c.a = 0xffff; break;
		case ALPHA_RGB:   c.a = (c.r+c.g+c.b)/3; break;
		}
	return c;
	}


//------------------------------------------------------------------------
// BMAlphaSampler -- Methods
//------------------------------------------------------------------------
void BMAlphaSampler::Init(BMTex *bmt) { 
	bm = bmt->thebm; 
	tex = bmt; 
	if (bm) {
		u0 = tex->clipu;
		v0 = tex->clipv;
		ufac= tex->clipw;
		vfac = tex->cliph;
		bmw = bm->Width();
		bmh = bm->Height();
		fbmw = float(bmw-1);
		fbmh = float(bmh-1);
		clipx = int(tex->clipu*fbmw);
		clipy = int(tex->clipv*fbmh);
		fclipw = tex->clipw*fbmw;
		fcliph = tex->cliph*fbmh;
		cliph = int(fcliph);
		ujit = tex->jitter*(1.0f-ufac);
		vjit = tex->jitter*(1.0f-vfac);
		}
	}

int BMAlphaSampler::PlaceUV(ShadeContext &sc, float &u, float &v, int iu, int iv) {
	if (tex->randPlace) {
		float ru,rv;
		Jitter(sc,ujit,vjit,ru,rv,iu,iv);
		if (u<ru||v<rv||u>ru+ufac||v>rv+vfac) return 0;
		u = (u-ru)/ufac;
		v = (v-rv)/vfac;
		}
	else {
		if (u<u0||v<v0||u>u1||v>v1) return 0;
		u = (u-u0)/ufac;
		v = (v-v0)/vfac;
		}

	return 1;
	}

void BMAlphaSampler::PlaceUVFilter(ShadeContext &sc, float &u, float &v, int iu, int iv) {
	if (tex->randPlace) {
		float ru,rv;
		Jitter(sc,ujit,vjit,ru,rv,iu,iv);
		u = (u-ru)/ufac;
		v = (v-rv)/vfac;
		}
	else {
		u = (u-u0)/ufac;
		v = (v-v0)/vfac;
		}
	}

float BMAlphaSampler::SampleMono(ShadeContext& sc, float u,float v) {
	BMM_Color_64 c;
	int x,y;
	float fu,fv;
	fu = frac(u);
	fv = 1.0f-frac(v);
	if (tex->applyCrop) {
		if (tex->placeImage) {
			if (!PlaceUV(sc,fu,fv,int(u),int(v))) return 0.0f;
			x = (int)(fu*fclipw);
			y = (int)(fv*fcliph);
			}
		else {
			x = mod(clipx + (int)(fu*fclipw),bmw);
			y = mod(clipy + cliph-1-(int)(fv*fcliph),bmh);
			}
		}
	else {
		x = (int)(fu*fbmw);
		y = (int)(fv*fbmh);
		}
	bm->GetLinearPixels(x,y,1,&c);
	return( (float)c.a/65536.0f);
	}

float BMAlphaSampler::SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	BMM_Color_64 c;
	float fu,fv;
	fu = frac(u);
	fv = 1.0f-frac(v);
	if (tex->applyCrop) {
		if (tex->placeImage) {
			PlaceUVFilter(sc,fu, fv, int(u), int(v));
			du /= ufac;
			dv /= vfac;
			float du2 = 0.5f*du;
			float ua = fu-du2;
			float ub = fu+du2;
			if (ub<=0.0f||ua>=1.0f) return 0.0f;
			float dv2 = 0.5f*dv;
			float va = fv-dv2;
			float vb = fv+du2;
			if (vb<=0.0f||va>=1.0f) return 0.0f;
			BOOL clip = 0;
			if (ua<0.0f) { ua=0.0f; clip = 1; }
			if (ub>1.0f) { ub=1.0f;	clip = 1; }
			if (va<0.0f) { va=0.0f;	clip = 1; }
			if (vb>1.0f) { vb=1.0f;	clip = 1; }
			bm->GetFiltered(fu,fv,du,dv,&c);
			float alph = (float)c.a/65536.0f;
			if (clip) {
				float f = ((ub-ua)/du) * ((vb-va)/dv);
				alph *= f;
				}
			return alph;
			}
		else {
			fu = frac(u0 + ufac*fu);
			fv = frac(v0 + vfac*fv);
			du *= ufac;
			dv *= vfac;
			}
		}
	bm->GetFiltered(fu,fv,du,dv,&c);
	return( (float)c.a/65536.0f);
	}

//------------------------------------------------------------------------
// BMCropper  -- Methods
//------------------------------------------------------------------------

void BMCropper::Init(BMTexDlg *txdlg, TimeValue t) {
	dlg = txdlg;
	tex = txdlg->theBMTex;
	u0 = tex->GetClipU(t);
	v0 = tex->GetClipV(t);
	w0 = tex->GetClipW(t);
	h0 = tex->GetClipH(t);
	mode= tex->placeImage;
	}

void BMCropper::SetValues(float u, float v, float w, float h, BOOL md) {
	BOOL b = FALSE;
	if (u!=tex->clipu) {
		tex->SetClipU(dlg->ip->GetTime(), u);
		b = TRUE;		
		}
	if (v!=tex->clipv) {
		tex->SetClipV(dlg->ip->GetTime(), v);
		b = TRUE;		
		}
	if (w!=tex->clipw) {
		tex->SetClipW(dlg->ip->GetTime(), w);
		b = TRUE;		
		}
	if (h!=tex->cliph) {
		tex->SetClipH(dlg->ip->GetTime(), h);
		b = TRUE;		
		}

	if (md!=tex->placeImage) {
		tex->placeImage= md;
		b = TRUE;
		}

	if(b) {
		tex->DiscardTexHandle();
		tex->NotifyChanged();
		dlg->UpdateMtlDisplay();
		}
	}

void BMCropper::OnClose(){
	dlg->cropping = FALSE;
	}

//------------------------------------------------------------------------
// BMTexNotify -- Methods
//------------------------------------------------------------------------

int BMTexNotify::Changed(ULONG flags) {
	tex->NotifyChanged();
	tex->DiscardTexHandle();
	return 1;
	}

//------------------------------------------------------------------------
//------------------------------------------------------------------------

int numBMTexs = 0;
class BMTexClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new BMTex; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_BITMAP_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return bmTexClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_2D;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("bitmapTex"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static BMTexClassDesc bmTexCD;

ClassDesc* GetBMTexDesc() { return &bmTexCD;  }

class BMTexPBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& val, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
		{
		BMTex* bmt = (BMTex*)owner;
		switch (id)
			{
			case bmtex_bitmap:
				{
				if (!bmt->loading) {
					bmt->ReloadBitmapAndUpdate();
					// send message so browser/navigator name gets updated
					bmt->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
					}
				break;
				}
			case bmtex_filename:
				{
				bmt->SetMapName(val.s);
				break;
				}
			case bmtex_filtering:
				bmt->SetFilterType(val.i);
				break;				
			case bmtex_clipu: {
				float u = val.f;
				float w = bmt->GetClipW(t);
				if (u+w>1.0f) 
					bmt->SetClipW(t,1.0f-u);
				break;
				}
			case bmtex_clipv: {
				float v = val.f;
				float h = bmt->GetClipH(t);
				if (v+h>1.0f) 
					bmt->SetClipH(t,1.0f-v);
				break;
				}
			case bmtex_clipw: {
				float w = val.f;
				float u = bmt->GetClipU(t);
				if (u+w>1.0f) 
					bmt->SetClipU(t,1.0f-w);
				break;
				}
			case bmtex_cliph: {
				float h = val.f;
				float v = bmt->GetClipV(t);
				if (v+h>1.0f) 
					bmt->SetClipV(t,1.0f-h);
				break;
				}
			}
		}
	void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval &valid)    // get into v
	{
		BMTex* bmt = (BMTex*)owner;
		switch (id)
		{
			case bmtex_filename:
			{
				v.s = bmt->GetMapName();
				break;
			}

		}
	}
};

static BMTexPBAccessor bmtex_accessor;

static ParamBlockDesc2 bmtex_param_blk ( bmtex_params, _T("parameters"),  0, &bmTexCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_BMTEX, IDS_DS_BITMAP_PARAMS, 0, 0, NULL, 
	// params

	bmtex_clipu,	_T("clipu"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CLIPU,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_CLIP_X, IDC_CLIP_XSPIN, 0.001f,
		p_accessor,		&bmtex_accessor,
		end,
	bmtex_clipv,	_T("clipv"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CLIPV,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_CLIP_Y, IDC_CLIP_YSPIN, 0.001f,
		p_accessor,		&bmtex_accessor,
		end,
	bmtex_clipw,	_T("clipw"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CLIPW,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_CLIP_W, IDC_CLIP_WSPIN, 0.001f,
		p_accessor,		&bmtex_accessor,
		end,
	bmtex_cliph,	_T("cliph"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CLIPH,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_CLIP_H, IDC_CLIP_HSPIN, 0.001f,
		p_accessor,		&bmtex_accessor,
		end,
	bmtex_jitter,	_T("jitter"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_JITTERAMT,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_JITTER_EDIT, IDC_JITTER_SPIN, 0.01f,
		end,
	bmtex_usejitter,	_T("useJitter"), TYPE_BOOL,			0,		IDS_PW_USEJITTER,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_BM_JITTER,
		end,
	bmtex_apply,	_T("apply"), TYPE_BOOL,			0,		IDS_PW_APPLY,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_BM_CLIP,
		end,
	bmtex_crop_place, _T("cropPlace"), TYPE_INT,		0,		IDS_PW_CROPPLACE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2,  IDC_BM_CROP,IDC_BM_PLACE,
		end,

	bmtex_filtering, _T("filtering"), TYPE_INT,		0,		IDS_PW_FILTERING,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_FILTER_PYR, IDC_FILTER_SAT,IDC_FILTER_NADA,
		p_accessor,		&bmtex_accessor,
		end,
	bmtex_monooutput, _T("monoOutput"), TYPE_INT,		0,		IDS_PW_MONOOUTPUT,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_BMTEX_RGBOUT, IDC_BMTEX_ALPHAOUT,
		end,
	bmtex_rgboutput, _T("rgbOutput"), TYPE_INT,		0,		IDS_PW_RGBOUTPUT,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_BMTEX_RGBOUT2, IDC_BMTEX_ALPHAOUT2,
		end,
	bmtex_alphasource, _T("alphaSource"), TYPE_INT,		0,		IDS_PW_ALPHASOURCE,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_ALPHA_FILE, IDC_ALPHA_RGB,IDC_ALPHA_NONE,
		end,
	
	bmtex_premultalpha, _T("preMultAlpha"), TYPE_BOOL,		0,		IDS_PW_PREMULT,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_ALPHA_PREMULT,
		end,

	bmtex_bitmap, _T("bitmap"),	TYPE_BITMAP, 0, IDS_DS_BITMAP,
		p_ui,			TYPE_BITMAPBUTTON, IDC_BMTEX_NAME,
		p_accessor,		&bmtex_accessor,
		end,
		
	bmtex_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		UVGEN_REF, 
		end,
	bmtex_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_TEXOUT,
		p_refno,		TEXOUT_REF, 
		end,

	bmtex_filename,		_T("fileName"), TYPE_STRING,		P_TRANSIENT,	IDS_JW_FILENAME,
		p_accessor,		&bmtex_accessor,
		end,

	end
);




#ifndef DESIGN_VER
class BMTexPBTimeAccessor : public PBAccessor
{
public:
	void Set(PB2Value& val, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
		{
		BMTex* bmt = (BMTex*)owner;
		switch (id)	{
			case bmtex_start:
				bmt->startTime = val.i;
				break;
			case bmtex_playbackrate:
				bmt->pbRate= val.f;
				break;
			case bmtex_endcondition:
				bmt->endCond = val.i;
				break;				
		}
	}
};

static BMTexPBTimeAccessor bmtextime_accessor;

static ParamBlockDesc2 bmtex_time_param_blk ( bmtex_time, _T("time parameters"),  0, &bmTexCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCKTIME_REF, 
	//rollout
	IDD_BMTEX_TIME, IDS_DS_TIME_PARAMS, 0, APPENDROLL_CLOSED, NULL, 
	// params
	bmtex_start, _T("startTime"), TYPE_TIMEVALUE,			0,	IDS_PW_STARTTIME,
		p_default,		0,
		p_range,		-1000000,	1000000,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,  IDC_BMTEX_START, IDC_BMTEX_START_SPIN, 1.0f,
		p_accessor,		&bmtextime_accessor,
		end,
	bmtex_playbackrate, _T("playBackRate"), TYPE_FLOAT,			0,	IDS_PW_PLAYBACK,
		p_default,		1.0f,
		p_range,		0.0f,	10000.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_BMTEX_RATE, IDC_BMTEX_RATE_SPIN, 1.0f,
		p_accessor,		&bmtextime_accessor,
		end,
	bmtex_endcondition, _T("endCondition"), TYPE_INT,		0,		IDS_PW_ENDCONDITION,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_BMTEX_LOOP, IDC_BMTEX_PINGPONG,IDC_BMTEX_HOLD,
		p_accessor,		&bmtextime_accessor,
		end,
	end
	);
#endif // DESIGN_VER

void BMTex::SetEndCondition(int endcond) { 
    #ifndef DESIGN_VER
	pblockTime->SetValue( bmtex_endcondition, 0, endcond);		
	endCond = endcond; 
//	ParamID changedParam = pblockTime->LastNotifyParamID();
//	bmtex_time_param_blk.InvalidateUI(changedParam);
    #endif // DESIGN_VER
}
void BMTex::SetStartTime(TimeValue t) {
    #ifndef DESIGN_VER
	pblockTime->SetValue( bmtex_start, 0, t);		
	startTime = t; 
//	ParamID changedParam = pblockTime->LastNotifyParamID();
//	bmtex_time_param_blk.InvalidateUI(changedParam);
    #endif // DESIGN_VER
}
void BMTex::SetPlaybackRate(float r) { 
    #ifndef DESIGN_VER
	pblockTime->SetValue( bmtex_playbackrate, 0, r);		
	pbRate = r; 
//	ParamID changedParam = pblockTime->LastNotifyParamID();
//	bmtex_time_param_blk.InvalidateUI(changedParam);
    #endif // DESIGN_VER
}


//------------------------------------------------------------------------
// BMTexDlg -- Methods
//------------------------------------------------------------------------
BMTexDlg::BMTexDlg(HWND hwMtlEdit, IMtlParams *imp, BMTex *m) { 
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanel = NULL;
	theBMTex = m; 
	valid  = FALSE;
	isActive  = FALSE;
	cropping = FALSE;
	curTime = imp->GetTime();

//	hTime = 0;
	curTime = 0;
	}

void BMTexDlg::ReloadDialog() {
	Interval valid;
	theBMTex->Update(curTime, valid);
	LoadDialog(FALSE);
	}

void BMTexDlg::Update(TimeValue t) {
#ifndef DESIGN_VER
	Interval valid;
	curTime = t;
	if (!theBMTex->ivalid.InInterval(t)) {
		theBMTex->Update(curTime, valid);
		LoadDialog(FALSE);
		InvalidateRect(hPanel,NULL,0);
		if (cropping) {
		    theBMTex->StuffCropValues();
			}
		}
#endif // !DESIGN_VER
	}


BMTexDlg::~BMTexDlg() {
	RemoveCropImage();
	theBMTex->paramDlg = NULL;
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	hPanel =  NULL;
	}

void BMTex::FreeBitmap() {
	if (thebm) {
		thebm->DeleteThis();
		thebm = NULL;
		}
	if (texHandle) {
		texHandle->DeleteThis();
		texHandle = NULL;	
		}
	loadFailed = FALSE;
	}


void BMTexDlg::BMNameChanged() {
	theBMTex->FreeBitmap();
	theBMTex->NotifyChanged();
	StuffBMNameField(hPanel);
	theBMTex->loadFailed = FALSE;
	BMMRES res = theBMTex->LoadBitmap(ip->GetTime());
	if (res==BMMRES_NODRIVER) 
	   	InvalidNameMsg(theBMTex->bi.Name());
	EnableAlphaButtons(TRUE);
    UpdateMtlDisplay();
	}



void BMTexDlg::HandleNameButton() {
	BOOL silent = TheManager->SetSilentMode(TRUE);
	BOOL res = TheManager->SelectFileInputEx(&theBMTex->bi, hPanel, GetString(IDS_DS_SELECT_BMFILE));
	TheManager->SetSilentMode(silent);
	if (res) {
		BMNameChanged();
		}
	}

BOOL BMTexDlg::KeyAtCurTime(int id) { return theBMTex->pblock->KeyFrameAtTime(id,curTime); }

void GetBMName(BitmapInfo& bi, TSTR &fname, BOOL full=FALSE) { 
	TSTR fullName;
	if (bi.Name()[0]==0)
		fullName = bi.Device();
	else 
		fullName =  bi.Name();
	if (full)
		fname = fullName;
	else 
		SplitPathFile(fullName,NULL,&fname);
	}

void BMTexDlg::StuffBMNameField(HWND hwndDlg) {
	TSTR fname;
//	GetBMName(theBMTex->bi,fname,TRUE);
//	if (iName) {
//		iName->SetText(fname.data());
//		iName->SetTooltip(TRUE,fname.data());
//		}
	}

void BMTexDlg::ShowCropImage() {
	if (!theBMTex) return;
	Bitmap *bm = theBMTex->thebm;
	if (!bm) { 
		BMMRES res = theBMTex->LoadBitmap(ip->GetTime());
		if (!bm) return;
		}
	cropper.Init(this,curTime);
	cropping = TRUE;
    int junk = bm->Display( GetString(IDS_DS_CROP_TITLE),BMM_CN, FALSE, FALSE, &cropper );
	}

void BMTexDlg::RemoveCropImage() {
	cropping = FALSE;
	if (!theBMTex) return;
	Bitmap *bm = theBMTex->thebm;
	if (!bm) return;
 	bm->UnDisplay( );
	}


static int colID[2] = { IDC_CHECK_COL1, IDC_CHECK_COL2 };

void BMTexDlg::EnableAlphaButtons(BOOL isNew) {
	if (hPanel==NULL) return;
	if (theBMTex->bi.Flags()&MAP_HAS_ALPHA) {
		EnableWindow(GetDlgItem(hPanel,IDC_ALPHA_FILE), 1);
		EnableWindow(GetDlgItem(hPanel,IDC_ALPHA_PREMULT), 1);
		EnableWindow(GetDlgItem(hPanel,IDC_BMTEX_ALPHAOUT), 1);
		EnableWindow(GetDlgItem(hPanel,IDC_BMTEX_ALPHAOUT2), 1);
		if (isNew) {
			theBMTex->SetAlphaSource(ALPHA_FILE);
			}
		}
	else {
		EnableWindow(GetDlgItem(hPanel,IDC_ALPHA_FILE), 0);
		EnableWindow(GetDlgItem(hPanel,IDC_ALPHA_PREMULT), 0);
		EnableWindow(GetDlgItem(hPanel,IDC_BMTEX_ALPHAOUT), 0);
		EnableWindow(GetDlgItem(hPanel,IDC_BMTEX_ALPHAOUT2), 0);
		if (isNew) {
			if (theBMTex->alphaSource == ALPHA_FILE)
 				theBMTex->SetAlphaSource(ALPHA_NONE);
			if (theBMTex->premultAlpha)
				theBMTex->SetPremultAlpha(FALSE);
			if (theBMTex->alphaAsRGB) 
				theBMTex->SetAlphaAsRGB(FALSE);
			if (theBMTex->alphaAsMono) 
				theBMTex->SetAlphaAsMono(FALSE);
			}
		}
	}


void BMTexDlg::EnableViewImage() {
	EnableWindow(GetDlgItem(hPanel,IDC_BM_CROP_IMAGE),(_tcslen(theBMTex->bi.Name())>0)?1:0); 	
	}

BOOL BMTexDlg::DlgProc(TimeValue t,IParamMap2 *map,HWND hwndDlg,UINT msg,WPARAM wParam,LPARAM lParam)		
{	
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			hPanel = map->GetHWnd();
			EnableAlphaButtons();
			EnableViewImage();
			return TRUE;
			}
			break;
		case WM_COMMAND:  
		    switch (id) {
				case IDC_BMTEX_NAME: 
					bmtex_param_blk.InvalidateUI(bmtex_bitmap);
					break;

				case IDC_ALPHA_FILE:
				case IDC_ALPHA_XPCOL:
				case IDC_ALPHA_RGB:
				case IDC_ALPHA_NONE:
					theBMTex->NotifyChanged();
					theBMTex->DiscardTexHandle();
				    UpdateMtlDisplay();
					break;
				case IDC_FILTER_NADA:
				case IDC_FILTER_PYR:
				case IDC_FILTER_SAT:
					theBMTex->NotifyChanged();
					break;
				case IDC_BMTEX_RELOAD:
					theBMTex->ReloadBitmap();
					BroadcastNotification(NOTIFY_BITMAP_CHANGED, (void *)theBMTex->bi.Name());
					//theBMTex->NotifyChanged();
				    UpdateMtlDisplay(); // redraw viewports
					Invalidate();  // incase path of map has changed.
					break;
				case IDC_BMTEX_RGBOUT:
				case IDC_BMTEX_ALPHAOUT:
					theBMTex->NotifyChanged();
					break;
				case IDC_BMTEX_RGBOUT2:
				case IDC_BMTEX_ALPHAOUT2:
					theBMTex->NotifyChanged();
					theBMTex->DiscardTexHandle();
				    UpdateMtlDisplay();
					break;
				case IDC_ALPHA_PREMULT:
					theBMTex->NotifyChanged();
					theBMTex->DiscardTexHandle();
				    UpdateMtlDisplay();
					break;
				case IDC_BM_CLIP: 
//					theBMTex->applyCrop = GetCheckBox(hwndDlg,id);
					theBMTex->NotifyChanged();
					theBMTex->DiscardTexHandle();
				    UpdateMtlDisplay();
					break;
				case IDC_BM_CROP_IMAGE: 
					ShowCropImage();
					break;
				case IDC_BM_CROP:
				case IDC_BM_PLACE:
//					CheckRadioButton( hwndDlg, IDC_BM_CROP, IDC_BM_PLACE, id);
//					theBMTex->placeImage = id==IDC_BM_PLACE?1:0;
					theBMTex->NotifyChanged();
					theBMTex->DiscardTexHandle();
				    UpdateMtlDisplay();
					if (cropping) theBMTex->StuffCropValues();
					theBMTex->EnableStuff();
					break;
				case IDC_BM_JITTER:
//					theBMTex->randPlace =  GetCheckBox(hwndDlg,id);
					theBMTex->NotifyChanged();
				    UpdateMtlDisplay();
					theBMTex->EnableStuff();
					break;
				}
			break;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			break;

		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
//			switch (id) {
				theBMTex->NotifyChanged();
				if (cropping) theBMTex->StuffCropValues();
//need to make as an accesot
/*
				case IDC_CLIP_XSPIN: {
					float u = 0.0f;//clipUSpin->GetFVal();
					theBMTex->SetClipU(curTime,u);
//					clipUSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPU));
					float w = theBMTex->GetClipW(curTime);
					if (u+w>1.0f) {
						w = 1.0f-u;
						theBMTex->SetClipW(curTime,w);
//						clipWSpin->SetValue(theBMTex->clipw,FALSE);
//						clipWSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPW));
						}
					theBMTex->NotifyChanged();
					if (cropping) theBMTex->StuffCropValues();
					}
					break; 	
				case IDC_CLIP_YSPIN: {
					float v = 0.0f;//clipVSpin->GetFVal();
					theBMTex->SetClipV(curTime,v);
//					clipVSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPV));
					float h = theBMTex->GetClipH(curTime);
					if (v+h>1.0f) {
						h = 1.0f-v;
						theBMTex->SetClipH(curTime,h);
//						clipHSpin->SetValue(theBMTex->cliph,FALSE);
//						clipHSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPH));
						}
					theBMTex->NotifyChanged();
					if (cropping) theBMTex->StuffCropValues();
					}
					break; 	
				case IDC_CLIP_WSPIN: {
					float w = 0.0f;//clipWSpin->GetFVal();
					theBMTex->SetClipW(curTime,w);
//					clipWSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPW));
					float u = theBMTex->GetClipU(curTime);
					if (u+w>1.0f) {
						u = 1.0f-w;
						theBMTex->SetClipU(curTime,u);
//						clipUSpin->SetValue(theBMTex->clipu,FALSE);
//						clipUSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPU));
						}
					theBMTex->NotifyChanged();
					if (cropping) theBMTex->StuffCropValues();
					}
					break; 	
				case IDC_CLIP_HSPIN: {
					float h = 0.0f;//clipHSpin->GetFVal();
					theBMTex->SetClipH(curTime,h);
//					clipHSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPH));
					float v = theBMTex->GetClipV(curTime);
					if (v+h>1.0f) {
						v = 1.0f-h;
						theBMTex->SetClipV(curTime,v);
//						clipVSpin->SetValue(theBMTex->clipv,FALSE);
//						clipVSpin->SetKeyBrackets(KeyAtCurTime(PB_CLIPV));
						}
					theBMTex->NotifyChanged();
					if (cropping) theBMTex->StuffCropValues();
					}
					break;
				case IDC_JITTER_SPIN:
//					theBMTex->SetJitter(curTime,jitterSpin->GetFVal());
//					jitterSpin->SetKeyBrackets(KeyAtCurTime(PB_JITTER));
					theBMTex->NotifyChanged();
					break;
*/

//				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			theBMTex->DiscardTexHandle();
			theBMTex->NotifyChanged();
		    UpdateMtlDisplay();
			if (cropping) theBMTex->StuffCropValues();
			break;
		case WM_DESTROY:		
			RemoveCropImage();
			break;
    	}
	return FALSE;
	}



void BMTexDlg::LoadDialog(BOOL draw) {
	if (theBMTex) {
		Interval valid;
		theBMTex->Update(curTime,valid);
		StuffBMNameField(hPanel);
		CheckRadioButton( hPanel, IDC_ALPHA_FILE, IDC_ALPHA_NONE, IDC_ALPHA_FILE+theBMTex->alphaSource);
		CheckRadioButton( hPanel, IDC_FILTER_PYR, IDC_FILTER_NADA, IDC_FILTER_PYR+theBMTex->filterType);
		CheckRadioButton( hPanel, IDC_BMTEX_RGBOUT, IDC_BMTEX_ALPHAOUT, IDC_BMTEX_RGBOUT+theBMTex->alphaAsMono);
		CheckRadioButton( hPanel, IDC_BMTEX_RGBOUT2, IDC_BMTEX_ALPHAOUT2, IDC_BMTEX_RGBOUT2+theBMTex->alphaAsRGB);
		SetCheckBox( hPanel, IDC_ALPHA_PREMULT, theBMTex->premultAlpha);
		SetCheckBox( hPanel, IDC_BM_CLIP, theBMTex->applyCrop);
		EnableAlphaButtons(FALSE);
		}
	}

void BMTexDlg::SetThing(ReferenceTarget *m) {

	assert (m->ClassID()==bmTexClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
 	RemoveCropImage();
	if (theBMTex) {
		theBMTex->paramDlg = NULL;
		}
	theBMTex = (BMTex *)m;
	if (theBMTex) theBMTex->paramDlg = this;
	LoadDialog(TRUE);
	}


ReferenceTarget *BMTexDlg::GetInstance(HWND hwnd, POINT p, SClass_ID type) {
	DADBitmapCarrier *bmc = GetDADBitmapCarrier();
	TSTR nm = theBMTex->bi.Name();
	bmc->SetName(nm);
	return bmc;
	}

void BMTexDlg::Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
	if (dropThis->SuperClassID()!=BITMAPDAD_CLASS_ID) 
		return;
	DADBitmapCarrier *bmc = (DADBitmapCarrier *)dropThis;
	theBMTex->bi.SetName(bmc->GetName().data());
	BMNameChanged();
	}

//------------------------------------------------------------------------
// BMTex -- Methods
//------------------------------------------------------------------------



#define BMTEX_VERSION 3

static ParamBlockDescID pbdesc1[] = {
	{ TYPE_FLOAT, NULL, TRUE,1} 	// blur
	};   

static ParamBlockDescID pbdesc2[] = {
	{ TYPE_FLOAT, NULL, TRUE,bmtex_clipu }, // clipu
	{ TYPE_FLOAT, NULL, TRUE,bmtex_clipv }, // clipv
	{ TYPE_FLOAT, NULL, TRUE,bmtex_clipw }, // clipw
	{ TYPE_FLOAT, NULL, TRUE,bmtex_cliph }, // cliph
	{ TYPE_FLOAT, NULL, TRUE,bmtex_jitter } // jitter
	};

static ParamVersionDesc oldVersions[] = {
	ParamVersionDesc(pbdesc1, 1, 0),
	ParamVersionDesc(pbdesc1, 1, 1),
	ParamVersionDesc(pbdesc2, 4, 2),
	ParamVersionDesc(pbdesc2, 5, 3)
	};
/*
static ParamVersionDesc oldVersions[] = {
	ParamVersionDesc(pbdesc2, 5, 2)
	};
*/
#define NUMOLDVERSIONS 4
//static ParamVersionDesc curVersion(pbdesc2,5,BMTEX_VERSION);

//static int name_id[NPARAMS] = { IDS_DS_CLIPU, IDS_DS_CLIPV, IDS_DS_CLIPW, IDS_DS_CLIPH, IDS_DS_JITTERAMT };

void BMTex::Init() {
	if (uvGen) uvGen->Reset();
	else ReplaceReference( 0, GetNewDefaultUVGen());	
//	ReplaceReference( 1, CreateParameterBlock( pbdesc2, NPARAMS, BMTEX_VERSION) );	
	if (texout) texout->Reset();
	else ReplaceReference( 2, GetNewDefaultTextureOutput());
	placeImage = FALSE;
	randPlace = FALSE;
	filterType = FILTER_PYR;
	alphaSource = ALPHA_FILE;
	alphaAsMono = FALSE;
	alphaAsRGB = FALSE;
	premultAlpha = TRUE;
	SetClipU(0,0.0f);
	SetClipV(0,0.0f);
	SetClipW(0,1.0f);
	SetClipH(0,1.0f);
	SetJitter(0,1.0f);
	ivalid.SetEmpty();
	clipValid.SetInfinite();
	isNew = FALSE;
	rumax = rvmax = -100000.0f;
	rumin = rvmin = +100000.0f;
	}

void BMTex::Reset() {
	bmTexCD.Reset(this, TRUE);	// reset all pb2's
	if (!isNew) {
		FreeBitmap();
		NotifyChanged();
	    if (paramDlg) paramDlg->UpdateMtlDisplay();
		}
	Init();
	}

void BMTex::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

#ifdef DESIGN_VER
static void SetGeoReferenceInfo(BitmapInfo & bi, StdUVGen * uvGen)
{
	TheManager->Execute(1, ULONG(bi.Name()), ULONG(&(uvGen->m_geoInfo)), 0);
}
#endif

static void BMTexNotify(void *param, NotifyInfo *info) {
	BMTex *bmt = (BMTex *) param;
	switch(info->intcode) {
		case NOTIFY_BITMAP_CHANGED: {
			TCHAR *nm = (TCHAR *)info->callParam;
			if (nm==NULL || !_tcscmp(nm,bmt->bi.Name())) {
				bmt->NotifyChanged();
				}
			if (nm==NULL) {
				bmt->fileNotFound = 0;
				}
#ifdef DESIGN_VER
			if (!_tcscmp(_T("TIF Image File"), bmt->bi.Device()))
				SetGeoReferenceInfo(bmt->bi, bmt->GetUVGen());
#endif
			break;
			}
		}
	}

BMTex::BMTex() {
	ip = NULL;
	isParm2 = TRUE;
	paramDlg = NULL;
	pblock = NULL;
	pblockTime = NULL;
	uvGen = NULL;
	texout = NULL;
	thebm = NULL;
	texHandle = NULL;
	loadFailed = FALSE;
	inRender = FALSE;
	startTime = 0;
	pbRate = 1.0f;
	endCond = END_LOOP;
	isNew = TRUE;
	applyCrop = FALSE;
	loading = FALSE;
	loadingOld = FALSE;
	clipValid = FOREVER;
	bitmapPB = NULL;
	fileNotFound = FALSE;
	bmTexCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	bmNotify.SetTex(this);
	rollScroll=0;
	RegisterNotification(BMTexNotify, this, NOTIFY_BITMAP_CHANGED);
	}

static int bmFilterType(int filt_type) {
	switch(filt_type) {
		case FILTER_PYR: return BMM_FILTER_PYRAMID;
		case FILTER_SAT: return BMM_FILTER_SUM;
		default: return BMM_FILTER_NONE;
		}
	}


void BMTex::SetClipU(TimeValue t, float f) { 
	clipu  = f; 
	pblock->SetValue(bmtex_clipu, t, f);
	bmtex_param_blk.InvalidateUI(bmtex_clipu);

	}


void BMTex::SetClipV(TimeValue t, float f) { 
	clipv  = f; 
	pblock->SetValue( bmtex_clipv, t, f);		
	bmtex_param_blk.InvalidateUI(bmtex_clipv);
	}

void BMTex::SetClipW(TimeValue t, float f) { 
	clipw  = f;
//	  pblock->SetValue( PB_CLIPW, t, f);		
	pblock->SetValue( bmtex_clipw, t, f);		
	bmtex_param_blk.InvalidateUI(bmtex_clipw);
	}

void BMTex::SetClipH(TimeValue t, float f) { 
	cliph  = f; 
//	pblock->SetValue( PB_CLIPH, t, f);		
	pblock->SetValue( bmtex_cliph, t, f);		
	bmtex_param_blk.InvalidateUI(bmtex_cliph);
	}

void BMTex::SetJitter(TimeValue t, float f) { 
	jitter = cliph  = f; 
//	pblock->SetValue( PB_JITTER, t, f);		
	pblock->SetValue( bmtex_jitter, t, f);	
    bmtex_param_blk.InvalidateUI(bmtex_jitter);
	}


void BMTex::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		pblock->GetValue( bmtex_crop_place, 0, placeImage, FOREVER );
		pblock->GetValue( bmtex_usejitter, 0, randPlace, FOREVER );
		if (map) {
			map->Enable(bmtex_jitter, placeImage);
			map->Enable(bmtex_usejitter, placeImage);
			map->Enable(bmtex_clipu, !(placeImage&&randPlace));
			map->Enable(bmtex_clipv, !(placeImage&&randPlace));
			}
		}
	}

void BMTex::SetFilterType(int ft) {
	filterType = ft;
	if (thebm)	
		thebm->SetFilter(bmFilterType(filterType));
	}


void BMTex::SetAlphaSource(int as) {
	if (as!=alphaSource) {
		alphaSource =as; 
		mysamp.Init(this);
		alphasamp.Init(this);
	    if (alphaSource == ALPHA_FILE) pblock->SetValue( bmtex_alphasource, 0, 0);		
	    else if (alphaSource == ALPHA_RGB) pblock->SetValue( bmtex_alphasource, 0, 1);		
	    else if (alphaSource == ALPHA_NONE) pblock->SetValue( bmtex_alphasource, 0, 2);		
		bmtex_param_blk.InvalidateUI(bmtex_alphasource);
	
		}
	}

static TimeValue modt(TimeValue x, TimeValue m) {
	TimeValue n = (int)(x/m);
	x -= n*m;
	return (x<0)? x+m : x ;
	}

void BMTex::StuffCropValues() {
	pblock->GetValue( bmtex_crop_place, 0, placeImage, FOREVER );

	if (thebm) thebm->SetCroppingValues(clipu,clipv,clipw,cliph, placeImage );
	}

int BMTex::CalcFrame(TimeValue t) {
	TimeValue tm,dur,td;
	int fstart = bi.FirstFrame();
	int fend = bi.LastFrame();
	int tpf = GetTicksPerFrame();
	tm = TimeValue(float(t-startTime)*pbRate);
	dur = (fend-fstart+1)*GetTicksPerFrame();
	switch (endCond) {
		case END_HOLD:
			if (tm<=0) return fstart;
			if (tm>=dur) return fend;
			return tm/tpf;
		case END_PINGPONG:
			//if ((tm/dur)&1) 
			if ( ((tm>=0) && ((tm/dur)&1)) || ( (tm<0) && !(tm/dur)))
				{
				td = modt(tm,dur);
				return fstart + fend-td/tpf;
				}
			// else fall thrue--
		case END_LOOP:
			td = modt(tm,dur);
			return td/tpf;
		}
	return 0;
	}

BMMRES BMTex::LoadBitmap(TimeValue t, BOOL quiet, BOOL reload) {
	BMMRES status = BMMRES_SUCCESS;
	pblock->GetValue( bmtex_bitmap, t,bitmapPB, clipValid );
	if ( ((bitmapPB != NULL) && (_tcscmp(bi.Name(), bitmapPB->bi.Name())) )   )
		FreeBitmap();

	UpdateBIName();   //DS 2/18/99
	if (bi.Name()[0]==0)
		if (bi.Device()[0]==0)
			return BMMRES_NODRIVER;
	if (thebm==NULL) {
		bi.SetCurrentFrame(CalcFrame(t));
		BOOL silent;
		if (quiet)
			silent = TheManager->SetSilentMode(TRUE);
		SetCursor(LoadCursor(NULL,IDC_WAIT));
		thebm = TheManager->Load(&bi,&status);
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		if (quiet)
			TheManager->SetSilentMode(silent);
		if (thebm==NULL) {
			fileNotFound = TRUE;
			return status;
			}
		if (bitmapPB) {
		    bitmapPB->bi = bi;	  //DS 3/29/99: in case name has changed ( or flags)
			}
		fileNotFound = FALSE; 
		thebm->SetNotify(&bmNotify);
		thebm->SetFilter(bmFilterType(filterType));
		// fixup for imported files
		if (!(bi.Flags()&MAP_HAS_ALPHA)&&alphaSource==ALPHA_FILE) {
			if (paramDlg) 
				paramDlg->EnableAlphaButtons(FALSE);
			else 
 				SetAlphaSource(ALPHA_NONE);
			}			
		if (paramDlg != NULL) {
			paramDlg->EnableAlphaButtons(!reload);
			paramDlg->EnableViewImage();
			}
		}
//	else {
	bi.SetCurrentFrame(CalcFrame(t));
	BOOL silent = TheManager->SetSilentMode(TRUE);
	status = thebm->GoTo(&bi);
	TheManager->SetSilentMode(silent);
#ifdef DESIGN_VER
			if (!_tcscmp(_T("TIF Image File"), bi.Device()))
				SetGeoReferenceInfo(bi, GetUVGen());
#endif
//		}

	mysamp.Init(this);
	alphasamp.Init(this);
	return status;
	}


void BMTex::RenderBitmap(TimeValue t, Bitmap *bm, float scale3D, BOOL filter) {
	LoadBitmap(t);
	if (thebm) 
		bm->CopyImage(thebm, filter?COPY_IMAGE_RESIZE_HI_QUALITY:COPY_IMAGE_RESIZE_LO_QUALITY, 0);
	}

void BMTex::ReloadBitmap() {
	if (thebm) {
		loadFailed = FALSE;
		FreeBitmap(); 
		LoadBitmap(GetCOREInterface()->GetTime(), TRUE, TRUE);
		TheManager->LoadInto(&bi,&thebm,TRUE);
		}
	else {
		loadFailed = FALSE;
		TimeValue t;
		t = GetCOREInterface()->GetTime();
		LoadBitmap(t);
		}

	//DS:  10/19/99: update path name on button in case it has changed ( fix for #196020)
	IParamMap2* pmap = pblock->GetMap();
	if (pmap != NULL)
		pmap->SetText(bmtex_bitmap, (char *)bi.Name());


	if (paramDlg) 
		paramDlg->EnableAlphaButtons(FALSE);

	}


void BMTex::DiscardTexHandle() {
	if (texHandle) {
		texHandle->DeleteThis();
		texHandle = NULL;
		}
	}

void BMTex::ActivateTexDisplay(BOOL onoff) {
	if (!onoff) 
		DiscardTexHandle();
	}

static BMM_Color_64 black64 = {0,0,0,0};

DWORD BMTex::GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {
	if (texHandle&&texTime==CalcFrame(t)&&texValid.InInterval(t)) 
		return texHandle->GetHandle();
	else {
		DiscardTexHandle();  // DS 9/9/96
		if (fileNotFound) 
			return 0;
		LoadBitmap(t);
		if (thebm==NULL) {
//			if (!loadFailed) {
//				TSTR fname;
//				GetBMName(bi,fname);
//				LoadFailedMsg(fname.data());
//				loadFailed = TRUE;
//				}
			return 0;
			}
		texTime = CalcFrame(t);
		texValid = clipValid;
		int xflags = premultAlpha?0:EX_MULT_ALPHA;
		if (applyCrop) {
			int w = thebm->Width();
			int h = thebm->Height();
			Bitmap *newBM;
			BitmapInfo bif;
			bif.SetName(_T("y8798734"));
			bif.SetType(BMM_TRUE_32);
	   		bif.SetFlags(MAP_HAS_ALPHA);
			if (placeImage) {
				int x0,y0,nw,nh;
				int bmw = thmaker.Size();
				int bmh = int(float(bmw)*float(h)/float(w));
				bif.SetWidth(bmw);
				bif.SetHeight(bmh);
				newBM = TheManager->Create(&bif);
			 	newBM->Fill(0,0,0,0);
				nw = int(float(bmw)*clipw);
				nh = int(float(bmh)*cliph);
				x0 = int(float(bmw-1)*clipu);
				y0 = int(float(bmh-1)*clipv);

				if (nw<1) nw = 1;
				if (nh<1) nh = 1;
				PixelBuf row(nw);
				
				Bitmap *tmpBM;
				BitmapInfo bif2;
				bif2.SetName(_T("xxxx67878"));
				bif2.SetType(BMM_TRUE_32);
				bif2.SetFlags(MAP_HAS_ALPHA);
				bif2.SetWidth(nw);				
				bif2.SetHeight(nh);
				tmpBM = TheManager->Create(&bif2);
				tmpBM->CopyImage(thebm, COPY_IMAGE_RESIZE_LO_QUALITY, 0);
				BMM_Color_64*  p1 = row.Ptr();
				for (int y = 0; y<nh; y++) {
					tmpBM->GetLinearPixels(0,y, nw, p1);
					if (alphaAsRGB) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].r = p1[ix].g = p1[ix].b = p1[ix].a;
						}
					//if (alphaSource==ALPHA_NONE||premultAlpha) {
					if (alphaSource==ALPHA_NONE) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].a = 0xffff;
						}
					else if (alphaSource==ALPHA_RGB) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].a = (p1[ix].r+p1[ix].g+p1[ix].b)/3;;
						}
					newBM->PutPixels(x0,y+y0, nw, p1);
					}
				tmpBM->DeleteThis();
				texHandle = thmaker.CreateHandle(newBM,uvGen->SymFlags(), xflags);
				newBM->DeleteThis();
				}
			else {
				int x0,y0,nw,nh;
				nw = int(float(w)*clipw);
				nh = int(float(h)*cliph);
				x0 = int(float(w-1)*clipu);
				y0 = int(float(h-1)*clipv);
				if (nw<1) nw = 1;
				if (nh<1) nh = 1;
				bif.SetWidth(nw);
				bif.SetHeight(nh);
				PixelBuf row(nw);
				newBM = TheManager->Create(&bif);
				BMM_Color_64*  p1 = row.Ptr();
				for (int y = 0; y<nh; y++) {
					thebm->GetLinearPixels(x0,y+y0, nw, p1);
					if (alphaAsRGB) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].r = p1[ix].g = p1[ix].b = p1[ix].a;
						}
//					if (alphaSource==ALPHA_NONE||premultAlpha) {
					if (alphaSource==ALPHA_NONE) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].a = 0xffff;
						}
					else if (alphaSource==ALPHA_RGB) {
						for (int ix =0; ix<nw; ix++) 
							p1[ix].a = (p1[ix].r+p1[ix].g+p1[ix].b)/3;;
						}
					newBM->PutPixels(0,y, nw, p1);
					}
				texHandle = thmaker.CreateHandle(newBM,uvGen->SymFlags(), xflags);
				newBM->DeleteThis();
				}
			}
		else {
			if (alphaAsRGB) xflags |= EX_RGB_FROM_ALPHA;
			if (alphaSource==ALPHA_NONE) xflags |= EX_OPAQUE_ALPHA;
			if (alphaSource==ALPHA_RGB) xflags |= EX_ALPHA_FROM_RGB;
			texHandle = thmaker.CreateHandle(thebm,uvGen->SymFlags(), xflags);
			}
		return texHandle->GetHandle();
		}
	}
							 
//----------------------------------------------------------- 

AColor BMTex::EvalColor(ShadeContext& sc) {
	if (!sc.doMaps) return black;
	AColor c;
	if (sc.GetCache(this,c)) 
		return c; 
	IPoint3 sp = sc.ScreenCoord();
	if (gbufID) sc.SetGBufferID(gbufID);
	if (thebm==NULL) 
		return black;
	if (alphaAsRGB)	{
		float a = texout->Filter(uvGen->EvalUVMapMono(sc,&alphasamp,filterType!=FILTER_NADA));
		c = AColor(a,a,a,a);
		}
	else {
		c = texout->Filter(uvGen->EvalUVMap(sc,&mysamp,filterType!=FILTER_NADA));
		if (!premultAlpha) c= AColor(c.r*c.a, c.g*c.a, c.b*c.a, c.a);
		}
	sc.PutCache(this,c); 
	return c;
	}

float BMTex::EvalMono(ShadeContext& sc) {
	if (!sc.doMaps||thebm==NULL) 
		return 0.0f;
	float f;
	if (sc.GetCache(this,f)) 
		return f; 
	if (gbufID) sc.SetGBufferID(gbufID);
	if (alphaAsMono) 
		f = texout->Filter(uvGen->EvalUVMapMono(sc,&alphasamp,filterType!=FILTER_NADA));
	else 
		f = texout->Filter(uvGen->EvalUVMapMono(sc,&mysamp,filterType!=FILTER_NADA));
	sc.PutCache(this,f); 
	return f;
	}

Point3 BMTex::EvalNormalPerturb(ShadeContext& sc) {
	Point3 dPdu, dPdv;
	Point2 dM;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	if (thebm==NULL) 
		return Point3(0,0,0);
	uvGen->GetBumpDP(sc,dPdu,dPdv);  // get bump basis vectors
	if (alphaAsMono) 
		dM =(.01f)*uvGen->EvalDeriv(sc,&alphasamp,filterType!=FILTER_NADA);
	else 
		dM =(.01f)*uvGen->EvalDeriv(sc,&mysamp,filterType!=FILTER_NADA);

#if 0
	// Blinn's algorithm
	Point3 N = sc.Normal();
	Point3 uVec = CrossProd(N,dPdv);
	Point3 vVec = CrossProd(N,dPdu);
	return texout->Filter(-dM.x*uVec+dM.y*vVec);
#else						 
	return texout->Filter(dM.x*dPdu+dM.y*dPdv);
#endif
	}

RefTargetHandle BMTex::Clone(RemapDir &remap) {
	BMTex *mnew = new BMTex();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(uvGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->ReplaceReference(2,remap.CloneRef(texout));
	mnew->filterType  = filterType;
	mnew->alphaSource = alphaSource;
	mnew->alphaAsMono = alphaAsMono;
	mnew->alphaAsRGB  = alphaAsRGB;
	mnew->premultAlpha = premultAlpha;
	mnew->endCond     = endCond;
	mnew->applyCrop   = applyCrop;
	mnew->ivalid.SetEmpty();
	mnew->placeImage  = placeImage;
	mnew->randPlace   = randPlace;
	mnew->applyCrop   = applyCrop;
	mnew->startTime  = startTime;
	mnew->pbRate  = pbRate;
	mnew->bi = bi;
	return (RefTargetHandle)mnew;
	}

ParamDlg* BMTex::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
//	BMTexDlg *dm = new BMTexDlg(hwMtlEdit, imp, this);
//	dm->LoadDialog(TRUE);	
//	paramDlg = dm;
//	return dm;
// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  
// Here you see we create the Coordinate, Gradient and Output ParamDlgs in the desired 
// order, and then add the Coordinate and Output dlgs as secondaries to the 
// Gradient master AutoMParamDlg so it will keep them up-to-date automatically

	// create the rollout dialogs
	uvGenDlg = uvGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = bmTexCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(uvGenDlg);
	masterDlg->AddDlg(texoutDlg);
	paramDlg = new BMTexDlg(hwMtlEdit,imp,this);
	bmtex_param_blk.SetUserDlgProc(paramDlg);
	ip = imp;
	EnableStuff();
	return masterDlg;
	
	}

BMTex::~BMTex() {
	UnRegisterNotification(BMTexNotify, this, NOTIFY_BITMAP_CHANGED);
	DiscardTexHandle();
	FreeBitmap();
	}

BOOL BMTex::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if (paramDlg) paramDlg->SetThing(this);
	EnableStuff();

	if ((uvGenDlg!= NULL) && (dlg == uvGenDlg))
		uvGenDlg->SetThing(uvGen);
	else if ((texoutDlg!= NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;

}



void BMTex::Update(TimeValue t, Interval& valid) {		

	if (!ivalid.InInterval(t)) {
		uvGen->SetClipFlag(FALSE);

		ivalid.SetInfinite();
		uvGen->Update(t,ivalid);
		clipValid.SetInfinite();
		pblock->GetValue( bmtex_clipu, t, clipu, clipValid );
		pblock->GetValue( bmtex_clipv, t, clipv, clipValid );
		pblock->GetValue( bmtex_clipw, t, clipw, clipValid );
		pblock->GetValue( bmtex_cliph, t, cliph, clipValid );
		pblock->GetValue( bmtex_jitter, t, jitter, clipValid );

		pblock->GetValue( bmtex_filtering, t, filterType, clipValid );
		pblock->GetValue( bmtex_alphasource, t, alphaSource, clipValid );

		if (alphaSource == 0) alphaSource  = ALPHA_FILE;
		else if (alphaSource == 1) alphaSource  = ALPHA_RGB;
		else if (alphaSource == 2) alphaSource  = ALPHA_NONE;

		pblock->GetValue( bmtex_monooutput, t, alphaAsMono, clipValid );
		pblock->GetValue( bmtex_rgboutput, t, alphaAsRGB, clipValid );
		pblock->GetValue( bmtex_premultalpha, t, premultAlpha, clipValid );
		pblock->GetValue( bmtex_usejitter, t, randPlace, clipValid );

		pblock->GetValue( bmtex_crop_place, t, placeImage, clipValid );

		pblock->GetValue( bmtex_apply, t, applyCrop, clipValid );

        #ifndef DESIGN_VER
		pblockTime->GetValue( bmtex_start, t, startTime, clipValid );
		pblockTime->GetValue( bmtex_playbackrate, t, pbRate, clipValid );
		pblockTime->GetValue( bmtex_endcondition, t, endCond, clipValid );
        #endif // DESIGN_VER

		if (applyCrop) ivalid &= clipValid;
		else clipValid.SetInfinite();
		texout->Update(t,ivalid);


		}
	if (thebm) {
		if (bi.FirstFrame()!=bi.LastFrame())
			{
			ivalid.SetInstant(t);  // force bitmap to be reloaded

			bi.SetCurrentFrame(CalcFrame(t));  //this is here to force non render things to advance the bitmap
			BOOL silent = TheManager->SetSilentMode(TRUE);
			int status = thebm->GoTo(&bi);
			TheManager->SetSilentMode(silent);
			}
		}
	else 
		ivalid.SetInstant(t);  // force bitmap to be reloaded 
	UpdtSampler();
	valid &= ivalid;
	}

RefTargetHandle BMTex::GetReference(int i) {
	switch(i) {
		case 0: return uvGen;
		case 1: return pblock;
		case 2:	return texout;
		case 3: return pblockTime;
		default: return NULL;
		}
	}

int BMTex::RemapRefOnLoad(int iref) { 
	if (loadingOld) { 
		switch(iref) {
			case 0: return 0;
			case 1: return 2;
			default: assert(0); return 0;
			}
		}
	else return iref;
	}

void BMTex::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: uvGen = (UVGen *)rtarg; break;
		case 1: pblock = (IParamBlock2 *)rtarg; break;
		case 2:	texout = (TextureOutput *)rtarg; break;
		case 3: pblockTime = (IParamBlock2 *)rtarg; break;
		default: break;
		}
	}

	 
Animatable* BMTex::SubAnim(int i) {
	switch (i) {
		case 0: return uvGen;
		case 1: return pblock;
		case 2: return texout;
		case 3: return pblockTime;
		default: assert(0); return NULL;
		}
	}

TSTR BMTex::GetFullName() {
	TSTR cnm,nm,fname;
   	GetClassName(cnm);
	UpdateBIName();   //DS 2/18/99
	GetBMName(bi,fname);
	TCHAR *s = fname.Length()>0? fname.data(): cnm.data(); 
	nm.printf(_T("%s (%s)"),GetName().data(), s);
	return nm;
	}

TSTR BMTex::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		case 2: return TSTR(GetString(IDS_DS_OUTPUT));		
		case 3: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: assert(0); return TSTR(_T(""));
		}
	}

RefResult BMTex::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			{
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				bmtex_param_blk.InvalidateUI(changing_param);
				if (changing_param != -1)
					DiscardTexHandle();
				if (changing_param == bmtex_bitmap)
					FreeBitmap();
				}
			if (hTarget == pblockTime)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblockTime->LastNotifyParamID();
				bmtex_time_param_blk.InvalidateUI(changing_param);
				}
			

			break;
			}
		case REFMSG_UV_SYM_CHANGE:
			DiscardTexHandle();  
			break;
		}
	return(REF_SUCCEED);
	}



//------------------------------------------------------------------------
// IO
//------------------------------------------------------------------------

class BMTexPostLoad : public PostLoadCallback {
	public:
		BMTex *chk;
		BMTexPostLoad(BMTex *b) {chk=b;}
		void proc(ILoad *iload) {
			chk->loadingOld = FALSE;
			if (chk->bmName.Length()>0) {
				chk->bi.SetName(chk->bmName);   // for obsolete files	
				iload->SetObsolete();
				}
			delete this;
			}
	};

#define MTL_HDR_CHUNK 0x4000
#define OLDBMTEX_NAME_CHUNK 0x5001
#define BMTEX_FILTER_CHUNK 0x5002
#define BMTEX_ALPHASOURCE_CHUNK 0x5003
#define BMTEX_NAME_CHUNK 0x5004
#define BMTEX_IO_CHUNK 0x5010
#define BMTEX_START_CHUNK 0x5011
#define BMTEX_RATE_CHUNK 0x5012
#define BMTEX_ALPHA_MONO_CHUNK 0x5013
#define BMTEX_ENDCOND_CHUNK 0x5014
#define BMTEX_ALPHA_RGB_CHUNK 0x5016
#define BMTEX_VERSOLD_CHUNK 0x5021
#define BMTEX_VERSION_CHUNK 0x5022
#define BMTEX_ALPHA_NOTPREMULT_CHUNK 0x5030
#define BMTEX_CLIP_CHUNK 0x5040
#define BMTEX_PLACE_IMAGE_CHUNK 0x5050
#define BMTEX_JITTER_CHUNK 0x5060

IOResult BMTex::Save(ISave *isave) { 
//	ULONG nb;
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	return IO_OK;
	}	


class BMTex2PostLoad : public PostLoadCallback {
	public:
		BMTex *n;
		BOOL isParam2;
		BMTex2PostLoad(BMTex *ns, BOOL b) {n = ns;isParam2 = b;}
		void proc(ILoad *iload) {  

			if (!isParam2)
				{
				macroRecorder->Disable();
				n->pblock->SetValue( bmtex_filtering, 0, n->filterType);
				if (n->alphaSource == ALPHA_FILE) n->alphaSource  = 0;
					else if (n->alphaSource == ALPHA_RGB) n->alphaSource  = 1;
					else if (n->alphaSource == ALPHA_NONE) n->alphaSource  = 2;

				n->pblock->SetValue( bmtex_alphasource, 0, n->alphaSource);


				n->pblock->SetValue( bmtex_monooutput, 0, n->alphaAsMono );
				n->pblock->SetValue( bmtex_rgboutput, 0, n->alphaAsRGB );
				n->pblock->SetValue( bmtex_premultalpha, 0, n->premultAlpha);
				n->pblock->SetValue( bmtex_usejitter, 0, n->randPlace );

				n->pblock->SetValue( bmtex_crop_place, 0, n->placeImage);

				n->pblock->SetValue( bmtex_apply, 0, n->applyCrop);

				PBBitmap bPB(n->bi);
				n->loading = TRUE;
				n->pblock->SetValue( bmtex_bitmap, 0, &bPB);
				n->loading = FALSE;

                #ifndef DESIGN_VER
				n->pblockTime->SetValue( bmtex_start, 0, n->startTime);
				n->pblockTime->SetValue( bmtex_playbackrate, 0, n->pbRate);
				n->pblockTime->SetValue( bmtex_endcondition, 0, n->endCond);
                #endif // DESIGN_VER

				macroRecorder->Enable();

				}
			delete this; 


			} 
	};


IOResult BMTex::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	bmName.Resize(0);
//	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions, 3, &curVersion, this,1));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case BMTEX_VERSOLD_CHUNK:
				loadingOld = TRUE;
				break;
			case BMTEX_FILTER_CHUNK:
				iload->Read(&filterType,sizeof(filterType),&nb);			
				isParm2 = FALSE;
				break;
			case BMTEX_ALPHASOURCE_CHUNK:
				isParm2 = FALSE;
				iload->Read(&alphaSource,sizeof(alphaSource),&nb);			
				break;
			case BMTEX_NAME_CHUNK:
				isParm2 = FALSE;
				TCHAR *buf;
				if (IO_OK==iload->ReadWStringChunk(&buf)) 
					bmName = buf;					
				break;
			case BMTEX_IO_CHUNK:
				isParm2 = FALSE;
				res = bi.Load(iload);
				// DS 7/18/96 - This is to handle old files 
				// that had the bi saved with start = end = 0, 
				// which now screws up animation.
				bi.SetStartFrame(BMM_UNDEF_FRAME);
				bi.SetEndFrame(BMM_UNDEF_FRAME);
				break;
			case BMTEX_START_CHUNK:
				isParm2 = FALSE;
				iload->Read(&startTime,sizeof(startTime),&nb);			
				break;
			case BMTEX_RATE_CHUNK:
				isParm2 = FALSE;
				iload->Read(&pbRate,sizeof(pbRate),&nb);			
				break;
			case BMTEX_ALPHA_MONO_CHUNK:
				isParm2 = FALSE;
				alphaAsMono = TRUE;
				break;
			case BMTEX_ALPHA_RGB_CHUNK:
				isParm2 = FALSE;
				alphaAsRGB = TRUE;
				break;
			case BMTEX_ALPHA_NOTPREMULT_CHUNK:
				isParm2 = FALSE;
				premultAlpha = FALSE;
				break;
			case BMTEX_ENDCOND_CHUNK:
				isParm2 = FALSE;
				iload->Read(&endCond,sizeof(endCond),&nb);			
				break;
			case BMTEX_CLIP_CHUNK:
				isParm2 = FALSE;
				applyCrop = TRUE;
				break;
			case BMTEX_PLACE_IMAGE_CHUNK:
				isParm2 = FALSE;
				placeImage = TRUE;
				break;
			case BMTEX_JITTER_CHUNK:
				isParm2 = FALSE;
				randPlace = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	if (alphaSource<0||alphaSource>ALPHA_NONE) 
		alphaSource = ALPHA_FILE;


	if (!isParm2)
		{
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB( oldVersions, NUMOLDVERSIONS, &bmtex_param_blk, this, 1);
		iload->RegisterPostLoadCallback(plcb);

		BMTex2PostLoad *bmt2PLCB = new BMTex2PostLoad(this,isParm2);
		iload->RegisterPostLoadCallback(bmt2PLCB);
		}
	


	return IO_OK;
	}

int BMTex::SetProperty(ULONG id, void *data)
	{
	switch (id) {
		case PROPID_CLEARCACHES:
			FreeBitmap();
			return 1;

		default: return 0;
		}
	}





BMTex::BitmapLoadDlg()	{
	//BOOL silent = TheManager->SetSilentMode(TRUE);
	HWND hpanel = GetCOREInterface()->GetMAXHWnd();
	BOOL res = TheManager->SelectFileInputEx(&bi, hpanel, GetString(IDS_DS_SELECT_BMFILE));
	//TheManager->SetSilentMode(silent);
	
	//load into param block
	if (res) {
		PBBitmap bt(bi);
		loading = 1;  // disable accessor
		pblock->SetValue(bmtex_bitmap, 0, &bt);
		loading = 0;
		}
	}

//watje forces the bitmap to reload and view to be redrawn
BMTex::ReloadBitmapAndUpdate()
	{
	FreeBitmap();
	ReloadBitmap();
	fileNotFound = FALSE; // DS 4/20/99 
	if (TestMtlFlag(MTL_TEX_DISPLAY_ENABLED)) {
		if (ip)
			ip->MtlChanged();
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\checker.cpp ===
/**********************************************************************
 *<
	FILE: CHECKER.CPP

	DESCRIPTION: CHECKER 2D Texture map.

	CREATED BY: Dan Silva
				Update 11/17 to param block2 by Peter Watje

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include <bmmlib.h>
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

#define NPARAMS 3

#define NSUBTEX 2
#define NCOLS 2

#define UVGEN_REF	0
#define PBLOCK_REF	1
#define MAP1_REF	2
#define MAP2_REF	3

#define NUM_REFS	4

static Class_ID checkerClassID(CHECKER_CLASS_ID,0);

class Checker;

// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { checker_params, };  // pblock ID
// checker_params param IDs
enum 
{ 
	checker_blur, checker_color1, checker_color2,
	checker_map1, checker_map2,		
	checker_map1_on, checker_map2_on, // main grad params 
	checker_coords,	  // access for UVW mapping

};

class Checker;

//--------------------------------------------------------------
// CheckSampler: checker sample function
//--------------------------------------------------------------
class CheckSampler: public MapSampler {
	Checker *check;
	public:
		CheckSampler() { check= NULL; }
		CheckSampler(Checker *c) { check= c; }
		void Set(Checker *c) { check = c; }
		AColor Sample(ShadeContext& sc, float u,float v);
		AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv);
		float SampleMono(ShadeContext& sc, float u,float v);
		float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv);
	} ;


//--------------------------------------------------------------
// Checker: A 2D texture map
//--------------------------------------------------------------

class Checker: public Texmap { 
	friend class CheckerPostLoad;
	Color col[NCOLS];
	float blur;
	UVGen *uvGen;		   // ref #0

	Texmap* subTex[NSUBTEX];  // More refs
	TexHandle *texHandle;
	Interval texHandleValid;
	Interval ivalid;
	int rollScroll;
	CheckSampler mysamp;
	public:
		Checker();
		~Checker() {
			DiscardTexHandle();
			}	
		IParamBlock2 *pblock;   // ref #1
		BOOL mapOn[2];
		static ParamDlg* uvGenDlg;	
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetColor(int i, Color c, TimeValue t);
		void SetBlur(float f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 
		Bitmap *BuildBitmap(int size);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);
		float MonoEvalFunction(ShadeContext& sc, float u, float v, float du, float dv);
		AColor DispEvalFunc( float u, float v);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods for interactive display
		void DiscardTexHandle();
		BOOL SupportTexDisplay() { return TRUE; }
		void ActivateTexDisplay(BOOL onoff);
		DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker);
		void GetUVTransform(Matrix3 &uvtrans) { uvGen->GetUVTransform(uvtrans); }
		int GetTextureTiling() { return  uvGen->GetTextureTiling(); }
		int GetUVWSource() { return uvGen->GetUVWSource(); }
		int GetMapChannel () { return uvGen->GetMapChannel(); }
		UVGen *GetTheUVGen() { return uvGen; }

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return uvGen->Requirements(subMtlNum); } 

		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			uvGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { 
			return subTex[i]; 
			}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		void InitSlotType(int sType) { if (uvGen) uvGen->InitSlotType(sType); }

		Class_ID ClassID() {	return checkerClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_CHECKER); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		BOOL Param1;
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

	};



int numCheckers = 0;
class CheckerClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Checker; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_CHECKER_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return checkerClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_2D;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Checker"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static CheckerClassDesc checkerCD;
ClassDesc* GetCheckerDesc() { return &checkerCD;  }

ParamDlg* Checker::uvGenDlg;	


//-----------------------------------------------------------------------------
//  Checker
//-----------------------------------------------------------------------------

//JBW: here is the new ParamBlock2 descriptor. There is only one block for Gradients, a per-instance block.
// for the moment, some of the parameters a Tab<>s to test the Tab system.  Aslo note that all the References kept
// kept in a Gradient are mapped here, marked as P_OWNERS_REF so that the paramblock accesses and maintains them
// as references on owning Gradient.  You need to specify the refno for these owner referencetarget parameters.
// I even went so far as to expose the UVW mapping and Texture Output sub-objects this way so that they can be
// seen by the scripter and the schema-viewer

// per instance checker block

static ParamBlockDesc2 checker_param_blk ( checker_params, _T("parameters"),  0, &checkerCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_CHECKER, IDS_DS_CHECKPARMS, 0, 0, NULL, 
	// params
	checker_blur,	_T("soften"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CHECK_BLUR,
		p_default,		0.0,
		p_range,		0.0, 5.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_BLUR_EDIT, IDC_BLUR_SPIN, 0.01f,
		end,
	checker_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_CHECK_COL1, 
		end,
	checker_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(1,1,1), 
		p_ui,			TYPE_COLORSWATCH, IDC_CHECK_COL2, 
		end,
	checker_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		MAP1_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_CHECK_TEX1,
		end,
	checker_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		MAP2_REF,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_CHECK_TEX2,
		end,
	checker_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_CHKMAP1,
		end,
	checker_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_CHKMAP2,
		end,
	checker_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		UVGEN_REF, 
		end,
	end
);



//dialog stuff to get the Set Ref button
class CheckerDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Checker *check;		
		CheckerDlgProc(Checker *m) {check = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			check = (Checker*)m;
//			ReloadDialog();
			}

	};



BOOL CheckerDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_CHECK_SWAP:
					{
					check->SwapInputs();
					}
				}
			break;
		}
	return FALSE;
	}

//-----------------------------------------------------------------------------
//  CheckSampler
//-----------------------------------------------------------------------------
AColor CheckSampler::SampleFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	return  check->EvalFunction(sc, u, v, du, dv);
	}
AColor CheckSampler::Sample(ShadeContext& sc, float u,float v) {
	return check->EvalFunction(sc, u, v, 0.0f, 0.0f);
	}

float CheckSampler::SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	return check->MonoEvalFunction(sc, u, v, du, dv);
	}
float CheckSampler::SampleMono(ShadeContext& sc, float u,float v) {
	return check->MonoEvalFunction(sc, u, v, 0.0f, 0.0f);
	}

//-----------------------------------------------------------------------------
//  Checker
//-----------------------------------------------------------------------------

#define CHECKER_VERSION 1


static int name_id[NPARAMS] = {IDS_DS_CHECK_BLUR,IDS_DS_COLOR1, IDS_DS_COLOR2};

static ParamBlockDescID pbdesc2[] = {
	{ TYPE_FLOAT, NULL, TRUE,checker_blur }, // blur
	{ TYPE_RGBA, NULL, TRUE,checker_color1 },  // col1
	{ TYPE_RGBA, NULL, TRUE,checker_color2 }   // col2
	};

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc2, 3, 1), 
	};


void Checker::Init() {
	if (uvGen) uvGen->Reset();
	else ReplaceReference( 0, GetNewDefaultUVGen());	
	ivalid.SetEmpty();
	macroRecorder->Disable();  // disable macrorecorder during reset
		SetColor(checker_color1, Color(0.0f,0.0f,0.0f), TimeValue(0));
		SetColor(checker_color2, Color(1.0f,1.0f,1.0f), TimeValue(0));
		SetBlur(.0f, TimeValue(0));
		mapOn[0] = mapOn[1] = 1;
	macroRecorder->Enable();
	}

void Checker::Reset() {
	checkerCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

void Checker::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Checker::Checker() {
	mysamp.Set(this);
	texHandle = NULL;
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	uvGen = NULL;
//	paramDlg = NULL;
	checkerCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	Param1 = FALSE;
	}


void Checker::DiscardTexHandle() {
	if (texHandle) {
		texHandle->DeleteThis();
		texHandle = NULL;
		}
	}

void Checker::ActivateTexDisplay(BOOL onoff) {
	if (!onoff) 
		DiscardTexHandle();
	}

DWORD Checker::GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {
	if (texHandle) {
		if (texHandleValid.InInterval(t))
			return texHandle->GetHandle();
		else DiscardTexHandle();
		}
	Bitmap *bm;
	Interval v;
	Update(t,v);
	bm = BuildBitmap(thmaker.Size());
	texHandle = thmaker.CreateHandle(bm,uvGen->SymFlags());
	bm->DeleteThis();
	texHandleValid.SetInfinite();
	Color ac;

	pblock->GetValue( checker_color1, t, ac, texHandleValid );
	pblock->GetValue( checker_color2, t, ac, texHandleValid );
	float b;
	pblock->GetValue( checker_blur, t, b, texHandleValid );
	return texHandle->GetHandle();
	}

inline UWORD FlToWord(float r) {
	return (UWORD)(65535.0f*r);
	}

Bitmap *Checker::BuildBitmap(int size) {
	float u,v;
	BitmapInfo bi;
	bi.SetName(_T("checkerTemp"));
	bi.SetWidth(size);
	bi.SetHeight(size);
	bi.SetType(BMM_TRUE_32);
	Bitmap *bm = TheManager->Create(&bi);
	if (bm==NULL) return NULL;
	PixelBuf l64(size);
	float d = 1.0f/float(size);
	v = 1.0f - 0.5f*d;
	for (int y=0; y<size; y++) {
		BMM_Color_64 *p64=l64.Ptr();
		u = 0.0f;
		for (int x=0; x<size; x++, p64++) {
			AColor c = DispEvalFunc(u,v);
			p64->r = FlToWord(c.r); 
			p64->g = FlToWord(c.g); 
			p64->b = FlToWord(c.b);
			p64->a = 0xffff; 
			u += d;
			}
		bm->PutPixels(0,y, size, l64.Ptr()); 
		v -= d;
		}
	return bm;
	}

// This is the integral of a square wave function
static inline float sintegral(float x) {
	float f = (float)floor(x);
	return (float)(f*0.5f + fmax(0.0f,(x-f)-.5f));
	}

// simplified evaluation for interactive render
AColor Checker::DispEvalFunc( float u, float v) {
	if (blur!=0.0f) {
		float hd = blur*.5f;
		float s = (sintegral(u+hd)-sintegral(u-hd))/blur;
		float t = (sintegral(v+hd)-sintegral(v-hd))/blur;
		float a = s*t + (1.0f-s)*(1.0f-t);
		if (a==0.0f) return  col[0];
		else if (a==1.0f)return  col[1];
		else return a*col[1] + (1.0f-a)*col[0];
		}
	else {
		u = u - (float)floor(u);
		v = v - (float)floor(v);
		if ( (u>.5f)^(v>.5f))
			return col[0];
		else 
			return  col[1];
		}
	}

// This function should only be called for samples within the 0,1 
// box, so a lot of this complication is not necessary.
AColor Checker::EvalFunction(ShadeContext& sc, float u, float v, float du, float dv) {
	dv += blur;
	du += blur;
	float hdu = du*.5f;
	float hdv = dv*.5f;
	if (du!=0.0f||dv!=0.0f) {
		float s = (sintegral(u+hdu)-sintegral(u-hdu))/du;
		float t = (sintegral(v+hdv)-sintegral(v-hdv))/dv;
		float a = s*t + (1.0f-s)*(1.0f-t);
		if (a<=.0005f) 
			return mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
		else if (a>=.9995f)
			return mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
		else {
			AColor c0  = mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
			AColor c1  = mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
			return a*c1 + (1.0f-a)*c0;
			}
		}
	else {
		u = u - (float)floor(u);
		v = v - (float)floor(v);
		if ( (u>.5f)^(v>.5f))
			return mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
		else 
			return mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
		}
	}

// This function should only be called for samples within the 0,1 
// box, so a lot of this complication is not necessary.
float Checker::MonoEvalFunction(ShadeContext& sc, float u, float v, float du, float dv) {
	du = blur+du; 
	dv = blur+dv;  
	float hdu = du*.5f;
	float hdv = dv*.5f;
	if (du!=0.0f||dv!=0.0f) {
		float s = (sintegral(u+hdu)-sintegral(u-hdu))/du;
		float t = (sintegral(v+hdv)-sintegral(v-hdv))/dv;
		float a = s*t + (1.0f-s)*(1.0f-t);
		if (a<=.0005f) 
			{
			float level;
			level = mapOn[0]&&subTex[0] ? subTex[0]->EvalMono(sc): Intens(col[0]);
			return level;
			}
//			return 
		else if (a>=.9995f)
			return mapOn[1]&&subTex[1] ? subTex[1]->EvalMono(sc): Intens(col[1]);
		else {
			float c0  = mapOn[0]&&subTex[0] ? subTex[0]->EvalMono(sc): Intens(col[0]);
			float c1  = mapOn[1]&&subTex[1] ? subTex[1]->EvalMono(sc): Intens(col[1]);
			return a*c1 + (1.0f-a)*c0;
			}
		}
	else {
		u = u - (float)floor(u);
		v = v - (float)floor(v);
		if ( (u>.5f)^(v>.5f))
			return mapOn[0]&&subTex[0] ? subTex[0]->EvalMono(sc): Intens(col[0]);
		else 
			return mapOn[1]&&subTex[1] ? subTex[1]->EvalMono(sc): Intens(col[1]);
		}
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);

AColor Checker::EvalColor(ShadeContext& sc) {
	if (!sc.doMaps) return black;
	if (gbufID) sc.SetGBufferID(gbufID);
	return uvGen->EvalUVMap(sc,&mysamp);
	}

float Checker::EvalMono(ShadeContext& sc) {
	if (!sc.doMaps) 	return 0.0f;
	if (gbufID) sc.SetGBufferID(gbufID);
	return uvGen->EvalUVMapMono(sc,&mysamp);
	}

Point3 Checker::EvalNormalPerturb(ShadeContext& sc) {
	Point3 dPdu, dPdv;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	uvGen->GetBumpDP(sc,dPdu,dPdv);
	Point2 dM = uvGen->EvalDeriv(sc,&mysamp);
	return dM.x*dPdu+dM.y*dPdv;
	}

RefTargetHandle Checker::Clone(RemapDir &remap) {
	Checker *mnew = new Checker();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(uvGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->blur = blur;
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		mnew->mapOn[i] = mapOn[i];
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Checker::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {

// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  

	// create the rollout dialogs
	uvGenDlg = uvGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = checkerCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(uvGenDlg);
//attach a dlg proc to handle the swap button 
	checker_param_blk.SetUserDlgProc(new CheckerDlgProc(this));

	return masterDlg;
	}


BOOL Checker::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if (dlg == uvGenDlg)
		uvGenDlg->SetThing(uvGen);
	else 
		return FALSE;
	return TRUE;
}




void Checker::Update(TimeValue t, Interval& valid) {		

	if (Param1)  //this is a hack to fix old 2.5 files check boxes
		{
		pblock->SetValue( checker_map1_on, 0, mapOn[0]);
		pblock->SetValue( checker_map2_on, 0, mapOn[1]);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		uvGen->Update(t,ivalid);
		pblock->GetValue( checker_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( checker_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( checker_blur, t, blur, ivalid );
		pblock->GetValue( checker_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( checker_map2_on, t, mapOn[1], ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}


void Checker::SetColor(int i, Color c, TimeValue t) {
	if (i== checker_color1)
		col[0] = c;
	else col[1] = c;

	pblock->SetValue( i, t, c);
	}

void Checker::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(checker_color1,0,checker_color2,0);
	checker_param_blk.InvalidateUI(checker_color1);
	checker_param_blk.InvalidateUI(checker_color2);
	checker_param_blk.InvalidateUI(checker_map1);
	checker_param_blk.InvalidateUI(checker_map2);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
	}

void Checker::SetBlur(float f, TimeValue t) { 
	blur = f; 
	pblock->SetValue( checker_blur, t, f);
	}

RefTargetHandle Checker::GetReference(int i) {
	switch(i) {
		case 0: return uvGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
		}
	}

void Checker::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: uvGen = (UVGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
	}

void Checker::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2,m);
	if (i==0)
		{
		checker_param_blk.InvalidateUI(checker_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		checker_param_blk.InvalidateUI(checker_map2);
		ivalid.SetEmpty();
		}

	}

TSTR Checker::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Checker::SubAnim(int i) {
	switch (i) {
		case 0: return uvGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
		}
	}

TSTR Checker::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-2);
		}
	}

RefResult Checker::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			{
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != uvGen  && hTarget != pblock ) 
					checker_param_blk.InvalidateUI(changing_param);
				if (changing_param != -1)
					DiscardTexHandle();
				}
			break;
			}
		case REFMSG_UV_SYM_CHANGE:
			DiscardTexHandle();  
			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Checker::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

	return IO_OK;
	}	
	 

//watje
class CheckerPostLoadCallback:public  PostLoadCallback
{
public:
	Checker      *s;
	CheckerPostLoadCallback(Checker *r) {s=r;}
	void proc(ILoad *iload);
};

/*
void CheckerPostLoadCallback::proc(ILoad *iload)
{

	if (s->Param1)
		{
		s->pblock->SetValue( checker_map1_on, 0, s->mapOn[0]);
		s->pblock->SetValue( checker_map2_on, 0, s->mapOn[1]);
		}

	delete this;

}
 */


IOResult Checker::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &checker_param_blk, this, PBLOCK_REF);
	iload->RegisterPostLoadCallback(plcb);

//copy loaded values into the new param block
//	CheckerPostLoadCallback* checkerplcb = new CheckerPostLoadCallback(this);
//	iload->RegisterPostLoadCallback(checkerplcb);

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\dblsided.cpp ===
/**********************************************************************
 *<
	FILE: dblsided.cpp

	DESCRIPTION:  A double sided material

	CREATED BY: Rolf Berteig
				
	HISTORY:	Updated to Param Block2 12/1/1998 Peter Watje


 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

static Class_ID dblsidedClassID(DOUBLESIDED_CLASS_ID,0);
#define  NSUBMTL 2

#define PB_REF		0
#define SUB1_REF	1
#define SUB2_REF	2

enum { doublesided_params, };  // pblock ID
// doublesided_params param IDs
enum 
{ 
	doublesided_map1, doublesided_map2,		
	doublesided_map1_on, doublesided_map2_on, // main grad params 
	doublesided_transluency
};


class DoubleSided : public Mtl {	
	public:
		BOOL Param1;
		IParamBlock2 *pblock; 	// ref #0
		Mtl *sub[2];		// ref #1, 2		
		BOOL mtlOn[2];
		float trans;
		Interval ivalid;

		DoubleSided(BOOL loading);
		void NotifyChanged() {NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
		Mtl *UseMtl() {return sub[0]?sub[0]:sub[1];}

		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}				
		
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);
				
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		
		Class_ID ClassID() {return dblsidedClassID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_DOUBLESIDED);}  

		void DeleteThis() {delete this;}	

		// Methods to access sub-materials of meta-materials
	   	int NumSubMtls() {return 2;}
		void SetSubMtl(int i, Mtl *m);

		Mtl* GetSubMtl(int i) {return sub[i];}
		TSTR GetSubMtlSlotName(int i) {return i?GetString(IDS_RB_BACK):GetString(IDS_RB_FACING);}

		ULONG LocalRequirements(int subMtlNum) {  return  MTLREQ_2SIDE; }

		int NumSubs() {return 3;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// From ref
 		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		// IO
		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload); 
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

	};

class DoubleSidedClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new DoubleSided(loading);}
	const TCHAR *	ClassName() {return GetString(IDS_RB_DOUBLESIDED_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return MATERIAL_CLASS_ID;}
	Class_ID 		ClassID() {return dblsidedClassID;}
	const TCHAR* 	Category() {return _T("");}
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("doubleSidedMat"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};
static DoubleSidedClassDesc dblsidedCD;
ClassDesc* GetDoubleSidedDesc() {return &dblsidedCD;}





// per instance gradient block
static ParamBlockDesc2 doublesided_param_blk ( doublesided_params, _T("parameters"),  0, &dblsidedCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PB_REF, 
	//rollout
	IDD_DOUBLESIDED, IDS_DS_DBLSIDED_PARAMS, 0, 0, NULL, 
	// params
	doublesided_map1,		_T("material1"),		TYPE_MTL,			P_OWNERS_REF,	IDS_RB_MATERIALONE,
		p_refno,		1,
		p_submtlno,		0,		
		p_ui,			TYPE_MTLBUTTON, IDC_2SIDE_MAT1,
		end,
	doublesided_map2,		_T("material2"),		TYPE_MTL,			P_OWNERS_REF,	IDS_RB_MATERIALTWO,
		p_refno,		2,
		p_submtlno,		1,		
		p_ui,			TYPE_MTLBUTTON, IDC_2SIDE_MAT2,
		end,
	doublesided_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	doublesided_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	doublesided_transluency,	_T("translucency"), TYPE_FLOAT,		P_ANIMATABLE,	IDS_RB_TRANSLUECENCY,
		p_default,		0.0f,
		p_range,		0.0f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_2SIDE_TRANSLUCENCY, IDC_2SIDE_TRANSLUCENCYSPIN, 0.1f, 
		end,
	end
);


//--- DoubleSided Material -------------------------------------------------

static ParamBlockDescID pbdesc[1] = {
	{TYPE_FLOAT, NULL, TRUE,doublesided_transluency }
	};   // Translucency
static ParamVersionDesc versions[1] = {
	ParamVersionDesc(pbdesc,1,0),	
	};

DoubleSided::DoubleSided(BOOL loading)
	{	
	Param1 = FALSE;
	pblock = NULL;
	sub[0] = sub[1] = NULL;	
	mtlOn[0] = mtlOn[1] = 1;
	ivalid.SetEmpty();
	if (!loading) {
		dblsidedCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
		Init();
		}
	}

void DoubleSided::Init()
	{
	ReplaceReference(SUB1_REF, NewDefaultStdMat());
	ReplaceReference(SUB2_REF, NewDefaultStdMat());
	GetCOREInterface()->AssignNewName(sub[0]);
	GetCOREInterface()->AssignNewName(sub[1]);
	mtlOn[0] = mtlOn[1] = 1;
	}

void DoubleSided::Reset()
	{
	dblsidedCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

Color DoubleSided::GetAmbient(int mtlNum, BOOL backFace) { 
	if (backFace&&sub[1]) return sub[1]->GetAmbient(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetAmbient(mtlNum);
	return UseMtl()?UseMtl()->GetAmbient():Color(0,0,0);
	}		
Color DoubleSided::GetDiffuse(int mtlNum, BOOL backFace){ 
	if (backFace&&sub[1]) return sub[1]->GetDiffuse(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetDiffuse(mtlNum);
	return UseMtl()?UseMtl()->GetDiffuse(mtlNum,backFace):Color(0,0,0);
	}				
Color DoubleSided::GetSpecular(int mtlNum, BOOL backFace){
	if (backFace&&sub[1]) return sub[1]->GetSpecular(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetSpecular(mtlNum);
	return UseMtl()?UseMtl()->GetSpecular(mtlNum,backFace):Color(0,0,0);
	}		
float DoubleSided::GetXParency(int mtlNum, BOOL backFace) {
	if (backFace&&sub[1]) return sub[1]->GetXParency(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetXParency(mtlNum);
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}
float DoubleSided::GetShininess(int mtlNum, BOOL backFace) {
	if (backFace&&sub[1]) return sub[1]->GetShininess(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetShininess(mtlNum);
	return UseMtl()?UseMtl()->GetShininess(mtlNum,backFace):0.0f;
	}		
float DoubleSided::GetShinStr(int mtlNum, BOOL backFace) {
	if (backFace&&sub[1]) return sub[1]->GetShinStr(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->GetShinStr(mtlNum);
	return UseMtl()?UseMtl()->GetShinStr(mtlNum,backFace):0.0f;
	}

float DoubleSided::WireSize(int mtlNum, BOOL backFace) {
	if (backFace&&sub[1]) return sub[1]->WireSize(mtlNum);
	if (!backFace&&sub[0]) return sub[0]->WireSize(mtlNum);
	return UseMtl()?UseMtl()->WireSize(mtlNum,backFace):0.0f;
	}

		
ParamDlg* DoubleSided::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	IAutoMParamDlg* masterDlg = dblsidedCD.CreateParamDlgs(hwMtlEdit, imp, this);
	return masterDlg;
	}

static Color black(0,0,0);

void DoubleSided::Shade(ShadeContext& sc)
	{
	if (gbufID) sc.SetGBufferID(gbufID);
	Mtl *m1, *m2, *m = UseMtl();
	if (!m) return;
	if (!sc.backFace) {	
		m1 = mtlOn[0]?sub[0]:NULL;
		m2 = mtlOn[1]?sub[1]:NULL;
	} else {
		m1 = mtlOn[1]?sub[1]:NULL;
		m2 = mtlOn[0]?sub[0]:NULL;
		}
	if (trans==0.0f) {
		if (m1) m1->Shade(sc);
	} else {		
		BOOL bf = sc.backFace;
		ShadeOutput out1;
		if(m1) {
			m1->Shade(sc);
			out1 = sc.out;
			}
		else out1.Reset();
		sc.backFace = !sc.backFace;
		if (m2) {
			m2->Shade(sc);
			}
		else sc.out.Reset();
		sc.backFace = bf;
		sc.out.MixIn(out1,trans);
		}
	}


void DoubleSided::SetSubMtl(int i, Mtl *m)
	{ 
	ReplaceReference(i+1,m); 
	if (i==0)
		{
		doublesided_param_blk.InvalidateUI(doublesided_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		doublesided_param_blk.InvalidateUI(doublesided_map2);
		ivalid.SetEmpty();
		}	
	}


void DoubleSided::Update(TimeValue t, Interval& valid)
	{	

/*
	if (Param1) // 2.5 load hack fix
		{
		pblock->SetValue(doublesided_map1_on,t,mtlOn[0]);
		pblock->SetValue(doublesided_map2_on,t,mtlOn[1]);
		Param1 = FALSE;
		}
*/

	ivalid = FOREVER;
	for (int i=0; i<2; i++) 
		if (sub[i]) sub[i]->Update(t,valid);
	pblock->GetValue(doublesided_transluency,t,trans,ivalid);
	trans = trans * 0.01f;
	pblock->GetValue(doublesided_map1_on,t,mtlOn[0],ivalid);
	pblock->GetValue(doublesided_map2_on,t,mtlOn[1],ivalid);
	valid &= ivalid;
	}

Interval DoubleSided::Validity(TimeValue t)
	{
	Interval valid = FOREVER;	
	float f;
	for (int i=0; i<2; i++) 
		if (sub[i]) valid &= sub[i]->Validity(t);
	pblock->GetValue(doublesided_transluency,t,f,valid);
	return valid;
	}

Animatable* DoubleSided::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return sub[0];
		case 2: return sub[1];
		default: return NULL;
		}
	}

TSTR DoubleSided::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_DS_PARAMETERS);
		case 1: return GetString(IDS_RB_FACINGMAT);
		case 2: return GetString(IDS_RB_BACKMATERIAL);
		default: return _T("");
		}
	}

RefTargetHandle DoubleSided::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return sub[0];
		case 2: return sub[1];
		default: return NULL;
		}
	}

void DoubleSided::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		case 1: sub[0] = (Mtl*)rtarg; break;
		case 2: sub[1] = (Mtl*)rtarg; break;
		}
	}

RefTargetHandle DoubleSided::Clone(RemapDir &remap)
	{
	DoubleSided *mtl = new DoubleSided(FALSE);
	*((MtlBase*)mtl) = *((MtlBase*)this);  // copy superclass stuff
	mtl->ReplaceReference(PB_REF,remap.CloneRef(pblock));
	if (sub[0]) mtl->ReplaceReference(SUB1_REF,remap.CloneRef(sub[0]));
	if (sub[1]) mtl->ReplaceReference(SUB2_REF,remap.CloneRef(sub[1]));
	for (int i=0; i<NSUBMTL; i++) 
		mtl->mtlOn[i] = mtlOn[i];
	return mtl;
	}

RefResult DoubleSided::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				doublesided_param_blk.InvalidateUI(changing_param);
				}

			break;
		}
	return REF_SUCCEED;
	}

//
// Note: ALL Materials and texmaps must have a Save and Load to save and load
// the MtlBase info.
#define MTL_HDR_CHUNK 0x4000
#define MTLOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult DoubleSided::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();


	return IO_OK;
	}

//watje
class DoubleSidedPostLoadCallback:public  PostLoadCallback
{
public:
	DoubleSided      *s;
	int Param1;
	DoubleSidedPostLoadCallback(DoubleSided *r, BOOL b) {s=r;Param1 = b;}
	void proc(ILoad *iload);
};

void DoubleSidedPostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		TimeValue t  = 0;
		s->pblock->SetValue(doublesided_map1_on,t,s->mtlOn[0]);
		s->pblock->SetValue(doublesided_map2_on,t,s->mtlOn[1]);

		Interval iv;
		s->pblock->GetValue(doublesided_transluency,t,s->trans,iv);
		s->trans *= 100.0f;
		s->pblock->SetValue(doublesided_transluency,t,s->trans);

		}
	delete this;
}
	
	  

IOResult DoubleSided::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MTLOFF_CHUNK+0:
			case MTLOFF_CHUNK+1:
				mtlOn[id-MTLOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	if (Param1)
	{
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &doublesided_param_blk, this, PB_REF);
		iload->RegisterPostLoadCallback(plcb);

		DoubleSidedPostLoadCallback* doubleSidedplcb = new DoubleSidedPostLoadCallback(this,Param1);
		iload->RegisterPostLoadCallback(doubleSidedplcb);
	}

	return IO_OK;
	}


float DoubleSided::EvalDisplacement(ShadeContext& sc) {
	Mtl *m1, *m2, *m = UseMtl();
	if (!m) return 0.0f;
	if (!sc.backFace) {	
		m1 = mtlOn[0]?sub[0]:NULL;
		m2 = mtlOn[1]?sub[1]:NULL;
	} else {
		m1 = mtlOn[1]?sub[1]:NULL;
		m2 = mtlOn[0]?sub[0]:NULL;
		}
	if (trans==0.0f) {
		return (m1)? m1->EvalDisplacement(sc):0.0f;
	} else {		
		BOOL bf = sc.backFace;
		float d1 = (m1)?m1->EvalDisplacement(sc):0.0f;
		sc.backFace = !sc.backFace;
		float d2 = (m2)?m2->EvalDisplacement(sc):0.0f;
		sc.backFace = bf;
		return (1.0f-trans)*d1 + trans*d2;
		}
	}

Interval DoubleSided::DisplacementValidity(TimeValue t) {
	Interval iv;
	iv.SetInfinite();
	if (mtlOn[0]&&sub[0]) 	
		iv &= sub[0]->DisplacementValidity(t);		
	if (mtlOn[1]&&sub[1]) 	
		iv &= sub[1]->DisplacementValidity(t);		
	return iv;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\composit.cpp ===
/**********************************************************************
 *<
	FILE: composit.cpp

	DESCRIPTION: A compositor texture map.

	CREATED BY: Rolf Berteig

	HISTORY: UPdated to Param2 1/11/98 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include <bmmlib.h>
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

static Class_ID compClassID(COMPOSITE_CLASS_ID,0);

class Composite;
class CompositeDlg;

#define NDLG 6


class CompositeDlg: public ParamDlg {
	public:
		HWND hwmedit;	 	// window handle of the materials editor dialog
		IMtlParams *ip;
		Composite *theTex;	 
		HWND hPanel; 		// Rollup pane		
		HWND hScroll;
		BOOL valid;
		ICustButton *iBut[NDLG];
		TexDADMgr dadMgr;
				
		CompositeDlg(HWND hwMtlEdit, IMtlParams *imp, Composite *m); 
		~CompositeDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );		
		void VScroll(int code, short int cpos );
		void LoadDialog(BOOL draw);  // stuff params into dialog
		void ReloadDialog();
		void UpdateMtlDisplay();		
		void UpdateSubTexNames();
		void ActivateDlg(BOOL onOff);
		void Invalidate();
		void Destroy(HWND hWnd);
		void SetNumMaps();
		void DragAndDrop(int ifrom, int ito);

		// methods inherited from ParamDlg:
		Class_ID ClassID() {return compClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() {return (ReferenceTarget *)theTex;}
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);
		int FindSubTexFromHWND(HWND hw);
	};



class Composite: public MultiTex { 
	public:			
		Tab<Texmap*> subTex;
		Tab<BOOL>mapOn;
		Interval ivalid;
		int offset;
		int rollScroll;
		CompositeDlg *paramDlg;

		BOOL Param1;
		IParamBlock2 *pblock;   // ref #0		

	
		Composite();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void ClampOffset();
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) {Interval v; Update(t,v); return ivalid;}
		void NotifyChanged();		
		void SetNumSubTexmaps(int n) { SetNumMaps(n); }
		void SetNumMaps(int n);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		
		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);		

		// Methods to access texture maps of material
		int NumSubTexmaps() {return subTex.Count();}
		Texmap* GetSubTexmap(int i) {return subTex[i];}		
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);		

		Class_ID ClassID() {return compClassID;}
		SClass_ID SuperClassID() {return TEXMAP_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_RB_COMPOSITE);}
		void DeleteThis() {delete this;}

		int NumSubs() {return subTex.Count();}
		Animatable* SubAnim(int i) {return subTex[i];}
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum+1;}

		// From ref
 		int NumRefs() {return subTex.Count()+1;}
		RefTargetHandle GetReference(int i) {
						if (i==0) return pblock;
						else return subTex[i-1];
						}
		void SetReference(int i, RefTargetHandle rtarg) {
						if(i==0) pblock = (IParamBlock2*) rtarg;
						else subTex[i-1] = (Texmap*)rtarg;
						}

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		int RemapRefOnLoad(int iref) ;

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};

class CompositeClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new Composite;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_COMPOSITE_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return TEXMAP_CLASS_ID;}
	Class_ID 		ClassID() {return compClassID;}
	const TCHAR* 	Category() {return TEXMAP_CAT_COMP;}
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("compositeTexture"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};
static CompositeClassDesc compCD;
ClassDesc* GetCompositeDesc() {return &compCD;}
// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { comptex_params, };  // pblock ID
// multi_params param IDs
enum 
{ 
	comptex_tex, comptex_ons

};

// per instance gradient block
static ParamBlockDesc2 comptex_param_blk ( comptex_params, _T("parameters"),  0, &compCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_COMPOSITEMAP, IDS_DS_BASIC, 0, 0, NULL, 
	// params
	comptex_tex,	_T("mapList"),	TYPE_TEXMAP_TAB, 2,	P_OWNERS_REF + P_VARIABLE_SIZE,	IDS_DS_TEXMAP,	
		p_refno,	1, 
		end,
	comptex_ons,	_T("mapEnabled"), TYPE_BOOL_TAB, 2,	P_VARIABLE_SIZE,				IDS_JW_MAP1ENABLE,
		p_default,	TRUE,
		end,

	end
);


static BOOL CALLBACK PanelDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) 
	{
	CompositeDlg *theDlg = (CompositeDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	if (msg==WM_INITDIALOG) {
		theDlg = (CompositeDlg*)lParam;
		theDlg->hPanel = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);
		}	
	if (theDlg) return theDlg->PanelProc(hWnd,msg,wParam,lParam);
	else return FALSE;
	}

int CompositeDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NDLG; i++) {
		if (hw == iBut[i]->GetHwnd()) return i+theTex->offset;
		}	
	return -1;
	}

void CompositeDlg::DragAndDrop(int ifrom, int ito) {
	theTex->CopySubTexmap(hPanel,ifrom+theTex->offset, ito+theTex->offset);
	theTex->NotifyChanged();
	}


//-------------------------------------------------------------------

CompositeDlg::CompositeDlg(HWND hwMtlEdit, IMtlParams *imp, Composite *m) 
	{
	dadMgr.Init(this);
	hwmedit  = hwMtlEdit;
	ip       = imp;
	hPanel   = NULL;
	theTex   = m; 	
	valid    = FALSE;	
	for (int i=0; i<NDLG; i++) iBut[i] = NULL;
	hPanel   = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_COMPOSITEMAP),
		PanelDlgProc, 
		GetString(IDS_RB_COMPOSITEPARAMS),
		(LPARAM)this);	
	}

void CompositeDlg::Destroy(HWND hWnd) {
	for (int i=0; i<NDLG; i++) {
		ReleaseICustButton(iBut[i]);
		iBut[i] = NULL; 
		}
	}

void CompositeDlg::Invalidate()
	{
	valid = FALSE;
	Rect rect;
	rect.left = rect.top = 0;
	rect.right = rect.bottom = 10;
	InvalidateRect(hPanel,&rect,FALSE);
	}

void CompositeDlg::ReloadDialog() 
	{
	Interval valid;
	theTex->Update(ip->GetTime(), valid);
	LoadDialog(FALSE);
	}

void CompositeDlg::SetTime(TimeValue t) 
	{
	Interval valid;	
	theTex->Update(ip->GetTime(), valid);
	LoadDialog(FALSE);
	InvalidateRect(hPanel,NULL,0);	
	}

CompositeDlg::~CompositeDlg() 
	{
	theTex->paramDlg = NULL;	
	SetWindowLong(hPanel, GWL_USERDATA, NULL);	
	hPanel =  NULL;
	}


void CompositeDlg::VScroll(int code, short int cpos ) {
	switch (code) {
		case SB_LINEUP: 	theTex->offset--;		break;
		case SB_LINEDOWN:	theTex->offset++;		break;
		case SB_PAGEUP:		theTex->offset -= NDLG;	break;
		case SB_PAGEDOWN:	theTex->offset += NDLG;	break;
		
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK:
			theTex->offset = cpos;
			break;
		}
	theTex->ClampOffset();
	UpdateSubTexNames();						
	LoadDialog(ip->GetTime());
	}

static int mapIDs[] = {IDC_COMP_TEX1,IDC_COMP_TEX2,IDC_COMP_TEX3,IDC_COMP_TEX4,IDC_COMP_TEX5,IDC_COMP_TEX6};
static int labelIDs[] = {IDC_COMP_LABEL1,IDC_COMP_LABEL2,IDC_COMP_LABEL3,IDC_COMP_LABEL4,IDC_COMP_LABEL5,IDC_COMP_LABEL6};
static int mapOnIDs[] = {IDC_MAPON1,IDC_MAPON2,IDC_MAPON3,IDC_MAPON4,IDC_MAPON5,IDC_MAPON6};


BOOL CompositeDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
	{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG: {			
			hScroll	= GetDlgItem(hWnd,IDC_COMP_SCROLL);
			SetScrollRange(hScroll,SB_CTL,0,theTex->NumSubTexmaps()-NDLG,FALSE);
			SetScrollPos(hScroll,SB_CTL,theTex->offset,TRUE);
			EnableWindow(hScroll,theTex->NumSubTexmaps()>NDLG);
			for (int i=0; i<NDLG; i++) {
				iBut[i] = GetICustButton(GetDlgItem(hWnd,IDC_COMP_TEX1+i));
				iBut[i]->SetDADMgr(&dadMgr);
//				if (i-theTex->offset<theTex->mapOn.Count())
//					SetCheckBox(hWnd, mapOnIDs[i], theTex->mapOn[i-theTex->offset]);
				}
			return TRUE;
			}
			
		case WM_PAINT:
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;

		case WM_VSCROLL:
			VScroll(LOWORD(wParam),(short int)HIWORD(wParam));
			break;
			
		case WM_COMMAND: 		    		 	
			switch (id) {		
				case IDC_COMP_TEX1: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset,(LPARAM)theTex); break;
				case IDC_COMP_TEX2: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset+1,(LPARAM)theTex); break;
				case IDC_COMP_TEX3: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset+2,(LPARAM)theTex); break;
				case IDC_COMP_TEX4: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset+3,(LPARAM)theTex); break;
				case IDC_COMP_TEX5: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset+4,(LPARAM)theTex); break;
				case IDC_COMP_TEX6: PostMessage(hwmedit,WM_TEXMAP_BUTTON,theTex->offset+5,(LPARAM)theTex); break;

				case IDC_MAPON1:							
				case IDC_MAPON2:							
				case IDC_MAPON3:							
				case IDC_MAPON4:							
				case IDC_MAPON5:							
				case IDC_MAPON6:
					theTex->pblock->SetValue(comptex_ons,0,GetCheckBox(hWnd, id),id-IDC_MAPON1+theTex->offset);
//					theTex->mapOn[id-IDC_MAPON1+theTex->offset] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					break;							
									
				case IDC_COMP_SETNUM:
					SetNumMaps();
					break;
				}			
			break;
				
		case WM_DESTROY:
			Destroy(hWnd);
			break;
    	}
	return FALSE;
	}

void CompositeDlg::UpdateSubTexNames() 
	{
	for (int i=theTex->offset; i<theTex->subTex.Count(); i++) {
		if (i-theTex->offset>=NDLG) break;

		Texmap *m = theTex->subTex[i];
		TSTR nm;
		if (m) 	nm = m->GetFullName();
		else 	nm = GetString(IDS_DS_NONE);
		TSTR buf;
		buf.printf(_T("%s %d:"),GetString(IDS_RB_MAP2),i+1);
		iBut[i-theTex->offset]->SetText(nm.data());
		SetDlgItemText(hPanel, labelIDs[i-theTex->offset], buf);
//		SetCheckBox(hPanel, mapOnIDs[i-theTex->offset], theTex->mapOn[i]);
		int on;
		Interval iv;
		theTex->pblock->GetValue(comptex_ons,0,on,iv,i);
		SetCheckBox(hPanel, mapOnIDs[i-theTex->offset], on);
		}
	}


void CompositeDlg::LoadDialog(BOOL draw) 
	{	
	if (theTex) {		
		theTex->ClampOffset();
		
		SetScrollRange(hScroll,SB_CTL,0,theTex->subTex.Count()-NDLG,FALSE);
		SetScrollPos(hScroll,SB_CTL,theTex->offset,TRUE);
		EnableWindow(hScroll,theTex->NumSubTexmaps()>NDLG);

		if (theTex->subTex.Count()>NDLG) {
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_UP),theTex->offset>0);
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_PAGEUP),theTex->offset>0);
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_DOWN),theTex->offset+NDLG<theTex->subTex.Count());
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_PAGEDOWN),theTex->offset+NDLG<theTex->subTex.Count());
		} else {
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_UP),FALSE);
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_PAGEUP),FALSE);
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_DOWN),FALSE);
			EnableWindow(GetDlgItem(hPanel,IDC_COMP_PAGEDOWN),FALSE);
			}

		Interval valid;
		theTex->Update(ip->GetTime(),valid);		
		UpdateSubTexNames();
		TSTR buf;
		buf.printf(_T("%d"),theTex->subTex.Count());
		SetDlgItemText(hPanel,IDC_COMP_NUMMAPS,buf);
		for (int i=0; i<min(theTex->subTex.Count(),NDLG); i++) {
			ShowWindow(GetDlgItem(hPanel,mapIDs[i]),SW_SHOW);
			ShowWindow(GetDlgItem(hPanel,labelIDs[i]),SW_SHOW);
			ShowWindow(GetDlgItem(hPanel,mapOnIDs[i]),SW_SHOW);
//			SetCheckBox(hPanel, mapOnIDs[i], theTex->mapOn[i+theTex->offset]);
			}
		for (; i<NDLG; i++) {
			ShowWindow(GetDlgItem(hPanel,mapIDs[i]),SW_HIDE);
			ShowWindow(GetDlgItem(hPanel,labelIDs[i]),SW_HIDE);
			ShowWindow(GetDlgItem(hPanel,mapOnIDs[i]),SW_HIDE);
			}
		}
	}

void CompositeDlg::SetThing(ReferenceTarget *m) 
	{
	assert (m->ClassID()==compClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
	if (theTex) theTex->paramDlg = NULL;
	theTex = (Composite*)m;	
	if (theTex) theTex->paramDlg = this;
	LoadDialog(TRUE);
	}

void CompositeDlg::UpdateMtlDisplay() {	
	ip->MtlChanged();  
	}

void CompositeDlg::ActivateDlg(BOOL onOff) {	
	}


static BOOL CALLBACK NumMapsDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			ISpinnerControl *spin = 
				SetupIntSpinner(
					hWnd,IDC_COMP_NUMMAPSSPIN,IDC_COMP_NUMMAPS,
					0,1000,(int)lParam);
			ReleaseISpinner(spin);
			CenterWindow(hWnd,GetParent(hWnd));
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin = 
						GetISpinner(GetDlgItem(hWnd,IDC_COMP_NUMMAPSSPIN));
					EndDialog(hWnd,spin->GetIVal());
					ReleaseISpinner(spin);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}
		
void CompositeDlg::SetNumMaps()
	{
	int res = DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_COMP_SETNUM),
		hPanel,
		NumMapsDlgProc,
		(LPARAM)theTex->subTex.Count());
	if (res>=0) {
		theTex->SetNumMaps(res);
		LoadDialog(TRUE);
		}
	}

//-----------------------------------------------------------------------------
//  Composite
//-----------------------------------------------------------------------------

#define COMPOSITE_VERSION 2

void Composite::Init() 
	{	
	macroRecorder->Disable();
	ivalid.SetEmpty();
	offset = 0;
	subTex.Resize(0);
//	mapOn.Resize(0);
	SetNumMaps(2);
	macroRecorder->Enable();
	}

void Composite::Reset() 
	{	
	DeleteAllRefsFromMe();
	compCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	}

void Composite::ClampOffset() {
	if (offset+NDLG>subTex.Count()) offset = subTex.Count()-NDLG;
	if (offset<0) offset=0;
	}

void Composite::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Composite::Composite() 
	{	
	paramDlg  = NULL;
	pblock = NULL;
	Param1 = FALSE;
	compCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

void Composite::SetNumMaps(int n)
	{
	int ct = subTex.Count();
	if (n!=ct) {
		if (n<ct) {
			for (int i=n; i<ct; i++) {
				// Tell mtledit to deactivate texture map in UI
				if (subTex[i])
					subTex[i]->DeactivateMapsInTree();
				ReplaceReference(i+1,NULL);
				}
			}
		subTex.SetCount(n);
//		mapOn.SetCount(n);
		pblock->SetCount(comptex_tex,n);
		macroRec->Disable();  // JBW 4/21/99, only record one count change
		pblock->SetCount(comptex_ons,n);
		macroRec->Enable();

		if (n>ct) {
			for (int i=ct; i<subTex.Count(); i++) {
				subTex[i] = NULL;				
				pblock->SetValue(comptex_ons,0,TRUE,i);
//				mapOn[i] = TRUE;
				}
			}		
		NotifyChanged();
		}
	}

//need to remap references since we added a paramblock
int Composite::RemapRefOnLoad(int iref) 
{
if (Param1) iref += 1;
return iref;
}


static AColor black(0.0f,0.0f,0.0f,0.0f);

AColor Composite::EvalColor(ShadeContext& sc) {	
	AColor c;
	if (sc.GetCache(this,c)) 
		return c; 
	if (gbufID) sc.SetGBufferID(gbufID);
	AColor res(0,0,0);	
	for (int i=0; i<subTex.Count(); i++) {
//		int on;
		Interval iv;
//		pblock->GetValue(comptex_ons,0,on,iv,i);

		if (!subTex[i]||!mapOn[i]) continue;
//		if (!subTex[i]||!on) continue;
		res = CompOver(subTex[i]->EvalColor(sc),res);
		}
	sc.PutCache(this,res); 
	return res;
	}


Point3 Composite::EvalNormalPerturb(ShadeContext& sc) 
	{
	Point3 p(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
    BOOL c = FALSE;
	for (int i=0; i<subTex.Count(); i++) {
//		int on;
		Interval iv;
//		pblock->GetValue(comptex_ons,0,on,iv,i);
		if (!subTex[i]||!mapOn[i]) continue;
//		if (!subTex[i]||!on) continue;
		Point3 d = subTex[i]->EvalNormalPerturb(sc);
		if (!c) {
			p = d;
			c = 1;
			}	
		else {
			// composite perturbations using alpha -- DS 4/4/97
			AColor col = subTex[i]->EvalColor(sc);
			p = (1.0f-col.a)*p + d;
			}
		}
	return p;	
	}

RefTargetHandle Composite::Clone(RemapDir &remap) 
	{
	Composite *mnew = new Composite();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff	
	mnew->ivalid.SetEmpty();	
	mnew->subTex.SetCount(subTex.Count());
	mnew->ReplaceReference(0,remap.CloneRef(pblock));

	mnew->offset = offset;
	mnew->mapOn.SetCount(subTex.Count()); //DS 3/8/99  this seems necessary due to the param block 2 changes.

	for (int i = 0; i<subTex.Count(); i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i]) {
			mnew->ReplaceReference(i+1,remap.CloneRef(subTex[i]));
			GetCOREInterface()->AssignNewName(mnew->subTex[i]);
			}
//		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Composite::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
	{
	CompositeDlg *dm = new CompositeDlg(hwMtlEdit, imp, this);
	dm->LoadDialog(TRUE);	
	paramDlg = dm;
	return dm;	
	}


void Composite::Update(TimeValue t, Interval& valid) 
	{
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();		
		int n = pblock->Count(comptex_ons);
		if (n!=mapOn.Count()) mapOn.SetCount(n);
		for (int i=0; i<subTex.Count(); i++) {
			pblock->GetValue(comptex_ons,0,mapOn[i],valid,i);
	
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

void Composite::SetSubTexmap(int i, Texmap *m) {
	if (i>=subTex.Count()) {
		int n = subTex.Count();
		subTex.SetCount(i+1);
		pblock->SetCount(comptex_tex,i+1);

		for (int j=n; j<=i; j++)
			subTex[j] = NULL;
		}
	ReplaceReference(i+1,m);
	if (paramDlg)
		paramDlg->UpdateSubTexNames();
	}

TSTR Composite::GetSubTexmapSlotName(int i) {
	TSTR buf;
	buf.printf("%s %d",GetString(IDS_RB_MAP2),i+1);
	return buf;
	}
	 
TSTR Composite::SubAnimName(int i) {	
	return GetSubTexmapTVName(i);
	}

RefResult Composite::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:			
			if (paramDlg) 
				paramDlg->Invalidate();
			if (pblock->LastNotifyParamID() == comptex_tex && pblock->Count(comptex_tex) != subTex.Count())
				SetNumMaps(pblock->Count(comptex_tex));
			else if (pblock->LastNotifyParamID() == comptex_ons && pblock->Count(comptex_ons) != subTex.Count())
				SetNumMaps(pblock->Count(comptex_ons));
			ivalid.SetEmpty();
			break;
		
		case REFMSG_GET_PARAM_DIM:
			return REF_STOP; 
		
		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name= GetSubTexmapSlotName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 		0x4000
#define PARAM2_CHUNK 		0x4010
#define SUBTEX_COUNT_CHUNK	0x0010
#define MAPOFF_CHUNK 0x1000


IOResult Composite::Save(ISave *isave) { 
	IOResult res;
	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	
	int c = subTex.Count();
	isave->BeginChunk(SUBTEX_COUNT_CHUNK);
	isave->Write(&c,sizeof(c),&nb);
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

/*	for (int i=0; i<subTex.Count(); i++) {
		if (mapOn[i]==0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
			}
		}
*/

	return IO_OK;
	}	
	  

//watje
class CompTexPostLoadCallback:public  PostLoadCallback
{
public:
	Composite      *s;
	Tab<BOOL> ons;

	int Param1;
	CompTexPostLoadCallback(Composite *r, BOOL b, Tab<BOOL> bl) {s=r;Param1 = b;ons = bl;}
	void proc(ILoad *iload);
};

void CompTexPostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		s->pblock->SetCount(comptex_ons,ons.Count());
		s->pblock->SetCount(comptex_tex,ons.Count());
		for (int i=0; i<s->subTex.Count(); i++) {
			s->pblock->SetValue(comptex_ons,0,ons[i],i);

			}
		}
	delete this;
}

IOResult Composite::Load(ILoad *iload) { 
	IOResult res;	
	ULONG nb;
	Param1 = TRUE;
	Tab<BOOL>mapOn;
	while (IO_OK==(res=iload->OpenChunk())) {
		int id = iload->CurChunkID();
		if (id>=MAPOFF_CHUNK&&id<=MAPOFF_CHUNK+0x1000) {
			mapOn[id-MAPOFF_CHUNK] = FALSE; 
			}
		else 
		switch(id)  {
			case SUBTEX_COUNT_CHUNK: {
				int c;
				iload->Read(&c,sizeof(c),&nb);
				subTex.SetCount(c);
				mapOn.SetCount(c);
				for (int i=0; i<c; i++)  {
					subTex[i] = NULL;
					mapOn[i] = TRUE;
					}
				break;
				}

			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}	
	CompTexPostLoadCallback* comptexplcb = new CompTexPostLoadCallback(this,Param1,mapOn);
	iload->RegisterPostLoadCallback(comptexplcb);

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\dent.h ===
/**********************************************************************
 *<
	FILE:			Dent.h

	DESCRIPTION:	Dent 3D Texture map class decl.

	CREATED BY:		Suryan Stalin, on 4th April 1996

	HISTORY:		Modified from Marble.cpp by adding IPAS dent stuff
	*>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __DENT__H
#define __DENT__H

#include "iparamm2.h"

//	defines
#define DENT_CLASS_ID 		0x0000218
#define NSUBTEX				2
#define NCOLS				2
#define DENT_VERSION		1

#define DENT_VERS			0xDE01
#define MTL_HDR_CHUNK		0x4000
#define DENTVERS1_CHUNK		0x4001
#define DENT_NOISE_CHUNK	0x4003
#define DENTSIZE			50.0f
#define NOISE_DIM			20    
#define FNOISE_DIM			20.0


//	C Prototypes
ClassDesc*		GetDentDesc();



class Dent: public Tex3D 
{ 
	friend class DentPostLoad;
	XYZGen *xyzGen;		   // ref #0
	static ParamDlg *xyzGenDlg;
	Texmap* subTex[NSUBTEX];  // More refs
	Interval ivalid;
	int rollScroll;
	float DentFunc(Point3 p);

	public:
		int vers;
//		int seed;
		BOOL Param1;
		Color col[NCOLS];
		float km,size;
		int	nits;
		IParamBlock2 *pblock;   // ref #1
		BOOL mapOn[NSUBTEX];
		Dent();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetColor(int i, Color c, TimeValue t);
		void SetSize(float f, TimeValue t);
		void SetKm(float f, TimeValue t);
		void SetNits(int f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 

		void ReadSXPData(TCHAR *name, void *sxpdata);

		// Dent noise functions
		void	InitNoise();
		float	DentNoise(float x, float y, float z);
		void	LerpColor(RGBA *c, RGBA *a, RGBA *b, float f);
		float	SmoothStep(float x0, float x1, float v);

		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return xyzGen->Requirements(subMtlNum); }
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		XYZGen *GetTheXYZGen() { return xyzGen; }

		Class_ID ClassID();
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_DENT); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);



};

class DentClassDesc:public ClassDesc2 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Dent; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_DENT_CDESC); } // mjm - 2.10.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID();
	const TCHAR* 	Category() { return TEXMAP_CAT_3D;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("dents"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};






#pragma pack(1)
struct DentState 
{
	ulong	version;
	float	size, km;
	Col24	col1, col2;
	int		nits;
};
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\dent.cpp ===
/**********************************************************************
 *<
	FILE:			Dent.cpp

	DESCRIPTION:	Dent 3D Texture map.

	CREATED BY:		Suryan Stalin, on 4th April 1996

	HISTORY:		Modified from Marble.cpp by adding IPAS dent stuff
	*>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


//Includes
#include "mtlhdr.h"
#include "woodres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "wooddent.h"
#include "dent.h"
#include "macrorec.h"

// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { dents_params, };  // pblock ID
// dents_params param IDs
enum 
{ 
	dents_map1,dents_map2,dents_color1,dents_color2,
	dents_map1_on, dents_map2_on, // main grad params 

	dents_size,dents_strength, dents_iterations,
	dents_coords,
//	dents_seed

};

//Externs
extern		HINSTANCE			hInstance;

ParamDlg *Dent::xyzGenDlg;

//Globals
static		DentClassDesc		dentCD;
static		int					subTexId[NSUBTEX] = { IDC_DENT_TEX1, IDC_DENT_TEX2 };
static		ParamBlockDescID	pbdesc[] =	{
											{	TYPE_FLOAT, NULL, TRUE,dents_size }, 	// size
											{	TYPE_FLOAT, NULL, TRUE,dents_strength }, 	// km
											{	TYPE_INT, NULL, TRUE,dents_iterations }, 	// nits
											{	TYPE_RGBA, NULL, TRUE,dents_color1 },  // col1
											{	TYPE_RGBA, NULL, TRUE,dents_color2 }   // col2
											};
static		int					nameID[] =	{	IDS_DS_DENTSIZE, 
												IDS_DS_DENT_KM, 
												IDS_DS_DENT_NITS, 
												IDS_DS_COLOR1, 
												IDS_DS_COLOR2 
											};
static		int					colID[2] =	{ IDC_DENT_COL1, IDC_DENT_COL2 };
static		Class_ID			dentClassID(DENT_CLASS_ID,0);
static		float				noiseTable[NOISE_DIM+1][NOISE_DIM+1][NOISE_DIM+1];
static 		int   	noiseInited = 0;

// Array of old versions
static ParamVersionDesc versions[1] = {
	ParamVersionDesc(pbdesc,5,1)	
	};


// per instance gradient block
static ParamBlockDesc2 dents_param_blk ( dents_params, _T("parameters"),  0, &dentCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_DENT, IDS_DS_DENT_PARAMS, 0, 0, NULL, 
	// params
	dents_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_DENT_TEX1,
		end,
	dents_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_DENT_TEX2,
		end,
	dents_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_DENT_COL1, 
		end,
	dents_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(1,1,1), 
		p_ui,			TYPE_COLORSWATCH, IDC_DENT_COL2, 
		end,
	dents_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	dents_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,

	dents_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_DENTSIZE,
		p_default,		200.0,
		p_range,		0.0, 999999999.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_DENTSIZE_EDIT, IDC_DENTSIZE_SPIN, 1.0f,
		end,
	dents_strength,	_T("strength"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_DENT_KM,
		p_default,		20.0,
		p_range,		0.0, 999999999.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_KM_EDIT, IDC_KM_SPIN, 2.0f,
		end,
	dents_iterations,	_T("iterations"),   TYPE_INT,			P_ANIMATABLE,	IDS_DS_DENT_NITS,
		p_default,		2,
		p_range,		0, 10,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,   IDC_NITS_EDIT, IDC_NITS_SPIN, 1.0f,
		end,
	dents_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		0, 
		end,
//	dents_seed,	_T("seed"),   TYPE_INT,			0,	IDS_PW_SEED,
//		p_default,		65432,
//		p_range,		0, 999999999,
//		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,  IDC_DENTSEED_EDIT, IDC_DENTSEED_SPIN, 1.0f,
//		end,

	end
);



//Class Implementations

//dialog stuff to get the Set Ref button
class DentsDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Dent *dent;		
		DentsDlgProc(Dent *m) {dent = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}

		void SetThing(ReferenceTarget *m) {
			dent = (Dent*)m;
			}

	};



BOOL DentsDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_DENT_SWAP:
					{
					dent->SwapInputs();
					}
				}
			break;
		}
	return FALSE;
	}


//  Dent
void Dent::Init() 	{
	if (xyzGen) xyzGen->Reset();
	else ReplaceReference( 0, GetNewDefaultXYZGen());	
	ivalid.SetEmpty();
	SetColor(0, Color(0.0f,0.0f,0.0f), TimeValue(0));
	SetColor(1, Color(1.0f,1.0f,1.0f), TimeValue(0));
	SetSize(200.0f, TimeValue(0));
	SetKm(20.0f, TimeValue(0));
	SetNits(2, TimeValue(0));
	mapOn[0] = mapOn[1] = 1;
	}

void Dent::Reset() 	{
	dentCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

Dent::Dent() {
	Param1 = FALSE;
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
	//seed = 0;
	InitNoise();
	dentCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	vers = 0;
	}


void Dent::NotifyChanged() 
{
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

Class_ID Dent::ClassID() 
{	
	return dentClassID; 
}

RefTargetHandle Dent::Clone(RemapDir &remap) 
{
	Dent *mnew = new Dent();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(xyzGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->km = km;
	mnew->nits = nits;
	mnew->size = size;
	mnew->InitNoise();
	//mnew->seed = seed;
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
}

ParamDlg* Dent::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = dentCD.CreateParamDlgs(hwMtlEdit, imp, this);
// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
//attach a dlg proc to handle the swap button 
	dents_param_blk.SetUserDlgProc(new DentsDlgProc(this));

	return masterDlg;

}

BOOL Dent::SetDlgThing(ParamDlg* dlg)
{
	// PW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if (dlg == xyzGenDlg)
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}


void Dent::ReadSXPData(TCHAR *name, void *sxpdata) 
{
	DentState *state = (DentState*)sxpdata;
	if (state->version==DENT_VERS) {
		SetColor(0, ColrFromCol24(state->col1),0);
		SetColor(1, ColrFromCol24(state->col2),0);
		SetKm(state->km,0);
		SetNits(state->nits,0);
		SetSize(state->size,0);
		}
}

void Dent::Update(TimeValue t, Interval& valid) 
{		


/*	if (Param1)  //hack to fix 2.x files 
		{
		pblock->SetValue(dents_map1_on,t,mapOn[0]);
		pblock->SetValue(dents_map2_on,t,mapOn[1]);

		pblock->SetValue(dents_seed,t,seed);
		Param1 = FALSE;
		}
*/

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		xyzGen->Update(t,ivalid);
		pblock->GetValue(dents_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( dents_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( dents_strength, t, km, ivalid );
		pblock->GetValue( dents_iterations, t, nits, ivalid );
		pblock->GetValue( dents_size, t, size, ivalid );
		pblock->GetValue( dents_map1_on, t, mapOn[0], ivalid );
		pblock->GetValue( dents_map2_on, t, mapOn[1], ivalid );

//		int rseed =-9876545;
//		pblock->GetValue( dents_seed, t, rseed, ivalid );
//		if (rseed != seed)
//			{
//			seed = rseed;
//			InitNoise();
//			}
//		else seed = rseed;

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
}


void Dent:: SetColor(int i, Color c, TimeValue t) 
{
//    col[i] = c;
	col[i].r = c.r;
	col[i].g = c.g;
	col[i].b = c.b;
	pblock->SetValue( i==0?dents_color1:dents_color2, t, c);
}

void Dent::SwapInputs() 
{
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(dents_color1,0,dents_color2,0);
	dents_param_blk.InvalidateUI(dents_color1);
	dents_param_blk.InvalidateUI(dents_color2);
	dents_param_blk.InvalidateUI(dents_map1);
	dents_param_blk.InvalidateUI(dents_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
}

void Dent::SetKm(float f, TimeValue t) 
{ 
	km = f; 
	pblock->SetValue( dents_strength, t, f);
}

void Dent::SetNits(int f, TimeValue t) 
{ 
	nits = f; 
	pblock->SetValue( dents_iterations, t, f);
}

void Dent::SetSize(float f, TimeValue t) 
{ 
	size = f; 
	pblock->SetValue( dents_size, t, f);
}

RefTargetHandle Dent::GetReference(int i) 
{
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
		}
}

void Dent::SetReference(int i, RefTargetHandle rtarg) 
{
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
}

void Dent::SetSubTexmap(int i, Texmap *m) 
{
	ReplaceReference(i+2,m);
	if (i==0)
		{
		dents_param_blk.InvalidateUI(dents_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		dents_param_blk.InvalidateUI(dents_map2);
		ivalid.SetEmpty();
		}


}

TSTR Dent::GetSubTexmapSlotName(int i) 
{
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
}
	 
Animatable* Dent::SubAnim(int i) 
{
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
		}
}

TSTR Dent::SubAnimName(int i) 
{
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-2);
		}
}


RefResult Dent::NotifyRefChanged(	Interval changeInt, RefTargetHandle hTarget, 
									PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock ) 
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != xyzGen  && hTarget != pblock ) 
				dents_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
//				NotifyChanged();
				}
			else if (hTarget == xyzGen ) 
				{
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
}

#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Dent::Save(ISave *isave) 
{ 
//	ULONG nb;
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

//	isave->BeginChunk(DENT_NOISE_CHUNK);
//	isave->Write(&seed,sizeof(int),&nb);			
//	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	
	return IO_OK;
}	

//watje
class Dents2PostLoadCallback:public  PostLoadCallback
{
public:
	Dent      *s;
	int Param1;
	Dents2PostLoadCallback(Dent *r, BOOL b) {s=r;Param1 = b;}
	void proc(ILoad *iload);
};

void Dents2PostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		TimeValue t  = 0;
		s->pblock->SetValue(dents_map1_on,t,s->mapOn[0]);
		s->pblock->SetValue(dents_map2_on,t,s->mapOn[1]);
//		s->pblock->SetValue(dents_seed,t,s->seed);
		Param1 = FALSE;

		}
	Interval ivalid;
//	s->pblock->GetValue( dents_seed, 0, s->seed, ivalid );
//	s->InitNoise();

	delete this;
}

class DentPostLoad : public PostLoadCallback 
{
	public:
		Dent *chk;
		DentPostLoad(Dent *b) {chk=b;}
		void proc(ILoad *iload) {
			if (chk->vers<1) {
				if (chk->pblock) 
					{
//					ScaleFloatController(chk->pblock, PB_SIZE, 100.0f);
					chk->pblock->RescaleParam(dents_size, 0, 100.0f);
					}
//				iload->SetObsolete();
				}
			delete this;
			}
};


IOResult Dent::Load(ILoad *iload) 
{ 
//	ULONG nb;
	IOResult res;
	int id;
	vers = 0;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case DENTVERS1_CHUNK:
				vers = 1;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;

#if 0
			case DENT_NOISE_CHUNK:
				iload->Read(&seed,sizeof(int),&nb);			
//				InitNoise();
				break;
#endif
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
	
	
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	if (Param1)
		{
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &dents_param_blk, this, 1);
		iload->RegisterPostLoadCallback(plcb);
		}
	Dents2PostLoadCallback* dents2plcb = new Dents2PostLoadCallback(this,Param1);
	iload->RegisterPostLoadCallback(dents2plcb);

	return IO_OK;
}

void Dent::InitNoise()
{
//	if(!seed)
//		seed = rand()+1;
	if (!noiseInited) {
		noiseInited = 1;
		srand(65432);
		
		int i, j, k, ii, jj, kk;
	   for (i=0; i<=NOISE_DIM; i++)
	      for (j=0; j<=NOISE_DIM; j++)
		 for (k=0; k<=NOISE_DIM; k++)
		 {
		    noiseTable[i][j][k] = (float)(rand()&0x7FFF);
		    ii = (i==NOISE_DIM)?0:i; 
		    jj = (j==NOISE_DIM)?0:j; 
		    kk = (k==NOISE_DIM)?0:k; 
		    noiseTable[i][j][k] = noiseTable[ii][jj][kk];
		 }
	}
}


float Dent::DentNoise(float x, float y, float z)
{
#if 0
	Point3 p(x,y,z);
	return 0.5f*(noise3(p)+1.0f);
#else
   int ix, iy, iz;
   double fx, fy, fz, mx, my, mz;
   double n, n00, n01, n10, n11, n0, n1;
   mx = fmod((double)x, FNOISE_DIM); if (mx<0) mx += FNOISE_DIM;
   my = fmod((double)y, FNOISE_DIM); if (my<0) my += FNOISE_DIM;
   mz = fmod((double)z, FNOISE_DIM); if (mz<0) mz += FNOISE_DIM;
   ix = (int)mx;
   iy = (int)my;
   iz = (int)mz;
   fx = fmod(mx, 1.0);
   fy = fmod(my, 1.0);
   fz = fmod(mz, 1.0);
   n = noiseTable[ix][iy][iz];
   n00 = n + fx*(noiseTable[ix+1][iy][iz]-n);
   n = noiseTable[ix][iy][iz+1];
   n01 = n + fx*(noiseTable[ix+1][iy][iz+1]-n);
   n = noiseTable[ix][iy+1][iz];
   n10 = n + fx*(noiseTable[ix+1][iy+1][iz]-n);
   n = noiseTable[ix][iy+1][iz+1];
   n11 = n + fx*(noiseTable[ix+1][iy+1][iz+1]-n);
   n0 = n00 + fy*(n10-n00);
   n1 = n01 + fy*(n11-n01);
   return (float)(((n0+fz*(n1-n0)))/32768.0);
#endif   
}


void Dent::LerpColor(RGBA *c, RGBA *a, RGBA *b, float f)
{
   int alph, ialph;
   
   if (f>1.0) f = 1.0f;
   alph = (int)(4096*f);
   ialph = 4096-alph;

   c->r = (float)(((int)(ialph*a->r + alph*b->r)*255)>>12);
   c->g = (float)(((int)(ialph*a->g + alph*b->g)*255)>>12);
   c->b = (float)(((int)(ialph*a->b + alph*b->b)*255)>>12);
   
   c->r /= 255.0f;
   c->g /= 255.0f;
   c->b /= 255.0f;

}

// Smooth step function with hermite interpolation
float Dent::SmoothStep(float x0, float x1, float v)
{
   if (v<=x0) return(0.0f);
   else if (v>=x1) return(1.0f);
   else {
      float u = (v-x0)/(x1-x0);
      return(u*u*(3-2*u));
   }
}

float Dent::DentFunc(Point3 p) 
{
	double s, mag;
	int i;
   
	s = 1.0;
	mag = 0.0;
	for (i=0; i<nits; i++)
	{
		mag += fabs(.5-DentNoise(p.x, p.y, p.z))/s;
		s *= 2.0;
		p.x*=2.0f;
		p.y*=2.0f;
		p.z*=2.0f;
	}
	return((float)(mag*mag*mag*km));
	
}

static AColor black(0.0f,0.0f,0.0f,0.0f);

RGBA Dent::EvalColor(ShadeContext& sc) 
{
	Point3	p,dp;
	RGBA	c;
	if (!sc.doMaps) return black;
	if (gbufID) sc.SetGBufferID(gbufID);
	
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
	p *= DENTSIZE/size;
	float  d = DentFunc(p);
	
	if (d<=.0005) 
		return  mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
	else 
		if (d>=.9995) 
			return  mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
	RGBA c0 = mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
//	LerpColor(&c, &c0, &c1, d);
	return (1.0f-d)*c0 + d*c1;
}

Point3 Dent::EvalNormalPerturb(ShadeContext& sc) 
{
	float del,d;
	Point3 p,dp;
	
	if (!sc.doMaps) return Point3(0,0,0);

	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
	p *= DENTSIZE/size;

	d = DentFunc(p);

	del = 0.1f;
	Point3 np;
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = (DentFunc(p+del*M[0]) - d)/del;
	np.y = (DentFunc(p+del*M[1]) - d)/del;
	np.z = (DentFunc(p+del*M[2]) - d)/del;
	return sc.VectorFromNoScale(np,REF_OBJECT);
	}

//DentClassDesc
Class_ID DentClassDesc::ClassID() 
{ 
	return dentClassID; 
}
/*
// C Implementations
static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
	DentDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (DentDlg*)lParam;
		theDlg->hPanel = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (DentDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->PanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
}
*/
ClassDesc* GetDentDesc()		{ return &dentCD;  }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\marble.cpp ===
/**********************************************************************
 *<
	FILE: MARBLE.CPP

	DESCRIPTION: MARBLE 3D Texture map.

	CREATED BY: Dan Silva
				Updated to Param Block 2 12/1/98 Peter Watje
	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

#define NSUBTEX 2
#define NCOLS 2

static Class_ID marbleClassID(MARBLE_CLASS_ID,0);
//--------------------------------------------------------------
// Marble: A 3D texture map
//--------------------------------------------------------------

class Marble: public Tex3D { 
	friend class MarblePostLoad;
	static ParamDlg* xyzGenDlg;	
	Color col[NCOLS];
	XYZGen *xyzGen;		   // ref #0
	Texmap* subTex[NSUBTEX];  // More refs
	Interval ivalid;
	int rollScroll;
	int vers;
	float MarbleFunc(Point3 p);
	public:
		BOOL Param1;
		BOOL mapOn[NSUBTEX];
		float width,size;
		IParamBlock2 *pblock;   // ref #1
		Marble();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		XYZGen *GetTheXYZGen() { return xyzGen; }

		void SetColor(int i, Color c, TimeValue t);
		void SetSize(float f, TimeValue t);
		void SetWidth(float f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 

		void ReadSXPData(TCHAR *name, void *sxpdata);

	
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return xyzGen->Requirements(subMtlNum); }
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return marbleClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_MARBLE); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);


	};
ParamDlg* Marble::xyzGenDlg;	

class MarbleClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Marble; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_MARBLE_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return marbleClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_3D;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("marble"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static MarbleClassDesc marbleCD;

ClassDesc* GetMarbleDesc() { return &marbleCD;  }

//dialog stuff to get the Set Ref button
class MarbleDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
	    Marble *marble;		
		MarbleDlgProc(Marble *m) {marble = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			marble = (Marble*)m;
			}

	};



BOOL MarbleDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_MARBLE_SWAP:
					{
					marble->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}



//-----------------------------------------------------------------------------
//  Marble
//-----------------------------------------------------------------------------


#define MARBLE_VERSION 1

enum { marble_params };  // pblock ID


// marble_params param IDs
enum 
{ 
	marble_map1, marble_map2,		
	marble_color1, marble_color2,
	marble_map1_on, marble_map2_on, 
	marble_size,marble_width, 
	marble_coords	  // access for XYZ mapping
};

static ParamBlockDesc2 marble_param_blk ( marble_params, _T("parameters"),  0, &marbleCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_MARBLE, IDS_DS_MARBPARMS, 0, 0, NULL, 
	// params
	marble_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MARB_TEX1,
		end,
	marble_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MARB_TEX2,
		end,
	marble_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0.2f,0.2f,0.1f), 
		p_ui,			TYPE_COLORSWATCH, IDC_MARB_COL1, 
		end,
	marble_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.82f,0.82f,0.6f), 
		p_ui,			TYPE_COLORSWATCH, IDC_MARB_COL2, 
		end,
	marble_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	marble_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	marble_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_MARBSIZE,
		p_default,		70.f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MARBSIZE_EDIT,IDC_MARBSIZE_SPIN,  1.0f, 
		end,
	marble_width,		_T("width"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_DS_MARBWIDTH,
		p_default,		0.025f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_WIDTH_EDIT,IDC_WIDTH_SPIN, 0.02f, 
		end,
	marble_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		0, 
		end,

	end
);

static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,marble_size }, 	// size
	{ TYPE_FLOAT, NULL, TRUE,marble_width }, 	// width
	{ TYPE_RGBA, NULL, TRUE,marble_color1 },  // col1
	{ TYPE_RGBA, NULL, TRUE,marble_color2 }   // col2
	};

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,4,1),	// Version 1 params
	};

void Marble::Init() {
	if (xyzGen) xyzGen->Reset();
	else ReplaceReference( 0, GetNewDefaultXYZGen());	
	ivalid.SetEmpty();
	macroRecorder->Disable();  // don't want to see this parameter reset in macrorecorder
		SetColor(0, Color(0.2f,0.2f,0.1f), TimeValue(0));
		SetColor(1, Color(0.82f,0.82f,0.6f), TimeValue(0));
		SetWidth(.025f, TimeValue(0));
		SetSize(70.0f, TimeValue(0));
	macroRecorder->Enable();  
	}

void Marble::Reset() {
	marbleCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

void Marble::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Marble::Marble() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
	marbleCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	vers = 0;
	mapOn[0] = mapOn[1] = 1;
	}

RefTargetHandle Marble::Clone(RemapDir &remap) {
	Marble *mnew = new Marble();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(xyzGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->width = width;
	mnew->size = size;
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		mnew->mapOn[i] = mapOn[i];
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Marble::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = marbleCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	marble_param_blk.SetUserDlgProc(new MarbleDlgProc(this));
	return masterDlg;

	}


#define MARBLE_VERS 0xE001

struct Col24 {ULONG r,g,b; };

#pragma pack(1)
struct MarbleState {
	ulong version;
	float size;
	float width;
	Col24 col1,col2;
	};
#pragma pack()

static Color ColrFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
	}

void Marble::ReadSXPData(TCHAR *name, void *sxpdata) {
	MarbleState *state = (MarbleState*)sxpdata;
	if (state!=NULL && (state->version==MARBLE_VERS)) {
		SetColor(0, ColrFromCol24(state->col1),0);
		SetColor(1, ColrFromCol24(state->col2),0);
		SetWidth(state->width,0);
		SetSize(state->size,0);
		}
	}


void Marble::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( marble_map1_on, 0, mapOn[0]);
		pblock->SetValue( marble_map2_on, 0, mapOn[1]);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		xyzGen->Update(t,ivalid);
		pblock->GetValue( marble_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( marble_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( marble_width, t, width, ivalid );
		pblock->GetValue( marble_size, t, size, ivalid );
		pblock->GetValue( marble_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( marble_map2_on, t, mapOn[1], ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

BOOL Marble::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}



void Marble:: SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	pblock->SetValue( i==0?marble_color1:marble_color2, t, c);
	}

void Marble::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(marble_color1,0,marble_color2,0);
	marble_param_blk.InvalidateUI(marble_color1);
	marble_param_blk.InvalidateUI(marble_color2);
	marble_param_blk.InvalidateUI(marble_map1);
	marble_param_blk.InvalidateUI(marble_map2);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
	}

void Marble::SetWidth(float f, TimeValue t) { 
	width = f; 
	pblock->SetValue( marble_width, t, f);
	}

void Marble::SetSize(float f, TimeValue t) { 
	size = f; 
	pblock->SetValue( marble_size, t, f);
	}

RefTargetHandle Marble::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
		}
	}

void Marble::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
	}

void Marble::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2,m);

	if (i==0)
		{
		marble_param_blk.InvalidateUI(marble_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		marble_param_blk.InvalidateUI(marble_map2);
		ivalid.SetEmpty();
		}	

	}

TSTR Marble::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Marble::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
		}
	}

TSTR Marble::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-2);
		}
	}

static int nameID[] = {IDS_DS_MARBSIZE, IDS_DS_MARBWIDTH, IDS_DS_COLOR1, IDS_DS_COLOR2 };

RefResult Marble::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != xyzGen  && hTarget != pblock) 
					marble_param_blk.InvalidateUI(changing_param);
				// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}
			else if (hTarget == xyzGen) 
				{
				// NotifyChanged();  //DS this is redundant
				}
			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MARBLEVERS1_CHUNK 0x4001
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Marble::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}	
	  
//extern void ScaleFloatController(IParamBlock *pblock, int index, float s);

class MarblePostLoad : public PostLoadCallback {
	public:
		Marble *chk;
		MarblePostLoad(Marble *b) {chk=b;}
		void proc(ILoad *iload) {
			if (chk->vers<1) {
				if (chk->pblock) 
//					ScaleFloatController(chk->pblock, PB_SIZE, 100.0f);
					chk->pblock->RescaleParam(marble_size, 0, 100.0f);
//				iload->SetObsolete();
				}
			delete this;
			}
	};
/*
class Marble2PostLoad : public PostLoadCallback {
	public:
		Marble *n;
		Marble2PostLoad(Marble *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->Param1)
				{
				n->pblock->SetValue( marble_map1_on, 0, n->mapOn[0]);
				n->pblock->SetValue( marble_map2_on, 0, n->mapOn[1]);
				}
			delete this; 


			} 
	};

*/

IOResult Marble::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
	vers = 0;
	Param1 = TRUE;
//	iload->RegisterPostLoadCallback(new MarblePostLoad(this));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MARBLEVERS1_CHUNK:
				vers = 1;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &marble_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

//	iload->RegisterPostLoadCallback(new Marble2PostLoad(this));

	return IO_OK;
	}


#define WD .02f
#define FACT 500.0f
#define SZ 1.0f //50.0

float Marble::MarbleFunc(Point3 p) {
	int id;
	float d,i,r[3];
	r[0] = p.x/100.0f;	r[1] = p.y/200.0f;	r[2] = p.z/200.0f;
	d = (p.x+10000.0f)*width + 7*NOISE(r);
	id = ((int)d)%17;
	if (id<4) {
		r[0] = p.x/70.0f;	r[1] = p.y/50.0f;	r[2] = p.z/50.0f;
		i = 0.7f+0.2f*NOISE(r);
		}
	else {
		r[0] = p.x/100.0f;	r[1] = p.y/100.0f;	r[2] = p.x/100.0f;
		if (id<9 || id>=12) {
			d = (float)fabs(d- ((int)d/17.0f)*17.0f-10.5f)*0.1538462f;
			i = 0.4f + 0.3f*d + 0.2f*NOISE(r);
			}
		else 
			i = 0.2f*(1.0f + NOISE(r));
		}
	return(i);
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);

RGBA Marble::EvalColor(ShadeContext& sc) {
	Point3 p,dp;
	if (!sc.doMaps) return black;
	if (gbufID) sc.SetGBufferID(gbufID);
	
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
	p *= FACT/size;

	float d = MarbleFunc(p);

	if (d<=.0005) return  mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
	else if (d>=.9995) return  mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
	RGBA c0 = mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
	return (1.0f-d)*c0 + d*c1;
	}

Point3 Marble::EvalNormalPerturb(ShadeContext& sc) {
	float del,d;
	Point3 p,dp;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
	p *= FACT/size;

	d = MarbleFunc(p);
	del = 20.0f;
	Point3 np;

	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = (MarbleFunc(p+del*M[0]) - d)/del;
	np.y = (MarbleFunc(p+del*M[1]) - d)/del;
	np.z = (MarbleFunc(p+del*M[2]) - d)/del;

	np *= 100.0f;
	return sc.VectorFromNoScale(np,REF_OBJECT);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\falloff.cpp ===
/**********************************************************************
 *<
	FILE: FALLOFF.CPP

	DESCRIPTION: FALLOFF 3D Texture map.

	CREATED BY: Dan Silva

	HISTORY: 12/2/98 Updated to Param Block 2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

static Class_ID falloffClassID(FALLOFF_CLASS_ID,0);

#define PBLOCK_REF 0

#define FALLTYPE_VIEW 0
#define FALLTYPE_OBJ  1
#define FALLTYPE_XLOC 2
#define FALLTYPE_YLOC 3
#define FALLTYPE_ZLOC 4
#define FALLTYPE_XWOR 5
#define FALLTYPE_YWOR 6
#define FALLTYPE_ZWOR 7

//--------------------------------------------------------------
// Falloff: A 3D texture map
//--------------------------------------------------------------

class Falloff: public Texmap { 
	float nearVal;
	float farVal;
	Interval ivalid;
	int rollScroll;
	Point3 nodePos;
	BOOL gotPos;
	BOOL inRender;
	CRITICAL_SECTION csect;
	public:

		BOOL Param1;

		TSTR nodeName;
		INode *vNode;
		int fallDir;
		BOOL frontBack; // vs parallel/perpendicular
		IParamBlock2 *pblock;   // ref #1
		Falloff();
		~Falloff() {DeleteCriticalSection(&csect);}
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void NotifyChanged();
		void EnableStuff();

		void SetNear(float f, TimeValue t); 
		void SetFar(float f, TimeValue t); 
		void SwapValues();
			
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);
	    float EvalMono(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		int RenderBegin(TimeValue t, ULONG flags); 
		int RenderEnd(TimeValue t) { inRender = FALSE;  return 1; }
		int LoadMapFiles(TimeValue t) { gotPos = FALSE; return 1; }

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return 0; }

		// Methods to access texture maps of material
		int NumSubTexmaps() { return 0; }
		Texmap* GetSubTexmap(int i) { assert(0); return NULL; }
		void SetSubTexmap(int i, Texmap *m) {}
		TSTR GetSubTexmapSlotName(int i) { return TSTR(""); }

		Class_ID ClassID() {	return falloffClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_FALLOFF); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};

class FalloffClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return FALSE; }
	void *			Create(BOOL loading) { 	return new Falloff; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_FALLOFF_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return falloffClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_3D;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("falloff"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static FalloffClassDesc falloffCD;

ClassDesc* GetFalloffDesc() { return &falloffCD;  }


// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { falloff_params, };  // pblock ID
// falloff_params param IDs
enum 
{ 
	falloff_perp, falloff_parallel,
	falloff_type, falloff_dir,
	falloff_node
};
static ParamBlockDesc2 falloff_param_blk ( falloff_params, _T("parameters"),  0, &falloffCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_FALLOFF, IDS_DS_FALLOFFPARAMS, 0, 0, NULL, 
	// params
	falloff_perp,	_T("perpendicularValue"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PERVAL,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_FALL_NEAR, IDC_FALL_NEAR_SPIN, 0.01f,
		end,
	falloff_parallel,	_T("parallelValue"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PARVAL,
		p_default,		1.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_FALL_FAR, IDC_FALL_FAR_SPIN, 0.01f,
		end,

	falloff_type, _T("type"), TYPE_INT,				0,				IDS_JW_FALLOFFTYPE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_FALL_PP, IDC_FALL_FB,
		end,
	falloff_dir, _T("direction"), TYPE_INT,				0,				IDS_PW_DIRECTION,
		p_default,		0,
		p_range,		0,	7,
		p_ui,			TYPE_RADIO, 8, IDC_FALLDIR_VIEW, IDC_FALLDIR_OBJ,
									   IDC_FALLDIR_X, IDC_FALLDIR_Y, IDC_FALLDIR_Z,
									   IDC_FALLDIR_XW, IDC_FALLDIR_YW,IDC_FALLDIR_ZW,
		end,
	falloff_node, 		_T("node"), 		TYPE_INODE, 	0,		IDS_PW_NODE,
		p_ui, 			TYPE_PICKNODEBUTTON, IDC_FALLOFF_PICK, 
		end, 

	end
);


//dialog stuff to get the Set Ref button
class FalloffDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Falloff *falloff;		
		FalloffDlgProc(Falloff *m) {falloff = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};



BOOL FalloffDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{

	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_FALL_SWAP:
					{
					falloff = (Falloff*)map->GetParamBlock()->GetOwner(); 
					falloff->SwapValues();
					}
				}
			break;
		}
	return FALSE;
	}


//-----------------------------------------------------------------------------
//  Falloff
//-----------------------------------------------------------------------------

#define FALLOFF_VERSION 1


static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,falloff_perp }, 	// nearVal
	{ TYPE_FLOAT, NULL, TRUE,falloff_parallel } 	// farVal
	};

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,2,1),	// Version 1 params
	};


void Falloff::Init() {
	ivalid.SetEmpty();
	SetNear(0.0f, TimeValue(0));
	SetFar(1.0f, TimeValue(0));
	fallDir = FALLTYPE_VIEW;
	frontBack = 0;
	}

void Falloff::Reset() {
	falloffCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

void Falloff::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Falloff::Falloff() {
	Param1 = FALSE;
	InitializeCriticalSection(&csect);
	pblock = NULL;
	vNode = NULL;
	inRender = FALSE;
	gotPos = FALSE;
	falloffCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

void Falloff::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		pblock->GetValue( falloff_type, 0, frontBack, FOREVER );
		if (map) {
			HWND hw = map->GetHWnd();
			if (frontBack) {
				SetDlgItemText(hw, IDC_FALL_NEARNAME, GetString(IDS_DS_BVAL));
				SetDlgItemText(hw, IDC_FALL_FARNAME, GetString(IDS_DS_FVAL));
				}
			else {
				SetDlgItemText(hw, IDC_FALL_NEARNAME, GetString(IDS_DS_PERVAL));
				SetDlgItemText(hw, IDC_FALL_FARNAME, GetString(IDS_DS_PARVAL));
				}
			}
		}
	}

RefTargetHandle Falloff::Clone(RemapDir &remap) {
	Falloff *mnew = new Falloff();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->nearVal = nearVal;
	mnew->farVal = farVal;
	mnew->fallDir = fallDir;
	mnew->frontBack = frontBack;
	mnew->ivalid.SetEmpty();	
	return (RefTargetHandle)mnew;
	}

ParamDlg* Falloff::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	IAutoMParamDlg* masterDlg = falloffCD.CreateParamDlgs(hwMtlEdit, imp, this);
//attach a dlg proc to handle the swap button 
	falloff_param_blk.SetUserDlgProc(new FalloffDlgProc(this));
	EnableStuff();
	return masterDlg;

	}

void Falloff::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( falloff_dir, 0, fallDir);
		pblock->SetValue( falloff_type, 0, frontBack);

		Interface *iface = GetCOREInterface();
		vNode = iface->GetINodeByName(nodeName);
		if (vNode != NULL)
			pblock->SetValue( falloff_node, 0, vNode);
		Param1 = FALSE;
		}


	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( falloff_perp, t, nearVal, ivalid );
		pblock->GetValue( falloff_parallel, t, farVal, ivalid );
		pblock->GetValue( falloff_type, t, frontBack, ivalid );
		pblock->GetValue( falloff_dir, t, fallDir, ivalid );
		pblock->GetValue( falloff_node, t, vNode, ivalid );

		EnableStuff();

		}
	valid &= ivalid;
	}


int Falloff::RenderBegin(TimeValue t, ULONG flags)  {
	inRender = TRUE;
	if (fallDir == FALLTYPE_OBJ&&nodeName.Length()) {
		Interface *iface = GetCOREInterface();
		vNode = iface->GetINodeByName(nodeName);
		}
	return 1;
	}

void Falloff::SetNear(float f, TimeValue t) { 
	nearVal = f; 
	pblock->SetValue( falloff_perp, t, f);
	}

void Falloff::SetFar(float f, TimeValue t) { 
	farVal = f; 
	pblock->SetValue( falloff_parallel, t, f);
	}

void Falloff::SwapValues() {
	pblock->SwapControllers(falloff_perp,0,falloff_parallel,0);
	falloff_param_blk.InvalidateUI(falloff_perp);
	falloff_param_blk.InvalidateUI(falloff_parallel);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("perpendicularValue"), mr_reftarg, this, mr_prop, _T("parallelValue"), mr_reftarg, this);
	}

RefTargetHandle Falloff::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		default: assert(0); return NULL; 
		}
	}

void Falloff::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		default: assert(0); break;
		}
	}
	 
Animatable* Falloff::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: assert(0); return NULL;
		}
	}

TSTR Falloff::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: assert(0); return TSTR(_T("null"));
		}
	}

static int ta_nameID[] = {IDS_DS_BVAL, IDS_DS_FVAL };
static int pp_nameID[] = {IDS_DS_PERVAL, IDS_DS_PARVAL };

RefResult Falloff::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				falloff_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}
			else 
				{
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define FALLOFF_TYPE_CHUNK 0x2000
#define NODE_NAME_CHUNK 0x2010
#define FRONTBACK_CHUNK 0x2020
#define PARAM2_CHUNK 0x2030

IOResult Falloff::Save(ISave *isave) { 
	IOResult res;
//	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	isave->EndChunk();
	if (res!=IO_OK) return res;

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();


	return IO_OK;
	}	
	  
class FalloffPostLoad : public PostLoadCallback {
	public:
		Falloff *n;
		BOOL Param1;
		FalloffPostLoad(Falloff *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( falloff_dir, 0, n->fallDir);
				n->pblock->SetValue( falloff_type, 0, n->frontBack);

				Interface *iface = GetCOREInterface();
				n->vNode = iface->GetINodeByName(n->nodeName);
				if (n->vNode != NULL)
					n->pblock->SetValue( falloff_node, 0, n->vNode);

				}

			delete this; 


			} 
	};

IOResult Falloff::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	int id;
	Param1 = TRUE;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case FALLOFF_TYPE_CHUNK:
				res = iload->Read(&fallDir,sizeof(fallDir), &nb);
				break;
			case FRONTBACK_CHUNK:
				frontBack = 1;
				break;
			case NODE_NAME_CHUNK:
				{
				TCHAR *buf;
				if (IO_OK==iload->ReadWStringChunk(&buf)) 
					nodeName = buf;
				break;
				}
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &falloff_param_blk, this, PBLOCK_REF);
	iload->RegisterPostLoadCallback(plcb);

//	iload->RegisterPostLoadCallback(new FalloffPostLoad(this,Param1));

	return IO_OK;
	}

static RGBA black(0.0f,0.0f,0.0f,1.0f);
static RGBA white(1.0f,1.0f,1.0f,1.0f);

RGBA Falloff::EvalColor(ShadeContext& sc) {
	RGBA c;
	c.r = EvalMono(sc);
	c.g = c.b = c.r;
	c.a = 1.0f;
	return c;
	}

float Falloff::EvalMono(ShadeContext& sc) {
	float d;
	Point3 n;
	if (!sc.doMaps) return 0.0f;
	if (gbufID) sc.SetGBufferID(gbufID);
	switch (fallDir) {
		case FALLTYPE_VIEW:
			d = -DotProd(sc.Normal(), sc.V());
			break;
		case FALLTYPE_OBJ:
			if (sc.InMtlEditor()) {
				d = sc.Normal().x;
				}
			else {
				if (!gotPos) {
					EnterCriticalSection(&csect);
					if (!gotPos) {
						if (vNode) {
							Matrix3 tm= vNode->GetNodeTM(sc.CurTime());
							nodePos = sc.PointFrom(tm.GetTrans(),REF_WORLD);
							}		
						gotPos = TRUE;
						}
					LeaveCriticalSection(&csect);
					}
				Point3 v = FNormalize(nodePos - sc.P());
				d = DotProd(sc.Normal(), v);
				}
			break;
		case FALLTYPE_XLOC:
		   n = sc.VectorTo(sc.Normal(), REF_OBJECT);
		   d = n.x;
		   break;
		case FALLTYPE_YLOC:
		   n = sc.VectorTo(sc.Normal(), REF_OBJECT);
		   d = n.y;
		   break;
		case FALLTYPE_ZLOC:
		   n = sc.VectorTo(sc.Normal(), REF_OBJECT);
		   d = n.z;
		   break;
		case FALLTYPE_XWOR:
		   n = sc.VectorTo(sc.Normal(), REF_WORLD);
		   d = n.x;
		   break;
		case FALLTYPE_YWOR:
		   n = sc.VectorTo(sc.Normal(), REF_WORLD);
		   d = n.y;
		   break;
		case FALLTYPE_ZWOR:
		   n = sc.VectorTo(sc.Normal(), REF_WORLD);
		   d = n.z;
		   break;
		}
	d = frontBack? 0.5f*(d+1.0f) : (float)fabs(d);
	return d*farVal + (1.0f-d)*nearVal;
	}	

Point3 Falloff::EvalNormalPerturb(ShadeContext& sc) {
	return Point3(0,0,0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mixmat.cpp ===
/**********************************************************************
 *<
	FILE: mixmat.cpp

	DESCRIPTION:  A blend of two materials

	CREATED BY: Rolf Berteig

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

static Class_ID mixmatClassID(MIXMAT_CLASS_ID,0);

#define NSUBMTL 2
class MixMat;

#define PB_REF		0
#define SUB1_REF	1
#define SUB2_REF	2
#define MAP_REF		3

class MixMatDlgProc;


class MixMat : public Mtl {	
	public:
		IParamBlock2 *pblock; 	// ref #0
		Mtl *sub1, *sub2;		// ref #1, 2		
		Texmap *map;			// ref #3
		BOOL mapOn[3];
		float u, crvA, crvB;
		BOOL useCurve;		
		Interval ivalid;
		BOOL Param1;

		static MixMatDlgProc *paramDlg;

		MixMat(BOOL loading);
		void NotifyChanged() {NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
		Mtl *UseMtl();
		float mixCurve(float x);

		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}				
		
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);
				
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void EnableStuff();
		
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		
		Class_ID ClassID() {return mixmatClassID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_RB_BLENDMAT);}  

		void DeleteThis() {delete this;}	

		// Methods to access sub-materials of meta-materials
	   	int NumSubMtls() {return 2;}
		Mtl* GetSubMtl(int i) {return i?sub2:sub1;}
		void SetSubMtl(int i, Mtl *m);

		TSTR GetSubMtlSlotName(int i) {return i?GetString(IDS_RB_MATERIALTWO):GetString(IDS_RB_MATERIALONE);}

		// Methods to access sub texture maps of material or texmap
		int NumSubTexmaps() {return 1;}
		Texmap* GetSubTexmap(int i) {return map;}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i) {return GetString(IDS_RB_MASK);}
		TSTR GetSubTexmapTVName(int i) {return GetString(IDS_RB_MASK);}

		int NumSubs() {return 4;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// From ref
 		int NumRefs() {return 4;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		// IO
		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload); 

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

	};

MixMatDlgProc* MixMat::paramDlg;



class MixMatClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new MixMat(loading);}
	const TCHAR *	ClassName() {return GetString(IDS_RB_BLENDMAT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return MATERIAL_CLASS_ID;}
	Class_ID 		ClassID() {return mixmatClassID;}
	const TCHAR* 	Category() {return _T("");}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Blend"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};
static MixMatClassDesc mixmatCD;
ClassDesc* GetMixMatDesc() {return &mixmatCD;}


enum { mixmat_params };  // pblock ID
// mixmat_params param IDs


enum 
{ 
	mixmat_mix, mixmat_curvea, mixmat_curveb, mixmat_usecurve, mixmat_usemat,
	mixmat_map1, mixmat_map2, mixmat_mask,		
	mixmat_map1_on, mixmat_map2_on,  mixmat_mask_on // main grad params 
};


//JBW: here is the new ParamBlock2 descriptor. There is only one block for Gradients, a per-instance block.
// for the moment, some of the parameters a Tab<>s to test the Tab system.  Aslo note that all the References kept
// kept in a Gradient are mapped here, marked as P_OWNERS_REF so that the paramblock accesses and maintains them
// as references on owning Gradient.  You need to specify the refno for these owner referencetarget parameters.
// I even went so far as to expose the UVW mapping and Texture Output sub-objects this way so that they can be
// seen by the scripter and the schema-viewer

// per instance gradient block

static ParamBlockDesc2 mixmat_param_blk ( mixmat_params, _T("parameters"),  0, &mixmatCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PB_REF, 
	//rollout
	IDD_MIXMAT, IDS_DS_BLEND_PARAMS, 0, 0, NULL, 
	// params
	mixmat_mix, _T("mixAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE,	IDS_PW_MIXAMOUNT,
		p_default,		0.0f,
		p_range,		0.0f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIXMAT_MIX, IDC_MIXMAT_MIXSPIN, 0.1f, 
		end,
	mixmat_curvea, _T("lower"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_LOWER,
		p_default,		0.25f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIXA_EDIT, IDC_MIXA_SPIN, 0.01f, 
		end,
	mixmat_curveb, _T("upper"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_UPPER,
		p_default,		0.75f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIXB_EDIT, IDC_MIXB_SPIN, 0.01f, 
		end,
	mixmat_usecurve,	_T("useCurve"), TYPE_BOOL,			0,				IDS_PW_USECURVE,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MIX_USECURVE,
		end,
	mixmat_usemat, _T("interactive"), TYPE_INT,		0,				IDS_PW_INTERACTIVE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_MIXMAT_USE1, IDC_MIXMAT_USE2,
		end,
	mixmat_map1,		_T("map1"),		TYPE_MTL,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		SUB1_REF,
		p_submtlno,		0,		
		p_ui,			TYPE_MTLBUTTON, IDC_MIXMAT_MAT1,
		end,
	mixmat_map2,		_T("map2"),		TYPE_MTL,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		SUB2_REF,
		p_submtlno,		1,		
		p_ui,			TYPE_MTLBUTTON, IDC_MIXMAT_MAT2,
		end,
	mixmat_mask,		_T("mask"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_DS_MASK,
		p_refno,		MAP_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MIXMAT_MAP,
		end,
	mixmat_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	mixmat_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	mixmat_mask_on,	_T("maskEnabled"), TYPE_BOOL,			0,				IDS_PW_MASKENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON3,
		end,

	end
);




//dialog stuff to get the Set Ref button
class MixMatDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		MixMat *mixmat;		
		BOOL valid;
		HWND hPanel; 
		MixMatDlgProc(MixMat *m) {
			mixmat = m;
			valid   = FALSE;
			}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}

	};


static void DrawCurve (HWND hWnd,HDC hdc, MixMat *mixmat) {

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_MIXCURVE),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	SelectObject(hdc,GetStockObject(BLACK_PEN));
	MoveToEx(hdc,rect.left+1, rect.bottom-1,NULL); 
	float fx,fy;
	int ix,iy;
	float w = (float)rect.w()-2;
	float h = (float)rect.h()-2;
	for (ix =0; ix<w; ix++) {
		fx = (float(ix)+0.5f)/w;
		fy = mixmat->mixCurve(fx);
		iy = int(h*fy+0.5f);
		LineTo(hdc, rect.left+1+ix, rect.bottom-1-iy);
		}
	WhiteRect3D(hdc,orect,TRUE);

}


BOOL MixMatDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	Rect rect;
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
	mixmat = (MixMat*)map->GetParamBlock()->GetOwner(); 
	switch (msg) {
		case WM_PAINT: {
//			em->EnableAffectRegion (t);
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			DrawCurve(hWnd,hdc,mixmat);
			EndPaint(hWnd,&ps);
			return FALSE;
			}

		case WM_COMMAND:  
		    switch (id) {
				case IDC_MIXMAT_MAP:
					mixmat->EnableStuff(); 
					break;
				}
			break;							
		case CC_SPINNER_CHANGE:
			mixmat->Update(GetCOREInterface()->GetTime(),FOREVER);
			GetClientRectP(GetDlgItem(hWnd,IDC_MIXCURVE),&rect);
			InvalidateRect(hWnd,&rect,FALSE);
			return FALSE;
			break;

		default:
			return FALSE;
		}
	return FALSE;
	}



//--- Blend Material -------------------------------------------------


static ParamBlockDesc pbdesc[] = {
	{TYPE_FLOAT, NULL, TRUE },	// Mix Amount
	{TYPE_FLOAT, NULL, TRUE },	// Curve A	
	{TYPE_FLOAT, NULL, TRUE },  // Curve B
	{TYPE_INT, NULL, FALSE },	// Use curve
	{TYPE_INT, NULL, FALSE }};  // Use mat
#define PBLOCK_LENGTH	5



static ParamBlockDescID pbdesc1[] = {
	{TYPE_FLOAT, NULL, TRUE ,mixmat_mix},	// Mix Amount
	{TYPE_FLOAT, NULL, TRUE ,mixmat_curvea},	// Curve A	
	{TYPE_FLOAT, NULL, TRUE ,mixmat_curveb},  // Curve B
	{TYPE_INT, NULL, FALSE,mixmat_usecurve },	// Use curve
	{TYPE_INT, NULL, FALSE,mixmat_usemat }};  // Use mat

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc1,5,0),	// Version 1 params
	};
#define NUM_OLDVERSIONS	1


MixMat::MixMat(BOOL loading)
	{	
	Param1 = FALSE;
	pblock = NULL;
	sub1 = sub2 = NULL;	
	map = NULL;
	ivalid.SetEmpty();
	for (int i=0; i<3; i++) 
		mapOn[i] = 1;
	if (!loading) {
		mixmatCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
		Init();
		}
	}

void MixMat::Init()
	{
	mixmatCD.Reset(this, TRUE);	// reset all pb2's
	pblock->SetValue(mixmat_curveb,0,0.75f);	
	ReplaceReference(SUB1_REF,NewDefaultStdMat());
	ReplaceReference(SUB2_REF,NewDefaultStdMat());
	GetCOREInterface()->AssignNewName(sub1);
	GetCOREInterface()->AssignNewName(sub2);
	}

void MixMat::Reset()
	{
	mixmatCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	DeleteReference(MAP_REF);
	}

Mtl *MixMat::UseMtl() 
	{
	int m;
	pblock->GetValue(mixmat_usemat,0,m,FOREVER);
	if (m==0 && sub1) return sub1;
	if (m==1 && sub2) return sub2;
	return sub1?sub1:sub2;
	}

Color MixMat::GetAmbient(int mtlNum, BOOL backFace) { 
	return UseMtl()?UseMtl()->GetAmbient(mtlNum,backFace):Color(0,0,0);
	}		
Color MixMat::GetDiffuse(int mtlNum, BOOL backFace){ 
	return UseMtl()?UseMtl()->GetDiffuse(mtlNum,backFace):Color(0,0,0);
	}				
Color MixMat::GetSpecular(int mtlNum, BOOL backFace){
	return UseMtl()?UseMtl()->GetSpecular(mtlNum,backFace):Color(0,0,0);
	}		
float MixMat::GetXParency(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}
float MixMat::GetShininess(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}		
float MixMat::GetShinStr(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->GetXParency(mtlNum,backFace):0.0f;
	}

float MixMat::WireSize(int mtlNum, BOOL backFace) {
	return UseMtl()?UseMtl()->WireSize(mtlNum,backFace):0.0f;
	}

void MixMat::EnableStuff() {
	if (pblock) {
		IParamMap2 *pmap = pblock->GetMap();
		if (pmap) {
			Texmap *mp = mapOn[2]?map:NULL;
			pmap->Enable(mixmat_mix, mp? FALSE: TRUE);
			pmap->Enable(mixmat_usecurve, mp?TRUE:FALSE);
			}
		}
	} 
		
ParamDlg* MixMat::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  

	// create the rollout dialogs
	IAutoMParamDlg* masterDlg = mixmatCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	paramDlg = new MixMatDlgProc(this);
	mixmat_param_blk.SetUserDlgProc(paramDlg);
	EnableStuff();
	Update(imp->GetTime(), FOREVER);
	return masterDlg;


	}

BOOL MixMat::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
//	paramDlg->mixmat = this;
	return FALSE;

}


void MixMat::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(MAP_REF,m);
	mixmat_param_blk.InvalidateUI(mixmat_mask);
	ivalid.SetEmpty();
	}

void MixMat::SetSubMtl(int i, Mtl *m)
{
	ReplaceReference(i+1,m);
	if (i==0)
		{
		mixmat_param_blk.InvalidateUI(mixmat_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		mixmat_param_blk.InvalidateUI(mixmat_map2);
		ivalid.SetEmpty();
		}	

}



float MixMat::mixCurve(float x) 
	{
	if (x<crvA)  return 0.0f;
	if (x>=crvB) return 1.0f;
	x = (x-crvA)/(crvB-crvA);
	return (x*x*(3-2*x));
	}

static Color black(0,0,0);

void MixMat::Shade(ShadeContext& sc) {
	Mtl *sm1 = mapOn[0]?sub1:NULL;
	Mtl *sm2 = mapOn[1]?sub2:NULL;
	Texmap *mp = mapOn[2]?map:NULL;

	if (gbufID) sc.SetGBufferID(gbufID);
	float mix = mp ? mp->EvalMono(sc) : u;
	if (mp && useCurve) mix = mixCurve(mix);
	if (mix<0.0001f) {
		if (sm1) sm1->Shade(sc);
	} else
	if (mix>0.9999f) {
		if (sm2) sm2->Shade(sc);
	} else {
		if (sm1) {
			sm1->Shade(sc);
			if(sm2) {
				ShadeOutput out1 = sc.out;
				sc.ResetOutput();
				sm2->Shade(sc);
				sc.out.MixIn(out1,mix);
				}
			}
		else {
			if (sm2) 
				sm2->Shade(sc);
			}
		}
	}

void MixMat::Update(TimeValue t, Interval& valid)
	{	

	if (Param1)
		{
		pblock->SetValue( mixmat_map1_on, 0, mapOn[0]);
		pblock->SetValue( mixmat_map2_on, 0, mapOn[1]);
		pblock->SetValue( mixmat_mask_on, 0, mapOn[2]);
		Param1 = FALSE;
		}

	ivalid = FOREVER;
	if (sub1) sub1->Update(t,valid);
	if (sub2) sub2->Update(t,valid);
	if (map) map->Update(t,valid);
	pblock->GetValue(mixmat_mix,t,u,ivalid);
	pblock->GetValue(mixmat_curvea,t,crvA,ivalid);
	pblock->GetValue(mixmat_curveb,t,crvB,ivalid);
	pblock->GetValue(mixmat_usecurve,t,useCurve,ivalid);
	pblock->GetValue(mixmat_map1_on,t,mapOn[0],ivalid);
	pblock->GetValue(mixmat_map2_on,t,mapOn[1],ivalid);
	pblock->GetValue(mixmat_mask_on,t,mapOn[2],ivalid);
	EnableStuff();
	valid &= ivalid;
	}

Interval MixMat::Validity(TimeValue t)
	{
	Interval valid = FOREVER;		
	if (sub1) valid &= sub1->Validity(t);
	if (sub2) valid &= sub2->Validity(t);
	if (map) valid &= map->Validity(t);
	pblock->GetValue(mixmat_mix,t,u,valid);
	pblock->GetValue(mixmat_curvea,t,crvA,valid);
	pblock->GetValue(mixmat_curveb,t,crvB,valid);
	return valid;
	}

Animatable* MixMat::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return sub1;
		case 2: return sub2;
		case 3: return map;
		default: return NULL;
		}
	}

TSTR MixMat::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_DS_PARAMETERS);
		case 1: return GetString(IDS_RB_MATERIALONE);
		case 2: return GetString(IDS_RB_MATERIALTWO);
		case 3: return GetString(IDS_RB_MASK);
		default: return _T("");
		}
	}

RefTargetHandle MixMat::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return sub1;
		case 2: return sub2;
		case 3: return map;
		default: return NULL;
		}
	}

void MixMat::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		case 1: sub1 = (Mtl*)rtarg; break;
		case 2: sub2 = (Mtl*)rtarg; break;
		case 3: map = (Texmap*)rtarg; break;
		}
	}

RefTargetHandle MixMat::Clone(RemapDir &remap)
	{
	MixMat *mtl = new MixMat(FALSE);
	*((MtlBase*)mtl) = *((MtlBase*)this);  // copy superclass stuff
	mtl->ReplaceReference(PB_REF,remap.CloneRef(pblock));
	if (sub1) mtl->ReplaceReference(SUB1_REF,remap.CloneRef(sub1));
	if (sub2) mtl->ReplaceReference(SUB2_REF,remap.CloneRef(sub2));
	if (map) mtl->ReplaceReference(MAP_REF,remap.CloneRef(map));
	for (int i=0; i<3; i++)
		mtl->mapOn[i] = mapOn[i];
	return mtl;
	}

RefResult MixMat::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				mixmat_param_blk.InvalidateUI(changing_param);
				// NotifyChanged();  //DS this is redundant
				}

//			if (hTarget==pblock) ivalid.SetEmpty();
			break;
		}
	return REF_SUCCEED;
	}


//
// Note: ALL Materials and texmaps must have a Save and Load to save and load
// the MtlBase info.
#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult MixMat::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
/*
	for (int i=0; i<3; i++) {
		if (mapOn[i]==0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
			}
		}
*/
	return IO_OK;
	}	
	  

class MixMatPostLoad : public PostLoadCallback {
	public:
		MixMat *n;
		MixMatPostLoad(MixMat *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->Param1)
				{
				n->pblock->SetValue( mixmat_map1_on, 0, n->mapOn[0]);
				n->pblock->SetValue( mixmat_map2_on, 0, n->mapOn[1]);
				n->pblock->SetValue( mixmat_mask_on, 0, n->mapOn[2]);
				}

			delete this; 

			} 
	};



IOResult MixMat::Load(ILoad *iload) { 
//	ULONG nb;
	int id;
	IOResult res;
	Param1 =TRUE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
			case MAPOFF_CHUNK+2:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &mixmat_param_blk, this, PB_REF);
	iload->RegisterPostLoadCallback(plcb);
//	iload->RegisterPostLoadCallback(new MixMatPostLoad(this));

	return IO_OK;
	}


float MixMat::EvalDisplacement(ShadeContext& sc) {
	Mtl *sm1 = mapOn[0]?sub1:NULL;
	Mtl *sm2 = mapOn[1]?sub2:NULL;
	Texmap *mp = mapOn[2]?map:NULL;
	
	float mix = mp ? mp->EvalMono(sc) : u;
	if (mp && useCurve) mix = mixCurve(mix);
	if (mix<0.0001f) {
		return (sm1)?sm1->EvalDisplacement(sc):0.0f;
	} else
	if (mix>0.9999f) {
		return (sm2)?sm2->EvalDisplacement(sc):0.0f;
	} else {
		if (sm1) {
			float d = sm1->EvalDisplacement(sc);
			if(sm2) {
				float d2 = sm2->EvalDisplacement(sc);
				d = (1.0f-mix)*d + mix*d2;
				}
			return d;
			}
		else {
			if (sm2) 
				return sm2->EvalDisplacement(sc);
			}
		}
	return 0.0f;
	}

Interval MixMat::DisplacementValidity(TimeValue t) {
	Mtl *sm1 = mapOn[0]?sub1:NULL;
	Mtl *sm2 = mapOn[1]?sub2:NULL;
	Texmap *mp = mapOn[2]?map:NULL;
	Interval iv;
	iv.SetInfinite();
	if (sm1) 	
		iv &= sm1->DisplacementValidity(t);		
	if (sm2) 	
		iv &= sm2->DisplacementValidity(t);		
	if (mp) { 	
		Interval ivm;
		ivm.SetInfinite();
		mp->Update(t,ivm);
		iv &= ivm;
		}
	return iv;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mask.cpp ===
/**********************************************************************
 *<
	FILE: MASK.CPP

	DESCRIPTION: MASK Composite.

	CREATED BY: Dan Silva

	HISTORY:12/2/98 Updated to Param Block 2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"

extern HINSTANCE hInstance;
#include "iparamm2.h"



#define NSUBTEX 2    // number of texture map slots

static Class_ID maskClassID(MASK_CLASS_ID,0);

static int subTexId[NSUBTEX] = { IDC_MASK_MAP, IDC_MASK_MASK };

//--------------------------------------------------------------
// Mask: A Composite texture map
//--------------------------------------------------------------
class Mask: public Texmap { 
	Texmap* subTex[NSUBTEX];  // refs
	Interval ivalid;
	BOOL rollScroll;
	public:
		BOOL Param1;
		Mask();
		BOOL mapOn[NSUBTEX];
		BOOL invertMask;

		IParamBlock2 *pblock;   // ref #2
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void NotifyChanged();

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return maskClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_MASK); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return NSUBTEX+1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return NSUBTEX+1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};

class MaskClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Mask; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_MASK_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return maskClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COMP;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("maskTex"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static MaskClassDesc maskCD;

ClassDesc* GetMaskDesc() { return &maskCD;  }

enum { mask_params, };  // pblock ID
// mask_params param IDs
enum 
{ 
	mask_map1, mask_map2,		
	mask_map1_on, mask_map2_on, // main grad params 
	mask_invert
};

// per instance gradient block
static ParamBlockDesc2 mask_param_blk ( mask_params, _T("parameters"),  0, &maskCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 2, 
	//rollout
	IDD_MASK, IDS_MASKPARMS, 0, 0, NULL, 
	// params
	mask_map1,		_T("map"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_DS_MAP,
		p_refno,		0,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MASK_MAP,
		end,
	mask_map2,		_T("mask"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_DS_MASK,
		p_refno,		1,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MASK_MASK,
		end,
	mask_map1_on,	_T("mapEnabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	mask_map2_on,	_T("maskEnabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	mask_invert,	_T("maskInverted"), TYPE_BOOL,			0,				IDS_PW_INVERT,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_INVERT_MASK,
		end,
	end
);


//-----------------------------------------------------------------------------
//  Mask
//-----------------------------------------------------------------------------


void Mask::Init() {
	ivalid.SetEmpty();
	invertMask = 0;
	}

void Mask::Reset() {
	for (int i=0; i<NSUBTEX; i++) {
		DeleteReference(i);	// get rid of maps
		mapOn[i] = 1;
		}
	maskCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

void Mask::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Mask::Mask() {
	Param1 = FALSE;
	mapOn[0] = mapOn[1] = 1;
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	pblock = NULL;
	maskCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}


static AColor white(1.0f,1.0f,1.0f,1.0f);

AColor Mask::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	float m = subTex[1]&&mapOn[1]? subTex[1]->EvalMono(sc): 1.0f;
	if (invertMask) m = 1.0f-m;
	AColor c0 = subTex[0]&&mapOn[0]? subTex[0]->EvalColor(sc): white;
	if(m==1.0f)   
		return c0;
	else 
		return m*c0;
	}

float Mask::EvalMono(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	float m = subTex[1]&&mapOn[1]? subTex[1]->EvalMono(sc): 1.0f;
	if (invertMask) m = 1.0f-m;
	float c0 = subTex[0]&&mapOn[0]? subTex[0]->EvalMono(sc): 1.0f;
	return m*c0;
	}

Point3 Mask::EvalNormalPerturb(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	float m = subTex[1]&&mapOn[1]? subTex[1]->EvalMono(sc): 1.0f;
	if (invertMask) m = 1.0f-m;
	Point3 p0  = subTex[0]&&mapOn[0]? subTex[0]->EvalNormalPerturb(sc): Point3(0.0f,0.0f,0.0f);
	return m*p0;
	}

RefTargetHandle Mask::Clone(RemapDir &remap) {
	Mask *mnew = new Mask();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(2,remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		mnew->invertMask = invertMask;
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Mask::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	IAutoMParamDlg* masterDlg = maskCD.CreateParamDlgs(hwMtlEdit, imp, this);
//attach a dlg proc to handle the swap button 
	// add the secondary dialogs to the master
	return masterDlg;

	}

void Mask::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( mask_map1_on, 0, mapOn[0]);
		pblock->SetValue( mask_map2_on, 0, mapOn[1]);
		pblock->SetValue( mask_invert, 0, invertMask);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {

		ivalid.SetInfinite();

		pblock->GetValue( mask_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( mask_map2_on, t, mapOn[1], ivalid);
		pblock->GetValue( mask_invert, t, invertMask, ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

RefTargetHandle Mask::GetReference(int i) {
	if (i <2 )
		return subTex[i];
	else return pblock;
	}

void Mask::SetReference(int i, RefTargetHandle rtarg) {
	if (i < 2)
		subTex[i] = (Texmap *)rtarg; 
	else pblock = (IParamBlock2 *)rtarg; 
	}

void Mask::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i,m);
	if (i==0)
		{
		mask_param_blk.InvalidateUI(mask_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		mask_param_blk.InvalidateUI(mask_map2);
		ivalid.SetEmpty();
		}	

	}

TSTR Mask::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_MAP)); 
		case 1:  return TSTR(GetString(IDS_DS_MASK)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Mask::SubAnim(int i) {
	if (i < 2)
		return subTex[i]; 
	else return pblock;
	}

TSTR Mask::SubAnimName(int i) {
	if (i< 2)
		return GetSubTexmapTVName(i);
	else return TSTR(_T(""));
	}

RefResult Mask::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			//if (paramDlg&&!paramDlg->isActive) 
				ParamID changing_param = pblock->LastNotifyParamID();
				mask_param_blk.InvalidateUI(changing_param);
				}

//			if (paramDlg) 
//					paramDlg->Invalidate();
			break;

		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define INVERT_MASK_CHUNK 0x2000
#define PARAM2_CHUNK 0x2010

IOResult Mask::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}	


//watje
class MaskPostLoadCallback:public  PostLoadCallback
{
public:
	Mask      *s;
	int loadedChecks;
	MaskPostLoadCallback(Mask *r, BOOL b) {s=r;loadedChecks = b;}
	void proc(ILoad *iload);
};

void MaskPostLoadCallback::proc(ILoad *iload)
{
	if (loadedChecks)
		{
		s->pblock->SetValue( mask_map1_on, 0, s->mapOn[0]);
		s->pblock->SetValue( mask_map2_on, 0, s->mapOn[1]);
		s->pblock->SetValue( mask_invert, 0, s->invertMask);
		}
	delete this;
}
	  

IOResult Mask::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
//	BOOL loadedChecks = FALSE;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case INVERT_MASK_CHUNK:
				invertMask = 1;
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

//	MaskPostLoadCallback* maskplcb = new MaskPostLoadCallback(this,loadedChecks);
//	iload->RegisterPostLoadCallback(maskplcb);

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mix.cpp ===
/**********************************************************************
 *<
	FILE: MIX.CPP

	DESCRIPTION: MIX Composite.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

static LRESULT CALLBACK CurveWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );


#define NSUBTEX 3    // number of texture map slots
#define NCOLS 2      // number of color swatches

static Class_ID mixClassID(MIX_CLASS_ID,0);

#define TEXOUT_REF 4

class Mix;

//--------------------------------------------------------------
// Mix: A Mix texture map
//--------------------------------------------------------------
#define PB_REF 0
#define SUB1_REF 1
#define SUB2_REF 2
#define SUB3_REF 3
#define PB_TEXOUT 4

class MixDlgProc;

class Mix: public MultiTex { 
	public:
	static ParamDlg* texoutDlg;
	static MixDlgProc *paramDlg;
	Color col[NCOLS];
	IParamBlock2 *pblock;   // ref #0
	Texmap* subTex[NSUBTEX];  // 3 More refs
	BOOL mapOn[NSUBTEX];
	TextureOutput *texout; // ref #4
	Interval ivalid;
	float mix;
	BOOL useCurve;
	float crvA;
	float crvB;
	BOOL rollScroll;
	public:
		BOOL Param1;
		Mix();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetOutputLevel(TimeValue t, float v) {texout->SetOutputLevel(t,v); }
		void SetColor(int i, Color c, TimeValue t);
		void SetMix(float f, TimeValue t);
		void SetCrvA(float f, TimeValue t);
		void SetCrvB(float f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 
		void EnableStuff();

		float mixCurve(float x);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return mixClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_MIX); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
//		BOOL loadOnChecks;
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);


	};

int numMixs = 0;
ParamDlg* Mix::texoutDlg;
MixDlgProc* Mix::paramDlg;

class MixClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Mix; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_MIX_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return mixClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COMP;  }

// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("mixTexture"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static MixClassDesc mixCD;

ClassDesc* GetMixDesc() { return &mixCD;  }
//-----------------------------------------------------------------------------
//  Mix
//-----------------------------------------------------------------------------

enum { mix_params };  // pblock ID
// grad_params param IDs


enum 
{ 
	mix_mix, mix_curvea, mix_curveb, mix_usecurve,
	mix_color1, mix_color2,
	mix_map1, mix_map2, mix_mask,		
	mix_map1_on, mix_map2_on,  mix_mask_on, // main grad params 
	mix_output
};

//JBW: here is the new ParamBlock2 descriptor. There is only one block for Gradients, a per-instance block.
// for the moment, some of the parameters a Tab<>s to test the Tab system.  Aslo note that all the References kept
// kept in a Gradient are mapped here, marked as P_OWNERS_REF so that the paramblock accesses and maintains them
// as references on owning Gradient.  You need to specify the refno for these owner referencetarget parameters.
// I even went so far as to expose the UVW mapping and Texture Output sub-objects this way so that they can be
// seen by the scripter and the schema-viewer

// per instance gradient block

static ParamBlockDesc2 mix_param_blk ( mix_params, _T("parameters"),  0, &mixCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PB_REF, 
	//rollout
	IDD_MIX, IDS_DS_MIX_PARAMS, 0, 0, NULL, 
	// params
	mix_mix, _T("mixAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE,	IDS_PW_MIXAMOUNT,
		p_default,		0.0f,
		p_range,		0.0f, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIX_EDIT, IDC_MIX_SPIN, 0.1f, 
		end,
	mix_curvea, _T("lower"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_LOWER,
		p_default,		0.25f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIXA_EDIT, IDC_MIXA_SPIN, 0.01f, 
		end,
	mix_curveb, _T("upper"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_UPPER,
		p_default,		0.75f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIXB_EDIT, IDC_MIXB_SPIN, 0.01f, 
		end,
	mix_usecurve,	_T("useCurve"), TYPE_BOOL,			0,				IDS_PW_USECURVE,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MIX_USECURVE,
		end,
	mix_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_MIX_COL1, 
		end,
	mix_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.5,0.5,0.5), 
		p_ui,			TYPE_COLORSWATCH, IDC_MIX_COL2, 
		end,
	mix_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		SUB1_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MIX_TEX1,
		end,
	mix_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		SUB2_REF,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MIX_TEX2,
		end,
	mix_mask,		_T("mask"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_DS_MASK,
		p_refno,		SUB3_REF,
		p_subtexno,		2,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MIX_TEX3,
		end,
	mix_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	mix_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	mix_mask_on,	_T("maskEnabled"), TYPE_BOOL,			0,				IDS_PW_MASKENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON3,
		end,
	mix_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_OUTPUT,
		p_refno,		PB_TEXOUT, 
		end,


	end
);

#define MIX_VERSION 2


#define NPARAMS 5

static int name_id[NPARAMS] = {IDS_DS_COLOR1, IDS_DS_COLOR2, IDS_DS_MIXAMT,
	IDS_RB_LOWER,IDS_RB_UPPER };

static ParamBlockDescID pbdesc1[] = {
	{ TYPE_RGBA, NULL, TRUE,mix_color1 },   // col1
	{ TYPE_RGBA, NULL, TRUE,mix_color2 },   // col2
	{ TYPE_FLOAT, NULL, TRUE,mix_mix} 	 // mix
	};   


static ParamBlockDescID pbdesc2[] = {
	{ TYPE_RGBA, NULL, TRUE,mix_color1 },   // col1
	{ TYPE_RGBA, NULL, TRUE,mix_color2 },   // col2
	{ TYPE_FLOAT, NULL, TRUE,mix_mix}, 	 // mix
	{ TYPE_FLOAT, NULL, TRUE,mix_curvea}, 	 // crva
	{ TYPE_FLOAT, NULL, TRUE,mix_curveb} 	 // crvb
	};   

static ParamVersionDesc versions[2] = {
	ParamVersionDesc(pbdesc1,3,1),
	ParamVersionDesc(pbdesc2,5,2),
	};


//dialog stuff to get the Set Ref button
class MixDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Mix *mix;		
		BOOL valid;
		HWND hPanel; 
		MixDlgProc(Mix *m) {
			mix = m;
			valid   = FALSE;
			}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};


static void DrawCurve (HWND hWnd,HDC hdc, Mix *mix) {

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_MIXCURVE),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	SelectObject(hdc,GetStockObject(BLACK_PEN));
	MoveToEx(hdc,rect.left+1, rect.bottom-1,NULL); 
	float fx,fy;
	int ix,iy;
	float w = (float)rect.w()-2;
	float h = (float)rect.h()-2;
	for (ix =0; ix<w; ix++) {
		fx = (float(ix)+0.5f)/w;
		fy = mix->mixCurve(fx);
		iy = int(h*fy+0.5f);
		LineTo(hdc, rect.left+1+ix, rect.bottom-1-iy);
		}
	WhiteRect3D(hdc,orect,TRUE);

}


BOOL MixDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	Rect rect;
	switch (msg) {
		case WM_PAINT: {
//			em->EnableAffectRegion (t);
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			mix = (Mix*)map->GetParamBlock()->GetOwner(); 
			DrawCurve(hWnd,hdc,mix);
			EndPaint(hWnd,&ps);
			return FALSE;
			}

		case CC_SPINNER_CHANGE:
			mix = (Mix*)map->GetParamBlock()->GetOwner(); 
			mix->Update(GetCOREInterface()->GetTime(),FOREVER);
			GetClientRectP(GetDlgItem(hWnd,IDC_MIXCURVE),&rect);
			InvalidateRect(hWnd,&rect,FALSE);
			return FALSE;
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_MIX_SWAP:
					{
					mix = (Mix*)map->GetParamBlock()->GetOwner(); 
					mix->SwapInputs();
					}
					break;
				default:
					break;
			}


		default:
			return FALSE;
		}
	return FALSE;
	}


//static ParamVersionDesc curVersion(pbdesc2,5,002);

void Mix::Init() {
	useCurve = 0;
	if (texout) texout->Reset();
	else ReplaceReference( TEXOUT_REF, GetNewDefaultTextureOutput());		
	ivalid.SetEmpty();
	SetColor(0, Color(0.0f,0.0f,0.0f), TimeValue(0));
	SetColor(1, Color(1.0f,1.0f,1.0f), TimeValue(0));
	SetMix(.0f, TimeValue(0));
	SetCrvA(.3f, TimeValue(0));
	SetCrvB(.7f, TimeValue(0));
	for (int i=0; i<NSUBTEX; i++) 
		mapOn[i] = 1;
	}

void Mix::Reset() {
	mixCD.Reset(this, TRUE);	// reset all pb2's
	for (int i=0; i<NSUBTEX; i++) {
		DeleteReference(i+1);	// get rid of maps
		}
	Init();
	}

void Mix::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Mix::Mix() {
	Param1 = FALSE;
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	texout = NULL;
	pblock = NULL;
//	paramDlg = NULL;
	crvA = crvB = mix = 0.0f;
	mixCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

float Mix::mixCurve(float x) {
	if (x<crvA)  return 0.0f;
	if (x>=crvB) return 1.0f;
	x = (x-crvA)/(crvB-crvA);
	return (x*x*(3-2*x));
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);

AColor Mix::EvalColor(ShadeContext& sc) {
	AColor c;
	if (sc.GetCache(this,c)) 
		return c; 
	if (gbufID) sc.SetGBufferID(gbufID);

	Texmap *sub[3];
	sub[0] = mapOn[0]?subTex[0]:NULL;
	sub[1] = mapOn[1]?subTex[1]:NULL;
	sub[2] = mapOn[2]?subTex[2]:NULL;
	float m = sub[2]? sub[2]->EvalMono(sc): mix;
	if (useCurve) m = mixCurve(m);
	if (m<.0001f)
		c = texout->Filter(sub[0] ? sub[0]->EvalColor(sc): col[0]);
	else if (m>0.9999f)   
		c = texout->Filter(sub[1] ? sub[1]->EvalColor(sc): col[1]);
	else {
		AColor c0  = sub[0] ? sub[0]->EvalColor(sc): col[0];
		AColor c1  = sub[1] ? sub[1]->EvalColor(sc): col[1];
		c = texout->Filter(m*c1 + (1.0f-m)*c0);
		}
	sc.PutCache(this,c); 
	return c;
	}

float Mix::EvalMono(ShadeContext& sc) {
	float f;
	if (sc.GetCache(this,f)) 
		return f; 
	if (gbufID) sc.SetGBufferID(gbufID);

	Texmap *sub[3];
	sub[0] = mapOn[0]?subTex[0]:NULL;
	sub[1] = mapOn[1]?subTex[1]:NULL;
	sub[2] = mapOn[2]?subTex[2]:NULL;
	float m = sub[2]? sub[2]->EvalMono(sc): mix;
	if (useCurve) m = mixCurve(m);
	if (m==0.0f)
	    f = texout->Filter(sub[0] ? sub[0]->EvalMono(sc): Intens(col[0]));
	else if(m==1.0f)   
		f = texout->Filter(sub[1] ? sub[1]->EvalMono(sc): Intens(col[1]));
	else {
		float c0  = sub[0] ? sub[0]->EvalMono(sc): Intens(col[0]);
		float c1  = sub[1] ? sub[1]->EvalMono(sc): Intens(col[1]);
		f = texout->Filter(m*c1 + (1.0f-m)*c0);
		}
	sc.PutCache(this,f); 
	return f;
	}

Point3 Mix::EvalNormalPerturb(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	Texmap *sub[3];
	sub[0] = mapOn[0]?subTex[0]:NULL;
	sub[1] = mapOn[1]?subTex[1]:NULL;
	sub[2] = mapOn[2]?subTex[2]:NULL;
	float m = sub[2]? sub[2]->EvalMono(sc): mix;
	if (useCurve) m = mixCurve(m);
	if (m==0.0f)
		return texout->Filter(sub[0] ? sub[0]->EvalNormalPerturb(sc): Point3(0,0,0));
	else if(m==1.0f)   
		return texout->Filter(sub[1] ? sub[1]->EvalNormalPerturb(sc): Point3(0,0,0));
	else {
		Point3 p0  = sub[0] ? sub[0]->EvalNormalPerturb(sc): Point3(0,0,0);
		Point3 p1  = sub[1] ? sub[1]->EvalNormalPerturb(sc): Point3(0,0,0);
		return texout->Filter(m*p1 + (1.0f-m)*p0);
		}
	}

RefTargetHandle Mix::Clone(RemapDir &remap) {
	Mix *mnew = new Mix();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(TEXOUT_REF,remap.CloneRef(texout));
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->mix = mix;
	mnew->crvA = crvA;
	mnew->crvB = crvB;
	mnew->useCurve = useCurve;
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+1,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

void Mix::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		if (map) {
			map->Enable(mix_mix, mapOn[2]&&subTex[2]?FALSE:TRUE);
			}
		}
	}

ParamDlg* Mix::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  
// Here you see we create the Coordinate, Gradient and Output ParamDlgs in the desired 
// order, and then add the Coordinate and Output dlgs as secondaries to the 
// Gradient master AutoMParamDlg so it will keep them up-to-date automatically

	// create the rollout dialogs
	IAutoMParamDlg* masterDlg = mixCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	paramDlg = new MixDlgProc(this);
	mix_param_blk.SetUserDlgProc(paramDlg);
	masterDlg->AddDlg(texoutDlg);

	EnableStuff();
	return masterDlg;

	}



BOOL Mix::SetDlgThing(ParamDlg* dlg)
{
	EnableStuff();
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((dlg != NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}



void Mix::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( mix_map1_on, 0, mapOn[0]);
		pblock->SetValue( mix_map2_on, 0, mapOn[1]);
		pblock->SetValue( mix_mask_on, 0, mapOn[2]);
		pblock->SetValue( mix_usecurve, 0, useCurve);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		texout->Update(t,ivalid);
		pblock->GetValue( mix_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( mix_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( mix_mix, t, mix, ivalid );
		pblock->GetValue( mix_curvea, t, crvA, ivalid );
		pblock->GetValue( mix_curveb, t, crvB, ivalid );

		pblock->GetValue(mix_usecurve,t,useCurve,ivalid);
		pblock->GetValue(mix_map1_on,t,mapOn[0],ivalid);
		pblock->GetValue(mix_map2_on,t,mapOn[1],ivalid);
		pblock->GetValue(mix_mask_on,t,mapOn[2],ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	EnableStuff();
	valid &= ivalid;
	}


void Mix::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(mix_color1,0,mix_color2,0);
	mix_param_blk.InvalidateUI(mix_color1);
	mix_param_blk.InvalidateUI(mix_color2);
	mix_param_blk.InvalidateUI(mix_map1);
	mix_param_blk.InvalidateUI(mix_map2);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);

	}

void Mix::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	pblock->SetValue( i==0?mix_color1:mix_color2, t, c);
	}

void Mix::SetMix(float f, TimeValue t) { 
	mix = f; 
	pblock->SetValue( mix_mix, t, f);
	}

void Mix::SetCrvA(float f, TimeValue t) { 
	crvA = f; 
	pblock->SetValue( mix_curvea, t, f);
	if (crvB<crvA) {
		crvB = crvA;
		pblock->SetValue( mix_curveb, t, crvB);
		}

	}

void Mix::SetCrvB(float f, TimeValue t) { 
	crvB = f; 
	pblock->SetValue( mix_curveb, t, f);
	if (crvB<crvA) {
		crvA = crvB;
		pblock->SetValue( mix_curvea, t, crvA);
		}
	}

RefTargetHandle Mix::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		case TEXOUT_REF: return texout;
		default:
			return subTex[i-1];
		}
	}

void Mix::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		case TEXOUT_REF: texout = (TextureOutput *)rtarg; break;
		default:
			subTex[i-1] = (Texmap *)rtarg; break;
		}
	}

static int submapids[3] = { mix_map1, mix_map2, mix_mask };

void Mix::SetSubTexmap(int i, Texmap *m) {
	if (i>2) 
		return;
	ReplaceReference(i+1,m);
	mix_param_blk.InvalidateUI( submapids[i] );
	ivalid.SetEmpty();
	}

TSTR Mix::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		case 2:  return TSTR(GetString(IDS_DS_MIXAMT)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Mix::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		case TEXOUT_REF: return texout;
		default: return subTex[i-1]; 
		}
	}

TSTR Mix::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));		
		case TEXOUT_REF: return TSTR(GetString(IDS_DS_OUTPUT));
		default: return GetSubTexmapTVName(i-1);
		}
	}

RefResult Mix::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
//				if ( hTarget != texout ) 
				mix_param_blk.InvalidateUI(changing_param);
				// NotifyChanged();  //DS this is redundant
				}
			if (hTarget == texout)
				{
				// NotifyChanged();  //DS this is redundant
				}


			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define USE_CURVE_CHUNK 0x6000
#define VERS2_CHUNK 0x6001
#define MAPOFF_CHUNK 0x3000
#define PARAM2_CHUNK 0x3010

IOResult Mix::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();


	return IO_OK;
	}	
	  
class MixPostLoad : public PostLoadCallback {
	public:
		Mix *tm;
		int version;
		MixPostLoad(Mix *b, int v) {tm=b;version = v;}
		void proc(ILoad *iload) {  
			if (version<2) 
				{
				tm->SetCrvA(.3f, TimeValue(0));
				tm->SetCrvB(.7f, TimeValue(0));
				}
			if (tm->Param1)
				{
				tm->pblock->SetValue( mix_map1_on, 0, tm->mapOn[0]);
				tm->pblock->SetValue( mix_map2_on, 0, tm->mapOn[1]);
				tm->pblock->SetValue( mix_mask_on, 0, tm->mapOn[2]);
				tm->pblock->SetValue( mix_usecurve, 0, tm->useCurve);

				}
			delete this; 
			} 
	};

IOResult Mix::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
	int version = 0;
	Param1 = TRUE;

//	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,1, &curVersion, this,0));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case USE_CURVE_CHUNK:
				useCurve = TRUE;
				break;
			case VERS2_CHUNK:
				version = 2;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
			case MAPOFF_CHUNK+2:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;;
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 2, &mix_param_blk, this, PB_REF);
	iload->RegisterPostLoadCallback(plcb);

//	if (version<2) 
//	iload->RegisterPostLoadCallback(new MixPostLoad(this,version));
	return IO_OK;
	}

/*
void MixDlg::DrawCurve(HDC hdc, Rect& rect) {
	HPEN blackPen = (HPEN)GetStockObject(BLACK_PEN);
	SelectPen(hdc,(HPEN)GetStockObject(BLACK_PEN));
	SelectPen(hdc,(HBRUSH)GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left, rect.top, rect.right, rect.bottom);
	MoveToEx(hdc,rect.left+1, rect.bottom-1,NULL); 
	float fx,fy;
	int ix,iy;
	float w = (float)rect.w()-2;
	float h = (float)rect.h()-2;
	for (ix =0; ix<w; ix++) {
		fx = (float(ix)+0.5f)/w;
		fy = theTex->mixCurve(fx);
		iy = int(h*fy+0.5f);
		LineTo(hdc, rect.left+1+ix, rect.bottom-1-iy);
		}
	}

void MixDlg::UpdateCurve() {
	HDC hdc = GetDC(hwCurve);
	Rect r;
	GetClientRect(hwCurve,&r);
	DrawCurve(hdc, r);
	ReleaseDC(hwCurve,hdc);
	}


BOOL MixDlg::CurveWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
	switch(msg) {
		case WM_COMMAND: 	break;
		case WM_MOUSEMOVE: 		break;
		case WM_LBUTTONUP: 	break;
		case WM_PAINT: 	
			{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				DrawCurve(hdc, rect);
				}
			EndPaint( hwnd, &ps );
			}													
			break;
		case WM_CREATE:
		case WM_DESTROY: 
			break;
    	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
	}

static LRESULT CALLBACK CurveWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
	HWND hwpar = GetParent(hwnd);
	MixDlg *theDlg = (MixDlg *)GetWindowLong(hwpar, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;
	int	res = theDlg->CurveWindowProc(hwnd,msg,wParam,lParam);
	return res;
	} 

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mirror.cpp ===
/**********************************************************************
 *<
	FILE: MIRROR.CPP

	DESCRIPTION: Flat Mirror Reflection.

	CREATED BY: Dan Silva

	HISTORY: 12/4/98 Updated to Param Block 2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 ***
 *******************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include <bmmlib.h>
#include "render.h"
#include "stdmat.h"
#include "iparamm2.h"

/*
#define PB_BLUR	      0
#define PB_NSAMT      1
#define PB_NSLEV      2
#define PB_NSSIZ      3
#define PB_NSPHS      4
*/

//#define DBG
extern HINSTANCE hInstance;

static Class_ID mirrorClassID(MIRROR_CLASS_ID,0);

#define DISTORT_NONE  0
#define DISTORT_BUMP  1
#define DISTORT_NOISE 2

#define NOISE_REGULAR 0
#define NOISE_FRACTAL 1
#define NOISE_TURB    2


// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { fmirror_params, };  // pblock ID
// mirror_params param IDs
enum 
{ 
	fmirror_blur, 
	fmirror_nsamt,	fmirror_nslev,	fmirror_nssiz,	fmirror_nsphs,
	fmirror_apply,
	fmirror_nthframe,
	fmirror_frame,
	fmirror_useenviroment,
	fmirror_applytofaceid,
	fmirror_faceid,
	fmirror_distortiontype,
	fmirror_noisetype,
	};


//---------------------------------------------------

class MirrorMap {	
	public:
		Bitmap  *bm;
		IPoint2 org;
		int nodeID;
		float xfact,yfact;
		TimeValue mapTime;  // when the mirror was last rendered
		Matrix3 pltm;  // reflection in plane in camera coords
		MirrorMap *next;
		MirrorMap() { next = NULL; bm = NULL; nodeID = -1; mapTime = 0; }
		~MirrorMap() { FreeMap(); }
		void FreeMap() { if (bm) bm->DeleteThis(); bm = NULL; } 
		
		int AllocMap(int w, int h, BOOL createAlpha);
	};

int MirrorMap::AllocMap(int w, int h, BOOL createAlpha) {
	if ( bm && w==bm->Width() && h==bm->Height())
		return 1;
	BitmapInfo bi;
	if (bm) bm->DeleteThis();
	bi.SetName(_T(""));
	bi.SetWidth(w);
	bi.SetHeight(h);
	bi.SetType(BMM_TRUE_32);
	if (createAlpha)
		bi.SetFlags(MAP_HAS_ALPHA);
	bi.SetCustomFlag(BMM_CUSTOM_GAMMA);
	bi.SetCustomGamma(1.0f);

	bm = TheManager->Create(&bi);
	return 1;
	}

/*
class Mirror;

class MirrorDlg: public ParamDlg {
	public:
		HWND hwmedit;	 	// window handle of the materials editor dialog
		IMtlParams *ip;
		Mirror *theTex;	// current Mirror being edited.
		HWND hPanel; 		// Rollup pane
		ISpinnerControl *blurSpin,*nthSpin;
		ISpinnerControl *nsAmtSpin, *nsLevSpin, *nsSizSpin, *nsPhsSpin, *mtlIdSpin;
		TimeValue curTime; 
		int isActive;
		BOOL valid;

		//-----------------------------
		MirrorDlg(HWND hwMtlEdit, IMtlParams *imp, Mirror *m); 
		~MirrorDlg();
		void EnableNoise();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
		void LoadDialog(BOOL draw);  // stuff params into dialog
		void ReloadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void ActivateDlg(BOOL onOff);
		void Invalidate() { valid = FALSE;	InvalidateRect(hPanel,NULL,0); }
		BOOL KeyAtCurTime(int id);

		// methods inherited from ParamDlg:
		Class_ID ClassID() {return mirrorClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theTex; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);
	};

*/

class MirrorDlg;

//--------------------------------------------------------------
// Mirror: 
//--------------------------------------------------------------

class Mirror: public StdMirror { 
	friend class MirrorPostLoad;
//	friend class MirrorDlg;
    MirrorMap *maps;
	Interval ivalid;
	int rollScroll;
	static MirrorDlg *paramDlg;
	public:
		BOOL Param1;
		int nth;
		float blur;
		float nsAmt,nsSize,nsPhase,nsAmt2,nsLev;
		BOOL applyBlur;
		BOOL do_nth;
		BOOL useEnvMap;
		BOOL distortType;
		BOOL useMtlID;
		BOOL createAlpha;
		int mtlID;
		int noiseType;
		IParamBlock2 *pblock;   // ref #1
		Mirror();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		// methods inherited from StdMirror:
		void SetDoNth(BOOL onoff) { do_nth = onoff;}
		void SetNth(int n){ nth = n;}
		void SetApplyBlur(BOOL onoff) { applyBlur = onoff; }
		void SetBlur(float b, TimeValue t);
		void SetNsAmt(float v, TimeValue t);
		void SetNsLev(float v, TimeValue t);
		void SetNsSiz(float v, TimeValue t);
		void SetNsPhase(float v, TimeValue t);
		BOOL GetDoNth() { return do_nth; }
		int GetNth() { return nth;}
		BOOL GetApplyBlur() { return applyBlur;}
		float GetBlur(TimeValue t) { 
//			return pblock->GetFloat(PB_BLUR,t); 
			return pblock->GetFloat(fmirror_blur,t); 
			}
		float NoiseFunc(Point3 p, float levels, float time);
		void EnableStuff();


		void NotifyChanged();
	
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// optimized evaluation for monochrome use
		float EvalMono(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		BOOL HandleOwnViewPerturb() { return TRUE; }

		ULONG LocalRequirements(int subMtlNum) {	
			return MTLREQ_AUTOMIRROR;
			}

		int BuildMaps(TimeValue t, RenderMapsContext &rmc);
		int DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime);
		MirrorMap *FindMap(int nodeNum);
		void FreeMaps();
		int RenderBegin(TimeValue t, ULONG flags) { return 1;}
		int RenderEnd(TimeValue t) { FreeMaps(); return 1; }

		Class_ID ClassID() {	return mirrorClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_FLATMIRROR); }  
		void DeleteThis() { delete this; }	

		int NumSubs() {return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		int SetProperty(ULONG id, void *data) { 
			 switch (id) {
				case 0x9500000: 
					createAlpha = data?1:0;
					break;
				}
			return 0;
			}

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

	};

class MirrorDlg : public ParamMap2UserDlgProc {
	public:
		Mirror *mirror;
		MirrorDlg(Mirror *m) { mirror = m; }
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam) { return FALSE; }		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			mirror = (Mirror *)m;
			mirror->EnableStuff();
			}
	};


MirrorDlg* Mirror::paramDlg = NULL;

class MirrorClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Mirror; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_FLATMIRROR_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return mirrorClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_ENV;  }

	const TCHAR*	InternalName() { return _T("flatMirror"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static MirrorClassDesc mirrorCD;

ClassDesc* GetMirrorDesc() { return &mirrorCD;  }
/*
static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	MirrorDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (MirrorDlg*)lParam;
		theDlg->hPanel = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (MirrorDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->PanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

MirrorDlg::MirrorDlg(HWND hwMtlEdit, IMtlParams *imp, Mirror *m) { 
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanel = NULL;
	theTex = m; 
	isActive = 0;
	valid = FALSE;
	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_MIRROR),
		PanelDlgProc, 
		GetString(IDS_DS_MIRROR_PARAMS), 
		(LPARAM)this );		
	curTime = imp->GetTime();
	}

void MirrorDlg::ReloadDialog() {
	Interval valid;
	theTex->Update(curTime, valid);
	LoadDialog(FALSE);
	}

void MirrorDlg::SetTime(TimeValue t) {
	Interval valid;
	if (t!=curTime) {
		curTime = t;
		theTex->Update(curTime, valid);
		LoadDialog(FALSE);
		InvalidateRect(hPanel,NULL,0);
		}
	}

MirrorDlg::~MirrorDlg() {
	theTex->paramDlg = NULL;
	ReleaseISpinner(blurSpin);
	ReleaseISpinner(nthSpin);
	ReleaseISpinner(nsAmtSpin);
	ReleaseISpinner(nsLevSpin);
	ReleaseISpinner(nsSizSpin);
	ReleaseISpinner(nsPhsSpin);
	ReleaseISpinner(mtlIdSpin);
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	hPanel =  NULL;
	}

void MirrorDlg::EnableNoise() {
	if (theTex&&hPanel) {
		BOOL en = (theTex->distortType==DISTORT_NOISE)?1:0;
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_REG),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_FRAC),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_TURB),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_ANI_EDIT),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_SIZ_EDIT),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_ANI_SPIN),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_SIZ_SPIN),en);
		en = en&&(theTex->noiseType!=NOISE_REGULAR);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_LEV_SPIN),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_LEV_EDIT),en);
		
		en = (theTex->distortType==DISTORT_NONE)?0:1;
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_AMT_SPIN),en);
		EnableWindow(GetDlgItem(hPanel,IDC_MIRNS_AMT_EDIT),en);

		
		}
	}

BOOL MirrorDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			blurSpin = SetupFloatSpinner(hwndDlg, IDC_ACUBE_BLUR_SPIN, IDC_ACUBE_BLUR_EDIT,0.0f,100.0f,1.0f,.01f);
			nthSpin = SetupIntSpinner(hwndDlg, IDC_ACUBE_NTH_SPIN, IDC_ACUBE_NTH_EDIT,1,1000, 1);

			nsAmtSpin = SetupFloatSpinner(hwndDlg, IDC_MIRNS_AMT_SPIN, IDC_MIRNS_AMT_EDIT,0.0f,10.0f, .5f, .01f);
			nsSizSpin = SetupFloatSpinner(hwndDlg, IDC_MIRNS_SIZ_SPIN, IDC_MIRNS_SIZ_EDIT,0.001f,100.0f,10.0f, .01f);
			nsLevSpin = SetupFloatSpinner(hwndDlg, IDC_MIRNS_LEV_SPIN, IDC_MIRNS_LEV_EDIT,1.0f,10.0f, 2.0f,.01f);
			nsPhsSpin = SetupFloatSpinner(hwndDlg, IDC_MIRNS_ANI_SPIN, IDC_MIRNS_ANI_EDIT,0.0f,100.0f, 0.0f, .01f);

			mtlIdSpin = SetupIntSpinner(hwndDlg, IDC_MIR_MID_SPIN, IDC_MIR_MID_EDIT,1,65536, theTex->mtlID+1);

			CheckRadioButton( hwndDlg, IDC_FIRST_ONLY, IDC_EVERY_NTH, IDC_FIRST_ONLY+theTex->do_nth);
			CheckRadioButton( hwndDlg, IDC_MIRNS_REG, IDC_MIRNS_TURB, IDC_MIRNS_REG+theTex->noiseType);
			CheckRadioButton( hwndDlg, IDC_MIRDIST_NONE, IDC_MIRDIST_NOISE, IDC_MIRDIST_NONE + theTex->distortType);
			EnableNoise();
			return TRUE;
			}
			break;
		case WM_COMMAND:  
		    switch (id) {
				case IDC_FIRST_ONLY:
					theTex->do_nth = FALSE;
					break;
				case IDC_EVERY_NTH:
					theTex->do_nth = TRUE;
					break;
				case IDC_ACUBE_BLUR:
					theTex->applyBlur = GetCheckBox(hwndDlg, IDC_ACUBE_BLUR);			
					break;
				case IDC_USE_ENVMAP:
					theTex->useEnvMap = GetCheckBox(hwndDlg, id);			
					break;
				case IDC_MIRDIST_NONE:
				case IDC_MIRDIST_BUMP:
				case IDC_MIRDIST_NOISE:
					theTex->distortType = id-IDC_MIRDIST_NONE;
					EnableNoise();
					break;
				case IDC_MIRNS_REG:
				case IDC_MIRNS_FRAC:
				case IDC_MIRNS_TURB:
					theTex->noiseType = id-IDC_MIRNS_REG;
					EnableNoise();
					break;
				case IDC_MIR_APPLY_MTLID:
					theTex->useMtlID = GetCheckBox(hwndDlg, id);			
					break;
				}
			break;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			break;
		case WM_CLOSE: 	break;       
		case WM_DESTROY:		break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_ACUBE_BLUR_SPIN: 
					theTex->SetBlur(blurSpin->GetFVal(),curTime); 	
					blurSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUR));
					break;
				case IDC_ACUBE_NTH_SPIN: 
					theTex->nth = nthSpin->GetIVal(); 	
					break;
				case IDC_MIRNS_AMT_SPIN: 
					theTex->SetNsAmt(nsAmtSpin->GetFVal(),curTime); 	
					nsAmtSpin->SetKeyBrackets(KeyAtCurTime(PB_NSAMT));
					break;
				case IDC_MIRNS_LEV_SPIN: 
					theTex->SetNsLev(nsLevSpin->GetFVal(),curTime); 	
					nsLevSpin->SetKeyBrackets(KeyAtCurTime(PB_NSLEV));
					break;
				case IDC_MIRNS_SIZ_SPIN: 
					theTex->SetNsSiz(nsSizSpin->GetFVal(),curTime); 	
					nsSizSpin->SetKeyBrackets(KeyAtCurTime(PB_NSSIZ));
					break;
				case IDC_MIRNS_ANI_SPIN: 
					theTex->SetNsPhase(nsPhsSpin->GetFVal(),curTime); 	
					nsPhsSpin->SetKeyBrackets(KeyAtCurTime(PB_NSPHS));
					break;
				case IDC_MIR_MID_SPIN: 
					theTex->mtlID = mtlIdSpin->GetIVal()-1; 	
					break;
				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			theTex->NotifyChanged();
		    UpdateMtlDisplay();
			break;
    	}
	return FALSE;
	}
 
BOOL MirrorDlg::KeyAtCurTime(int id) { return theTex->pblock->KeyFrameAtTime(id,ip->GetTime()); }

void MirrorDlg::LoadDialog(BOOL draw) {
	if (theTex) {
		Interval valid;
		theTex->Update(curTime,valid);
		blurSpin->SetValue(theTex->blur,FALSE);
		nthSpin->SetValue(theTex->nth,FALSE);
		nsAmtSpin->SetValue(theTex->nsAmt,FALSE);
		nsLevSpin->SetValue(theTex->nsLev,FALSE);
		nsSizSpin->SetValue(theTex->nsSize,FALSE);
		nsPhsSpin->SetValue(theTex->nsPhase,FALSE);
		mtlIdSpin->SetValue(theTex->mtlID+1,FALSE);

		blurSpin->SetKeyBrackets(KeyAtCurTime(PB_BLUR));
		nsAmtSpin->SetKeyBrackets(KeyAtCurTime(PB_NSAMT));
		nsLevSpin->SetKeyBrackets(KeyAtCurTime(PB_NSLEV));
		nsSizSpin->SetKeyBrackets(KeyAtCurTime(PB_NSSIZ));
		nsPhsSpin->SetKeyBrackets(KeyAtCurTime(PB_NSPHS));

		CheckRadioButton( hPanel, IDC_FIRST_ONLY, IDC_EVERY_NTH, IDC_FIRST_ONLY+theTex->do_nth);
		SetCheckBox(hPanel, IDC_ACUBE_BLUR, theTex->applyBlur);
		SetCheckBox(hPanel, IDC_ACUBE_BLUR, theTex->applyBlur);
		SetCheckBox(hPanel, IDC_USE_ENVMAP, theTex->useEnvMap);
		SetCheckBox(hPanel, IDC_MIR_APPLY_MTLID, theTex->useMtlID);
		CheckRadioButton( hPanel, IDC_MIRNS_REG, IDC_MIRNS_TURB, IDC_MIRNS_REG+theTex->noiseType);
		CheckRadioButton( hPanel, IDC_MIRDIST_NONE, IDC_MIRDIST_NOISE, IDC_MIRDIST_NONE + theTex->distortType);
		EnableNoise();
		}
	}

void MirrorDlg::SetThing(ReferenceTarget *m) {
	assert (m->ClassID()==mirrorClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
	if (theTex) theTex->paramDlg = NULL;
	theTex = (Mirror *)m;
	if (theTex)
		theTex->paramDlg = this;
	LoadDialog(TRUE);
	}

void MirrorDlg::ActivateDlg(BOOL onOff) {
	}
*/

class MirrorPBAccessor : public PBAccessor
{
public:
void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t);    // set from v
};

void Mirror::EnableStuff() {
	if (!pblock) return;
	IParamMap2 *map = pblock->GetMap();
	if (!map) return;
	pblock->GetValue( fmirror_distortiontype, 0, distortType, FOREVER);
	pblock->GetValue( fmirror_noisetype, 0, noiseType, FOREVER);
	switch(distortType) {
		case 0:  // NONE
			map->Enable(fmirror_noisetype, FALSE);
			map->Enable(fmirror_nsamt, FALSE);
			map->Enable(fmirror_nslev, FALSE);
			map->Enable(fmirror_nsphs, FALSE);
			map->Enable(fmirror_nssiz, FALSE);
			break;
		case 1:	 // Use Bump map
			map->Enable(fmirror_noisetype, FALSE);
			map->Enable(fmirror_nsamt, TRUE);
			map->Enable(fmirror_nsphs, FALSE);
			map->Enable(fmirror_nssiz, FALSE);
			map->Enable(fmirror_nslev, FALSE);
			break;
		case 2:  // Builtin noise
			map->Enable(fmirror_noisetype, TRUE);
			map->Enable(fmirror_nsamt, TRUE);
			map->Enable(fmirror_nsphs, TRUE);
			map->Enable(fmirror_nssiz, TRUE);
			map->Enable(fmirror_nslev, noiseType);
			break;
		}
	pblock->GetValue( fmirror_apply, 0, applyBlur, FOREVER);
	map->Enable(fmirror_blur, applyBlur);
	}

void MirrorPBAccessor::Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
	Mirror* p = (Mirror*)owner;
	if (p->pblock == NULL) return;
	IParamMap2 *map = p->pblock->GetMap();
	if (map == NULL) return;
	switch (id)	{
		case fmirror_distortiontype:
			p->distortType = v.i;
			p->EnableStuff();
			break;
		case fmirror_noisetype:
			p->noiseType =v.i;
			p->EnableStuff();
			break;
		}
	}

static MirrorPBAccessor fmirror_accessor;


//-----------------------------------------------------------------------------
//  Mirror
//-----------------------------------------------------------------------------

static ParamBlockDesc2 fmirror_param_blk ( fmirror_params, _T("parameters"),  0, &mirrorCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_MIRROR, IDS_DS_MIRROR_PARAMS, 0, 0, NULL, 
	// params
	fmirror_blur,	_T("blurAmount"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_PW_BLURAMOUNT,
		p_default,		1.0,
		p_range,		0.0, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_ACUBE_BLUR_EDIT,  IDC_ACUBE_BLUR_SPIN, 0.01f,
		end,

	fmirror_nsamt,	_T("distortionAmount"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_PW_DISTORTIONAMOUNT,
		p_default,		.5,
		p_range,		0.0, 10.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MIRNS_AMT_EDIT, IDC_MIRNS_AMT_SPIN, 0.01f,
		p_enabled,		FALSE,
		end,
	fmirror_nslev,	_T("level"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_PW_LEVEL,
		p_default,		2.0,
		p_range,		1.0, 10.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_MIRNS_LEV_EDIT,IDC_MIRNS_LEV_SPIN, 0.01f,
		p_enabled,		FALSE,
		end,
	fmirror_nssiz,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_SIZE,
		p_default,		10.,
		p_range,		0.001, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,   IDC_MIRNS_SIZ_EDIT,IDC_MIRNS_SIZ_SPIN, 0.01f,
		p_enabled,		FALSE,
		end,
	fmirror_nsphs,	_T("phase"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PHASE,
		p_default,		0.,
		p_range,		0.0, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,    IDC_MIRNS_ANI_EDIT, IDC_MIRNS_ANI_SPIN,0.01f,
		p_enabled,		FALSE,
		end,
	fmirror_apply,	_T("applyBlur"), TYPE_BOOL,			0,				IDS_PW_APPLYBLUR,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_ACUBE_BLUR,
		end,
	fmirror_nthframe,	_T("nthFrame"),   TYPE_INT,			0,	IDS_PW_NTHFRAME,
		p_default,		1,
		p_range,		1, 10000,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,  IDC_ACUBE_NTH_EDIT, IDC_ACUBE_NTH_SPIN, 1.0f,
		end,
	fmirror_frame, _T("frame"), TYPE_INT,				0,				IDS_PW_FRAME,
		p_default,		1,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_FIRST_ONLY, IDC_EVERY_NTH,
		end,
	fmirror_useenviroment,	_T("useEnviroment"), TYPE_BOOL,			0,				IDS_PW_USENVIROMENT,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_USE_ENVMAP,
		end,
	fmirror_applytofaceid,	_T("applyToFaceID"), TYPE_BOOL,			0,				IDS_PW_APPLYTOFACEID,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MIR_APPLY_MTLID,
		end,
	fmirror_faceid,	_T("faceID"),   TYPE_INT,			0,	IDS_PW_FACEID,
		p_default,		1,
		p_range,		1, 65536,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,   IDC_MIR_MID_EDIT, IDC_MIR_MID_SPIN, 1.0f,
		end,

	fmirror_distortiontype, _T("distortionType"), TYPE_INT,				0,				IDS_PW_DISTORTIONTYPE,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_MIRDIST_NONE, IDC_MIRDIST_BUMP,IDC_MIRDIST_NOISE,
		p_accessor,		&fmirror_accessor,
		end,
	fmirror_noisetype, _T("noiseType"), TYPE_INT,				0,				IDS_PW_NOISETYPE,
		p_default,		0,
		p_range,		0,	2,
		p_enabled,		FALSE,
		p_ui,			TYPE_RADIO, 3, IDC_MIRNS_REG, IDC_MIRNS_FRAC,IDC_MIRNS_TURB,
		p_accessor,		&fmirror_accessor,
		end,

	end
);


#define NPARAMS 5
#define MIRROR_VERSION 4

// Version 1 desc
static ParamBlockDescID pbdesc1[] = {
	{ TYPE_INT, NULL, TRUE,fmirror_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,fmirror_apply} 	// blurOff
	};

// Version 2 desc
static ParamBlockDescID pbdesc2[] = {
	{ TYPE_FLOAT, NULL, TRUE,fmirror_blur } 	// blur
	};

// Version 3 desc
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,fmirror_blur}, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,fmirror_nsamt }, 	// noise amount
	{ TYPE_FLOAT, NULL, TRUE,fmirror_nslev }, 	// noise levels
	{ TYPE_FLOAT, NULL, TRUE,fmirror_nssiz }, 	// noise size
	{ TYPE_FLOAT, NULL, TRUE,fmirror_nsphs } 	// noise phase
	};

static ParamVersionDesc versions[3] = {
	ParamVersionDesc(pbdesc1,2,1),
	ParamVersionDesc(pbdesc2,1,2),
	ParamVersionDesc(pbdesc,5,3)
	};

//static ParamVersionDesc curVersion(pbdesc,NPARAMS,MIRROR_VERSION);

void Mirror::Init() {
	ivalid.SetEmpty();
	noiseType = NOISE_REGULAR;
	nth = 1;
	do_nth = TRUE;
	applyBlur = TRUE;
	distortType = DISTORT_NONE;
	useMtlID = FALSE;
	mtlID = 0;
	useEnvMap = TRUE;
	createAlpha = FALSE;
	SetBlur(1.0f, TimeValue(0));
	SetNsAmt(.5f, TimeValue(0));
	SetNsSiz(10.0f, TimeValue(0));
	SetNsLev(2.0f, TimeValue(0));
	SetNsPhase(0.0f, TimeValue(0));
	}

void Mirror::Reset() {
	mirrorCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

void Mirror::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Mirror::Mirror() {
	Param1 = FALSE;
//	paramDlg = NULL;
	pblock = NULL;
	maps = NULL;
	mirrorCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

RefTargetHandle Mirror::Clone(RemapDir &remap) {
	Mirror *mnew = new Mirror();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->do_nth = do_nth;
	mnew->applyBlur = applyBlur;
	mnew->distortType = distortType;
	mnew->useEnvMap = useEnvMap;
	mnew->useMtlID = useMtlID;
	mnew->mtlID = mtlID;
	mnew->ivalid.SetEmpty();	
	return (RefTargetHandle)mnew;
	}

ParamDlg* Mirror::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
//	MirrorDlg *dm = new MirrorDlg(hwMtlEdit, imp, this);
//	dm->LoadDialog(TRUE);	
//	paramDlg = dm;
//	return dm;	
	IAutoMParamDlg* masterDlg = mirrorCD.CreateParamDlgs(hwMtlEdit, imp, this);
	paramDlg = new MirrorDlg(this);
	fmirror_param_blk.SetUserDlgProc(paramDlg);
	EnableStuff();
	return masterDlg;

	}

void Mirror::Update(TimeValue t, Interval& valid) {		
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
//		pblock->GetValue( PB_BLUR, t, blur, ivalid );
//		pblock->GetValue( PB_NSAMT, t, nsAmt, ivalid);
		pblock->GetValue( fmirror_blur, t, blur, ivalid );
		pblock->GetValue( fmirror_nsamt, t, nsAmt, ivalid);
		nsAmt2 = nsAmt/10.0f;
//		pblock->GetValue( PB_NSSIZ, t, nsSize, ivalid);
//		pblock->GetValue( PB_NSPHS, t, nsPhase, ivalid);
//		pblock->GetValue( PB_NSLEV, t, nsLev, ivalid);
		pblock->GetValue( fmirror_nssiz, t, nsSize, ivalid);
		pblock->GetValue( fmirror_nsphs, t, nsPhase, ivalid);
		pblock->GetValue( fmirror_nslev, t, nsLev, ivalid);


		pblock->GetValue( fmirror_apply, t, applyBlur, ivalid);
		pblock->GetValue( fmirror_nthframe, t, nth, ivalid);
		pblock->GetValue( fmirror_frame, t, do_nth, ivalid);
		pblock->GetValue( fmirror_useenviroment, t, useEnvMap, ivalid);
		pblock->GetValue( fmirror_applytofaceid, t, useMtlID, ivalid);
		pblock->GetValue( fmirror_faceid, t, mtlID, ivalid);
		--mtlID;
		pblock->GetValue( fmirror_distortiontype, t, distortType, ivalid);
		pblock->GetValue( fmirror_noisetype, t, noiseType, ivalid);
		EnableStuff();
		}
	valid &= ivalid;
	}

void Mirror::FreeMaps() {
	MirrorMap *cm,*nxtcm;
	for (cm = maps; cm!=NULL; cm = nxtcm) {
		nxtcm = cm->next;
	   	delete cm;		
		}
	maps = NULL;
	}


void Mirror::SetBlur(float f, TimeValue t) { 
	blur = f; 
//	pblock->SetValue( PB_BLUR, t, f);
	pblock->SetValue( fmirror_blur, t, f);
	}


void Mirror::SetNsAmt(float v, TimeValue t){
	nsAmt = v; 
	nsAmt2 = nsAmt/10.0f;
//	pblock->SetValue( PB_NSAMT, t, v);
	pblock->SetValue( fmirror_nsamt, t, v);
	}

void Mirror::SetNsLev(float v, TimeValue t){
	nsLev = v; 
//	pblock->SetValue( PB_NSLEV, t, v);
	pblock->SetValue( fmirror_nslev, t, v);
	}

void Mirror::SetNsSiz(float v, TimeValue t) {
	nsSize = v; 
//	pblock->SetValue( PB_NSSIZ, t, v);
	pblock->SetValue( fmirror_nssiz, t, v);
	}

void Mirror::SetNsPhase(float v, TimeValue t) {
	nsPhase =v; 
//	pblock->SetValue( PB_NSPHS, t, v);
	pblock->SetValue( fmirror_nsphs, t, v);
	}


RefTargetHandle Mirror::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		default: return NULL;
		}
	}

void Mirror::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		}
	}
	 
Animatable* Mirror::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}

TSTR Mirror::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));
		default: return TSTR("");		
		}
	}

static int nameID[] = { IDS_DS_BLUR, IDS_DS_DISTAMT, IDS_DS_NSLEV, IDS_DS_NSSIZ, IDS_DS_NSPHS };

RefResult Mirror::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			if (hTarget == pblock)
				{
				ivalid.SetEmpty();
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				fmirror_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				NotifyChanged();
				}

//			ivalid.SetEmpty();
//			if (paramDlg) 
//				paramDlg->Invalidate();
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_BLUR: 
				case PB_NSAMT: 
				case PB_NSLEV: 
				case PB_NSPHS: 
					gpd->dim = defaultDim; break;
				case PB_NSSIZ: 
					gpd->dim = stdWorldDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = TSTR(GetString(nameID[gpn->index]));
			return REF_STOP; 
			}
*/
		}
	return(REF_SUCCEED);
	}

static void FlipAxis(Matrix3& tm, int k) {
	MRow* m = tm.GetAddr();
	for (int i=0; i<4; i++) m[i][k] = -m[i][k];
	}

/* build reflection matrix for plane p */
static void BuildReflMatrix(Matrix3& rm, float *p) {
	MRow* m = rm.GetAddr();
	m[0][0] = 1.0f-2.0f*p[0]*p[0];		
	m[1][1] = 1.0f-2.0f*p[1]*p[1];		
	m[2][2] = 1.0f-2.0f*p[2]*p[2];		
	m[0][1] = m[1][0] = -2.0f*p[0]*p[1];		
	m[0][2] = m[2][0] = -2.0f*p[0]*p[2];		
	m[1][2] = m[2][1] = -2.0f*p[1]*p[2];		
	m[3][0] = -2.0f*p[0]*p[3];		
	m[3][1] = -2.0f*p[1]*p[3];		
	m[3][2] = -2.0f*p[2]*p[3];		
	rm.SetNotIdent();
	}


MirrorMap *Mirror::FindMap(int nodeNum) {
	MirrorMap *cm;
	for (cm=maps; cm!=NULL; cm = cm->next)
		if (cm->nodeID==nodeNum) return cm;
	return NULL;
	}

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

static void whoa(){}

int Mirror::DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime) {
	if (!do_nth) {
		if (t!=mapTime) return 0;  // only do it on first frame.
		}
	if (nth==1) return 1;   // need every one
	TimeValue del = abs(t - mapTime);
	if (del==0) return 1; // repeated iterations on a frame are ok
	if (fieldRender) del*=2;
	return  (del>=nth*GetTicksPerFrame())?1:0;
	}

int Mirror::BuildMaps(TimeValue t, RenderMapsContext &rmc) {
	SubRendParams srp;
	rmc.GetSubRendParams(srp);
  	MirrorMap *mir = FindMap(rmc.NodeRenderID());
	if (mir&&!DoThisFrame(t,srp.fieldRender, mir->mapTime))
		return 1;
	RenderGlobalContext *gc = rmc.GetGlobalContext();
	if (gc->inMtlEdit) 
		return 1;
	ViewParams vp;
	
	if (useMtlID)
		rmc.SetSubMtlIndex(mtlID);

	float plane[4];
	Box2 sbox;
    rmc.FindMtlPlane(plane);
	rmc.GetCurrentViewParams(vp);
	Matrix3 worldToCam = vp.affineTM;
	Matrix3 tm = Inverse(vp.affineTM);  // get tm = camToWorld
	if (vp.projType==PROJ_PERSPECTIVE) {
		// If this is a perspective projection, and the Camera is behind plane
		// of the mirror, then quit.
		if ( DotProd(tm.GetRow(3),Point3(plane[0],plane[1],plane[2]))+plane[3]<0.0f ) 
			return 1;
		}
	else  {
		// If this is an ortho projection, and if view vector is
		// looking at edge or back of mirror, we punt.
		if (DotProd(tm.GetRow(2),Point3(plane[0],plane[1],plane[2]))<.0001f )
			return 1; 
		}

	Matrix3 rm;
	// compute a matrix that reflects in plane
	BuildReflMatrix(rm, plane);
	vp.affineTM  = Inverse(tm*rm);

	// Flip so parity is positive -- otherwise it wont render right. This
	// will be corrected for when we access the bitmap.
	FlipAxis(vp.affineTM, X_AXIS);	

	rmc.FindMtlScreenBox(sbox, &vp.affineTM, rmc.SubMtlIndex());

	int xmin,xmax,ymin,ymax;
	xmax = sbox.right;
	xmin = sbox.left;
	ymax = sbox.bottom;
	ymin = sbox.top;
	if (srp.fieldRender) {
		ymin *= 2;
		ymax *= 2;
		}
	if ( srp.rendType==RENDTYPE_REGION || srp.rendType==RENDTYPE_REGIONCROP ) {
		int rxmax = srp.devWidth - srp.xmin;
		int rxmin = srp.devWidth - srp.xmax;
		ymin = MAX(ymin,srp.ymin);
		ymax = MIN(ymax,srp.ymax);
		xmin = MAX(xmin,rxmin);
		xmax = MIN(xmax,rxmax);
		}

	srp.ymin = MAX(ymin,0);
	srp.ymax = MIN(ymax,srp.devHeight);
	srp.xmin = MAX(xmin,0);
	srp.xmax = MIN(xmax,srp.devWidth);
	srp.xorg = srp.xmin;
	srp.yorg = srp.ymin;
	srp.doingMirror = TRUE;
	srp.doEnvMap = useEnvMap;

	int w = srp.xmax-srp.xmin;
	int h = srp.ymax-srp.ymin;

	if (w<=0||h<=0) 
		return 1;
#ifdef DBG
	w = ((w+3)/4)*4;   // For some reason this needs to be a multiple of 4 for bm->Display
#endif

  	if (mir==NULL) {
	  	mir = new MirrorMap;
		mir->nodeID = rmc.NodeRenderID();
		mir->next = maps;
		maps = mir;
		}
	mir->mapTime = t;	
	mir->pltm = tm*rm*worldToCam; // tm for mirror reflection in camera space
	mir->AllocMap(w, h, createAlpha);
	mir->org.x = srp.xorg-srp.devWidth/2;
	mir->org.y = srp.yorg-srp.devHeight/2;
//	mir->org.y = srp.fieldRender ?srp.yorg/2:srp.yorg;
	if (gc) {
		mir->xfact = nsAmt2*gc->xscale/float(w); 
		mir->yfact = nsAmt2*gc->yscale/float(h); 
		}

	Point4 camPlane;
	camPlane = TransformPlane(vp.affineTM, plane);

	// Render the mirror map.
	if (!rmc.Render(mir->bm, vp, srp, &camPlane,1))
		return 0;

	if (srp.fieldRender) {
		// Double the lines, otherwise the blur and distortion wont work right,
		// because the blank lines in between get averaged in and darken it.
		int	evenLines = srp.evenLines; 

		PixelBuf l64(w);
		if (evenLines) {
			for (int i=0; i<h; i+=2) {
				BMM_Color_64 *p64=l64.Ptr();
				if (i+1<h) {
					mir->bm->GetPixels(0,i,  w, p64); 
					mir->bm->PutPixels(0,i+1,w, p64);				
					}
				}
			}
		else {
			for (int i=0; i<h; i+=2) {
				BMM_Color_64 *p64=l64.Ptr();
				if (i+1<h) {
					mir->bm->GetPixels(0,i+1,w, p64); 
					mir->bm->PutPixels(0,i  ,w, p64);				
					}
				}
			}
		}

#ifdef DBG
	mir->bm->UnDisplay();
	mir->bm->Display(_T("Mirror Test"), BMM_UR);
	MessageBox(NULL, GetName(), _T(" Mirror Test"), MB_OK|MB_ICONEXCLAMATION);
#endif

	if (applyBlur) {
		// I tried pyramids here, but SATs looked much better. 
		//  maybe we should give users a choice?
		mir->bm->SetFilter(BMM_FILTER_SUM); 
//		mir->bm->SetFilter(BMM_FILTER_PYRAMID); 
		BitmapFilter *filt = mir->bm->Filter();
		if (filt)
			filt->MakeDirty();  // so filter gets recomputed for each frame
		}
	else 
		mir->bm->SetFilter(BMM_FILTER_NONE); 
	return 1;
	}

inline float FMax(float a, float b) { return (a>b?a:b); }

float Mirror::NoiseFunc(Point3 p, float levels, float time)
	{
	float res;
	switch (noiseType) {
		case NOISE_TURB: {
			float sum = 0.0f;
			float l,f = 1.0f;			
			for (l = levels; l>=1.0f; l-=1.0f) {				
				sum += (float)fabs(noise4(p*f,time))/f;
				f *= 2.0f;
				}
			if (l>0.0f) {				
				sum += l*(float)fabs(noise4(p*f,time))/f;
				}
			res = sum;
			break;
			}
			
		case NOISE_REGULAR:
			res = noise4(p,time);
			break;

		case NOISE_FRACTAL:
			if (levels==1.0f) {
				res = noise4(p,time);
			} else {
				float sum = 0.0f;
				float l,f = 1.0f;				
				for (l = levels; l>=1.0f; l-=1.0f) {					
					sum += noise4(p*f,time)/f;
					f *= 2.0f;
					}
				if (l>0.0f) {					
					sum += l*noise4(p*f,time)/f;
					}
				res = sum;
				}
			break;
		}
	
//	if (low<high) {
//		res = 2.0f * sramp((res+1.0f)/2.0f,low,high,sd) - 1.0f;
//		}
	return res;
	}

static inline Point3 ReflectVector(Point3 V, Point3 N) {   return V-2.0f*DotProd(V,N)*N; }

static BMM_Color_64 black64 = {0,0,0,0};
static AColor black(0.0f,0.0f,0.0f,0.0f);
static RGBA blackrgba(0.0f,0.0f,0.0f,1.0f);
#define RGC_DOINGMIRROR 100

RGBA Mirror::EvalColor(ShadeContext& sc) {
	BMM_Color_64 c;
	IPoint2 s;
	int id = sc.NodeID();
	if (sc.InMtlEditor()) return blackrgba;
	MirrorMap *mir = FindMap(id);
	if (gbufID) sc.SetGBufferID(gbufID);
	if (mir) {
		if (useMtlID && (sc.mtlNum!=mtlID)) return blackrgba;
		RenderGlobalContext *gc = sc.globContext;
		if (gc->Execute(RGC_DOINGMIRROR))
			return blackrgba;
		s = sc.ScreenCoord();
		int w = mir->bm->Width(); 
		int h = mir->bm->Height();
		float nsx,nsy,nsblur;
		if (gc==NULL) 
			return blackrgba;
		switch (distortType) {
			case DISTORT_NOISE: {
				Point3 p = sc.PObj();
				nsx = NoiseFunc(p/nsSize,nsLev,nsPhase)*nsAmt2;
				nsy = NoiseFunc(Point3(p.y+23.0f,p.z+12.0f,p.x+35.0f)/nsSize,nsLev,nsPhase)*nsAmt2;
				Point3 dp = sc.DPObj();
				float a = float(fabs(dp.x)+fabs(dp.y)+fabs(dp.z));
				// A heuristic attempt at anti-aliasing.
				// Increase the sample size porportional to the size of the sample
				// area in Noise space (dp/nsSize), &the amplitude of perturbation
				// applied in uv space (nsAmt).  This seems to work, but the scale
				// factor is arbitrary, and may need tuning.
				nsblur = blur + a*nsAmt/nsSize;
				}
				break;
			case DISTORT_BUMP: {
				// reflection vector for the bumped normal
				Point3 view = sc.V();
				Point3 R1 = ReflectVector(view,sc.Normal());
				// reflect in mirror( in camera space)
				R1 = VectorTransform(mir->pltm,R1);
				// compare with current view vector
				Point3 dv = R1-view;  // the difference
				nsx =    dv.x*mir->xfact; 
				nsy =   -dv.y*mir->yfact;
	  			nsblur = blur;
				}
				break;
			case DISTORT_NONE:
				nsx = nsy = 0.0f; 
				nsblur = 0.0f;
				break;
			}

		int xorg = mir->org.x + gc->devWidth/2;
		int yorg = mir->org.y + gc->devHeight/2;

		if (applyBlur) {
			float du = 1.0f/float(w);
			float dv = 1.0f/float(h);
			float du2,dv2;
			float u = float(gc->devWidth-1-s.x-xorg)*du+0.5f*du; 
			float v = float(s.y-yorg)*dv+0.5f*dv;
			if (distortType) {
				u += nsx; 
				if (u<0.0f) u = 0.0f; else if (u>1.0f) u = 1.0f;
				v += nsy; 
				if (v<0.0f) v = 0.0f; else if (v>1.0f) v = 1.0f;
				du2 = du*nsblur; 
				dv2 = dv*nsblur; 
				}
			else { 
				du2 = du*blur; 
				dv2 = dv*blur; 
				}
			mir->bm->GetFiltered(u,v, du2, dv2,&c);
			}
		else {
			int ix = gc->devWidth-1-s.x-xorg;
			int iy = s.y-yorg;
			if (distortType) {
				ix += int(nsx*w);
				if (ix<0) ix = 0; else if (ix>=w) ix = 1-1;
				iy += int(nsy*h);
				if (iy<0) iy = 0; else if (iy>=w) iy = 1-1;
				}
			mir->bm->GetLinearPixels(ix,iy,1,&c);
#if 0
			FILE *f = sc.DebugFile();
			if (f) {
				fprintf(f,"w=%d, h=%d org = (%d, %d) ", w, mir->bm->Height(),mir->org.x, mir->org.y);
				fprintf(f, "s = (%d, %d), c = (%x, %x, %x, %x)\n",
					s.x,s.y,c.r,c.g,c.b,c.a);
				}
#endif
			}
		return c;
		}
	else 
		return black;
	}

float Mirror::EvalMono(ShadeContext& sc) {
	return Intens(EvalColor(sc));
	}

Point3 Mirror::EvalNormalPerturb(ShadeContext& sc) {
	return Point3(0,0,0);
	}

#define MTL_HDR_CHUNK 0x4000
#define DONT_DO_NTH_CHUNK 0x1000
#define NTH_CHUNK 0x1001
#define DONT_APPLY_BLUR_CHUNK 0x1002
#define DONT_USE_ENV_CHUNK 0x1003
#define DO_NOISE_CHUNK 0x1004
#define NOISE_TYPE_CHUNK 0x1005
#define DISTORT_TYPE_CHUNK 0x1020
#define USE_MTLID_CHUNK 0x1030
#define MTLID_CHUNK 0x1040
#define PARAM2_CHUNK 0x1050
IOResult Mirror::Save(ISave *isave) { 
	IOResult res;
//	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

/*
	if (!do_nth) {
		isave->BeginChunk(DONT_DO_NTH_CHUNK);
		isave->EndChunk();
		}
	if (!applyBlur) {
		isave->BeginChunk(DONT_APPLY_BLUR_CHUNK);
		isave->EndChunk();
		}
	if (!useEnvMap) {
		isave->BeginChunk(DONT_USE_ENV_CHUNK);
		isave->EndChunk();
		}
	isave->BeginChunk(DISTORT_TYPE_CHUNK);
	isave->Write(&distortType,sizeof(distortType),&nb);			
	isave->EndChunk();

	isave->BeginChunk(NTH_CHUNK);
	isave->Write(&nth,sizeof(nth),&nb);			
	isave->EndChunk();

	isave->BeginChunk(NOISE_TYPE_CHUNK);
	isave->Write(&noiseType,sizeof(noiseType),&nb);			
	isave->EndChunk();

	isave->BeginChunk(MTLID_CHUNK);
	isave->Write(&mtlID,sizeof(mtlID),&nb);			
	isave->EndChunk();

	if (useMtlID) {
		isave->BeginChunk(USE_MTLID_CHUNK);
		isave->EndChunk();
		}

*/
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}

class MirrorPostLoad : public PostLoadCallback {
	public:
		Mirror *n;
		BOOL Param1;
		MirrorPostLoad(Mirror *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				TimeValue t = 0;
				n->pblock->SetValue( fmirror_apply, t, n->applyBlur);
				n->pblock->SetValue( fmirror_nthframe, t, n->nth);
				n->pblock->SetValue( fmirror_frame, t, n->do_nth);
				n->pblock->SetValue( fmirror_useenviroment, t, n->useEnvMap);
				n->pblock->SetValue( fmirror_applytofaceid, t, n->useMtlID);
				n->pblock->SetValue( fmirror_faceid, t, n->mtlID+1);
				n->pblock->SetValue( fmirror_distortiontype, t, n->distortType);
				n->pblock->SetValue( fmirror_noisetype, t, n->noiseType);

				}

			delete this; 


			} 
	};

		

IOResult Mirror::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
//	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,2, &curVersion, this,0));
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case DONT_DO_NTH_CHUNK:
				do_nth = FALSE;
				break;
			case DONT_APPLY_BLUR_CHUNK:
				applyBlur = FALSE;
				break;
			case DONT_USE_ENV_CHUNK:
				useEnvMap = FALSE;
				break;
			case DO_NOISE_CHUNK:
				distortType = DISTORT_NOISE;
				break;
			case NTH_CHUNK:
				iload->Read(&nth,sizeof(nth),&nb);			
				break;
			case NOISE_TYPE_CHUNK:
				iload->Read(&noiseType,sizeof(noiseType),&nb);			
				break;
			case DISTORT_TYPE_CHUNK:
				iload->Read(&distortType,sizeof(distortType),&nb);			
				break;
			case MTLID_CHUNK:
				iload->Read(&mtlID,sizeof(mtlID),&nb);			
				break;
			case USE_MTLID_CHUNK:
				useMtlID = TRUE;
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 3, &fmirror_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new MirrorPostLoad(this,Param1));

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\gradient.cpp ===
/**********************************************************************
 *<
	FILE: gradient2.cpp

	DESCRIPTION: A simple gradient texture map.
				 Ed. 2 using ParamBlock2's

	CREATED BY: Rolf Berteig
			    Ed. 2 John Wainwright

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include <bmmlib.h>
#include "stdmat.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

#define NSUBTEX 3
#define NCOLS 3

static Class_ID gradClassID(GRADIENT_CLASS_ID,0);

#define NOISE_REGULAR	0
#define NOISE_FRACTAL	1
#define NOISE_TURB		2

#define GRAD_LINEAR	0
#define GRAD_RADIAL	1

class Gradient;

#define UVGEN_REF	0
#define PBLOCK_REF	1
#define MAP1_REF	2
#define MAP2_REF	3
#define MAP3_REF	4
#define TEXOUT_REF	5

#define NUM_REFS	6

class Gradient;

// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { grad_params, };  // pblock ID
// grad_params param IDs
enum 
{ 
	grad_color1, grad_color2, grad_color3, grad_map1, grad_map2,		// main grad params 
	grad_map3, grad_map1_on, grad_map2_on, grad_map3_on,	
	grad_center, grad_type,					
	grad_amount, grad_noise_type, grad_size, grad_phase, grad_levels,	// noise
	grad_low_thresh, grad_high_thresh, grad_thresh_smooth,				// noise threshold
	grad_coords, grad_output,											// access for UVW mapping & output refs
};

//--------------------------------------------------------------
// MySampler: gradient sample function
//--------------------------------------------------------------
class GradSampler: public MapSampler {
	Gradient *grad;
	public:
		GradSampler() { grad= NULL; }
		GradSampler(Gradient *c) { grad= c; }
		void Set(Gradient *c) { grad = c; }
		AColor Sample(ShadeContext& sc, float u,float v);
		AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv);
//		float SampleMono(ShadeContext& sc, float u,float v);
//		float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv);
	} ;

// JBW: the Gradient dialog class has gone, all UI is managed automatically by auto-generated
// ParamMap2's from the paramblock descriptor

class Gradient: public GradTex { 
	public:	
		static ParamDlg* uvGenDlg;	
		static ParamDlg* texoutDlg;
		Color col[NCOLS];
		int type, noiseType;
		float amount, size, phase, size1, center, levels, low, high, smooth, sd, hminusl;
		UVGen *uvGen;				// ref #0
// JBW: use an IParamBlock2
		IParamBlock2 *pblock;		// ref #1		
		Texmap* subTex[NSUBTEX];	// More refs: 2,3,4  (also accessible as Texmap* params in pblock)
		BOOL mapOn[NSUBTEX];
		TextureOutput *texout;		// ref #5
		TexHandle *texHandle;
		Interval texHandleValid;
		Interval ivalid;
		int rollScroll;
		GradSampler mysamp;

		Gradient();
		~Gradient() { DiscardTexHandle(); }
		void EnableStuff();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		BOOL SetDlgThing(ParamDlg* dlg);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) {Interval v; Update(t,v); return ivalid;}

		StdUVGen* GetUVGen() { return (StdUVGen *)uvGen; }
		TextureOutput* GetTexout() { return texout; }
		void SetOutputLevel(TimeValue t, float v) {texout->SetOutputLevel(t,v); }
		void SetMidPoint(float m, TimeValue t=0) {	pblock->SetValue(grad_center, t, m);	}
		void NotifyChanged();		
		Bitmap *BuildBitmap(int size);
		float NoiseFunc(Point3 p);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);
		AColor DispEvalFunc( float u, float v);		
		float gradFunc(float u, float v);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods for interactive display
		void DiscardTexHandle();
		BOOL SupportTexDisplay() { return TRUE; }
		void ActivateTexDisplay(BOOL onoff);
		DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker);
		void GetUVTransform(Matrix3 &uvtrans) { uvGen->GetUVTransform(uvtrans); }
		int GetTextureTiling() { return  uvGen->GetTextureTiling(); }
		int GetUVWSource() { return uvGen->GetUVWSource(); }
		int GetMapChannel () { return uvGen->GetMapChannel (); }
		UVGen *GetTheUVGen() { return uvGen; }

		// Requirements
		ULONG LocalRequirements(int subMtlNum) {
			return uvGen->Requirements(subMtlNum); 
			}

		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			uvGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() {return NSUBTEX;}
		Texmap* GetSubTexmap(int i) {return subTex[i];}		
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		void InitSlotType(int sType) {if (uvGen) uvGen->InitSlotType(sType);}

		Class_ID ClassID() {return gradClassID;}
		SClass_ID SuperClassID() {return TEXMAP_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_RB_GRADIENT);}
		void DeleteThis() {delete this;}

		// from Animatable
		int NumSubs() {return NUM_REFS;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

		// From ref
 		int NumRefs() {return NUM_REFS;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave); 
};

// JBW: need to use the new ClassDesc2 for ParamBlock2 classes
class GradientClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new Gradient;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_GRADIENT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return TEXMAP_CLASS_ID;}
	Class_ID 		ClassID() {return gradClassID;}
	const TCHAR* 	Category() {return TEXMAP_CAT_2D;}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Gradient"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static GradientClassDesc gradCD;
ClassDesc* GetGradientDesc() { return &gradCD; }
ParamDlg* Gradient::uvGenDlg;	
ParamDlg* Gradient::texoutDlg;

//-----------------------------------------------------------------------------
//  GradSampler
//-----------------------------------------------------------------------------
AColor GradSampler::SampleFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	return grad->EvalFunction(sc, u, v, du, dv);
	}

AColor GradSampler::Sample(ShadeContext& sc, float u,float v) {
	return grad->EvalFunction(sc, u, v, 0.0f, 0.0f);
	}


class GradientDlgProc : public ParamMap2UserDlgProc 
	{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { return FALSE; }
		void SetThing(ReferenceTarget *m) {	
			Gradient *theGrad = (Gradient *)m;
			if (theGrad) theGrad->EnableStuff();
			}
		void DeleteThis() { }
	};

static GradientDlgProc gradientDlgProc;

class GradientPBAccessor : public PBAccessor
	{
	public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
		{
		Gradient* p = (Gradient*)owner;
		p->EnableStuff();
		}
	};
	
static GradientPBAccessor gradient_accessor;

//-----------------------------------------------------------------------------
//  Gradient
//-----------------------------------------------------------------------------

//JBW: here is the new ParamBlock2 descriptor. There is only one block for Gradients, a per-instance block.
// for the moment, some of the parameters a Tab<>s to test the Tab system.  Aslo note that all the References kept
// kept in a Gradient are mapped here, marked as P_OWNERS_REF so that the paramblock accesses and maintains them
// as references on owning Gradient.  You need to specify the refno for these owner referencetarget parameters.
// I even went so far as to expose the UVW mapping and Texture Output sub-objects this way so that they can be
// seen by the scripter and the schema-viewer

// shader rollout dialog proc

// per instance gradient block
static ParamBlockDesc2 grad_param_blk ( grad_params, _T("parameters"),  0, &gradCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_GRADIENT, IDS_RB_GRADIENTPARAMS, 0, 0, &gradientDlgProc, 
	// params
	grad_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_GRAD_COL1, 
		end,
	grad_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.5,0.5,0.5), 
		p_ui,			TYPE_COLORSWATCH, IDC_GRAD_COL2, 
		end,
	grad_color3,	 _T("color3"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR3,	
		p_default,		Color(1.0,1.0,1.0),
		p_ui,			TYPE_COLORSWATCH, IDC_GRAD_COL3, 
		end,
	grad_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		MAP1_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_GRAD_TEX1,
		end,
	grad_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		MAP2_REF,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_GRAD_TEX2,
		end,
	grad_map3,		_T("map3"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP3,
		p_refno,		MAP3_REF,
		p_subtexno,		2,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_GRAD_TEX3,
		end,
	grad_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	grad_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	grad_map3_on,	_T("map3Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP3ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON3,
		end,
	grad_center,	_T("color2Pos"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_CENTER2,
		p_default,		0.5,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_CENTER, IDC_GRAD_CENTERSPIN, SPIN_AUTOSCALE, 
		end,
	grad_type,		_T("gradientType"),	TYPE_INT,				0,			IDS_GRAD_TYPE,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_GRAD_LINEAR, IDC_GRAD_RADIAL, 
		end,
	grad_amount,	_T("noiseAmount"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NOISEAMT,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_AMOUNT, IDC_GRAD_AMOUNTSPIN, 0.1, 
		end,
	grad_noise_type, _T("noiseType"), TYPE_INT,				0,				IDS_NOISE_TYPE,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_GRAD_REGULAR, IDC_GRAD_FRACT, IDC_GRAD_TURB,
		p_accessor,		&gradient_accessor,
		end,
	grad_size,		_T("noiseSize"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NOISESIZE,
		p_default,		1.0,
		p_range,		0.0, 999999999.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_SIZE, IDC_GRAD_SIZESPIN, 0.1, 
		end,
	grad_phase,		_T("noisePhase"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NSPHS,
		p_default,		0.0,
		p_range,		0.0, 999999999.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_PHASE, IDC_GRAD_PHASESPIN, 0.1, 
		end,
	grad_levels,	_T("noiseLevels"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NSLEV,
		p_default,		4.0,
		p_range,		0.0, 10.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_LEVELS, IDC_GRAD_LEVELSSPIN, 0.05, 
		end,
	grad_low_thresh, _T("noiseThresholdLow"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_LOWTHRESH,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_LOWTHRESH, IDC_GRAD_LOWTHRESHSPIN, 0.005, 
		end,
	grad_high_thresh, _T("noiseThresholdHigh"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_HIGHTHRESH,
		p_default,		1.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_HIGHTHRESH, IDC_GRAD_HIGHTHRESHSPIN, 0.005, 
		end,
	grad_thresh_smooth, _T("noiseThresholdSMooth"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_THRESHOLDSMOOTHING,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAD_THRESHSMOOTH, IDC_GRAD_THRESHSMOOTHSPIN, 0.005, 
		end,
	grad_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		UVGEN_REF, 
		end,
	grad_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_OUTPUT,
		p_refno,		TEXOUT_REF, 
		end,
	end
	);

// JBW: the old version ParamBlockDescID arrays are used to permit old version Gradients to be 
// loaded.  Note that the ID in each DescID is replaced with the ParamBlock2 ID so that the 
// automatic post-load callback canfix things up properly

#define GRADIENT_VERSION 4

static ParamBlockDescID pbdesc1[] = {	
	{ TYPE_POINT3, NULL, TRUE, grad_color1 }, 	// col1
	{ TYPE_POINT3, NULL, TRUE, grad_color2 }, 	// col2
	{ TYPE_POINT3, NULL, TRUE, grad_color3 }, 	// col3
	{ TYPE_INT, NULL, FALSE, grad_type }, 		// type
	{ TYPE_FLOAT, NULL, TRUE, grad_amount }, 	// amount
	{ TYPE_FLOAT, NULL, TRUE, grad_size }, 		// size
	{ TYPE_FLOAT, NULL, TRUE, grad_phase }, 	// phase
	};

static ParamBlockDescID pbdesc2[] = {	
	{ TYPE_POINT3, NULL, TRUE, grad_color1 }, 	// col1
	{ TYPE_POINT3, NULL, TRUE, grad_color2 }, 	// col2
	{ TYPE_POINT3, NULL, TRUE, grad_color3 }, 	// col3
	{ TYPE_INT,    NULL, FALSE , grad_type }, 	// type
	{ TYPE_FLOAT, NULL, TRUE, grad_amount }, 	// amount
	{ TYPE_FLOAT, NULL, TRUE, grad_size }, 	// size
	{ TYPE_FLOAT, NULL, TRUE, grad_phase }, 	// phase
	{ TYPE_FLOAT, NULL, TRUE, grad_center }, 	// center
	};

static ParamBlockDescID pbdesc3[] = {	
	{ TYPE_POINT3, NULL, TRUE, grad_color1 }, 	// col1
	{ TYPE_POINT3, NULL, TRUE, grad_color2 }, 	// col2
	{ TYPE_POINT3, NULL, TRUE, grad_color3 }, 	// col3
	{ TYPE_INT,    NULL, FALSE , grad_type }, 	// type
	{ TYPE_FLOAT, NULL, TRUE, grad_amount }, 	// amount
	{ TYPE_FLOAT, NULL, TRUE, grad_size }, 		// size
	{ TYPE_FLOAT, NULL, TRUE, grad_phase }, 	// phase
	{ TYPE_FLOAT, NULL, TRUE, grad_center }, 	// center
	{ TYPE_INT, NULL, FALSE, -1 }, 				// turbulence
	{ TYPE_FLOAT, NULL, TRUE, grad_levels }, 	// levels
	};

static ParamBlockDescID pbdesc4[] = {	
	{ TYPE_POINT3, NULL, TRUE, grad_color1 }, 	// col1
	{ TYPE_POINT3, NULL, TRUE, grad_color2 }, 	// col2
	{ TYPE_POINT3, NULL, TRUE, grad_color3 }, 	// col3
	{ TYPE_INT,    NULL, FALSE , grad_type }, 	// type
	{ TYPE_FLOAT, NULL, TRUE, grad_amount }, 	// amount
	{ TYPE_FLOAT, NULL, TRUE, grad_size }, 		// size
	{ TYPE_FLOAT, NULL, TRUE, grad_phase }, 	// phase
	{ TYPE_FLOAT, NULL, TRUE, grad_center }, 	// center
	{ TYPE_INT, NULL, FALSE, grad_noise_type }, 	// noise type
	{ TYPE_FLOAT, NULL, TRUE, grad_levels }, 		// levels
	{ TYPE_FLOAT, NULL, TRUE, grad_low_thresh }, 	// low thresh
	{ TYPE_FLOAT, NULL, TRUE, grad_high_thresh }, 	// high thresh
	{ TYPE_FLOAT, NULL, TRUE, grad_thresh_smooth }, // thresh smoothing
	};

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc1, 7, 1), 	
	ParamVersionDesc(pbdesc2, 8, 2), 
	ParamVersionDesc(pbdesc3, 10, 3), 
	ParamVersionDesc(pbdesc4, 13, 4), 
	};

#define NUM_OLDVERSIONS	4

void Gradient::Init() 
	{
	if (uvGen) uvGen->Reset();
	else ReplaceReference( UVGEN_REF, GetNewDefaultUVGen());	
	if (texout) texout->Reset();
	else ReplaceReference( TEXOUT_REF, GetNewDefaultTextureOutput());
	ivalid.SetEmpty();
	}

void Gradient::Reset() 
	{
	gradCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	DeleteReference(MAP1_REF);
	DeleteReference(MAP2_REF);
	DeleteReference(MAP3_REF);
	}

void Gradient::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Gradient::Gradient() 
	{
	texHandle = NULL;
	subTex[0] = subTex[1] = subTex[2] =NULL;
	pblock    = NULL;
	uvGen     = NULL;
	texout    = NULL;
	mysamp.Set(this);
	// JBW: ask the ClassDesc to make the P_AUTO_CONSTRUCT blocks
	gradCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

void Gradient::DiscardTexHandle() 
	{
	if (texHandle) {
		texHandle->DeleteThis();
		texHandle = NULL;
		}
	}

void Gradient::ActivateTexDisplay(BOOL onoff) {
	if (!onoff) 
		DiscardTexHandle();
	}

DWORD Gradient::GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {
	if (texHandle) {
		if (texHandleValid.InInterval(t))
			return texHandle->GetHandle();
		else DiscardTexHandle();
		}
	Bitmap *bm;
	Interval v;
	Update(t,v);
	bm = BuildBitmap(thmaker.Size());
	texHandle = thmaker.CreateHandle(bm,uvGen->SymFlags());
	bm->DeleteThis();
	texHandleValid.SetInfinite();
	Color ac;
	pblock->GetValue( grad_color1, t, ac, texHandleValid );
	pblock->GetValue( grad_color2, t, ac, texHandleValid );
	pblock->GetValue( grad_color3, t, ac, texHandleValid );

	return texHandle->GetHandle();
	}

inline UWORD FlToWord(float r) {
	return (UWORD)(65535.0f*r);
	}

Bitmap *Gradient::BuildBitmap(int size) {
	float u,v;
	BitmapInfo bi;
	bi.SetName(GetString(IDS_RB_GRADTEMP));
	bi.SetWidth(size);
	bi.SetHeight(size);
	bi.SetType(BMM_TRUE_32);
	Bitmap *bm = TheManager->Create(&bi);
	if (bm==NULL) return NULL;
	PixelBuf l64(size);
	float d = 1.0f/float(size);
	v = 1.0f - 0.5f*d;
	for (int y=0; y<size; y++) {
		BMM_Color_64 *p64=l64.Ptr();
		u = 0.0f;
		for (int x=0; x<size; x++, p64++) {
			AColor c = DispEvalFunc(u,v);
			p64->r = FlToWord(c.r); 
			p64->g = FlToWord(c.g); 
			p64->b = FlToWord(c.b);
			p64->a = 0xffff; 
			u += d;
			}
		bm->PutPixels(0,y, size, l64.Ptr()); 
		v -= d;
		}
	return bm;
	}

static float junk = 1.0f;
float Gradient::NoiseFunc(Point3 p)
	{
	float res;
	switch (noiseType) {
		case NOISE_TURB: {
			float sum = 0.0f;
			float l,f = 1.0f;			
			for (l = levels; l>=1.0f; l-=1.0f) {				
				sum += (float)fabs(noise3(p*f))/f;
				f *= 2.0f;
				}
			if (l>0.0f) {				
				sum += l*(float)fabs(noise3(p*f))/f;
				}
			res = sum;
			break;
			}
			
		case NOISE_REGULAR:
			// multiply by junk (1.0) to avoid compiler bug
			res = junk*noise3(p);
			break;

		case NOISE_FRACTAL:
			if (levels==1.0f) {
				res = junk*noise3(p);
			} else {
				float sum = 0.0f;
				float l,f = 1.0f;				
				for (l = levels; l>=1.0f; l-=1.0f) {					
					sum += noise3(p*f)/f;
					f *= 2.0f;
					}
				if (l>0.0f) {					
					sum += l*noise3(p*f)/f;
					}
				res = sum;
				}
			break;
		}
	
	if (low<high) {
		res = 2.0f * sramp((res+1.0f)/2.0f,low,high,sd) - 1.0f;
		}
	return res;
	}

float Gradient::gradFunc(float u, float v) {
	float a;
	if (type==GRAD_LINEAR) {
		a = v;	
	} else {
		u-=0.5f;
		v-=0.5f;
		a = (float)sqrt(u*u+v*v)*2.0f;
		if (a>1.0f) a = 1.0f;
		}
	
	if (amount!=0.0f) {
		a += amount*NoiseFunc(Point3(u*size1+1.0f,v*size1+1.0f,phase));
		if (a<0.0f) a = 0.0f;
		if (a>1.0f) a = 1.0f;
		}
//	a = (a*a*(3-2*a));
	return a;
	}

// simplified evaluation for interactive render
AColor Gradient::DispEvalFunc(float u, float v) 
	{
	float a = gradFunc(u,v);

	if (a<center) {
		a = a/center;
		return col[2]*(1.0f-a) + col[1]*a;
	} else 
	if (a>center) {
		a = (a-center)/(1.0f-center);
		return col[1]*(1.0f-a) + col[0]*a;
	} else return col[1];
	}

AColor Gradient::EvalFunction(
		ShadeContext& sc, float u, float v, float du, float dv) 
	{	
	int n1=0, n2=0;
	float a = gradFunc(u,v);

	if (a<center) {
		a = a/center;
		n1 = 2;
		n2 = 1;		
	} else 
	if (a>center) {
		a = (a-center)/(1.0f-center);		
		n1 = 1;
		n2 = 0;
	} else {
		return (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];		
		}

	Color c1, c2;
	c1 = mapOn[n1]&&subTex[n1] ? subTex[n1]->EvalColor(sc): col[n1];	
	c2 = mapOn[n2]&&subTex[n2] ? subTex[n2]->EvalColor(sc): col[n2];
	return c1*(1.0f-a) + c2*a;
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);

AColor Gradient::EvalColor(ShadeContext& sc) {
	if (!sc.doMaps) 
		return black;
	AColor c;
	if (sc.GetCache(this,c)) 
		return c; 
	if (gbufID) sc.SetGBufferID(gbufID);
	c = texout->Filter(uvGen->EvalUVMap(sc,&mysamp));
	sc.PutCache(this,c); 
	return c;
	}

float Gradient::EvalMono(ShadeContext& sc) {
	if (!sc.doMaps) 
		return 0.0f;
	float f;
	if (sc.GetCache(this,f)) 
		return f; 
	if (gbufID) sc.SetGBufferID(gbufID);
	f = texout->Filter(uvGen->EvalUVMapMono(sc,&mysamp));
	sc.PutCache(this,f); 
	return f;
	}

Point3 Gradient::EvalNormalPerturb(ShadeContext& sc) 
	{
	Point3 dPdu, dPdv;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	Point2 dM = uvGen->EvalDeriv(sc,&mysamp);
	uvGen->GetBumpDP(sc,dPdu,dPdv);

#if 0
	// Blinn's algorithm
	Point3 N = sc.Normal();
	Point3 uVec = CrossProd(N,dPdv);
	Point3 vVec = CrossProd(N,dPdu);
	return texout->Filter(-dM.x*uVec+dM.y*vVec);
#else 
	// Lazy algorithm
	return texout->Filter(dM.x*dPdu+dM.y*dPdv);
#endif

	}

RefTargetHandle Gradient::Clone(RemapDir &remap) 
	{
	Gradient *mnew = new Gradient();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(uvGen));
	mnew->ReplaceReference(TEXOUT_REF,remap.CloneRef(texout));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->col[2] = col[2];	
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}


void Gradient::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		pblock->GetValue( grad_noise_type, 0, noiseType, FOREVER );
		if (map) {
			map->Enable(grad_levels, noiseType==NOISE_REGULAR?FALSE:TRUE);
			}
		}
	}


ParamDlg* Gradient::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  
// Here you see we create the Coordinate, Gradient and Output ParamDlgs in the desired 
// order, and then add the Coordinate and Output dlgs as secondaries to the 
// Gradient master AutoMParamDlg so it will keep them up-to-date automatically

	// create the rollout dialogs
	uvGenDlg = uvGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = gradCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(uvGenDlg);
	masterDlg->AddDlg(texoutDlg);
	EnableStuff();
	return masterDlg;
}

BOOL Gradient::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if (dlg == uvGenDlg)
		uvGenDlg->SetThing(uvGen);
	else if (dlg == texoutDlg)
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}

void Gradient::Update(TimeValue t, Interval& valid) 
	{
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		uvGen->Update(t,ivalid);
		texout->Update(t,ivalid);
		pblock->GetValue( grad_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( grad_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( grad_color3, t, col[2], ivalid );
		col[2].ClampMinMax();		
		pblock->GetValue( grad_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( grad_map2_on, t, mapOn[1], ivalid);
		pblock->GetValue( grad_map3_on, t, mapOn[2], ivalid);
		pblock->GetValue( grad_type, t, type, ivalid );
		pblock->GetValue( grad_noise_type, t, noiseType, ivalid );
		pblock->GetValue( grad_amount, t, amount, ivalid );
		pblock->GetValue( grad_size, t, size, ivalid );
		pblock->GetValue( grad_phase, t, phase, ivalid );
		pblock->GetValue( grad_center, t, center, ivalid );
		pblock->GetValue( grad_levels, t, levels, ivalid );
		pblock->GetValue( grad_high_thresh, t, high, ivalid );
		pblock->GetValue( grad_low_thresh, t, low, ivalid );
		pblock->GetValue( grad_thresh_smooth, t, smooth, ivalid );		
		if (low>high) {
			float temp = low;
			low = high;
			high = temp;
			}
		hminusl = (high-low);
		sd = hminusl*0.5f*smooth;
		if (size!=0.0f) size1 = 20.0f/size;
		else size1 = 0.0f;
		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		EnableStuff();
		}
	valid &= ivalid;
	}


RefTargetHandle Gradient::GetReference(int i) {
	switch(i) {
		case 0: return uvGen;
		case 1:	return pblock ;
		case TEXOUT_REF: return texout;
		default:return subTex[i-2];
		}
	}

void Gradient::SetReference(int i, RefTargetHandle rtarg) 
{
	switch(i) {
		case 0: uvGen = (UVGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2*)rtarg; break;
		case TEXOUT_REF: texout = (TextureOutput *)rtarg; break;
		default: 
			subTex[i-2] = (Texmap *)rtarg; 
// JBW: cause UI updating for auto-UI dialigs by calling InvalidateUI() on the Block descriptror
			grad_param_blk.InvalidateUI();
			break;
		}
}

void Gradient::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2,m);
	if (i==0)
		{
		grad_param_blk.InvalidateUI(grad_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		grad_param_blk.InvalidateUI(grad_map2);
		ivalid.SetEmpty();
		}	
	else if (i==2)
		{
		grad_param_blk.InvalidateUI(grad_map3);
		ivalid.SetEmpty();
		}	

	}

TSTR Gradient::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_RB_COLOR1); 
		case 1:  return GetString(IDS_RB_COLOR2);
		case 2:  return GetString(IDS_RB_COLOR3);
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Gradient::SubAnim(int i) {
	switch (i) {
		case 0: return uvGen;
		case 1: return pblock;
		case TEXOUT_REF: return texout;
		default: return subTex[i-2]; 
		}
	}

TSTR Gradient::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		case TEXOUT_REF: return TSTR(GetString(IDS_DS_OUTPUT));
		default: return GetSubTexmapTVName(i-2);
		}
	}

RefResult Gradient::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) 
{
	switch (message) 
	{
		case REFMSG_CHANGE:
		{
			ivalid.SetEmpty();
			if (hTarget == pblock) {
				// see if this message came from a changing parameter in the pblock,
				// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				if (hTarget != uvGen && hTarget != texout) 
					grad_param_blk.InvalidateUI(changing_param);
				if (changing_param != -1)
					DiscardTexHandle();
				}
			// notify our dependents that we've changed
			// NotifyChanged();  //DS this is redundant
			break;
		}

		case REFMSG_UV_SYM_CHANGE:
			DiscardTexHandle();  
			break;
	}
	return(REF_SUCCEED);
}

#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000

IOResult Gradient::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
// JBW: removed the MAPOFF_CHUNK saving as this is now part of the ParamBlock2
	return IO_OK;
	}	

IOResult Gradient::Load(ILoad *iload) 
{ 
	IOResult res;
	int id;
// JBW:  continue to recognize old-version chunks for map enable switches, but
// we don't write them any more (they are in the ParamBlock2)
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
			case MAPOFF_CHUNK+2:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &grad_param_blk, this, PBLOCK_REF);
	iload->RegisterPostLoadCallback(plcb);
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\matte.cpp ===
/**********************************************************************
 *<
	FILE: matte.cpp

	DESCRIPTION:  A Matte material

	CREATED BY: Dan Silva

	HISTORY:  1/13/98 Updated to Param2 by Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "notify.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

static Class_ID matteClassID(MATTE_CLASS_ID,0);

class Matte;
/*
class MatteDlg : public ParamDlg {
	public:		
		HWND hwmedit;
		IMtlParams *ip;
		Matte *theMtl;
		HWND hPanel; 
		BOOL valid;
		BOOL isActive;
		ISpinnerControl *iAmb;		
		ISpinnerControl *iReflAmt;		
		IColorSwatch *cs;		
		BOOL creating;
		TexDADMgr dadMgr;
		ICustButton *iReflBut;

		MatteDlg(HWND hwMtlEdit, IMtlParams *imp, Matte *m); 
		~MatteDlg();
		
		void EnableAlpha(HWND hWnd);
		BOOL WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);				
		void Invalidate();		
		void UpdateSubTexNames();
		void SetDepthRadios();
		void UpdateMtlDisplay() { ip->MtlChanged();  	}
		
		// methods inherited from ParamDlg:		
		void ReloadDialog();
		Class_ID ClassID() {return matteClassID;}
		BOOL KeyAtCurTime(int id); 
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theMtl; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t) {Invalidate();}
		void ActivateDlg(BOOL onOff) { cs->Activate(onOff); }
		int FindSubTexFromHWND(HWND hw) {
			return  (hw == iReflBut->GetHwnd())? 0: -1;
			}
	};
*/

#define PB_REF		0
#define REFLMAP_REF		1

//#define PB_AMB	0
//#define PB_COL	1
//#define PB_REFLAMT	2


enum { matte_params, };  // pblock ID
// grad_params param IDs
enum 
{ 
	matte_opaque_alpha,
	matte_apply_atmosphere, matte_atmosphere_depth,
	matte_receive_shadows, matte_affect_alpha,
	matte_shadow_brightness, matte_color,
	matte_reflection_amount, matte_reflection_map,
	matte_use_reflection_map
};



static Color black(0,0,0);
static Color white(1,1,1);

class Matte : public Mtl {	
	public:
//		MatteDlg *dlg;
		IParamBlock2 *pblock; 	// ref #0
		Texmap *reflmap; 	// ref #1
		IParamBlock *savepb;   // for saving pblock when saving Max R2 files
		Interval ivalid;
		float amblev,reflAmt;
		Color col;
		BOOL fogBG;
		BOOL useReflMap;
		BOOL shadowBG;
		BOOL opaque;
		BOOL shadowAlpha;
		BOOL fogObjDepth;
		int version;

		Matte(BOOL loading);
			void NotifyChanged() {NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
		~Matte();
		void SetAmbLev(float v, TimeValue t);
		void SetReflAmt(float v, TimeValue t);
		void SetShadColor(Color c, TimeValue t){  col= c;	pblock->SetValue(matte_color, t, c); }
					
	
		// From MtlBase and Mtl
		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}				
		
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE) { return black; }
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE) { return white; }
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE) { return black; }
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE){ return 0.0f; }
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE){ return 0.0f; }		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE){ return 1.0f; }
				
		void EnableStuff();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		
		void Shade(ShadeContext& sc);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		
		Class_ID ClassID() {return matteClassID; }
		SClass_ID SuperClassID() {return MATERIAL_CLASS_ID;}
		void GetClassName(TSTR& s) {s=GetString(IDS_DS_MATTE_SHADOW);}  

		void DeleteThis() {delete this;}	

		ULONG LocalRequirements(int subMtlNum) {  
			return fogBG ?(fogObjDepth?0:MTLREQ_NOATMOS):MTLREQ_NOATMOS; 
			}


		// Methods to access texture maps of material
		int NumSubTexmaps() { return 1; }
		Texmap* GetSubTexmap(int i) { return reflmap; }
		void SetSubTexmap(int i, Texmap *m) {
			ReplaceReference(REFLMAP_REF,m);
//			if (dlg) dlg->UpdateSubTexNames();
			}
		TSTR GetSubTexmapSlotName(int i) {
			return TSTR(GetString(IDS_DS_MAP)); 
			}
		int NumSubs() {return 2;} 
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		// From ref
 		int NumRefs() {return GetSavingVersion()==2000?1:2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		IOResult Save(ISave *isave); 
		IOResult Load(ILoad *iload);
		 
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

	};

class MatteClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new Matte(loading);}
	const TCHAR *	ClassName() {return GetString(IDS_DS_MATTE_SHADOW_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return MATERIAL_CLASS_ID;}
	Class_ID 		ClassID() {return matteClassID;}
	const TCHAR* 	Category() {return _T("");}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Matte"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};
static MatteClassDesc matteCD;
ClassDesc* GetMatteDesc() {return &matteCD;}


//--- MatteDlg ------------------------------------------------------
/*
static BOOL CALLBACK PanelDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	MatteDlg *dlg;
	if (msg==WM_INITDIALOG) {
		dlg = (MatteDlg*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);
		}
	else {
	    if ( (dlg = (MatteDlg *)GetWindowLong(hWnd, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	dlg->isActive = TRUE;
	int	res = dlg->WndProc(hWnd,msg,wParam,lParam);
	dlg->isActive = FALSE;
	return res;
	}


MatteDlg::MatteDlg(HWND hwMtlEdit, IMtlParams *imp, Matte *m)
	{
	dadMgr.Init(this);
	hwmedit = hwMtlEdit;
	ip      = imp;
	theMtl  = m;
	valid   = FALSE;
	iAmb  = NULL;
	iReflAmt  = NULL;
	creating = TRUE;
	iReflBut = NULL;
	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_MATTE),
		PanelDlgProc,
		GetString(IDS_DS_MATTE_SHADOW_PAR),
		(LPARAM)this);
	creating = FALSE;
	}

MatteDlg::~MatteDlg()
	{
	theMtl->dlg = NULL;	
	ReleaseISpinner(iAmb);
	ReleaseISpinner(iReflAmt);
	ReleaseIColorSwatch(cs);
	ReleaseICustButton(iReflBut);
	iReflBut = NULL;
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	}

void MatteDlg::EnableAlpha(HWND hWnd) {
	EnableWindow(GetDlgItem(hWnd,IDC_MATTE_SHADALPHA), !theMtl->opaque);
	}

BOOL MatteDlg::WndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			iAmb= SetupFloatSpinner(hWnd, IDC_MATTE_AMB_SPIN, IDC_MATTE_AMB_EDIT, 0.0f,1.0f, 0.5f,.01f);
			SetCheckBox(hWnd,IDC_MATTE_FOGBG, theMtl->fogBG);
			SetCheckBox(hWnd,IDC_MATTE_SHADOW, theMtl->shadowBG);
			SetCheckBox(hWnd,IDC_MATTE_OPAQUE, theMtl->opaque);
			SetCheckBox(hWnd,IDC_MATTE_SHADALPHA, theMtl->shadowAlpha);
			SetDepthRadios();
			EnableAlpha(hWnd);
			iReflBut = GetICustButton(GetDlgItem(hWnd,IDC_MATTE_REFL_MAP));
			iReflBut->SetDADMgr(&dadMgr);
			iReflAmt= SetupFloatSpinner(hWnd, IDC_MATTE_REFLAMT_SPIN, IDC_MATTE_REFLAMT_EDIT, 0.0f, 9999.0f, 1.0f,.01f);
			cs = GetIColorSwatch(GetDlgItem(hWnd, IDC_SHAD_COLOR),
   					theMtl->col, GetString(IDS_DS_SHAD_COLOR));
			iReflAmt->Enable(theMtl->reflmap?1:0);
			break;			

		case WM_PAINT:
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;

		case WM_COMMAND:
			if (creating) break;
			switch (LOWORD(wParam)) {
				case IDC_MATTE_FOGBG:
					theMtl->fogBG = GetCheckBox(hWnd,IDC_MATTE_FOGBG);
					break;
				case IDC_MATTE_SHADOW:
					theMtl->shadowBG = GetCheckBox(hWnd,IDC_MATTE_SHADOW);
					break;
				case IDC_MATTE_SHADALPHA:
					theMtl->shadowAlpha = GetCheckBox(hWnd,IDC_MATTE_SHADALPHA);
					break;
				case IDC_MATTE_OPAQUE:
					theMtl->opaque = GetCheckBox(hWnd,IDC_MATTE_OPAQUE);
					EnableAlpha(hWnd);
					break;
				case IDC_MATTE_FOG_BGDEPTH:
					theMtl->fogObjDepth = 0;
					SetDepthRadios();
					break;
				case IDC_MATTE_FOG_OBJDEPTH:
					theMtl->fogObjDepth = 1;
					SetDepthRadios();
					break;
				case IDC_MATTE_REFL_MAP: 	
					PostMessage(hwmedit,WM_TEXMAP_BUTTON, 0 ,(LPARAM)theMtl);	
					break;
				}
			break;
		

		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			break;

		case CC_COLOR_CHANGE: {
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			if (buttonUp) theHold.Begin();
			theMtl->SetShadColor(cs->GetColor(),ip->GetTime());
			cs->SetKeyBrackets(KeyAtCurTime(PB_COL));
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				UpdateMtlDisplay();
				theMtl->NotifyChanged();
				}
			break;
			}


		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (LOWORD(wParam)) {
				case IDC_MATTE_AMB_SPIN: {
					ISpinnerControl *spin = (ISpinnerControl*)lParam;
					theMtl->SetAmbLev(spin->GetFVal(),ip->GetTime());
					spin->SetKeyBrackets(KeyAtCurTime(PB_AMB));
 					break; 
					}
				case IDC_MATTE_REFLAMT_SPIN: {
					ISpinnerControl *spin = (ISpinnerControl*)lParam;
					theMtl->SetReflAmt(spin->GetFVal(),ip->GetTime());
					spin->SetKeyBrackets(KeyAtCurTime(PB_REFLAMT));
 					break; 
					}
				}
			break; // DS 4/11/96
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();			
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void MatteDlg::Invalidate()
	{
	valid = FALSE;
	isActive = FALSE;
	Rect rect;	
	rect.left = rect.top = 0;
	rect.right = rect.bottom = 10;
	InvalidateRect(hPanel,&rect,FALSE);	
	}

void MatteDlg::UpdateSubTexNames() {
	TSTR nm;
	if (theMtl->reflmap)  nm = theMtl->reflmap->GetFullName();
	else nm = GetString(IDS_DS_NONE);
	iReflBut->SetText(nm.data());
	}

void MatteDlg::SetDepthRadios() {
	int id = theMtl->fogObjDepth?IDC_MATTE_FOG_OBJDEPTH:IDC_MATTE_FOG_BGDEPTH; 
	CheckRadioButton(hPanel,IDC_MATTE_FOG_BGDEPTH,IDC_MATTE_FOG_OBJDEPTH,id); 
	}
			
void MatteDlg::SetThing(ReferenceTarget *m) {
	theMtl = (Matte*)m;
	if (theMtl) theMtl->dlg = this;
	ReloadDialog();   //DS 11/9/96
	}

BOOL MatteDlg::KeyAtCurTime(int id) { 
	return theMtl->pblock->KeyFrameAtTime(id,ip->GetTime()); 
	}

void MatteDlg::ReloadDialog()
	{
	Interval valid;
	theMtl->Update(ip->GetTime(), valid);
	iAmb->SetValue(theMtl->amblev,FALSE);
	iReflAmt->SetValue(theMtl->reflAmt,FALSE);
	cs->SetColor(theMtl->col);
	SetCheckBox(hPanel,IDC_MATTE_FOGBG, theMtl->fogBG);
	SetCheckBox(hPanel,IDC_MATTE_SHADOW, theMtl->shadowBG);
	SetCheckBox(hPanel,IDC_MATTE_SHADALPHA, theMtl->shadowAlpha);
	SetCheckBox(hPanel,IDC_MATTE_OPAQUE, theMtl->opaque);
	cs->SetKeyBrackets(KeyAtCurTime(PB_COL));
	iAmb->SetKeyBrackets(KeyAtCurTime(PB_AMB));
	iReflAmt->SetKeyBrackets(KeyAtCurTime(PB_REFLAMT));
	iReflAmt->Enable(theMtl->reflmap?1:0);

	SetDepthRadios();
	UpdateSubTexNames();
	}
*/


// shader rollout dialog proc
class MatteDlgProc : public ParamMap2UserDlgProc 
	{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { return FALSE; }
		void SetThing(ReferenceTarget *m) {	
			Matte *mtl = (Matte *)m;
			if (mtl) mtl->EnableStuff();
			}
		void DeleteThis() { }
	};

static MatteDlgProc matteDlgProc;

class MattePBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		Matte* p = (Matte*)owner;
		if (p!=NULL) {
			IParamMap2 *map = p->pblock->GetMap();
			if (map) {
				switch (id)	{
					case matte_opaque_alpha:
						map->Enable(matte_affect_alpha, v.i? FALSE: TRUE);
						break;
					case matte_reflection_map:
				   		map->Enable(matte_reflection_amount, v.r?TRUE: FALSE);
						break;
					}
				}
			}

	}
};

static MattePBAccessor matte_accessor;



static ParamBlockDesc2 matte_param_blk ( matte_params, _T("parameters"),  0, &matteCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PB_REF, 
	//rollout
	IDD_MATTE, IDS_DS_MATTE_SHADOW_PAR, 0, 0, &matteDlgProc, 
	// params
	matte_opaque_alpha,	_T("opaqueAlpha"), TYPE_BOOL,			0,				IDS_PW_OALPHA,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MATTE_OPAQUE,
		p_accessor,		&matte_accessor,
		end,

	matte_apply_atmosphere,	_T("applyAtmosphere"), TYPE_BOOL,			0,				IDS_PW_APPLYATMOS,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MATTE_FOGBG,
		end,
	matte_atmosphere_depth, _T("atmosphereDepth"), TYPE_INT,				0,				IDS_PW_ATMOSDEPTH,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_MATTE_FOG_BGDEPTH, IDC_MATTE_FOG_OBJDEPTH,
		end,
	matte_receive_shadows,	_T("receiveShadows"), TYPE_BOOL,			0,				IDS_PW_RECEIVESHADOWS,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MATTE_SHADOW,
		end,
	matte_affect_alpha,	_T("affectAlpha"), TYPE_BOOL,			0,				IDS_PW_AFFECTALPHA,
		p_default,		FALSE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MATTE_SHADALPHA,
		p_enabled,		FALSE,
		end,
	matte_shadow_brightness,	_T("shadowBrightness"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SHADOW_BRITE,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MATTE_AMB_EDIT, IDC_MATTE_AMB_SPIN, 0.1, 
		end, 
	matte_color, _T("color"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_SHAD_COLOR,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_SHAD_COLOR, 
		end,
	matte_reflection_amount,	_T("amount"), TYPE_PCNT_FRAC,	P_ANIMATABLE,	IDS_DS_REFLAMT,
		p_default,		0.5,
		p_range,		0.0, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_MATTE_REFLAMT_EDIT, IDC_MATTE_REFLAMT_SPIN, 0.1, 

		end,  
	matte_reflection_map, _T("map"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_DS_MAP,
		p_refno,		REFLMAP_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MATTE_REFL_MAP,
		p_accessor,		&matte_accessor,

		end,
	matte_use_reflection_map,	_T("useReflMap"), TYPE_BOOL, 		0,	 IDS_DS_USEREFL,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MATTE_USEREFL,
		end,

	end
	);

//--- Matte Material -------------------------------------------------


static ParamBlockDescID pbdesc0[] = {
	{TYPE_FLOAT, NULL, TRUE,matte_shadow_brightness }};   // ambient light level


static ParamBlockDescID pbdesc1[] = {
	{TYPE_FLOAT, NULL, TRUE,matte_shadow_brightness },
	{TYPE_RGBA, NULL, TRUE ,matte_color }
	};   

static ParamBlockDescID pbdesc[] = {
	{TYPE_FLOAT, NULL, TRUE,matte_shadow_brightness },
	{TYPE_RGBA,  NULL, TRUE,matte_color },
	{TYPE_FLOAT, NULL, TRUE,matte_reflection_amount }
	};   

#define MATTE_VERSION 3
#define NUM_OLDVERSIONS	3
#define NPARAMS 3

// Array of old versions
static ParamVersionDesc versions[NUM_OLDVERSIONS] = {
	ParamVersionDesc(pbdesc0,1,0),	
	ParamVersionDesc(pbdesc1,2,1),
	ParamVersionDesc(pbdesc,3,2)	
	};


//static ParamVersionDesc curVersion(pbdesc,NPARAMS,MATTE_VERSION);

// Code for saving Max R2 files -------------------
/*
static void NotifyPreSaveOld(void *param, NotifyInfo *info) {
	Matte *mt = (Matte *)param;
	if (GetSavingVersion()==2000) {
		mt->savepb = mt->pblock;
		mt->pblock = UpdateParameterBlock(pbdesc,3,mt->savepb,pbdesc1,2,1);
		}
	}

static void NotifyPostSaveOld(void *param, NotifyInfo *info) {
	Matte *mt = (Matte *)param;
	if (mt->savepb) {
		mt->pblock->DeleteThis();
		mt->pblock = mt->savepb;
		mt->savepb = NULL;
		}
	}
	*/
//----------------------------------------------------------------

Matte::Matte(BOOL loading)
	{	
//	dlg = NULL;
	pblock = NULL;
	savepb = NULL;  // for saving pblock when saving Max R2 files
	reflmap = NULL;
	ivalid.SetEmpty();
	fogBG = FALSE;    // DS 11/9/96
	shadowBG = FALSE;
	shadowAlpha = FALSE;
	opaque = FALSE;
	fogObjDepth = FALSE;
	
//	RegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
//	RegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);

	matteCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	}

Matte::~Matte() {
//  UnRegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
//	InRegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);
	}

void Matte::Init()
	{
	SetAmbLev(0.0f,0);
	SetShadColor(Color(0.0f,0.0f,0.0f), TimeValue(0));
	fogBG = FALSE;
	shadowBG = FALSE;
	shadowAlpha = FALSE;
	opaque = TRUE;
	fogObjDepth = FALSE;
	}
		
void Matte::Reset()
	{
	matteCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}
		
void Matte::SetAmbLev(float v, TimeValue t) {
    amblev= v;
	pblock->SetValue( matte_shadow_brightness, t, v);
	}

void Matte::SetReflAmt(float v, TimeValue t) {
    reflAmt= v;
	pblock->SetValue( matte_reflection_amount, t, v);
	}


void Matte::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		if (map) {
			map->Enable(matte_reflection_amount, reflmap?TRUE:FALSE);
			map->Enable(matte_affect_alpha, opaque?FALSE:TRUE);
			}
		}
	}

ParamDlg* Matte::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	// create the rollout dialogs
	IAutoMParamDlg* masterDlg = matteCD.CreateParamDlgs(hwMtlEdit, imp, this);

	EnableStuff();

	return masterDlg;

//	dlg = new MatteDlg(hwMtlEdit, imp, this);
//	return dlg;     
	}


Color DiffuseIllum(ShadeContext &sc) { 
	Point3 N = sc.Normal();
	Point3 P = sc.P();
	Color diffwk(0,0,0);
	Color lightCol;
	for (int i = 0; i<sc.nLights; i++) {
		LightDesc* l = sc.Light(i);
		register float dot_nl,diffCoef;
		Point3 L;
		if (!l->Illuminate(sc, N, lightCol, L, dot_nl,diffCoef))
			continue;
		if (dot_nl>0.0f)	  
			diffwk += diffCoef*lightCol;
		}
	return diffwk;
	}


static Color blackCol(0.0f,0.0f,0.0f);

#define CLAMP(x) (((x)>1.0f)?1.0f:((x)<0.0f)?0.0f:(x))

static inline void Clamp(Color &c) {
	c.r = CLAMP(c.r);
	c.g = CLAMP(c.g);
	c.b = CLAMP(c.b);
	}

void Matte::Shade(ShadeContext& sc)
	{
	Color c,t;
	float atten;
	if (gbufID) sc.SetGBufferID(gbufID);
	
	if (!opaque) sc.Execute(0x1000); // DS: 6/24/99:use black bg when AA filtering (#192348)
	sc.GetBGColor(c,t,fogBG&&(!fogObjDepth));
	if (!opaque) sc.Execute(0x1001); // DS: 6/24/99:use black bg when AA filtering (#192348)


	if (shadowBG&&sc.shadow) {
		sc.shadow = 0;
		Color col0 = DiffuseIllum(sc);
		sc.shadow = 1;
		Color scol = DiffuseIllum(sc);
		float f = Intens(col0);
		atten = (f>0.0f)?Intens(scol)/f:1.0f;
		if (atten>1.0f) atten = 1.0f/atten;
		atten = amblev+(1.0f-amblev)*atten;
		sc.out.c = c*atten + (1.0f-atten)*col;
		if (shadowAlpha)
			t *= atten;
		}
	else 
		sc.out.c  = c;
	sc.out.t = opaque? black: t ; 
	if (reflmap&&useReflMap) {
		AColor rcol;
		if (reflmap->HandleOwnViewPerturb()) {
			sc.TossCache(reflmap);
			rcol = reflmap->EvalColor(sc);
			}
		else 
			rcol = sc.EvalEnvironMap(reflmap, sc.ReflectVector());
		Color rc;
		rc = Color(rcol.r,rcol.g,rcol.b)*reflAmt;
		sc.out.c += rc;
		}
	Clamp(sc.out.t);
	}

void Matte::Update(TimeValue t, Interval& valid)
	{	
	ivalid = FOREVER;
	pblock->GetValue(matte_shadow_brightness,t,amblev,ivalid);
	pblock->GetValue(matte_color,t,col,ivalid);
	pblock->GetValue(matte_reflection_amount,t,reflAmt,ivalid);


	pblock->GetValue(matte_opaque_alpha,t,opaque,ivalid);
	pblock->GetValue(matte_apply_atmosphere,t,fogBG,ivalid);
	pblock->GetValue(matte_receive_shadows,t,shadowBG,ivalid);
	pblock->GetValue(matte_affect_alpha,t,shadowAlpha,ivalid);
	pblock->GetValue(matte_atmosphere_depth,t,fogObjDepth,ivalid);
	pblock->GetValue( matte_use_reflection_map,t, useReflMap, ivalid);
	if (reflmap&&useReflMap)
		reflmap->Update(t,ivalid);
	EnableStuff();

	valid &= ivalid;
	}

Interval Matte::Validity(TimeValue t)
	{
	Interval valid = FOREVER;	
	Update(t,valid);
	return valid;
	}

Animatable* Matte::SubAnim(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return reflmap;
		default: return NULL;
		}
	}

TSTR Matte::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_DS_PARAMETERS);
		case 1: return GetString(IDS_DS_MAP);
		default: return _T("");
		}
	}

RefTargetHandle Matte::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return reflmap;
		default: return NULL;
		}
	}

void Matte::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		case 1: reflmap = (Texmap*)rtarg; 
//			matte_param_blk.InvalidateUI();

			break;
		}
	}

RefTargetHandle Matte::Clone(RemapDir &remap)
	{
	Matte *mtl = new Matte(FALSE);
	*((MtlBase*)mtl) = *((MtlBase*)this);  // copy superclass stuff
	mtl->ReplaceReference(PB_REF,remap.CloneRef(pblock));
	mtl->fogBG = fogBG;
	mtl->shadowBG = shadowBG;
	mtl->shadowAlpha = shadowAlpha;
	mtl->opaque = opaque;
	mtl->fogObjDepth = fogObjDepth;
	mtl->useReflMap = useReflMap;
	if (reflmap)
		mtl->ReplaceReference(REFLMAP_REF,remap.CloneRef(reflmap));
	return mtl;
	}

RefResult Matte::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (hTarget = pblock)
				{
				ivalid.SetEmpty();
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				matte_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

//			if (hTarget==pblock) ivalid.SetEmpty();
//			if (dlg && dlg->theMtl==this&& !dlg->isActive) dlg->Invalidate();
//			if (dlg && dlg->iReflAmt)
//				dlg->iReflAmt->Enable(reflmap?1:0);
			break;
		
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_AMB: 
				case PB_REFLAMT: gpd->dim = defaultDim; break;
				case PB_COL: gpd->dim = stdColor255Dim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_AMB: gpn->name = TSTR(GetString(IDS_DS_SHADOW_BRITE)); break;
				case PB_REFLAMT: gpn->name = TSTR(GetString(IDS_DS_REFLAMT)); break;
				case PB_COL: gpn->name= GetString(IDS_DS_SHAD_COLOR); break;
					 break;
				}
			return REF_STOP; 
			}
*/
		}
	return REF_SUCCEED;
	}


#define MTL_HDR_CHUNK 0x4000
#define FOGBG_CHUNK 0x0001
#define SHADOWBG_CHUNK 0x0002
#define MATTE_VERSION_CHUNK 0003
#define OPAQUE_CHUNK 0x0004
#define FOG_OBJDEPTH_CHUNK 0x0005
#define SHADALPHA_CHUNK 0x0010

IOResult Matte::Save(ISave *isave) { 
	ULONG nb;
	isave->BeginChunk(MTL_HDR_CHUNK);
	IOResult res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
/*
	if (fogBG) {
		isave->BeginChunk(FOGBG_CHUNK);
		isave->EndChunk();
		}
	if (shadowBG) {
		isave->BeginChunk(SHADOWBG_CHUNK);
		isave->EndChunk();
		}
	if (shadowAlpha) {
		isave->BeginChunk(SHADALPHA_CHUNK);
		isave->EndChunk();
		}
	if (opaque) {
		isave->BeginChunk(OPAQUE_CHUNK);
		isave->EndChunk();
		}
	if (fogObjDepth) {
		isave->BeginChunk(FOG_OBJDEPTH_CHUNK);
		isave->EndChunk();
		}
*/
	int vers = 2;

	isave->BeginChunk(MATTE_VERSION_CHUNK);
	isave->Write(&vers, sizeof(vers), &nb);
	isave->EndChunk();

	return IO_OK;
	}

//watje
class MattePostLoadCallback:public  PostLoadCallback
{
public:
	Matte      *s;
	MattePostLoadCallback(Matte *r) {s=r;}
	void proc(ILoad *iload);
};


void MattePostLoadCallback::proc(ILoad *iload)
{

	s->pblock->SetValue(matte_opaque_alpha,0,s->opaque);
	s->pblock->SetValue(matte_apply_atmosphere,0,s->fogBG);
	s->pblock->SetValue(matte_receive_shadows,0,s->shadowBG);
	s->pblock->SetValue(matte_affect_alpha,0,s->shadowAlpha);
	s->pblock->SetValue(matte_atmosphere_depth,0,s->fogObjDepth);

	delete this;

}
 


IOResult Matte::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	version = 0;
	IOResult res;
	
	opaque = FALSE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				ivalid.SetEmpty();
				break;
			case FOGBG_CHUNK:
				fogBG = TRUE;
				break;
			case SHADOWBG_CHUNK:
				shadowBG = TRUE;
				break;
			case SHADALPHA_CHUNK:
				shadowAlpha = TRUE;
				break;
			case OPAQUE_CHUNK:
				opaque = TRUE;
				break;
			case FOG_OBJDEPTH_CHUNK:
				fogObjDepth = TRUE;
				break;
			case MATTE_VERSION_CHUNK:
				iload->Read(&version,sizeof(int), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	if (version  < 2)
		{

	// JBW: register old version ParamBlock to ParamBlock2 converter
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &matte_param_blk, this, PB_REF);
		iload->RegisterPostLoadCallback(plcb);

		MattePostLoadCallback* matteplcb = new MattePostLoadCallback(this);
		iload->RegisterPostLoadCallback(matteplcb);
		}


//	iload->RegisterPostLoadCallback(
//		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PB_REF));
	return IO_OK;
                                                      
	}

//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mtldefs.h ===
/**********************************************************************
 *<
	FILE: mtldefs.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MTLDEFS__H
#define __MTLDEFS__H




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\output.cpp ===
/**********************************************************************
 *<
	FILE: OUTPUT.CPP

	DESCRIPTION: OUTPUT Composite.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;



#define NSUBTEX 1    // number of texture map slots

static Class_ID outputClassID(OUTPUT_CLASS_ID,0);

static int subTexId[NSUBTEX] = { IDC_OUT_MAP};
enum { output_params };  // pblock ID
// output_params param IDs
enum 
{ 
	output_map1,
	output_map1_on, // main grad params 
	output_output
};


//--------------------------------------------------------------
// Output: A Composite texture map
//--------------------------------------------------------------
class Output: public Texmap { 
	Texmap* subTex[NSUBTEX];  // ref 0
	TextureOutput *texout; // ref 1

	Interval ivalid;
	BOOL rollScroll;
	public:
		BOOL Param1;
		static ParamDlg* texoutDlg;
		IParamBlock2 *pblock;   // ref #2	
		BOOL mapOn[NSUBTEX];

		Output();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void NotifyChanged();

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return outputClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_OUTPUT); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 3; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 3; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);


	};

class OutputClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Output; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_OUTPUT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return outputClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COLMOD;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("output"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static OutputClassDesc maskCD;

ClassDesc* GetOutputDesc() { return &maskCD;  }

//-----------------------------------------------------------------------------
//  Output
//-----------------------------------------------------------------------------

ParamDlg* Output::texoutDlg;


static ParamBlockDesc2 output_param_blk ( output_params, _T("parameters"),  0, &maskCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 2, 
	//rollout
	IDD_OUTPUT, IDS_DS_OUTPUTPARAMS, 0, 0, NULL, 
	// params
	output_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		0,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_OUT_MAP,
		end,
	output_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	output_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_OUTPUT,
		p_refno,		1, 
		end,

	end
);

void Output::Init() {
	ivalid.SetEmpty();
	if (texout) texout->Reset();
	else ReplaceReference( 1, GetNewDefaultTextureOutput());	
	texout->SetRollupOpen(1);
	mapOn[0] = 1;
	}

void Output::Reset() {
	DeleteReference(0);	// get rid of map
	Init();
	maskCD.Reset(this, TRUE);	// reset all pb2's
	}

void Output::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Output::Output() {
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	texout   = NULL;
	maskCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}


static AColor white(1.0f,1.0f,1.0f,1.0f);

AColor Output::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	return texout->Filter((subTex[0]&&mapOn[0])? subTex[0]->EvalColor(sc): white);
	}

float Output::EvalMono(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	return texout->Filter((subTex[0]&&mapOn[0])? subTex[0]->EvalMono(sc): 1.0f);
	}

Point3 Output::EvalNormalPerturb(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	return texout->Filter((subTex[0]&&mapOn[0])? subTex[0]->EvalNormalPerturb(sc): Point3(0,0,0));
	}

RefTargetHandle Output::Clone(RemapDir &remap) {
	Output *mnew = new Output();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(1,remap.CloneRef(texout));
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Output::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// create the rollout dialogs
	IAutoMParamDlg* masterDlg = maskCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(texoutDlg);
	return masterDlg;

	}

BOOL Output::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((texoutDlg!= NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}


void Output::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( output_map1_on, 0, mapOn[0]);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		texout->Update(t,ivalid);
		pblock->GetValue( output_map1_on, t, mapOn[0], ivalid);

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

RefTargetHandle Output::GetReference(int i) {
	if (i==0) return subTex[0];
	else if (i==1) return texout;
	else  return pblock;

	}

void Output::SetReference(int i, RefTargetHandle rtarg) {
	if (i==0) subTex[0] = (Texmap *)rtarg; 
	else if (i==1) texout = (TextureOutput *)rtarg;
	else pblock = (IParamBlock2 *)rtarg;
	}

void Output::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i,m);
	if (i==0)
		{
		output_param_blk.InvalidateUI(output_map1);
		ivalid.SetEmpty();
		}	

	}

TSTR Output::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_MAP)); 
		default: assert(0); return TSTR(_T(""));
		}
	}
	 
Animatable* Output::SubAnim(int i) {
	switch(i) {
		case 0: return subTex[0];
		case 1: return texout;
		case 2: return pblock;
		default: assert(0); return NULL;
		}
	}

TSTR Output::SubAnimName(int i) {
	switch (i) {
		case 0: return GetSubTexmapTVName(0);
		case 1: return TSTR(GetString(IDS_DS_OUTPUT));
		case 2: TSTR(GetString(IDS_DS_PARAMETERS));		
		default: assert(0); return _T("");
		}
	}

RefResult Output::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != pblock && hTarget != texout ) 
					output_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}
			else if (hTarget == texout ) 
				{
				// NotifyChanged();  //DS this is redundant
				}


			break;

		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Output::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();


	return IO_OK;
	}	
	  
class OutputPostLoad : public PostLoadCallback {
	public:
		Output *n;
		OutputPostLoad(Output *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->Param1)
				{
				n->pblock->SetValue( output_map1_on, 0, n->mapOn[0]);
				}
			delete this; 


			} 
	};


IOResult Output::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	int id;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE; 
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

//	iload->RegisterPostLoadCallback(new OutputPostLoad(this));

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mtlres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mtl.rc
//
#define IDS_DS_RGBAMT                   1
#define IDS_DS_RGBOFF                   2
#define IDS_PW_COMPOSITE_MATERIAL       3
#define IDS_PW_TYPE                     4
#define IDS_PW_AMOUNT                   5
#define IDD_COPYTEXMAP                  104
#define IDD_MULTI_SETNUM                105
#define IDB_BITMAP1                     106
#define IDD_DIALOG1                     107
#define IDD_BRITECON_EFFECT             108
#define IDD_DMTL_BASIC2                 109
#define IDD_DMTL_BASIC3                 110
#define IDD_DMTL_EXTRA3                 111
#define IDD_DMTL_BASIC4                 112
#define IDD_DMTL_EXTRA4                 113
#define IDD_DMTL_BASIC5                 114
#define IDD_DMTL_EXTRA5                 115
#define IDD_DMTL_EXTRA6                 116
#define IDD_DMTL_BASIC6                 117
#define IDD_DMTL_SHADER1                118
#define IDD_DMTL_SAMPLING1              119
#define IDD_DMTL_BASIC7                 120
#define IDD_DMTL_SHADER2                121
#define IDB_DMTL_BUTTONS                122
#define IDD_DMTL_SHADER3                122
#define IDB_DMTL_MASKBUTTONS            123
#define IDD_DMTL_TEXMAP2                123
#define IDD_DMTL_BASIC_ONB              124
#define IDD_DMTL_SHADER4                125
#define IDD_DMTL_BASIC_ONB2             126
#define IDD_DMTL_BASIC_WARD1            127
#define IDI_ICON1                       128
#define IDB_PRESET_RECORD               129
#define IDB_PRESET_DELETE               130
#define IDD_DMTL_BASIC_WARD2            131
#define IDD_DMTL_BASIC_WARD3            134
#define IDD_DMTL_TEXMAP3                136
#define IDD_DMTL_BASIC_WARD4            137
#define IDD_DMTL_SHADER5                138
#define IDD_DMTL_BASIC_STRAUSS1         140
#define IDD_DMTL_BASIC_STRAUSS2         141
#define IDD_DMTL_BASIC_SCHLICK1         142
#define IDD_DMTL_BASIC_SCHLICK2         143
#define IDD_DMTL_BASIC_MULTILAYER       144
#define IDD_DMTL_TEXMAP4                145
#define IDD_DMTL_BASIC_MULTILAYER1      146
#define IDD_DMTL_STRAUSS3               147
#define IDD_DMTL_STRAUSS4               148
#define IDD_DMTL_BASIC_STRAUSS3         149
#define IDD_DMTL_SAMPLING2              150
#define IDD_DMTL_SAMPLING3              151
#define IDD_ATILING                     152
#define IDD_COMP_SETNUM                 192
#define IDC_SH_EDIT                     216
#define IDC_SS_EDIT                     217
#define IDC_TF_EDIT                     218
#define IDC_SOFT_EDIT                   218
#define IDC_SH_EDIT2                    218
#define IDC_SI_EDIT                     219
#define IDC_IOR_EDIT                    219
#define IDC_TR_EDIT                     220
#define IDC_DIM_AMT                     220
#define IDC_WIRE_EDIT                   221
#define IDC_DIFFLEV_EDIT                221
#define IDC_DIM_MULT                    222
#define IDC_DIM_AMT2                    222
#define IDC_DIFFROUGH_EDIT              222
#define IDC_DIFFLEV_EDIT2               222
#define IDC_USCL_EDIT                   223
#define IDC_DIM_MULT2                   223
#define IDC_DIFFREFL_EDIT               223
#define IDC_VSCL_EDIT                   224
#define IDC_DIM_MULT3                   224
#define IDC_UVANG_EDIT                  225
#define IDC_XSCL_EDIT                   225
#define IDC_UVBLUR_EDIT                 226
#define IDC_XANG_EDIT                   226
#define IDC_UVBLUROFF_EDIT              227
#define IDC_UVNOIS_AMT_EDIT             229
#define IDC_MIRNS_AMT_EDIT              229
#define IDC_UVNOIS_PER_EDIT             230
#define IDC_UVNOIS_LEV_EDIT2            231
#define IDC_SH_SPIN                     326
#define IDC_SS_SPIN                     327
#define IDC_TF_SPIN                     328
#define IDC_SOFT_SPIN                   328
#define IDC_SH_SPIN2                    328
#define IDC_SI_SPIN                     329
#define IDC_IOR_SPIN                    329
#define IDC_TR_SPIN                     330
#define IDC_DIM_AMTSPIN                 330
#define IDC_DIM_MULTSPIN                331
#define IDC_DIM_AMTSPIN2                331
#define IDC_DIFFLEV_SPIN                331
#define IDC_WIRE_SPIN                   332
#define IDC_DIFFROUGH_SPIN              332
#define IDC_DIFFLEV_SPIN2               332
#define IDC_DIM_MULTSPIN2               333
#define IDC_DIFFREFL_SPIN               333
#define IDC_USCL_SPIN                   334
#define IDC_DIM_MULTSPIN3               334
#define IDC_VSCL_SPIN                   335
#define IDC_UVANG_SPIN                  336
#define IDC_XSCL_SPIN                   336
#define IDC_UVBLUR_SPIN                 337
#define IDC_XANG_SPIN                   337
#define IDC_UVNOIS_AMT_SPIN             338
#define IDC_UVBLUROFF_SPIN              338
#define IDC_MIRNS_AMT_SPIN              338
#define IDC_UVNOISE_PER_SPIN            339
#define IDC_UVNOISE_LEV_SPIN            340
#define IDC_TOP_MTL                     1000
#define IDC_BOT_MTL                     1001
#define IDC_TR_ADD                      1003
#define IDC_CMTL_Y_EDIT                 1003
#define IDC_TR_SUB                      1002
#define IDC_CMTL_Y_SPIN                 1004
#define IDC_TR_SUB2                     1001
#define IDC_CMTL_SWAP                   1005
#define IDC_TF_IN                       1300
//#define IDC_USE_FILTER                  1006
#define IDC_TF_OUT                      1301
#define IDC_UVTYPE                      1008
#define IDC_UV_MIRROR                   1010
#define IDC_U_MIRROR                    1010
#define IDC_UOFFS_EDIT                  1011
#define IDC_UOFFS_SPIN                  1012
#define IDC_VOFFS_EDIT                  1013
#define IDC_VOFFS_SPIN                  1014
#define IDC_UV_NOISE                    1015
#define IDC_V_MIRROR                    1015
#define IDC_UV_TILE                     1016
#define IDC_XOFFS_EDIT                  1016
#define IDC_U_TILE                      1016
#define IDC_SOFTEN                      1017
#define IDC_USEMAP_DI                   1017
#define IDC_UV_AXIS_X                   1017
#define IDC_XOFFS_SPIN                  1017
#define IDC_OLD_SPEC                    1017
#define IDC_USEMAP_AM                   1018
#define IDC_UV_AXIS_Y                   1018
#define IDC_CUBE_PICK                   1018
#define IDC_UV_AXIS_Z                   1019
#define IDC_ACUBE_PICKCAM               1019
#define IDC_CHECK_TEX1                  1020
#define IDC_V_TILE                      1020
#define IDC_GRAD_TEX1                   1020
#define IDC_ATILING_TEX1                1020
#define IDC_CHECK_TEX2                  1021
#define IDC_GRAD_TEX2                   1021
#define IDC_ATILING_TEX2                1021
#define IDC_USEMAP_SI                   1022
#define IDC_CHECK_COL1                  1022
#define IDC_GRAD_COL1                   1022
#define IDC_ATILING_COL1                1022
#define IDC_CHECK_COL2                  1023
#define IDC_GRAD_COL2                   1023
#define IDC_ATILING_COL2                1023
#define IDC_R_EDIT                      1024
#define IDC_BLUR_SPIN                   1024
#define IDC_TINT_B                      1024
#define IDC_GRAD_TEX3                   1024
#define IDC_ATILING_COL3                1024
#define IDC_G_EDIT                      1025
#define IDC_CMTL_W_EDIT                 1025
#define IDC_BMTEX_RATE                  1025
#define IDC_GRAD_COL3                   1025
#define IDC_ATILING_TEX3                1025
#define IDC_B_EDIT                      1026
#define IDC_BLUR_EDIT                   1026
#define IDC_R_SPIN                      1027
#define IDC_MARB_COL1                   1027
#define IDC_G_SPIN                      1028
#define IDC_CMTL_W_SPIN                 1028
#define IDC_MARB_COL2                   1028
#define IDC_BMTEX_RATE_SPIN             1028
#define IDC_B_SPIN                      1029
#define IDC_MARB_TEX1                   1029
#define IDC_MARB_TEX2                   1030
#define IDD_DMTL_BASIC                  1031
#define IDC_WIDTH_SPIN                  1031
#define IDC_WIDTH_EDIT                  1032
#define IDD_DMTL_TEXMAP                 1033
#define IDC_MARBSIZE_EDIT               1033
#define IDC_BMTEX_NAME                  1033
#define IDD_DMTL_EXTRA                  1034
#define IDC_MARBSIZE_SPIN               1034
#define IDC_MTL_COLORS                  1035
#define IDC_AMT_OP                      1035
#define IDD_CMTL_BASIC                  1035
#define IDD_CMTL                        1035
#define IDC_FILTER_PYR                  1035
#define IDC_SPIN_OP                     1036
#define IDD_DMTL_BASIC1                 1036
#define IDC_FILTER_SAT                  1036
#define IDC_AMT_FI                      1037
#define IDD_UVGEN                       1037
#define IDC_FILTER_NADA                 1037
#define IDC_MAPON_TR                    1038
#define IDC_SPIN_BU                     1038
#define IDD_CHECKER                     1038
#define IDC_SPIN_FI                     1039
#define IDD_MARBLE                      1039
#define IDD_BMTEX                       1040
#define IDC_MIX_COL1                    1040
#define IDD_MIX                         1041
#define IDC_MIX_COL2                    1041
#define IDC_MIX_TEX1                    1042
#define IDD_NOISE                       1042
#define IDC_PIXELS                      1043
#define IDC_MIX_TEX2                    1043
#define IDD_MASK                        1043
#define IDC_ALPHA_FILE                  1043
#define IDC_UNITS                       1044
#define IDC_ALPHA_XPCOL                 1044
#define IDC_MIX_TEX3                    1044
#define IDD_TINT                        1044
#define IDC_MIX_SPIN                    1045
#define IDC_ALPHA_RGB                   1045
#define IDD_MULTI                       1045
#define IDC_ALPHA_NONE                  1046
#define IDC_MIX_EDIT                    1046
#define IDD_DOUBLESIDED                 1046
#define IDC_NOISE_COL1                  1047
#define IDD_MIXMAT                      1047
#define IDC_WIRE                        1048
#define IDC_NOISE_COL2                  1048
#define IDD_AUTO_CUBIC                  1048
#define IDC_LOCK_AD                     1049
#define IDC_MAPPAR_SP                   1049
#define IDC_NOISESIZE_SPIN              1049
#define IDD_MIRROR                      1049
#define IDC_LOCK_DS                     1050
#define IDC_MAPPAR_OP                   1050
#define IDC_NOISESIZE_EDIT              1050
#define IDD_MATTE                       1050
#define IDC_H_EDIT                      1051
#define IDC_NOISE_TEX1                  1051
#define IDC_MIXA_EDIT                   1051
#define IDD_BMTEX_TIME                  1051
#define IDC_PRESET_REC                  1051
#define IDC_S_EDIT                      1052
#define IDC_NOISE_TEX2                  1052
#define IDC_MIXA_SPIN                   1052
#define IDD_XYZGEN                      1052
#define IDC_PRESET_DEL                  1052
#define IDC_V_EDIT                      1053
#define IDC_MIXB_EDIT                   1053
#define IDD_UVNOISE                     1053
#define IDC_GRAD_TURB                   1053
#define IDC_PRESET_MORE                 1053
#define IDC_LOCK_ADTEX                  1054
#define IDC_NOISE_SWAP                  1054
#define IDC_MIXB_SPIN                   1054
#define IDD_TEXOUT                      1054
#define IDC_AMB                         1055
#define IDC_MAPPAR_SH                   1055
#define IDC_MIXCURVE                    1055
#define IDC_NOISEPHASE_EDIT             1055
#define IDD_COMPOSITEMAP                1055
#define IDC_DIFF                        1056
#define IDC_MAPPAR_SI                   1056
#define IDC_MIX_USECURVE                1056
#define IDC_NOISEPHASE_SPIN             1056
#define IDD_GRADIENT                    1056
#define IDC_SPEC                        1057
#define IDC_MAPPAR_RL                   1057
#define IDC_CHECK_SWAP                  1057
#define IDC_NOISELEV_EDIT               1057
#define IDD_DMTL_DYNAM                  1057
#define IDC_MAPPAR_SS                   1058
#define IDC_FILT                        1058
#define IDC_MARBLE_SWAP                 1058
#define IDC_NOISELEV_SPIN               1058
#define IDD_BMTEX1                      1058
#define IDD_FALLOFF                     1058
#define IDC_MAP_SS                      1059
#define IDC_COPYMAP                     1059
#define IDC_FACE_MAP                    1059
#define IDD_RGBMULT                     1059
#define IDC_MAPON_SI                    1060
#define IDC_MAP_OP                      1060
#define IDC_INSTMAP                     1060
#define IDC_MIX_SWAP                    1060
#define IDD_OUTPUT                      1060
#define IDC_FACETED                     1060
#define IDC_MAPON_SH                    1061
#define IDC_MAP_FI                      1061
#define IDC_MASK_MAP                    1061
#define IDD_VCOL                        1061
#define IDD_SAMPLE_EFFECT               1061
#define IDC_HIGHLIGHT                   1062
#define IDC_MAP_SH                      1062
#define IDC_MASK_MASK                   1062
#define IDD_PBLUR_PARAMS                1062
#define IDC_H_SPIN                      1063
#define IDC_TINT_MAP                    1063
#define IDD_PLATE                       1063
#define IDC_MAPON_SH2                   1063
#define IDC_HIGHLIGHT2                  1063
#define IDC_S_SPIN                      1064
#define IDC_TINT_R                      1064
#define IDD_RAYMAP                      1064
#define IDD_PARTAGE_PARAMS              1064
#define IDC_V_SPIN                      1065
#define IDC_TINT_G                      1065
#define IDD_VCOL1                       1065
#define IDC_SHADING                     1066
#define IDC_MAP_SI2                     1066
#define IDC_MAP_SI                      1066
#define IDD_COMPOSITE_MAT               1066
#define IDC_2SIDE                       1067
#define IDC_SUPER_SAMP                  1068
#define IDC_ADAPT_ON                    1069
#define IDC_SAMPLE_TEX                  1070
#define IDC_MAP_DI                      1071
#define IDC_MAP_SP                      1072
#define IDC_AMT_DI                      1073
#define IDC_AMT_SP                      1074
#define IDC_AMT_AM                      1075
#define IDC_AMT_BU                      1076
#define IDC_AMT_SH                      1077
#define IDC_AMT_SI                      1078
#define IDC_AMT_RL                      1079
#define IDC_AMT_RR                      1080
#define IDC_USEMAP_RR                   1081
#define IDC_USEMAP_RL                   1082
#define IDC_USEMAP_BU                   1083
#define IDC_USEMAP_OP                   1084
#define IDC_MULTI_NUMMATS               1084
#define IDC_USEMAP_SP                   1085
#define IDC_MULTI_NUMMATSSPIN           1085
#define IDC_SPIN_DI                     1086
#define IDC_MULTI_UP                    1086
#define IDC_SPIN_SP                     1087
#define IDC_MULTI_DOWN                  1087
#define IDC_2SIDE_MAT1                  1087
#define IDC_SPIN_SH                     1088
#define IDC_MULTI_PAGEUP                1088
#define IDC_2SIDE_MAT2                  1088
#define IDC_SPIN_SI                     1089
#define IDC_MULTI_PAGEDOWN              1089
#define IDC_2SIDE_TRANSLUCENCY          1089
#define IDC_SPIN_RL                     1090
#define IDC_2SIDE_TRANSLUCENCYSPIN      1090
#define IDC_MULTI_SETNUM                1090
#define IDC_SPIN_RR                     1091
#define IDC_MIXMAT_MAT1                 1091
#define IDC_MULTI_SETNUM2               1091
#define IDC_MAP_BU                      1092
#define IDC_MIXMAT_MAT2                 1092
#define IDC_MAP_RL                      1093
#define IDC_MIXMAT_MIX                  1093
#define IDC_MAP_RR                      1094
#define IDC_MIXMAT_MIXSPIN              1094
#define IDC_MAPPAR_RR                   1095
#define IDC_USEMAP_FI                   1095
#define IDC_MIXMAT_MAP                  1095
#define IDC_MAPPAR_BU                   1096
#define IDC_MIXMAT_USE1                 1096
#define IDC_USEMAP_DP                   1096
#define IDC_MAPPAR_DI                   1097
#define IDC_MIXMAT_USE2                 1097
#define IDC_ACUBE_SIZE_SPIN             1097
#define IDC_AMT_DP                      1097
#define IDC_USEMAP_SH                   1098
#define IDC_ACUBE_SIZE_EDIT             1098
#define IDC_SPIN_AM                     1099
#define IDC_ACUBE_BLUR_EDIT             1099
#define IDC_MAP_AM                      1100
#define IDC_ACUBE_BLUR_SPIN             1100
#define IDC_MAPPAR_AM                   1101
#define IDC_FIRST_ONLY                  1101
#define IDC_SPIN_DP                     1101
#define IDC_USEMAP_SS                   1102
#define IDC_EVERY_NTH                   1102
#define IDC_MAPON_AM                    1103
#define IDC_AMT_SS                      1103
#define IDC_ACUBE_NTH_EDIT              1103
#define IDC_MAPON_DI                    1104
#define IDC_SPIN_SS                     1104
#define IDC_ACUBE_NTH_SPIN              1104
#define IDC_MAPON_SP                    1105
#define IDC_ACUBE_BLUOFF_EDIT           1105
#define IDC_MAP_DP                      1105
#define IDC_MAPON_SS                    1106
#define IDC_ACUBE_BLUROFF_SPIN          1106
#define IDC_MAPON_FI                    1107
#define IDC_ACUBE_BLUR                  1107
#define IDC_MAPON_DIFF_LEVEL            1107
#define IDC_BMTEX_RELOAD                1108
#define IDC_MIR_APPLY_MTLID             1108
#define IDC_ACUBE_NEAR_EDIT             1108
#define IDC_MAPON_DIFF_ROUGH            1108
#define IDC_MAPON_DIFF_LEVEL2           1108
#define IDC_STD_COLOR1                  1109
#define IDC_ACUBE_NEAR_SPIN             1109
#define IDC_MATTE_FOGBG                 1110
#define IDC_ACUBE_FAR_EDIT              1110
#define IDC_SI_COLOR                    1110
#define IDC_MATTE_SHADOW                1111
#define IDC_ACUBE_FAR_SPIN              1111
#define IDC_MAPON_DIFF_RHO              1111
#define IDC_MATTE_AMB_SPIN              1112
#define IDC_STD_COLOR2                  1113
#define IDC_MATTE_AMB_EDIT              1113
#define IDC_STD_COLOR3                  1114
#define IDC_MATTE_OPAQUE                1114
#define IDC_YOFFS_EDIT                  1114
#define IDC_STD_COLOR4                  1115
#define IDC_MATTE_FOG_BGDEPTH           1115
#define IDC_ZOFFS_EDIT                  1115
#define IDC_MATTE_FOG_OBJDEPTH          1116
#define IDC_YOFFS_SPIN                  1116
#define IDC_GRAD_REGULAR                1116
#define IDC_STD_COLOR5                  1116
#define IDC_ZOFFS_SPIN                  1117
#define IDC_GRAD_FRACT                  1117
#define IDC_MATTE_REFLAMT_EDIT          1117
#define IDC_YSCL_EDIT                   1118
#define IDC_MATTE_REFLAMT_SPIN          1118
#define IDC_BMTEX_LOOP                  1119
#define IDC_YSCL_SPIN                   1119
#define IDC_BMTEX_PINGPONG              1120
#define IDC_ZSCL_EDIT                   1120
#define IDC_BMTEX_HOLD                  1121
#define IDC_ZSCL_SPIN                   1121
#define IDC_BMTEX_START                 1122
#define IDC_YANG_EDIT                   1122
#define IDC_BMTEX_START_SPIN            1123
#define IDC_YANG_SPIN                   1123
#define IDC_BMTEX_RGBOUT                1124
#define IDC_ZANG_EDIT                   1124
#define IDC_BMTEX_ALPHAOUT              1125
#define IDC_ZANG_SPIN                   1125
#define IDC_USE_ENVMAP                  1125
#define IDC_BMTEX_RGBOUT2               1126
#define IDC_MIR_BEHINDCAM               1126
#define IDC_UVNOIS_SIZ_EDIT             1127
#define IDC_BMTEX_ALPHAOUT2             1127
#define IDC_MIRNS_SIZ_EDIT              1127
#define IDC_UVNOIS_SIZ_SPIN             1128
#define IDC_MIRNS_SIZ_SPIN              1128
#define IDC_UVNOIS_ON                   1129
#define IDC_ALPHA_PREMULT               1129
#define IDC_MIRNS_ON                    1129
#define IDC_UVNOIS_LEV_EDIT             1130
#define IDC_CUBESRC_AUTO                1130
#define IDC_MIRNS_LEV_EDIT              1130
#define IDC_UVNOIS_LEV_SPIN             1131
#define IDC_CUBESRC_FILE                1131
#define IDC_MIRNS_LEV_SPIN              1131
#define IDC_UVNOIS_ANI                  1132
#define IDC_CUBE_UP                     1132
#define IDC_MIRNS_ANI                   1132
#define IDC_UVNOIS_ANI_SPIN             1133
#define IDC_CUBE_DN                     1133
#define IDC_MIRNS_ANI_SPIN              1133
#define IDC_UVNOIS_ANI_EDIT             1134
#define IDC_TEXOUT_INVERT               1134
#define IDC_CUBE_LF                     1134
#define IDC_MIRNS_ANI_EDIT              1134
#define IDC_OUTLEV_EDIT                 1135
#define IDC_CUBE_RT                     1135
#define IDC_OUTLEV_SPIN                 1136
#define IDC_CUBE_FR                     1136
#define IDC_OUTOFF_SPIN                 1137
#define IDC_CUBE_BK                     1137
#define IDC_OUTOFF_EDIT                 1138
#define IDC_FILE_UP                     1138
#define IDC_OUTAMT_EDIT                 1139
#define IDC_CUBE_OUTFILE                1139
#define IDC_OUTAMT_SPIN                 1140
#define IDC_FILE_DN                     1140
#define IDC_FILE_LF                     1141
#define IDC_FILE_RT                     1142
#define IDC_FILE_FR                     1143
#define IDC_FILE_BK                     1144
#define IDC_CUBE_BLUR_GRP               1145
#define IDC_CUBE_AUTO_GRP               1146
#define IDC_CUBE_FILE_GRP               1147
#define IDC_CUBE_FILE_GRP2              1148
#define IDC_CUBE_OUTFILE_NAME           1149
#define IDC_CUBE_AUTO_GRP2              1150
#define IDC_CUBE_BLUR_GRP2              1151
#define IDC_USE_UV                      1152
#define IDC_USE_VW                      1153
#define IDC_USE_WU                      1154
#define IDC_UV_MAPPING                  1156
#define IDC_CUBE_RELOAD                 1156
#define IDC_CLIP_X                      1157
#define IDC_TEXMAP                      1158
#define IDC_CLIP_XSPIN                  1158
#define IDC_ENVMAP                      1159
#define IDC_CLIP_Y                      1159
#define IDC_COORD_XYZ                   1160
#define IDC_CLIP_YSPIN                  1160
#define IDC_COORD_UVW                   1161
#define IDC_CLIP_W                      1161
#define IDC_XLABEL                      1162
#define IDC_CLIP_WSPIN                  1162
#define IDC_YLABEL                      1163
#define IDC_CLIP_H                      1163
#define IDC_ZLABEL                      1164
#define IDC_CLIP_HSPIN                  1164
#define IDC_CLIPH_SPIN                  1164
#define IDC_FALL_FAR                    1165
#define IDC_JITTER_EDIT                 1165
#define IDC_BM_CLIP                     1166
#define IDC_FALL_FAR_SPIN               1166
#define IDC_MATTE_SHADALPHA             1167
#define IDC_FALL_NEAR                   1167
#define IDC_JITTER_SPIN                 1167
#define IDC_BM_CROP_IMAGE               1168
#define IDC_FALL_NEAR_SPIN              1168
#define IDC_MATTE_USEREFL               1168
#define IDC_SHAD_COLOR                  1177
#define IDC_MTL_NAME6                   1186
#define IDC_CHKMAP1                     1191
#define IDC_ATILING_MAP1                1191
#define IDC_CHKMAP2                     1192
#define IDC_ATILING_MAP2                1192
#define IDC_BOUNCE_EDIT                 1193
#define IDC_ATILING_MAP3                1193
#define IDC_BOUNCE_SPIN                 1194
#define IDC_STATFRIC_EDIT               1195
#define IDC_STATFRIC_SPIN               1196
#define IDC_SLIDFRIC_EDIT               1197
#define IDC_CMTL_LOCAL                  1197
#define IDC_SLIDFRIC_SPIN               1198
#define IDC_CMTL_WORLD                  1198
#define IDC_INVERT_MASK                 1206
#define IDC_MULT_TEX1                   1214
#define IDC_MULT_TEX2                   1215
#define IDC_MULT_ALPHA1                 1216
#define IDC_MULT_ALPHA2                 1217
#define IDC_OUT_MAP                     1217
#define IDC_MULT_ALPHA3                 1218
#define IDC_FALLDIR_VIEW                1218
#define IDC_FALLDIR_OBJ                 1219
#define IDC_FALLDIR_X                   1220
#define IDC_FALLDIR_Y                   1221
#define IDC_FALLDIR_Z                   1222
#define IDC_FALLDIR_XW                  1223
#define IDC_FALLDIR_YW                  1224
#define IDC_FALLDIR_ZW                  1225
#define IDC_FALL_OBJNAME                1227
#define IDC_MULTI_SCROLL                1229
#define IDC_COMP_SCROLL                 1231
#define IDC_FALL_NEARNAME               1232
#define IDC_FALL_FARNAME                1233
#define IDC_FALL_PP                     1236
#define IDC_FALL_FB                     1237
#define IDC_FALLOFF_PICK                1238
#define IDC_FALL_SWAP                   1239
#define IDC_MIRNS_REG                   1251
#define IDC_MIRNS_FRAC                  1252
#define IDC_DIM_REFL                    1252
#define IDC_MIRNS_TURB                  1253
#define IDC_VC_VC                       1254
#define IDC_VC_UVW                      1255
#define IDC_PBLUR_COLOR1                1256
#define IDC_PBLUR_COLOR2                1257
#define IDC_PBLUR_SHARP                 1258
#define IDC_PBLUR_SHARPSPIN             1259
#define IDC_PLT_AMT_EDIT                1260
#define IDC_PLT_AMT_SPIN                1261
#define IDC_PLT_THK_EDIT                1262
#define IDC_PLT_THK_SPIN                1263
#define IDC_BM_CROP                     1264
#define IDC_BM_PLACE                    1265
#define IDC_BM_JITTER                   1266
#define IDC_MULT_COL1                   1267
#define IDC_MULT_COL2                   1268
#define IDC_RAY_MAXDEPTH                1268
#define IDC_RAY_MAXDEPTH_SPIN           1269
#define IDC_MIRDIST_NONE                1270
#define IDC_MIRDIST_BUMP                1271
#define IDC_MIRDIST_NOISE               1272
#define IDC_MIR_DISTORTION              1273
#define IDC_MIR_MID_EDIT                1274
#define IDC_MIR_MID_SPIN                1275
#define IDC_GRAD_LINEAR                 1494
#define IDC_GRAD_RADIAL                 1495
#define IDC_GRAD_AMOUNT                 1496
#define IDC_GRAD_AMOUNTSPIN             1497
#define IDC_GRAD_SIZE                   1498
#define IDC_COMP_LABEL1                 1499
#define IDC_GRAD_SIZESPIN               1499
#define IDC_COMP_UP                     1500
#define IDC_GRAD_PHASE                  1500
#define IDC_COMP_DOWN                   1501
#define IDC_GRAD_PHASESPIN              1501
#define IDC_COMP_PAGEUP                 1502
#define IDC_GRAD_CENTER                 1502
#define IDC_COMP_PAGEDOWN               1503
#define IDC_GRAD_CENTERSPIN             1503
#define IDC_COMP_NUMMAPS                1504
#define IDC_GRAD_LEVELS                 1504
#define IDC_COMP_SETNUM                 1505
#define IDC_GRAD_LEVELSSPIN             1505
#define IDC_COMP_NUMMAPSSPIN            1505
#define IDC_NOISE_LOWTHRESH             1506
#define IDC_GRAD_LOWTHRESH              1506
#define IDC_NOISE_LOWTHRESHSPIN         1507
#define IDC_COMP_LABEL2                 1507
#define IDC_GRAD_LOWTHRESHSPIN          1507
#define IDC_NOISE_HIGHTHRESH            1508
#define IDC_GRAD_HIGHTHRESH             1508
#define IDC_NOISE_HIGHTHRESHSPIN        1509
#define IDC_COMP_LABEL3                 1509
#define IDC_GRAD_HIGHTHRESHSPIN         1509
#define IDC_GRAD_THRESHSMOOTH           1510
#define IDC_COMP_LABEL4                 1511
#define IDC_GRAD_THRESHSMOOTHSPIN       1511
#define IDC_COMP_LABEL5                 1513
#define IDC_COMP_LABEL6                 1515
#define IDC_NOISE_REGULAR               1516
#define IDC_NOISE_FRACT                 1517
#define IDC_NOISE_TURB                  1518
#define IDC_COMP_TEX1                   1521
#define IDC_COMP_TEX2                   1522
#define IDC_COMP_TEX3                   1523
#define IDC_COMP_TEX4                   1524
#define IDC_COMP_TEX5                   1525
#define IDC_COMP_TEX6                   1526
#define IDC_MULTI_COLOR1                1540
#define IDC_MULTI_COLOR2                1541
#define IDC_MULTI_COLOR3                1542
#define IDC_MULTI_COLOR4                1543
#define IDC_MULTI_COLOR5                1544
#define IDC_MULTI_COLOR6                1545
#define IDC_MULTI_COLOR7                1546
#define IDC_MULTI_COLOR8                1547
#define IDC_MULTI_COLOR9                1548
#define IDC_MULTI_COLOR10               1549
#define IDC_MTL_NAME0                   1580
#define IDC_MTL_NAME1                   1581
#define IDC_MTL_NAME2                   1582
#define IDC_MTL_NAME3                   1583
#define IDC_MTL_NAME4                   1584
#define IDC_MTL_NAME5                   1585
#define IDC_MTL_NAME7                   1587
#define IDC_MTL_NAME8                   1588
#define IDC_MTL_NAME9                   1589
#define IDC_MULTI_MTL0                  1600
#define IDC_MULTI_MTL1                  1601
#define IDC_MULTI_MTL2                  1602
#define IDC_MULTI_MTL3                  1603
#define IDC_MULTI_MTL4                  1604
#define IDC_MULTI_MTL5                  1605
#define IDC_MULTI_MTL6                  1606
#define IDC_MULTI_MTL7                  1607
#define IDC_MULTI_MTL8                  1608
#define IDC_MULTI_MTL9                  1609
#define IDC_MULTI_MATLABEL1             1620
#define IDC_MULTI_MATLABEL2             1621
#define IDC_MULTI_MATLABEL3             1622
#define IDC_MULTI_MATLABEL4             1623
#define IDC_MULTI_MATLABEL5             1624
#define IDC_MULTI_MATLABEL6             1625
#define IDC_MULTI_MATLABEL7             1626
#define IDC_MULTI_MATLABEL8             1627
#define IDC_MULTI_MATLABEL9             1628
#define IDC_MULTI_MATLABEL10            1629
#define IDC_MAPON1                      1640
#define IDC_MAPON2                      1641
#define IDC_MAPON3                      1642
#define IDC_MAPON4                      1643
#define IDC_MAPON5                      1644
#define IDC_MAPON6                      1645
#define IDC_MAPON7                      1646
#define IDC_MAPON8                      1647
#define IDC_MAPON9                      1648
#define IDC_MAPON10                     1649
#define IDC_MULT_NUM1                   1660
#define IDC_MULT_NUM2                   1661
#define IDC_MULT_NUM3                   1662
#define IDC_MULT_NUM4                   1663
#define IDC_MULT_NUM5                   1664
#define IDC_MULT_NUM6                   1665
#define IDC_MULT_NUM7                   1666
#define IDC_MULT_NUM8                   1667
#define IDC_MULT_NUM9                   1668
#define IDC_MULT_NUM10                  1669
#define IDC_MTL_ON1                     1690
#define IDC_MTL_ON2                     1691
#define IDC_PARTAGE_COLOR1              1700
#define IDC_PARTAGE_MAP1                1701
#define IDC_PARTAGE_COLOR2              1702
#define IDC_PARTAGE_MAP2                1703
#define IDC_PARTAGE_COLOR3              1704
#define IDC_PARTAGE_MAP3                1705
#define IDC_PARTAGE_USEMAP1             1706
#define IDC_PARTAGE_USEMAP2             1707
#define IDC_PARTAGE_USEMAP3             1708
#define IDC_PARTAGE_AGE1                1709
#define IDC_PARTAGE_AGE1SPIN            1710
#define IDC_PARTAGE_AGE2                1711
#define IDC_MAPON                       1711
#define IDC_PARTAGE_AGE2SPIN            1712
#define IDC_MATTE_REFL_MAP              1712
#define IDC_PARTAGE_AGE3                1713
#define IDC_SAMP_COLOR                  1713
#define IDC_PARTAGE_AGE3SPIN            1714
#define IDC_BC_BRIGHTNESS               1718
#define IDC_BC_CONTRAST                 1719
#define IDC_BC_BRIGHTNESS_SPIN          1720
#define IDC_BC_CONTRAST_SPIN            1721
#define IDC_COMBO1                      1724
#define IDC_SI_COLORON                  1725
#define IDC_SPEC_PRESETS                1726
#define IDC_SHADER                      1728
#define IDC_SAMPLEQUALITY_SPIN          1729
#define IDC_SAMPLEQUALITY_EDIT          1730
#define IDC_PIX_SAMPLER                 1731
#define IDC_THRESHOLD_EDIT              1732
#define IDC_THRESHOLD_SPIN              1733
#define IDC_PARAM0_EDIT                 1734
#define IDC_PARAM0_SPIN                 1735
#define IDC_FILTER_CS                   1736
#define IDC_PARAM1_EDIT                 1736
#define IDC_USEMAP_0                    1737
#define IDC_PARAM1_SPIN                 1737
#define IDC_AMTEDIT_0                   1738
#define IDC_AMTSPIN_0                   1739
#define IDC_MAP_0                       1740
#define IDC_USEMAP_1                    1741
#define IDC_AMTEDIT_1                   1742
#define IDC_AMTSPIN_1                   1743
#define IDC_MAP_1                       1744
#define IDC_USEMAP_2                    1745
#define IDC_AMTEDIT_2                   1746
#define IDC_AMTSPIN_2                   1747
#define IDC_MAP_2                       1748
#define IDC_USEMAP_3                    1749
#define IDC_AMTEDIT_3                   1750
#define IDC_AMTSPIN_3                   1751
#define IDC_MAP_3                       1752
#define IDC_USEMAP_4                    1753
#define IDC_AMTEDIT_4                   1754
#define IDC_AMTSPIN_4                   1755
#define IDC_MAP_4                       1756
#define IDC_USEMAP_5                    1757
#define IDC_AMTEDIT_5                   1758
#define IDC_AMTSPIN_5                   1759
#define IDC_MAP_5                       1760
#define IDC_USEMAP_6                    1761
#define IDC_AMTEDIT_6                   1762
#define IDC_AMTSPIN_6                   1763
#define IDC_MAP_6                       1764
#define IDC_USEMAP_7                    1765
#define IDC_AMTEDIT_7                   1766
#define IDC_AMTSPIN_7                   1767
#define IDC_MAP_7                       1768
#define IDC_USEMAP_8                    1769
#define IDC_AMTEDIT_8                   1770
#define IDC_AMTSPIN_8                   1771
#define IDC_MAP_8                       1772
#define IDC_USEMAP_9                    1773
#define IDC_AMTEDIT_9                   1774
#define IDC_AMTSPIN_9                   1775
#define IDC_MAP_9                       1776
#define IDC_USEMAP_10                   1777
#define IDC_AMTEDIT_10                  1778
#define IDC_AMTSPIN_10                  1779
#define IDC_MAP_10                      1780
#define IDC_USEMAP_11                   1781
#define IDC_AMTEDIT_11                  1782
#define IDC_AMTSPIN_11                  1783
#define IDC_MAP_11                      1784
#define IDC_LOCK_TEX01                  1785
#define IDC_PRESETS                     1786
#define IDC_USEMAP_12                   1786
#define IDC_PRESET_RECORD               1787
#define IDC_AMTEDIT_12                  1787
#define IDC_PRESET_DELETE               1788
#define IDC_USEMAP_13                   1788
#define IDC_COMPMAT_MAT1                1789
#define IDC_SLEV_EDIT                   1789
#define IDC_AMTEDIT_13                  1789
#define IDC_COMPMAT_MAT2                1790
#define IDC_SLEV_SPIN                   1790
#define IDC_USEMAP_14                   1790
#define IDC_COMPMAT_A1                  1791
#define IDC_MAPON_SLEV                  1791
#define IDC_AMTEDIT_14                  1791
#define IDC_COMPMAT_S1                  1792
#define IDC_GLX_EDIT                    1792
#define IDC_AMTSPIN_12                  1792
#define IDC_COMPMAT_M1                  1793
#define IDC_GLX_SPIN                    1793
#define IDC_AMTSPIN_13                  1793
#define IDC_COMPMAT_A2                  1794
#define IDC_MAPON_GLX                   1794
#define IDC_AMTSPIN_14                  1794
#define IDC_COMPMAT_S2                  1795
#define IDC_GLY_EDIT                    1795
#define IDC_MAP_12                      1795
#define IDC_COMPMAT_M2                  1796
#define IDC_GLY_SPIN                    1796
#define IDC_MAP_13                      1796
#define IDC_COMPMAT_MAT3                1797
#define IDC_MAPON_GLY                   1797
#define IDC_MAP_14                      1797
#define IDC_COMPMAT_A3                  1798
#define IDC_MAPON_DLEV                  1798
#define IDC_USEMAP_15                   1798
#define IDC_COMPMAT_S3                  1799
#define IDC_DLEV_SPIN                   1799
#define IDC_AMTEDIT_15                  1799
#define IDC_COMPMAT_M3                  1800
#define IDC_DLEV_EDIT                   1800
#define IDC_AMTSPIN_15                  1800
#define IDC_COMPMAT_MAT4                1801
#define IDC_NORMALIZE_CHECK             1801
#define IDC_MAP_15                      1801
#define IDC_COMPMAT_A4                  1802
#define IDC_OR_EDIT                     1802
#define IDC_USEMAP_16                   1802
#define IDC_COMPMAT_S4                  1803
#define IDC_OR_SPIN                     1803
#define IDC_AMTEDIT_16                  1803
#define IDC_COMPMAT_M4                  1804
#define IDC_MAPON_OR                    1804
#define IDC_AMTSPIN_16                  1804
#define IDC_COMPMAT_MAT5                1805
#define IDC_CH_EDIT                     1805
#define IDC_MAP_16                      1805
#define IDC_COMPMAT_A5                  1806
#define IDC_CH_SPIN                     1806
#define IDC_USEMAP_17                   1806
#define IDC_COMPMAT_S5                  1807
#define IDC_GL_EDIT                     1807
#define IDC_AMTEDIT_17                  1807
#define IDC_OR1_EDIT                    1807
#define IDC_COMPMAT_M5                  1808
#define IDC_GL_SPIN                     1808
#define IDC_AMTSPIN_17                  1808
#define IDC_OR1_SPIN                    1808
#define IDC_COMPMAT_MAT6                1809
#define IDC_MAPON_GL                    1809
#define IDC_MAP_17                      1809
#define IDC_MAPON_OR1                   1809
#define IDC_COMPMAT_A6                  1810
#define IDC_ALEV_EDIT                   1810
#define IDC_AN_EDIT                     1810
#define IDC_LLEV_EDIT                   1810
#define IDC_USEMAP_18                   1810
#define IDC_COMPMAT_S6                  1811
#define IDC_ALEV_SPIN                   1811
#define IDC_AN_SPIN                     1811
#define IDC_LLEV_SPIN                   1811
#define IDC_AMTEDIT_18                  1811
#define IDC_COMPMAT_M6                  1812
#define IDC_MAPON_ALEV                  1812
#define IDC_MAPON_AN                    1812
#define IDC_MAPON_LLEV                  1812
#define IDC_AMTSPIN_18                  1812
#define IDC_COMPMAT_MAT7                1813
#define IDC_COLOR                       1813
#define IDC_MAP_18                      1813
#define IDC_COMPMAT_A7                  1814
#define IDC_MAPON_CLR                   1814
#define IDC_USEMAP_19                   1814
#define IDC_COMPMAT_S7                  1815
#define IDC_MT_EDIT                     1815
#define IDC_AN_EDIT2                    1815
#define IDC_AMTEDIT_19                  1815
#define IDC_COMPMAT_M7                  1816
#define IDC_MT_SPIN                     1816
#define IDC_AN_SPIN2                    1816
#define IDC_AMTSPIN_19                  1816
#define IDC_COMPMAT_MAT8                1817
#define IDC_MAPON_MT                    1817
#define IDC_MAPON_AN2                   1817
#define IDC_MAP_19                      1817
#define IDC_COMPMAT_A8                  1818
#define IDC_DIM_DIFF_CHECK              1818
#define IDC_COLOR2                      1818
#define IDC_USEMAP_20                   1818
#define IDC_COMPMAT_S8                  1819
#define IDC_LAYER_TABS                  1819
#define IDC_MAPON_CLR2                  1819
#define IDC_AMTEDIT_20                  1819
#define IDC_COMPMAT_M8                  1820
#define IDC_LAYER0_STATICTEXT           1820
#define IDC_AMTSPIN_20                  1820
#define IDC_COMPMAT_MAT9                1821
#define IDC_GL2_EDIT                    1821
#define IDC_MAP_20                      1821
#define IDC_COMPMAT_A9                  1822
#define IDC_GL2_SPIN                    1822
#define IDC_USEMAP_21                   1822
#define IDC_COMPMAT_S9                  1823
#define IDC_MAPON_GL2                   1823
#define IDC_AMTEDIT_21                  1823
#define IDC_COMPMAT_M9                  1824
#define IDC_AN2_EDIT                    1824
#define IDC_AMTSPIN_21                  1824
#define IDC_COMPMAT_MAT10               1825
#define IDC_AN2_SPIN                    1825
#define IDC_MAP_21                      1825
#define IDC_COMPMAT_A10                 1826
#define IDC_USEMAP_22                   1826
#define IDC_COMPMAT_S10                 1827
#define IDC_LLEV2_EDIT                  1827
#define IDC_AMTEDIT_22                  1827
#define IDC_COMPMAT_M10                 1828
#define IDC_LLEV2_SPIN                  1828
#define IDC_AMTSPIN_22                  1828
#define IDC_COMPMAP_AMOUNT1             1829
#define IDC_MAPON_LLEV2                 1829
#define IDC_MAP_22                      1829
#define IDC_COMPMAP_AMOUNTSPIN1         1830
#define IDC_LAYER0_STATICTEXT2          1830
#define IDC_USEMAP_23                   1830
#define IDC_COMPMAP_AMOUNT2             1831
#define IDC_MAPON_AN1                   1831
#define IDC_AMTEDIT_23                  1831
#define IDC_COMPMAP_AMOUNTSPIN2         1832
#define IDC_MAPON_LLEV1                 1832
#define IDC_AMTSPIN_23                  1832
#define IDC_COMPMAP_AMOUNT3             1833
#define IDC_MAPON_GL1                   1833
#define IDC_MAP_23                      1833
#define IDC_COMPMAP_AMOUNTSPIN3         1834
#define IDC_MAPON_CLR1                  1834
#define IDC_COMPMAP_AMOUNT4             1835
#define IDC_GL1_EDIT                    1835
#define IDC_COMPMAP_AMOUNTSPIN4         1836
#define IDC_GL1_SPIN                    1836
#define IDC_COMPMAP_AMOUNT5             1837
#define IDC_AN1_EDIT                    1837
#define IDC_COMPMAP_AMOUNTSPIN5         1838
#define IDC_AN1_SPIN                    1838
#define IDC_COMPMAP_AMOUNT6             1839
#define IDC_LLEV1_EDIT                  1839
#define IDC_COMPMAP_AMOUNTSPIN6         1840
#define IDC_LLEV1_SPIN                  1840
#define IDC_COMPMAP_AMOUNT7             1841
#define IDC_COLOR1                      1841
#define IDC_COMPMAP_AMOUNTSPIN7         1842
#define IDC_HIGHLIGHT1                  1842
#define IDC_COMPMAP_AMOUNT8             1843
#define IDC_SPEC_LEV2_EDIT              1843
#define IDC_COMPMAP_AMOUNTSPIN8         1844
#define IDC_SPEC_LEV2_SPIN              1844
#define IDC_COMPMAP_AMOUNT9             1845
#define IDC_MAPON_SPECLEV2              1845
#define IDC_COMPMAP_AMOUNTSPIN9         1846
#define IDC_SPEC_LEV1_EDIT              1846
#define IDC_COMPMAP_AMOUNT10            1847
#define IDC_SPEC_LEV1_SPIN              1847
#define IDC_COMPMAP_AMOUNTSPIN10        1848
#define IDC_MAPON_SPECLEV1              1848
#define IDC_MAPON_DIFFLEV               1849
#define IDC_MAPON_SPECCLR1              1850
#define IDC_MAPON_SPECCLR2              1851
#define IDC_AMB_CLR                     1852
#define IDC_DIFF_CLR                    1853
#define IDC_SPEC_CLR1                   1854
#define IDC_SPEC_CLR2                   1855
#define IDC_SI_CLR                      1856
#define IDC_MAPON_OR2                   1857
#define IDC_OR2_EDIT                    1858
#define IDC_OR2_SPIN                    1859
#define IDC_MAPON_DIFFROUGH             1860
#define IDC_ADAPT_STATIC                1861
#define IDC_ADVANCED_BUTTON             1862
#define IDC_SPEC_TEXT                   1863
#define IDC_SOFTEN_TEXT                 1864
#define IDC_OPAC_TEXT1                  1865
#define IDC_OPAC_TEXT2                  1866
#define IDC_REFR_TEXT1                  1867
#define IDC_OPAC_TEXT3                  1868
#define IDC_REFL_TEXT1                  1869
#define IDC_REFL_TEXT2                  1870
#define IDC_REFL_BOX                    1871
#define IDC_OPAC_BOX                    1872
#define IDC_FILTER_OVERLAY              1873
#define IDC_COMMENT_BOX                 1874
#define IDC_QUALITY_TEXT                1875
#define IDC_COMMENT_TEXT                1876
#define IDC_PARAM0_TEXT                 1877
#define IDC_PARAM1_TEXT                 1878
#define IDS_DS_PHASE                    10041
#define IDS_DS_AMBIENT                  10045
#define IDS_DS_DIFFUSE                  10046
#define IDS_DS_SPECULAR                 10047
#define IDS_DS_WIREFRAME                10049
#define IDS_DS_SHININESS                10051
#define IDS_DS_SHIN_STR                 10052
#define IDS_DS_OPACITY                  10053
#define IDS_DS_SELFI                    10054
#define IDS_DS_XPFALL                   10055
#define IDS_MAPENABLE                   10056
#define IDS_JW_SHADERTYPE               10057
#define IDS_DS_BASIC                    10058
#define IDS_DS_EXTRA                    10059
#define IDS_DS_TEXMAP                   10060
#define IDS_COLORS                      10061
#define IDS_MAPS                        10062
#define IDS_GRAD_TYPE                   10063
#define IDS_JW_MAPENABLES               10064
#define IDS_DS_THRESH                   10065
#define IDS_DS_BLEND                    10066
#define IDS_DS_BU                       10067
#define IDS_DS_RL                       10068
#define IDS_DS_RR                       10069
#define IDS_DS_TEXMAPS                  10070
#define IDS_DS_FILTER                   10071
#define IDS_DS_CHECKPARMS               10072
#define IDS_DS_COORDINATES              10073
#define IDS_NOISE_TYPE                  10074
#define IDS_DS_UOFFS                    10075
#define IDS_DS_VOFFS                    10076
#define IDS_DS_USCL                     10077
#define IDS_DS_VSCL                     10078
#define IDS_DS_ANGLE                    10079
#define IDS_DS_COLOR1                   10080
#define IDS_DS_COLOR2                   10081
#define IDS_DS_BLUR                     10082
#define IDS_JW_MAP1                     10083
#define IDS_DS_FLAT                     10084
#define IDS_DS_GOURAUD                  10085
#define IDS_DS_PHONG                    10086
#define IDS_DS_METAL                    10087
#define IDS_DS_OFFS                     10088
#define IDS_DS_SCL                      10089
#define IDS_DS_MARBPARMS                10090
#define IDS_DS_MARBWIDTH                10091
#define IDS_DS_MARBSIZE                 10092
#define IDS_DS_COORDNOISE               10093
#define IDS_DS_TEXOUT                   10094
#define IDS_DS_MIXAMT                   10095
#define IDS_DS_NOISEPARMS               10096
#define IDS_DS_MIXPARMS                 10097
#define IDS_DS_NOISESIZE                10098
#define IDS_DS_OUTAMT                   10099
#define IDS_DS_OUTPUT                   10100
#define IDS_DS_NOISEAMT                 10101
#define IDS_DS_NOISELEV                 10102
#define IDS_DS_OUTOFF                   10103
#define IDS_DS_MAP                      10104
#define IDS_DS_MASK                     10105
#define IDS_MASKPARMS                   10106
#define IDS_DS_COLOR3                   10107
#define IDS_DS_TINTPARMS                10108
#define IDS_JW_MAP2                     10108
#define IDS_DS_EXPLICIT                 10109
#define IDS_DS_SPHERE_ENV               10110
#define IDS_DS_CYL_ENV                  10111
#define IDS_DS_SHRINK_ENV               10112
#define IDS_DS_SCREEN                   10113
#define IDS_DS_WIRESZ                   10114
#define IDS_DS_IOR                      10115
#define IDS_DS_MAPSIZE                  10116
#define IDS_DS_ACUBIC_PARAMS            10117
#define IDS_DS_BLUROFFS                 10118
#define IDS_DS_MIRROR_PARAMS            10119
#define IDS_DS_LEVELS                   10120
#define IDS_DS_CONSTANT                 10121
#define IDS_DS_PARAMETERS               10122
#define IDS_JW_MAP3                     10123
#define IDS_JW_MAP1ENABLE               10124
#define IDS_JW_MAP2ENABLE               10125
#define IDS_JW_MAP3ENABLE               10126
#define IDS_JW_MAPS                     10127
#define IDS_JW_MAPAMOUNTS               10128
#define IDS_DS_MATTE_SHADOW_PAR         10129
#define IDS_DS_SHADOW_BRITE             10130
#define IDS_DS_BITMAP_PARAMS            10131
#define IDS_DS_TIME_PARAMS              10132
#define IDS_JW_ENABLE                   10133
#define IDS_JW_AMOUNT                   10134
#define IDS_DS_EFFECTS_CHANNEL          10135
#define IDS_DS_OUTPUT_CDESC             10136
#define IDS_DS_MASK_CDESC               10137
#define IDS_JW_FILENAME                 10138
#define IDS_JW_SHADERBYNAME             10139
#define IDS_JW_SAMPLERBYNAME            10140
#define IDS_DS_XLABEL                   10163
#define IDS_DS_YLABEL                   10164
#define IDS_DS_ZLABEL                   10165
#define IDS_DS_ULABEL                   10166
#define IDS_DS_VLABEL                   10167
#define IDS_DS_WLABEL                   10168
#define IDS_DS_BITMAP_TEXTURE_ERR       10172
#define IDS_DS_PARAMCHG                 10183
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_CURVITURE                30032
#define IDS_RB_AMPLITUDE                30033
#define IDS_RB_WAVELEN                  30034
#define IDS_RB_PHASE                    30035
#define IDS_RB_DECAY                    30036
#define IDS_RB_LOWTHRESH                30313
#define IDS_RB_HIGHTHRESH               30314
#define IDS_RB_NOISE                    30411
#define IDS_RB_MULTISUBOBJECT           30412
#define IDS_RB_MATERIAL2                30413
#define IDS_RB_BLENDMAT                 30414
#define IDS_RB_BACK                     30415
#define IDS_RB_FACING                   30416
#define IDS_RB_MASK                     30417
#define IDS_RB_MATERIALONE              30418
#define IDS_RB_MATERIALTWO              30419
#define IDS_RB_MIXAMOUNT                30420
#define IDS_RB_UPPER                    30421
#define IDS_RB_LOWER                    30422
#define IDS_RB_GRADIENT                 30423
#define IDS_RB_GRADIENTPARAMS           30424
#define IDS_RB_GRADTEMP                 30425
#define IDS_RB_COLOR1                   30426
#define IDS_RB_COLOR2                   30427
#define IDS_RB_COLOR3                   30428
#define IDS_RB_SIZE                     30429
#define IDS_RB_LEVELS                   30430
#define IDS_RB_CENTER2                  30431
#define IDS_RB_HIGHTHRESHOLD            30432
#define IDS_RB_LOWTHRESHOLD             30433
#define IDS_RB_THRESHOLDSMOOTHING       30434
#define IDS_RB_DOUBLESIDED              30435
#define IDS_RB_FACINGMAT                30436
#define IDS_RB_BACKMATERIAL             30437
#define IDS_RB_TRANSLUECENCY            30438
#define IDS_RB_COMPOSITE                30439
#define IDS_RB_COMPOSITEPARAMS          30440
#define IDS_RB_MAP2                     30441
#define IDS_DS_AMOUNT                   30442
#define IDS_DS_LOCKAD                   30443
#define IDS_DS_LOCKCOL                  30444
#define IDS_DS_TOPBOTTOM                30445
#define IDS_DS_TOP                      30446
#define IDS_DS_BOTTOM                   30447
#define IDS_DS_MARBLE                   30448
#define IDS_DS_MIX                      30449
#define IDS_DS_MATTE_SHADOW             30450
#define IDS_DS_PLACEMENT                30451
#define IDS_DS_BITMAP                   30452
#define IDS_DS_SELECT_BMFILE            30453
#define IDS_DS_ACUBIC_NAME              30454
#define IDS_DS_UP                       30455
#define IDS_DS_DOWN                     30456
#define IDS_DS_LEFT                     30457
#define IDS_DS_RIGHT                    30458
#define IDS_DS_FLATMIRROR               30459
#define IDS_DS_LOCK_DS                  30460
#define IDS_DS_XYZNAME                  30461
#define IDS_DS_RGBTINT                  30462
#define IDS_DS_CHECKER                  30463
#define IDS_DS_NONE                     30464
#define IDS_DS_TRANS                    30465
#define IDS_RB_NONE                     30466
#define IDS_DS_FILE_NOT_FOUND           30467
#define IDS_DS_STANDARD                 30468
#define IDS_DS_CHECK_BLUR               30469
#define IDS_DS_MTLDESC                  30470
#define IDS_DS_CLASSTEXMAPS             30471
#define IDS_DS_FRONT                    30472
#define IDS_DS_BACK                     30473
#define IDS_DS_NOT_SQUARE               30474
#define IDS_DS_WRONG_SIZE               30475
#define IDS_DS_REFL_ERROR               30476
#define IDS_DS_SELECT_UPFILE            30477
#define IDS_DS_CLIPU                    30478
#define IDS_DS_CLIPV                    30479
#define IDS_DS_CLIPW                    30480
#define IDS_DS_CLIPH                    30481
#define IDS_DS_CROP_TITLE               30482
#define IDS_DS_SHAD_COLOR               30483
#define IDS_DS_DYNAMICS                 30484
#define IDS_DS_BOUNCE                   30485
#define IDS_DS_STATFRIC                 30486
#define IDS_DS_SLIDFRIC                 30487
#define IDS_DS_RGBMULT                  30488
#define IDS_DS_RGBMULTPARAMS            30489
#define IDS_DS_MASKPARAMS               30490
#define IDS_DS_TINTPARAMS               30491
#define IDS_DS_OUTPUTPARAMS             30492
#define IDS_DS_FALLNEAR                 30493
#define IDS_DS_FALLFAR                  30494
#define IDS_DS_FALLOFF                  30495
#define IDS_DS_FALLOFFPARAMS            30496
#define IDS_DS_PERVAL                   30497
#define IDS_DS_PARVAL                   30498
#define IDS_DS_FVAL                     30499
#define IDS_DS_BVAL                     30500
#define IDS_DS_NSAMT                    30501
#define IDS_DS_NSSIZ                    30502
#define IDS_DS_NSLEV                    30503
#define IDS_DS_NSPHS                    30504
#define IDS_DS_VCOL                     30505
#define IDS_DS_VCOLPARAMS               30506
#define IDS_RB_PARTBLUR                 30507
#define IDS_RB_PBLURPARAMS              30508
#define IDS_RB_SHARP                    30509
#define IDS_DS_FLATPLATE                30510
#define IDS_DS_PLATE_PARAMS             30511
#define IDS_DS_THICKFACT                30512
#define IDS_DS_REFRAMT                  30513
#define IDS_DS_DIMLEV                   30514
#define IDS_DS_DIMMULT                  30515
#define IDS_DS_JITTERAMT                30516
#define IDS_DS_BLINN                    30517
#define IDS_DS_RAYMAP_NAME              30518
#define IDS_DS_NEARRANGE                30518
#define IDS_DS_RAYMAP_PARAMS            30519
#define IDS_DS_FARRANGE                 30519
#define IDS_DS_DISTAMT                  30520
#define IDS_RB_PARTICLEAGE              30521
#define IDS_RB_PARTAGEPARAMS            30522
#define IDS_RB_AGE1                     30523
#define IDS_RB_AGE2                     30524
#define IDS_RB_AGE3                     30525
#define IDS_DS_RED                      30526
#define IDS_DS_GREEN                    30527
#define IDS_DS_BLUE                     30528
#define IDS_DS_SOFTEN                   30529
#define IDS_DS_DP                       30530
#define IDS_DS_REFLAMT                  30531
#define IDS_DS_SAMPEFPARAMS             30532
#define IDS_KE_SELFILLUM_CLR            30532
#define IDS_KE_BRITECON_PARAMS          30533
#define IDS_KE_NOSUCH_CLR               30533
#define IDS_KE_BRIGHTNESS               30534
#define IDS_KE_STANDARD2                30534
#define IDS_KE_CONTRAST                 30535
#define IDS_KE_SHADER                   30535
#define IDS_KE_BRITECON                 30536
#define IDS_KE_SAMPLING                 30536
#define IDS_KE_PHONG                    30537
#define IDS_KE_BLINN                    30538
#define IDS_KE_METAL                    30539
#define IDS_KE_CONSTANT                 30540
#define IDS_KE_STDSHADER                30541
#define IDS_KE_OREN_NAYER               30542
#define IDS_KE_OREN_NAYAR               30542
#define IDS_KE_OREN_NAYER_BLINN         30543
#define IDS_KE_OREN_NAYAR_BLINN         30543
#define IDS_KE_DIFF_LEVEL               30544
#define IDS_KE_DIFF_ROUGH               30545
#define IDS_KE_DIFF_RHO                 30546
#define IDS_KE_NONE                     30547
#define IDS_DS_ON_BASIC                 30548
#define IDS_KE_SPEC_LEVEL               30549
#define IDS_KE_GLOSSINESS_Y             30550
#define IDS_KE_GLOSSINESS_X             30551
#define IDS_KE_WARD_BASIC               30552
#define IDS_KE_WARD                     30553
#define IDS_KE_STRAUSS                  30554
#define IDS_KE_STRAUSS_BASIC            30555
#define IDS_KE_METALNESS                30556
#define IDS_KE_GLOSSINESS               30557
#define IDS_KE_AMBIENT_LEV              30558
#define IDS_KE_COLOR                    30559
#define IDS_KE_ANISOTROPY               30560
#define IDS_KE_ORIENTATION              30561
#define IDS_KE_SELFILLUM                30562
#define IDS_KE_ANISO                    30563
#define IDS_KE_ANSIO_BASIC              30564
#define IDS_KE_CONST_PARMS              30565
#define IDS_KE_PHONG_PARMS              30566
#define IDS_KE_BLINN_PARMS              30567
#define IDS_KE_METAL_PARMS              30568
#define IDS_KE_OREN_PARMS               30569
#define IDS_KE_WARD_PARMS               30570
#define IDS_KE_STRAUSS_PARMS            30571
#define IDS_KE_ANISO_PARMS              30572
#define IDS_KE_CLR1                     30573
#define IDS_KE_CLR2                     30574
#define IDS_KE_GLOSS1                   30575
#define IDS_KE_GLOSS2                   30576
#define IDS_KE_ANISO1                   30577
#define IDS_KE_ANISO2                   30578
#define IDS_KE_LEVEL1                   30579
#define IDS_KE_LEVEL2                   30580
#define IDS_KE_MAPCHANNEL               30581
#define IDS_KE_SCHLICK                  30582
#define IDS_KE_SCHLICK_PARMS            30583
#define IDS_KE_SCHLICK_BASIC            30584
#define IDS_JW_TWOSIDED                 30585
#define IDS_JW_FACEMAP                  30586
#define IDS_JW_OPACITYTYPE              30587
#define IDS_JW_FILTERMAP                30588
#define IDS_JW_FALLOFFTYPE              30589
#define IDS_JW_WIREUNITS                30590
#define IDS_JW_APPLYREFDIM              30591
#define IDS_JW_PIXELSAMPLER             30592
#define IDS_JW_SAMPLERQUAL              30593
#define IDS_JW_SAMPLERENABLE            30594
#define IDS_JW_SHADERPARAMS             30595
#define IDS_PW_ALPHAFROM                30596
#define IDS_DS_VCOL_CDESC               30597
#define IDS_DS_RGBTINT_CDESC            30598
#define IDS_DS_STANDARD_CDESC           30599
#define IDS_KE_STANDARD2_CDESC          30600
#define IDS_DS_RGBMULT_CDESC            30601
#define IDS_DS_FLATPLATE_CDESC          30602
#define IDS_RB_PARTBLUR_CDESC           30603
#define IDS_RB_PARTICLEAGE_CDESC        30604
#define IDS_RB_NOISE_CDESC              30605
#define IDS_RB_MULTISUBOBJECT_CDESC     30606
#define IDS_RB_BLENDMAT_CDESC           30607
#define IDS_DS_MIX_CDESC                30608
#define IDS_DS_FLATMIRROR_CDESC         30609
#define IDS_DS_MATTE_SHADOW_CDESC       30610
#define IDS_DS_MARBLE_CDESC             30611
#define IDS_RB_GRADIENT_CDESC           30612
#define IDS_DS_FALLOFF_CDESC            30613
#define IDS_RB_DOUBLESIDED_CDESC        30614
#define IDS_RB_COMPOSITE_CDESC          30615
#define IDS_DS_TOPBOTTOM_CDESC          30616
#define IDS_DS_CHECKER_CDESC            30617
#define IDS_DS_BITMAP_CDESC             30618
#define IDS_DS_ACUBIC_NAME_CDESC        30619
#define IDS_JW_ADTEXLOCK                30620
#define IDS_JW_ADLOCK                   30625
#define IDS_JW_DSLOCK                   30626
#define IDS_JW_SELFILLUMCOLORON         30627
#define IDS_KE_SPEC_CLR1                30628
#define IDS_KE_SPEC_CLR2                30629
#define IDS_KE_SPEC_LEVEL1              30630
#define IDS_KE_SPEC_LEVEL2              30631
#define IDS_KE_MULTI_LAYER_BASIC        30632
#define IDS_KE_MULTI_LAYER              30633
#define IDS_KE_MULTI_LAYER_PARMS        30634
#define IDS_PW_DIRECTION                30635
#define IDS_PW_NODE                     30636
#define IDS_PW_INVERT                   30637
#define IDS_PW_OALPHA                   30638
#define IDS_PW_APPLYATMOS               30639
#define IDS_PW_ATMOSDEPTH               30640
#define IDS_PW_RECEIVESHADOWS           30641
#define IDS_PW_AFFECTALPHA              30642
#define IDS_PW_SPACE                    30643
#define IDS_PW_USECURVE                 30644
#define IDS_PW_MASKENABLE               30645
#define IDS_PW_INTERACTIVE              30646
#define IDS_PW_USEJITTER                30647
#define IDS_PW_APPLY                    30648
#define IDS_PW_CROPPLACE                30649
#define IDS_PW_FILTERING                30650
#define IDS_PW_MONOOUTPUT               30651
#define IDS_PW_RGBOUTPUT                30652
#define IDS_PW_ALPHASOURCE              30653
#define IDS_PW_PREMULT                  30654
#define IDS_PW_STARTTIME                30655
#define IDS_PW_PLAYBACK                 30656
#define IDS_PW_ENDCONDITION             30657
#define IDS_PW_USENVIROMENT             30658
#define IDS_PW_NTHFRAME                 30659
#define IDS_PW_FRAME                    30660
#define IDS_PW_APPLYTOFACEID            30661
#define IDS_PW_FACEID                   30662
#define IDS_PW_DISTORTIONTYPE           30663
#define IDS_PW_NOISETYPE                30664
#define IDS_PW_COORDINATES              30665
#define IDS_PW_POSITION                 30666
#define IDS_PW_MIXAMOUNT                30667
#define IDS_PW_BLURAMOUNT               30668
#define IDS_PW_DISTORTIONAMOUNT         30669
#define IDS_PW_LEVEL                    30670
#define IDS_PW_APPLYBLUR                30671
#define IDS_KE_FACETED                  30672
#define IDS_KE_ORIENTATION1             30673
#define IDS_KE_ORIENTATION2             30674
#define IDS_KE_SAMPLERADAPTTHRESH       30675
#define IDS_KE_SAMPLERADAPTON           30676
#define IDS_KE_SAMPLERADVANCED          30677
#define IDS_PW_SOURCE                   30678
#define IDS_PW_USEATMOSPHERIC           30679
#define IDS_PW_FRAMETYPE                30680
#define IDS_DS_NTHFRAME                 30681
#define IDS_PW_OUTPUTNAME               30682
#define IDS_KE_SUBSAMPLE_TEX_ON         30683
#define IDS_KE_BASIC_BLINN              30684
#define IDS_KE_BASIC_PHONG              30685
#define IDS_KE_BASIC_METAL              30686
#define IDS_PW_MAT                      30687
#define IDS_PW_BASE                     30688
#define IDS_DS_USEREFL                  30689
#define IDS_DS_BLEND_PARAMS             30690
#define IDS_DS_DBLSIDED_PARAMS          30691
#define IDS_DS_MULTI_PARAMS             30692
#define IDS_DS_TB_PARAMS                30693
#define IDS_DS_MIX_PARAMS               30694
#define IDS_PW_COMPOSITE_MATERIAL_PARAMS 30695
#define IDS_KE_SAMPLER_PARAM0           30696
#define IDS_KE_SAMPLER_PARAM1           30697
#define IDS_ACUBIC_SELECT_INPUT_FILE    30698
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1877
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\noise.cpp ===
/**********************************************************************
 *<
	FILE: NOISE.CPP

	DESCRIPTION: NOISE 3D Texture map.

	CREATED BY: Dan Silva
				Updated to Param Block2 by Peter Watje 12/1/1998
	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

#define DOAA
#define BLENDBAND 4.0f  // blend to average value over this many orders of magnitude


extern HINSTANCE hInstance;

#define NSUBTEX 2
#define NCOLS 2

static Class_ID noiseClassID(NOISE_CLASS_ID,0);

#define NPARAMS 7
#define NOISE_VERSION 4


#define NOISE_REGULAR	0
#define NOISE_FRACTAL	1
#define NOISE_TURB		2

class Noise;
//--------------------------------------------------------------
// Noise: A 3D texture map
//--------------------------------------------------------------

#define XYZGEN_REF	0
#define PBLOCK_REF	1
#define MAP1_REF	2
#define MAP2_REF	3
#define TEXOUT_REF	4

#define NUM_REFS	5


class Noise: public Tex3D { 
	friend class NoisePostLoad;
	static float avgAbsNs;
	Color col[NCOLS];
	float size;
	XYZGen *xyzGen;		   // ref #0
	IParamBlock2 *pblock;   // ref #1	
	Texmap* subTex[NSUBTEX];  // More refs (2 & 3)
	BOOL mapOn[NSUBTEX];
	TextureOutput *texout; // ref #4
	Interval ivalid;
	int noiseType;
	float phase;
	float levels;
	float low, high, smooth, sd, hminusl;
	float avgValue;
	int vers;
	int rollScroll;
	BOOL filter;
//	NoiseDlg *paramDlg;
	float Turb(Point3 p, float lev);
	public:
		Noise();
		~Noise() { 
//			DiscardTexHandle(); 
			}
		static ParamDlg* xyzGenDlg;	
		static ParamDlg* texoutDlg;
		void EnableStuff();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }
		void ReadSXPData(TCHAR *name, void *sxpdata);

		XYZGen *GetTheXYZGen() { return xyzGen; }

		void SetOutputLevel(TimeValue t, float v) {texout->SetOutputLevel(t,v); }
		void SetColor(int i, Color c, TimeValue t);
		void SetSize(float f, TimeValue t);
		void SetPhase(float f, TimeValue t);
		void SetLevels(float f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 

	
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// optimized evaluation for monochrome use
		float EvalMono(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		float LimitLevel(Point3 dp, float &smw);
		void ComputeAvgValue();
		float NoiseFunction(Point3 p,  float limLev, float smWidth);

		ULONG LocalRequirements(int subMtlNum) { return xyzGen->Requirements(subMtlNum); }
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return noiseClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_NOISE); }  
		void DeleteThis() { delete this; }	

		ULONG UVSpacesNeeded() { return 0; } 

		int NumSubs() { return NUM_REFS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return NUM_REFS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		BOOL loadOnChecks;
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		int FixLevel0(); 

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

//inertactive display stuff
/*
		TexHandle *texHandle;
		Interval texHandleValid;
		BOOL SupportTexDisplay() { return TRUE; }					
		void ActivateTexDisplay(BOOL onoff);
		DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker);
		void DiscardTexHandle();
		Bitmap *BuildBitmap(int size);
		AColor DispEvalFunc( float u, float v);		
*/
		float GetHiThresh();
		void SetHiThresh(float v);
		float GetLowThresh();
		void SetLowThresh(float v);

	};

class NoiseClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Noise; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_NOISE_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return noiseClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_3D;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("noise"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static NoiseClassDesc noiseCD;

ClassDesc* GetNoiseDesc() { return &noiseCD;  }
ParamDlg* Noise::xyzGenDlg;	
ParamDlg* Noise::texoutDlg;

enum { noise_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	noise_color1, noise_color2,
	noise_map1, noise_map2,		
	noise_map1_on, noise_map2_on, 
	noise_size, noise_phase, noise_levels, noise_lowthresh, noise_hithresh,
	noise_type,// main grad params 
	noise_coords, noise_output,	  // access for UVW mapping
};



/*
class NoisePBAccessor : public PBAccessor
	{
	public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
		{
		Noise* p = (Noise*)owner;
		p->EnableStuff();
		}
	};
	
static NoisePBAccessor noise_accessor;
*/

// parameter setter callback, reflect any ParamBlock-mediated param setting in instance data members.
// JBW: since the old path controller kept all parameters as instance data members, this setter callback
// is implemented to to reduce changes to existing code 


class NoisePBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		Noise* p = (Noise*)owner;
		if (p!=NULL)
			{
			switch (id)
				{
				case noise_lowthresh:
					{
					float high = p->GetHiThresh();
					float low = v.f;
					if (low > high) p->SetHiThresh(low+0.001f);
					break;
					}
				case noise_hithresh:
					{
					float low = p->GetLowThresh();
					float high = v.f;
					if (low > high) p->SetLowThresh(high-0.001f);
					break;
					}
				}
			p->EnableStuff();
			}

	}
};

static NoisePBAccessor noise_accessor;


//JBW: here is the new ParamBlock2 descriptor. There is only one block for Noises, a per-instance block.
// for the moment, some of the parameters a Tab<>s to test the Tab system.  Aslo note that all the References kept
// kept in a Noise are mapped here, marked as P_OWNERS_REF so that the paramblock accesses and maintains them
// as references on owning Noise.  You need to specify the refno for these owner referencetarget parameters.
// I even went so far as to expose the UVW mapping and Texture Output sub-objects this way so that they can be
// seen by the scripter and the schema-viewer

// per instance noise block



static ParamBlockDesc2 noise_param_blk ( noise_params, _T("parameters"),  0, &noiseCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_NOISE, IDS_DS_NOISEPARMS, 0, 0, NULL, 
	// params
	noise_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_NOISE_COL1, 
		end,
	noise_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.5,0.5,0.5), 
		p_ui,			TYPE_COLORSWATCH, IDC_NOISE_COL2, 
		end,
	noise_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		MAP1_REF,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_NOISE_TEX1,
		end,
	noise_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		MAP2_REF,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_NOISE_TEX2,
		end,
	noise_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	noise_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	noise_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NOISESIZE,
		p_default,		25.f,
		p_range,		0.001, 1000000.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NOISESIZE_EDIT, IDC_NOISESIZE_SPIN, 0.1f, 
		end,
	noise_phase,		_T("phase"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_DS_PHASE,
		p_default,		25.f,
		p_range,		-1000.0, 1000.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NOISEPHASE_EDIT, IDC_NOISEPHASE_SPIN, 0.1f, 
		end,
	noise_levels,	_T("levels"), TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_NSLEV,
		p_default,		3.0f,
		p_range,		1.0f, 10.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NOISELEV_EDIT, IDC_NOISELEV_SPIN, 0.1f, 
		end,
	noise_lowthresh, _T("thresholdLow"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_LOWTHRESH,
		p_default,		0.0f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NOISE_LOWTHRESH, IDC_NOISE_LOWTHRESHSPIN, 0.005f, 
		p_accessor,		&noise_accessor,
		end,
	noise_hithresh, _T("thresholdHigh"), TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_HIGHTHRESH,
		p_default,		1.0f,
		p_range,		0.0f, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NOISE_HIGHTHRESH, IDC_NOISE_HIGHTHRESHSPIN, 0.005f, 
		p_accessor,		&noise_accessor,
		end,
	noise_type, _T("type"), TYPE_INT,				0,				IDS_NOISE_TYPE,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_NOISE_REGULAR, IDC_NOISE_FRACT, IDC_NOISE_TURB,
		p_accessor,		&noise_accessor,
		end,
	noise_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		XYZGEN_REF, 
		end,
	noise_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_OUTPUT,
		p_refno,		TEXOUT_REF, 
		end,

	end
);


//dialog stuff to get the Set Ref button
class NoiseDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Noise *noise;		
		NoiseDlgProc(Noise *m) {noise = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			noise = (Noise*)m;
			noise->EnableStuff();
			}

	};



BOOL NoiseDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_NOISE_SWAP:
					{
					noise->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}



// Version 1 params
static ParamBlockDescID pbdesc1[] = {
	{ TYPE_FLOAT, NULL, TRUE,noise_size }, 	// size
	{ TYPE_POINT3, NULL, TRUE,noise_color1 },  // col1
	{ TYPE_POINT3, NULL, TRUE,noise_color2 }   // col2
	};

static ParamBlockDescID pbdesc2[] = {
	{ TYPE_FLOAT, NULL, TRUE,noise_size }, 	// size
	{ TYPE_POINT3, NULL, TRUE,noise_color1 },  // col1
	{ TYPE_POINT3, NULL, TRUE,noise_color2 },  // col2
	{ TYPE_FLOAT, NULL, TRUE,noise_phase }, 	// phase
	{ TYPE_FLOAT, NULL, TRUE,noise_levels } 	// levels
	};

static ParamBlockDescID pbdesc3[] = {
	{ TYPE_FLOAT, NULL, TRUE,noise_size }, 	// size
	{ TYPE_RGBA, NULL, TRUE,noise_color1 },  // col1
	{ TYPE_RGBA, NULL, TRUE,noise_color2 },  // col2
	{ TYPE_FLOAT, NULL, TRUE,noise_phase }, 	// phase
	{ TYPE_FLOAT, NULL, TRUE,noise_levels }, 	// levels
	{ TYPE_FLOAT, NULL, TRUE,noise_lowthresh },	// low thresh
	{ TYPE_FLOAT, NULL, TRUE,noise_hithresh },	// high thresh	
	};

// Current version params

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc1,3,1),	// Version 1 params
	ParamVersionDesc(pbdesc2,4,2),	// Version 2 params
	ParamVersionDesc(pbdesc3,7,3),	// Version 2 params
	};
#define NUM_OLDVERSIONS	3


float Noise::avgAbsNs = -1.0f;

void Noise::Init() {
	if (xyzGen) xyzGen->Reset();
	else ReplaceReference( XYZGEN_REF, GetNewDefaultXYZGen());	
	if (texout) texout->Reset();
	else ReplaceReference( TEXOUT_REF, GetNewDefaultTextureOutput());		
	ivalid.SetEmpty();
	macroRecorder->Disable();  // disable macrorecorder during reset
		SetColor(0, Color(0.0f,0.0f,0.0f), TimeValue(0));
		SetColor(1, Color(1.0f,1.0f,1.0f), TimeValue(0));
		noiseType = NOISE_REGULAR;
		SetSize(25.0f, TimeValue(0));
		SetPhase(.0f,TimeValue(0));
		SetLevels(3.0f,TimeValue(0));
		pblock->SetValue(noise_hithresh,0,1.0f);
	macroRecorder->Enable();
	for (int i=0; i<NSUBTEX; i++) 
		mapOn[i] = 1;
	}

void Noise::Reset() {
	noiseCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	for (int i=0; i<NSUBTEX; i++) 
		DeleteReference(i+2);
	}

void Noise::NotifyChanged() {
	ivalid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Noise::Noise() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
	texout = NULL;
//	texHandle = NULL;
	noiseType = NOISE_REGULAR;
	noiseCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	vers = 0;
	rollScroll=0;
	}


RefTargetHandle Noise::Clone(RemapDir &remap) {
	Noise *mnew = new Noise();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(XYZGEN_REF,remap.CloneRef(xyzGen));
	mnew->ReplaceReference(TEXOUT_REF,remap.CloneRef(texout));
	mnew->ReplaceReference(PBLOCK_REF,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->noiseType = noiseType;
	mnew->size = size;
	mnew->avgValue = avgValue;
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}


void Noise::EnableStuff() {
	if (pblock) {
		IParamMap2 *map = pblock->GetMap();
		pblock->GetValue( noise_type, 0, noiseType, FOREVER );
		if (map) {
			map->Enable(noise_levels, noiseType==NOISE_REGULAR?FALSE:TRUE);
			}
		}
	}


ParamDlg* Noise::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
// JBW: the main difference here is the automatic creation of a ParamDlg by the new
// ClassDesc2 function CreateParamDlgs().  This mirrors the way BeginEditParams()
// can be redirected to the ClassDesc2 for automatic ParamMap2 management.  In this 
// case a special subclass of ParamDlg, AutoMParamDlg, defined in IParamm2.h, is 
// created.  It can act as a 'master' ParamDlg to which you can add any number of 
// secondary dialogs and it will make sure all the secondary dialogs are kept 
// up-to-date and deleted as necessary.  

	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = noiseCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	masterDlg->AddDlg(texoutDlg);
	noise_param_blk.SetUserDlgProc(new NoiseDlgProc(this));
	EnableStuff();
	return masterDlg;

	}



float Noise::GetHiThresh()
{
if (pblock != NULL)
	return pblock->GetFloat(noise_hithresh, GetCOREInterface()->GetTime());
else return 0;
}
void Noise::SetHiThresh(float v)
{
if (pblock != NULL)
	{
	pblock->SetValue(noise_hithresh,GetCOREInterface()->GetTime(),v);
	noise_param_blk.InvalidateUI(noise_hithresh);
	}

}
float Noise::GetLowThresh()
{
if (pblock != NULL)
	return  pblock->GetFloat(noise_lowthresh, GetCOREInterface()->GetTime());
else return 0;
}
void Noise::SetLowThresh(float v)
{
if (pblock != NULL)
	{
	pblock->SetValue(noise_lowthresh,GetCOREInterface()->GetTime(),v);
	noise_param_blk.InvalidateUI(noise_lowthresh);
}
}

struct Col24 {ULONG r,g,b; };
#define NOISE_VERS 0xC79A0

struct NoiseState {
	ulong version;
	float size;
	float x1,y1,z1;
	float x2,y2,z2;
	Col24 col1,col2;
	long frame1,frame2;
	};

static Color ColrFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
	}

void Noise::ReadSXPData(TCHAR *name, void *sxpdata) {
	NoiseState *state = (NoiseState*)sxpdata;
	if (state!=NULL && state->version==NOISE_VERS) {
		SetColor(0, ColrFromCol24(state->col1),0);
		SetColor(1, ColrFromCol24(state->col2),0);
		SetSize(state->size,0);
		}
	}

#define NAVG 10000
		
void Noise::ComputeAvgValue() {
#ifdef DOAA
	srand(1345);
	Point3 p;
	int i;
	float sum = 0.0f;
	filter = FALSE;
	for (i=0; i<NAVG; i++) {
		p.x = float(rand())/100.0f;			
		p.y = float(rand())/100.0f;			
		p.z = float(rand())/100.0f;			
		sum += NoiseFunction(p,levels,0.0f);
		}
	avgValue = sum/float(NAVG);
	sum = 0.0f;
	if (avgAbsNs<0.0f) {
#define NAVGNS 10000
		float phase;
		for (i=0; i<NAVGNS; i++) {
			p.x = float(rand())/100.0f;			
			p.y = float(rand())/100.0f;			
			p.z = float(rand())/100.0f;			
			phase = float(rand())/100.0f;
			sum += (float)fabs(noise4(p,phase));
			}
		avgAbsNs = sum/float(NAVGNS);
		}
#endif
	}

BOOL Noise::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else if ((texoutDlg!= NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}


void Noise::Update(TimeValue t, Interval& valid) {

	if (pblock == NULL) return;

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		if (xyzGen != NULL)
			xyzGen->Update(t,ivalid);
		if (texout != NULL)
			texout->Update(t,ivalid);
		pblock->GetValue( noise_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( noise_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( noise_size, t,   size, ivalid );
		pblock->GetValue( noise_phase, t,  phase, ivalid );
		pblock->GetValue( noise_levels, t,  levels, ivalid );
		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}		
		pblock->GetValue( noise_hithresh, t, high, ivalid );
		pblock->GetValue( noise_lowthresh, t, low, ivalid );		

		if (high<low) {
			float tmp = low;
			low = high;
			high = tmp;
			}
		pblock->GetValue( noise_map1_on, t, mapOn[0], ivalid);
		pblock->GetValue( noise_map2_on, t, mapOn[1], ivalid);
		pblock->GetValue( noise_type, t, noiseType, ivalid);


		ComputeAvgValue();
		EnableStuff();
		}
	valid &= ivalid;
	}

void Noise::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(noise_color1,0,noise_color2,0);
	noise_param_blk.InvalidateUI(noise_color1);
	noise_param_blk.InvalidateUI(noise_color2);
	noise_param_blk.InvalidateUI(noise_map1);
	noise_param_blk.InvalidateUI(noise_map2);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRecorder->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
	}

void Noise::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	pblock->SetValue( i==0?noise_color1:noise_color2, t, c);
	}

void Noise::SetSize(float f, TimeValue t) { 
	size = f; 
	pblock->SetValue( noise_size, t, f);
	}

void Noise::SetPhase(float f, TimeValue t) { 
	phase = f; 
	pblock->SetValue( noise_phase, t, f);
	}

void Noise::SetLevels(float f, TimeValue t) { 
	levels = f; 
	pblock->SetValue( noise_levels, t, f);
	}

RefTargetHandle Noise::GetReference(int i) {
	switch(i) {
		case XYZGEN_REF: return xyzGen;
		case PBLOCK_REF: return pblock;
		case TEXOUT_REF: return texout;
		default:return subTex[i-2];
		}
	}

void Noise::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case XYZGEN_REF: xyzGen = (XYZGen *)rtarg; break;
		case PBLOCK_REF: pblock = (IParamBlock2 *)rtarg; break;
		case TEXOUT_REF: texout = (TextureOutput *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
	}

void Noise::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2,m);

	if (i==0)
		{
		noise_param_blk.InvalidateUI(noise_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		noise_param_blk.InvalidateUI(noise_map2);
		ivalid.SetEmpty();
		}	

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
	}

TSTR Noise::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Noise::SubAnim(int i) {
	switch (i) {
		case XYZGEN_REF: return xyzGen;
		case PBLOCK_REF: return pblock;
		case TEXOUT_REF: return texout;
		default: return subTex[i-2]; 
		}
	}

TSTR Noise::SubAnimName(int i) {
	switch (i) {
		case XYZGEN_REF: return TSTR(GetString(IDS_DS_COORDINATES));		
		case PBLOCK_REF: return TSTR(GetString(IDS_DS_PARAMETERS));		
		case TEXOUT_REF: return TSTR(GetString(IDS_DS_OUTPUT));
		default: return GetSubTexmapTVName(i-2);
		}
	}

static int nameID[] = {IDS_DS_NOISESIZE, IDS_DS_COLOR1, IDS_DS_COLOR2, IDS_DS_PHASE, IDS_DS_LEVELS,
						IDS_RB_LOWTHRESH, IDS_RB_HIGHTHRESH};

RefResult Noise::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != xyzGen && hTarget != texout ) 
				noise_param_blk.InvalidateUI(changing_param);
				// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 	0x4000
#define DO_TURB_CHUNK 	0x1000
#define NOISETYPE_CHUNK	0x1010
#define NOISEVERS1_CHUNK 0x2001
#define MAPOFF_CHUNK 0x3000

IOResult Noise::Save(ISave *isave) { 
	IOResult res;
//	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	return IO_OK;
	}	

int Noise::FixLevel0() {
	// old files had level==0: this is to fix them
	if (pblock) {
		float l;
		Interval ivalid;
		pblock->GetValue( noise_levels, 0,  l, ivalid );
		if (l<1.0f) {
			pblock->SetValue( noise_levels, 0,  1.0f );
			return 1;
			}
		}
	return 0;
	}

class NoisePostLoad : public PostLoadCallback {
	public:
		Noise *n;
		NoisePostLoad(Noise *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->FixLevel0())
				iload->SetObsolete();

			if (n->loadOnChecks)
				{
				macroRecorder->Disable();  
					n->pblock->SetValue( noise_map1_on, 0, n->mapOn[0]);
					n->pblock->SetValue( noise_map2_on, 0, n->mapOn[1]);
					n->pblock->SetValue( noise_type, 0, n->noiseType);
				macroRecorder->Enable(); 
				}
			delete this; 


			} 
	};

	
IOResult Noise::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	int id;
	vers = 0;
//	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions, NUM_OLDVERSIONS, &curVersion, this, 1 /*ref # */ ));
	loadOnChecks = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case DO_TURB_CHUNK:
				noiseType = NOISE_TURB;
				loadOnChecks = TRUE;
				break;
			case NOISETYPE_CHUNK:
				res = iload->Read(&noiseType,sizeof(noiseType),&nb);
				loadOnChecks = TRUE;
				break;
			case NOISEVERS1_CHUNK:
				vers = 1;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				loadOnChecks = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	if (loadOnChecks)
	{
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &noise_param_blk, this, PBLOCK_REF);
		iload->RegisterPostLoadCallback(plcb);
	}

	iload->RegisterPostLoadCallback(new NoisePostLoad(this));



	return IO_OK;
	}

#define NOISE01(p) ((1.0f+noise4(p,phase))*.5f)

float Noise::Turb(Point3 p, float lev) {
	float sum = 0.0f;
	float l,f = 1.0f;
	float ml = levels;
	for (l = lev; l >= 1.0f; l-=1.0f, ml-=1.0f) {
		sum += (float)fabs(noise4(p*f,phase))/f;
		f *= 2.0f;
		}
	if (l>0.0f)
		sum += l*(float)fabs(noise4(p*f,phase))/f;

#ifdef DOAA
	if (filter&&(ml>l)) {
		float r = 0;
	    if (ml<1.0f) {
			r += (ml-l)/f;
			}
		else  {
			r  += (1.0f-l)/f;
			ml -= 1.0f;
			f  *= 2.0f;
			for (l = ml; l >=1.0f; l-=1.0f) {
				r += 1.0f/f;
				f *= 2.0f;
				}
			if (l>0.0f)
				r+= l/f;
			sum += r*avgAbsNs;
			}
		}
#endif
	return sum;
	}

float SmoothThresh(float x, float a, float b, float d) {
	float al = a-d;  
	float ah = a+d;	
	float bl = b-d;
	float bh = b+d;
	if (x<al) return 0.0f;
	if (x>bh) return 1.0f;
	if (x<ah) {
		float u = (x-al)/(ah-al);
		u = u*u*(3-2*u);  // smooth cubic curve 
		return u*(x-a)/(b-a);
		}
	if (x<bl){ 
		return (x-a)/(b-a);
		}
	else  {
		float u = (x-bl)/(bh-bl);
		u = u*u*(3-2*u);  // smooth cubic curve 
			return (1.0f-u)*(x-a)/(b-a) + u;
		}
	}

float Noise::NoiseFunction(Point3 p, float limitLev, float smWidth) {
	float res;
	float lev = limitLev;
	if (limitLev<(1.0f-BLENDBAND)) return avgValue;

	if (lev<1.0f) lev = 1.0f;
	switch (noiseType) {
		case NOISE_TURB:
			res = Turb(p,lev);
			break;
	
    	case NOISE_REGULAR:
			res = NOISE01(p);
			break;

		case NOISE_FRACTAL:
			{
			float sum = 0.0f;
			float l, f = 1.0f;
			for (l = lev; l >= 1.0f; l-=1.0f) {				
				sum += noise4(p*f,phase)/f;
				f *= 2.0f;
				}
			if (l>0.0f)				
				sum += l*noise4(p*f,phase)/f;				
			res = 0.5f*(sum+1.0f);
			}
			break;
		}
	if (low<high) {
		//res = threshold(res,low,high);
		res = filter? SmoothThresh(res,low,high, smWidth): threshold(res,low,high);
		}
	if (res<0.0f) res = 0.0f;
	else if (res>1.0f) res = 1.0f;

	if (filter) {
		if (limitLev<1.0f) {
			float u = (limitLev+BLENDBAND-1.0f)/BLENDBAND;
			res = u*res + (1.0f-u)*avgValue;
			}
		}
	return res;   
	}



static AColor black(0.0f,0.0f,0.0f,0.0f);

inline float logb2(float x) { return float(log(x)/.6931478); }

float  Noise::LimitLevel(Point3 dp, float &smw ) {
#ifdef DOAA
#define epsilon	0.00001f

	if (filter) {
		float m = (float(fabs(dp.x) + fabs(dp.y) + fabs(dp.z))/3.0f)/size;
		if ( m < epsilon ) m = epsilon;
		float l = logb2(1/m);
		float smWidth = m*.2f;
		if (smWidth>.4f) smWidth = .4f;
		smw = smWidth;
		return  (levels<l)?levels:l;	  
		}
	else 
#endif 
		{
		smw = 0.0f;
		return levels;
		}
	}

RGBA Noise::EvalColor(ShadeContext& sc) {
	Point3 p,dp;
	if (!sc.doMaps) return black;

	AColor c;
	if (sc.GetCache(this,c)) 
		return c; 

	if (gbufID) sc.SetGBufferID(gbufID);

	//IPoint2 ps = sc.ScreenCoord();
	xyzGen->GetXYZ(sc,p,dp);
	p /= size;	   
	filter = sc.filterMaps;
	
	float smw;
	float limlev = LimitLevel(dp,smw);
    float d = NoiseFunction(p,limlev,smw);

	RGBA c0 = mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1];
	c = texout->Filter((1.0f-d)*c0 + d*c1);
	
	sc.PutCache(this,c); 
	return c;
	}

float Noise::EvalMono(ShadeContext& sc) {
	Point3 p,dp;
	if (!sc.doMaps) 	return 0.0f;

	float f;
	if (sc.GetCache(this,f)) 
		return f; 

	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	p /= size;
	filter = sc.filterMaps;
	float smw;
	float limlev = LimitLevel(dp, smw);
    float d = NoiseFunction(p,limlev,smw);
	float c0 = mapOn[0]&&subTex[0] ? subTex[0]->EvalMono(sc): Intens(col[0]);
	float c1 = mapOn[1]&&subTex[1] ? subTex[1]->EvalMono(sc): Intens(col[1]);
	f = texout->Filter((1.0f-d)*c0 + d*c1);
	sc.PutCache(this,f); 
	return f;
	}
							
Point3 Noise::EvalNormalPerturb(ShadeContext& sc) {
	Point3 p,dp;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	p /= size;
	filter = sc.filterMaps;
	float smw;
	float limlev = LimitLevel(dp,smw);
	float del,d;
	d = NoiseFunction(p,limlev,smw);
	//del = (dp.x+dp.y+dp.z)/(size*3.0f);
	del = .1f;
	Point3 np;					  
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);

	np.x = (NoiseFunction(p+del*M[0],limlev,smw) - d)/del;
	np.y = (NoiseFunction(p+del*M[1],limlev,smw) - d)/del;
	np.z = (NoiseFunction(p+del*M[2],limlev,smw) - d)/del;

	np = sc.VectorFromNoScale(np, REF_OBJECT);

	Texmap *sub0 = mapOn[0]?subTex[0]:NULL;
	Texmap *sub1 = mapOn[1]?subTex[1]:NULL;
	if (sub0||sub1) {
		// d((1-k)*a + k*b ) = dk*(b-a) + k*(db-da) + da
		float a,b,k;
		Point3 da,db;
		k = EvalMono(sc);
		if (sub0) {
			a = sub0->EvalMono(sc);
			da = sub0->EvalNormalPerturb(sc);
			}
		else {
			 a = Intens(col[0]);
			 da = Point3(0.0f,0.0f,0.0f);
			 }
		if (sub1) {
			b = sub1->EvalMono(sc);
			db = sub1->EvalNormalPerturb(sc);
			}
		else {
			 b = Intens(col[1]);
			 db= Point3(0.0f,0.0f,0.0f);
			 }
		np = (b-a)*np + k*(db-da) + da;
		}
	return texout->Filter(np);
	}
/*
AColor Noise::DispEvalFunc(float u, float v) 
	{
	Point3 p;
	p.x = u;
	p.y = v;
	p.z = 0.0f;
	p /= size;	   

    float d = NoiseFunction(p,0,1.0f);
//	AColor c;
//	c.r = d;
//	c.g = d;
//	c.b = d;

	return col[1]*(1.0f-d) + col[0]*d;;
	}



void Noise::DiscardTexHandle() 
	{
	if (texHandle!= NULL) 
		{
		texHandle->DeleteThis();
		}
	texHandle = NULL;
	}

void Noise::ActivateTexDisplay(BOOL onoff) {
	if (!onoff) 
		DiscardTexHandle();
	}

DWORD Noise::GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {
	DebugPrint("Active Tex Handle \n");
	if (texHandle) {
		if (texHandleValid.InInterval(t))
			return texHandle->GetHandle();
		else DiscardTexHandle();
		}
	Bitmap *bm;
	Interval v;
	Update(t,v);
	bm = BuildBitmap(thmaker.Size());
//	texHandle = thmaker.CreateHandle(bm,xyzGen->SymFlags());
	texHandle = thmaker.CreateHandle(bm,3);
//	bm->DeleteThis();
	texHandleValid.SetInfinite();
	Color ac;
	pblock->GetValue( noise_color1, t, ac, texHandleValid );
	pblock->GetValue( noise_color2, t, ac, texHandleValid );

	float f;
	pblock->GetValue( noise_size, t,   f, texHandleValid );
	pblock->GetValue( noise_phase, t,  f, texHandleValid );
	pblock->GetValue( noise_levels, t,  f, texHandleValid );
	pblock->GetValue( noise_hithresh, t, f, texHandleValid );
	pblock->GetValue( noise_lowthresh, t, f, texHandleValid );		


	return texHandle->GetHandle();
	}

inline UWORD FlToWord(float r) {
	return (UWORD)(65535.0f*r);
	}

Bitmap *Noise::BuildBitmap(int sz) {
	float u,v;
	BitmapInfo bi;
	bi.SetName(GetString(IDS_RB_NOISETEMP));
	bi.SetWidth(sz);
	bi.SetHeight(sz);
	bi.SetType(BMM_TRUE_32);
	Bitmap *bm = TheManager->Create(&bi);
	if (bm==NULL) return NULL;
	PixelBuf l64(sz);
	float d = 1.0f/float(sz);
	v = 1.0f - 0.5f*d;
	for (int y=0; y<sz; y++) {
		BMM_Color_64 *p64=l64.Ptr();
		u = 0.0f;
		for (int x=0; x<size; x++, p64++) {
			AColor c = DispEvalFunc(u,v);
			if (x==(1)) 
				{
				c.r = 1.0f;
				c.g = 0;
				c.b = 0;
				}
			else
				{
				c.r = 0.0f;
				c.g = 1.0;
				c.b = 0;
				}
			p64->r = FlToWord(c.r); 
			p64->g = FlToWord(c.g); 
			p64->b = FlToWord(c.b);
			p64->a = 0xffff; 
			u += d;
			}
		bm->PutPixels(0,y, sz, l64.Ptr()); 
		v -= d;
		}
	return bm;
	}


*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\partage.cpp ===
/**********************************************************************
 *<
	FILE: PARTAGE.CPP

	DESCRIPTION: A texture map that changes color based on particle ages.

	CREATED BY: Rolf Berteig
				Update 12/23 to param block2 by Peter Watje

	HISTORY: created 6/21/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "texutil.h"
			   
extern HINSTANCE hInstance;

#define PARTAGE_CLASSID	Class_ID(0x8d618ea4,0x49bbe8cf)


#define NSUBTEX	3

class PartAgeTex : public Texmap { 
	public:
		static ParamDlg* texoutDlg;
		IParamBlock2 *pblock;		// ref 0		
		TextureOutput *texout;		// ref 1
		Texmap* subTex[NSUBTEX];	// ref 2-4


		// Caches
		Interval ivalid;
		CRITICAL_SECTION csect;
		Color col1, col2, col3;
		int usemap1, usemap2, usemap3;
		float p1, p2, p3;		

		PartAgeTex();
		~PartAgeTex() {DeleteCriticalSection(&csect);}

		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);		
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) {Update(t,FOREVER); return ivalid;}		

		// Evaluation
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);		
		Point3 EvalNormalPerturb(ShadeContext& sc);		

		// Methods to access texture maps of material
		int NumSubTexmaps() {return NSUBTEX;}
		Texmap* GetSubTexmap(int i) {return subTex[i];}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {return PARTAGE_CLASSID;}
		SClass_ID SuperClassID() {return TEXMAP_CLASS_ID;}
		void GetClassName(TSTR& s) { s = GetString(IDS_RB_PARTICLEAGE); } // mjm - 2.3.99
		void DeleteThis() {delete this;}	

		int NumSubs() {return 5;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

 		int NumRefs() {return 5;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

	};

ParamDlg* PartAgeTex::texoutDlg;


class PartAgeTexClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new PartAgeTex;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_PARTICLEAGE_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return TEXMAP_CLASS_ID;}
	Class_ID 		ClassID() {return PARTAGE_CLASSID;}
	const TCHAR* 	Category() {return TEXMAP_CAT_3D;}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("particleAge"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static PartAgeTexClassDesc partAgeCD;
ClassDesc* GetPartAgeDesc() {return &partAgeCD;}

enum { page_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	page_color1, page_color2,page_color3,
	page_map1, page_map2,	page_map3,		
	page_map1_on, page_map2_on, page_map3_on, 
	page_page1, page_page2, page_page3, 
	page_output,	  // access for UVW mapping
};

static ParamBlockDesc2 page_param_blk ( page_params, _T("parameters"),  0, &partAgeCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_PARTAGE_PARAMS, IDS_RB_PARTAGEPARAMS, 0, 0, NULL, 
	// params
	page_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_COLOR1,	
		p_default,		Color(0.0f,0.0f,0.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_PARTAGE_COLOR1, 
		end,
	page_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_COLOR2,	
		p_default,		Color(.5f,.5f,.5f), 
		p_ui,			TYPE_COLORSWATCH, IDC_PARTAGE_COLOR2, 
		end,
	page_color3,	 _T("color3"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_COLOR3,	
		p_default,		Color(1.0f,1.0f,1.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_PARTAGE_COLOR3, 
		end,
	page_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_PARTAGE_MAP1,
		end,
	page_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_PARTAGE_MAP2,
		end,
	page_map3,		_T("map3"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP3,
		p_refno,		4,
		p_subtexno,		2,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_PARTAGE_MAP3,
		end,
	page_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_PARTAGE_USEMAP1,
		end,
	page_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_PARTAGE_USEMAP2,
		end,
	page_map3_on,	_T("map3Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP3ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_PARTAGE_USEMAP3,
		end,

		
	page_page1,	_T("age1"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_AGE1,
		p_default,		0.f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PARTAGE_AGE1, IDC_PARTAGE_AGE1SPIN, 0.1f, 
		end,
	page_page2,	_T("age2"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_AGE2,
		p_default,		50.f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PARTAGE_AGE2, IDC_PARTAGE_AGE2SPIN, 0.1f, 
		end,
	page_page3,	_T("age3"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_AGE3,
		p_default,		100.f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PARTAGE_AGE3, IDC_PARTAGE_AGE3SPIN, 0.1f, 
		end,

	page_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_OUTPUT,
		p_refno,		1, 
		end,

	end
);


//--- Parameter Map/Parameter block IDs ------------------------------
/*
#define PB_COL1				0
#define PB_COL2				1
#define PB_COL3				2
#define PB_USEMAP1			3
#define PB_USEMAP2			4
#define PB_USEMAP3			5
#define PB_AGE1				6
#define PB_AGE2				7
#define PB_AGE3				8


static ParamUIDesc descParam[] = {
	// Color 1
	ParamUIDesc(PB_COL1,TYPE_COLORSWATCH,IDC_PARTAGE_COLOR1),

	// Color 2
	ParamUIDesc(PB_COL2,TYPE_COLORSWATCH,IDC_PARTAGE_COLOR2),

	// Color 3
	ParamUIDesc(PB_COL3,TYPE_COLORSWATCH,IDC_PARTAGE_COLOR3),

	// Use Map 1
	ParamUIDesc(PB_USEMAP1,TYPE_SINGLECHEKBOX,IDC_PARTAGE_USEMAP1),

	// Use Map 2
	ParamUIDesc(PB_USEMAP2,TYPE_SINGLECHEKBOX,IDC_PARTAGE_USEMAP2),

	// Use Map 3
	ParamUIDesc(PB_USEMAP3,TYPE_SINGLECHEKBOX,IDC_PARTAGE_USEMAP3),

	// Age 1
	ParamUIDesc(
		PB_AGE1,
		EDITTYPE_FLOAT,
		IDC_PARTAGE_AGE1,IDC_PARTAGE_AGE1SPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Age 2
	ParamUIDesc(
		PB_AGE2,
		EDITTYPE_FLOAT,
		IDC_PARTAGE_AGE2,IDC_PARTAGE_AGE2SPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Age 3
	ParamUIDesc(
		PB_AGE3,
		EDITTYPE_FLOAT,
		IDC_PARTAGE_AGE3,IDC_PARTAGE_AGE3SPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),
	};
*/
#define PARAMDESC_LENGH 9

static ParamBlockDescID descVer0[] = {
	{ TYPE_RGBA, NULL, TRUE, page_color1 }, // Color 1
	{ TYPE_RGBA, NULL, TRUE, page_color2 }, // Color 2
	{ TYPE_RGBA, NULL, TRUE, page_color3 }, // Color 3	
	{ TYPE_INT,  NULL, FALSE, page_map1_on },	// use map 1
	{ TYPE_INT,  NULL, FALSE, page_map2_on },	// use map 2
	{ TYPE_INT,  NULL, FALSE, page_map3_on },	// use map 3
	{ TYPE_FLOAT,  NULL, TRUE, page_page1 },	// Age 1
	{ TYPE_FLOAT,  NULL, TRUE, page_page2 },	// Age 2
	{ TYPE_FLOAT,  NULL, TRUE, page_page3 },	// Age 3
	};

#define PBLOCK_LENGTH	9

//static ParamVersionDesc versions[] = {
//	ParamVersionDesc(descVer0,12,0),	
//	ParamVersionDesc(descVer1,15,1),
//	};
//#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION	0
//static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,9,0)
};
//--- PartAgeTex Methods -----------------------------------------------

PartAgeTex::PartAgeTex()
	{
	pblock   = NULL;	
	texout   = NULL;
	subTex[0] = subTex[1] = subTex[2] = NULL;
	partAgeCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	InitializeCriticalSection(&csect);
	ivalid.SetEmpty();
	}

ParamDlg* PartAgeTex::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	IAutoMParamDlg* masterDlg = partAgeCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(texoutDlg);
	return masterDlg;
	}

void PartAgeTex::Update(TimeValue t, Interval& valid)
	{
	EnterCriticalSection(&csect);
	if (!ivalid.InInterval(t)) {
		ivalid = FOREVER;				
		texout->Update(t,ivalid);
/*
		pblock->GetValue(PB_COL1,t,col1,ivalid);
		pblock->GetValue(PB_COL2,t,col2,ivalid);
		pblock->GetValue(PB_COL3,t,col3,ivalid);
		pblock->GetValue(PB_USEMAP1,t,usemap1,ivalid);
		pblock->GetValue(PB_USEMAP2,t,usemap2,ivalid);
		pblock->GetValue(PB_USEMAP3,t,usemap3,ivalid);
		pblock->GetValue(PB_AGE1,t,p1,ivalid);
		pblock->GetValue(PB_AGE2,t,p2,ivalid);
		pblock->GetValue(PB_AGE3,t,p3,ivalid);
*/
		pblock->GetValue(page_color1,t,col1,ivalid);
		pblock->GetValue(page_color2,t,col2,ivalid);
		pblock->GetValue(page_color3,t,col3,ivalid);
		pblock->GetValue(page_map1_on,t,usemap1,ivalid);
		pblock->GetValue(page_map2_on,t,usemap2,ivalid);
		pblock->GetValue(page_map3_on,t,usemap3,ivalid);
		pblock->GetValue(page_page1,t,p1,ivalid);
		pblock->GetValue(page_page2,t,p2,ivalid);
		pblock->GetValue(page_page3,t,p3,ivalid);
		p1 = p1 *0.01f;
		p2 = p2 *0.01f;
		p3 = p3 *0.01f;
		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}		
		}
	valid &= ivalid;
	LeaveCriticalSection(&csect);
	}

void PartAgeTex::Init()
	{
//	ReplaceReference(0, 
//		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));	

/*
	pblock->SetValue(PB_COL1,0,Point3( 1 , 1 , 1 ));
	pblock->SetValue(PB_COL2,0,Point3(.5f,.5f,.5f));
	pblock->SetValue(PB_COL3,0,Point3( 0 , 0 , 0 ));
	pblock->SetValue(PB_USEMAP1,0,1);
	pblock->SetValue(PB_USEMAP2,0,1);
	pblock->SetValue(PB_USEMAP3,0,1);
	pblock->SetValue(PB_AGE1,0,0.0f);
	pblock->SetValue(PB_AGE2,0,0.5f);
	pblock->SetValue(PB_AGE3,0,1.0f);
*/
//	if (paramDlg) 
//		paramDlg->pmap->SetParamBlock(pblock);

	ivalid.SetEmpty();	

	if (texout) texout->Reset();
	else ReplaceReference(1, GetNewDefaultTextureOutput());
	}

void PartAgeTex::Reset()
	{
	partAgeCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}


BOOL PartAgeTex::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((texoutDlg!= NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}



AColor PartAgeTex::EvalColor(ShadeContext& sc)
	{
	if (gbufID) sc.SetGBufferID(gbufID);
	Color tcol1 = col1;
	Color tcol2 = col2;
	Color tcol3 = col3;

	// Evaluate...
	Object *ob = sc.GetEvalObject();
	float u=0.0f;
	if (ob && ob->IsParticleSystem()) {
		ParticleObject *obj = (ParticleObject*)ob;
		TimeValue t = sc.CurTime();
		TimeValue age  = obj->ParticleAge(t,sc.mtlNum);
		TimeValue life = obj->ParticleLife(t,sc.mtlNum);
		if (age>=0 && life>=0) 
			u = float(age)/float(life);
		}

	if (u<p1) {
		if (usemap1 && subTex[0]) tcol1 = subTex[0]->EvalColor(sc);
		return texout->Filter(RGBA(tcol1));
	} else 
	if (u<p2) {
		u = (u-p1)/(p2-p1);
		if (usemap1 && subTex[0]) tcol1 = subTex[0]->EvalColor(sc);
		if (usemap2 && subTex[1]) tcol2 = subTex[1]->EvalColor(sc);
		return texout->Filter(RGBA(tcol2*u + (1.0f-u)*tcol1));	
	} else 
	if (u<p3) {
		u = (u-p2)/(p3-p2);
		if (usemap2 && subTex[1]) tcol2 = subTex[1]->EvalColor(sc);
		if (usemap3 && subTex[2]) tcol3 = subTex[2]->EvalColor(sc);
		return texout->Filter(RGBA(tcol3*u + (1.0f-u)*tcol2));		
	} else {
		if (usemap3 && subTex[2]) tcol3 = subTex[2]->EvalColor(sc);
		return texout->Filter(RGBA(tcol3));	
		}
	}

float PartAgeTex::EvalMono(ShadeContext& sc)
	{
	return Intens(EvalColor(sc));
	}

Point3 PartAgeTex::EvalNormalPerturb(ShadeContext& sc)
	{	
	Point3 np(0,0,0);	
	return texout->Filter(sc.VectorFrom(np,REF_OBJECT));
	}

void PartAgeTex::SetSubTexmap(int i, Texmap *m)
	{
	ReplaceReference(i+2,m);
//	if (paramDlg) paramDlg->UpdateSubTexNames();
	if (i==0)
		{
		page_param_blk.InvalidateUI(page_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		page_param_blk.InvalidateUI(page_map2);
		ivalid.SetEmpty();
		}	
	else if (i==2)
		{
		page_param_blk.InvalidateUI(page_map3);
		ivalid.SetEmpty();
		}	

	}

TSTR PartAgeTex::GetSubTexmapSlotName(int i)
	{
	switch (i) {
		case 0:  return GetString(IDS_RB_COLOR1);
		case 1:  return GetString(IDS_RB_COLOR2);
		case 2:  return GetString(IDS_RB_COLOR3);
		default: return _T("");
		}
	}

Animatable* PartAgeTex::SubAnim(int i)
	{
	return GetReference(i);
	}

TSTR PartAgeTex::SubAnimName(int i)
	{
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));		
		case 1: return TSTR(GetString(IDS_DS_OUTPUT));		
		default: return GetSubTexmapTVName(i-2);
		}
	assert(0); 
	return _T("");

	}

RefTargetHandle PartAgeTex::GetReference(int i)
	{
	switch (i) {
		case 0:  return pblock;		
		case 1:  return texout;
		default: return subTex[i-2];
		}
	}

void PartAgeTex::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0:  pblock = (IParamBlock2*)rtarg; break;		
		case 1:  texout = (TextureOutput *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
	}

#define MTL_HDR_CHUNK 	0x4000


#define PARAM2_CHUNK 0x1010

IOResult PartAgeTex::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();


	return IO_OK;
	}	



//watje
class PartAgePostLoadCallback:public  PostLoadCallback
{
public:
	PartAgeTex      *s;
	int Param1;
	PartAgePostLoadCallback(PartAgeTex *r, BOOL b) {s=r;Param1 = b;}
	void proc(ILoad *iload);
};

void PartAgePostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{

		Interval ivalid;
		TimeValue t = 0;
		s->pblock->GetValue(page_page1,t,s->p1,ivalid);
		s->pblock->GetValue(page_page2,t,s->p2,ivalid);
		s->pblock->GetValue(page_page3,t,s->p3,ivalid);


		s->p1 *= 100.0f;
		s->p2 *= 100.0f;
		s->p3 *= 100.0f;

		s->pblock->SetValue(page_page1,t,s->p1);
		s->pblock->SetValue(page_page2,t,s->p2);
		s->pblock->SetValue(page_page3,t,s->p3);

		}
	delete this;
}


IOResult PartAgeTex::Load(ILoad *iload)
	{
#if 0
//	iload->RegisterPostLoadCallback(
//		new ParamBlockPLCB(
//			versions, 
//			NUM_OLDVERSIONS, 
//			&curVersion, this, 0/*ref # */));
#endif	

	IOResult res;
	int id;
	BOOL Param1 = TRUE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &page_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

	PartAgePostLoadCallback* partAgeplcb = new PartAgePostLoadCallback(this,Param1);
	iload->RegisterPostLoadCallback(partAgeplcb);


	return IO_OK;
	}

RefTargetHandle PartAgeTex::Clone(RemapDir &remap)
	{
	PartAgeTex *map = new PartAgeTex;
	*((MtlBase*)map) = *((MtlBase*)this);  // copy superclass stuff
	map->ReplaceReference(0,remap.CloneRef(pblock));		
	map->ReplaceReference(1,remap.CloneRef(texout));
	for (int i=0; i<NSUBTEX; i++) {
		if (subTex[i]) map->ReplaceReference(2+i,remap.CloneRef(subTex[i]));
		}
	return map;
	}

RefResult PartAgeTex::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//				if (hTarget != texout ) 
					page_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}
			else if (hTarget == texout)
				{
			// notify our dependents that we've changed
				// NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);  
				}

			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_COL1:
				case PB_COL2:
				case PB_COL3: gpd->dim = stdColor255Dim; break;
				case PB_AGE1:
				case PB_AGE2:
				case PB_AGE3: gpd->dim = stdPercentDim; break;
				default:      gpd->dim = defaultDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_COL1:  gpn->name = GetString(IDS_RB_COLOR1); break;
				case PB_COL2:  gpn->name = GetString(IDS_RB_COLOR2); break;
				case PB_COL3:  gpn->name = GetString(IDS_RB_COLOR3); break;
				case PB_AGE1:  gpn->name = GetString(IDS_RB_AGE1); break;
				case PB_AGE2:  gpn->name = GetString(IDS_RB_AGE2); break;
				case PB_AGE3:  gpn->name = GetString(IDS_RB_AGE3); break;
				default: gpn->name = _T("Parameter");  break;
				}
			return REF_STOP; 
			}
*/
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mtlhdr.h ===
/**********************************************************************
 *<
	FILE: mtlhdr.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __MTLHDR__H
#define __MTLHDR__H

#define USE_STDMTL2_AS_STDMTL

#ifdef BLD_MTL
#define MtlExport __declspec( dllexport )
#else
#define MtlExport __declspec( dllimport )
#endif

#include "max.h"
#include "imtl.h"
#include "texutil.h"

extern ClassDesc* GetStdMtlDesc();
extern ClassDesc* GetStdMtl2Desc();
extern ClassDesc* GetBMTexDesc();
extern ClassDesc* GetTexmapsDesc();
extern ClassDesc* GetTexmaps2Desc();
extern ClassDesc* GetOldTexmapsDesc();
extern ClassDesc* GetOldTexmaps2Desc();
extern ClassDesc* GetCMtlDesc();
extern ClassDesc* GetCheckerDesc();
extern ClassDesc* GetMixDesc();
extern ClassDesc* GetMarbleDesc();
extern ClassDesc* GetMaskDesc();
extern ClassDesc* GetTintDesc();
extern ClassDesc* GetNoiseDesc();
extern ClassDesc* GetMultiDesc();
extern ClassDesc* GetDoubleSidedDesc();
extern ClassDesc* GetMixMatDesc();
extern ClassDesc* GetACubicDesc();
extern ClassDesc* GetMirrorDesc();
extern ClassDesc* GetGradientDesc();
extern ClassDesc* GetCompositeDesc();
extern ClassDesc* GetMatteDesc();
extern ClassDesc* GetRGBMultDesc();
extern ClassDesc* GetOutputDesc();
extern ClassDesc* GetFalloffDesc();
extern ClassDesc* GetVColDesc();
extern ClassDesc* GetPartBlurDesc();
extern ClassDesc* GetPlateDesc();
extern ClassDesc* GetPartAgeDesc();
extern ClassDesc* GetCompositeMatDesc();

// old shaders are here, mostly to guarantee the existance of the default shader
extern ClassDesc* GetConstantShaderCD();
extern ClassDesc* GetPhongShaderCD();
extern ClassDesc* GetBlinnShaderCD();
extern ClassDesc* GetOldBlinnShaderCD();
extern ClassDesc* GetMetalShaderCD();

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\multi.cpp ===
/**********************************************************************
 *<
	FILE: multi.cpp

	DESCRIPTION:  Composite material

	CREATED BY: Dan Silva

	HISTORY: UPdated to Param2 1/11/98 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "macrorec.h"

extern HINSTANCE hInstance;

#define NSUBMTLS 10
static Class_ID multiClassID(MULTI_CLASS_ID,0);

class Multi;
class MultiDlg;



#define PBLOCK_REF	0
#define MTL_REF		1

class MultiDlg: public ParamDlg {
	public:		
		HWND hwmedit;	 // window handle of the materials editor dialog
		IMtlParams *ip;
		Multi *theMtl;	 // current mtl being edited.
		HWND hPanelBasic; // Rollup pane		
		HWND hScroll;
		TimeValue curTime; 
		int isActive;
		BOOL valid;
		ICustButton *iBut[NSUBMTLS];
		ICustEdit *iName[NSUBMTLS];
		MtlDADMgr dadMgr;
				
		MultiDlg(HWND hwMtlEdit, IMtlParams *imp, Multi *m); 
		~MultiDlg();
		BOOL BasicPanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
		void VScroll(int code, short int cpos );
		void UpdateSubMtlNames();
		void UpdateColorSwatches();
		void LoadDialog(BOOL draw);  // stuff params into dialog
		void Invalidate() {
			valid = FALSE;
			Rect rect;
			rect.left = rect.top = 0;
			rect.right = rect.bottom = 10;
			InvalidateRect(hPanelBasic,&rect,FALSE);
			}
		void ReloadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void ActivateDlg(BOOL onOff) {}
		void SetNumMats(HWND hWnd);
		void DragAndDrop(int ifrom, int ito);
		int SubMtlNumFromNameID(int id);

		// methods inherited from ParamDlg:
		Class_ID ClassID() {return multiClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theMtl; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);
		int FindSubMtlFromHWND(HWND hw);
	};


// Parameter block indices
#define PB_THRESH		0
#define PB_WIDTH		1

class Multi: public MultiMtl {
	friend class MultiDlg;
	friend class SetNumMtlsRestore;
	// Animatable parameters
	Interval ivalid;
	MultiDlg *paramDlg;
	int offset;
	public:
		NameTab subNames;
		Tab<Mtl *>subMtl;
//		Tab<BOOL>mapOn;

		BOOL Param1;
		IParamBlock2 *pblock;   // ref #0		

		BOOL loadingOld;
		void SetNumSubMtls(int n);
		void ClampOffset();

		void SetAmbient(Color c, TimeValue t) {}		
		void SetDiffuse(Color c, TimeValue t) {}		
		void SetSpecular(Color c, TimeValue t) {}
		void SetShininess(float v, TimeValue t) {}		
		void SetThresh(float v, TimeValue t);
		void SetWidth(float v, TimeValue t);

		Mtl *UseMtl();
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float WireSize(int mtlNum=0, BOOL backFace=FALSE);

		Multi(BOOL loading, BOOL createDefaultSubMtls = TRUE); // mjm - 10.11.99 - added createDefaultSubMtls parameter
		void SetParamDlg( MultiDlg *pd) { paramDlg = pd; }
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		void NotifyChanged();

		Class_ID ClassID() {	return multiClassID; }
		SClass_ID SuperClassID() { return MATERIAL_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_MULTISUBOBJECT); }  

		void DeleteThis() { delete this; }	

		// Methods to access sub-materials of meta-materials
	   	int NumSubMtls() { return subMtl.Count(); }
		Mtl* GetSubMtl(int i) { return subMtl[i]; }
		void SetSubMtl(int i, Mtl *m);
		TSTR GetSubMtlSlotName(int i);
		BOOL IsMultiMtl() { return TRUE; }

		int NumSubs() { return subMtl.Count(); }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum+1; }

		// From ref
		int NumRefs() { return loadingOld?subMtl.Count()+1: subMtl.Count()+1;  }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int RemapRefOnLoad(int iref) ;

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};


int numMultis = 0;
class MultiClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Multi(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_RB_MULTISUBOBJECT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return MATERIAL_CLASS_ID; }
	Class_ID 		ClassID() { return multiClassID; }
	const TCHAR* 	Category() { return _T("");  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("multiSubMaterial"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static MultiClassDesc multiCD;

ClassDesc* GetMultiDesc() { 
	return &multiCD;  
	}


//-----------------------------------------------------------------------------
//  Multi
//-----------------------------------------------------------------------------
// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { multi_params, };  // pblock ID
// multi_params param IDs
enum 
{ 
	multi_mtls,
	multi_ons,
	multi_names,

};

// per instance gradient block
static ParamBlockDesc2 multi_param_blk ( multi_params, _T("parameters"),  0, &multiCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_MULTI, IDS_DS_MULTI_PARAMS, 0, 0, NULL, 
	// params
	multi_mtls,	_T("materialList"),	TYPE_MTL_TAB,	10,		P_OWNERS_REF + P_VARIABLE_SIZE,	IDS_RB_MATERIAL2,	
		p_refno,		MTL_REF, 
		end,
	multi_ons,	_T("mapEnabled"), TYPE_BOOL_TAB,	10,		P_VARIABLE_SIZE,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		end,
	multi_names, _T("names"), TYPE_STRING_TAB,		10,		P_VARIABLE_SIZE,				IDS_DS_MAP,
		end,


	end
);


static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	MultiDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (MultiDlg*)lParam;
		theDlg->hPanelBasic = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (MultiDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->BasicPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}


int MultiDlg::FindSubMtlFromHWND(HWND hw) {
	for (int i=0; i<NSUBMTLS; i++) {
		if (hw == iBut[i]->GetHwnd()) return i+theMtl->offset;
		}	
	return -1;
	}

void MultiDlg::DragAndDrop(int ifrom, int ito) {
	theMtl->CopySubMtl(hPanelBasic,ifrom+theMtl->offset, ito+theMtl->offset);
	theMtl->NotifyChanged();
	UpdateMtlDisplay();
	}

//-------------------------------------------------------------------

MultiDlg::MultiDlg(HWND hwMtlEdit, IMtlParams *imp, Multi *m) { 
	dadMgr.Init(this);
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanelBasic = NULL;
	theMtl = m; 
	isActive = 0;
	valid = FALSE;
	theMtl->ClampOffset();
	for (int i=0; i<NSUBMTLS; i++) iBut[i] = NULL;
	for (i=0; i<NSUBMTLS; i++) iName[i] = NULL;
	hPanelBasic = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_MULTI),
		PanelDlgProc, 
		GetString(IDS_DS_MULTI_PARAMS), 
		(LPARAM)this );		
	curTime = imp->GetTime();
	}

void MultiDlg::ReloadDialog() {
	Interval valid;
	theMtl->Update(curTime,valid);
	LoadDialog(FALSE);
	}

void MultiDlg::SetTime(TimeValue t) {
	if (t!=curTime) {
		Interval valid;
		curTime = t;
		theMtl->Update(curTime,valid);
		// Since nothing is time varying, can skip this
		//InvalidateRect(hPanelBasic,NULL,0);
		}
	}

MultiDlg::~MultiDlg() {
	theMtl->SetParamDlg(NULL);	
	SetWindowLong(hPanelBasic, GWL_USERDATA, NULL);
	hPanelBasic =  NULL;
	for (int i=0; i<NSUBMTLS; i++) {
		ReleaseICustButton(iBut[i]);
		ReleaseICustEdit(iName[i]);
		iBut[i] = NULL; 
		iName[i] = NULL;
		}
	}


static int subMtlId[NSUBMTLS] = {
	IDC_MULTI_MTL0,
	IDC_MULTI_MTL1,
	IDC_MULTI_MTL2,
	IDC_MULTI_MTL3,
	IDC_MULTI_MTL4,
	IDC_MULTI_MTL5,
	IDC_MULTI_MTL6,
	IDC_MULTI_MTL7,
	IDC_MULTI_MTL8,
	IDC_MULTI_MTL9
	};


static int subNameId[NSUBMTLS] = {
	IDC_MTL_NAME0,
	IDC_MTL_NAME1,
	IDC_MTL_NAME2,
	IDC_MTL_NAME3,
	IDC_MTL_NAME4,
	IDC_MTL_NAME5,
	IDC_MTL_NAME6,
	IDC_MTL_NAME7,
	IDC_MTL_NAME8,
	IDC_MTL_NAME9
	};

static int mapOnIDs[] = {
	IDC_MAPON1,
	IDC_MAPON2,
	IDC_MAPON3,
	IDC_MAPON4,
	IDC_MAPON5,
	IDC_MAPON6,
	IDC_MAPON7,
	IDC_MAPON8,
	IDC_MAPON9,
	IDC_MAPON10,
	};
static int numIDs[] = {
	IDC_MULT_NUM1,
	IDC_MULT_NUM2,
	IDC_MULT_NUM3,
	IDC_MULT_NUM4,
	IDC_MULT_NUM5,
	IDC_MULT_NUM6,
	IDC_MULT_NUM7,
	IDC_MULT_NUM8,
	IDC_MULT_NUM9,
	IDC_MULT_NUM10,
	};	

int MultiDlg::SubMtlNumFromNameID(int id) {
	for (int i=0; i<NSUBMTLS; i++) {
		if (subNameId[i]==id) return i;
		}
	return 0;
	}

void MultiDlg::VScroll(int code, short int cpos ) {
	for (int i=0; i<NSUBMTLS; i++) {
		if (iName[i]->HasFocus()) 
			SetFocus(NULL);
		}
	switch (code) {
		case SB_LINEUP: 	theMtl->offset--;		break;
		case SB_LINEDOWN:	theMtl->offset++;		break;
		case SB_PAGEUP:		theMtl->offset -= NSUBMTLS;	break;
		case SB_PAGEDOWN:	theMtl->offset += NSUBMTLS;	break;
		
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK:
			theMtl->offset = cpos;
			break;
		}

	theMtl->ClampOffset();
	UpdateSubMtlNames();						
	}

BOOL MultiDlg::BasicPanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:	 {		
			hScroll	= GetDlgItem(hwndDlg,IDC_MULTI_SCROLL);
			SetScrollRange(hScroll,SB_CTL,0,theMtl->NumSubMtls()-NSUBMTLS,FALSE);
			SetScrollPos(hScroll,SB_CTL,theMtl->offset,TRUE);
			EnableWindow(hScroll,theMtl->subMtl.Count()>NSUBMTLS);
			for (int i=0; i<NSUBMTLS; i++) {
				iBut[i] = GetICustButton(GetDlgItem(hwndDlg,subMtlId[i]));
				iBut[i]->SetDADMgr(&dadMgr);
				iName[i] = GetICustEdit( GetDlgItem(hwndDlg,subNameId[i]));
				iName[i]->SetLeading(2); //??
				if (i+theMtl->offset<theMtl->NumSubMtls()) {
					TCHAR *name;
					Interval iv;
					theMtl->pblock->GetValue(multi_names,0,name,iv,i+theMtl->offset);
					iName[i]->SetText(name);
//					iName[i]->SetText(theMtl->subNames[i+theMtl->offset]);
					}
				TSTR buf;
				buf.printf("%d:",i+theMtl->offset+1);
				SetDlgItemText(hwndDlg,numIDs[i],buf);
				int onCount = theMtl->pblock->Count(multi_ons);
				if (i-theMtl->offset<onCount)
					{
					int on;
					Interval iv;
					theMtl->pblock->GetValue(multi_ons,0,on,iv,i+theMtl->offset);
					SetCheckBox(hwndDlg, mapOnIDs[i], on);
					}
//				if (i-theMtl->offset<theMtl->mapOn.Count())
//					SetCheckBox(hwndDlg, mapOnIDs[i], theMtl->mapOn[i+theMtl->offset]);
				}
			}
			return TRUE;
		case WM_VSCROLL:
			VScroll(LOWORD(wParam),(short int)HIWORD(wParam));
			break;
			
		case WM_COMMAND:  
		    switch (id) {
				case IDC_MULTI_MTL0: 
				case IDC_MULTI_MTL1: 
				case IDC_MULTI_MTL2: 
				case IDC_MULTI_MTL3: 
				case IDC_MULTI_MTL4: 
				case IDC_MULTI_MTL5: 
				case IDC_MULTI_MTL6: 
				case IDC_MULTI_MTL7: 
				case IDC_MULTI_MTL8: 
				case IDC_MULTI_MTL9: 
					if (id-IDC_MULTI_MTL0 + theMtl->offset < theMtl->subMtl.Count()) {
						PostMessage(hwmedit,WM_SUB_MTL_BUTTON, 
							id-IDC_MULTI_MTL0 + theMtl->offset ,(LPARAM)theMtl);
						}
					break;
				
				case IDC_MAPON1:							
				case IDC_MAPON2:							
				case IDC_MAPON3:							
				case IDC_MAPON4:							
				case IDC_MAPON5:							
				case IDC_MAPON6:
				case IDC_MAPON7:
				case IDC_MAPON8:
				case IDC_MAPON9:
				case IDC_MAPON10:
//					theMtl->mapOn[id-IDC_MAPON1+theMtl->offset] = GetCheckBox(hwndDlg, id);
					{
					int on = GetCheckBox(hwndDlg, id);
					Interval iv;
					theMtl->pblock->SetValue(multi_ons,0,on,id-IDC_MAPON1+theMtl->offset);

					theMtl->NotifyChanged();
					break;
					}
				case IDC_MULTI_SETNUM:
					SetNumMats(hwndDlg);
					break;
				case IDC_MTL_NAME0: 
				case IDC_MTL_NAME1: 
				case IDC_MTL_NAME2: 
				case IDC_MTL_NAME3: 
				case IDC_MTL_NAME4: 
				case IDC_MTL_NAME5: 
				case IDC_MTL_NAME6: 
				case IDC_MTL_NAME7: 
				case IDC_MTL_NAME8: 
				case IDC_MTL_NAME9: 
					if (HIWORD(wParam)==EN_CHANGE) {
						TCHAR buf[200];
						int n = SubMtlNumFromNameID(id);
						iName[n]->GetText(buf,199);
//						theMtl->subNames.SetName(n+theMtl->offset, buf);
						theMtl->pblock->SetValue(multi_names,0,buf,n+theMtl->offset);

						}
					break;
				}
			break;
		case WM_PAINT:
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
			break;       
		case WM_DESTROY: 
			break;		
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE: {
			if (HIWORD(wParam)) theHold.Begin();
			int i = LOWORD(wParam)-IDC_MULTI_COLOR1+theMtl->offset;
			IColorSwatch *cs = (IColorSwatch*)lParam;
			if (i>=0 && i<theMtl->subMtl.Count()&&theMtl->subMtl[i]) {
				theMtl->subMtl[i]->SetDiffuse(
					cs->GetColor(),curTime);
				}
			UpdateColorSwatches();
			if (HIWORD(wParam)) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			    UpdateMtlDisplay();
				}
			break;
			}

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
		    UpdateMtlDisplay();
			break;

    	}
	return FALSE;
	}

static BOOL CALLBACK  BasicPanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	MultiDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (MultiDlg*)lParam;
		theDlg->hPanelBasic = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (MultiDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->BasicPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

void MultiDlg::UpdateColorSwatches() {
	for (int i=0; i<theMtl->subMtl.Count()-theMtl->offset && i<NSUBMTLS; i++) {
		Mtl *m = theMtl->subMtl[i+theMtl->offset];
			
		TSTR nm, label;
			if (m) 	nm = m->GetFullName();
			else 	nm = GetString(IDS_DS_NONE);
		if (m) {
			IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hPanelBasic,IDC_MULTI_COLOR1+i),
				m->GetDiffuse(),nm);
			cs->SetColor(m->GetDiffuse());
			ReleaseIColorSwatch(cs);
			}
		}
	}


void MultiDlg::UpdateSubMtlNames() {
	IColorSwatch *cs;	
	int ct = theMtl->pblock->Count(multi_names);

	for (int i=0; i<theMtl->subMtl.Count()-theMtl->offset && i<NSUBMTLS; i++) {
		Mtl *m = theMtl->subMtl[i+theMtl->offset];
		TSTR nm, label;
		if (m) 
			nm = m->GetFullName();
		else 
			nm = GetString(IDS_DS_NONE);
		
		ShowWindow(GetDlgItem(hPanelBasic, IDC_MULTI_MTL0+i), SW_SHOW);
		ShowWindow(GetDlgItem(hPanelBasic, IDC_MULTI_COLOR1+i), SW_SHOW);
		ShowWindow(GetDlgItem(hPanelBasic, subNameId[i]), SW_SHOW);
		ShowWindow(GetDlgItem(hPanelBasic,mapOnIDs[i]),SW_SHOW);

		int on;
		Interval iv;

		if ((i+theMtl->offset)<ct)
			{
			theMtl->pblock->GetValue(multi_ons,0,on,iv,i+theMtl->offset);

			SetCheckBox(hPanelBasic, mapOnIDs[i], on);
			}
//		SetCheckBox(hPanelBasic, mapOnIDs[i], theMtl->mapOn[i+theMtl->offset]);

//		SetDlgItemText(hPanelBasic, IDC_MULTI_MTL0+i, nm.data());
		iBut[i]->SetText(nm.data());

		if (m) {
			cs = GetIColorSwatch(GetDlgItem(hPanelBasic,IDC_MULTI_COLOR1+i),
				m->GetDiffuse(),nm);
			cs->SetColor(m->GetDiffuse());
			ReleaseIColorSwatch(cs);
			}

		TCHAR *name;
		Interval niv;
		if ((i+theMtl->offset)<ct)
			{
			theMtl->pblock->GetValue(multi_names,0,name,niv,i+theMtl->offset);
			if (name) {
				TCHAR buf[256];
				iName[i]->GetText(buf,255);
				if (_tcscmp(name,buf))
					iName[i]->SetText(name);
				}
			else iName[i]->SetText(_T(""));
			}
//		iName[i]->SetText(theMtl->subNames[i+theMtl->offset]);
		TSTR buf;
		buf.printf("%d:",i+theMtl->offset+1);
		SetDlgItemText(hPanelBasic,numIDs[i],buf);
		}
	for ( ; i<NSUBMTLS; i++) {
		ShowWindow(GetDlgItem(hPanelBasic, IDC_MULTI_MTL0+i), SW_HIDE);
		ShowWindow(GetDlgItem(hPanelBasic, IDC_MULTI_COLOR1+i), SW_HIDE);
		ShowWindow(GetDlgItem(hPanelBasic, subNameId[i]), SW_HIDE);
		ShowWindow(GetDlgItem(hPanelBasic,mapOnIDs[i]),SW_HIDE);
		TSTR buf;
		SetDlgItemText(hPanelBasic,numIDs[i],buf);
		}
	TSTR buf;
	buf.printf(_T("%d"),theMtl->subMtl.Count());
	SetDlgItemText(hPanelBasic,IDC_MULTI_NUMMATS,buf);
	SetScrollRange(hScroll,SB_CTL,0,theMtl->NumSubMtls()-NSUBMTLS,FALSE);
	SetScrollPos(hScroll,SB_CTL,theMtl->offset,TRUE);
	EnableWindow(hScroll,theMtl->subMtl.Count()>NSUBMTLS);
	}

void MultiDlg::LoadDialog(BOOL draw) {
	if (theMtl) {
		Interval valid;
		theMtl->Update(curTime,valid);
		UpdateSubMtlNames();		
		}
	}

void MultiDlg::SetThing(ReferenceTarget *m) {
	assert (m->ClassID()==multiClassID);
	assert (m->SuperClassID()==MATERIAL_CLASS_ID);
	if (theMtl) theMtl->paramDlg = NULL;
	theMtl = (Multi *)m;
	if (theMtl) theMtl->paramDlg = this;
	LoadDialog(TRUE);
	}


static BOOL CALLBACK NumMatsDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			ISpinnerControl *spin = 
				SetupIntSpinner(
					hWnd,IDC_MULTI_NUMMATSSPIN,IDC_MULTI_NUMMATS,
					1,1000,(int)lParam);
			ReleaseISpinner(spin);
			CenterWindow(hWnd,GetParent(hWnd));
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin = 
						GetISpinner(GetDlgItem(hWnd,IDC_MULTI_NUMMATSSPIN));
					EndDialog(hWnd,spin->GetIVal());
					ReleaseISpinner(spin);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void MultiDlg::SetNumMats(HWND hWnd)
	{
	int res = DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_MULTI_SETNUM),
		hPanelBasic,
		NumMatsDlgProc,
		(LPARAM)theMtl->subMtl.Count());
	if (res>=0) {
		if (res<=0) res = 1;
		if (res>1000) res = 1000;
		HCURSOR c = SetCursor(LoadCursor(NULL,IDC_WAIT));
		theMtl->SetNumSubMtls(res);
		SetCursor(c);
		theMtl->ClampOffset();
		UpdateSubMtlNames();
	
		GetCOREInterface()->FlushUndoBuffer();  // DS 6/7/99
		}
	}

//-----------------------------------------------------------------------------
//  Multi
//-----------------------------------------------------------------------------

static ParamBlockDesc pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE } };   // blend

void Multi::Init() {
	ivalid.SetEmpty();
	offset = 0;
	}

void Multi::Reset() {
	Init();
	multiCD.Reset(this, TRUE);	// reset all pb2's
//	for (int i=0; i<subMtl.Count(); i++)
//		DeleteReference(i+1);
	SetNumSubMtls(NSUBMTLS);
	for (int i=0; i<subMtl.Count(); i++) {
		ReplaceReference(i+1,(ReferenceTarget*)GetStdMtl2Desc()->Create());
		GetCOREInterface()->AssignNewName(subMtl[i]);
		}
	}

void Multi::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Multi::Multi(BOOL loading, BOOL createDefaultSubMtls) // mjm - 10.11.99 - added createDefaultSubMtls parameter
{
	paramDlg = NULL;
	Param1 = FALSE;
	/*
	subMtl.SetCount(NSUBMTLS);
	for (int i=0; i<NSUBMTLS; i++)  subMtl[i] = NULL;
	*/
	pblock = NULL;

	loadingOld = FALSE;
	multiCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();

	if (!loading && createDefaultSubMtls) // mjm - 10.11.99
		SetNumSubMtls(NSUBMTLS);

	pblock->DefineParamAlias(_T("material1"), multi_mtls, 0);  // JBW 5/24/99, add alias for base material to support macroRecording
}

Mtl *Multi::UseMtl() {
	Mtl* m = NULL;
	for (int i=0; i<subMtl.Count(); i++) if (subMtl[i]) { m = subMtl[i]; break; }
	return m;
	}

void Multi::ClampOffset()
	{
	if (offset>subMtl.Count()-NSUBMTLS) {
		offset=subMtl.Count()-NSUBMTLS;
		}
	if (offset<0) offset = 0;
	}

// These allow the real-time renderer to display a material appearance.
Color Multi::GetAmbient(int mtlNum, BOOL backFace) { 
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetAmbient(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetAmbient(mtlNum,backFace):Color(0,0,0);
	}		
Color Multi::GetDiffuse(int mtlNum, BOOL backFace){ 
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetDiffuse(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetDiffuse():Color(0,0,0);
	}				
Color Multi::GetSpecular(int mtlNum, BOOL backFace){
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetSpecular(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetSpecular():Color(0,0,0);
	}		

float Multi::GetXParency(int mtlNum, BOOL backFace) {
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetXParency(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetXParency():0.0f;
	}

float Multi::GetShininess(int mtlNum, BOOL backFace) {
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetShininess(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetShininess():0.0f;
	}		
float Multi::GetShinStr(int mtlNum, BOOL backFace) {
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->GetShinStr(mtlNum,backFace);
	return UseMtl()?UseMtl()->GetShinStr():0.0f;
	}

float Multi::WireSize(int mtlNum, BOOL backFace) {
	mtlNum = mtlNum%subMtl.Count();
	if (subMtl[mtlNum]) return subMtl[mtlNum]->WireSize(mtlNum,backFace);
	return UseMtl()?UseMtl()->WireSize():0.0f;
	}

RefTargetHandle Multi::Clone(RemapDir &remap) {
	Multi *mnew = new Multi(FALSE, FALSE); // mjm - 10.11.99 - don't create default subMtls
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ivalid.SetEmpty();
	int nsub = subMtl.Count();
	mnew->subMtl.SetCount(nsub);
//	mnew->mapOn.SetCount(nsub);
//	mnew->subNames.SetSize(nsub);
	mnew->offset = offset;
	mnew->ReplaceReference(PBLOCK_REF,remap.CloneRef(pblock));
	mnew->pblock->SetCount(multi_mtls, nsub);
	mnew->pblock->SetCount(multi_ons, nsub);
	mnew->pblock->SetCount(multi_names, nsub);

	for (int i = 0; i<nsub; i++)
	{
		mnew->subMtl[i] = NULL;
		if (subMtl[i])
			mnew->ReplaceReference(i+1,remap.CloneRef(subMtl[i]));
//		mnew->mapOn[i] = mapOn[i];
	}
	return (RefTargetHandle)mnew;
}


ParamDlg* Multi::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	MultiDlg *dm = new MultiDlg(hwMtlEdit, imp, this);
	dm->LoadDialog(TRUE);	
	SetParamDlg(dm);
	return dm;	
	}

void Multi::Update(TimeValue t, Interval& valid) {		
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		TCHAR *buf;
		buf = new TCHAR[200];


		for (int i=0; i<subMtl.Count(); i++) {
			if (subMtl[i]) 
				subMtl[i]->Update(t,ivalid);

			}
		delete buf;
		}
	valid &=ivalid;
	}

Interval Multi::Validity(TimeValue t) {
	Interval valid;
	Update(t,valid);
	return ivalid;
	}

class SetNumMtlsRestore : public RestoreObj {
	public:
		Multi *multi;
		Tab<Mtl*> undo, redo;
//		Tab<BOOL> undoMO, redoMO;
		SetNumMtlsRestore(Multi *m) {
			multi  = m;
			undo   = multi->subMtl;
//			undoMO = multi->mapOn;
			}
   		
		void Restore(int isUndo) {
			if (isUndo) {
				redo   = multi->subMtl;
//				redoMO = multi->mapOn;
				}
			multi->subMtl = undo;
//			multi->mapOn  = undoMO;
			}
		void Redo() {
			multi->subMtl = redo;
//			multi->mapOn  = redoMO;
			}
	};

void Multi::SetNumSubMtls(int n)
	{
	int ct = subMtl.Count();
	if (n!=ct) {
		/*
		if (theHold.Holding()) {
			theHold.Put(new SetNumMtlsRestore(this));
			}
		*/
		if (n<ct) {
			for (int i=n; i<ct; i++) {
				if (subMtl[i])
					subMtl[i]->DeactivateMapsInTree();
				ReplaceReference(i+1,NULL);
				}
			}
		subMtl.SetCount(n);
//		subNames.SetSize(n);
//		mapOn.SetCount(n);
//		pblock->SetCount(multi_mtls,n);
		if (n>ct) {
			for (int i=ct; i<subMtl.Count(); i++) {
				subMtl[i] = NULL;
				ReplaceReference(i+1,(ReferenceTarget*)GetStdMtl2Desc()->Create());
				GetCOREInterface()->AssignNewName(subMtl[i]);

//				pblock->SetValue(multi_ons,0,TRUE,i);
//				mapOn[i] = TRUE;
				}
//have to do this sepperate because setvalue causes an update and all the references are not in place yet
			macroRec->Disable();	// JBW 4/21/99, just record on count change
			pblock->SetCount(multi_ons,n);
			pblock->SetCount(multi_names,n);
			macroRec->Enable();
			pblock->SetCount(multi_mtls,n);
			for (i=ct; i<subMtl.Count(); i++) {
				pblock->SetValue(multi_ons,0,TRUE,i);
//				mapOn[i] = TRUE;
				}

			}		
		else 
			{
			macroRec->Disable();	// JBW 4/21/99, just record on count change
			pblock->SetCount(multi_ons,n);
			pblock->SetCount(multi_names,n);
			macroRec->Enable();
			pblock->SetCount(multi_mtls,n);

			}

		ClampOffset();
		NotifyChanged();
		if (paramDlg&&!paramDlg->isActive) {
			paramDlg->ReloadDialog();
			paramDlg->UpdateMtlDisplay();	  // DS 9/2/99
			}
		}
	}
//need to remap references since we added a paramblock
int Multi::RemapRefOnLoad(int iref) 
{
if (Param1) iref += 1;
return iref;
}

RefTargetHandle Multi::GetReference(int i) {
	if (loadingOld) {
		if (i==0) return NULL;
		else return subMtl[i-1];
		}
	else 
		{
		if (i==PBLOCK_REF) return pblock;
		else return subMtl[i-1];
		}
	}

void Multi::SetReference(int i, RefTargetHandle rtarg) {
	if ((i-1)>=subMtl.Count()) {
		int n = subMtl.Count();
		SetNumSubMtls(i+1);
//		subMtl.SetCount(i+1);
//		for (int j=n; j<=i; j++) // mjm - 10,11.99
//			subMtl[j] = NULL;    // mjm - 10,11.99 - default subMtl created in SetNumSubMtls()
	}
	if (loadingOld) {
		if (i==0|| (rtarg&&!IsMtl(rtarg)))  
			{ } //pblock = (IParamBlock *)rtarg;
		else 
			subMtl[i-1] = (Mtl *)rtarg;
		}
	else 
		{
		if (i==PBLOCK_REF) pblock = (IParamBlock2 *)rtarg;
 		else subMtl[i-1] = (Mtl *)rtarg;
		}
	}

void Multi::SetSubMtl(int i, Mtl *m) {
	if (i>=subMtl.Count()) {
		int n = subMtl.Count();
		SetNumSubMtls(i+1);
	    //	subMtl.SetCount(i+1);
//		for (int j=n; j<=i; j++) // mjm - 10,11.99
//			subMtl[j] = NULL;    // mjm - 10,11.99 - default subMtl created in SetNumSubMtls()
		}
	ReplaceReference(i+1,m);
	if (paramDlg)	  
		paramDlg->UpdateSubMtlNames();
	}

TSTR Multi::GetSubMtlSlotName(int i) {
	TSTR s;
	TCHAR *name;
	Interval iv;
	pblock->GetValue(multi_names,0,name,iv,i);

	if (name) 
		s.printf("(%d) %s",i+1,name);
	else 
		s.printf("(%d)",i+1);
	return s;
	}

Animatable* Multi::SubAnim(int i) {
//	if (i==PBLOCK_REF) return pblock;
//	else return subMtl[i-1]; 
	return subMtl[i]; 
	}

TSTR Multi::SubAnimName(int i) {
	return GetSubMtlTVName(i);
	}

RefResult Multi::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (paramDlg) 
				paramDlg->Invalidate();		
//			if (paramDlg&&!paramDlg->isActive) 
//					paramDlg->ReloadDialog();
			// following by JBW 45/21/99 to allow scripter-setting of submtl counts (any count change updates others)
			if (pblock &&
                    pblock->LastNotifyParamID() == multi_ons &&
                    pblock->Count(multi_ons) != subMtl.Count())
				SetNumSubMtls(pblock->Count(multi_ons));
			else if (pblock &&
                    pblock->LastNotifyParamID() == multi_names &&
                    pblock->Count(multi_names) != subMtl.Count())
				SetNumSubMtls(pblock->Count(multi_names));
			else if (pblock &&
                    pblock->LastNotifyParamID() == multi_mtls &&
                    pblock->Count(multi_mtls) != subMtl.Count())
				SetNumSubMtls(pblock->Count(multi_mtls));
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


inline void Clamp(Color &c) {
	if (c.r > 1.0f) c.r = 1.0f;
	if (c.g > 1.0f) c.g = 1.0f;
	if (c.b > 1.0f) c.b = 1.0f;
	}

static Color black(0,0,0);

void Multi::Shade(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	int mtlnum = sc.mtlNum, ct = subMtl.Count();
	if (ct) {
		if (mtlnum < 0) mtlnum = 0;
		if (mtlnum >= ct) mtlnum = mtlnum % ct;		
		Mtl* subm = subMtl[mtlnum];
		int on;
		Interval iv;
		pblock->GetValue(multi_ons,0,on,iv,mtlnum);
//		if (subm&&mapOn[mtlnum]) 
		if (subm&&on) 
			subm->Shade(sc);		
		}
	}

float Multi::EvalDisplacement(ShadeContext& sc) {
	int mtlnum = sc.mtlNum, ct = subMtl.Count();
	if (ct) {
		if (mtlnum < 0) mtlnum = 0;
		if (mtlnum >= ct) mtlnum = mtlnum % ct;		
		Mtl* subm = subMtl[mtlnum];
		int on;
		Interval iv;
		pblock->GetValue(multi_ons,0,on,iv,mtlnum);
//		if (subm&&mapOn[mtlnum]) 
		if (subm&&on) 
			return subm->EvalDisplacement(sc);		
		}
	return 0.0f;
	}

Interval Multi::DisplacementValidity(TimeValue t){
	int ct = subMtl.Count();
	Interval iv;
	iv.SetInfinite();
	for (int i=0; i<ct; i++) {
		Mtl* subm = subMtl[i];
		int on;
		Interval iv;
		pblock->GetValue(multi_ons,0,on,iv,i);
//		if (subm&&mapOn[i]) 
		if (subm&&on) 
			iv &= subm->DisplacementValidity(t);		
		}
	return iv;
	} 

#define MTL_HDR_CHUNK 0x4000
#define MULTI_NUM_OLD 0x4001
#define MULTI_NUM 0x4002
#define MULTI_NAMES 0x4010
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x4003

IOResult Multi::Save(ISave *isave) { 
	IOResult res;
	ULONG nb;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();


	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

	//int numSubs = NSUBMTLS;
	int numSubs = subMtl.Count();
	isave->BeginChunk(MULTI_NUM);
	isave->Write(&numSubs,sizeof(numSubs),&nb);			
	isave->EndChunk();


//	isave->BeginChunk(MULTI_NAMES);
//	subNames.Save(isave);
//	isave->EndChunk();

/*
	for (int i=0; i<subMtl.Count(); i++) {
		if (mapOn[i]==0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
			}
		}
*/

	return IO_OK;
	}	

//2-18-96
class MultiPostLoad : public PostLoadCallback {
	public:
		Multi *m;
		MultiPostLoad(Multi *b) {m=b;}
		void proc(ILoad *iload) {  m->loadingOld = FALSE; delete this; } 
	};

//watje
class Multi2PostLoadCallback:public  PostLoadCallback
{
public:
	Multi      *s;
	Tab<BOOL> ons;
//	NameTab subNames;

	int Param1;
	Multi2PostLoadCallback(Multi *r, BOOL b, Tab<BOOL> bl/*,	NameTab sNames*/) {s=r;Param1 = b;ons = bl;/*subNames = sNames;*/}
	void proc(ILoad *iload);
};

void Multi2PostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		s->pblock->SetCount(multi_ons,ons.Count());
		s->pblock->SetCount(multi_names,ons.Count());
		s->pblock->SetCount(multi_mtls,ons.Count());
		for (int i=0; i<s->subMtl.Count(); i++) {
			s->pblock->SetValue(multi_ons,0,ons[i],i);
			if (s->subNames[i])
				s->pblock->SetValue(multi_names,0,s->subNames[i],i);

			}
		}
	delete this;
}
	  
IOResult Multi::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	Param1 = TRUE;

	Tab<BOOL>mapOn;
//	NameTab subNames;


	while (IO_OK==(res=iload->OpenChunk())) {
		int id = iload->CurChunkID();

		if (id>=MAPOFF_CHUNK&&id<=MAPOFF_CHUNK+0x1000) {
			mapOn[id-MAPOFF_CHUNK] = FALSE; 
			}
		else 

		switch(id)  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MULTI_NUM_OLD: 
				iload->SetObsolete();
				iload->RegisterPostLoadCallback(new MultiPostLoad(this));
				loadingOld = TRUE;
			case MULTI_NUM: {
				int numSubs;
				iload->Read(&numSubs,sizeof(numSubs),&nb);			
				subMtl.SetCount(numSubs);
				mapOn.SetCount(numSubs);
				subNames.SetSize(numSubs);

				for (int i=0; i<numSubs; i++) {	
					subMtl[i] = NULL;
					mapOn[i] = TRUE;
					}
				}
				break;
			case MULTI_NAMES:
				res = subNames.Load(iload);	
				subNames.SetSize(subMtl.Count());
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	Multi2PostLoadCallback* multiplcb = new Multi2PostLoadCallback(this,Param1,mapOn);
	iload->RegisterPostLoadCallback(multiplcb);
	return IO_OK;
                                                      
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\mtlmain.cpp ===
/**********************************************************************
 *<
	FILE: mtl.cpp

	DESCRIPTION:   DLL implementation of material and textures

	CREATED BY: Dan Silva

	HISTORY: created 12 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "stdmat.h"
#include "mtlres.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();

		// register SXP readers
		RegisterSXPReader(_T("MARBLE_I.SXP"), Class_ID(MARBLE_CLASS_ID,0));
		RegisterSXPReader(_T("NOISE_I.SXP"),  Class_ID(NOISE_CLASS_ID,0));
		RegisterSXPReader(_T("NOISE2_I.SXP"), Class_ID(NOISE_CLASS_ID,0));
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_DS_MTLDESC); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() 
{
#ifndef DESIGN_VER
	return 31;
#else
	return 29;
#endif // !DESIGN_VER
}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
#ifdef USE_STDMTL2_AS_STDMTL
		case  0: return GetStdMtl2Desc();
#else
		case  0: return GetStdMtlDesc();
#endif
		case  1: return GetMultiDesc();
		case  2: return GetCMtlDesc();
		case  3: return GetBMTexDesc();
		case  4: return GetMaskDesc();
		case  5: return GetTintDesc();
		case  6: return GetCheckerDesc();
		case  7: return GetMixDesc();
		case  8: return GetMarbleDesc();
		case  9: return GetNoiseDesc();
		case 10: return GetTexmapsDesc();
		case 11: return GetDoubleSidedDesc();
		case 12: return GetMixMatDesc();
		case 13: return GetACubicDesc();
		case 14: return GetMirrorDesc();
		case 15: return GetGradientDesc();
		case 16: return GetCompositeDesc();
		case 17: return GetMatteDesc();
		case 18: return GetRGBMultDesc();
		case 19: return GetOutputDesc();
		case 20: return GetFalloffDesc();
		case 21: return GetVColDesc();
		
//		case 22: return GetConstantShaderCD();
		case 22: return GetPhongShaderCD();
		case 23: return GetBlinnShaderCD();
		case 24: return GetOldBlinnShaderCD();
		case 25: return GetMetalShaderCD();

#ifndef DESIGN_VER
		case 26: return GetPartBlurDesc();
		case 27: return GetPlateDesc();
		case 28: return GetPartAgeDesc();
		case 29: return GetOldTexmapsDesc();
		case 30: return GetCompositeMatDesc();

#else // Design Version
		case 26: return GetPlateDesc();
		case 27: return GetOldTexmapsDesc();
		case 28: return GetCompositeMatDesc();

#endif // DESIGN_VER

		default: return 0;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\partblur.cpp ===
/**********************************************************************
 *<
	FILE: PARTBLUR.CPP

	DESCRIPTION: Particle motion blur

	CREATED BY: Rolf Berteig

	HISTORY: created 2/8/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

#define PARTBLUR_CLASSID	Class_ID(0x8a746be5,0x81163ef6)

//class PartBlurParamDlg;

class PartBlur : public Texmap { 
	public:
		IParamBlock2 *pblock;

		// Caches
		Interval ivalid;
		CRITICAL_SECTION csect;
		Color color1, color2;
		float sharp;

		PartBlur();
		~PartBlur() { DeleteCriticalSection(&csect); }

		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		ULONG Requirements(int subMtlNum) {return MTLREQ_XYZ;}
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) {Update(t,FOREVER); return ivalid;}		

		// Evaluation
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);		
		Point3 EvalNormalPerturb(ShadeContext& sc);

		Class_ID ClassID() {return PARTBLUR_CLASSID;}
		SClass_ID SuperClassID() {return TEXMAP_CLASS_ID;}
		void GetClassName(TSTR& s) { s = GetString(IDS_RB_PARTBLUR); } // mjm - 2.3.99
		void DeleteThis() {delete this;}	

		int NumSubs() {return 1;}  
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return TSTR(GetString(IDS_DS_PARAMETERS));}
		
 		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock2*)rtarg;}

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		IOResult Load(ILoad *iload);
		
		// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
	};
class PartBlurClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new PartBlur;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_PARTBLUR_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return TEXMAP_CLASS_ID;}
	Class_ID 		ClassID() {return PARTBLUR_CLASSID;}
	const TCHAR* 	Category() {return TEXMAP_CAT_3D;}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("particleBlur"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static PartBlurClassDesc partBlurCD;
ClassDesc* GetPartBlurDesc() {return &partBlurCD;}


enum { pblur_params };  // pblock ID
// pblur_params param IDs
enum 
{ 
	pblur_color1, pblur_color2,
	pblur_sharp
};


static ParamBlockDesc2 pblur_param_blk ( pblur_params, _T("parameters"),  0, &partBlurCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_PBLUR_PARAMS, IDS_RB_PBLURPARAMS, 0, 0, NULL, 
	// params
	pblur_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(1.0f,1.0f,1.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_PBLUR_COLOR1, 
		end,
	pblur_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.f,0.f,0.f), 
		p_ui,			TYPE_COLORSWATCH, IDC_PBLUR_COLOR2, 
		end,
	pblur_sharp,	_T("sharp"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_SHARP,
		p_default,		2.f,
		p_range,		0.0, 9999999999.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PBLUR_SHARP, IDC_PBLUR_SHARPSPIN, 0.01f, 
		end,

	end
);




#define PARAMDESC_LENGH 3

static ParamBlockDescID descVer0[] = {
	{ TYPE_RGBA, NULL, TRUE, pblur_color1 }, // color1
	{ TYPE_RGBA, NULL, TRUE,  pblur_color2 }, // color2
	{ TYPE_FLOAT, NULL, TRUE,  pblur_sharp },	// sharp
	};
#define PBLOCK_LENGTH	3

static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),	
	};
#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	1


//--- PartBlur Methods -----------------------------------------------

PartBlur::PartBlur()
	{
	pblock = NULL;
	partBlurCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	InitializeCriticalSection(&csect);
	}

ParamDlg* PartBlur::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
	IAutoMParamDlg* masterDlg = partBlurCD.CreateParamDlgs(hwMtlEdit, imp, this);
	return masterDlg;
	}

void PartBlur::Update(TimeValue t, Interval& valid)
	{
	EnterCriticalSection(&csect);
	if (!ivalid.InInterval(t)) {
		ivalid = FOREVER;		
		pblock->GetValue(pblur_color1,t,color1,ivalid);
		pblock->GetValue(pblur_color2,t,color2,ivalid);
		pblock->GetValue(pblur_sharp,t,sharp,ivalid);		
		}
	valid &= ivalid;
	LeaveCriticalSection(&csect);
	}

void PartBlur::Init()
	{
	pblock->SetValue(pblur_color1,0,Point3(1,1,1));
	pblock->SetValue(pblur_sharp,0,2.0f);
	ivalid.SetEmpty();
	}

void PartBlur::Reset()
	{
	partBlurCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

AColor PartBlur::EvalColor(ShadeContext& sc)
	{
	if (gbufID) sc.SetGBufferID(gbufID);
	Object *ob = sc.GetEvalObject();
	if (ob && ob->IsParticleSystem()) {
		ParticleObject *obj = (ParticleObject*)ob;
		TimeValue t = sc.CurTime();
		Point3 pos  = sc.PointTo(sc.P(),REF_WORLD);
		Point3 ppos = obj->ParticlePosition(t,sc.mtlNum);
		Point3 v    = obj->ParticleVelocity(t,sc.mtlNum);
		float size  = obj->ParticleSize(t,sc.mtlNum);
		float size2 = size/2.0f;
		float s = sharp/size2;
		float u = 0.0f;
		if (size2<=sharp) {
			u = 1.0f;
			s = 1.0f;
		} else {
			int ct      = obj->ParticleCenter(t,sc.mtlNum);
			float proj  = DotProd(pos-ppos,v)/Length(v);
			switch (ct) {
				case PARTCENTER_HEAD:
					proj += size2;
					break;
				case PARTCENTER_TAIL:
					proj -= size2;
					break;
				}
			proj = (float)fabs(proj);
			if (proj<sharp) u = 1.0f;
			else {
				u = 1.0f-(proj-sharp)/(size2-sharp);		
				}
			}
		u *= s;
		if (u<0.0) u = 0.0f;
		if (u>1.0f) u = 1.0f;
		return u*color1 + (1-u)*color2;
	} else {
		return AColor(0,0,0);
		}
	}

float PartBlur::EvalMono(ShadeContext& sc)
	{
	return Intens(EvalColor(sc));
	}

Point3 PartBlur::EvalNormalPerturb(ShadeContext& sc)
	{
	return Point3(0,0,0);
	}

RefTargetHandle PartBlur::Clone(RemapDir &remap)
	{
	PartBlur *map = new PartBlur;
	*((MtlBase*)map) = *((MtlBase*)this);  // copy superclass stuff
	map->ReplaceReference(0,remap.CloneRef(pblock));	
	return map;
	}

RefResult PartBlur::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				pblur_param_blk.InvalidateUI(changing_param);
				//NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				}
			break;
		}
	return REF_SUCCEED;
	}


IOResult PartBlur::Load(ILoad *iload)
	{
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &pblur_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\stdmtl2.cpp ===
/**********************************************************************
 *<
	FILE: StdMtl2.cpp

	DESCRIPTION:  default material class

	CREATED BY: Dan Silva

	HISTORY: modified for shader plug-ins by Kells Elmquist, 1998
	         modified to use ParamBlock2's, John Wainwright, 11/16/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#include "buildver.h"
#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmtl2.h"
#include "gport.h"
#include "hsv.h"
#include "control.h"
#include "shaders.h"
#include "macrorec.h"

#ifdef USE_STDMTL2_AS_STDMTL
	static Class_ID StdMtl2ClassID(DMTL_CLASS_ID, 0);
#else
	static Class_ID StdMtl2ClassID(DMTL2_CLASS_ID, 0);
#endif

class StdMtl2ClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new StdMtl2(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_STANDARD2_CDESC); }
	SClass_ID		SuperClassID() { return MATERIAL_CLASS_ID; }
	Class_ID 		ClassID() { return StdMtl2ClassID; }
	const TCHAR* 	Category() { return _T("");  }
	// JBW: new descriptor data accessors added.  Note that the 
	//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("Standard"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

static StdMtl2ClassDesc stdmtl2CD;
ClassDesc* GetStdMtl2Desc() { return &stdmtl2CD;  }

ShaderParamDlg* StdMtl2::pShaderDlg;	
IAutoMParamDlg* StdMtl2::masterDlg;
IAutoMParamDlg* StdMtl2::texmapDlg;
IAutoMParamDlg* StdMtl2::extendedDlg;
IAutoMParamDlg* StdMtl2::samplingDlg;
HWND			StdMtl2::curHwmEdit;
IMtlParams*	    StdMtl2::curImp;
Tab<ClassDesc*> StdMtl2::shaderList;
Tab<ClassDesc*> StdMtl2::samplerList;

/////////////////////////////////////////////////////////////////////////
//	Material Texture Channels
//
#define MTL_NTEXMAPS	4


// channels ids needed by shader
#define _BUMP		0
#define _REFLECT	1
#define _REFRACT	2
#define _DISPLACE	3

// channel names
static int mtlChannelNameIDS[] = {
	IDS_DS_BU, IDS_DS_RL, IDS_DS_RR, IDS_DS_DP, 
};	

// what channel corresponds to the stdMat ID's
static int mtlStdIDToChannel[N_ID_CHANNELS] = { -1, -1, -1, -1, -1,	-1,   -1, -1, 0, 1, 2, 3  };

// internal non-local parsable channel map names
static TCHAR* mtlChannelInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("bumpMap"), _T("reflectionMap"), _T("refractionMap"), _T("displacementMap"),
	_T(""),	_T(""),	_T(""),	_T(""),

	_T(""),	_T(""),	_T(""),	_T(""),
	_T(""),	_T(""),	_T(""),	_T(""),

	_T(""),	_T(""),	_T(""),	_T(""),
	_T(""),	_T(""),	_T(""),	_T(""),
};	

// sized for nmax textures
static int mtlChannelType[STD2_NMAX_TEXMAPS] = {
	BUMP_CHANNEL, REFL_CHANNEL, REFR_CHANNEL, DISP_CHANNEL,	
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,

	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
};	


#define NO_UPDATE	-2

// parameter setter callback, reflect any ParamBlock-mediated param setting in instance data members.
// Since standard2 keeps many parameters as instance data members, these setter callbacks
// are implemented to reduce changes to existing code 
class ShaderPBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		StdMtl2* m = (StdMtl2*)owner;
		switch (id)
		{
			// use item data to unscramble sorted lists
			case std2_shader_type: {
				ClassDesc* pCD = StdMtl2::GetShaderCD(v.i);
				if (pCD && m->GetShaderIndx() != NO_UPDATE )
				{
					m->SwitchShader(pCD); 
					m->shaderId = v.i; 
				}
			} break;
			case std2_shader_by_name: {
				for (int i = 0; i < StdMtl2::NumShaders(); i++)
				{
					ClassDesc* pCD = StdMtl2::GetShaderCD(i);
					if (_tcsicmp(pCD->ClassName(), v.s) == 0)
					{
						m->pb_shader->SetValue(std2_shader_type, 0, i);
						break;
					}
				}
			} break;
			case std2_wire:
				m->SetFlag(STDMTL_WIRE, v.i); break;		
			case std2_two_sided:
				m->SetFlag(STDMTL_2SIDE, v.i); break;		
			case std2_face_map:
				m->SetFlag(STDMTL_FACEMAP, v.i); break;
			case std2_faceted:
				m->SetFlag(STDMTL_FACETED, v.i); break;
		}
	}

	void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval& valid)    // get into v
	{
		StdMtl2* m = (StdMtl2*)owner;
		switch (id)
		{
			case std2_shader_by_name: {
				ClassDesc* pCD = StdMtl2::GetShaderCD(m->shaderId);
				if (pCD)
					v.s = (TCHAR*)pCD->ClassName();
			} break;
		}
	}
};

static ShaderPBAccessor shaderPBAccessor;

// shader rollout dialog proc
class ShaderDlgProc : public ParamMap2UserDlgProc 
{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
		{
			switch (msg) 
			{
				case WM_INITDIALOG:
					//  load the shader dropdown
					HWND hwndShader = GetDlgItem(hWnd, IDC_SHADER);
					SendMessage(hwndShader, CB_RESETCONTENT, 0L, 0L);
					for (int i = 0; i < StdMtl2::NumShaders(); i++) {
						ClassDesc* pClassD = StdMtl2::GetShaderCD(i);
						int n = SendMessage(hwndShader, CB_ADDSTRING, 0L, (LPARAM)(pClassD->ClassName()) );
						SendMessage(hwndShader, CB_SETITEMDATA, n, (LPARAM)pClassD );
					}
//					StdMtl2* m = (StdMtl2*)map->GetParamBlock()->GetOwner();
//					Class_ID shadeId = m->GetShader()->ClassID();
//					macroRecorder->Disable();
//					m->SetShaderIndx( m->FindShader( shadeId ) );
//					macroRecorder->Enable();
					return TRUE;
			}
			return FALSE;
		}
		void DeleteThis() { }
};


static ShaderDlgProc shaderDlgProc;

// shader parameters
static ParamBlockDesc2 std2_shader_blk ( std2_shader, _T("shaderParameters"),  0, &stdmtl2CD, P_AUTO_CONSTRUCT + P_AUTO_UI, SHADER_PB_REF, 
	//rollout
	IDD_DMTL_SHADER4, IDS_KE_SHADER, 0, 0, &shaderDlgProc, 
	// params
	std2_shader_type, _T("shaderType"), TYPE_INT, 				0, 		IDS_JW_SHADERTYPE, 	
		p_default, 		3, 
		p_ui, 			TYPE_INTLISTBOX, IDC_SHADER, 0,
		p_accessor,		&shaderPBAccessor,
		end, 
	std2_wire, 		_T("wire"), 		TYPE_BOOL, 				0, 		IDS_DS_WIREFRAME, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_WIRE, 
		p_accessor,		&shaderPBAccessor,
		end, 
	std2_two_sided, 	_T("twoSided"), TYPE_BOOL, 				0, 		IDS_JW_TWOSIDED, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_2SIDE, 
		p_accessor,		&shaderPBAccessor,
		end, 
	std2_face_map, 	_T("faceMap"), 		TYPE_BOOL, 				0, 		IDS_JW_FACEMAP, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_FACE_MAP, 
		p_accessor,		&shaderPBAccessor,
		end, 
	std2_faceted, 		_T("faceted"), 		TYPE_BOOL, 			0, 		IDS_KE_FACETED, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_FACETED, 
		p_accessor,		&shaderPBAccessor,
		end,
	std2_shader_by_name, _T("shaderByName"), TYPE_STRING, 		0, 		IDS_JW_SHADERBYNAME, 	
		p_accessor,		&shaderPBAccessor,
		end,
	end
	);


////////////////////////
// Extended Rollout
class ExtendedPBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		StdMtl2* m = (StdMtl2*)owner;
		IParamMap2* map = m->pb_extended ? m->pb_extended->GetMap() : NULL;

		switch (id)
		{
			case std2_opacity_type:
				m->SetFlag(STDMTL_ADD_TRANSP, v.i == 2);
				m->SetFlag(STDMTL_FILT_TRANSP, v.i == 0);
				if (map != NULL)
				{
					map->Show(std2_filter_color, v.i == 0);
					map->Show(std2_ep_filter_map, v.i == 0);
					m->UpdateTexmaps();
				}
				break;
			case std2_opacity:
				m->opacity = v.f; 
				if (m->pShader->GetParamDlg())
					m->pShader->GetParamDlg()->UpdateOpacity(); 
				break;
			case std2_filter_color:
				m->filter = *v.p; break;
			case std2_falloff_type:
				m->SetFlag(STDMTL_FALLOFF_OUT, v.i == 1); break;
			case std2_falloff_amnt:
				m->opfall = v.f; break;
			case std2_ior:
				m->ioRefract = v.f; break;

			case std2_wire_size:
				m->wireSize = v.f; break;
			case std2_wire_units:
				m->SetFlag(STDMTL_WIRE_UNITS, v.i == 1); break;

			case std2_apply_refl_dimming:
				m->dimReflect = v.i; break;
			case std2_dim_lvl:
				m->dimIntens = v.f; break;
			case std2_refl_lvl:
				m->dimMult = v.f; break;
		}
	}
};

static ExtendedPBAccessor extendedPBAccessor;

// extra rollout dialog proc
class ExtraDlgProc : public ParamMap2UserDlgProc 
{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
		{
			switch (msg) 
			{
				case WM_INITDIALOG:{
					StdMtl2* m = (StdMtl2*)map->GetParamBlock()->GetOwner();
					m->UpdateExtraParams( m->GetShader()->SupportStdParams() );
					return TRUE;
				}
			}
			return FALSE;
		}
		void DeleteThis() { }
};

static ExtraDlgProc extraDlgProc;

// extended parameters
static ParamBlockDesc2 std2_extended_blk ( std2_extended, _T("extendedParameters"),  0, &stdmtl2CD, P_AUTO_CONSTRUCT + P_AUTO_UI, EXTENDED_PB_REF, 
	//rollout
	IDD_DMTL_EXTRA6, IDS_DS_EXTRA, 0, APPENDROLL_CLOSED, &extraDlgProc, 
	// params
	std2_opacity_type,  _T("opacityType"), 	TYPE_INT, 		0, 				IDS_JW_OPACITYTYPE,
		p_default, 		0, 
		p_range, 		0, 2, 
		p_ui, 			TYPE_RADIO, 	3, IDC_TR_SUB2, IDC_TR_SUB, IDC_TR_ADD, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_opacity,		_T("opacity"), 	TYPE_PCNT_FRAC, 	P_ANIMATABLE, 	IDS_DS_OPACITY, 
		p_default, 		0.0, 
		p_range, 		0.0, 100.0,   // UI us in the shader rollout
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_filter_color, 	 _T("filterColor"), TYPE_RGBA, 		P_ANIMATABLE, 	IDS_DS_FILTER, 	
		p_default, 		Color(0, 0, 0), 
		p_ui, 			TYPE_COLORSWATCH, IDC_FILTER_CS, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_ep_filter_map, _T("filterMap"), 	TYPE_TEXMAP, 	P_SUBTEX + P_NO_AUTO_LABELS, IDS_JW_FILTERMAP, 
		p_subtexno, 	ID_FI, 
		p_ui, 			TYPE_TEXMAPBUTTON, IDC_MAPON_FI, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_falloff_type,  _T("opacityFallOffType"), 	TYPE_INT, 	0, 			IDS_JW_FALLOFFTYPE, 	 
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2, IDC_TF_IN, IDC_TF_OUT, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_falloff_amnt, _T("opacityFallOff"), TYPE_PCNT_FRAC, 	P_ANIMATABLE, 	IDS_DS_FALLOFF, 
		p_default, 		0.0, 
		p_range, 		0.0, 100.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_TF_EDIT, IDC_TF_SPIN, 0.1, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_ior, 			_T("ior"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_IOR, 
		p_default, 		1.5, 
		p_range, 		0.0, 10.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_IOR_EDIT, IDC_IOR_SPIN, 0.01, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_wire_size, 		_T("wireSize"), TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_WIRESZ, 
		p_default, 		1.0, 
		p_range, 		0.0, 100.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_WIRE_EDIT, IDC_WIRE_SPIN, 1.0, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_wire_units, 	_T("wireUnits"), 	TYPE_INT, 		0, 				IDS_JW_WIREUNITS, 	 
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2, IDC_PIXELS, IDC_UNITS, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_apply_refl_dimming, _T("applyReflectionDimming"), 	TYPE_BOOL, 	0, 	IDS_JW_APPLYREFDIM, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_DIM_REFL, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_dim_lvl, 		_T("dimLevel"), 		TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_DIMLEV, 
		p_default, 		0.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_DIM_AMT, IDC_DIM_AMTSPIN, 0.01, 
		p_accessor,		&extendedPBAccessor,
		end, 
	std2_refl_lvl, 		_T("reflectionLevel"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_DIMMULT, 
		p_default, 		1.0, 
		p_range, 		0.1, 10.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_DIM_MULT, IDC_DIM_MULTSPIN, 0.01, 
		p_accessor,		&extendedPBAccessor,
		end, 
	end
	);

///////////////////////////////////////////////////////////////////////////////////
// Sampling Rollout
//
class SamplingPBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		StdMtl2* m = (StdMtl2*)owner;
		macroRecorder->Disable();
		switch (id)
		{
			case std2_ssampler: {
				ClassDesc* pCD = StdMtl2::GetSamplerCD(v.i);
				if (pCD && m->GetSamplerIndx() != NO_UPDATE )
				{
					m->SwitchSampler(pCD); 
//					m->samplerId = v.i;
				}
			} break;
			case std2_ssampler_by_name: {
				for (int i = 0; i < StdMtl2::NumSamplers(); i++)
				{
					ClassDesc* pCD = StdMtl2::GetSamplerCD(i);
					if (_tcsicmp(pCD->ClassName(), v.s) == 0)
					{
						m->pb_sampling->SetValue(std2_ssampler, 0, i);
						break;
					}
				}
			} break;
			case std2_ssampler_qual:
				m->GetPixelSampler()->SetQuality( v.f ); break;
			case std2_ssampler_enable:
				m->GetPixelSampler()->SetEnable( v.i ); 
				m->SetFlag(STDMTL_SSAMP_ON, v.i); break;		

			case std2_ssampler_adapt_threshold:
				m->GetPixelSampler()->SetAdaptiveThreshold( v.f ); break;
			case std2_ssampler_adapt_on:{
				m->GetPixelSampler()->SetAdaptiveOn( v.i );
				IParamMap2* map = m->pb_sampling ? m->pb_sampling->GetMap() : NULL;
				if ( map ) {
					map->Enable(std2_ssampler_adapt_threshold, v.i );
				}
			} break;
			case std2_ssampler_subsample_tex_on:
				m->GetPixelSampler()->SetTextureSuperSampleOn( v.i ); break;
			case std2_ssampler_advanced: {
				IParamMap2* map = m->pb_sampling ? m->pb_sampling->GetMap() : NULL;
				HWND hwnd = ( map ) ? map->GetHWnd() : NULL;
				m->GetPixelSampler()->ExecuteParamDialog( hwnd, m );
			} break;
			case std2_ssampler_param0:
				m->GetPixelSampler()->SetOptionalParam( 0, v.f ); break;
			case std2_ssampler_param1:
				m->GetPixelSampler()->SetOptionalParam( 1, v.f ); break;

		}
		macroRecorder->Enable();
	}
	void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval& valid)    // get into v
	{
		StdMtl2* m = (StdMtl2*)owner;
		switch (id)
		{
			case std2_ssampler_by_name: {
				ClassDesc* pCD = StdMtl2::GetSamplerCD(m->samplerId);
				if (pCD)
					v.s = (TCHAR*)pCD->ClassName();
			} break;
		}
	}
};


static SamplingPBAccessor samplingPBAccessor;

// sampling rollout dialog proc

class SamplingDlgProc : public ParamMap2UserDlgProc 
{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
		{
			switch (msg) 
			{
				case WM_INITDIALOG:
					//  load the sampler dropdown
					HWND hwndSamplerCombo = GetDlgItem(hWnd, IDC_PIX_SAMPLER);
					SendMessage(hwndSamplerCombo, CB_RESETCONTENT, 0L, 0L);
					for (int i = 0; i < StdMtl2::NumSamplers(); i++) {
						ClassDesc* pClassD = StdMtl2::GetSamplerCD(i);
						int n = SendMessage(hwndSamplerCombo, CB_ADDSTRING, 0L, (LPARAM)(pClassD->ClassName()) );
						SendMessage(hwndSamplerCombo, CB_SETITEMDATA, n, (LPARAM)pClassD );
					}
					StdMtl2* m = (StdMtl2*)map->GetParamBlock()->GetOwner();
//					Class_ID sampId = m->GetPixelSampler()->ClassID();

					// JohnW: Are these still necessary? removed setindx 3/23/99 ke
					macroRecorder->Disable();
//					m->SetSamplerIndx( m->FindSampler( sampId ) );
					m->UpdateSamplingParams();
					macroRecorder->Enable();
					return TRUE;
			}
			return FALSE;
		}
		void DeleteThis() { }
};

static SamplingDlgProc samplingDlgProc;

// supersampling parameters
static ParamBlockDesc2 std2_sampling_blk ( std2_sampling, _T("samplingParameters"), 0, &stdmtl2CD, P_AUTO_CONSTRUCT + P_AUTO_UI, SAMPLING_PB_REF, 
	  //rollout
	IDD_DMTL_SAMPLING3, IDS_KE_SAMPLING, 0, APPENDROLL_CLOSED, &samplingDlgProc, 
	// params
	std2_ssampler, _T("sampler"), TYPE_INT, 0,	IDS_JW_PIXELSAMPLER, 	
		p_default, 		0, 
		p_ui, 			TYPE_INTLISTBOX, IDC_PIX_SAMPLER, 0, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_qual, _T("samplerQuality"), TYPE_FLOAT, P_ANIMATABLE, IDS_JW_SAMPLERQUAL, 
		p_default, 		0.5, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SAMPLEQUALITY_EDIT, IDC_SAMPLEQUALITY_SPIN, 0.01, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_enable, _T("samplerEnable"), TYPE_BOOL, P_ANIMATABLE, IDS_JW_SAMPLERENABLE, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_SUPER_SAMP, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_adapt_threshold, _T("samplerAdaptThreshold"), TYPE_FLOAT, 0, IDS_KE_SAMPLERADAPTTHRESH, 
		p_default, 		0.1, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_THRESHOLD_EDIT, IDC_THRESHOLD_SPIN, 0.001, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_adapt_on, _T("samplerAdaptOn"), TYPE_BOOL, 0, IDS_KE_SAMPLERADAPTON, 	
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_ADAPT_ON, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_subsample_tex_on, _T("subSampleTextureOn"), TYPE_BOOL, 0, IDS_KE_SUBSAMPLE_TEX_ON, 	
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_SAMPLE_TEX, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_advanced, _T("samplerAdvancedOptions"), TYPE_BOOL, 0, IDS_KE_SAMPLERADVANCED, 	
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_ADVANCED_BUTTON, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_by_name, _T("samplerByName"), TYPE_STRING, 		0, 		IDS_JW_SAMPLERBYNAME, 	
		p_accessor,		&samplingPBAccessor,
		end,
	std2_ssampler_param0, _T("UserParam0"), TYPE_FLOAT, 0, IDS_KE_SAMPLER_PARAM0, 
		p_default, 		0.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PARAM0_EDIT, IDC_PARAM0_SPIN, 0.01, 
		p_accessor,		&samplingPBAccessor,
		end, 
	std2_ssampler_param1, _T("UserParam1"), TYPE_FLOAT, 0, IDS_KE_SAMPLER_PARAM1, 
		p_default, 		0.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PARAM1_EDIT, IDC_PARAM1_SPIN, 0.01, 
		p_accessor,		&samplingPBAccessor,
		end, 
	end
	);


//////////////////////////////////////////end, sampling
static HIMAGELIST hLockButtons = NULL;

// mjm - begin - 5.10.99
class ResourceDelete
{
public:
	ResourceDelete() {}
	~ResourceDelete() { if (hLockButtons) ImageList_Destroy(hLockButtons); }
};

static ResourceDelete theResourceDelete;
// mjm - end

static void SetupPadLockButton(HWND hWnd, int id, BOOL check) 
{
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd, id));
	iBut->SetImage(hLockButtons, 2, 2, 2, 2, 16, 15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
}

static void LoadStdMtl2Resources()
{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;
	hLockButtons = ImageList_Create(16, 15, TRUE, 2, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_BUTTONS));
	hMask   = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_MASKBUTTONS));
	ImageList_Add(hLockButtons, hBitmap, hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
}

class StdMapsDlgProc : public ParamMap2UserDlgProc 
{
	public:
		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
		{
			StdMtl2* m = (StdMtl2*)map->GetParamBlock()->GetOwner();
			switch (msg) 
			{
				case WM_INITDIALOG:
					// conditionally set map amount spinner ranges and padlock button images
					LoadStdMtl2Resources();
					int bumpChan = m->stdIDToChannel[ ID_BU ];
					int dispChan = m->stdIDToChannel[ ID_DP ];
					int slevChan = m->stdIDToChannel[ ID_SS ];

					for (int i = 0; i < STD2_NMAX_TEXMAPS; i++) 
					{
						if (i == bumpChan || i == dispChan || i == slevChan)
							map->SetRange(std2_map_amnts, -999, 999, i);
						else 
							map->SetRange(std2_map_amnts, 0, 100, i);
					}

					SetupPadLockButton(hWnd, IDC_LOCK_TEX01, TRUE);
					macroRecorder->Disable();
					m->UpdateLockADTex(TRUE);
					macroRecorder->Enable();
					return TRUE;
			}
			return FALSE;
		}

		void DeleteThis() { }
};

static StdMapsDlgProc stdMapsDlgProc;

static BOOL IsMultipleInstanced(StdMtl2 *m, Texmap *t) {
	int cnt=0;
	for (int i = 0; i < STD2_NMAX_TEXMAPS; i++) {
		if (m->maps->txmap[i].map == t)			
			cnt++;
		}
	return (cnt>1)?TRUE:FALSE;
	}

#define BUMP_DEF_AMT .30f

class MapsPBAccessor : public PBAccessor
{
public:
	// the texture maps are stored, as before, in the Texmaps structure, so the parameters in the 
	// pb_map block act as 'views' onto this structure.  Any setting of map info (say from the scripter)
	// is reflected here in the Texmaps structure, and any getting of map info is extracted here from
	// this structure.

	// I hope to be able to host the texmap stuff entirely in the paramblock when I get assignable subanim
	// numbers supported in PB2's (so that the map, map enable and map amount Tab<>s are number in interleaved row order)
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		StdMtl2* m = (StdMtl2*)owner;
		switch (id)
		{
			case std2_map_enables:
				m->maps->txmap[tabIndex].mapOn = v.i;
				m->UpdateMapButtons();
				m->UpdateExtendedMapButtons();
				break;

			case std2_maps:
			{
				Texmap* tex = (Texmap*)v.r;
				m->maps->ReplaceReference(2*tabIndex+1, tex);
				if (tex != NULL) {
					macroRecorder->Disable();
					m->EnableMap(tabIndex, TRUE);
					macroRecorder->Enable();
					if (m->maps->txmap[tabIndex].amtCtrl == NULL) {			
						m->maps->ReplaceReference(2*tabIndex, NewDefaultFloatController());
						m->maps->txmap[tabIndex].amtCtrl->SetValue(TimeValue(0), &m->maps->txmap[tabIndex].amount);
					}
				} else {
					if (m->maps->txmap[tabIndex].amtCtrl != NULL)			
						m->maps->DeleteReference(2*tabIndex);
					macroRecorder->Disable();
					m->SetTexmapAmt(tabIndex, ((tabIndex == m->stdIDToChannel[ID_BU]) ? BUMP_DEF_AMT : 1.0f), TimeValue(0));
					m->EnableMap(tabIndex, FALSE);
					macroRecorder->Enable();
				}
				if (tex && (tabIndex == m->stdIDToChannel[ID_RL]|| tabIndex == m->stdIDToChannel[ID_RR]) ){
					if (!IsMultipleInstanced(m,tex)) {  //DS 4/26/99: keep settings for instanced map
						UVGen* uvg0 = tex->GetTheUVGen();
						if (uvg0 && uvg0->IsStdUVGen()) {
							StdUVGen *uvg = (StdUVGen*)uvg0;
							uvg->InitSlotType(MAPSLOT_ENVIRON);
							uvg->SetCoordMapping(UVMAP_SPHERE_ENV);
						 }
					}
				}
				m->UpdateMapButtons();
				m->UpdateExtendedMapButtons();

				break;
			}

			case std2_map_amnts:
				if (m->maps->txmap[tabIndex].amtCtrl) 
					m->maps->txmap[tabIndex].amtCtrl->SetValue(t, &v.f);
				m->maps->txmap[tabIndex].amount = v.f;
				break;

			case std2_mp_ad_texlock:
				m->SetFlag(STDMTL_LOCK_ADTEX, v.i);
				m->UpdateLockADTex(TRUE);
//			 removed to avoid multiple viewport redraws on change shader
//				m->UpdateMtlDisplay();
				break;
		}
	}

	void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval& valid)    // set from v
	{
		StdMtl2* m = (StdMtl2*)owner;
		switch (id)
		{
			case std2_map_enables:
				v.i = m->maps->txmap[tabIndex].mapOn; break;
			case std2_maps:
				v.r = m->maps->txmap[tabIndex].map; break;
			case std2_map_amnts:
				if (m->maps->txmap[tabIndex].amtCtrl) 
					m->maps->txmap[tabIndex].amtCtrl->GetValue(t, &v.f, valid);
				else
					v.f = m->maps->txmap[tabIndex].amount;
				break;
		}
	}

	// this allows 'virtual' parameters to refelect key state if in spinners and the underlying
	// source parameter is animatable (map amount in this case)
	BOOL KeyFrameAtTime(ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)
	{
		if (id == std2_map_amnts)
			return ((StdMtl2*)owner)->AmtKeyAtTime(tabIndex, t);
		else
			return FALSE;
	}

};
static MapsPBAccessor mapsPBAccessor;


// std_maps parameters
static ParamBlockDesc2 std_maps_blk ( std_maps, _T("maps"),  0, &stdmtl2CD, P_AUTO_CONSTRUCT + P_AUTO_UI, MAPS_PB_REF, 
	//rollout
	IDD_DMTL_TEXMAP4, IDS_DS_TEXMAP, 0, APPENDROLL_CLOSED, &stdMapsDlgProc, 
	// params
	std2_map_enables,	_T("mapEnables"), 	TYPE_BOOL_TAB, STD2_NMAX_TEXMAPS, 		0, 				IDS_JW_MAPENABLES, 	
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_USEMAP_0, IDC_USEMAP_1, IDC_USEMAP_2, IDC_USEMAP_3, 
											IDC_USEMAP_4, IDC_USEMAP_5, IDC_USEMAP_6, IDC_USEMAP_7,
											IDC_USEMAP_8, IDC_USEMAP_9, IDC_USEMAP_10, IDC_USEMAP_11,
											IDC_USEMAP_12, IDC_USEMAP_13, IDC_USEMAP_14, IDC_USEMAP_15,
											IDC_USEMAP_16, IDC_USEMAP_17, IDC_USEMAP_18, IDC_USEMAP_19,
											IDC_USEMAP_20, IDC_USEMAP_21, IDC_USEMAP_22, IDC_USEMAP_23,
		p_accessor,		&mapsPBAccessor,
		end, 
	std2_maps, 			_T("maps"), 		TYPE_TEXMAP_TAB, STD2_NMAX_TEXMAPS,	P_NO_REF,		IDS_JW_MAPS, 
		p_ui, 			TYPE_TEXMAPBUTTON,  IDC_MAP_0, IDC_MAP_1, IDC_MAP_2, IDC_MAP_3, 
										    IDC_MAP_4, IDC_MAP_5, IDC_MAP_6, IDC_MAP_7, 
										    IDC_MAP_8, IDC_MAP_9, IDC_MAP_10, IDC_MAP_11, 
										    IDC_MAP_12, IDC_MAP_13, IDC_MAP_14, IDC_MAP_15, 
										    IDC_MAP_16, IDC_MAP_17, IDC_MAP_18, IDC_MAP_19, 
										    IDC_MAP_20, IDC_MAP_21, IDC_MAP_22, IDC_MAP_23, 
		p_accessor,		&mapsPBAccessor,
		end, 
	std2_map_amnts, 	_T("mapAmounts"), 	TYPE_PCNT_FRAC_TAB, STD2_NMAX_TEXMAPS, 0, 				IDS_JW_MAPAMOUNTS, 
		p_default, 		1.0,   // default is given in internal units   JBW 10.8.99
		p_range, 		0.0, 100.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_AMTEDIT_0, IDC_AMTSPIN_0, IDC_AMTEDIT_1, IDC_AMTSPIN_1, 
													IDC_AMTEDIT_2, IDC_AMTSPIN_2, IDC_AMTEDIT_3, IDC_AMTSPIN_3, 
													IDC_AMTEDIT_4, IDC_AMTSPIN_4, IDC_AMTEDIT_5, IDC_AMTSPIN_5, 
													IDC_AMTEDIT_6, IDC_AMTSPIN_6, IDC_AMTEDIT_7, IDC_AMTSPIN_7, 
													IDC_AMTEDIT_8, IDC_AMTSPIN_8, IDC_AMTEDIT_9, IDC_AMTSPIN_9, 
													IDC_AMTEDIT_10, IDC_AMTSPIN_10, IDC_AMTEDIT_11, IDC_AMTSPIN_11, 
													IDC_AMTEDIT_12, IDC_AMTSPIN_12, IDC_AMTEDIT_13, IDC_AMTSPIN_13, 
													IDC_AMTEDIT_14, IDC_AMTSPIN_14, IDC_AMTEDIT_15, IDC_AMTSPIN_15, 
													IDC_AMTEDIT_16, IDC_AMTSPIN_16, IDC_AMTEDIT_17, IDC_AMTSPIN_17, 
													IDC_AMTEDIT_18, IDC_AMTSPIN_18, IDC_AMTEDIT_19, IDC_AMTSPIN_19, 
													IDC_AMTEDIT_20, IDC_AMTSPIN_20, IDC_AMTEDIT_21, IDC_AMTSPIN_21, 
													IDC_AMTEDIT_22, IDC_AMTSPIN_22, IDC_AMTEDIT_23, IDC_AMTSPIN_23, 
													1.0, 
		p_accessor,		&mapsPBAccessor,
		end, 
	std2_mp_ad_texlock, _T("adTextureLock"), 	TYPE_BOOL, 			0,				IDS_JW_ADTEXLOCK, 	
		p_default, 		TRUE, 
		p_ui, 			TYPE_CHECKBUTTON, IDC_LOCK_TEX01, 
		p_accessor,		&mapsPBAccessor,
		end, 
	end
	);

#ifndef DESIGN_VER
// std2_dynamics parameters
static ParamBlockDesc2 std2_dynamics_blk ( std2_dynamics, _T("dynamicsParameters"),  0, &stdmtl2CD, P_AUTO_CONSTRUCT + P_AUTO_UI, DYNMAICS_PB_REF, 
	//rollout
	IDD_DMTL_DYNAM, IDS_DS_DYNAMICS, 0, APPENDROLL_CLOSED, NULL, 
	// params
	std2_bounce, 	_T("bounce"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_BOUNCE, 
		p_default, 		1.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_BOUNCE_EDIT, IDC_BOUNCE_SPIN, 0.01, 
		end, 
	std2_static_friction, 	_T("staticFriction"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_STATFRIC, 
		p_default, 		0.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_STATFRIC_EDIT, IDC_STATFRIC_SPIN, 0.01, 
		end, 
	std2_sliding_friction, 	_T("slidingFriction"), 	TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_DS_SLIDFRIC, 
		p_default, 		0.0, 
		p_range, 		0.0, 1.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SLIDFRIC_EDIT, IDC_SLIDFRIC_SPIN, 0.01, 
		end, 
	end
	);
#endif

// Old Parameter block indices, kept around for old-version loading
#define PB_AMBIENT_O		0
#define PB_DIFFUSE_O		1
#define PB_SPECULAR_O		2
#define PB_SHININESS_O 		3
#define PB_SHIN_STR_O		4
#define PB_SELFI_O			5
#define PB_OPAC_O			6
#define PB_OPFALL_O			7
#define PB_FILTER_O			8
#define PB_WIRESZ_O			9
#define PB_IOR_O 			10
#define PB_BOUNCE_O			11
#define PB_STATFRIC_O		12
#define PB_SLIDFRIC_O		13
#define PB_DIMLEV_O			14
#define PB_DIMMULT_O		15
#define PB_SOFTEN_O			16
#define PB_SELFILLUM_CLR_O	17

// Ver. 10 Parameter block indices
#define PB_OPAC			0
#define PB_OPFALL		1
#define PB_FILTER 		2
#define PB_WIRESZ 		3
#define PB_IOR	 		4
#define PB_BOUNCE 		5
#define PB_STATFRIC		6
#define PB_SLIDFRIC		7
#define PB_DIMLEV		8
#define PB_DIMMULT		9

#define CURRENT_STDMTL_VERSION 12
#define FINAL_PARAMBLOCK_v1_VERSION 10

#define NPARAMS 10
#define STDMTL2_PBVERSION   1
#define STDMTL_PBVERSION   9

// conversion descriptors for old ParamBlocks to ParamBlock2s
// here we have two version descriptors, one for parameters going into 
// new pb_extended pblock, the other for params going into the
// new pb_dynamics block.  The -1 ID's below indicate no copy,
// so we use to update calls to distribute old params from one block
// into two new blocks
 
static ParamBlockDescID extVer10[] = {
	{ TYPE_FLOAT, NULL, TRUE, std2_opacity },		// opacity
	{ TYPE_FLOAT, NULL, TRUE, std2_falloff_amnt },	// opfalloff
	{ TYPE_RGBA,  NULL, TRUE, std2_filter_color },	// filter
	{ TYPE_FLOAT, NULL, TRUE, std2_wire_size },		// wireSize
	{ TYPE_FLOAT, NULL, TRUE, std2_ior },			// index of refraction
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// bounce
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// static friction
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// sliding friction
	{ TYPE_FLOAT, NULL, TRUE, std2_dim_lvl },		// reflect dim level
	{ TYPE_FLOAT, NULL, TRUE, std2_refl_lvl },		// reflect dim multiplier 
};

static ParamBlockDescID dynVer10[] = {
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// opacity
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// opfalloff
	{ TYPE_RGBA,  NULL, TRUE, -1 },					// filter
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// wireSize
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// index of refraction
	{ TYPE_FLOAT, NULL, TRUE, std2_bounce },		// bounce
	{ TYPE_FLOAT, NULL, TRUE, std2_static_friction }, // static friction
	{ TYPE_FLOAT, NULL, TRUE, std2_sliding_friction }, // sliding friction
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// reflect dim level
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// reflect dim multiplier 
};

// v10 Param Block Descriptor
static ParamBlockDescID stdmtl2PB[ NPARAMS ] = {
	{ TYPE_FLOAT, NULL, TRUE, 7 },   // opacity
	{ TYPE_FLOAT, NULL, TRUE, 8 }, 	// opfalloff
	{ TYPE_RGBA,  NULL, TRUE, 9 },   // filter
	{ TYPE_FLOAT, NULL, TRUE, 10 },  // wireSize
	{ TYPE_FLOAT, NULL, TRUE, 11 },  // index of refraction
	{ TYPE_FLOAT, NULL, TRUE, 12 },  // bounce
	{ TYPE_FLOAT, NULL, TRUE, 13 },  // static friction
	{ TYPE_FLOAT, NULL, TRUE, 14 },  // sliding friction
	{ TYPE_FLOAT, NULL, TRUE, 15 },  // reflect dim level
	{ TYPE_FLOAT, NULL, TRUE, 16 },  // reflect dim multiplier 
	}; 

#define NPARAMS_O 17

//Old (2.5 and before) Param Block Descriptor
static ParamBlockDescID stdmtlPB[ NPARAMS_O ] = {
	{ TYPE_RGBA, NULL, TRUE, 1 },    // ambient
	{ TYPE_RGBA, NULL, TRUE, 2 },    // diffuse
	{ TYPE_RGBA, NULL, TRUE, 3 },    // specular
	{ TYPE_FLOAT, NULL, TRUE, 4 },   // shininess
	{ TYPE_FLOAT, NULL, TRUE, 5 },   // shini_strength
	{ TYPE_FLOAT, NULL, TRUE, 6 },   // self-illum
	{ TYPE_FLOAT, NULL, TRUE, 7 },   // opacity
	{ TYPE_FLOAT, NULL, TRUE, 8 }, 	// opfalloff
	{ TYPE_RGBA,  NULL, TRUE, 9 },   // filter
	{ TYPE_FLOAT, NULL, TRUE, 10 },  // wireSize
	{ TYPE_FLOAT, NULL, TRUE, 11 },  // index of refraction
	{ TYPE_FLOAT, NULL, TRUE, 12 },  // bounce
	{ TYPE_FLOAT, NULL, TRUE, 13 },  // static friction
	{ TYPE_FLOAT, NULL, TRUE, 14 },  // sliding friction
	{ TYPE_FLOAT, NULL, TRUE, 15 },  // reflect dim level
	{ TYPE_FLOAT, NULL, TRUE, 16 },  // reflect dim multiplier 
	{ TYPE_FLOAT, NULL, TRUE, 17 }   // soften
	}; 

// Descriptor for mapping old (2.5 and before) shader parameters into new stdShader PB2's
// Shader::ConvertParamBlock() uses this to extract old mtl shader params into new Shader
static ParamBlockDescID stdmtlPB2[ NPARAMS_O ] = {
	{ TYPE_RGBA, NULL, TRUE, shdr_ambient },			// ambient
	{ TYPE_RGBA, NULL, TRUE, shdr_diffuse },			// diffuse
	{ TYPE_RGBA, NULL, TRUE, shdr_specular },			// specular
	{ TYPE_FLOAT, NULL, TRUE, shdr_glossiness },		// shininess
	{ TYPE_FLOAT, NULL, TRUE, shdr_spec_lvl },			// shini_strength
	{ TYPE_FLOAT, NULL, TRUE, shdr_self_illum_amnt },   // self-illum
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// opacity
	{ TYPE_FLOAT, NULL, TRUE, -1 }, 					// opfalloff
	{ TYPE_RGBA,  NULL, TRUE, -1 },						// filter
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// wireSize
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// index of refraction
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// bounce
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// static friction
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// sliding friction
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// reflect dim level
	{ TYPE_FLOAT, NULL, TRUE, -1 },						// reflect dim multiplier 
	{ TYPE_FLOAT, NULL, TRUE, shdr_soften }				// soften
	}; 
#define NUMOLDVER 1
static ParamVersionDesc oldStdMtl2Versions[ NUMOLDVER ] = {
	ParamVersionDesc(stdmtl2PB, NPARAMS, 0), 
};

#define STDMTL_NUMOLDVER 9

static ParamVersionDesc oldStdMtlVersions[ STDMTL_NUMOLDVER+1 ] = {
	ParamVersionDesc(stdmtlPB, 8, 0), 
	ParamVersionDesc(stdmtlPB, 9, 1), 
	ParamVersionDesc(stdmtlPB, 9, 2), 
	ParamVersionDesc(stdmtlPB, 10, 3), 
	ParamVersionDesc(stdmtlPB, 11, 4), 
	ParamVersionDesc(stdmtlPB, 14, 5), 
	ParamVersionDesc(stdmtlPB, 15, 6), 
	ParamVersionDesc(stdmtlPB, 15, 7), 
	ParamVersionDesc(stdmtlPB, 16, 8), 
	ParamVersionDesc(stdmtlPB, 17, 9)
};

static ParamVersionDesc curVersion(stdmtl2PB, NPARAMS, STDMTL2_PBVERSION);
static ParamVersionDesc stdMtlVersion(stdmtlPB, NPARAMS_O, STDMTL_PBVERSION);

#define IDT_MYTIMER 1010
#define DRAGTHRESH 6
#define DITHER_WHEN_INACTIVE // avoids palette conflict probs




//-----------------------------------------------------------------------------
//  StdMtl2
//-----------------------------------------------------------------------------

void StdMtl2::Reset() 
{
	ReplaceReference( TEXMAPS_REF, new Texmaps((MtlBase*)this));	
	ivalid.SetEmpty();


	SetShaderIndx( FindShader( Class_ID(DEFAULT_SHADER_CLASS_ID,0) ));
	// back in 4.28, as it broke reset....fixed in shader.reset so only allocs pb if not there
	pShader->Reset(); // mjm - 4.22.99 - fix mem leak (pblock already created through SetShaderIndx() above.

	SetSamplerIndx( FindSampler( Class_ID(DEFAULT_SAMPLER_CLASS_ID,0) ) ); 

// HEY!! this should all be done automatically in ParamBlock init...
	macroRecorder->Disable();  // don't want to see this parameter reset in macrorecorder
		// ensure all map-related parameters are set up
		UpdateMapButtons();	// calls updatetexmaps
		UpdateExtendedMapButtons();

		pb_shader->SetValue(std2_wire, 0, FALSE );
		pb_shader->SetValue(std2_two_sided, 0, FALSE );
		pb_shader->SetValue(std2_faceted, 0, FALSE );
		pb_shader->SetValue(std2_face_map, 0, FALSE );

		SetDimIntens( 0.0f, 0 );
		SetDimMult( 3.0f, 0 );

		pb_extended->SetValue(std2_opacity_type, 0, 0 );
		pb_extended->SetValue(std2_falloff_type, 0, 0 );
		pb_extended->SetValue(std2_wire_units, 0, 0 );
		pb_extended->SetValue(std2_apply_refl_dimming, 0, FALSE );
		SetOpacity(1.0f, 0);
		SetFilter(Color(.5f, .5f, .5f), 0);
		SetIOR(1.5f, 0);

		// sampling
		SetSamplingQuality( 0.5f );
		SetSamplingOn( FALSE );
		pb_sampling->SetValue(std2_ssampler_subsample_tex_on, 0, TRUE );
		pb_sampling->SetValue(std2_ssampler_adapt_threshold, 0, .1f );
		pb_sampling->SetValue(std2_ssampler_adapt_on, 0, TRUE );

		SetOpacFalloff(0.0f, 0);
		SetWireSize(1.0f, 0);
		int bumpChan = stdIDToChannel[ ID_BU ];
		SetTexmapAmt(bumpChan, BUMP_DEF_AMT, 0);
		SetDynamicsProperty(0, 0, DYN_BOUNCE, 1.0f);
		SetDynamicsProperty(0, 0, DYN_STATIC_FRICTION, 0.0f);
		SetDynamicsProperty(0, 0, DYN_SLIDING_FRICTION, 0.0f);

	macroRecorder->Enable();
}

StdMtl2::StdMtl2(BOOL loading) 
{
	pixelSampler = NULL;
	samplerId = -1;

	filterOverrideOn = FALSE;
	filterSz = 1.0f;
	ioRefract = 1.5f;

	old_pblock = NULL;
	pb_shader = pb_extended = pb_sampling = pb_maps = pb_dynamics = NULL;	
	maps = NULL;
	filter = Color(0.0f, 0.0f, 0.0f);
	pShader = NULL;
	shaderId = -1;
	flags = STDMTL_FILT_TRANSP | STDMTL_ROLLUP1_OPEN;

	dimReflect = FALSE;
	dimIntens = 0.0f;
	dimMult = 2.0f;
	wireSize = opacity = 1.0f;
	opfall = 0.0f;
	for ( int i = 0; i < 12; ++i )
		stdIDToChannel[i] = -1;

	for ( i = 0; i < STD2_NMAX_TEXMAPS; ++i )
		channelTypes[i] = UNSUPPORTED_CHANNEL;

	ivalid.SetEmpty();

	if (!loading){
		// ask the ClassDesc to make the P_AUTO_CONSTRUCT paramblocks
		stdmtl2CD.MakeAutoParamBlocks(this); 
		Reset();
		}
	}

RefTargetHandle StdMtl2::Clone(RemapDir &remap) {
	//DebugPrint(" Cloning STDMTL %d \n", ++numStdMtls);
	macroRecorder->Disable();
	StdMtl2 *mnew = new StdMtl2(TRUE);
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(TEXMAPS_REF,		remap.CloneRef(maps));
	mnew->ReplaceReference(SHADER_REF,		remap.CloneRef(pShader));	
	mnew->ReplaceReference(SHADER_PB_REF,	remap.CloneRef(pb_shader));
	mnew->ReplaceReference(EXTENDED_PB_REF, remap.CloneRef(pb_extended));
	mnew->ReplaceReference(SAMPLING_PB_REF, remap.CloneRef(pb_sampling));
	mnew->ReplaceReference(MAPS_PB_REF,		remap.CloneRef(pb_maps));
#ifndef DESIGN_VER
	mnew->ReplaceReference(DYNMAICS_PB_REF, remap.CloneRef(pb_dynamics));
#endif
	mnew->ReplaceReference(SAMPLER_REF,		remap.CloneRef(pixelSampler));	

	mnew->ivalid.SetEmpty();	
	mnew->flags = flags;

	mnew->filterOverrideOn = filterOverrideOn;
	mnew->filterSz = filterSz;

	mnew->ioRefract = ioRefract;
	mnew->opacity = opacity;
	mnew->filter = filter;
	mnew->opfall = opfall;

	mnew->wireSize = wireSize;
	mnew->dimReflect = dimReflect;
	
	mnew->samplerId = samplerId;
	mnew->shaderId = shaderId;

	for ( int i = 0; i < 12; ++i )
		mnew->stdIDToChannel[i] = stdIDToChannel[i];

	for ( i = 0; i < STD2_NMAX_TEXMAPS; ++i )
		mnew->channelTypes[i] = channelTypes[i];
	macroRecorder->Enable();
	return (RefTargetHandle)mnew;
}

ParamDlg* StdMtl2::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
	Interval v;
	macroRecorder->Disable();
	Update(imp->GetTime(), v);
	// save the creation context for possible later shader switching requiring a new CreateParamDialog
	curHwmEdit = hwMtlEdit;
	curImp = imp;
	// create the rollouts, first the main shader dialog as master
	//  note, we can't use PB2 AUTO_UI here, since the shader's dialog is to be installed in the
	//        middle of the rollouts
	masterDlg = stdmtl2CD.CreateParamDlg(std2_shader, hwMtlEdit, imp, this);
	// then have the selected shader make its own
	pShaderDlg = pShader->CreateParamDialog(NULL, hwMtlEdit, imp, this, 
											((flags & STDMTL_ROLLUP1_OPEN) ? 0 : APPENDROLL_CLOSED));
	masterDlg->AddDlg(pShaderDlg);
	// now make the rest (they are added to the master automatically)
	extendedDlg = stdmtl2CD.CreateParamDlg(std2_extended, hwMtlEdit, imp, this);
	samplingDlg = stdmtl2CD.CreateParamDlg(std2_sampling, hwMtlEdit, imp, this);
	texmapDlg = stdmtl2CD.CreateParamDlg(std_maps, hwMtlEdit, imp, this);
	UpdateTexmaps();
	if( pb_dynamics )	// not in the VIZ version
		stdmtl2CD.CreateParamDlg(std2_dynamics, hwMtlEdit, imp, this);
	// restore any saved rollout state
	stdmtl2CD.RestoreRolloutState();
	UpdateMapButtons();
	UpdateExtendedMapButtons();

	macroRecorder->Enable();
	return masterDlg;	
}

BOOL StdMtl2::SetDlgThing(ParamDlg* dlg)
{
	// set the appropriate 'thing' sub-object for each secondary dialog
	if (dlg == pShaderDlg)
	{
		// handle material switching in the shader dialog, incoming material is 'this'
		assert (SuperClassID() == MATERIAL_CLASS_ID);
		assert (ClassID() == StdMtl2ClassID);
		StdMtl2* oldMtl = (StdMtl2*)pShaderDlg->GetThing();
		ULONG oldParams, newParams;
		Class_ID newClassId, oldClassId;

		if (oldMtl) {
			oldParams = oldMtl->GetShader()->SupportStdParams();
			oldClassId = oldMtl->GetShader()->ClassID();
		} else oldParams = 0;;

		newParams = pShader->SupportStdParams();
		newClassId = pShader->ClassID();

		if ( shaderId < 0 ) {
			DbgAssert(0);
			SetShaderIndx( FindShader( pShader->ClassID() ), FALSE );
		}

		// see if we need to change Shader basic params rollup
		if ( (oldClassId == newClassId) || 
			 ((newParams & STD_BASIC2_DLG) && (oldParams & STD_BASIC2_DLG)) ){
			assert( pShaderDlg );
			// update in case of partial stdParam support
			pShaderDlg->SetThings(this, pShader);
			pShader->SetParamDlg( pShaderDlg );				
			pShaderDlg->ReloadDialog(); 
			UpdateMapButtons();
		} else {
			// different shader in this Std2Mtl, toss out the old rollup
			HWND oldPanel = pShaderDlg->GetHWnd();
			masterDlg->DeleteDlg(pShaderDlg);
			pShaderDlg->DeleteThis();

			// make a new one
			pShaderDlg = pShader->CreateParamDialog(oldPanel, curHwmEdit, curImp, this, 
							(flags & STDMTL_ROLLUP1_OPEN ? 0 : APPENDROLL_CLOSED));
			pShader->SetParamDlg(pShaderDlg);				
			pShaderDlg->LoadDialog(TRUE); 
			masterDlg->AddDlg(pShaderDlg);

			UpdateMapButtons(); // calls update texmaps
		}
	}
	else if (dlg == texmapDlg)
	{
		texmapDlg->SetThing(this);	
		UpdateTexmaps();
		UpdateLockADTex(TRUE);
	}
	else if (dlg == extendedDlg)
	{
		extendedDlg->SetThing(this);	
		UpdateExtraParams( pShader->SupportStdParams() );
		UpdateExtendedMapButtons();				
		std2_extended_blk.SetSubTexNo(std2_ep_filter_map, stdIDToChannel[ID_FI]);
	}
	else if (dlg == samplingDlg)
	{
		samplingDlg->SetThing(this);	
		if ( samplerId < 0 ) {
			DbgAssert(0);
//			SetSamplerIndx( FindSampler( pixelSampler->ClassID() ) );
		}
		UpdateSamplingParams();
	}
	else
		return FALSE;
	return TRUE;
}

// compare function for sorting Shader Tab<>
static int classDescListCompare(const void *elem1, const void *elem2) 
{
	ClassDesc* s1 = *(ClassDesc**)elem1;
	ClassDesc* s2 = *(ClassDesc**)elem2;
	TSTR sn1 = s1->ClassName();  // need to snap name string, since both use GetString()
	TSTR sn2 = s2->ClassName();
	return _tcscmp(sn1.data(), sn2.data());
}

void StdMtl2::LoadShaderList()
{
	// loads static shader list with name-sorted Shader ClassDesc*'s
	shaderList.ZeroCount();
	SubClassList* scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SHADER_CLASS_ID);
	for (long i = 0, j = 0; i < scList->Count(ACC_ALL); ++i) {
		if ( (*scList)[ i ].IsPublic() ) {
			ClassDesc* pClassD = (*scList)[ i ].CD();
			shaderList.Append(1, &pClassD);
		}
	}
	shaderList.Sort(&classDescListCompare);
}

int StdMtl2::NumShaders()
{
	if (shaderList.Count() == 0)
		LoadShaderList();
	return shaderList.Count();
}

ClassDesc* StdMtl2::GetShaderCD(int i)
{
	if (shaderList.Count() == 0)
		LoadShaderList();
	return (i >= 0 && i < shaderList.Count()) ? shaderList[i] : NULL;
}

void StdMtl2::LoadSamplerList()
{
	// loads static sampler list with name-sorted Sampler ClassDesc*'s
	samplerList.ZeroCount();
	SubClassList* scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SAMPLER_CLASS_ID);
	for (long i = 0, j = 0; i < scList->Count(ACC_ALL); ++i) {
		if ( (*scList)[ i ].IsPublic() ) {
			ClassDesc* pClassD = (*scList)[ i ].CD();
			samplerList.Append(1, &pClassD);
		}
	}
	samplerList.Sort(&classDescListCompare);
}

int StdMtl2::NumSamplers()
{
	if (samplerList.Count() == 0)
		LoadSamplerList();
	return samplerList.Count();
}

ClassDesc* StdMtl2::GetSamplerCD(int i)
{
	if (samplerList.Count() == 0)
		LoadSamplerList();
	return (i >= 0 && i < samplerList.Count()) ? samplerList[i] : NULL;
}


//-------------------------------------------------------------------
// This handles Undo/Redo of SwitchShader

class SwitchShaderRestore: public RestoreObj, public ReferenceMaker {
	public:
		StdMtl2 *mtl;
		Shader *saveShader;
		SwitchShaderRestore() { saveShader = NULL; mtl = NULL; }
		SwitchShaderRestore( StdMtl2 * m, Shader *s) {
			mtl = m;
			saveShader = NULL;
			theHold.Suspend();
			ReplaceReference(0,s);
			theHold.Resume();
			}
		~SwitchShaderRestore() { DeleteAllRefsFromMe();	}
		void Switch() {
			Shader *sh = mtl->pShader;
			
			sh->SetAFlag(A_LOCK_TARGET); // keeps sh from getting auto-deleted
			mtl->SwitchShader(saveShader,TRUE);
			sh->ClearAFlag(A_LOCK_TARGET);
			
			ReplaceReference(0,sh);
			}
		void Restore(int isUndo) { Switch(); }
		void Redo() { Switch(); }
		TSTR Description() { return(TSTR(_T("SwitchShaderRestore"))); }

		// ReferenceMaker 
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) { 
			if (message==REFMSG_TARGET_DELETED) {
				if (hTarget==saveShader) 
					saveShader = NULL;
				}
		   	return REF_SUCCEED; 
		   	}
		void DeleteThis() { delete this; }

		// From ref
		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return saveShader; }
		void SetReference(int i, RefTargetHandle rtarg) { 	saveShader = (Shader *)rtarg;	}
		BOOL CanTransferReference(int i) {return FALSE;}
	};


//--------------------------------------------------------------------------


void StdMtl2::SwitchShader(Shader* newShader, BOOL loadDlg )
{
	// switch to a different shader
	SuspendAnimate();
	Class_ID oldShaderId = pShader? pShader->ClassID(): Class_ID(0,0);
	Class_ID newShaderId = newShader->ClassID();
	Class_ID constShaderId( CONSTClassID, 0 );
	if ( newShaderId != oldShaderId ) 
	{
		if ( pb_extended ) {
			int n = pb_extended->IDtoIndex( std2_opacity );
			pb_extended->RemoveController( n, 0);
		}

		theHold.Suspend(); //-----------------------------------------------------

		if (newShaderId == constShaderId ) { // constant
			SetFlag( STDMTL_FACETED, TRUE );
			pb_shader->SetValue(std2_faceted, 0, TRUE );
		} else if ( oldShaderId == constShaderId ) {
			SetFlag( STDMTL_FACETED, FALSE );
			pb_shader->SetValue(std2_faceted, 0, FALSE );
		}

		Shader * oldShader = GetShader();
		ULONG	 oldParams = oldShader ? oldShader->SupportStdParams() : 0;
		ShaderParamDlg* oldShaderDlg = oldShader ? oldShader->GetParamDlg() : loadDlg? pShaderDlg:NULL;

		ULONG	 newParams = newShader->SupportStdParams();

		// copy any params in common
		if (  oldShader && newShader ){
			ShuffleShaderParams( newShader, oldShader );
			ShuffleTexMaps( newShader, oldShader );
		}

		theHold.Resume(); //-----------------------------------------------------

		if (theHold.Holding())
			theHold.Put(new SwitchShaderRestore(this,oldShader));  // this will make a ref to oldShader
		
		theHold.Suspend(); //-----------------------------------------------------

		// moved from below, or it crashes on reset
		if( oldShader) oldShader->SetParamDlg(NULL);  // DS 3/9/99 ( undo may bring oldShader back, have to clear invalid pointer)
		if(	oldShaderDlg )	oldShaderDlg->SetThings( this, NULL );
		
		// NB: this deletes the oldShader ( unless it being ref'd by SwitchShaderRestore)
		SetShader( newShader );


		UpdateTexmaps();
		std2_extended_blk.SetSubTexNo(std2_ep_filter_map, stdIDToChannel[ID_FI]);
		
		// update UI if open
		if (oldShaderDlg != NULL )
		{
			// enable or disable extra params
			UpdateExtraParams( newParams );

			// now update or replace the basic rollup
			if ((newParams & STD_BASIC2_DLG) && (oldParams & STD_BASIC2_DLG)) {
				// update in case of partial stdParam support
				oldShaderDlg->SetThings( this, newShader );
				newShader->SetParamDlg( oldShaderDlg );
				oldShaderDlg->LoadDialog(TRUE); 
				pShaderDlg = oldShaderDlg;

			} else {

				HWND oldPanel = oldShaderDlg->GetHWnd();
				masterDlg->DeleteDlg(oldShaderDlg);
				oldShaderDlg->DeleteThis();	

				// including oldPanel replaces it...
				pShaderDlg = newShader->CreateParamDialog(oldPanel, 
								curHwmEdit, curImp, this, 
								((flags & STDMTL_ROLLUP1_OPEN) ? 0 : APPENDROLL_CLOSED));
				newShader->SetParamDlg(pShaderDlg);
				pShaderDlg->LoadDialog(TRUE);
				masterDlg->AddDlg(pShaderDlg);

			}
			newShader->SetParamDlg(pShaderDlg);
			SyncADTexLock( newShader->GetLockADTex() );
			UpdateMapButtons();
			UpdateExtendedMapButtons();

			UpdateMtlDisplay();

		}// end, oldShaderDlg not NULL

		theHold.Resume(); //--------------------------------------------------

	}
	ResumeAnimate();   
}

// this is exposed at stdmat2 level
BOOL StdMtl2::SwitchShader(Class_ID shaderId)
{
	ClassDesc* pCD;
	int n = FindShader( shaderId, &pCD );
	if ( pCD ){
		SwitchShader(pCD);
		return TRUE;
	} 
	return FALSE;
}


void StdMtl2::SwitchShader(ClassDesc* pNewCD)
{
	// create the new shader object
	Shader * newShader = (Shader*)(pNewCD->Create(0));
	newShader->Reset();	// creates pblock

	SwitchShader( newShader );
}


// these provide R 2.5 id access to the old shaders.
void StdMtl2::SetShading(int s)
{
	long cid;
	pb_shader->SetValue(std2_faceted,0,FALSE);
	switch( s ) {
		case 0: cid = PHONGClassID; 
				pb_shader->SetValue(std2_faceted,0,TRUE);
				break;
		case 1: cid = PHONGClassID; break;
		case 2: cid = METALClassID; break;
		case 3: cid = BLINNClassID; break;
	}
	long indx =  FindShader( Class_ID(cid, 0) );
		
	// this sets the new shader via pb2 accessor
	SetShaderIndx( indx );
}

// all faceted shaders approximated by constant, all new shaders by blinn.
int StdMtl2::GetShading() {
	if (IsFaceted()) return 0;
	Class_ID id = pShader->ClassID(); 
	if ( id == Class_ID(PHONGClassID,0) ) return 1;
	else if ( id == Class_ID(METALClassID,0) ) return 2;
	return 3;
}


//-------------------------------------------------------------------
// This handles Undo/Redo of SwitchSampler

class SwitchSamplerRestore: public RestoreObj, public ReferenceMaker {
	public:
		StdMtl2 *mtl;
		Sampler *saveSampler;
		SwitchSamplerRestore() { saveSampler = NULL; mtl = NULL; }
		SwitchSamplerRestore( StdMtl2 * m, Sampler *s) {
			mtl = m;
			saveSampler = NULL;
			theHold.Suspend();
			ReplaceReference(0,s);
			theHold.Resume();
			}
		~SwitchSamplerRestore() { DeleteAllRefsFromMe();	}
		void Switch() {
			Sampler *samp = mtl->pixelSampler;
			
			samp->SetAFlag(A_LOCK_TARGET); // keeps sh from getting auto-deleted
			mtl->SwitchSampler(saveSampler);
			samp->ClearAFlag(A_LOCK_TARGET);
			
			ReplaceReference(0,samp);
			}
		void Restore(int isUndo) { Switch(); }
		void Redo() { Switch(); }
		TSTR Description() { return(TSTR(_T("SwitchSamplerRestore"))); }

		// ReferenceMaker 
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) { 
			if (message==REFMSG_TARGET_DELETED) {
				if (hTarget==saveSampler) 
					saveSampler = NULL;
				}
		   	return REF_SUCCEED; 
		   	}
		void DeleteThis() { delete this; }

		// From ref
		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return saveSampler; }
		void SetReference(int i, RefTargetHandle rtarg) { 	saveSampler = (Sampler*)rtarg;	}
		BOOL CanTransferReference(int i) {return FALSE;}
	};


//--------------------------------------------------------------------------

// copy of classid of the default sampler
static Class_ID defaultSamplerID( DEFAULT_SAMPLER_CLASS_ID , 0);



void StdMtl2::SwitchSampler( Sampler* newSampler )
{
	theHold.Suspend(); //-----------------------------------------------------

	DbgAssert( newSampler );
	Class_ID oldSamplerId = pixelSampler? pixelSampler->ClassID(): Class_ID(0,0);
	Class_ID newSamplerId = newSampler->ClassID();

	if ( oldSamplerId != newSamplerId ) {

		theHold.Resume(); //-----------------------------------------------------
		if (theHold.Holding())
			theHold.Put(new SwitchSamplerRestore(this, pixelSampler));  // this will make a ref to oldShader
		theHold.Suspend(); //-----------------------------------------------------

		SetPixelSampler( newSampler );
	}

	if ( pb_sampling ) 
		UpdateSamplingParams();

	theHold.Resume(); //-----------------------------------------------------
}


void StdMtl2::SwitchSampler(ClassDesc* pNewCD)
{
//	if ( ! pNewCD ) {
		// get default
//		ClassDesc* pCD;
//		int indx = FindSampler( defaultSamplerID, &pCD );
//		pNewCD = pCD;
//		DbgAssert( pNewCD);
//	}
	DbgAssert( pNewCD);
	Sampler * newSampler = (Sampler*)(pNewCD->Create(0));
	SwitchSampler( newSampler );
}

// this is exposed at stdmat2 level
BOOL StdMtl2::SwitchSampler(Class_ID samplerId){
//	ClassDesc* pCD;
//	int n = FindSampler( samplerId, &pCD );
	int n = FindSampler( samplerId );
//	if ( pCD ){
	if ( n >= 0 ){
//		SwitchSampler( (Sampler*)(pCD->Create(0)) );
		SetSamplerIndx( n );
		return TRUE;
	} 
	return FALSE;
}



void StdMtl2::SetPixelSampler( Sampler * sampler )
{
	BOOL on = pixelSampler? pixelSampler->GetEnable() : FALSE;
	BOOL superTex = pixelSampler? pixelSampler->GetTextureSuperSampleOn() : TRUE;
	float quality = pixelSampler? pixelSampler->GetQuality() : 0.5f;
	ReplaceReference( SAMPLER_REF, sampler );	
 	NotifyDependents(FOREVER, 0, REFMSG_SUBANIM_STRUCTURE_CHANGED);
	if(pixelSampler) {
		pixelSampler->SetEnable( on );
		pixelSampler->SetTextureSuperSampleOn( superTex );
		pixelSampler->SetQuality( quality );
	}
}	

static TCHAR dots[] = _T("..........................");

void StdMtl2::UpdateTexmaps()
{
	// if the UI is up for the maps paramblock, adjust button text and enables 
	// according to current shader's capabilities
	// UI controls are updated indirectly via calls on the ParamMap2.
	// further, a Param Alias table is set up for all the pmap Tab<> params for scripter access
	IParamMap2* pmap = pb_maps->GetMap();
	Shader* pShader = GetShader();
	long nShaderMapChannels = pShader->nTexChannelsSupported();
	long nMtlMapChannels = MTL_NTEXMAPS;
	pb_maps->ClearParamAliases();
	int slevChan = pShader->StdIDToChannel( ID_SS );

	for ( long i = 0; i < STD2_NMAX_TEXMAPS; ++i )
	{
		if ( i < nShaderMapChannels ) 
		{
			BOOL isSupported = ! (pShader->ChannelType( i ) & UNSUPPORTED_CHANNEL);				
			if (pmap != NULL)
			{
				TSTR chanName = maps->txmap[i].name = pShader->GetTexChannelName(i);
				// append dots 
				int n = chanName.length();
				chanName.append( &dots[ n ] );
				pmap->SetText(std2_map_enables, chanName, i);
				pmap->Enable(std2_map_enables, isSupported, i);
				pmap->Enable(std2_map_amnts, isSupported, i);
				pmap->Enable(std2_maps, isSupported, i);

				if ( i == slevChan)
					pmap->SetRange(std2_map_amnts, -999, 999, i);
				else 
					pmap->SetRange(std2_map_amnts, 0, 100, i);

			}
			// set up the Tab<> param aliases 
			TSTR chanIntName = pShader->GetTexChannelInternalName(i);
			if (chanIntName.Length() > 0)
			{
				channelTypes[ i ] = pShader->ChannelType( i );
				pb_maps->DefineParamAlias(chanIntName, std2_maps, i);
				pb_maps->DefineParamAlias(chanIntName + _T("Enable"), std2_map_enables, i);  // JBW 5/24/99, made non-localizable (as names s/b internal)
				pb_maps->DefineParamAlias(chanIntName + _T("Amount"), std2_map_amnts, i);
			}
		} 
		else 
		{ // beyond the end of supported shader channels
			if (pmap != NULL)
			{
				// add the mtls texture channels
				if ( nMtlMapChannels > 0 ) {
					TSTR chanName = maps->txmap[i].name = GetString( mtlChannelNameIDS[ i - nShaderMapChannels ] );
					// append dots 
					int n = chanName.length();
					chanName.append( &dots[ n ] );
					pmap->SetText(std2_map_enables, chanName, i);
					pmap->Enable(std2_map_enables, TRUE, i);
					pmap->Enable(std2_map_amnts, TRUE, i);
					pmap->Enable(std2_maps, TRUE, i);
					// range, first channel is bumps, last is displacement 
					if ( nMtlMapChannels == MTL_NTEXMAPS || nMtlMapChannels == 1 )
						pmap->SetRange(std2_map_amnts, -999, 999, i);
					else 
						pmap->SetRange(std2_map_amnts, 0, 100, i);

					--nMtlMapChannels;

				} else {
					// channel is not used for this mtl/shader
					pmap->SetText(std2_map_enables, dots, i);
					macroRecorder->Disable();
						SetTexmapAmt(i, 0.0f, 0);
					macroRecorder->Enable();
					pmap->Enable(std2_map_enables, FALSE, i);
					pmap->Enable(std2_map_amnts, FALSE, i);
					pmap->Enable(std2_maps, FALSE, i);
				}
			}
			TSTR chanIntName = mtlChannelInternalNames[ i - nShaderMapChannels ] ;
			if (chanIntName.Length() > 0)
			{
				channelTypes[ i ] = mtlChannelType[ i - nShaderMapChannels ];
				pb_maps->DefineParamAlias(chanIntName, std2_maps, i);
				pb_maps->DefineParamAlias(chanIntName + GetString(IDS_JW_ENABLE), std2_map_enables, i);
				pb_maps->DefineParamAlias(chanIntName + GetString(IDS_JW_AMOUNT), std2_map_amnts, i);
			}

		}
	}
 
	// last do the Channel Ids from stdMat
	for ( i = 0; i < N_ID_CHANNELS; ++i ){
		int chan = pShader->StdIDToChannel(i);
		if ( chan >= 0 ) {
			stdIDToChannel[i] = chan;
		} else if (mtlStdIDToChannel[ i ] >= 0){
			stdIDToChannel[i] = mtlStdIDToChannel[ i ] + pShader->nTexChannelsSupported();
		} else
			stdIDToChannel[i] = -1;
	}

	// disable for old metal
	ULONG stdParms =  pShader->SupportStdParams();
	if ( (stdParms & STD_BASIC2_DLG) &&  (stdParms & STD_PARAM_METAL) ){
		//metal std shader, turn off stuff
		int n = stdIDToChannel[ ID_SP ];
		if ( pmap ) {
			pmap->Enable(std2_map_amnts, FALSE, n );
			pmap->Enable(std2_maps, FALSE, n);
			pmap->Enable(std2_map_enables, FALSE, n);
		}
	}
	// disable filter on additive/subtractive
	if ( (stdParms & STD_EXTRA_DLG) &&  TRANSP_FILTER != GetTransparencyType() ){
		//metal std shader, turn off stuff
		int n = stdIDToChannel[ ID_FI ];
		if ( pmap ) {
			pmap->Enable(std2_map_amnts, FALSE, n );
			pmap->Enable(std2_maps, FALSE, n);
			pmap->Enable(std2_map_enables, FALSE, n);
		}
	}

}

static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void StdMtl2::UpdateMapButtons() 
{
	UpdateTexmaps();
	if (IsShaderInUI()){
		pShader->GetParamDlg()->UpdateMapButtons();
		UpdateLockADTex(TRUE);
	}
//	UpdateExtendedMapButtons();
}

void StdMtl2::UpdateExtendedMapButtons()
{
	IParamMap2* pmap = pb_extended->GetMap();
	if (pmap != NULL){
		int filtChan = stdIDToChannel[ID_FI];
		int state = GetMapState( filtChan );
		pmap->SetText(std2_ep_filter_map, mapStates[ state ]);

		TSTR nm	 = GetMapName( filtChan );
		pmap->SetTooltip(std2_ep_filter_map, TRUE, nm);
	}
}

void StdMtl2::UpdateSamplingParams()
{
	IParamMap2* map = pb_sampling->GetMap();
	if ( map ) {
		HWND hwnd = map->GetHWnd();
		BOOL qualityOn = pixelSampler->SupportsQualityLevels()>0 ? TRUE:FALSE ;
		map->Show(std2_ssampler_qual, qualityOn );
		HWND hwQual = GetDlgItem( hwnd, IDC_QUALITY_TEXT );
		ShowWindow( hwQual, qualityOn );

		ULONG samplerParms = pixelSampler->SupportsStdParams();
		map->Show(std2_ssampler_adapt_on, samplerParms & ADAPTIVE_CHECK_BOX );
		map->Enable(std2_ssampler_adapt_threshold, pixelSampler->IsAdaptiveOn() );
		map->Show(std2_ssampler_adapt_threshold, samplerParms & ADAPTIVE_THRESHOLD );

		map->Show(std2_ssampler_subsample_tex_on, samplerParms & SUPER_SAMPLE_TEX_CHECK_BOX );
		HWND hwThresh = GetDlgItem( hwnd, IDC_ADAPT_STATIC );
		ShowWindow( hwThresh, samplerParms & ADAPTIVE_THRESHOLD?TRUE:FALSE );
		map->Show(std2_ssampler_advanced, samplerParms & ADVANCED_DLG_BUTTON );
		SetDlgItemText( hwnd, IDC_COMMENT_TEXT, pixelSampler->GetDefaultComment() );

		map->Show(std2_ssampler_param0, samplerParms & OPTIONAL_PARAM_0 );
		if( samplerParms & OPTIONAL_PARAM_0 )
			SetDlgItemText( hwnd, IDC_PARAM0_TEXT, pixelSampler->GetOptionalParamName(0) );
		ShowWindow( GetDlgItem( hwnd, IDC_PARAM0_TEXT ), samplerParms & OPTIONAL_PARAM_0 );

		map->Show(std2_ssampler_param1, samplerParms & OPTIONAL_PARAM_1 );
		if( samplerParms & OPTIONAL_PARAM_1 )
			SetDlgItemText( hwnd, IDC_PARAM1_TEXT, pixelSampler->GetOptionalParamName(1) );
		ShowWindow( GetDlgItem( hwnd, IDC_PARAM1_TEXT ), samplerParms & OPTIONAL_PARAM_1 );
	}
}

// enable & disable extra params possibly overridden by the shader
void StdMtl2::UpdateExtraParams( ULONG stdParams ) 
{
	// update shader dlg map buttons 
	IParamMap2* pmap = pb_extended->GetMap();
	if (pmap != NULL)
	{
		HWND hRollup = pmap->GetHWnd();
		BOOL opacOn = ( stdParams & STD_EXTRA_OPACITY ) ? TRUE : FALSE;
		pmap->Show( std2_opacity_type, opacOn );
		pmap->Show( std2_falloff_type, opacOn );
		pmap->Show( std2_falloff_amnt, opacOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_OPAC_TEXT1), opacOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_OPAC_TEXT2), opacOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_OPAC_TEXT3), opacOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_FILTER_OVERLAY), !opacOn );

		BOOL reflOn = ( stdParams & STD_EXTRA_REFLECTION) ? TRUE : FALSE;
		pmap->Show( std2_apply_refl_dimming, reflOn );
		pmap->Show( std2_dim_lvl, reflOn );
		pmap->Show( std2_refl_lvl, reflOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_REFL_TEXT1), reflOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_REFL_TEXT2), reflOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_REFL_BOX), reflOn );
//		EnableWindow( GetDlgItem(hRollup,  IDC_REFL_BOX), reflOn );

		BOOL refrOn = ( stdParams & STD_EXTRA_REFRACTION ) ? TRUE : FALSE;
		pmap->Show( std2_ior, refrOn );
		ShowWindow( GetDlgItem(hRollup,  IDC_REFR_TEXT1), refrOn );

//		BOOL filterOn = (refrOn || opacOn) && GetTransparencyType() == TRANSP_FILTER;
		BOOL filterOn = (refrOn && !opacOn) || (opacOn && GetTransparencyType() == TRANSP_FILTER);
		pmap->Show( std2_filter_color, filterOn );
		pmap->Show( std2_ep_filter_map, filterOn );
		EnableWindow( GetDlgItem(hRollup,  IDC_OPAC_BOX), (refrOn || opacOn) );
	}
}

int StdMtl2::GetMapState( int nMap ) 
{
	Texmap *t = (*maps)[nMap].map;
	if ( t == NULL ) return 0;
	return (*maps)[nMap].mapOn ? 2 :1; 
}


TSTR StdMtl2::GetMapName( int nMap ) 
{
	Texmap *t = (*maps)[nMap].map;
	if ( t == NULL )
		return TSTR( GetString( IDS_KE_NONE ) );
	return t->GetFullName(); 
}


void StdMtl2::SyncADTexLock( BOOL lockOn ) 
{
	pb_maps->SetValue(std2_mp_ad_texlock, 0, lockOn );
	UpdateLockADTex(FALSE);
//	SetFlag( STDMTL_LOCK_ADTEX, lockOn );
	// force an update
//	if (masterDlg)
//		masterDlg->ReloadDialog();
}

void StdMtl2::UpdateLockADTex( BOOL passOn ) 
{
	IParamMap2* pmap = pb_maps->GetMap();
	int lock = 	GetFlag(STDMTL_LOCK_ADTEX)!=0;
	if ( pShader->SupportStdParams() & STD_PARAM_LOCKADTEX ) {
		if ( passOn ){
			pShader->SetLockADTex( lock );
			if (pmap != NULL && pShader->GetParamDlg())
				pShader->GetParamDlg()->LoadDialog(TRUE);
		}
		if (pmap != NULL)
		{
			pmap->Show(std2_mp_ad_texlock, TRUE);
			pmap->Enable(std2_maps, !lock, 0);
		}
	} else {
		// no std params, so no amb/diff lock
		if (pmap != NULL)
		{
			pmap->Show(std2_mp_ad_texlock, FALSE);
			pmap->Enable(std2_maps, TRUE, 0);
		}
	}

}

void StdMtl2::UpdateMtlDisplay() 
{
	IParamMap2* map = pb_maps->GetMap();
	if (map != NULL) 
	{
//	 removed to avoid multiple viewport redraws on change shader
//		map->RedrawViews(GetCOREInterface()->GetTime());
		map->Invalidate();
	}
}

#define LIMIT0_1(x) if (x<0.0f) x = 0.0f; else if (x>1.0f) x = 1.0f;
#define LIMIT1(x) if (x > 1.0f) x = 1.0f;
#define LIMITMINMAX(x, min, max) if (x<min) x = min; else if (x>max) x = max;

static Color LimitColor(Color c) {
	LIMIT0_1(c.r);
	LIMIT0_1(c.g);
	LIMIT0_1(c.b);
	return c;
}

void StdMtl2::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pb_extended->GetValue(std2_filter_color, t, p, ivalid );
		filter = LimitColor(Color(p.x, p.y, p.z));
		pb_extended->GetValue(std2_ior, t, ioRefract, ivalid );
		pb_extended->GetValue(std2_opacity, t, opacity, ivalid );
		LIMIT0_1(opacity);

		if (IsShaderInUI())
			pShader->GetParamDlg()->UpdateOpacity(); 

		pb_extended->GetValue(std2_falloff_amnt, t, opfall, ivalid );
		LIMIT0_1(opfall);

		pb_extended->GetValue(std2_wire_size, t, wireSize, ivalid );
		pb_extended->GetValue(std2_dim_lvl, t, dimIntens, ivalid );
		LIMIT0_1(dimIntens);
		pb_extended->GetValue(std2_refl_lvl, t, dimMult, ivalid );

		SetFlag(STDMTL_WIRE, pb_shader->GetInt(std2_wire, t));
		SetFlag(STDMTL_2SIDE, pb_shader->GetInt(std2_two_sided, t));
		SetFlag(STDMTL_FACEMAP, pb_shader->GetInt(std2_face_map, t));
		SetFlag(STDMTL_FACETED, pb_shader->GetInt(std2_faceted, t));

		SetFlag(STDMTL_ADD_TRANSP, pb_extended->GetInt(std2_opacity_type, t) == 2);
		SetFlag(STDMTL_FILT_TRANSP, pb_extended->GetInt(std2_opacity_type, t) == 0);
		SetFlag(STDMTL_FALLOFF_OUT, pb_extended->GetInt(std2_falloff_type, t) == 1);
		SetFlag(STDMTL_WIRE_UNITS, pb_extended->GetInt(std2_wire_units, t) == 1);
		SetFlag(STDMTL_LOCK_ADTEX, pb_maps->GetInt(std2_mp_ad_texlock, t) == 1);
		dimReflect = pb_extended->GetInt(std2_apply_refl_dimming, t);
		
		if (pShader)
			pShader->Update( t, ivalid );
	
		for (int i = 0; i < STD2_NMAX_TEXMAPS; i++)
			if (MAPACTIVE(i)) 
				maps->txmap[i].Update(t, ivalid);

	}
	valid &= ivalid;
}

BOOL StdMtl2::AmtKeyAtTime(int i, TimeValue t) {
	if (maps->txmap[i].amtCtrl) 
		return 	maps->txmap[i].amtCtrl->IsKeyAtTime(t,0);
	else
		return FALSE;
}

typedef struct {
	float amount;
	Control *amtCtrl;  
	Texmap *map;       
	BOOL mapOn;
	TSTR name;
} saveChan;

void StdMtl2::ShuffleTexMaps( Shader* newShader, Shader* oldShader )
{
	saveChan oldMaps[STD2_NMAX_TEXMAPS];

	for( long i = 0; i < STD2_NMAX_TEXMAPS; ++i ){
		oldMaps[i].amtCtrl = maps->txmap[i].amtCtrl; maps->txmap[i].amtCtrl = NULL; 
		oldMaps[i].amount = maps->txmap[i].amount; maps->txmap[i].amount = 1.0f; 
		oldMaps[i].map = maps->txmap[i].map; maps->txmap[i].map = NULL; 
		oldMaps[i].mapOn = maps->txmap[i].mapOn; maps->txmap[i].mapOn = FALSE; 
		oldMaps[i].name = maps->txmap[i].name; maps->txmap[i].name = _T(""); 
	}
	int nOldShadeMaps = oldShader->nTexChannelsSupported();
	int nNewShadeMaps = newShader->nTexChannelsSupported();

	// for each new shader map
	for( int oldChan, newChan = 0; newChan < nNewShadeMaps; ++newChan ){

		TSTR newName = newShader->GetTexChannelInternalName(newChan);
		
		// look for match in each old map
		for ( oldChan = 0; oldChan < nOldShadeMaps; ++oldChan ) {
			if ( newName == oldShader->GetTexChannelInternalName(oldChan) )
				break;
		}

		if( oldChan < nOldShadeMaps ) {	// found it
			maps->txmap[newChan].amtCtrl = oldMaps[oldChan].amtCtrl; 
			maps->txmap[newChan].amount = oldMaps[oldChan].amount;
			maps->txmap[newChan].map = oldMaps[oldChan].map;
			maps->txmap[newChan].mapOn = oldMaps[oldChan].mapOn;
			maps->txmap[newChan].name = oldMaps[oldChan].name;
		}

	}// end, for each new map

	// now do the mtl maps
	for ( int n = 0; n < MTL_NTEXMAPS; ++n ){
		newChan = n + nNewShadeMaps;
		oldChan = n + nOldShadeMaps;
		maps->txmap[newChan].amtCtrl = oldMaps[oldChan].amtCtrl; 
		maps->txmap[newChan].amount = oldMaps[oldChan].amount;
		maps->txmap[newChan].map = oldMaps[oldChan].map;
		maps->txmap[newChan].mapOn = oldMaps[oldChan].mapOn;
		maps->txmap[newChan].name = oldMaps[oldChan].name;
	}
}

void StdMtl2::ShuffleShaderParams( Shader* newShader, Shader* oldShader )
{
	ClassDesc2 *oldCD2 = NULL, *newCD2 = NULL;

	ClassDesc * newCD;
	FindShader( newShader->ClassID(), &newCD );

	ClassDesc * oldCD;
	FindShader( oldShader->ClassID(), &oldCD );

	// check if we have a ParamBlock2-based shaders 
	if (oldCD != NULL && oldCD->InternalName() != NULL)
		oldCD2 = (ClassDesc2*)oldCD;
	if (newCD != NULL && newCD->InternalName() != NULL)
		newCD2 = (ClassDesc2*)newCD;
	
	// loop over destination shaders PB2-based parameters
	if (oldCD2 != NULL && newCD2 != NULL){
		// loop over each block in the new shader
		for (int i = 0; i < newCD2->NumParamBlockDescs(); i++){
			// get block descriptor and source paramblock
			ParamBlockDesc2* newPBdesc = newCD2->GetParamBlockDesc(i);
			IParamBlock2* newPB2 = newShader->GetParamBlockByID(newPBdesc->ID);
			// loop over each new param and copy from old if there's a match
			for (int j = 0; j < newPBdesc->count; j++){
				ParamDef& paramDef = newPBdesc->paramdefs[j];

				// Now search the old shaders blocks
				for (int i = 0; i < oldCD2->NumParamBlockDescs(); i++){
					ParamBlockDesc2* oldPBdesc = oldCD2->GetParamBlockDesc(i);
					int j = oldPBdesc->NameToIndex(paramDef.int_name);
					if (j >= 0){
						// found an internal name match, get the dest pblock and param def
						ParamDef& srcParamDef = oldPBdesc->paramdefs[j];
						// copy only if types match
						if (srcParamDef.type == paramDef.type){
							IParamBlock2* oldPB2 = oldShader->GetParamBlockByID(oldPBdesc->ID);
							newPB2->Assign(paramDef.ID, oldPB2, srcParamDef.ID);
							goto nextParam;	// found it, outta here...
						}
						
					}
				}
nextParam:		;
			}// end, dest param loop
		}// end, desk block loop
		Interval v;
		v.SetInfinite();
		newShader->Update(0, v);

	// end, pb2 copying
	} else {

		// StdParam based copy
		newShader->CopyStdParams( oldShader );
	}
}


ULONG StdMtl2::Requirements(int subMtlNum) {
	ULONG req;
	
	assert( pShader );
	req = pShader->GetRequirements(subMtlNum);

	int opacChan = stdIDToChannel[ ID_OP ];
	int bumpChan = stdIDToChannel[ ID_BU ];
	int dispChan = stdIDToChannel[ ID_DP ];

	if (opacity!=1.0f||MAPACTIVE(opacChan)||opfall>0.0f) 
		req |= MTLREQ_TRANSP;

	for (int i=0; i<STD2_NMAX_TEXMAPS; i++) {
		if (MAPACTIVE(i))	
			req |= (*maps)[i].map->Requirements(subMtlNum);
		}
	if (MAPACTIVE(bumpChan)) {
		ULONG bmpreq = (*maps)[bumpChan].map->Requirements(subMtlNum);
		if (bmpreq&MTLREQ_UV)
			req |= MTLREQ_BUMPUV;
		if (bmpreq&MTLREQ_UV2)
			req |= MTLREQ_BUMPUV2;
		}
	if (flags&STDMTL_WIRE) 	req|= MTLREQ_WIRE;
	if (flags&STDMTL_2SIDE) req|= MTLREQ_2SIDE;
//	if (pixelSampler && pixelSampler->GetEnable() )
	if ( flags&STDMTL_SSAMP_ON )
		req|= MTLREQ_SUPERSAMPLE;
	if (flags&STDMTL_WIRE_UNITS) req|= MTLREQ_WIRE_ABS;
	if (flags&STDMTL_FACEMAP) req |= MTLREQ_FACEMAP;
	if (flags&STDMTL_ADD_TRANSP) req |= MTLREQ_ADDITIVE_TRANSP;
	if (MAPACTIVE(dispChan)) req |= MTLREQ_DISPLACEMAP;
	return req;		
}

int StdMtl2::MapSlotType(int i) 
{ 
	if (i==stdIDToChannel[ID_DP]) return MAPSLOT_DISPLACEMENT;  // DS 4/12/99
	return (i==stdIDToChannel[ID_RL] || i==stdIDToChannel[ID_RR])?
				MAPSLOT_ENVIRON : MAPSLOT_TEXTURE; 
}

void StdMtl2::MappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {
	int bumpChan = stdIDToChannel[ ID_BU ];
	for (int i=0; i<STD2_NMAX_TEXMAPS; i++) {
		if (MAPACTIVE(i)) {	
			if (i==bumpChan) 
				(*maps)[i].map->MappingsRequired(subMtlNum,bumpreq,bumpreq);
			else 
				(*maps)[i].map->MappingsRequired(subMtlNum,mapreq,bumpreq);
			}
		}
	}

Interval StdMtl2::Validity(TimeValue t) {
	Interval v;
#ifdef DESIGN_VER
	t = 0;
#endif
	Update(t, v);
	return ivalid;
}

void StdMtl2::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void StdMtl2::SetFlag(ULONG f, ULONG val) {
	if (val) flags|=f; 
	else flags &= ~f;
}

void StdMtl2::SetTransparencyType(int type) {
	switch (type) {
		case TRANSP_SUBTRACTIVE:  
			SetFlag(STDMTL_ADD_TRANSP, 0); 
			SetFlag(STDMTL_FILT_TRANSP, 0);
			pb_extended->SetValue(std2_opacity_type, 0, 1);
			break;
		case TRANSP_ADDITIVE:  
			SetFlag(STDMTL_ADD_TRANSP, 1); 
			SetFlag(STDMTL_FILT_TRANSP, 0); 
			pb_extended->SetValue(std2_opacity_type, 0, 2);
			break;
		case TRANSP_FILTER:  
			SetFlag(STDMTL_ADD_TRANSP, 0); 
			SetFlag(STDMTL_FILT_TRANSP, 1); 
			pb_extended->SetValue(std2_opacity_type, 0, 0);
			break;
		}
}

void StdMtl2::DeleteThis() {
    delete this;
}


TSTR StdMtl2::SubAnimName(int i) { 
	switch(i){
	case TEXMAPS_SUB: return TSTR(GetString( IDS_DS_TEXMAPS ));
	case SHADER_SUB: return TSTR(GetString( IDS_KE_SHADER ));
	case EXTRA_PB_SUB:	return TSTR(GetString( IDS_DS_EXTRA ));
	case SAMPLING_PB_SUB:	return TSTR(GetString( IDS_KE_SAMPLING ));
	case DYNAMICS_PB_SUB:	return TSTR(GetString( IDS_DS_DYNAMICS ));
	}
	return TSTR("");
}		

Animatable* StdMtl2::SubAnim(int i) {
	switch(i) {
		case TEXMAPS_SUB: return maps;
		case SHADER_SUB: return pShader;
		case EXTRA_PB_SUB:	return pb_extended;
		case SAMPLING_PB_SUB:	return pb_sampling;
		case DYNAMICS_PB_SUB:	return pb_dynamics;
		default: DbgAssert(0); return NULL;
		}
}

int StdMtl2::SubNumToRefNum(int subNum) 
{ 
	switch (subNum)
	{
		case TEXMAPS_SUB: return TEXMAPS_REF;
		case SHADER_SUB: return SHADER_REF;
		case EXTRA_PB_SUB:	return EXTENDED_PB_REF;
		case SAMPLING_PB_SUB:	return SAMPLING_PB_REF;
		case DYNAMICS_PB_SUB:	return DYNMAICS_PB_REF;
		default: DbgAssert(0); return 0;
	}
}

IParamBlock2* 
StdMtl2::GetParamBlock(int i)
{
	switch (i)
	{
		case 0:	return pb_shader;
		case 1:	return pb_extended;
		case 2:	return pb_sampling;
		case 3:	return pb_maps;
		case 4:	return pb_dynamics;
	}
	return NULL;
}

IParamBlock2* 
StdMtl2::GetParamBlockByID(BlockID id) 
{ 
	// return id'd ParamBlock	
	switch (id)
	{
		case std2_shader:	return pb_shader;
		case std2_extended:	return pb_extended;
		case std2_sampling:	return pb_sampling;
		case std_maps:		return pb_maps;
		case std2_dynamics:	return pb_dynamics;
	}
	return NULL; 
}

RefTargetHandle StdMtl2::GetReference(int i) {
	switch(i) {
		case OLD_PBLOCK_REF:	return old_pblock;  // old pblock, replaced by the 6 new pb2's
		case TEXMAPS_REF:		return maps;
		case SHADER_REF:		return pShader;
		case SHADER_PB_REF:		return pb_shader;
		case EXTENDED_PB_REF:	return pb_extended;
		case SAMPLING_PB_REF:	return pb_sampling;
		case MAPS_PB_REF:		return pb_maps;
#ifndef DESIGN_VER
		case DYNMAICS_PB_REF:	return pb_dynamics;
#else
		case DYNMAICS_PB_REF:	return NULL;
#endif
		case SAMPLER_REF:		return pixelSampler;
		default: assert(0);		return NULL;
		}
}

void StdMtl2::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case OLD_PBLOCK_REF:	old_pblock = (IParamBlock*)rtarg; return;
		case TEXMAPS_REF:	{
			maps = (Texmaps*)rtarg; 
			if (maps != NULL)
				maps->client = this;
			return;
			}
		case SHADER_REF:	
			if (IsShaderInUI()){
				pShader->GetParamDlg()->SetThings(this, NULL);
				pShader->SetParamDlg(NULL);	
			}
			pShader = (Shader*)rtarg; 

							return;
		case SHADER_PB_REF: pb_shader = (IParamBlock2*)rtarg; return;
		case EXTENDED_PB_REF: pb_extended = (IParamBlock2*)rtarg; return;
		case SAMPLING_PB_REF: pb_sampling = (IParamBlock2*)rtarg; return;
		case MAPS_PB_REF:	pb_maps = (IParamBlock2*)rtarg; return;
		case DYNMAICS_PB_REF: pb_dynamics = (IParamBlock2*)rtarg; return;
		case SAMPLER_REF: pixelSampler = (Sampler*)rtarg; return;
		default: assert(0);
	}
}

void StdMtl2::SetSubTexmap(int i, Texmap *m)
{
	assert(i < STD2_NMAX_TEXMAPS);
	pb_maps->SetValue(std2_maps, TimeValue(0), m, i);
}

// invaldate for the viewport
RefResult StdMtl2::NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
								     PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_WANT_SHOWPARAMLEVEL:
			{
			BOOL *pb = (BOOL *)(partID);
			*pb = TRUE;
			return REF_STOP;
			}
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			// ask ClassDesc if any paramblock change caused the notify
			// if not and changing ref was one of the pblocks, inval all PB2 UI
			// else inval indicated param UI
			IParamBlock2* cpb;
			ParamID changing_param = stdmtl2CD.LastNotifyParamID(this, cpb);
			if (hTarget != pShader) // && hTarget != maps)
			{
				if (changing_param != -1)
				{
					cpb->GetDesc()->InvalidateUI(changing_param);
					if (changing_param == std2_opacity && 
                            cpb == pb_extended && pShader &&
                            pShader->GetParamDlg())
						pShader->GetParamDlg()->UpdateOpacity(); 
				}
				else
				{
					stdmtl2CD.InvalidateUI();
					if (hTarget == pb_extended && pShader &&
                            pShader->GetParamDlg())
						pShader->GetParamDlg()->UpdateOpacity();
				}
			}
			break;
		}

	return REF_SUCCEED;
}

Class_ID StdMtl2::ClassID() { return StdMtl2ClassID; }

TSTR StdMtl2::GetSubTexmapSlotName(int i) {
	if ( pShader ){
		long nShaderChan = pShader->nTexChannelsSupported();
		if ( i < nShaderChan )
			return pShader->GetTexChannelName( i );
		else
			return GetString( mtlChannelNameIDS[i - nShaderChan] );
	} else return TSTR("");
}


void StdMtl2::EnableMap(int i, BOOL onoff) { 
	pb_maps->SetValue(std2_map_enables, TimeValue(0), onoff, i);
}
			
void StdMtl2::SetFilter(Color c, TimeValue t) {
    filter = c;
	pb_extended->SetValue( std2_filter_color, t, Point3(c.r, c.g, c.b));
	int opacChan = stdIDToChannel[ ID_OP ];
	if (opacity!=1.0f||opfall!=0.0f||MAPACTIVE(opacChan)) 
		NotifyChanged();
}

void StdMtl2::SetIOR(float v, TimeValue t) {
	ioRefract = v;
	pb_extended->SetValue(std2_ior, t, v);
	}

void StdMtl2::SetOpacity(float v, TimeValue t) {
    opacity = v;
	pb_extended->SetValue(std2_opacity, t, v);
	}
			
void StdMtl2::SetOpacFalloff(float v, TimeValue t) {
	opfall = v;
	pb_extended->SetValue(std2_falloff_amnt, t, v);
	int opacChan = stdIDToChannel[ ID_OP ];
	if (opacity!=1.0f||opfall!=0.0f||MAPACTIVE(opacChan)) 
		NotifyChanged();
}		

void StdMtl2::SetWireSize(float v, TimeValue t) {
	wireSize = v;
	pb_extended->SetValue(std2_wire_size, t, v);
	if (flags&STDMTL_WIRE)
		NotifyChanged();
	}

void StdMtl2::SetDimIntens(float v, TimeValue t) {
	dimIntens = v;
	pb_extended->SetValue(std2_dim_lvl, t, v);
	}

void StdMtl2::SetDimMult(float v, TimeValue t) {
	dimMult = v;
	pb_extended->SetValue(std2_refl_lvl, t, v);
	}

void StdMtl2::SetTexmapAmt(int imap, float amt, TimeValue t) {
	pb_maps->SetValue(std2_map_amnts, t, amt, imap);
}

/////////////////////////////////////////////////////////////////////
// shaders
void StdMtl2::SetShaderIndx( long indx, BOOL update ) 
{
	if( !update ) shaderId = NO_UPDATE; 
	pb_shader->SetValue(std2_shader_type, 0, indx<0 ? 0 : indx );
	shaderId = indx; 
}

void StdMtl2::SetSamplerIndx( long indx, BOOL update )
{
	if( !update ) samplerId = NO_UPDATE;
	pb_sampling->SetValue(std2_ssampler, 0, indx<0 ? 0 : indx );
	samplerId = indx; 
}


static Class_ID ClassID0(0, 0);
static Class_ID ClassID1(1, 0);

void StdMtl2::SetShader( Shader* pNewShader )
{
//	if ( (pShader?pShader->ClassID():ClassID0) != (pNewShader?pNewShader->ClassID():ClassID1) ){
		ReplaceReference( SHADER_REF, pNewShader );	
		NotifyChanged();
		NotifyDependents(FOREVER, 0, REFMSG_SUBANIM_STRUCTURE_CHANGED);
//	}
}

// the shader Gets & Sets
BOOL StdMtl2::IsSelfIllumColorOn()
{	if (pShader->SupportStdParams() & STD_PARAM_SELFILLUM_CLR){
		return pShader->IsSelfIllumClrOn();
	}
	return FALSE;
}

void StdMtl2::SetSelfIllumColorOn( BOOL on )
{	if (pShader->SupportStdParams() & STD_PARAM_SELFILLUM_CLR){
		pShader->SetSelfIllumClrOn( on );
	}
}
	
void StdMtl2::SetAmbient(Color c, TimeValue t)		
{	if (pShader->SupportStdParams() & STD_PARAM_AMBIENT_CLR){
		pShader->SetAmbientClr( c, t );
	}
}

void StdMtl2::SetDiffuse(Color c, TimeValue t)		
{	if (pShader->SupportStdParams() & STD_PARAM_DIFFUSE_CLR){
		pShader->SetDiffuseClr( c, t );
	}
}

void StdMtl2::SetSpecular(Color c, TimeValue t)
{	if (pShader->SupportStdParams() & STD_PARAM_SPECULAR_CLR){
		pShader->SetSpecularClr( c, t );
	}
}

void StdMtl2::SetShininess(float v, TimeValue t)	
{	if (pShader->SupportStdParams() & STD_PARAM_GLOSSINESS ){
		pShader->SetGlossiness( v, t );
	}
}

void StdMtl2::SetShinStr(float v, TimeValue t)		
{	if (pShader->SupportStdParams() & STD_PARAM_SPECULAR_LEV ){
		pShader->SetSpecularLevel( v, t );
	}
}

void StdMtl2::SetSelfIllum(float v, TimeValue t)
{	if (pShader->SupportStdParams() & STD_PARAM_SELFILLUM ){
		pShader->SetSelfIllum( v, t );
	}
}


void StdMtl2::SetSelfIllumColor(Color c, TimeValue t)
{	if (pShader->SupportStdParams() & STD_PARAM_SELFILLUM_CLR){
		pShader->SetSelfIllumClr( c, t );
	}
}

static Color blackClr( 0.0, 0.0, 0.0 );
		
Color StdMtl2::GetAmbient(int mtlNum, BOOL backFace) 
{
	return pShader->GetAmbientClr( mtlNum, backFace );
}

Color StdMtl2::GetDiffuse(int mtlNum, BOOL backFace)
{	
	return pShader->GetDiffuseClr( mtlNum, backFace );
}

Color StdMtl2::GetSpecular(int mtlNum, BOOL backFace) 
{	
	return pShader->GetSpecularClr( mtlNum, backFace );
}

Color StdMtl2::GetSelfIllumColor(int mtlNum, BOOL backFace) 
{	
	return pShader->GetSelfIllumClr( mtlNum, backFace );
}

inline float Bound( float x, float min = 0.0f, float max = 1.0f ){ return x < min? min:( x > max? max : x); }

float StdMtl2::GetShininess(int mtlNum, BOOL backFace) 	
{	
	float g = pShader->GetGlossiness( mtlNum, backFace );
	return Bound( g, 0.01f, 1.0f );
}

float StdMtl2::GetShinStr(int mtlNum, BOOL backFace) 
{	
	return pShader->GetSpecularLevel( mtlNum, backFace );
}

float StdMtl2::GetSelfIllum(int mtlNum, BOOL backFace)		
{	
	return pShader->GetSelfIllum( mtlNum, backFace );
}

float StdMtl2::GetShininess(TimeValue t) 	
{	
	return pShader->GetGlossiness( t );
}

float StdMtl2::GetShinStr(TimeValue t) 
{	
	return pShader->GetSpecularLevel( t );
}

float StdMtl2::GetSelfIllum(TimeValue t)		
{	
	return pShader->GetSelfIllum(t);
}


BOOL StdMtl2::GetSelfIllumColorOn(int mtlNum, BOOL backFace)		
{	
	return pShader->IsSelfIllumClrOn();
}

Color StdMtl2::GetAmbient(TimeValue t) 	
{	
	return pShader->GetAmbientClr( t );
}
Color StdMtl2::GetDiffuse(TimeValue t) 	
{	
	return pShader->GetDiffuseClr(t);
}
Color StdMtl2::GetSpecular(TimeValue t) 
{
	return pShader->GetSpecularClr( t );
}
Color StdMtl2::GetSelfIllumColor(TimeValue t) 		
{
	return pShader->GetSelfIllumClr(t );
}

float StdMtl2::GetSoftenLevel( TimeValue t)  
{	
	return pShader->GetSoftenLevel(t);
}

Color StdMtl2::GetFilter() {	return filter;	}
float StdMtl2::GetTexmapAmt(int imap) {	return maps->txmap[imap].amount;	}
float StdMtl2::GetTexmapAmt(int imap, TimeValue t) {	return maps->txmap[imap].GetAmount(t); 	}

Color StdMtl2::GetFilter(TimeValue t)   { return pb_extended->GetColor(std2_filter_color, t);	}
float StdMtl2::GetOpacity( TimeValue t) { return  pb_extended->GetFloat(std2_opacity, t); }		
float StdMtl2::GetOpacFalloff(TimeValue t){ return  pb_extended->GetFloat(std2_falloff_amnt, t);}		
float StdMtl2::GetWireSize(TimeValue t) { return  pb_extended->GetFloat(std2_wire_size, t);}
float StdMtl2::GetIOR( TimeValue t)     { return  pb_extended->GetFloat(std2_ior, t);}
float StdMtl2::GetDimIntens( TimeValue t)   { return  pb_extended->GetFloat(std2_dim_lvl, t); }
float StdMtl2::GetDimMult( TimeValue t)   { return  pb_extended->GetFloat(std2_refl_lvl, t); }
BOOL StdMtl2::MapEnabled(int i)         { return maps->txmap[i].mapOn;}


float StdMtl2::GetDynamicsProperty(TimeValue t, int mtlNum, int propID) {
	float val;
	Interval ivalid;
	switch(propID) {
		case DYN_BOUNCE:
			pb_dynamics->GetValue(std2_bounce, t, val, ivalid);	
			return val;
		case DYN_STATIC_FRICTION:
			pb_dynamics->GetValue(std2_static_friction, t, val, ivalid);	
			return val;
		case DYN_SLIDING_FRICTION:
			pb_dynamics->GetValue(std2_sliding_friction, t, val, ivalid);	
			return val;
		default: 
			assert(0);
			return 0.0f;
		}
}

void StdMtl2::SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value){
#ifndef DESIGN_VER
	switch(propID) {
		case DYN_BOUNCE: 
			pb_dynamics->SetValue( std2_bounce, t, value);
			break;
		case DYN_STATIC_FRICTION:
			pb_dynamics->SetValue( std2_static_friction, t, value);
			break;
		case DYN_SLIDING_FRICTION:
			pb_dynamics->SetValue( std2_sliding_friction, t, value);
			break;
		default:
			assert(0);
			break;
		}
#endif
}

// returns the index of the shader in the list
int StdMtl2::FindShader( Class_ID& findId, ClassDesc** ppCD )
{
	for (int i = 0; i < StdMtl2::NumShaders(); i++) {
		ClassDesc* pCD = StdMtl2::GetShaderCD(i);
		if ( findId == pCD->ClassID() ){
			if (ppCD) *ppCD = pCD;
			return i;
		}
	}
	if (ppCD) *ppCD = NULL; // not found
	return -1;
}

int StdMtl2::FindSampler( Class_ID findId, ClassDesc** ppCD )
{
	for (int i = 0; i < StdMtl2::NumSamplers(); i++) {
		ClassDesc* pCD = StdMtl2::GetSamplerCD(i);
		if ( findId == pCD->ClassID() ){
			if (ppCD) *ppCD = pCD;
			return i;
		}
	}
	if (ppCD) *ppCD = NULL; // not found
	return -1;
}

/***
ClassDesc* StdMtl2::SamplerIndxToCD( int indx )
{
	IParamMap2* map = pb_sampling ? pb_sampling->GetMap() : NULL;
	if ( indx < 0 ) indx = 0;
	if ( map ) {
		HWND hwnd = map->GetHWnd();
		HWND hwndSampler = GetDlgItem(hwnd, IDC_PIX_SAMPLER);
		ClassDesc* pCD = (ClassDesc*)SendMessage( hwndSampler, CB_GETITEMDATA, indx, 0 );
		return pCD;
	}
	// last resort
	SubClassList * scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SAMPLER_CLASS_ID);
	return (*scList)[ 1 ].CD();
}
***/



/////////////////////////////////////////////////////////////////////////
//	Filing
//
#define MTL_HDR_CHUNK 0x4000
#define STDMTL_FLAGS_CHUNK 0x5000
#define STDMTL_SHADING_CHUNK 0x5004
#define STDMTL_TEX_ONOFF_CHUNK 0x5002
#define STDMTL_TEX_AMT0 0x5100
#define STDMTL_TEX_AMT1 0x5101
#define STDMTL_TEX_AMT2 0x5102
#define STDMTL_TEX_AMT3 0x5103
#define STDMTL_TEX_AMT4 0x5104
#define STDMTL_TEX_AMT5 0x5105
#define STDMTL_TEX_AMT6 0x5106
#define STDMTL_TEX_AMT7 0x5107
#define STDMTL_TEX_AMT8 0x5108
#define STDMTL_TEX_AMT9 0x5109
#define STDMTL_TEX_AMTA 0x510A

//#define STDMTL_BUMP1_CHUNK 0x5200
#define STDMTL_VERS_CHUNK 0x5300
#define STDMTL_DIM_REFLECT 0x5400

#define STDMTL_SELFILLUM_CLR_ON 0x5500
#define STDMTL_SAMPLING_ON		0x5510
#define STDMTL_SAMPLING_QUALITY	0x5511

// IO
IOResult StdMtl2::Save(ISave *isave) 
{ 
	ULONG nb;
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(STDMTL_VERS_CHUNK);
	int version = CURRENT_STDMTL_VERSION;
	isave->Write(&version, sizeof(version), &nb);			
	isave->EndChunk();



	return IO_OK;
}		


static INode* FindNodeRef(ReferenceTarget *rt) {
	DependentIterator di(rt);
	ReferenceMaker *rm;
	INode *nd = NULL;
	while (rm=di.Next()) {	
		if (rm->SuperClassID()==BASENODE_CLASS_ID) return (INode *)rm;
		nd = FindNodeRef((ReferenceTarget *)rm);
		if (nd) return nd;
		}
	return NULL;
	}



static float  GetNodeScaling(Mtl *m) {
	INode *n = FindNodeRef(m);
	if (n==NULL) 
		return 1.0f;
	Interval v;
	Matrix3 tm = n->GetNodeTM(0, &v);
	float f = (  fabs(Length(tm.GetRow(0))) +fabs(Length(tm.GetRow(1))) + fabs(Length(tm.GetRow(2))) )/3.0f;
	return f;
	}


//-----------------------------------------------------------------------
// DS - 4/7/97: Changed Opacity, Self-illumination, SHininess, Shininess strengh
// so that the map amount blends between the corresponding slider 
// setting and the map value.  This code fixes up old files so they
// will render the same way. This does not correctly handle animated values
// for the amount or parameter sliders.
//
// KE - 8/4/98 modified for converting old stdmtls to stdmtl2's
// JBW - 11/19/98 updated to convert old stdmtls and v.10 stdmtl2's to ParamBlock2-based StdMtl2's
//-----------------------------------------------------------------------

void StdMtl2::OldVerFix(int loadVer) 
{
	ULONG stdParams;

	macroRecorder->Disable();

	// ask the ClassDesc to make the P_AUTO_CONSTRUCT paramblock2s
	stdmtl2CD.MakeAutoParamBlocks(this); 

	if (loadVer < 10) {
		// create a shader, note: always a stdshader as it's an old version
		if ( shaderId < 0 || shaderId > 3 ) shaderId = 1;	// v1 files
		long cid;
		switch( shaderId ) {
			case 0: cid = PHONGClassID; 
					pb_shader->SetValue(std2_faceted,0,TRUE);
					break;
			case 1: cid = PHONGClassID; break;
			case 2: cid = METALClassID; break;
			case 3: cid = BLINNClassID; break;
		}
		long indx =  FindShader( Class_ID(cid, 0) );
		
		if ( indx < 0 ) return;

		// this sets the new shader via pb2 accessor
		SetShaderIndx( indx );

		pShader->SetSelfIllumClrOn( FALSE );
		stdParams = pShader->SupportStdParams();

		// convert param blocks
		IParamBlock* oldPB = old_pblock;
		IParamBlock* newParamBlk = UpdateParameterBlock(stdmtlPB, NPARAMS_O, oldPB, 
								                     stdmtl2PB, NPARAMS, STDMTL_PBVERSION);

		// if shader is PB2-based, give it the PB2 remapping descriptor
		if (pShader->NumParamBlocks() > 0)
			pShader->ConvertParamBlk(stdmtlPB2, NPARAMS_O, oldPB);
		else
			pShader->ConvertParamBlk(stdmtlPB, NPARAMS_O, oldPB);

		ReplaceReference( OLD_PBLOCK_REF, newParamBlk );	
		UpdateTexmaps();
		std2_extended_blk.SetSubTexNo(std2_ep_filter_map, stdIDToChannel[ID_FI]);

		SetSamplerIndx( FindSampler( Class_ID(DEFAULT_SAMPLER_CLASS_ID,0) ) ); 
		if (flags & STDMTL_SSAMP_ON) {
			pb_sampling->SetValue( std2_ssampler_enable,0, TRUE );
		}

		// gloss & strength are swapped from old versions
		TexmapSlot tmSlot = maps->txmap[ID_SH];
		maps->txmap[ID_SH] = maps->txmap[ID_SS];
		maps->txmap[ID_SS] = tmSlot;


	}

	// now set values that were previously stored outside the PB, prior to update
	pb_shader->SetValue(std2_wire, 0, GetFlag(STDMTL_WIRE)!=0);
	pb_shader->SetValue(std2_two_sided, 0, GetFlag(STDMTL_2SIDE)!=0);
	pb_shader->SetValue(std2_face_map, 0, GetFlag(STDMTL_FACEMAP)!=0);
	pb_shader->SetValue(std2_faceted, 0, GetFlag(STDMTL_FACETED)!=0);

	pb_extended->SetValue(std2_opacity_type, 0, (GetFlag(STDMTL_ADD_TRANSP) ? 2 : GetFlag(STDMTL_FILT_TRANSP) ? 0 : 1));
	pb_extended->SetValue(std2_falloff_type, 0, GetFlag(STDMTL_FALLOFF_OUT) ? 1 : 0);
	pb_extended->SetValue(std2_wire_units, 0, GetFlag(STDMTL_WIRE_UNITS) ? 1 : 0);
	pb_extended->SetValue(std2_apply_refl_dimming, 0, dimReflect);

	pShader->SetLockAD( GetFlag(STDMTL_LOCK_AD)?TRUE:FALSE );
	pShader->SetLockDS( GetFlag(STDMTL_LOCK_DS)?TRUE:FALSE );
	pShader->SetLockADTex( GetFlag(STDMTL_LOCK_ADTEX)!=0 );
	pb_maps->SetValue(std2_mp_ad_texlock, 0, GetFlag(STDMTL_LOCK_ADTEX)!=0 );

	if (loadVer < 8) {
		Interval v;
		Update(0, v);
		// In old versions, the ID's & the channel numbers correspond
		if (MAPACTIVE(ID_OP)) {
			if (maps->txmap[ID_OP].amount != 1.0f) 
				SetOpacity(0.0f, 0);
			}

		if ( stdParams & STD_PARAM_SELFILLUM )
			if (MAPACTIVE(ID_SI)) {
				if (maps->txmap[ID_SI].amount != 1.0f) 
					pShader->SetSelfIllum(0.0f, 0);
				}
			
		if ( stdParams & STD_PARAM_SPECULAR_LEV )
			if (MAPACTIVE(ID_SS)) {
				float amt = maps->txmap[ID_SS].amount;
				SetTexmapAmt(ID_SS, amt * pShader->GetSpecularLevel(0, 0), 0);
				pShader->SetSpecularLevel(0.0f, 0);
				}

		if ( stdParams & STD_PARAM_GLOSSINESS )
			if (MAPACTIVE(ID_SH)) {
				float amt = maps->txmap[ID_SH].amount;
				SetTexmapAmt(ID_SH, amt* pShader->GetGlossiness(0, 0), 0);
				pShader->SetGlossiness(0.0f, 0);
				}

	}
	if (loadVer < 9) {
		if ( stdParams & STD_PARAM_SOFTEN_LEV )
			if (flags&STDMTL_SOFTEN) 
				pShader->SetSoftenLevel(.6f, 0);
			else 
				pShader->SetSoftenLevel(0.0f, 0);
	}

	// at this point we have a v10 Stdmtl2, convert to PB2-based
	// distribute old pblock values to new pb2 blocks 
	UpdateParameterBlock2(extVer10, NPARAMS, old_pblock, &std2_extended_blk, pb_extended);
#ifndef DESIGN_VER
	UpdateParameterBlock2(dynVer10, NPARAMS, old_pblock, &std2_dynamics_blk, pb_dynamics);
#endif

	// mask off  rollup flags
	flags &= ~STDMTL_ROLLUP_FLAGS;
	flags |= STDMTL_ROLLUP1_OPEN;
//	pb_shader->SetRolloutOpen( flags & STDMTL_ROLLUP1_OPEN );

	macroRecorder->Enable();

	// delete old pblock
	ReplaceReference(OLD_PBLOCK_REF, NULL);

	}


// versin update post-load call back
class StdMtl2UpdateCB: public PostLoadCallback {
public:
	// create shader & new pblock
	StdMtl2 *m;
	int loadVersion;

	StdMtl2UpdateCB( StdMtl2 *s, int loadVers ){ m = s; loadVersion = loadVers; }
	void proc(ILoad *iload) {
		m->OldVerFix( loadVersion );
		delete this; 
	} 
};

void StdMtl2::BumpFix( ) {
	// Fix up bump map amount on old files if the node is scaled.	DS 4/16/99
	int bumpChannel = stdIDToChannel[ID_BU];
	if ((*maps)[ bumpChannel].IsActive()) {
		float s = GetNodeScaling(this);
		if (s!=1.0f) {
			float am = GetTexmapAmt(bumpChannel);
			SetTexmapAmt(bumpChannel, s*am, 0);
			}
		}
	}
 

// Bumpp map amount fix post-load call back
class StdMtl2BumpFixCB: public PostLoadCallback {
public:
	// create shader & new pblock
	StdMtl2 *m;

	StdMtl2BumpFixCB( StdMtl2 *s ){ m = s; }
	int Priority() { return 7; } // run at lower priority after normal PLCB's are all finished
	void proc(ILoad *iload) {
		m->BumpFix( );
		delete this; 
	} 
};

// post-load finalize callback
class StdMtl2CB: public PostLoadCallback {
public:
	StdMtl2 *m;

	StdMtl2CB(StdMtl2 *s){ m = s; }
	void proc(ILoad *iload) 
	{
		// ensure all map-related parameters are set up
		m->UpdateTexmaps();

		// make sure the right indx is selected for shaders & samplers
		m->SetShaderIndx( m->FindShader( m->pShader->ClassID() ), FALSE );
		if( m->pixelSampler == NULL ) // for some alpha files!
			m->SetSamplerIndx( m->FindSampler( Class_ID(DEFAULT_SAMPLER_CLASS_ID,0) ) ); 

		m->SetSamplerIndx( m->FindSampler( m->pixelSampler->ClassID() ), FALSE ); 
		m->SetFlag(STDMTL_SSAMP_ON, m->pixelSampler->GetEnable() );

		// DS - 2/11/99 This Update should not be here: it causes all
		// submaps to be loaded when loading, which makes loading matlibs very slow.
//		Interval i;
//		i.SetInfinite();
//		m->Update(0, i);

		delete this; 
	} 
};

IOResult StdMtl2::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;
	dimReflect = FALSE;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				ivalid.SetEmpty();
				break;
			case STDMTL_FLAGS_CHUNK:
				res = iload->Read(&flags, sizeof(flags), &nb);
				break;
			case STDMTL_SHADING_CHUNK:
				res = iload->Read(&shaderId, sizeof(shaderId), &nb);
				break;

			case STDMTL_VERS_CHUNK:
				res = iload->Read(&version, sizeof(version), &nb);
				break;
			case STDMTL_TEX_ONOFF_CHUNK:
				{
				ULONG f;
				res = iload->Read(&f, sizeof(f), &nb);
				for (int i=0; i<STD2_NMAX_TEXMAPS; i++) 
				    maps->txmap[i].mapOn = (f&(1<<i))?1:0;
				}
				break;
			case STDMTL_DIM_REFLECT:
				dimReflect = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	
	// register version updaters
	if (version <= FINAL_PARAMBLOCK_v1_VERSION) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldStdMtlVersions, STDMTL_NUMOLDVER, &stdMtlVersion, this, 0));
		iload->RegisterPostLoadCallback(new StdMtl2UpdateCB(this, version));
		if (version<12)
			iload->RegisterPostLoadCallback(new StdMtl2BumpFixCB(this));
		iload->SetObsolete();
	}

	// register plcb to finalize setup
	iload->RegisterPostLoadCallback(new StdMtl2CB(this));

	return IO_OK;
}

/******
static inline float Intens(RGBA& c) {	return (c.r+c.g+c.b)/3.0f;	}

static Color blackCol(0.0f, 0.0f, 0.0f);
static Color whiteCol(1.0f, 1.0f, 1.0f);


#define MAX3(a, b, c) ((a)>(b)?((a)>(c)?(a):(c)):((b)>(c)?(b):(c)))

static inline float MaxRGB(Color c) { 	return MAX3(c.r, c.g, c.b); }


Color StdMtl2::TranspColor(ShadeContext& sc, float opac, Color& diff) {
	// Compute the color of the transparent filter color
	if (flags&STDMTL_ADD_TRANSP) {
		float f = 1.0f - opac;
		return Color(f, f, f);   
		}
	else 
		{
		// Transparent Filter color mapping
		if (flags&STDMTL_FILT_TRANSP) {
			Color filt = filter;
			int filtChan = pShader->StdIDToChannel( ID_FI );
			if (MAPACTIVE(filtChan)) 
				AlphaCompCol(filt, (*maps)[filtChan].Eval(sc)); 

			if (opac>0.5f) {
				// darken as opac goes ( 0.5--> 1.0)
				// so that max component reaches 0.0f when opac reaches 1.0
				// find max component of filt
				float m = (filt.r>filt.g)?filt.r:filt.g;
				if(filt.b>m) m = filt.b;
				Color fc;
				float d = 2.0f*(opac-.5f)*m;
				fc = filt-d;
				if (fc.r<0.0f) fc.r = 0.0f;
				if (fc.g<0.0f) fc.g = 0.0f;
				if (fc.b<0.0f) fc.b = 0.0f;
				return fc;
			} else {
				// lighten as opac goes ( 0.5--> 0.0)
				// so that min component reaches 1.0f when opac reaches 1.0
				// find min component of filt
				float m = (filt.r<filt.g)?filt.r:filt.g;
				if(filt.b<m) m = filt.b;
				Color fc;
				float d = (1.0f-2.0f*opac)*(1.0f-m);
				fc = filt+d;
				if (fc.r>1.0f) fc.r = 1.0f;
				if (fc.g>1.0f) fc.g = 1.0f;
				if (fc.b>1.0f) fc.b = 1.0f;
				return fc;
			}

		} else {
			Color f = (1.0f-diff);  // original 3DS transparency 
			return  (1.0f-opac)*f;
		}
	}
}
*******/

inline float Abs( float a ) { return (a < 0.0f) ? -a : a; }
inline float Min( float a, float b ) { return (a < b) ? a : b; }
inline float Min( float a, float b, float c ) { return (a < b) ? Min(a,c) : Min(b,c); }
inline float Min( Color& c ){ return Min( c.r, c.g, c.b ); }
inline float Max( float a, float b ) { return (a < b) ? b : a; }
inline float Max( float a, float b, float c ) { return (a < b) ? Max( b, c ) : Max(a,c); }
inline float Max( Color& c ){ return Max( c.r, c.g, c.b ); }
inline float LBound( float x, float min = 0.0f ){ return x < min ? min : x; }
inline Color LBound( Color& c, float min = 0.0f )
	{ return Color( LBound(c.r, min), LBound(c.g, min), LBound(c.b, min) ); }
inline float UBound( float x, float max = 1.0f ){ return x > max ? max : x; }
inline Color UBound( Color& c, float max = 1.0f )
	{ return Color( UBound(c.r,max), UBound(c.g,max), UBound(c.b,max) ); }

#define TRANSP_SUB		0
#define TRANSP_ADD		1
#define TRANSP_FILTER	2


// Composite  c_over on top of c. Assume c_over has pre-multiplied alpha.
inline void AlphaCompCol(Color& c,  RGBA c_over) {
	float ia = 1.0f - Abs(c_over.a);
	ia = LBound( ia );
	c.r = c.r * ia + c_over.r;
	c.g = c.g * ia + c_over.g;
	c.b = c.b * ia + c_over.b;
} 

//////////////////////////////////////////////////////////////////////////////
//
//	transpColor utility, same as in shaders/shaderUtil
//
Color transpColor( ULONG type, float opac, Color filt, Color diff )
{
	// Compute the color of the transparent filter color
	if ( type == TRANSP_ADD ) { // flags & STDMTL_ADD_TRANSP) {
		float f = 1.0f - opac;
		return Color(f, f, f);   

	} else if ( type == TRANSP_FILTER ) { //flags & STDMTL_FILT_TRANSP ){
		// Transparent Filter color mapping
		if (opac>0.5f) {
			// darken as opac goes ( 0.5--> 1.0)
			// so that max component reaches 0.0f when opac reaches 1.0
			// find max component of filt
			float m = Max(filt);
			float d = 2.0f*(opac-.5f)*m;
			Color fc = filt-d;
			fc = LBound( fc );
			return fc;
		} else {
			// lighten as opac goes ( 0.5--> 0.0)
			// so that min component reaches 1.0f when opac reaches 1.0
			// find min component of filt
			float m = Min(filt);
			float d = (1.0f-2.0f*opac)*(1.0f-m);
			Color fc = filt+d;
			fc = UBound( fc );
			return fc;
		}

	} else {
		// original 3DS transparency 
		Color f = (1.0f-diff);  
		return  (1.0f-opac)*f;
	}

}


#define DOMAP(n) ((n>=0) && sc.doMaps&&(*maps)[ n ].IsActive())

#ifdef _DEBUG
static long xStop = -1;
static long yStop = -1;
#endif

void StdMtl2::Shade(ShadeContext& sc) 
{
	IllumParams ip;
	Color lightCol, rescol, diffIllum0;
	float opac;
	RGBA mval;
	Point3 N0, P;

#ifdef _DEBUG
	IPoint2 sPt = sc.ScreenCoord();
	if( sPt.x == xStop && sPt.y == yStop )
		long junk = -1;
#endif

	BOOL bumped = FALSE;
	if (gbufID) sc.SetGBufferID(gbufID);
	ip.mtlFlags = flags;

	pShader->GetIllumParams( sc, ip );
	ip.ClearOutputs();

	N0 = ip.N = sc.Normal();
 	opac =  opacity;

	int ambChan = stdIDToChannel[ ID_AM ];
	int diffChan = stdIDToChannel[ ID_DI ];
	int trChan = stdIDToChannel[ ID_OP ];
	int filtChan = stdIDToChannel[ ID_FI ];
	if ( filtChan >= 0 )ip.channels[filtChan] = filter;
	if ( trChan >= 0 ) ip.channels[trChan].r = opac;
	ULONG trType = (flags & STDMTL_FILT_TRANSP) ? TRANSP_FILTER :
						(flags & STDMTL_ADD_TRANSP) ? TRANSP_ADD : TRANSP_SUB;

	if (sc.mode==SCMODE_SHADOW) {
		// Opacity mapping;
		if (DOMAP(trChan)) 
			opac = (*maps)[trChan].LerpEvalMono(sc, opac);

		// "Shadow mode": This just computes the transparency, which is all 
		// you need for shadowing.
		if (opac!=1.0f || opfall!=0.0f) {

			if (opfall != 0.0f) {	
				ip.N = (flags & STDMTL_FACETED) ? sc.GNormal() : sc.Normal();
				ip.V = sc.V();  // get unit view vector
				float d = (float)fabs(DotProd(ip.N, ip.V));
				if (flags & STDMTL_FALLOFF_OUT) d = 1.0f-d;
				opac *= (1.0f-opfall*d);
			}

		 	// Transparency may use diffuse color mapping, check for orig 3ds transp
			if ((flags & (STDMTL_ADD_TRANSP|STDMTL_FILT_TRANSP))==0) {
				if (DOMAP(diffChan)) {
					mval = (*maps)[diffChan].Eval(sc);
				    AlphaCompCol(ip.channels[diffChan], mval); 
				}
			}
		 	// Transparency may also use filter color mapping
			if ( flags & STDMTL_FILT_TRANSP ){
				if (DOMAP(filtChan)) {
					mval = (*maps)[filtChan].Eval(sc);
				    AlphaCompCol(ip.channels[filtChan], mval); 
				}
			}
			// Compute the transpareny color
			sc.out.t = transpColor(trType, opac, ip.channels[filtChan], ip.channels[diffChan]);
		} else 
			sc.out.t.Black();
		return;
	} // end, shadow mode

	// any shader can be faceted...& bumpmapped as well
	if ( flags & STDMTL_FACETED ){
		ip.N = sc.GNormal();
		bumped = TRUE;
		sc.SetNormal(ip.N);
	}

	P = sc.P();		// position
	ip.V = sc.V();  // unit view vector

	ip.stdParams = pShader->SupportStdParams();

	// Do texture mapping
	ip.hasComponents = 0;
	ip.stdIDToChannel = stdIDToChannel;
	sc.SetIOR(ioRefract);

	// Bump mapping: Do this FIRST so other maps can use the perturbed normal
	int bumpChannel = stdIDToChannel[ID_BU];
	if (DOMAP(bumpChannel)) {
		ip.hasComponents |= HAS_BUMPS; 
		Point3 dn = (*maps)[bumpChannel].EvalNormalPerturb(sc);
		bumped = TRUE;
		ip.N = Normalize(ip.N + (sc.backFace?-dn:dn));
		// NB: shadeContext has perturbed normal
		sc.SetNormal(ip.N);
	}

	// All normal color & scalar maps are handled here
	long t0 = pShader->ChannelType(0);
	RGBA c;
	for ( long i = 0; i < STD2_NMAX_TEXMAPS; ++i ) {
		if ( sc.doMaps && (*maps)[ i ].IsActive()) {
			long t = pShader->ChannelType(i);
			// composite the channel
			if ( (t & SKIP_CHANNELS)==0 ){
				if ( t & MONO_CHANNEL ) {
					// note: x always holds channel data for mono channels
					ip.channels[ i ].r = (*maps)[i].LerpEvalMono(sc, ip.channels[ i ].r );
				} else {
					if ( i != ambChan || (flags & STDMTL_LOCK_ADTEX)==0 ) { 
						c = (*maps)[i].Eval(sc);
						AlphaCompCol( ip.channels[ i ], c); 
					}
				}
				// lock adtex, really channels 0 & 1
				if ( i == diffChan && ambChan >= 0 && (flags & STDMTL_LOCK_ADTEX) ) { 
					if ( t0 & MONO_CHANNEL ) {
						ip.channels[ ambChan ].r = (*maps)[diffChan].LerpEvalMono(sc, ip.channels[diffChan].r );
					} else {
						AlphaCompCol( ip.channels[ ambChan ], c ); 
					}
					
				}
			}
		}
	}

	// Evaluate reflection map.
	int reflChan = stdIDToChannel[ ID_RL ];
//	if (DOMAP(reflChan)) {
	if ( (*maps)[ reflChan ].map ) 
		ip.hasComponents |= HAS_REFLECT_MAP;

	if (DOMAP(reflChan)) {
		ip.hasComponents |= HAS_REFLECT;
		AColor rcol;
		Texmap *reflmap = (*maps)[reflChan].map;
		if (reflmap->HandleOwnViewPerturb()) {
			sc.TossCache(reflmap);
			rcol = reflmap->EvalColor(sc);
		} else 
			rcol = sc.EvalEnvironMap(reflmap, sc.ReflectVector());
		Color rc(rcol.r, rcol.g, rcol.b);
		ip.channels[reflChan] = rc;
		ip.kR = rcol.a * (*maps)[reflChan].amount;
	}

	// do refraction map 
	int refrChan = stdIDToChannel[ ID_RR ];
	if ( (*maps)[ reflChan ].map ) 
		ip.hasComponents |= HAS_REFRACT_MAP;

	if (DOMAP(refrChan)) {
		// Evaluate refraction map, as yet unfiltered by filter color.
		Texmap *refrmap = (*maps)[refrChan].map;
		AColor rcol;
		if (refrmap->HandleOwnViewPerturb()) 
			rcol = refrmap->EvalColor( sc );
		else  
			rcol = sc.EvalEnvironMap( refrmap, sc.RefractVector(ioRefract) );

		Color rc(  rcol.r,  rcol.g,  rcol.b );
		ip.channels[refrChan] = rc;
		ip.hasComponents |= HAS_REFRACT;
	}

	// get falloff opacity for possible use by shader or compositor
	opac = ip.channels[trChan].r; // get (perhaps) textured opacity

	if ( opac != 1.0f || opfall != 0.0f) {
		// yes
		ip.hasComponents |= HAS_OPACITY;
		if (opfall != 0.0f) {	
			float d = (float)fabs( DotProd(ip.N, ip.V) );
			if (flags&STDMTL_FALLOFF_OUT) d = 1.0f-d;
			ip.falloffOpac = opac * (1.0f - opfall * d);
		} else ip.falloffOpac = opac;
	} else ip.falloffOpac = 1.0f;

	// init the global ambient
	ip.ambIllumOut = sc.ambientLight;

	// mapping done, illuminate...
	pShader->Illum(sc, ip);

	// composite in the refraction map, if supporting std refract
	if ( (ip.hasComponents & HAS_REFRACT) && (ip.stdParams & STD_EXTRA_REFRACTION) ){
		// Set up opacity for Refraction map.
		ip.finalOpac = ip.falloffOpac * (1.0f - (*maps)[refrChan].amount);   

		// Make more opaque where specular hilite occurs:
		float max = Max(ip.specIllumOut);
		if (max > 1.0f) max = 1.0f; 
	   	float newOpac = ip.finalOpac + max - ip.finalOpac * max;

		// Evaluate refraction map, filtered by filter color.
		ip.transIllumOut = ip.channels[refrChan] 
			* transpColor(trType, newOpac, ip.channels[filtChan], ip.channels[diffChan]);

		// no transparency when doing refraction
		ip.finalT.Black();

	} else {
		// no refraction, transparent?
		if (ip.stdParams & STD_EXTRA_OPACITY ) {
			// std opacity & compositing
			if ( (ip.hasComponents & HAS_OPACITY) ) {
				ip.finalOpac = ip.falloffOpac;

				// Make more opaque where specular hilite occurs, so you
				// can still see the hilite:
				float max = Max(ip.specIllumOut);
				if (max > 1.0f) max = 1.0f; 
		   		float newOpac = ip.finalOpac + max - ip.finalOpac*max;

				// Compute the color of the transparent filter color
				ip.finalT = transpColor(trType, newOpac, ip.channels[filtChan], ip.channels[diffChan]);

			} else {
				// opaque, no Refraction map
				ip.finalT.Black();
				ip.finalOpac = 1.0f;
			}
		}
	}

	// add reflection in, if the shader didn't do it
	if( (ip.hasComponents & HAS_REFLECT) && (ip.stdParams & STD_EXTRA_REFLECTION) ){
		Color rc = ip.channels[reflChan];
		pShader->AffectReflection(sc, ip, rc);
		float r = ip.kR;
		if (dimReflect) {
//			float dimfact = ((1.0f-dimIntens)*Intens(ip.diffIllumOut)*dimMult + dimIntens);
			float dimfact = ((1.0f-dimIntens)*ip.diffIllumIntens*dimMult + dimIntens);
			r *= dimfact;
		}
		// add in the reflection
		ip.reflIllumOut = rc * r;

	} // end, std reflection

	// the shader provides combining, all components are available
	pShader->CombineComponents( sc, ip ); 
	sc.out.c = ip.finalC;
	sc.out.t = ip.finalT;

	if (bumped) sc.SetNormal(N0); // restore normal
}


float StdMtl2::EvalDisplacement(ShadeContext& sc) {
//	UpdateTexmaps();
	int dispChan = stdIDToChannel[ ID_DP ];
	if (DOMAP(dispChan))
		return (*maps)[dispChan].EvalMono(sc);
	else return 0.0f; 
}


Interval StdMtl2::DisplacementValidity(TimeValue t) {
	int dispChan = stdIDToChannel[ ID_DP ];
	if (MAPACTIVE(dispChan)) { 
		Interval iv;
		iv.SetInfinite();
		maps->txmap[dispChan].Update(t, iv);
		return iv;
		}
	else 
		return FOREVER;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\stdShaders.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//		Shader plug-ins, implementation
//
//		Created: 8/18/98 Kells Elmquist
//
#include "mtlhdr.h"
#include "mtlres.h"
#include "gport.h"
#include "shaders.h"
#include "macrorec.h"

// paramblock2 block and parameter IDs for the standard shaders
// NB these are duplicated in mtls/stdmtl2.h ...
enum { shdr_params, };
// shdr_params param IDs
enum 
{ 
	shdr_ambient, shdr_diffuse, shdr_specular,
	shdr_ad_texlock, shdr_ad_lock, shdr_ds_lock, 
	shdr_use_self_illum_color, shdr_self_illum_amnt, shdr_self_illum_color, 
	shdr_spec_lvl, shdr_glossiness, shdr_soften,
};


// including self-illum color but not filter
 #define NCOLBOX 4
static int colID[NCOLBOX] = { IDC_STD_COLOR1, IDC_STD_COLOR2, IDC_STD_COLOR3, IDC_SI_COLOR };
static int colParamID[NCOLBOX] = { shdr_ambient, shdr_diffuse, shdr_specular, shdr_self_illum_color };
#define N_SI_CLR		3
#define N_AMB_CLR		0

#define PB_AMBIENT_CLR		0
#define PB_DIFFUSE_CLR		1
#define PB_SPECULAR_CLR		2
#define PB_SELFILLUM_CLR	3
#define PB_SELFILLUM		4
#define PB_GLOSSINESS 		5
#define PB_SPEC_LEV			6
#define PB_SOFTEN_LEV		7

static int PB_ID[NCOLBOX] = 
	{ PB_AMBIENT_CLR, PB_DIFFUSE_CLR, PB_SPECULAR_CLR, PB_SELFILLUM_CLR };


static Class_ID StdShaderClassID(STDSHADERS_CLASS_ID,0);
static Class_ID ConstantClassID(STDSHADERS_CLASS_ID+1,0);
static Class_ID PhongClassID(PHONGClassID,0);
static Class_ID BlinnClassID(BLINNClassID,0);
static Class_ID MetalClassID(METALClassID,0);
static Class_ID OldBlinnClassID(DMTL_CLASS_ID+34+3,0);

static Class_ID StdShaderParamDlgClassID(STDSHADERS_CLASS_ID,0);

extern HINSTANCE hInstance;

static LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );


//////////////////////////////////////////////////////////
static HIMAGELIST hLockButtons = NULL;

// mjm - begin - 5.28.99
class StdShaderResourceDelete
{
public:
	StdShaderResourceDelete() {}
	~StdShaderResourceDelete() { if (hLockButtons) ImageList_Destroy(hLockButtons); }
};

static StdShaderResourceDelete theResourceDelete;
// mjm - end

static BOOL IsButtonChecked(HWND hWnd,int id)
	{
	ICustButton *iBut;
	BOOL res;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	res = iBut->IsChecked();
	ReleaseICustButton(iBut);
	return res;
	}

static void CheckButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetCheck(check);
	ReleaseICustButton(iBut);
	}

static void SetupLockButton(HWND hWnd,int id, BOOL check)
	{
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,0,1,0,1,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}

static void SetupPadLockButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,2,2,2,2,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}
 
static void LoadStdShaderResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;

	hLockButtons = ImageList_Create(16, 15, TRUE, 2, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_BUTTONS));
	hMask   = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_MASKBUTTONS));
	ImageList_Add(hLockButtons,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	}

static TSTR rollupName( Shader* pShader )
{
	Class_ID id = pShader->ClassID();
	if ( id == BlinnClassID )
		return GetString( IDS_KE_BASIC_BLINN );
	else if ( id == PhongClassID )
 		return GetString( IDS_KE_BASIC_PHONG );
	else if ( id == MetalClassID )
 		return GetString( IDS_KE_BASIC_METAL );
	else return _T("");
}


inline float PcToFrac(int pc) { return (float)pc/100.0f; }

inline int FracToPc(float f) {
	if (f<0.0) return (int)(100.0f*f - .5f);
	else return (int) (100.0f*f + .5f);
}

// Quadratic
inline float Soften(float r) {
	return r*(2.0f-r);
}

// all the old shaders add the highlights on
void CombineComponentsAdd( IllumParams& ip )
{
	ip.finalC = ip.finalOpac * (ip.ambIllumOut + ip.diffIllumOut  + ip.selfIllumOut)
			+ ip.specIllumOut + ip.reflIllumOut + ip.transIllumOut; 
}

 
inline float Abs( float a ) { return (a < 0.0f) ? -a : a; }
inline float LBound( float x, float min = 0.0f ){ return x < min ? min : x; }
inline float UBound( float x, float max = 1.0f ){ return x > max ? max : x; }

///////////////////////////////////////////////////////////////////////////////
//
//	Generic standard shader. supports phong blinn, metal & constant
//
class StdShaderDlg;


class StdShaderImp : public Shader {
friend class StdShaderCB;
friend class StdShaderDlg;
protected:
	IParamBlock2* pblock;   // ref 0
	Interval ivalid;
	TimeValue	curTime;

	StdShaderDlg* paramDlg;

	BOOL selfIllumClrOn;
	BOOL lockDS;
	BOOL lockAD;
	BOOL lockADTex;

	Color ambient;
	Color diffuse;
	Color specular;
	Color selfIllumClr;
	float selfIllum;	
	float softThresh;
	float glossiness;
	float specularLevel;

public:
	StdShaderImp();
	void ConvertParamBlk( ParamBlockDescID *descOld, int oldCount, IParamBlock *oldPB );
    void CopyStdParams( Shader* pFrom );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (StdShaderDlg*)newDlg; }

	virtual void  Illum(ShadeContext &sc, IllumParams &ip){};
	virtual void  AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol){};
	void CombineComponents( ShadeContext &sc, IllumParams& ip ){ CombineComponentsAdd(ip); }
    virtual ULONG SupportStdParams(){ return STD_BASIC+STD_EXTRA; }

	// texture maps
	virtual long  nTexChannelsSupported();
	virtual TSTR  GetTexChannelName( long nTex );
	virtual TSTR  GetTexChannelInternalName( long nTex );
	virtual long  ChannelType( long nTex );
	// map StdMat Channel ID's to the channel number
	virtual long StdIDToChannel( long stdID );

	BOOL KeyAtTime(int id,TimeValue t);
	void DeleteThis(){ delete this; }		
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	void Update(TimeValue t, Interval& valid);
	void Reset();
	void NotifyChanged();

	SClass_ID SuperClassID() { return SHADER_CLASS_ID; }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i);
	TSTR SubAnimName(int i);
	int SubNumToRefNum(int subNum) { return subNum;	}
 	// JBW: add direct ParamBlock access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }
	virtual ClassDesc2* GetCD() { return NULL; } // must be overridden

	// From ref
 	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);

	RefTargetHandle Clone( RemapDir &remap=NoRemap(), StdShaderImp* mnew=NULL );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// cache for mapping of params, mtl fills in ip
	void GetIllumParams( ShadeContext &sc, IllumParams& ip );

	// Shader specific section
	// these shd always be overridden
	virtual Class_ID ClassID(); 
	virtual TSTR GetName() ;
	virtual float EvalHiliteCurve(float x){ return 0.0f; }

	void SetLockDS(BOOL lock){ lockDS = lock; pblock->SetValue( shdr_ds_lock, 0, lock); }
	BOOL GetLockDS(){ return lockDS; }
	void SetLockAD(BOOL lock){ lockAD = lock; pblock->SetValue( shdr_ad_lock, 0, lock); }
	BOOL GetLockAD(){ return lockAD; }
	void SetLockADTex(BOOL lock){ lockADTex = lock; pblock->SetValue( shdr_ad_texlock, 0, lock); }
	BOOL GetLockADTex(){ return lockADTex; }

	void SetSelfIllum(float v, TimeValue t);		
	void SetSelfIllumClrOn( BOOL on ){ selfIllumClrOn = on; pblock->SetValue( shdr_use_self_illum_color, 0, on); };
	BOOL IsSelfIllumClrOn(){ return selfIllumClrOn; };
	void SetSelfIllumClr(Color c, TimeValue t);		

	void SetAmbientClr(Color c, TimeValue t);		
	void SetDiffuseClr(Color c, TimeValue t);		
	void SetSpecularClr(Color c, TimeValue t);
	void SetGlossiness(float v, TimeValue t);		
	void SetSpecularLevel(float v, TimeValue t);		
	void SetSoftenLevel(float v, TimeValue t);
		
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return selfIllumClrOn; };
	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE){ return ambient;}		
    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse;}		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE){ return specular; };
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE){ return selfIllumClr; };
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE){ return selfIllum; };
	float GetGlossiness(int mtlNum=0, BOOL backFace=FALSE){ return glossiness; };	
	float GetSpecularLevel(int mtlNum=0, BOOL backFace=FALSE){ return specularLevel; };
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return softThresh; };

	Color GetAmbientClr(TimeValue t);	
	Color GetDiffuseClr(TimeValue t);
	Color GetSpecularClr(TimeValue t);
	float GetGlossiness( TimeValue t);	
	float GetSpecularLevel(TimeValue t);
	float GetSoftenLevel(TimeValue t);
	float GetSelfIllum(TimeValue t);	
	Color GetSelfIllumClr(TimeValue t);	

};

///////////////////////////////////////////////////////////////////
//
//	generic standard shader dlg panel
//
#define NCOLBOX 4

class StdShaderDlg : public ShaderParamDlg {
public:
	StdShaderImp*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	 // window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite;    // the hilite window
	HWND		hRollup; // Rollup panel
	TimeValue	curTime;
	DWORD		curRGB;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[NCOLBOX];
	ISpinnerControl *softSpin;
	ISpinnerControl *shSpin, *ssSpin, *siSpin, *trSpin;
	ICustButton** texMBut;
	TexDADMgr dadMgr;
	
	StdShaderDlg(HWND hwMtlEdit, IMtlParams *pParams, int nButtons); 
	~StdShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw);

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(); //{ return StdShaderParamDlgClassID; }
	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader ){
		if (pShader) 
			pShader->SetParamDlg(NULL);   // DS 3/11/99
		pShader = (StdShaderImp*)theShader; 
		if( pShader ) 
			pShader->SetParamDlg(this); 
		pMtl = theMtl;
	}

	ReferenceTarget* GetThing(){ return (ReferenceTarget*)pMtl; }
	Shader* GetShader(){ return pShader; }
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		curTime = t; 
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		else
			UpdateOpacity();  // always update opacity since it's not in validity computations
		}		
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }

	// ***** required code
	void UpdateOpacity();
	// ***** 

	void LoadDialog(BOOL draw);
	void ReloadDialog();
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }
	void NotifyChanged();

	// the rest is all specific to standard shaders
	void UpdateMtlDisplay();
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateLockADTex(BOOL passOn);
	void UpdateMapButtons();
    void DrawHilite( HDC hdc, Rect& rect );
	void DisableNonMetalControls();

	void SetLockDS(BOOL lock);
	void SetLockAD(BOOL lock);
	void SetLockADTex(BOOL lock);

	void   SetMtlColor( int i, Color c );
	Color  GetMtlColor( int i );
	TCHAR* GetColorName( int i );

	void SelectEditColor(int i) ;
	void SetCurRGB(DWORD rgb) { curRGB = rgb; }

};

/////////////////////////////////////////////////////////////////////
//
//	Shader Channel Descriptions 
//
#define N_STD_SHADER_CHANNELS 8

#define NMBUTS 7
#define N_SI_BUT 5
#define N_TR_BUT 6

static int texMButtonsIDC[NMBUTS] = {
	IDC_MAPON_AM,	IDC_MAPON_DI,	IDC_MAPON_SP,	IDC_MAPON_SH,
	IDC_MAPON_SS,	IDC_MAPON_SI,	IDC_MAPON_TR, 
	};
		
// This array gives the texture map number for given MButton number								
// static int texmapFromMBut[NMBUTS] = { 0, 1, 2, 7, 3, 4, 5, 6 };
// these ID_s are from stdmat.h
static int texmapFromMBut[NMBUTS] = { ID_AM, ID_DI, ID_SP, ID_SS, ID_SH, ID_SI, ID_OP };

// channel names
static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, IDS_DS_SHIN_STR, IDS_DS_SHININESS, 
	IDS_KE_SELFILLUM, IDS_DS_TRANS, IDS_DS_FILTER, 
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,	
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,	
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,	
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE	};	

// internal non-local parsable channel map names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("ambientMap"), _T("diffuseMap"),	_T("specularMap"), _T("specularLevelMap"), _T("glossinessMap"),  
	_T("selfIllumMap"), _T("opacityMap"), _T("filterMap"),
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),	
	_T(""), _T(""), _T(""), _T("") };	

static int channelType[] = {
	CLR_CHANNEL, CLR_CHANNEL, CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, 
	CLR_CHANNEL, MONO_CHANNEL, CLR_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
};

// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { 0, 1, 2, 4, 3, 5, 6, 7, -1, -1, -1, -1 };

long StdShaderImp::StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

///////////////////////////////////////////////////////////////////////////////
//
//	StdShaders Paramter block
//
#define CURRENT_STDSHADER_VERSIOM 2
#define STDSHADER_NPARAMS 8
#define STDSHADER_PB_VERSION   1

//Current Param Block Descriptor
static ParamBlockDescID stdShaderPB[ STDSHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, TRUE, shdr_ambient },		// ambient
	{ TYPE_RGBA,  NULL, TRUE, shdr_diffuse },		// diffuse
	{ TYPE_RGBA,  NULL, TRUE, shdr_specular },		// specular
	{ TYPE_RGBA,  NULL, TRUE, shdr_self_illum_color }, // self-illum color
	{ TYPE_FLOAT, NULL, TRUE, shdr_self_illum_amnt },  // selfIllum
	{ TYPE_FLOAT, NULL, TRUE, shdr_glossiness },		// glossiness
	{ TYPE_FLOAT, NULL, TRUE, shdr_spec_lvl },		// specularLevel
	{ TYPE_FLOAT, NULL, TRUE, shdr_soften },			// soften
}; 

#define NUMOLDVER 1

static ParamVersionDesc oldVersions[NUMOLDVER] = {
	ParamVersionDesc(stdShaderPB,8, 0),
};

static ParamVersionDesc curVersion(stdShaderPB,STDSHADER_NPARAMS,STDSHADER_PB_VERSION);

#define STD_NMAX_TEXMAPS	12

////////////////////////////////////////////////////////////////////////////////////////
long  StdShaderImp::nTexChannelsSupported(){ return N_STD_SHADER_CHANNELS; }
TSTR  StdShaderImp::GetTexChannelName( long nTex ){ return GetString( texNameIDS[ nTex ] ); }
TSTR  StdShaderImp::GetTexChannelInternalName( long nTex ){ return texInternalNames[ nTex ]; }
long  StdShaderImp::ChannelType( long nTex ){ return channelType[ nTex ]; }

Class_ID StdShaderImp::ClassID(){ return StdShaderClassID; }

Color StdShaderImp::GetAmbientClr(TimeValue t)  { return pblock->GetColor(shdr_ambient,t); }		
Color StdShaderImp::GetDiffuseClr(TimeValue t)  { return pblock->GetColor(shdr_diffuse,t); }		
Color StdShaderImp::GetSpecularClr(TimeValue t) { return pblock->GetColor(shdr_specular,t);	}
float StdShaderImp::GetGlossiness( TimeValue t) {return pblock->GetFloat(shdr_glossiness,t);  }		
float StdShaderImp::GetSpecularLevel(TimeValue t)  { return  pblock->GetFloat(shdr_spec_lvl,t); }
float StdShaderImp::GetSoftenLevel(TimeValue t){ return  pblock->GetFloat(shdr_soften,t); }
float StdShaderImp::GetSelfIllum(TimeValue t){ return  pblock->GetFloat(shdr_self_illum_amnt,t); }		
Color StdShaderImp::GetSelfIllumClr(TimeValue t){ return  pblock->GetColor(shdr_self_illum_color,t); }		

//StdShaderImp::StdShaderImp(ClassDesc2* pParentCD) 
StdShaderImp::StdShaderImp() 
{ 
	lockDS = lockAD = lockADTex = selfIllumClrOn = 0;
	pblock = NULL; 
	paramDlg = NULL; 
	ivalid.SetEmpty(); 
}

void StdShaderImp::CopyStdParams( Shader* pFrom )
{
	macroRecorder->Disable();  // don't want to see this parameter copying in macrorecorder
		SetLockDS( pFrom->GetLockDS() );
		SetLockAD( pFrom->GetLockAD() );
		SetLockADTex( pFrom->GetLockADTex() );
		SetSelfIllumClrOn( pFrom->IsSelfIllumClrOn() );

		SetAmbientClr( pFrom->GetAmbientClr(0,0), curTime );
		SetDiffuseClr( pFrom->GetDiffuseClr(0,0), curTime );
		SetSpecularClr( pFrom->GetSpecularClr(0,0), curTime );
		SetSelfIllumClr( pFrom->GetSelfIllumClr(0,0), curTime );

		SetSelfIllum( pFrom->GetSelfIllum(0,0), curTime );
		SetSpecularLevel( pFrom->GetSpecularLevel(0,0), curTime );
		SetGlossiness( pFrom->GetGlossiness(0,0), curTime );
		SetSoftenLevel( pFrom->GetSoftenLevel(0,0), curTime );
	macroRecorder->Enable();

	ivalid.SetEmpty();	
}

void StdShaderImp::ConvertParamBlk( ParamBlockDescID *oldPBDesc, int oldCount, IParamBlock *oldPB )
{
	// old Standrard material loaded, transfer any shader-related parameters from old Mtl PB to shader PB2
	UpdateParameterBlock2(oldPBDesc, oldCount, oldPB, pblock->GetDesc(), pblock);
}


BOOL StdShaderImp::KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime((ParamID)id,t); }
TSTR StdShaderImp::GetName() { return GetString( IDS_KE_STDSHADER ); }

#define LIMIT0_1(x) if (x < 0.0f) x = 0.0f; else if (x > 1.0f) x = 1.0f;
#define LIMITMINMAX(x, min, max) if (x < min) x = min; else if (x > max) x = max;

static Color LimitColor(Color c) {
	LIMIT0_1(c.r);
	LIMIT0_1(c.g);
	LIMIT0_1(c.b);
	return c;
}

RefTargetHandle StdShaderImp::Clone( RemapDir &remap, StdShaderImp* mnew )
{
	if (mnew == NULL ){
		assert( 0 );
		mnew = new StdShaderImp();
	}

	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	

	mnew->ambient = ambient;
	mnew->diffuse = diffuse;
	mnew->specular = specular;
	mnew->glossiness = glossiness;
	mnew->specularLevel = specularLevel;
	mnew->softThresh = softThresh;
	mnew->selfIllum = selfIllum;
	mnew->selfIllumClr = selfIllumClr;
	mnew->selfIllumClrOn = selfIllumClrOn;
	mnew->lockDS = lockDS;
	mnew->lockAD = lockAD;
	mnew->lockADTex = lockADTex;
	
	return (RefTargetHandle)mnew;
}

void StdShaderImp::GetIllumParams( ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.shFlags = selfIllumClrOn? SELFILLUM_CLR_ON : 0;
	ip.channels[ID_AM] = ambient;
	ip.channels[ID_DI] = diffuse;
	ip.channels[ID_SP] = specular;
	ip.channels[StdIDToChannel(ID_SH)].r = glossiness;
	ip.channels[StdIDToChannel(ID_SS)].r = specularLevel;
	if( selfIllumClrOn )
		ip.channels[ID_SI] = selfIllumClr;
	else
		ip.channels[ID_SI].r = ip.channels[ID_SI].g = ip.channels[ID_SI].b = selfIllum;
}


void StdShaderImp::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( shdr_ambient, t, p, ivalid );
		ambient = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( shdr_diffuse, t, p, ivalid );
		diffuse= LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( shdr_specular, t, p, ivalid );
		specular = LimitColor(Color(p.x,p.y,p.z));

		pblock->GetValue( shdr_glossiness, t, glossiness, ivalid );
		LIMIT0_1(glossiness);
		pblock->GetValue( shdr_spec_lvl, t, specularLevel, ivalid );
		LIMITMINMAX(specularLevel,0.0f,9.99f);
		pblock->GetValue( shdr_soften, t, softThresh, ivalid); 
		LIMIT0_1(softThresh);

		pblock->GetValue( shdr_self_illum_amnt, t, selfIllum, ivalid );
		LIMIT0_1(selfIllum);
		pblock->GetValue( shdr_self_illum_color, t, p, ivalid );
		selfIllumClr = LimitColor(Color(p.x,p.y,p.z));

		// also get the non-animatables in case changed from scripter or other pblock accessors
		pblock->GetValue(shdr_ds_lock, t, lockDS, ivalid);
		pblock->GetValue(shdr_ad_lock, t, lockAD, ivalid);
		pblock->GetValue(shdr_ad_texlock, t, lockADTex, ivalid);
		pblock->GetValue(shdr_use_self_illum_color, t, selfIllumClrOn, ivalid);

		curTime = t;
	}
	valid &= ivalid;
}

void StdShaderImp::Reset()
{
	if ( pblock==NULL )
		GetCD()->MakeAutoParamBlocks(this);	// make and intialize paramblock2
	
	ivalid.SetEmpty();
	macroRecorder->Disable();  // don't want to see this parameter reset in macrorecorder
		SetSoftenLevel(0.1f,0);
		SetAmbientClr(Color(0.1f,0.1f,0.1f),0);
		SetDiffuseClr(Color(0.5f,0.5f,0.5f),0);
		SetSpecularClr(Color(0.9f,0.9f,0.9f),0);
		SetGlossiness(.25f,0);   // change from .4, 5-21-97
		SetSpecularLevel(.05f,0);   

		SetSelfIllum(.0f,0);
		SetSelfIllumClr( Color(.0f, .0f, .0f), 0 );
		SetSelfIllumClrOn( FALSE );
		SetLockADTex( TRUE );
		SetLockAD( FALSE );
		SetLockDS( FALSE );
	macroRecorder->Enable(); 
}

void StdShaderImp::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

RefResult StdShaderImp::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget==pblock)
			{
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg)
					paramDlg->UpdateDialog( changingParam );
			}
			break;
	}
	return(REF_SUCCEED);
}


TSTR StdShaderImp::SubAnimName(int i) { 
	return TSTR(GetString( IDS_DS_PARAMETERS ));
}		

Animatable* StdShaderImp::SubAnim(int i) {
	switch(i) {
		case 0: return pblock; 
		default: assert(0); return NULL;
	}
}

RefTargetHandle StdShaderImp::GetReference(int i) {
	switch(i) {
		case 0: return pblock;
		default: assert(0);	 return NULL;
	}
}

void StdShaderImp::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2*)rtarg; return;
		default: assert(0);
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
#define SHADER_HDR_CHUNK 0x4000
#define SHADER_SELFILLUM_CLR_ON_CHUNK 0x5000
#define SHADER_LOCKDS_ON_CHUNK 0x5001
#define SHADER_LOCKAD_ON_CHUNK 0x5002
#define SHADER_LOCKADTEX_ON_CHUNK 0x5003
#define SHADER_MAPSON_CHUNK 0x5004
#define SHADER_VERS_CHUNK 0x5300

#define SHADER_VERSION  2 

// IO
IOResult StdShaderImp::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = SHADER_VERSION;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();


	return IO_OK;
}		

class StdShaderCB: public PostLoadCallback {
	public:
		StdShaderImp *s;
		int loadVersion;
	    StdShaderCB(StdShaderImp *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			// convert old v1 ParamBlock to ParamBlock2
			ParamBlockDesc2* pbd = s->GetCD()->GetParamBlockDescByID(shdr_params);
			s->ReplaceReference(0,
				UpdateParameterBlock2(stdShaderPB, STDSHADER_NPARAMS, (IParamBlock*)s->pblock, pbd));

			// then set values that were previously stored outside the PB
			s->pblock->SetValue(shdr_use_self_illum_color, 0, s->selfIllumClrOn);
			s->pblock->SetValue(shdr_ds_lock, 0, s->lockDS);
			s->pblock->SetValue(shdr_ad_lock, 0, s->lockAD);
			s->pblock->SetValue(shdr_ad_texlock, 0, s->lockADTex);
		}
};


IOResult StdShaderImp::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	selfIllumClrOn = lockAD = lockADTex = lockDS = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_SELFILLUM_CLR_ON_CHUNK:
				selfIllumClrOn = TRUE;
				break;
			case SHADER_LOCKDS_ON_CHUNK:
				lockDS = TRUE;
				break;
			case SHADER_LOCKAD_ON_CHUNK:
				lockAD = TRUE;
				break;
			case SHADER_LOCKADTEX_ON_CHUNK:
				lockADTex = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new StdShaderCB(this, version));
		iload->SetObsolete();
	}

	return IO_OK;

}



void StdShaderImp::SetAmbientClr(Color c, TimeValue t) 
{
	ambient =c;
	pblock->SetValue( shdr_ambient, t, Point3(c.r,c.g,c.b));
}
			
void StdShaderImp::SetDiffuseClr(Color c, TimeValue t) 
{
	Point3 p;
	Interval iv;
	pblock->SetValue( shdr_diffuse, t, Point3(c.r,c.g,c.b));

	pblock->GetValue( shdr_diffuse, t, p, iv );
	diffuse = LimitColor(Color(p.x,p.y,p.z));

}
			
void StdShaderImp::SetSpecularClr(Color c, TimeValue t) 
{
    specular = c;
	pblock->SetValue( shdr_specular, t, Point3(c.r,c.g,c.b));
}
			
			
void StdShaderImp::SetGlossiness(float v, TimeValue t) 
{
	glossiness = v;
	pblock->SetValue( shdr_glossiness, t, v);
}
			
void StdShaderImp::SetSpecularLevel(float v, TimeValue t) 
{
	specularLevel = v;
	pblock->SetValue( shdr_spec_lvl, t, v);
}

void StdShaderImp::SetSoftenLevel(float v, TimeValue t) 
{
	softThresh = v;
	pblock->SetValue( shdr_soften, t, v);
}

void StdShaderImp::SetSelfIllum(float v, TimeValue t) 
{
	selfIllum =v;
	pblock->SetValue( shdr_self_illum_amnt, t, v);
}

void StdShaderImp::SetSelfIllumClr(Color c, TimeValue t) 
{
	selfIllumClr = c;
	pblock->SetValue( shdr_self_illum_color, t, Point3(c.r,c.g,c.b) );
}
		
static BOOL CALLBACK  StdShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StdShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (StdShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (StdShaderDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}



ShaderParamDlg* StdShaderImp::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) {
	Interval v;
	Update(imp->GetTime(),v);
	StdShaderDlg *pDlg = new StdShaderDlg(hwMtlEdit, imp, NMBUTS );
	pDlg->SetThings( theMtl, theMtl->GetShader() );
	LoadStdShaderResources();
	if ( hOldRollup )
		pDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC7),
			StdShaderDlgProc, 
			rollupName(theMtl->GetShader()),	
			(LPARAM)pDlg , 
			rollupOpen
			);		
	else 
		pDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC7),
			StdShaderDlgProc, 
			rollupName(theMtl->GetShader()),	
			(LPARAM)pDlg , 
			rollupOpen
			);	
	return pDlg;	
}


///////////////////////////////////////////////////////////////////
//
//	generic standard shader dlg panel
//
StdShaderDlg::StdShaderDlg( HWND hwMtlEdit, IMtlParams *pParams, int nMapButtons )
{
	pShader = NULL;
	pMtl = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;

	dadMgr.Init(this);
	
	shSpin = softSpin = ssSpin = siSpin = trSpin = NULL;
	for( long i = 0; i < NCOLBOX; ++i )
		cs[ i ] = NULL;

	texMBut = new ICustButton*[ NMBUTS ];
	for( i = 0; i < NMBUTS; ++i )
		texMBut[ i ] = NULL;

	hRollup = hwHilite = NULL;
	curTime = pMtlPar->GetTime();
	curRGB = 0;
	isActive = valid = FALSE;
}

StdShaderDlg::~StdShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if ( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < NMBUTS; i++ )
	{
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}
// mjm - begin - 5.10.99
	delete[] texMBut;

	for (i=0; i<NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]);
// mjm - end

	ReleaseISpinner(shSpin);
	ReleaseISpinner(ssSpin);
	ReleaseISpinner(softSpin);
	ReleaseISpinner(siSpin);
	ReleaseISpinner(trSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}

int StdShaderDlg::FindSubTexFromHWND(HWND hw)
{
	for (long i=0; i<NMBUTS; i++) {
		if (hw == texMBut[i]->GetHwnd()) 
			return texmapFromMBut[i];
	}	
	return -1;
}

Class_ID StdShaderDlg::ClassID(){ return StdShaderParamDlgClassID; }

void  StdShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		Interval v;
		
		IRollupWindow* pRollup = pMtlPar->GetMtlEditorRollup();
		pRollup->SetPanelTitle( pRollup->GetPanelIndex(hRollup), rollupName(pShader) );

		shSpin->SetValue(FracToPc(pShader->GetGlossiness()),FALSE);
		shSpin->SetKeyBrackets(KeyAtCurTime(shdr_glossiness));

		ssSpin->SetValue(FracToPc(pShader->GetSpecularLevel()),FALSE);
		ssSpin->SetKeyBrackets(KeyAtCurTime(shdr_spec_lvl));

		softSpin->SetValue(pShader->GetSoftenLevel(),FALSE);
		softSpin->SetKeyBrackets(KeyAtCurTime(shdr_soften));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity( curTime )),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		softSpin->Enable( ! (pShader->SupportStdParams() & STD_PARAM_METAL) );

		CheckButton(hRollup, IDC_LOCK_AD, pShader->GetLockAD() );
		CheckButton(hRollup, IDC_LOCK_DS, pShader->GetLockDS() );
	 	UpdateLockADTex( FALSE ); //don't send to mtl
		DisableNonMetalControls();

		// >>>> color selfIllum
		BOOL colorSelfIllum = pShader->IsSelfIllumClrOn();
		SetCheckBox(hRollup,IDC_SI_COLORON, colorSelfIllum ); 
		if( colorSelfIllum ) {
//			ShowWindow( siSpin->GetHwnd(), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_HIDE );
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
		} else {
			// disable the color swatch
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			// show self-illum slider
//			ShowWindow( siSpin->GetHwnd(), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_SHOW );

			siSpin->SetValue(FracToPc(pShader->GetSelfIllum()), FALSE);
			siSpin->SetKeyBrackets(KeyAtCurTime(shdr_self_illum_amnt));
		}

		UpdateColSwatches();
		UpdateHilite();
	}
}


void StdShaderDlg::NotifyChanged() 
{
	pShader->NotifyChanged();
}

void StdShaderDlg::ReloadDialog() 
{
	Interval v;
	pShader->Update(pMtlPar->GetTime(), v);
	LoadDialog(FALSE);
}


void StdShaderDlg::UpdateMtlDisplay()
{
	pMtlPar->MtlChanged(); // redraw viewports
}


static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void StdShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm	 = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);
	}
}


void StdShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}

Color StdShaderDlg::GetMtlColor(int i) 
{
	switch(i) {
		case 0:  return pShader->GetAmbientClr(); 
		case 1:  return pShader->GetDiffuseClr();
		case 2:  return pShader->GetSpecularClr();
		case 3:  return pShader->GetSelfIllumClr();
		default: return Color(0,0,0);
	}
}

TCHAR *StdShaderDlg::GetColorName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_AMBIENT);	 
		case 1:  return GetString(IDS_DS_DIFFUSE);	 
		case 2:  return GetString(IDS_DS_SPECULAR);	 
		case 3:  return GetString(IDS_KE_SELFILLUM_CLR);	 
		default: return GetString(IDS_KE_NOSUCH_CLR);	 
	}
}

void StdShaderDlg::SetMtlColor(int i, Color c) {
	switch(i) {
		case 0: //ambient
			pShader->SetAmbientClr(c,curTime); 
			if ( pShader->GetLockAD() ){
				pShader->SetDiffuseClr(c, curTime);
				cs[1]->SetColor( c );
				if (pShader->GetLockDS() ){
					pShader->SetSpecularClr(c,curTime);
					cs[2]->SetColor(c);
				}
			}
			break;
		case 1: //diffuse
			pShader->SetDiffuseClr(c,curTime); 
			if (pShader->GetLockAD() ){
				pShader->SetAmbientClr(c,curTime);
				cs[0]->SetColor(c);
			}
			if ( pShader->GetLockDS() ){
				pShader->SetSpecularClr(c,curTime);
				cs[2]->SetColor(c);
				}
			break;
		case 2: // specular
			pShader->SetSpecularClr(c,curTime); 
			if (pShader->GetLockDS() ){
				pShader->SetDiffuseClr(c,curTime);
				cs[1]->SetColor(c);
				if (pShader->GetLockAD() ){
					pShader->SetAmbientClr(c,curTime);
					cs[0]->SetColor(c);
					}
				}
			break;
		case 3: 
			pShader->SetSelfIllumClr(c,curTime); 
			break;
	}
}

void StdShaderDlg::SelectEditColor(int i) {
	cs[ i ]->EditThis(FALSE);
	curRGB = GetMtlColor(i);
}

void StdShaderDlg::SetLockAD(BOOL lock)
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_AD, FALSE);	
			return;	
		}
		// set ambient color to diffuse
		pShader->SetAmbientClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockAD(lock);
}


void StdShaderDlg::UpdateColSwatches() 
{
	for(int i=0; i < NCOLBOX; i++) {
		if ( cs[ i ] ) {
			cs[i]->SetKeyBrackets( pShader->KeyAtTime(colParamID[i],curTime) );
			cs[i]->SetColor( GetMtlColor(i) );
		}
	}
}

//-HiLite Curve Control------------------------------------------------------

static LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	StdShaderDlg *theDlg = (StdShaderDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_COMMAND: 	
		case WM_MOUSEMOVE: 	
		case WM_LBUTTONUP: 
		case WM_CREATE:
		case WM_DESTROY: 
		break;

		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				theDlg->DrawHilite(hdc, rect);
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 


static void VertLine(HDC hdc,int x, int ystart, int yend) 
{
	MoveToEx(hdc, x, ystart, NULL); 
	if (ystart <= yend)
		LineTo(hdc, x, yend+1);
	else 
		LineTo(hdc, x, yend-1);
}

void StdShaderDlg::DrawHilite(HDC hdc, Rect& rect)
{
int w,h,npts,xcen,ybot,ytop,ylast,i,iy;

	HPEN linePen = (HPEN)GetStockObject(WHITE_PEN);
	HPEN fgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNFACE));
	HPEN bgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNSHADOW));

	w = rect.w();
	h = rect.h()-3;
	npts = (w-2)/2;
	xcen = rect.left+npts;
	ybot = rect.top+h;
	ytop = rect.top+2;
	ylast = -1;
	for (i=0; i<npts; i++) {
		float v = pShader->EvalHiliteCurve( (float)i/((float)npts*2.0f) );
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = ybot-(int)(v*((float)h-2.0f));

		if (iy<ytop) iy = ytop;

		SelectPen(hdc, fgPen);
		VertLine(hdc,xcen+i,ybot,iy);
		VertLine(hdc,xcen-i,ybot,iy);

		if (iy-1>ytop) {
			// Fill in above curve
			SelectPen(hdc,bgPen);
			VertLine(hdc,xcen+i, ytop, iy-1);
			VertLine(hdc,xcen-i, ytop, iy-1);
			}
		if (ylast>=0) {
			SelectPen(hdc,linePen);
			VertLine(hdc,xcen+i-1,iy-1,ylast);
			VertLine(hdc,xcen-i+1,iy-1,ylast);
			}

		ylast = iy;
	}

	SelectObject( hdc, linePen );
	DeleteObject(fgPen);
	DeleteObject(bgPen);
	WhiteRect3D(hdc, rect, 1);
}


void StdShaderDlg::DisableNonMetalControls() 
{
	BOOL b = (pShader->SupportStdParams() & STD_PARAM_METAL) ? 0 : 1;
//	EnableWindow( GetDlgItem(hRollup,  IDC_SOFT_EDIT), b);
//	EnableWindow( GetDlgItem(hRollup,  IDC_SPEC), b);
//	EnableWindow( GetDlgItem(hRollup,  IDC_MAPON_SP), b);
//	EnableWindow( GetDlgItem(hRollup,  IDC_LOCK_DS), b);

	ShowWindow( GetDlgItem(hRollup,  IDC_SOFT_EDIT), b);
	ShowWindow( GetDlgItem(hRollup,  IDC_SOFT_SPIN), b);
	ShowWindow( GetDlgItem(hRollup,  IDC_MAPON_SP), b);
	ShowWindow( GetDlgItem(hRollup,  IDC_LOCK_DS), b);
	ShowWindow( GetDlgItem(hRollup,  IDC_SPEC_TEXT), b);
	ShowWindow( GetDlgItem(hRollup,  IDC_SOFTEN_TEXT), b);
	ShowWindow( cs[2]->GetHwnd(), b );
}

void StdShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite(hdc, r);
	ReleaseDC(hwHilite,hdc);
}

void StdShaderDlg::UpdateLockADTex( BOOL passOn) {
	int lock = 	pShader->GetLockADTex();
	CheckButton(hRollup, IDC_LOCK_ADTEX, lock);

	ShowWindow(GetDlgItem(hRollup, IDC_MAPON_AM), !lock);
	texMBut[ 0 ]->Enable(!lock);

	if ( passOn ) {
		pMtl->SyncADTexLock( lock );
	}
//	UpdateMtlDisplay();
}


void StdShaderDlg::SetLockADTex(BOOL lock) {
	pShader->SetLockADTex( lock );
	UpdateLockADTex(TRUE); // passon to mtl
	NotifyChanged();
	UpdateMtlDisplay();
	}

void StdShaderDlg::SetLockDS(BOOL lock) 
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCK_DS),GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_DS, FALSE);	
			return;	
		}
		pShader->SetSpecularClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockDS( lock );
}

int _ColIDCToIndex(int id) {
	switch (id) {
		case IDC_STD_COLOR1: return 0;
		case IDC_STD_COLOR2: return 1;
		case IDC_STD_COLOR3: return 2;
		case IDC_SI_COLOR: return 3;
		default: return 0;
		}
	}


BOOL StdShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			int i;
			
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			for (i=0; i<NCOLBOX; i++) {
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					GetMtlColor(i), GetColorName(i));
			}

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)HiliteWndProc);

			shSpin = SetupIntSpinner(hwndDlg, IDC_SH_SPIN, IDC_SH_EDIT, 0,100, 0);
			ssSpin = SetupIntSpinner(hwndDlg, IDC_SS_SPIN, IDC_SS_EDIT, 0,999, 0);
			softSpin = SetupFloatSpinner(hwndDlg, IDC_SOFT_SPIN, IDC_SOFT_EDIT, 0.0f,1.0f,0.0f,.01f);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupLockButton(hwndDlg,IDC_LOCK_DS,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);

/* // mjm - 5.10.99 - isn't this already created above when i == N_SI_CLR?
			// create both a self-illum color as well as a spinner
			cs[N_SI_CLR] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[N_SI_CLR] ),
   											GetMtlColor(N_SI_CLR), GetColorName(N_SI_CLR));
*/
			// self-illum spinner
			siSpin = SetupIntSpinner(hwndDlg, IDC_SI_SPIN, IDC_SI_EDIT, 0,100, 0);
			
			if( pShader->IsSelfIllumClrOn() ) {
				// enable the color swatch, disable the spinner
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
			} else {
				// disable the color swatch
				ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			}

			LoadDialog(TRUE);
			}
			break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}

		    switch (id) {

				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_DS:
					SetLockDS(IsButtonChecked(hwndDlg, IDC_LOCK_DS));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_ADTEX:{
					BOOL on = IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX);
					SetLockADTex(on);
					UpdateMtlDisplay();
				} break;

				case IDC_SI_COLORON:{
					int isOn = GetCheckBox(hwndDlg, IDC_SI_COLORON );
					pShader->SetSelfIllumClrOn( isOn );			
					if ( isOn ) {
						// enable the color swatch, disable the spinner
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
					} else {
						// disable the color swatch
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_SHOW );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_SHOW );
					}
				    NotifyChanged();
					UpdateMtlDisplay();
				}
				break;
			}
			break;
		case CC_COLOR_SEL:
			{
			int id = LOWORD(wParam);
			SelectEditColor(_ColIDCToIndex(id));
			}			
			break;
		case CC_COLOR_DROP:
			{
			int id = LOWORD(wParam);
			SelectEditColor(_ColIDCToIndex(id));
			UpdateMtlDisplay();				
			}			
			break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();				
			break;
		case CC_COLOR_CHANGE:
			{			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = _ColIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			curRGB = cs[n]->GetColor();
			SetMtlColor(n, curRGB);
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				// DS: 5/3/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
			}			
			break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
			break;       
		case WM_DESTROY:
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_SH_SPIN: 
					pShader->SetGlossiness(PcToFrac(shSpin->GetIVal()), curTime); 
					UpdateHilite();
					break;
				case IDC_SS_SPIN: 
					pShader->SetSpecularLevel(PcToFrac(ssSpin->GetIVal()),curTime); 
					UpdateHilite();
					break;
				case IDC_SOFT_SPIN: 
					pShader->SetSoftenLevel(softSpin->GetFVal(),curTime); 
					break;
				case IDC_SI_SPIN: 
					pShader->SetSelfIllum(PcToFrac(siSpin->GetIVal()),curTime); 
					break;
				//******** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    	}
	exit:
	return FALSE;
	}



//----------------------------------------------------------------------------------------
//- Constant & Phong Shader  -------------------------------------------------------------
//----------------------------------------------------------------------------------------
#define	SELFILLUM_FRAC		1.0f

void phongIllum(ShadeContext &sc, IllumParams &ip, float softThresh) 
{
LightDesc *l;
Color lightCol;
BOOL isShiny;
Point3 R;

	if (isShiny = (ip.channels[stdIDToChannel[ID_SS]].r > 0.0f) ) 
		R = sc.ReflectVector(); // no use of ip.N?, no, it's in sc too

	double phExp = pow(2.0, ip.channels[stdIDToChannel[ID_SH]].r * 10.0); // expensive.!!	TBD

	for (int i=0; i<sc.nLights; i++) {

		l = sc.Light(i);
		register float NL, kL;
		Point3 L;
		if (l->Illuminate(sc, ip.N, lightCol, L, NL, kL) ){
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;
			// diffuse
			if (l->affectDiffuse)
				ip.diffIllumOut += kL * lightCol;
			if (isShiny && l->affectSpecular) {
				// specular (Phong2) 
				float c = DotProd(L,R);
				if (c > 0.0f) {
					if (softThresh != 0.0 && kL < softThresh ){
						float r = kL/softThresh;
						c *= Soften(r);
					}
					c = (float)pow((double)c, (double)phExp); // could use table lookup for speed
					ip.specIllumOut += c * ip.channels[stdIDToChannel[ID_SS]].r * lightCol;
				}
			}
		}
	}
	
	// Apply mono self illumination
	BOOL clrSelfIllum = (ip.shFlags & SELFILLUM_CLR_ON) ? 1 : 0;
	if ( ! clrSelfIllum ){
		// changed back, fixed in getIllumParams, KE 4/27
		float si = 0.3333333f * (ip.channels[ID_SI].r + ip.channels[ID_SI].g + ip.channels[ID_SI].b);
		//		float si = ip.channels[ID_SI].r; // DS: 4/23/99
//		ip.diffIllumOut = (si>=1.0f) ?  Color(1.0f,1.0f,1.0f) 
//			: ip.diffIllumOut * (1.0f-si) + si;
		if ( si > 0.0f ) {
			si = UBound( si );
			ip.selfIllumOut = si * ip.channels[ID_DI];
			ip.diffIllumOut *= (1.0f-si);
			// fade the ambient down on si: 5/27/99 ke
			ip.ambIllumOut *= 1.0f-si;
		}
	}
	else {
		// colored self-illum
		ip.selfIllumOut += ip.channels[ID_SI];
		}

	// now we can multiply by the clrs,
	ip.ambIllumOut *= ip.channels[ID_AM]; 
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= ip.channels[ID_DI]; 
	ip.specIllumOut *= ip.channels[ID_SP]; 

}


class Constant2: public StdShaderImp {
public:
	BOOL IsFaceted() { return TRUE; }
	Class_ID 		ClassID() { return ConstantClassID; }
	TSTR GetName() { return GetString( IDS_KE_CONSTANT ); }
	void Illum(ShadeContext &sc, IllumParams &ip){ 
		phongIllum( sc, ip, softThresh ); 
		}
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) { 
		rcol *= ip.channels[ID_SP];
	};
	float EvalHiliteCurve(float x) {
		double phExp = pow(2.0, glossiness * 10.0); // expensive.!!	TBD
		return specularLevel*(float)pow((double)cos(x*PI), phExp );  
	}
	RefTargetHandle Clone( RemapDir &remap ){ Constant2* s = new Constant2(); 
											  StdShaderImp::Clone(remap, s); 
											  return s;	
											}
	ClassDesc2* GetCD();
//	Constant2();
};

class ConstantShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Constant2(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CONSTANT); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return ConstantClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Constant"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};
ConstantShaderClassDesc constCD;
ClassDesc * GetConstantShaderCD(){ return &constCD; }
ClassDesc2* Constant2::GetCD() { return &constCD; }
//Constant2::Constant2(){ StdShaderImp(); }

// shader parameters
static ParamBlockDesc2 const_param_blk ( shdr_params, _T("shaderParameters"),  0, &constCD, P_AUTO_CONSTRUCT, 0, 
	// params
	shdr_ambient,	 _T("ambient"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_AMBIENT,	
		p_default,		Color(0, 0, 0), 
		end,
	shdr_diffuse,	 _T("diffuse"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_DIFFUSE,	
		p_default,		Color(0.5f, 0.5f, 0.5f), 
		end,
	shdr_specular,	 _T("specular"), TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_SPECULAR,	
		p_default,		Color(1.0f, 1.0f, 1.0f), 
		end,
	shdr_ad_texlock, _T("adTextureLock"),	TYPE_BOOL,		0,				IDS_JW_ADTEXLOCK,	
		p_default,		TRUE, 
		end,
	shdr_ad_lock,	_T("adLock"),	TYPE_BOOL,				0,				IDS_JW_ADLOCK,	
		p_default,		FALSE, 
		end,
	shdr_ds_lock,	_T("dsLock"),	TYPE_BOOL,				0,				IDS_JW_DSLOCK,	
		p_default,		FALSE, 
		end,
	shdr_use_self_illum_color, _T("useSelfIllumColor"), TYPE_BOOL, 0,		IDS_JW_SELFILLUMCOLORON,	
		p_default,		FALSE, 
		end,
	shdr_self_illum_amnt, _T("selfIllumAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE, IDS_KE_SELFILLUM,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	shdr_self_illum_color, _T("selfIllumColor"), TYPE_RGBA, P_ANIMATABLE,	IDS_KE_SELFILLUM_CLR,	
		p_default,		Color(0, 0, 0), 
		end,
	shdr_spec_lvl,	_T("specularLevel"),TYPE_PCNT_FRAC,		P_ANIMATABLE,	IDS_KE_SPEC_LEVEL,
		p_default,	 	0.0,
		p_range,		0.0, 999.0,
		end,
	shdr_glossiness, _T("glossiness"),	TYPE_PCNT_FRAC,		P_ANIMATABLE,	IDS_KE_GLOSSINESS,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	shdr_soften,		_T("soften"),		TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SOFTEN,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		end,
	end
	);

class Phong2: public StdShaderImp {
public:
	Class_ID 		ClassID() { return PhongClassID; }
	TSTR GetName() { return GetString( IDS_KE_PHONG ); }
	void Illum(ShadeContext &sc, IllumParams &ip){
		phongIllum( sc, ip, softThresh ); 
		}
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) { 
		rcol *= ip.channels[ID_SP];
	};
	float EvalHiliteCurve(float x) {
		double phExp = pow(2.0, glossiness * 10.0); 
		return specularLevel*(float)pow((double)cos(x*PI), phExp );  
	}
	RefTargetHandle Clone( RemapDir &remap ){ Phong2* s = new Phong2(); 
											  StdShaderImp::Clone(remap, s); 
											  return s;	
											}
	ClassDesc2* GetCD();
//	Phong2();
};

class PhongShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Phong2(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_PHONG); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return PhongClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Phong2"); }		// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

PhongShaderClassDesc phongCD;
ClassDesc * GetPhongShaderCD(){ return &phongCD; }
ClassDesc2* Phong2::GetCD() { return &phongCD; }

// shader parameters
static ParamBlockDesc2 phong2_param_blk ( shdr_params, _T("shaderParameters"),  0, &phongCD, P_AUTO_CONSTRUCT + P_USE_PARAMS, 
	// pblock refno
	0, 
	// use params from existing descriptor
	&const_param_blk
	);
							 

//----------------------------------------------------------------------------------------
//- Blinn2 Shader  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------

class Blinn2: public StdShaderImp {
	public:
	Class_ID 		ClassID() { return BlinnClassID; }
	TSTR GetName() { return GetString( IDS_KE_BLINN ); }
	void Illum(ShadeContext &sc, IllumParams &ip);
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) 
		{ rcol *= ip.channels[ID_SP]; };
	float EvalHiliteCurve(float x) {
		double phExp = pow(2.0, glossiness * 10.0); // expensive.!!	TBD
		return specularLevel*(float)pow((double)cos(x*PI), phExp );  
		}
	RefTargetHandle Clone( RemapDir &remap ){ Blinn2* s = new Blinn2(); 
											  StdShaderImp::Clone(remap, s); 
											  return s;	
											}
	ClassDesc2* GetCD();
};

class BlinnShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Blinn2(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLINN); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return BlinnClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Blinn2"); }		// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

BlinnShaderClassDesc blinnCD;
ClassDesc * GetBlinnShaderCD(){ return &blinnCD; }
ClassDesc2* Blinn2::GetCD() { return &blinnCD; }


// fix for loading alpha files >>>>>>< !!!! out for release
class OldBlinnShaderClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { 	return new Blinn2(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLINN); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return OldBlinnClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

OldBlinnShaderClassDesc oldBlinnCD;
ClassDesc * GetOldBlinnShaderCD(){ return &oldBlinnCD; }

// shader parameters
static ParamBlockDesc2 blinn2_param_blk ( shdr_params, _T("shaderParameters"),  0, &blinnCD, P_AUTO_CONSTRUCT + P_USE_PARAMS, 
	// pblock refno
	0, 
	// use params from existing descriptor
	&const_param_blk
	);
										 
void Blinn2::Illum(ShadeContext &sc, IllumParams &ip) {
	LightDesc *l;
	Color lightCol;

	// Blinn style phong
	BOOL is_shiny= (ip.channels[StdIDToChannel(ID_SS)].r > 0.0f) ? 1:0; 
	double phExp = pow(2.0, ip.channels[StdIDToChannel(ID_SH)].r * 10.0) * 4.0; // expensive.!!	TBD

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (l->Illuminate(sc,ip.N,lightCol,L,NL,diffCoef)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// diffuse
			if (l->affectDiffuse)
				ip.diffIllumOut += diffCoef * lightCol;

			// specular (Phong2) 
			if (is_shiny&&l->affectSpecular) {
				Point3 H = Normalize(L-ip.V);
				float c = DotProd(ip.N,H);	 
				if (c>0.0f) {
					if (softThresh!=0.0 && diffCoef<softThresh) {
						c *= Soften(diffCoef/softThresh);
						}
					c = (float)pow((double)c, phExp); // could use table lookup for speed
					ip.specIllumOut += c * ip.channels[StdIDToChannel(ID_SS)].r * lightCol;
					}
				}
 			}
		}

	// Apply mono self illumination
	if ( ! selfIllumClrOn ){
		// lerp between diffuse & white
		// changed back, fixed in getIllumParams, KE 4/27
		float si = 0.3333333f * (ip.channels[ID_SI].r + ip.channels[ID_SI].g + ip.channels[ID_SI].b);
		if ( si > 0.0f ) {
			si = UBound( si );
			ip.selfIllumOut = si * ip.channels[ID_DI];
			ip.diffIllumOut *= (1.0f-si);
			// fade the ambient down on si: 5/27/99 ke
			ip.ambIllumOut *= 1.0f-si;
		}
	} else {
		// colored self illum, 
		ip.selfIllumOut += ip.channels[ID_SI];
	}
	// now we can multiply by the clrs, 
	ip.ambIllumOut *= ip.channels[ID_AM]; 
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= ip.channels[ID_DI]; 
	ip.specIllumOut *= ip.channels[ID_SP]; 

}

//----------------------------------------------------------------------------------------
//- Metal2 Shader  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------

class Metal2: public StdShaderImp {
	public:
	Class_ID 		ClassID() { return MetalClassID; }
	TSTR GetName() { return GetString( IDS_KE_METAL ); }
	void Illum(ShadeContext &sc, IllumParams &ip);
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol)
		{ rcol *= ip.channels[ID_DI]; };
	float EvalHiliteCurve(float x);
    ULONG SupportStdParams(){ return STD_BASIC_METAL+STD_EXTRA; }

	BOOL IsChannelSupported( long nTex ){ return ( nTex==ID_SP ) ? FALSE : TRUE; }
	RefTargetHandle Clone( RemapDir &remap ){ Metal2* s = new Metal2(); 
											  StdShaderImp::Clone(remap, s); 
											  return s;	
											}
	ClassDesc2* GetCD();
//	Metal2();
};

class MetalShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Metal2(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_METAL); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return MetalClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Metal2"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

MetalShaderClassDesc metalCD;
ClassDesc* GetMetalShaderCD(){ return &metalCD; }
ClassDesc2* Metal2::GetCD() { return &metalCD; }
//Metal2::Metal2(){ StdShaderImp(); }


// shader parameters
static ParamBlockDesc2 metal2_param_blk ( shdr_params, _T("shaderParameters"),  0, &metalCD, P_AUTO_CONSTRUCT + P_USE_PARAMS, 
	// pblock refno
	0, 
	// use params from existing descriptor
	&const_param_blk
	);

float _CompK(float f0) { return float(2.0*sqrt(f0)/sqrt(1.0-f0)); }

float _fres_metal(float c, float k) 
{
	float b,rpl,rpp,c2;
	b = k*k + 1.0f;
	c2 = c*c;
	rpl = (b*c2-2*c+1)/(b*c2+2*c+1);
	rpp = (b-2*c+c2)/(b+2*c+c2);
	return(.5f*(rpl+rpp));
}

void Metal2::Illum(ShadeContext &sc, IllumParams &ip)
{
	LightDesc *l;
	Color lightCol;
	BOOL gotKav = FALSE;
	float kav, fav0, m2inv,NV;
	
	BOOL is_shiny;
	if (ip.channels[StdIDToChannel(ID_SS)].r != 0.0f) {		// spec lev	
		NV = -DotProd(ip.N,ip.V);  // N dot V: view vector is TOWARDS us.
		is_shiny = 1;
		float r = 1.0f-ip.channels[StdIDToChannel(ID_SH)].r;	//gloss
		if (r<=0.0f) r = .00001f;
		if (r>=1.0f) r = .99999f;//ke, 2/26/99
		m2inv = 1.0f/(r*r);  
		}
	else 
		is_shiny = 0;
	
	for (int i=0; i < sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;

		if (!l->Illuminate(sc, ip.N, lightCol, L, NL, diffCoef)) 
			continue;

		if (l->ambientOnly) {
			ip.ambIllumOut += lightCol;
			continue;
			}

		// diffuse
		if (NL>0.0f&&l->affectDiffuse)  // TBD is the NL test necessary?
			ip.diffIllumOut += diffCoef * lightCol;

		if (is_shiny&&l->affectSpecular) { // SPECULAR 
			Color fcol;
			float LH,NH,VH;
		    float sec2;  // Was double?? TBD
			Point3 H;
	
			if (NV<0.0f) continue;

			H = Normalize(L-ip.V);

			LH = DotProd(L,H);  // cos(phi)   
			NH = DotProd(ip.N,H);  // cos(alpha) 
			if (NH==0.0f) continue;
			VH = -DotProd(ip.V,H);

			// compute geometrical attenuation factor 
			float G = (NV<NL)? (2.0f*NV*NH/VH): (2.0f*NL*NH/VH);
			if (G>0.0f) {
				// Compute (approximate) indices of refraction
				//	this can be factored out for non-texture-mapped mtls
				if (!gotKav) {
					fav0 = Intens(ip.channels[ID_DI]);
					if (fav0>=1.0f) fav0 = .9999f;
					kav = _CompK(fav0);	
					gotKav = TRUE;
				}

				float fav = _fres_metal(LH,kav);
				float t = (fav-fav0)/(1.0f-fav0);
				fcol = (1.0f-t)*ip.channels[ID_DI] + Color(t,t,t);

				// Beckman distribution  (from Cook-Torrance paper)
				sec2 = 1.0f/(NH*NH);  // 1/sqr(cos) 
				float D = (.5f/PI)*sec2*sec2*m2inv*(float)exp((1.0f-sec2)*m2inv);  					
				if (G>1.0f) G = 1.0f;
				float Rs = ip.channels[StdIDToChannel(ID_SS)].r * D * G / (NV+.05f);	
				ip.specIllumOut += fcol * Rs * lightCol;
				}
			} 
		}
	ip.diffIllumOut *= LBound( 1.0f - Abs(ip.channels[StdIDToChannel(ID_SS)].r) ); //ke, 2/26/99

	// Apply mono self illumination
	BOOL clrSelfIllum = (ip.shFlags & SELFILLUM_CLR_ON) ? 1 : 0;
	if ( ! clrSelfIllum ){
		// lerp between diffuse illum & white
		// changed back, fixed in getIllumParams, KE 4/27
		float si = 0.3333333f * (ip.channels[ID_SI].r + ip.channels[ID_SI].g + ip.channels[ID_SI].b);
		if ( si > 0.0f ) {
			si = UBound( si );
			ip.selfIllumOut = si * ip.channels[ID_DI];
			ip.diffIllumOut *= (1.0f-si);
			// fade the ambient down on si: 5/27/99 ke
			ip.ambIllumOut *= 1.0f-si;
		}
	} else {
		// colored self illum, 
		ip.selfIllumOut += ip.channels[ID_SI];
	}

	// now we can multiply by the clrs, save ambient
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= ip.channels[ID_DI]; 
	ip.ambIllumOut *= ip.channels[ID_AM]; 

}


float Metal2::EvalHiliteCurve(float x) 
{
	float r = 1.0f - glossiness;
	if (r == 0.0f) r = .00001f;
	float fm2inv = 1.0f/(r*r);  

	float c = (float)cos(x*PI);
	float sec2 = 1.0f/(c*c);	  // 1/sqr(cos) 
	return specularLevel *(.5f/PI)*sec2*sec2*fm2inv*(float)exp((1.0f-sec2)*fm2inv);  					
}

//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\plate.cpp ===
/**********************************************************************
 *<
	FILE: PLATE.CPP

	DESCRIPTION: Thin Wall Glass Refraction.

	CREATED BY: Dan Silva

	HISTORY:  12/4/98 Updated to Param Block 2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include <bmmlib.h>
#include "render.h"
#include "stdmat.h"
#include "iparamm2.h"

//#define DBG        // define this to display rendered bitmap

extern HINSTANCE hInstance;

#define PLATE_CLASS_ID 0xd1f5a804

static Class_ID plateClassID(PLATE_CLASS_ID,0);

// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { plate_params, };  // pblock ID
// plate_params param IDs
enum 
{ 
	plate_blur, plate_thick, plate_reframt,
	plate_apply,
	plate_nthframe,
	plate_useenviroment,
	plate_frame

};

//---------------------------------------------------

class PlateMap {	
	public:
		Bitmap  *bm;
		IPoint2 org;
		int devW;
		int nodeID;
		TimeValue mapTime;
		PlateMap *next;
		PlateMap() { next = NULL; bm = NULL; nodeID = -1; mapTime = 0; }
		~PlateMap() { FreeMap(); }
		void FreeMap() { if (bm) bm->DeleteThis(); bm = NULL; } 
		
		int AllocMap(int w, int h);
	};

int PlateMap::AllocMap(int w, int h) {
	if ( bm && w==bm->Width() && h==bm->Height())
		return 1;
	BitmapInfo bi;
	if (bm) bm->DeleteThis();
	bi.SetName(_T(""));
	bi.SetWidth(w);
	bi.SetHeight(h);
	bi.SetType(BMM_TRUE_32);
	bi.SetCustomFlag(BMM_CUSTOM_GAMMA);
	bi.SetCustomGamma(1.0f);

	bm = TheManager->Create(&bi);

//	bm->CreateChannels(BMM_CHAN_Z); 
	return 1;
	}



//--------------------------------------------------------------
// Plate: 
//--------------------------------------------------------------

class Plate: public Texmap { 
	friend class PlatePostLoad;
	float blur;
	float thick,refrAmt;
    PlateMap *maps;
	Interval ivalid;
	int rollScroll;
	public:
		BOOL Param1;
		BOOL applyBlur;
		BOOL do_nth;
		BOOL useEnvMap;
		int nth;
		IParamBlock2 *pblock;   // ref #1
		Plate();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		// methods inherited from StdPlate:
		void SetDoNth(BOOL onoff) { do_nth = onoff;}
		void SetNth(int n){ nth = n;}
		void SetApplyBlur(BOOL onoff) { applyBlur = onoff; }
		void SetBlur(float b, TimeValue t);
		void SetThick(float v, TimeValue t);
		void SetRefrAmt(float v, TimeValue t);
		BOOL GetDoNth() { return do_nth; }
		int GetNth() { return nth;}
		BOOL GetApplyBlur() { return applyBlur;}
		float GetBlur(TimeValue t) { 
			return pblock->GetFloat(plate_blur,t); 
			}


		void NotifyChanged();
	
		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// optimized evaluation for monochrome use
		float EvalMono(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		BOOL HandleOwnViewPerturb() { return FALSE; }

		ULONG LocalRequirements(int subMtlNum) {	
			return MTLREQ_AUTOREFLECT;
			}

		int BuildMaps(TimeValue t, RenderMapsContext &rmc);
		int DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime);
		PlateMap *FindMap(int nodeNum);
		void FreeMaps();
		int RenderBegin(TimeValue t, ULONG flags) { return 1;}
		int RenderEnd(TimeValue t) { FreeMaps(); return 1; }

		Class_ID ClassID() {	return plateClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_FLATPLATE); }  
		void DeleteThis() { delete this; }	

		int NumSubs() {return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

	};

class PlateClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Plate; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_FLATPLATE_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return plateClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_ENV;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("thinWallRefraction"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static PlateClassDesc plateCD;

ClassDesc* GetPlateDesc() { return &plateCD;  }
//-----------------------------------------------------------------------------
//  Plate
//-----------------------------------------------------------------------------

static ParamBlockDesc2 plate_param_blk ( plate_params, _T("parameters"),  0, &plateCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_PLATE, IDS_DS_PLATE_PARAMS, 0, 0, NULL, 
	// params
	plate_blur,	_T("blur"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_BLUR,
		p_default,		1.0,
		p_range,		0.0, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_ACUBE_BLUR_EDIT, IDC_ACUBE_BLUR_SPIN, 0.01f,
		end,
	plate_thick,	_T("thicknessOffset"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_THICKFACT,
		p_default,		0.5,
		p_range,		0.0, 10.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_PLT_THK_EDIT, IDC_PLT_THK_SPIN, 0.01f,
		end,
	plate_reframt,	_T("bumpMapEffect"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_REFRAMT,
		p_default,		1.0,
		p_range,		0.0, 5.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_PLT_AMT_EDIT, IDC_PLT_AMT_SPIN, 0.01f,
		end,
	plate_apply,	_T("applyBlur"), TYPE_BOOL,			0,				IDS_PW_APPLYBLUR,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_ACUBE_BLUR,
		end,

	plate_nthframe,	_T("nthFrame"),   TYPE_INT,			0,	IDS_PW_NTHFRAME,
		p_default,		1,
		p_range,		1, 10000,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,  IDC_ACUBE_NTH_EDIT, IDC_ACUBE_NTH_SPIN, 1.0f,
		end,

	plate_useenviroment,	_T("useEnviroment"), TYPE_BOOL,			0,				IDS_PW_USENVIROMENT,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_USE_ENVMAP,
		end,
	plate_frame, _T("frame"), TYPE_INT,				0,				IDS_PW_FRAME,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_FIRST_ONLY, IDC_EVERY_NTH,
		end,

	end
);





#define NPARAMS 3
#define PLATE_VERSION 5

// Version 1 desc
static ParamBlockDescID pbdesc1[] = {
	{ TYPE_INT, NULL, TRUE,plate_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,plate_thick } 	// blurOff
	};

// Version 2 desc
static ParamBlockDescID pbdesc2[] = {
	{ TYPE_FLOAT, NULL, TRUE,plate_blur } 	// blur
	};

// Version 3 desc
static ParamBlockDescID pbdesc3[] = {
	{ TYPE_FLOAT, NULL, TRUE,plate_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,plate_thick }, 	// noise amount
	{ TYPE_FLOAT, NULL, TRUE,plate_thick }, 	// noise levels
	{ TYPE_FLOAT, NULL, TRUE,plate_thick }, 	// noise size
	{ TYPE_FLOAT, NULL, TRUE,plate_thick } 	// noise phase
	};

static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,plate_blur }, 	// blur
	{ TYPE_FLOAT, NULL, TRUE,plate_thick }, 	// thickness
	{ TYPE_FLOAT, NULL, TRUE,plate_reframt }, 	// refraction amount
	};

static ParamVersionDesc versions[4] = {
	ParamVersionDesc(pbdesc1,2,1),
	ParamVersionDesc(pbdesc2,1,2),
	ParamVersionDesc(pbdesc3,5,3),
	ParamVersionDesc(pbdesc,3,4)
	};

//static ParamVersionDesc curVersion(pbdesc,NPARAMS,PLATE_VERSION);

void Plate::Init() {
	ivalid.SetEmpty();
	nth = 1;
	do_nth = TRUE;
	applyBlur = TRUE;
	useEnvMap = TRUE;
	SetBlur(1.0f, TimeValue(0));
	SetThick(0.5f, TimeValue(0));
	SetRefrAmt(1.0f, TimeValue(0));
	}

void Plate::Reset() {
	plateCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

void Plate::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Plate::Plate() {
	Param1 = FALSE;
	pblock = NULL;
	maps = NULL;
	plateCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

RefTargetHandle Plate::Clone(RemapDir &remap) {
	Plate *mnew = new Plate();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->do_nth = do_nth;
	mnew->applyBlur = applyBlur;
	mnew->ivalid.SetEmpty();	
	return (RefTargetHandle)mnew;
	}

ParamDlg* Plate::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	IAutoMParamDlg* masterDlg = plateCD.CreateParamDlgs(hwMtlEdit, imp, this);
	return masterDlg;
	}

void Plate::Update(TimeValue t, Interval& valid) {		
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( plate_blur, t, blur, ivalid );
		pblock->GetValue( plate_reframt, t, refrAmt, ivalid);
		pblock->GetValue( plate_thick, t, thick, ivalid);


		pblock->GetValue( plate_apply, t, applyBlur, ivalid );

		pblock->GetValue( plate_nthframe, t, nth, ivalid);
		pblock->GetValue( plate_useenviroment, t, useEnvMap, ivalid);
		pblock->GetValue( plate_frame, t, do_nth, ivalid);


		}
	valid &= ivalid;
	}

void Plate::FreeMaps() {
	PlateMap *cm,*nxtcm;
	for (cm = maps; cm!=NULL; cm = nxtcm) {
		nxtcm = cm->next;
	   	delete cm;		
		}
	maps = NULL;
	}


void Plate::SetBlur(float f, TimeValue t) { 
	blur = f; 
	pblock->SetValue( plate_blur, t, f);
	}


void Plate::SetThick(float v, TimeValue t){
	thick = v; 
	pblock->SetValue( plate_thick, t, v);
	}

void Plate::SetRefrAmt(float v, TimeValue t) {
	refrAmt = v; 
	pblock->SetValue( plate_reframt, t, v);
	}


RefTargetHandle Plate::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		default: return NULL;
		}
	}

void Plate::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		}
	}
	 
Animatable* Plate::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}

TSTR Plate::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));
		default: return TSTR("");		
		}
	}

static int nameID[] = { IDS_DS_BLUR, IDS_DS_THICKFACT,IDS_DS_REFRAMT };

RefResult Plate::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				plate_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}


			break;
		}
	return(REF_SUCCEED);
	}


static void FlipAxis(Matrix3& tm, int k) {
	MRow* m = tm.GetAddr();
	for (int i=0; i<4; i++) m[i][k] = -m[i][k];
	}

/* build reflection matrix for plane p */
static void BuildReflMatrix(Matrix3& rm, float *p) {
	MRow* m = rm.GetAddr();
	m[0][0] = 1.0f-2.0f*p[0]*p[0];		
	m[1][1] = 1.0f-2.0f*p[1]*p[1];		
	m[2][2] = 1.0f-2.0f*p[2]*p[2];		
	m[0][1] = m[1][0] = -2.0f*p[0]*p[1];		
	m[0][2] = m[2][0] = -2.0f*p[0]*p[2];		
	m[1][2] = m[2][1] = -2.0f*p[1]*p[2];		
	m[3][0] = -2.0f*p[0]*p[3];		
	m[3][1] = -2.0f*p[1]*p[3];		
	m[3][2] = -2.0f*p[2]*p[3];		
	rm.SetNotIdent();
	}


PlateMap *Plate::FindMap(int nodeNum) {
	PlateMap *cm;
	for (cm=maps; cm!=NULL; cm = cm->next)
		if (cm->nodeID==nodeNum) return cm;
	return NULL;
	}

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

int Plate::DoThisFrame(TimeValue t, BOOL fieldRender, TimeValue mapTime) {
	if (!do_nth) return 0;  // only do it once.
	if (nth==1) return 1;   // need every one
	TimeValue del = abs(t - mapTime);
	if (fieldRender) del*=2;
	return  (del>=nth*GetTicksPerFrame())?1:0;
	}


static void TransformPlane(Matrix3& tm, Point4 plin, Point4 plout) {
	Point3 n = VectorTransform(tm, Point3(plin[0],plin[1],plin[2]));
	plout[0] = n.x;
	plout[1] = n.y;
	plout[2] = n.z;
	plout[3] = plin[3] - DotProd(tm.GetRow(3),n); 
	}

int Plate::BuildMaps(TimeValue t, RenderMapsContext &rmc) {
	SubRendParams srp;
	rmc.GetSubRendParams(srp);
  	PlateMap *pmap = FindMap(rmc.NodeRenderID());
	if (pmap&&!DoThisFrame(t,srp.fieldRender,pmap->mapTime))
		return 1;
	ViewParams vp;

	Box2 sbox;

	rmc.GetCurrentViewParams(vp);

	rmc.FindMtlScreenBox(sbox, &vp.affineTM, rmc.SubMtlIndex());

	int xmin,xmax,ymin,ymax;
	// add a margin around object for refraction
	int ew = srp.devWidth/20;
	int eh = srp.devHeight/20;
	xmax = sbox.right+ew;
	xmin = sbox.left-ew;
	ymax = sbox.bottom+eh;
	ymin = sbox.top-eh;

	if (srp.fieldRender) {
		ymin *= 2;
		ymax *= 2;
		}

	if (srp.rendType==RENDTYPE_REGION) {
		ymin = MAX(ymin,srp.ymin-eh);
		ymax = MIN(ymax,srp.ymax+eh);
		xmin = MAX(xmin,srp.xmin-ew);
		xmax = MIN(xmax,srp.xmax+ew);
		}

	srp.xmin = MAX(xmin,-ew);
	srp.xmax = MIN(xmax,srp.devWidth+ew);
	srp.ymin = MAX(ymin,-eh);
	srp.ymax = MIN(ymax,srp.devHeight+eh);
	int xorg = xmin;
	int yorg = ymin;
	int devw = srp.devWidth;
	int devh = srp.devHeight;

	// The renderer is set up to allocate A-buffer for the range
	// 0..devWidth-1,  0..devHeight-1.  If the region of the plate
	// bitmap goes out of this region, it must be extended.
	int d1 = 0, d2 = 0;
	if (srp.xmin<0) d1 = -srp.xmin;
	if (srp.xmax>=srp.devWidth) d2 = srp.xmax-srp.devWidth+1;
	int d = MAX(d1,d2);
	if (d) {
		srp.devWidth += 2*d;
		srp.xmax += d;
		srp.xmin += d;
		// must also correct fov (or zoom) so the renderer computes the
		// same xscale and yscale
		if (vp.projType==PROJ_PERSPECTIVE) {
			vp.fov = 2.0f*(float)atan((float(srp.devWidth)/float(devw))*tan(0.5*vp.fov));
			}
		else {
			vp.zoom *= (float(srp.devWidth)/float(devw));
			}
		}	

	d1 = d2 = 0;
	if (srp.ymin<0) d1 = -srp.ymin;
	if (srp.ymax>=srp.devHeight) d2 = srp.ymax-srp.devHeight+1;
	d = MAX(d1,d2);
	if (d) {
		if (srp.fieldRender)
			d = ((d+1)>>1)<<1; // make d even, so line doubling (below) works right.
		srp.devHeight += 2*d;
		srp.ymax += d;
		srp.ymin += d;
		}	


	srp.xorg = srp.xmin;
	srp.yorg = srp.ymin;

	srp.doEnvMap = useEnvMap;
	srp.doingMirror = TRUE;

	int w = srp.xmax-srp.xmin;
	int h = srp.ymax-srp.ymin;


	if (w<=0||h<=0) 
		return 1;
#ifdef DBG
	w = ((w+3)/4)*4;   // For some reason this needs to be a multiple of 4 for bm->Display
#endif

  	if (pmap==NULL) {
	  	pmap = new PlateMap;
		pmap->nodeID = rmc.NodeRenderID();
		pmap->next = maps;
		maps = pmap;
		}
	
	pmap->AllocMap(w, h);
	pmap->org.x = xorg-devw/2;
	pmap->org.y = yorg-devh/2;
	pmap->devW = devw;  // TBD: This should be accessable from the SC
	pmap->mapTime = t;

	
	// Set up clipping planes to clip out stuff between camera and pmapror.
	Box3 b = rmc.ObjectSpaceBoundingBox();
	Matrix3 tmObToWorld = rmc.ObjectToWorldTM();
	Matrix3 obToCam = tmObToWorld*vp.affineTM;	
	int nplanes=0;
	Point4 pl[6],pc;
	Point4 clip[6];

	
	pl[0] = Point4( 1.0f, 0.0f, 0.0f, -b.pmax.x);
	pl[1] = Point4(-1.0f, 0.0f, 0.0f,  b.pmin.x);
	pl[2] = Point4( 0.0f, 1.0f, 0.0f, -b.pmax.y);
	pl[3] = Point4( 0.0f,-1.0f, 0.0f,  b.pmin.y);
	pl[4] = Point4( 0.0f, 0.0f, 1.0f, -b.pmax.z);
	pl[5] = Point4( 0.0f, 0.0f,-1.0f,  b.pmin.z);
	for (int i=0; i<6; i++) {
		pc = TransformPlane(obToCam,pl[i]);	
		// see if camera = (0,0,0) is in front of plane
		if (pc.w>0.0f)  
			clip[nplanes++] = -pc;
		}
//	assert(nplanes<4);
	if (!rmc.Render(pmap->bm, vp, srp, clip, nplanes))
		return 0;

	if (srp.fieldRender) {
		// Double the lines, otherwise the blur wont work right,
		// because the blank lines in between get averaged in and darken it.
		int	evenLines = srp.evenLines; 
		if(srp.ymin&1) 
			evenLines = !evenLines;

		PixelBuf l64(w);
		if (evenLines) {
			for (int i=0; i<h; i+=2) {
				BMM_Color_64 *p64=l64.Ptr();
				if (i+1<h) {
					pmap->bm->GetPixels(0,i,  w, p64); 
					pmap->bm->PutPixels(0,i+1,w, p64);				
					}
				}
			}
		else {
			for (int i=0; i<h; i+=2) {
				BMM_Color_64 *p64=l64.Ptr();
				if (i+1<h) {
					pmap->bm->GetPixels(0,i+1,w, p64); 
					pmap->bm->PutPixels(0,i  ,w, p64);				
					}
				}
			}
		}

#ifdef DBG
	if (devw>200){
		pmap->bm->UnDisplay();
		TSTR buf;
		RenderGlobalContext *gc = rmc.GetGlobalContext();
		RenderInstance* inst = gc->GetRenderInstance(rmc.NodeRenderID());
		INode *node  = inst->GetINode();
		buf.printf(_T("Thinwall: %s"), node->GetName());
		pmap->bm->Display(buf, BMM_UR);
		MessageBox(NULL, _T("hi"), _T(" Plate Test"), MB_OK|MB_ICONEXCLAMATION);
		}
#endif

	if (applyBlur) {
		// I tried pyramids here, but SATs looked much better. 
		//  maybe we should give users a choice?
		pmap->bm->SetFilter(BMM_FILTER_SUM); 
//		pmap->bm->SetFilter(BMM_FILTER_PYRAMID); 
		BitmapFilter *filt = pmap->bm->Filter();
		if (filt)
			filt->MakeDirty();  // so filter gets recomputed for each frame
		}
	else 
		pmap->bm->SetFilter(BMM_FILTER_NONE); 
	return 1;
	}

inline float FMax(float a, float b) { return (a>b?a:b); }

static BMM_Color_64 black64 = {0,0,0,0};
static AColor black(0.0f,0.0f,0.0f,0.0f);
static RGBA blackrgba(0.0f,0.0f,0.0f,1.0f);


static Point3 RefractVector(ShadeContext &sc, Point3 N, Point3 V, float ior) { 
	float VN,nur,k1;
	VN = DotProd(-V,N);
	if (sc.backFace) nur = ior;
	else nur = (ior!=0.0f) ? 1.0f/ior: 1.0f;
	k1 = 1.0f-nur*nur*(1.0f-VN*VN);
	if (k1<=0.0f) {
		// Total internal reflection: 
		return FNormalize(2.0f*VN*N + V);
		}
	else 
		return (nur*VN-(float)sqrt(k1))*N + nur*V;
	}

//float GetZ(Bitmap *bm, int x, int y, int w, int h) {
//	ULONG ctype;
//	float *zb = (float*)bm->GetChannel(BMM_CHAN_Z, ctype); 
//	return zb[w*y+x];
//	}


RGBA Plate::EvalColor(ShadeContext& sc) {
	BMM_Color_64 c;
	IPoint2 s;
	int id = sc.NodeID();
	PlateMap *pmap = FindMap(id);
	if (gbufID) sc.SetGBufferID(gbufID);
	if (pmap) {
		s = sc.ScreenCoord();
		int w = pmap->bm->Width(); 
		int h = pmap->bm->Height();

		Point3 view = sc.OrigView();
		Point3 v2 = sc.V();
		Point3 p = sc.P();
		Point3 dv,dvf;
		Point3 N0 = sc.OrigNormal();

		Point3 vf = RefractVector(sc, N0, view, sc.GetIOR()); 
		
		RenderGlobalContext *gc = sc.globContext;
		if (gc==NULL) return blackrgba;

		// total deflection due to refraction
		dv = view-v2;

		// deflection due to flat refracton (no bumps)
		dvf = view-vf;

		dv = refrAmt*(dv-dvf) + thick*dvf;

		// compute screen deflection: This is really a cheat, and the
		// scale factor is arbitrary. Infact it depends on the distance 
		// between to the point on the glass plate and  to the point being
		// seen behind it, which we don't know.
		// these should be multiplied by the factor (Zbehind-Zcur)/Zcur
		// This assumes that the factor is .1

		float dsx,dsy;
		if (gc->projType==0) {
			// perspective
			dsx = dv.x*0.1f*gc->xscale;
			dsy = dv.y*0.1f*gc->yscale;
			}
		else {
			// parallel projection
			dsx = -dv.x*gc->xscale*10.0f;
			dsy = -dv.y*gc->yscale*10.0f;
			}
		
		int x = s.x - (pmap->org.x+gc->devWidth/2);
		int y = s.y - (pmap->org.y+gc->devHeight/2);

		if (applyBlur) {
			float du = 1.0f/float(w);
			float dv = 1.0f/float(h);

			float u = (float(x)+dsx)*du; 
			float v = (float(y)+dsy)*dv; 
			if (u<0.0f||u>1.0f||v<0.0f||v>1.0f) {
				if (useEnvMap) {
					return sc.EvalGlobalEnvironMap(view-dvf);
					}
				else 
					return blackrgba;
				}
			else 
				pmap->bm->GetFiltered(u,v, du*blur, dv*blur,&c);
			}
		else {
			int ix = x + int(dsx); 
			int iy = y + int(dsy); 
			if (ix<0||ix>=w||iy<0||iy>=h) {
				if (useEnvMap)
					return sc.EvalGlobalEnvironMap(view-dvf);
				else 
					return blackrgba;
				}
			else 
				pmap->bm->GetLinearPixels(ix,iy,1,&c);
			}
		return c;
		}
	else 
		return blackrgba;
	}

float Plate::EvalMono(ShadeContext& sc) {
	return Intens(EvalColor(sc));
	}

Point3 Plate::EvalNormalPerturb(ShadeContext& sc) {
	return Point3(0,0,0);
	}

#define MTL_HDR_CHUNK 0x4000
#define DONT_DO_NTH_CHUNK 0x1000
#define NTH_CHUNK 0x1001
#define DONT_APPLY_BLUR_CHUNK 0x1002
#define DONT_USE_ENV_CHUNK 0x1003
#define DO_NOISE_CHUNK 0x1004
#define NOISE_TYPE_CHUNK 0x1005
#define PARAM2_CHUNK 0x1006

IOResult Plate::Save(ISave *isave) { 
	IOResult res;
//	ULONG nb;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

	return IO_OK;
	}
		
class PlatePostLoad : public PostLoadCallback {
	public:
		Plate *n;
		BOOL Param1;
		PlatePostLoad(Plate *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( plate_apply, 0, n->applyBlur);
				n->pblock->SetValue( plate_nthframe, 0, n->nth);
				n->pblock->SetValue( plate_useenviroment, 0, n->useEnvMap);
				n->pblock->SetValue( plate_frame, 0, n->do_nth);


				}

			delete this; 


			} 
	};

IOResult Plate::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	Param1 = TRUE;
//	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,3, &curVersion, this,0));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case DONT_DO_NTH_CHUNK:
				do_nth = FALSE;
				break;
			case DONT_APPLY_BLUR_CHUNK:
				applyBlur = FALSE;
				break;
			case DONT_USE_ENV_CHUNK:
				useEnvMap = FALSE;
				break;
			case NTH_CHUNK:
				iload->Read(&nth,sizeof(nth),&nb);			
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 4, &plate_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new PlatePostLoad(this,Param1));

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\stdmtl2.h ===
/**********************************************************************
 *<
	FILE: stdmtl2.h

	DESCRIPTION:

	CREATED BY: Dan Silva modified for shiva by Kells Elmquist

	HISTORY: modified for shiva by Kells Elmquist
	         modified to use ParamBlock2, John Wainwright 11/16/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __STDMTL2__H
#define __STDMTL2__H

#include "shaders.h"
#include "samplers.h"
#include "iparamm2.h"
#include "texmaps.h"

// StdMtl2 flags values
#define STDMTL_ADD_TRANSP   (1<<0)
#define STDMTL_FALLOFF_OUT  (1<<1)
#define STDMTL_WIRE		  	(1<<2)
#define STDMTL_2SIDE		(1<<3)
#define STDMTL_SOFTEN       (1<<4)
#define STDMTL_FILT_TRANSP 	(1<<5)
#define STDMTL_WIRE_UNITS	(1<<6)
#define STDMTL_LOCK_AD      (1<<8)
#define STDMTL_LOCK_DS      (1<<9)
#define STDMTL_UNUSED1		(1<<10)
#define STDMTL_LOCK_ADTEX   (1<<11)
#define STDMTL_FACEMAP		(1<<12)
#define STDMTL_OLDSPEC      (1<<13)
#define STDMTL_SSAMP_ON		(1<<14)
#define STDMTL_COLOR_SI		(1<<15)
#define STDMTL_FACETED		(1<<16)

#define STDMTL_ROLLUP0_OPEN  (1<<27)	// shader
#define STDMTL_ROLLUP1_OPEN  (1<<28)	// basic
#define STDMTL_ROLLUP2_OPEN  (1<<29)	// extra
#define STDMTL_ROLLUP3_OPEN  (1<<30)	// maps
#define STDMTL_ROLLUP4_OPEN  (1<<26)	// sampling
#define STDMTL_ROLLUP5_OPEN  (1<<25)	// dynamics
#define STDMTL_ROLLUP6_OPEN  (1<<24)	// effects

// only needed if the constant shader is included in shaders
#define  CONSTClassID (STDSHADERS_CLASS_ID+1)

#define STDMTL_ROLLUP_FLAGS (STDMTL_ROLLUP0_OPEN|STDMTL_ROLLUP1_OPEN|STDMTL_ROLLUP2_OPEN|STDMTL_ROLLUP3_OPEN \
							|STDMTL_ROLLUP4_OPEN|STDMTL_ROLLUP5_OPEN|STDMTL_ROLLUP6_OPEN)

class StdMtl2Dlg;


// IDs for all the ParamBlocks and their parameters.  One block UI per rollout.
enum { std2_shader, std2_extended, std2_sampling, std_maps, std2_dynamics, };  // pblock IDs
// std2_shader param IDs
enum 
{ 
	std2_shader_type, std2_wire, std2_two_sided, std2_face_map, std2_faceted,
	std2_shader_by_name,  // virtual param for accessing shader type by name
};
// std2_extended param IDs
enum 
{ 
	std2_opacity_type, std2_opacity, std2_filter_color, std2_ep_filter_map,
	std2_falloff_type, std2_falloff_amnt, 
	std2_ior,
	std2_wire_size, std2_wire_units,
	std2_apply_refl_dimming, std2_dim_lvl, std2_refl_lvl,
};

// std2_sampling param IDs
enum 
{ 
	std2_ssampler, std2_ssampler_qual, std2_ssampler_enable, 
		std2_ssampler_adapt_on, std2_ssampler_adapt_threshold, std2_ssampler_advanced,
		std2_ssampler_subsample_tex_on, std2_ssampler_by_name, 
		std2_ssampler_param0, std2_ssampler_param1,
};
// std_maps param IDs
enum 
{
	std2_map_enables, std2_maps, std2_map_amnts, std2_mp_ad_texlock, 
};
// std2_dynamics param IDs
enum 
{
	std2_bounce, std2_static_friction, std2_sliding_friction,
};


// paramblock2 block and parameter IDs for the standard shaders
// NB these are duplicated in shaders/stdShaders.cpp...
enum { shdr_params, };
// shdr_params param IDs
enum 
{ 
	shdr_ambient, shdr_diffuse, shdr_specular,
	shdr_ad_texlock, shdr_ad_lock, shdr_ds_lock, 
	shdr_use_self_illum_color, shdr_self_illum_amnt, shdr_self_illum_color, 
	shdr_spec_lvl, shdr_glossiness, shdr_soften,
};



#define NUM_REFS		9

// refs
#define OLD_PBLOCK_REF	0		// reference number assignments
#define TEXMAPS_REF		1
#define SHADER_REF		2
#define SHADER_PB_REF	3
#define EXTENDED_PB_REF	4
#define SAMPLING_PB_REF	5
#define MAPS_PB_REF		6
#define DYNMAICS_PB_REF	7
#define SAMPLER_REF		8

// sub anims
#define NUM_SUB_ANIMS	5
//#define OLD_PARAMS_SUB		0
#define TEXMAPS_SUB			0
#define SHADER_SUB			1
#define EXTRA_PB_SUB		2
#define SAMPLING_PB_SUB		3
#define DYNAMICS_PB_SUB		4


class StdMtl2 : public StdMat2 {
	// Animatable parameters
	public:
		// current UI if open
		static ShaderParamDlg* pShaderDlg;
		static IAutoMParamDlg* masterDlg;
		static IAutoMParamDlg* texmapDlg;
		static IAutoMParamDlg* extendedDlg;
		static IAutoMParamDlg* samplingDlg;
		static HWND			   curHwmEdit;
		static IMtlParams*	   curImp;
		static Tab<ClassDesc*> shaderList;
		static Tab<ClassDesc*> samplerList;

		IParamBlock *old_pblock;    // ref 0, for old version loading
		Texmaps* maps;				// ref 1
		Interval ivalid;
		ULONG flags;
		int shaderId;
		Shader *pShader;			// ref 2
		// new PB2 paramblocks, one per rollout
		IParamBlock2 *pb_shader;	// ref 3, 4, ...
		IParamBlock2 *pb_extended;	
		IParamBlock2 *pb_sampling;	
		IParamBlock2 *pb_maps;	
		IParamBlock2 *pb_dynamics;	

		Color filter;
		float opacity;	
		float opfall;
		float wireSize;
		float ioRefract;
		float dimIntens;
		float dimMult;
		BOOL dimReflect;

		// sampling 
		int samplerId;
		Sampler* pixelSampler;	// ref 8

		// composite of shader/mtl channel types
		int channelTypes[ STD2_NMAX_TEXMAPS ];
		int stdIDToChannel[ N_ID_CHANNELS ];

		// experiment: override filter
		BOOL	filterOverrideOn;
		float	filterSz;

		void SetFlag(ULONG f, ULONG val);
		void EnableMap(int i, BOOL onoff);
		BOOL IsMapEnabled(int i) { return (*maps)[i].mapOn; }
		BOOL KeyAtTime(int id,TimeValue t) { return (id == OPACITY_PARAM) ? pb_extended->KeyFrameAtTime(std2_opacity, t) : FALSE; }
		BOOL AmtKeyAtTime(int i, TimeValue t);
		int  GetMapState( int indx ); //returns 0 = no map, 1 = disable, 2 = mapon
		TSTR  GetMapName( int indx ); 
		void SyncADTexLock( BOOL lockOn );

		// from StdMat
		// these set Approximate colors into the plug in shader
		BOOL IsSelfIllumColorOn();
		void SetSelfIllumColorOn( BOOL on );
		void SetSelfIllumColor(Color c, TimeValue t);		
		void SetAmbient(Color c, TimeValue t);		
		void SetDiffuse(Color c, TimeValue t);		
		void SetSpecular(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);		
		void SetShinStr(float v, TimeValue t);		
		void SetSelfIllum(float v, TimeValue t);	
		void SetSoften(BOOL onoff) { SetFlag(STDMTL_SOFTEN,onoff); }
		
		void SetTexmapAmt(int imap, float amt, TimeValue t);
		void LockAmbDiffTex(BOOL onoff) { SetFlag(STDMTL_LOCK_ADTEX,onoff); }

		void SetWire(BOOL onoff){ pb_shader->SetValue(std2_wire,0, (onoff!=0) ); }//SetFlag(STDMTL_WIRE,onoff); }
		void SetWireSize(float s, TimeValue t);
		void SetWireUnits(BOOL onoff) { pb_extended->SetValue(std2_wire_units,0, (onoff!=0) ); } //SetFlag(STDMTL_WIRE_UNITS,onoff); }
		
		void SetFaceMap(BOOL onoff) { pb_shader->SetValue(std2_face_map,0, (onoff!=0) ); } //SetFlag(STDMTL_FACEMAP,onoff); }
		void SetTwoSided(BOOL onoff) { pb_shader->SetValue(std2_two_sided,0, (onoff!=0) ); } //SetFlag(STDMTL_2SIDE,onoff); }
		void SetFalloffOut(BOOL outOn) { pb_extended->SetValue(std2_falloff_type,0, (outOn!=0) ); } //SetFlag(STDMTL_FALLOFF_OUT,onoff); }
		void SetTransparencyType(int type);

		void SetFilter(Color c, TimeValue t);
		void SetOpacity(float v, TimeValue t);		
		void SetOpacFalloff(float v, TimeValue t);		
		void SetIOR(float v, TimeValue t);
		void SetDimIntens(float v, TimeValue t);
		void SetDimMult(float v, TimeValue t);
		
	    int GetFlag(ULONG f) { return (flags&f)?1:0; }

		// >>>Shaders

		// these 3 internal only
		void SetShaderIndx( long shaderId, BOOL update=TRUE );
		long GetShaderIndx(){ return shaderId; }
		void SetShader( Shader* pNewShader );
		void ShuffleTexMaps( Shader* newShader, Shader* oldShader );
		void ShuffleShaderParams( Shader* newShader, Shader* oldShader );

		Shader* GetShader(){ return pShader; }
		void SwitchShader(Shader* pNewShader, BOOL loadDlg = FALSE);
		void SwitchShader(ClassDesc* pNewCD);
		BOOL SwitchShader(Class_ID shaderId);
		int FindShader( Class_ID& findId, ClassDesc** ppCD=NULL );
		BOOL IsShaderInUI() { return pb_shader && pb_shader->GetMap() && pShader && pShader->GetParamDlg(); }

		static void StdMtl2::LoadShaderList();
		static int StdMtl2::NumShaders();
		static ClassDesc* StdMtl2::GetShaderCD(int i);
		static void StdMtl2::LoadSamplerList();
		static int StdMtl2::NumSamplers();
		static ClassDesc* StdMtl2::GetSamplerCD(int i);

		BOOL IsFaceted(){ return GetFlag(STDMTL_FACETED); }
		void SetFaceted( BOOL on ){	pb_shader->SetValue(std2_faceted,0, (on!=0) ); }

		// These utilitys provide R2.5 shaders, ONLY used for Translators
		// Does not & will not work for plug-in shaders
		void SetShading(int s);
		int GetShading();

		// from Mtl
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);		
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);		
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);	
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE) ;
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE) { if(opacity>0.9f && opfall>0.0f) return 0.1f; return 1.0f-opacity; }
		float WireSize(int mtlNum=0, BOOL backFace=FALSE) { return wireSize; }

		// >>>> Self Illumination 
		float GetSelfIllum(int mtlNum, BOOL backFace) ;
		BOOL  GetSelfIllumColorOn(int mtlNum, BOOL backFace);
		Color GetSelfIllumColor(int mtlNum, BOOL backFace);
		
		// >>>> sampling
		void SetSamplingOn( BOOL on )
		{	
			pb_sampling->SetValue(std2_ssampler_enable, 0, on!=0 );
		}	
		BOOL GetSamplingOn()
		{	Interval iv; 
			BOOL on;
			pb_sampling->GetValue(std2_ssampler_enable, 0, on, iv );
			return on;
		}	
		void SetSamplingQuality( float quality )
		{	 
			pb_sampling->SetValue(std2_ssampler_qual, 0, quality );
		}	
		float GetSamplingQuality()
		{	Interval iv; 
			float q;
			pb_sampling->GetValue(std2_ssampler_qual, 0, q, iv );
			return q;
		}

		void SwitchSampler(ClassDesc* pNewCD);
		void SwitchSampler(Sampler* pNewSampler);
		BOOL SwitchSampler(Class_ID samplerId);
		int FindSampler( Class_ID findId, ClassDesc** pNewCD=NULL );
		Sampler * GetPixelSampler(int mtlNum=0, BOOL backFace=FALSE){  return pixelSampler; }	

		// these 2 internal only
		void SetSamplerIndx( long indx, BOOL update=TRUE );
		long  GetSamplerIndx(){ return samplerId; }
		void SetPixelSampler( Sampler * sampler );

		// Dynamics properties
		float GetDynamicsProperty(TimeValue t, int mtlNum, int propID);
		void SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value);

		// from StdMat
		BOOL GetSoften() { return GetFlag(STDMTL_SOFTEN); }
		BOOL GetFaceMap() { return GetFlag(STDMTL_FACEMAP); }
		BOOL GetTwoSided() { return GetFlag(STDMTL_2SIDE); }
		BOOL GetWire() { return GetFlag(STDMTL_WIRE); }
		BOOL GetWireUnits() { return GetFlag(STDMTL_WIRE_UNITS); }
		BOOL GetFalloffOut() { return GetFlag(STDMTL_FALLOFF_OUT); }  // 1: out, 0: in
		BOOL GetAmbDiffTexLock(){ return GetFlag(STDMTL_LOCK_ADTEX); } 
		int GetTransparencyType() {
			return (flags&STDMTL_FILT_TRANSP)?TRANSP_FILTER:
				flags&STDMTL_ADD_TRANSP ? TRANSP_ADDITIVE: TRANSP_SUBTRACTIVE;
			}
		Color GetFilter(TimeValue t);

		// these are stubs till i figure out scripting
		Color GetAmbient(TimeValue t);		
		Color GetDiffuse(TimeValue t);		
		Color GetSpecular(TimeValue t);
		float GetShininess( TimeValue t);		
		float GetShinStr(TimeValue t);	
		float GetSelfIllum(TimeValue t);
		BOOL  GetSelfIllumColorOn();
		Color GetSelfIllumColor(TimeValue t); 

		float GetOpacity( TimeValue t);		
		float GetOpacFalloff(TimeValue t);		
		float GetWireSize(TimeValue t);
		float GetIOR( TimeValue t);
		float GetDimIntens( TimeValue t);
		float GetDimMult( TimeValue t);
		float GetSoftenLevel( TimeValue t);
		BOOL MapEnabled(int i);
		float GetTexmapAmt(int imap, TimeValue t);

		// internal
		float GetOpacity() { return opacity; }		
		float GetOpacFalloff() { return opfall; }		
		float GetTexmapAmt(int imap);
		Color GetFilter();
		float GetIOR() { return ioRefract; }

		StdMtl2(BOOL loading = FALSE);
		BOOL ParamWndProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		BOOL SetDlgThing(ParamDlg* dlg);
		void UpdateTexmaps();
		void UpdateMapButtons();
		void UpdateExtendedMapButtons();
		void UpdateMtlDisplay();
		void UpdateLockADTex( BOOL passOn );
		void UpdateExtraParams( ULONG stdParams );
		void UpdateSamplingParams();


		Color TranspColor(ShadeContext& sc, float opac, Color& diff);
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& validr);
		void Reset();
		void OldVerFix(int loadVer);
		void BumpFix();
		Interval Validity(TimeValue t);
		void NotifyChanged();

		// Requirements
		ULONG Requirements(int subMtlNum);
		void MappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return STD2_NMAX_TEXMAPS; }
		Texmap* GetSubTexmap(int i) { return (*maps)[i].map; }
		int MapSlotType(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		int SubTexmapOn(int i) { return  MAPACTIVE(i); } 
		long StdIDToChannel( long id ){ return stdIDToChannel[id]; }

		Class_ID ClassID();
		SClass_ID SuperClassID() { return MATERIAL_CLASS_ID; }
		void GetClassName(TSTR& s) { s = GetString(IDS_KE_STANDARD2); }  

		void DeleteThis();

		int NumSubs() { return NUM_SUB_ANIMS; }  
	    Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum);

		// JBW: add direct ParamBlock access
		int	NumParamBlocks() { return 5; }
		IParamBlock2* GetParamBlock(int i);
		IParamBlock2* GetParamBlockByID(BlockID id);

		// From ref
 		int NumRefs() { return NUM_REFS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

	};

Mtl* CreateStdMtl2();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\stdmtl.h ===
/**********************************************************************
 *<
	FILE: stdmtl.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __STDMTL__H
#define __STDMTL__H

#include "stdmat.h"
#include "texmaps.h"

// StdMtl flags values
#define STDMTL_ADD_TRANSP   (1<<0)
#define STDMTL_FALLOFF_OUT  (1<<1)
#define STDMTL_WIRE		  	(1<<2)
#define STDMTL_2SIDE		(1<<3)
#define STDMTL_SOFTEN       (1<<4)
#define STDMTL_FILT_TRANSP 	(1<<5)
#define STDMTL_WIRE_UNITS	(1<<6)
#define STDMTL_LOCK_AD      (1<<8)
#define STDMTL_LOCK_DS      (1<<9)
#define STDMTL_UNUSED1		(1<<10)
#define STDMTL_LOCK_ADTEX   (1<<11)
#define STDMTL_FACEMAP		(1<<12)
#define STDMTL_OLDSPEC      (1<<13)
#define STDMTL_SSAMP		(1<<14)

#define STDMTL_ROLLUP1_OPEN  (1<<28)
#define STDMTL_ROLLUP2_OPEN  (1<<29)
#define STDMTL_ROLLUP3_OPEN  (1<<30)
#define STDMTL_ROLLUP4_OPEN  (1<<27)

#define STDMTL_ROLLUP_FLAGS (STDMTL_ROLLUP1_OPEN|STDMTL_ROLLUP2_OPEN|STDMTL_ROLLUP3_OPEN|STDMTL_ROLLUP4_OPEN)


class StdMtlDlg;
class Sampler;
struct SIllumParams;

class SShader {
	public:
	virtual void Illum(ShadeContext &sc, SIllumParams &ip)=0;
	virtual void AffectReflMap(ShadeContext &sc, SIllumParams &ip, Color &rcol)=0;
	virtual void SetShininess(float shininess, float shineStr)=0;
	virtual float EvalHilite(float x)=0;
	};

class StdMtl: public StdMat {
	// Animatable parameters
	public:
		IParamBlock *pblock;   // ref 0
		Texmaps* maps;         // ref 1
		Interval ivalid;
		StdMtlDlg *paramDlg;
		ULONG flags;
		int rollScroll;
		int shading;
		SShader *curShader;

		// Cache values: must call Update() when change frame.
		Color ambient;
		Color diffuse;
		Color specular;
		Color filter;
		float shininess;  
		float shine_str;  
		float self_illum;	
		float opacity;	
		float opfall;
		float phongexp;
		float wireSize;
		float ioRefract;
		float dimIntens;
		float dimMult;
		float softThresh;
		BOOL dimReflect;

		void SetFlag(ULONG f, ULONG val);
		void EnableMap(int i, BOOL onoff);
		BOOL IsMapEnabled(int i) { return (*maps)[i].mapOn; }
		BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }
		BOOL AmtKeyAtTime(int i, TimeValue t);
		void SetShadingNoNotify( int s);

		// from StdMat
		void SetAmbient(Color c, TimeValue t);		
		void SetDiffuse(Color c, TimeValue t);		
		void SetSpecular(Color c, TimeValue t);
		void SetFilter(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);		
		void SetShinStr(float v, TimeValue t);		
		void SetSelfIllum(float v, TimeValue t);		
		void SetTexmapAmt(int imap, float amt, TimeValue t);
		void SetWireSize(float s, TimeValue t);
		void SetSelfIllumColor(class Color,int){}
		void SetSelfIllumColorOn(BOOL){}
		int IsSelfIllumColorOn(){ return FALSE; }
		// >>>> sampling
		void SetSamplingOn( BOOL on ){}	
		BOOL GetSamplingOn(){ return FALSE; }	
		void SetSamplingQuality( float quality ) { }	
		float GetSamplingQuality(){ return 1.0f; }	
		void SetPixelSampler( Sampler * sampler ){}	
		Sampler * GetPixelSampler(int mtlId, BOOL backFace){ return NULL; }	

		// >>>Shaders
		void SetShaderId( long shaderId );
		long GetShaderId();
		void SetShader( Shader* pShader ){}
		Shader* GetShader(){ return NULL; }
		
	 	void SetShading(int s){ SetShaderId(s); }
		void SetSoften(BOOL onoff) { SetFlag(STDMTL_SOFTEN,onoff); }
		void SetFaceMap(BOOL onoff) { SetFlag(STDMTL_FACEMAP,onoff); }
		void SetTwoSided(BOOL onoff) { SetFlag(STDMTL_2SIDE,onoff); }
		void SetWire(BOOL onoff){ SetFlag(STDMTL_WIRE,onoff); }
		void SetWireUnits(BOOL onoff) { SetFlag(STDMTL_WIRE_UNITS,onoff); }
		void SetFalloffOut(BOOL onoff) { SetFlag(STDMTL_FALLOFF_OUT,onoff); }
		void SetTransparencyType(int type);
		void LockAmbDiffTex(BOOL onoff) { SetFlag(STDMTL_LOCK_ADTEX,onoff); }
		void SetOpacity(float v, TimeValue t);		
		void SetOpacFalloff(float v, TimeValue t);		
		void SetIOR(float v, TimeValue t);
		void SetDimIntens(float v, TimeValue t);
		void SetDimMult(float v, TimeValue t);
		void SetSoftenLevel(float v, TimeValue t);
		
	    int GetFlag(ULONG f) { return (flags&f)?1:0; }


		// from Mtl
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);		
	    Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);		
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE) { return shininess; }		
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE) { return shine_str;  }
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE) { if(opacity>0.9f && opfall>0.0f) return 0.1f; return 1.0f-opacity; }
		float WireSize(int mtlNum=0, BOOL backFace=FALSE) { return wireSize; }
		float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE) { return self_illum; }
		
		// Dynamics properties
		float GetDynamicsProperty(TimeValue t, int mtlNum, int propID);
		void SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value);

		// from StdMat
		int GetShading(){ return GetShaderId(); }
		BOOL GetSoften() { return GetFlag(STDMTL_SOFTEN); }
		BOOL GetFaceMap() { return GetFlag(STDMTL_FACEMAP); }
		BOOL GetTwoSided() { return GetFlag(STDMTL_2SIDE); }
		BOOL GetWire() { return GetFlag(STDMTL_WIRE); }
		BOOL GetWireUnits() { return GetFlag(STDMTL_WIRE_UNITS); }
		BOOL GetFalloffOut() { return GetFlag(STDMTL_FALLOFF_OUT); }  // 1: out, 0: in
		BOOL GetAmbDiffTexLock(){ return GetFlag(STDMTL_LOCK_ADTEX); } 
		int GetTransparencyType() {
			return (flags&STDMTL_FILT_TRANSP)?TRANSP_FILTER:
				flags&STDMTL_ADD_TRANSP ? TRANSP_ADDITIVE: TRANSP_SUBTRACTIVE;
			}
		Color GetAmbient(TimeValue t);		
		Color GetDiffuse(TimeValue t);		
		Color GetSpecular(TimeValue t);
		Color GetFilter(TimeValue t);
		float GetShininess( TimeValue t);		
		float GetShinStr(TimeValue t);		
		float GetSelfIllum(TimeValue t);		
		float GetOpacity( TimeValue t);		
		float GetOpacFalloff(TimeValue t);		
		float GetWireSize(TimeValue t);
		float GetIOR( TimeValue t);
		float GetDimIntens( TimeValue t);
		float GetDimMult( TimeValue t);
		float GetSoftenLevel( TimeValue t);
		BOOL MapEnabled(int i);
		float GetTexmapAmt(int imap, TimeValue t);

		// internal
		float GetSelfIll() { return self_illum; }		
		float GetOpacity() { return opacity; }		
		float GetOpacFalloff() { return opfall; }		
		float GetTexmapAmt(int imap);
		Color GetFilter();
		float GetIOR() { return ioRefract; }
		StdMtl(BOOL loading = FALSE);
		void SetParamDlg( StdMtlDlg *pd) {	paramDlg = pd; }
		BOOL ParamWndProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		Color TranspColor(ShadeContext& sc, float opac, Color& diff);
		void Shade(ShadeContext& sc);
		float EvalDisplacement(ShadeContext& sc); 
		Interval DisplacementValidity(TimeValue t); 
		void Update(TimeValue t, Interval& validr);
		void Reset();
		void OldVerFix(int loadVer);
		Interval Validity(TimeValue t);
		void NotifyChanged();
		void UpdateShader();


		// Requirements
		ULONG Requirements(int subMtlNum);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NTEXMAPS; }
		Texmap* GetSubTexmap(int i) { return (*maps)[i].map; }
		int MapSlotType(int i) { 
			if (i==ID_DP) return MAPSLOT_DISPLACEMENT;
			return (i==ID_RL||i==ID_RR)?MAPSLOT_ENVIRON:MAPSLOT_TEXTURE; 
			}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		int SubTexmapOn(int i) { return  MAPACTIVE(i); } 

		Class_ID ClassID();
		SClass_ID SuperClassID() { return MATERIAL_CLASS_ID; }
		void GetClassName(TSTR& s) { s = GetString(IDS_DS_STANDARD); }  

		void DeleteThis();

		int NumSubs() { return 2; }  
	    Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;	}

		// From ref
 		int NumRefs() { return 2; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

	};

Mtl* CreateStdMtl();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\stdmtl.cpp ===
/**********************************************************************
 *<
	FILE: stdmtl.cpp

	DESCRIPTION:  default material class

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#include "buildver.h"
#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmtl.h"
#include "gport.h"
#include "hsv.h"
static Shader *GetShader(int s);

#define HITHRESH 0.5f
#define LOTHRESH 0.1f


#if 1
// Quadratic
static inline float Soften(float r) {
	return r*(2.0f-r);
	}
#else
// Cubic
static inline float Soften(float r) {
	return r*r*(3.0f-2.0f*r);
	}
#endif

struct SIllumParams {
	ULONG flags;
	float sh_str, ph_exp, shine, softThresh;
	Color amb,diff,spec;
	Point3 N,V;
	Color diffIllum,specIllum,ambIllum;
	};

// Parameter block indices
#define PB_AMBIENT		0
#define PB_DIFFUSE		1
#define PB_SPECULAR		2
#define PB_SHININESS 	3
#define PB_SHIN_STR		4
#define PB_SELFI		5
#define PB_OPAC			6
#define PB_OPFALL		7
#define PB_FILTER 		8
#define PB_WIRESZ 		9
#define PB_IOR	 		10
#define PB_BOUNCE 		11
#define PB_STATFRIC		12
#define PB_SLIDFRIC		13
#define PB_DIMLEV		14
#define PB_DIMMULT		15
#define PB_SOFTEN		16

//#define OLDFILTER    // scaling instead of additive

#define IDT_MYTIMER 1010
#define DRAGTHRESH 6
#define DITHER_WHEN_INACTIVE // avoids palette conflict probs
#define BUMP_DEF_AMT .30f

#define NCOLBOX 4
static int colID[NCOLBOX] = { IDC_STD_COLOR1, IDC_STD_COLOR2, IDC_STD_COLOR3, IDC_STD_COLOR4 };

// >>>> must become dynamic shader table
extern HINSTANCE hInstance;
static int shadeNameID[] = { IDS_DS_CONSTANT, IDS_DS_PHONG, IDS_DS_BLINN, IDS_DS_METAL };

static IPoint2 GetPoint(LPARAM lp) {
	IPoint2 p;
	MAKEPOINT(lp,p);
	return p;
	}
#define SET_HSV 1
#define SET_RGB 2
#define SET_BOTH (SET_HSV|SET_RGB)

#ifdef USE_STDMTL2_AS_STDMTL
static Class_ID stdmtlClassID(DMTL2_CLASS_ID,0);
#else
static Class_ID stdmtlClassID(DMTL_CLASS_ID,0);
#endif

int numStdMtls = 0;
class StdMtlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new StdMtl(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_DS_STANDARD_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return MATERIAL_CLASS_ID; }
	Class_ID 		ClassID() { return stdmtlClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};

static StdMtlClassDesc stdmtlCD;

ClassDesc* GetStdMtlDesc() { return &stdmtlCD;  }

static HIMAGELIST hLockButtons = NULL;

static BOOL IsButtonChecked(HWND hWnd,int id)
	{
	ICustButton *iBut;
	BOOL res;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	res = iBut->IsChecked();
	ReleaseICustButton(iBut);
	return res;
	}

static void CheckButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetCheck(check);
	ReleaseICustButton(iBut);
	}

static void SetupLockButton(HWND hWnd,int id, BOOL check)
	{
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,0,1,0,1,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}

static void SetupPadLockButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,2,2,2,2,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}

static void LoadStdMtlResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;

	HINSTANCE hInst = hInstance;
	hLockButtons = ImageList_Create(16, 15, TRUE, 2, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_BUTTONS));
	hMask   = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_MASKBUTTONS));
	ImageList_Add(hLockButtons,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	}


static inline float PcToFrac(int pc) {
	return (float)pc/100.0f;	
	}

static inline int FracToPc(float f) {
	if (f<0.0) return (int)(100.0f*f - .5f);
	else return (int) (100.0f*f + .5f);
	}


static LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );

#define NMBUTS 8
static int texMButtons[NMBUTS] = {
	IDC_MAPON_AM,	IDC_MAPON_DI,	IDC_MAPON_SP,	IDC_MAPON_FI,
	IDC_MAPON_SH,	IDC_MAPON_SS,	IDC_MAPON_SI,	IDC_MAPON_TR, 
	};
		
// This array gives the text map number for given MButton number								
static int texmapFromMBut[NMBUTS] = { 0, 1, 2, 7, 3, 4, 5, 6 };

// This array gives the MButton number for given Texmap number								
static int mButFromTexmap[NTEXMAPS] = { 0, 1, 2, 4, 5, 6, 7, 3, -1, -1, -1, -1 };

// >>>> these maps either need to be dynamic or allocated w/ a hard maximum.

static int texAmtID[NTEXMAPS] = {
	IDC_AMT_AM,	IDC_AMT_DI,	IDC_AMT_SP,	IDC_AMT_SH, IDC_AMT_SS,
	IDC_AMT_SI,	IDC_AMT_OP, IDC_AMT_FI,	IDC_AMT_BU,	IDC_AMT_RL,	IDC_AMT_RR, IDC_AMT_DP
	};	

static int texOnID[NTEXMAPS] = 	{
	IDC_USEMAP_AM, IDC_USEMAP_DI, IDC_USEMAP_SP, IDC_USEMAP_SH, IDC_USEMAP_SS,
	IDC_USEMAP_SI, IDC_USEMAP_OP, IDC_USEMAP_FI, IDC_USEMAP_BU, IDC_USEMAP_RL, IDC_USEMAP_RR, IDC_USEMAP_DP
	};	

static int texSpinID[NTEXMAPS] = {
	IDC_SPIN_AM, IDC_SPIN_DI, IDC_SPIN_SP,	IDC_SPIN_SH, IDC_SPIN_SS,
	IDC_SPIN_SI, IDC_SPIN_OP, IDC_SPIN_FI, IDC_SPIN_BU,	IDC_SPIN_RL, IDC_SPIN_RR, IDC_SPIN_DP
	};	

static int texMapID[NTEXMAPS] =  {
	IDC_MAP_AM, IDC_MAP_DI, IDC_MAP_SP,	IDC_MAP_SH, IDC_MAP_SS,
	IDC_MAP_SI, IDC_MAP_OP, IDC_MAP_FI, IDC_MAP_BU,	IDC_MAP_RL, IDC_MAP_RR, IDC_MAP_DP
	};	

static int texNameID[NTEXMAPS] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, IDS_DS_SHININESS, IDS_DS_SHIN_STR,
	IDS_DS_SELFI,	IDS_DS_TRANS, IDS_DS_FILTER, IDS_DS_BU, IDS_DS_RL, IDS_DS_RR, IDS_DS_DP
	};	

// which edit control enum
enum EditControl {Hc, Sc, Vc, Rc, Gc, Bc};


//-----------------------------------------------------------------------------
//  Texmaps
//-----------------------------------------------------------------------------
/*******
//#define TEXMAPS_CLASS_ID 0x001200

//#ifdef USE_STDMTL2_AS_STDMTL
//#define TEXMAPS_CLASS_ID 0x001200+33
//#else
#define TEXMAPS_CLASS_ID 0x001200
//#endif

static Class_ID texmapsClassID(TEXMAPS_CLASS_ID,0);

class OldTexmapsClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { 	return new Texmaps(NULL); }
	const TCHAR *	ClassName() { return GetString(IDS_DS_CLASSTEXMAPS); }
	SClass_ID		SuperClassID() { return REF_MAKER_CLASS_ID; }
	Class_ID 		ClassID() { return texmapsClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};


class TexmapsClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { 	return new Texmaps(NULL); }
	const TCHAR *	ClassName() { return GetString(IDS_DS_CLASSTEXMAPS); }
//	SClass_ID		SuperClassID() { return REF_MAKER_CLASS_ID; }
	SClass_ID		SuperClassID() { return TEXMAP_CONTAINER_CLASS_ID; }
	Class_ID 		ClassID() { return texmapsClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};

TexmapSlot::TexmapSlot() { 
	amount = 1.0f; 
	map = NULL; 
	mapOn = FALSE; 
	amtCtrl=NULL; 
	}

void TexmapSlot::Update(TimeValue t,Interval& ivalid) {
	if (IsActive()) 
		map->Update(t,ivalid);			
	if (amtCtrl) {
		amtCtrl->GetValue(t,&amount,ivalid);	
		}
	}

float TexmapSlot::GetAmount(TimeValue t) {
	Interval v;
	float f;
	if (amtCtrl) {
		amtCtrl->GetValue(t,&f,v);	
		return f;
		}
	else return amount;
	} 

Texmaps::Texmaps() {
	loadingOld = FALSE;
	client = NULL;
	}

					
Texmaps::Texmaps(MtlBase *mb) {
	loadingOld = FALSE;
	client = mb;
	}


static TexmapsClassDesc texmapsCD;

ClassDesc* GetTexmapsDesc() { return &texmapsCD;  }

static OldTexmapsClassDesc oldtexmapsCD;

ClassDesc* GetOldTexmapsDesc() { return &oldtexmapsCD;  }

Class_ID Texmaps::ClassID() { return texmapsClassID; }

int Texmaps::NumSubs() { return NTEXMAPS*2; }  

Animatable* Texmaps::SubAnim(int i) {
	if (i&1)
		return txmap[i/2].map;
	else 
		return txmap[i/2].amtCtrl;
	}

TSTR Texmaps::SubAnimName(int i) {
	if (i&1)
		return client->GetSubTexmapTVName(i/2);
	else  {
		TSTR nm;
		nm = GetString(texNameID[i/2]);
		nm += TSTR(GetString(IDS_DS_AMOUNT));
		return nm;
		}
	}

RefTargetHandle Texmaps::GetReference(int i) {
	if (i&1)
		return txmap[i/2].map;
	else 
		return txmap[i/2].amtCtrl;
	}

void Texmaps::SetReference(int i, RefTargetHandle rtarg) {
	if (loadingOld)
		txmap[i].map = (Texmap*)rtarg;
	else {
		if (i&1)
			txmap[i/2].map = (Texmap*)rtarg;
		else 
			txmap[i/2].amtCtrl = (Control*)rtarg;
		}
	}

void Texmaps::DeleteThis() { delete this;}

RefResult Texmaps::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = defaultDim; 
			break;
			}
		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

void Texmaps::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	// This code will be replaced in particular implementations
	for (int i=0; i<NumRefs(); i++) {
		if ( (i&1) ==0) 
			continue;  // skip the amount controllers
		ReferenceMaker *srm = GetReference(i);
		if (srm) {
			srm->RescaleWorldUnits(f);
			}
		}
		
	}

RefTargetHandle Texmaps::Clone(RemapDir &remap) {
	Texmaps *tm = new Texmaps(NULL);
	for (int i = 0; i<NTEXMAPS; i++) {
		tm->txmap[i].amount = txmap[i].amount;
		tm->txmap[i].mapOn = txmap[i].mapOn;
		tm->txmap[i].map = NULL;
		if (txmap[i].amtCtrl) 
			tm->ReplaceReference(2*i,remap.CloneRef(txmap[i].amtCtrl));
		if (txmap[i].map) 
			tm->ReplaceReference(2*i+1,remap.CloneRef(txmap[i].map));
		}
	return tm;
	}

#define TEX_OLD_ONOFF_CHUNK 0x5002
#define TEX_ONOFF_CHUNK 0x5003
#define TEX_AMT0 0x5100
#define TEX_AMT1 0x5101
#define TEX_AMT2 0x5102
#define TEX_AMT3 0x5103
#define TEX_AMT4 0x5104
#define TEX_AMT5 0x5105
#define TEX_AMT6 0x5106
#define TEX_AMT7 0x5107
#define TEX_AMT8 0x5108
#define TEX_AMT9 0x5109
#define TEX_AMTA 0x510A

IOResult Texmaps::Save(ISave *isave) { 
	isave->BeginChunk(TEX_ONOFF_CHUNK);
	ULONG nb,f=0;
	for ( int i=0; i<NTEXMAPS; i++) 
		if (txmap[i].mapOn) f|= (1<<i);
	isave->Write(&f,sizeof(f),&nb);			
	isave->EndChunk();

	for ( i=0; i<NTEXMAPS; i++) {
		if (txmap[i].amount!=1.0f) {
			isave->BeginChunk(TEX_AMT0+i);
			isave->Write(&txmap[i].amount,sizeof(float),&nb);			
			isave->EndChunk();
			}
		}
	return IO_OK;
	}

class TexmapsPostLoad : public PostLoadCallback {
	public:
		Texmaps *tm;
		TexmapsPostLoad(Texmaps *b) {tm=b;}
		void proc(ILoad *iload) {  tm->loadingOld = FALSE; delete this; } 
	};

	
IOResult Texmaps::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case TEX_OLD_ONOFF_CHUNK:
				iload->SetObsolete();
				iload->RegisterPostLoadCallback(new TexmapsPostLoad(this));
				loadingOld = TRUE;
			case TEX_ONOFF_CHUNK:
				{
				ULONG f;
				res = iload->Read(&f,sizeof(f), &nb);
				for (int i=0; i<NTEXMAPS; i++) 
				    txmap[i].mapOn = (f&(1<<i))?1:0;
				}
				break;
			case TEX_AMT0: case TEX_AMT1:
			case TEX_AMT2:	case TEX_AMT3:
			case TEX_AMT4:	case TEX_AMT5:
			case TEX_AMT6:	case TEX_AMT7:
			case TEX_AMT8:	case TEX_AMT9:
			case TEX_AMTA:
				res = iload->Read(&txmap[id-TEX_AMT0].amount,sizeof(float), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
                                                      
	}
//-----------------------------------------------------------------------------
**************/
//-----------------------------------------------------------------------------
//class StdMtlDlg;


//-----------------------------------------------------------------------------
//  StdMtlDlg
//-----------------------------------------------------------------------------
class StdMtlDlg: public ParamDlg {
	public:
	HWND hwmedit;	 // window handle of the materials editor dialog
	IMtlParams *ip;
	StdMtl *theMtl;	 // current mtl being edited.
	HWND hPanelBasic; // Rollup panel
	HWND hPanelExtra; // Rollup panel
	HWND hPanelTexmap; // Rollup panel
	HWND hPanelDynam; // Rollup panel
	HWND hwHilite;  // the hilite window
	HPALETTE hOldPal;
	TimeValue curTime;
	int instCopy;
	int iStart;
	Rect texRect;
	int isActive;
	IPoint2 pDown,pDrag;
	IPoint2 pLast;
	BOOL dragging,dragAbort;
	Rect colBox[NCOLBOX];
	IColorSwatch *cs[NCOLBOX];
	BOOL animPalOn;
	BOOL valid;
	int editingColor; //0= amb,1= diff,2= spec, 3 = filterCol
	DWORD curRGB;
	int H,S,V;
	ISpinnerControl *hSpin,*sSpin,*vSpin;
	ISpinnerControl *rSpin,*gSpin,*bSpin;
	ISpinnerControl *softSpin;
	ISpinnerControl *shSpin, *ssSpin, *siSpin, *trSpin, *tfSpin, *wireSizeSpin, *iorSpin;
	ISpinnerControl *dimSpin, *dimMultSpin;
	ISpinnerControl* texAmtSpin[NTEXMAPS];
	ISpinnerControl *iBounce, *iStatFrict, *iSlidFrict;
	ICustButton* texMBut[NMBUTS];
	ICustButton *iBut[NTEXMAPS];
	TexDADMgr dadMgr;

	StdMtlDlg(HWND hwMtlEdit, IMtlParams *imp, StdMtl *m); 
	~StdMtlDlg();
	void BuildDialog();  // put up the dialog
	void Invalidate();
	BOOL BasicPanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	BOOL ExtraPanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	BOOL TexmapPanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	BOOL DynamPanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	void ActivateDlg(BOOL onOff);
	void LoadDialog(BOOL draw);  // stuff params into dialog
	void SetEditColor(int i);    //0=amb, 1=diff, 2=spec, 3=filterColor
	void SetRGB(DWORD rgb);
	void UpdateColFromSpin(HWND hwndDlg,int indx, ISpinnerControl *spin );
	void UpdateColControls( int  which);
	void UpdateColSwatches();
	void AnimPalette(HDC hdc);
	Color MtlColor(int i);
	TCHAR *ColorName(int i);
	void SetMtlColor(int i, Color c);
	void UpdateMBut(int i);
	void ReloadDialog();
	void EnablePhongStuff();
	void DrawHilite(HDC hdc, Rect& rect);
	void GenDrawHilite(HDC hdc, Rect& rect, SShader &sh);
	void UpdateHilite(); 
	void SetLockAD(BOOL lock);
	void UpdateLockADTex();
	void SetLockDS(BOOL lock);
 	void SetLockADTex(BOOL lock);
	void UpdateMtlDisplay();
	void UpdateTexmapDisplay(int i);
	void UpdateTexmaps();
	void FixFilterButtons();
	void UpdateControlFor(int np);
	void UpdateColorStuff();
	BOOL KeyAtCurTime(int id) { return theMtl->KeyAtTime(id,curTime); } 
	// methods inherited from ParamDLg:
	Class_ID ClassID() {return stdmtlClassID;  }
	void SetThing(ReferenceTarget *m);
	ReferenceTarget* GetThing() { return (ReferenceTarget*)theMtl; }
	void DeleteThis() { delete this;  }	
	void SetTime(TimeValue t);
	int FindSubTexFromHWND(HWND hw);
	};

static int PB_ID[4] = { PB_AMBIENT, PB_DIFFUSE, PB_SPECULAR, PB_FILTER };

int StdMtlDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NTEXMAPS; i++) {
		if (hw == iBut[i]->GetHwnd()) 
			return i;
		}	
	for (i=0; i<NMBUTS; i++) {
		if (hw == texMBut[i]->GetHwnd()) 
			return texmapFromMBut[i];
		}	
	return -1;
	}


//-------------------------------------------------------------------


StdMtlDlg::StdMtlDlg(HWND hwMtlEdit, IMtlParams *imp, StdMtl *m) {
	dadMgr.Init(this);
	hwmedit = hwMtlEdit;
	hPanelBasic = hPanelExtra = hPanelTexmap = hPanelDynam = NULL;
	hOldPal = NULL;
	theMtl = m; 
	ip = imp;
	valid = FALSE;
	editingColor = 1; // default to diffuse
	animPalOn = 1;
	isActive = 0;
	instCopy = FALSE;
	for (int i=0; i<NTEXMAPS; i++) iBut[i] = NULL;
	}

	

void StdMtlDlg::Invalidate()
	{
	valid = FALSE;
	InvalidateRect(hPanelBasic,NULL,0);
	InvalidateRect(hPanelExtra,NULL,0);
	InvalidateRect(hPanelTexmap,NULL,0);
#ifndef DESIGN_VER
	InvalidateRect(hPanelDynam,NULL,0);
#endif
	}

void StdMtlDlg::AnimPalette(HDC hdc) {
#if 0
	if (animPalOn) {
		GetGPort()->PlugPalette(hdc);
		GetGPort()->AnimPalette(hdc);
		}
#endif
	}		  

static TCHAR blnk[] = _T(" ");
static TCHAR lcm[] = _T("m");
static TCHAR ucm[] = _T("M");

void StdMtlDlg::UpdateMBut(int j) {
	int i = mButFromTexmap[j];
	if (i<0) return;
	TCHAR* s = (*theMtl->maps)[j].map?((*theMtl->maps)[j].mapOn?ucm:lcm):blnk; 
	texMBut[i]->SetText(s);
	Texmap *t = (*theMtl->maps)[j].map;
	TSTR nm;
	if (t) nm = t->GetFullName();
	else  nm = GetString(IDS_DS_NONE);
	texMBut[i]->SetTooltip(TRUE,nm);
	}

void StdMtlDlg::ReloadDialog() {
	Interval v;
	theMtl->Update(ip->GetTime(),v);
	LoadDialog(FALSE);
	}

void StdMtlDlg::FixFilterButtons() {
	BOOL b = (theMtl->flags&STDMTL_FILT_TRANSP)?1:0;
	EnableWindow(GetDlgItem(hPanelBasic,IDC_FILT), b);
	EnableWindow(GetDlgItem(hPanelBasic,IDC_MAPON_FI), b);
	}

void StdMtlDlg::SetTime(TimeValue t) {
	if (t!=curTime) {
		curTime = t;
		Interval v;
		theMtl->Update(ip->GetTime(),v);
		LoadDialog(TRUE);
		}
	}


// >>>> SelfIllum Color ?????
Color StdMtlDlg::MtlColor(int i) {
	switch(i) {
		case 0: return theMtl->GetAmbient(); 
		case 1: return theMtl->GetDiffuse();
		case 2: return theMtl->GetSpecular();
		case 3: return theMtl->GetFilter();
		default: return Color(0,0,0);
		}
	}

TCHAR *StdMtlDlg::ColorName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_AMBIENT);	 
		case 1:  return GetString(IDS_DS_DIFFUSE);	 
		case 2:  return GetString(IDS_DS_SPECULAR);	 
		default:  return GetString(IDS_DS_FILTER);	 
		}
	}

void StdMtlDlg::SetMtlColor(int i, Color c) {
	switch(i) {
		case 0: 
			theMtl->SetAmbient(c,curTime); 
			if (theMtl->GetFlag(STDMTL_LOCK_AD)) {
				theMtl->SetDiffuse(c,curTime);
				cs[1]->SetColor(MtlColor(1));
				if (theMtl->GetFlag(STDMTL_LOCK_DS)) {
					theMtl->SetSpecular(c,curTime);
					cs[2]->SetColor(MtlColor(2));
					}
				}
			break;
		case 1: 
			theMtl->SetDiffuse(c,curTime); 
			if (theMtl->GetFlag(STDMTL_LOCK_AD)) {
				theMtl->SetAmbient(c,curTime);
				cs[0]->SetColor(MtlColor(0));
				}
			if (theMtl->GetFlag(STDMTL_LOCK_DS)) {
				theMtl->SetSpecular(c,curTime);
				cs[2]->SetColor(MtlColor(2));
				}
			break;
		case 2: 
			theMtl->SetSpecular(c,curTime); 
			if (theMtl->GetFlag(STDMTL_LOCK_DS)) {
				theMtl->SetDiffuse(c,curTime);
				cs[1]->SetColor(MtlColor(1));
				if (theMtl->GetFlag(STDMTL_LOCK_AD)) {
					theMtl->SetAmbient(c,curTime);
					cs[0]->SetColor(MtlColor(0));
					}
				}
			break;
		case 3: 
			theMtl->SetFilter(c,curTime); 
			break;
		}

	}

StdMtlDlg::~StdMtlDlg() {
	int i;
	for (i=0; i<NCOLBOX; i++) {
		ReleaseIColorSwatch(cs[i]);
		}
	if (hPanelBasic) {
		HDC hdc = GetDC(hPanelBasic);
		GetGPort()->RestorePalette(hdc, hOldPal);
		ReleaseDC(hPanelBasic,hdc);
		}

	theMtl->SetFlag(STDMTL_ROLLUP1_OPEN,ip->IsRollupPanelOpen(hPanelBasic));
	theMtl->SetFlag(STDMTL_ROLLUP2_OPEN,ip->IsRollupPanelOpen(hPanelExtra));
	theMtl->SetFlag(STDMTL_ROLLUP3_OPEN,ip->IsRollupPanelOpen(hPanelTexmap));
#ifndef DESIGN_VER
	theMtl->SetFlag(STDMTL_ROLLUP4_OPEN,ip->IsRollupPanelOpen(hPanelDynam));
#endif
	theMtl->rollScroll = ip->GetRollupScrollPos();

	theMtl->SetParamDlg(NULL);
	for (i=0; i<NTEXMAPS; i++) 
		ReleaseISpinner(texAmtSpin[i]);

	for (i=0; i<NMBUTS; i++)
		ReleaseICustButton(texMBut[i]);

	for (i=0; i<NTEXMAPS; i++) {
		ReleaseICustButton(iBut[i]);
		iBut[i] = NULL; 
		}
	
	ReleaseISpinner(hSpin);
	ReleaseISpinner(sSpin);
	ReleaseISpinner(vSpin);
	ReleaseISpinner(rSpin);
	ReleaseISpinner(gSpin);
	ReleaseISpinner(bSpin);
	ReleaseISpinner(softSpin);
	ReleaseISpinner(shSpin);
	ReleaseISpinner(ssSpin);
	ReleaseISpinner(siSpin);
	ReleaseISpinner(trSpin);
	ReleaseISpinner(tfSpin);
	ReleaseISpinner(wireSizeSpin);
	ReleaseISpinner(iorSpin);
	ReleaseISpinner(dimSpin);
	ReleaseISpinner(dimMultSpin);
#ifndef DESIGN_VER
	ReleaseISpinner(iBounce);
	ReleaseISpinner(iStatFrict);
	ReleaseISpinner(iSlidFrict);
#endif

	SetWindowLong(hPanelBasic, GWL_USERDATA, NULL);
	SetWindowLong(hPanelExtra, GWL_USERDATA, NULL);
	SetWindowLong(hPanelTexmap, GWL_USERDATA, NULL);
#ifndef DESIGN_VER
	SetWindowLong(hPanelDynam, GWL_USERDATA, NULL);
#endif
	hPanelBasic = hPanelExtra = hPanelTexmap = hPanelDynam = NULL;
	}


void StdMtlDlg::UpdateColorStuff() {
	curRGB = MtlColor(editingColor);
	RGBtoHSV(curRGB, &H, &S, &V);
	UpdateColControls(SET_HSV|SET_RGB);
	}
		
void StdMtlDlg::UpdateControlFor(int np) {
	Point3 p;
	Interval v;
	TimeValue t = ip->GetTime();
	theMtl->Update(t, v);
	switch(np) {
		case PB_AMBIENT:
			UpdateColSwatches();
		 	if (editingColor==0)
				UpdateColorStuff();
			cs[0]->SetKeyBrackets(theMtl->KeyAtTime(PB_AMBIENT,curTime));
			break;
		case PB_DIFFUSE:
			UpdateColSwatches();
		 	if (editingColor==1)
				UpdateColorStuff();
			cs[1]->SetKeyBrackets(theMtl->KeyAtTime(PB_DIFFUSE,curTime));
			break;
		case PB_SPECULAR:
			UpdateColSwatches();
		 	if (editingColor==2)
				UpdateColorStuff();
			cs[2]->SetKeyBrackets(theMtl->KeyAtTime(PB_SPECULAR,curTime));
			break;
		case PB_SHININESS:
			shSpin->SetValue(FracToPc(theMtl->GetShininess()),FALSE);
			shSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_SHININESS,curTime));
			break;
		case PB_SHIN_STR:
			ssSpin->SetValue(FracToPc(theMtl->GetShinStr()),FALSE);
			ssSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_SHIN_STR,curTime));
			break;
		case PB_SOFTEN:
			softSpin->SetValue(theMtl->GetSoftenLevel(curTime),FALSE);
			softSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_SOFTEN,curTime));
			break;

		// >>>>
		case PB_SELFI:
			siSpin->SetValue(FracToPc(theMtl->GetSelfIll()),FALSE);
			siSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_SELFI,curTime));
			break;
		case PB_OPAC:
			trSpin->SetValue(FracToPc(theMtl->GetOpacity()),FALSE);
			trSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_OPAC,curTime));
			break;
		case PB_OPFALL:
			tfSpin->SetValue(FracToPc(theMtl->GetOpacFalloff()),FALSE);
			tfSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_OPFALL,curTime));
			break;
		case PB_FILTER:
			UpdateColSwatches();
		 	if (editingColor==3)
				UpdateColorStuff();
			cs[3]->SetKeyBrackets(theMtl->KeyAtTime(PB_FILTER,curTime));
			break;
		case PB_WIRESZ:
			wireSizeSpin->SetValue( theMtl->WireSize(),FALSE);
			wireSizeSpin->SetKeyBrackets(theMtl->KeyAtTime(PB_WIRESZ,curTime));
			break;
		case PB_IOR:
			iorSpin->SetValue( theMtl->GetIOR(),FALSE);
			iorSpin->SetKeyBrackets(KeyAtCurTime(PB_IOR));
			break;
#ifndef DESIGN_VER
		case PB_BOUNCE:
			iBounce->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_BOUNCE),FALSE); 
			iBounce->SetKeyBrackets(KeyAtCurTime(PB_BOUNCE));
			break;
		case PB_STATFRIC:
			iStatFrict->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_STATIC_FRICTION),FALSE); 
			iStatFrict->SetKeyBrackets(KeyAtCurTime(PB_STATFRIC));
			break;
		case PB_SLIDFRIC:
			iSlidFrict->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_SLIDING_FRICTION),FALSE); 
			iSlidFrict->SetKeyBrackets(KeyAtCurTime(PB_SLIDFRIC));
			break;
#endif
		case PB_DIMLEV:
			dimSpin->SetValue( theMtl->GetDimIntens(curTime),FALSE);
			dimSpin->SetKeyBrackets(KeyAtCurTime(PB_DIMLEV));
			break;
		case PB_DIMMULT:
			dimMultSpin->SetValue( theMtl->GetDimMult(curTime),FALSE);
			dimMultSpin->SetKeyBrackets(KeyAtCurTime(PB_DIMMULT));
			break;
		}
	}


static LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwpar = GetParent(hwnd);
	StdMtlDlg *theDlg = (StdMtlDlg *)GetWindowLong(hwpar, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;
    switch (msg)    {
		case WM_COMMAND: 	
			break;
		case WM_MOUSEMOVE: 	
			break;
		case WM_LBUTTONUP: 
			break;
		case WM_PAINT: 	
			{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				theDlg->DrawHilite(hdc, rect);
				}
			EndPaint( hwnd, &ps );
			}													
			break;
		case WM_CREATE:
		case WM_DESTROY: 
			break;
    	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
	} 

int ColIDToIndex(int id) {
	switch (id) {
		case IDC_STD_COLOR1: return 0;
		case IDC_STD_COLOR2: return 1;
		case IDC_STD_COLOR3: return 2;
		case IDC_STD_COLOR4: return 3;
		default: return 0;
		}
	}


static int ShadeFromListID( int i) {
	switch (i) {
		case 0: return SHADE_CONST;
		case 1: return SHADE_PHONG;
		case 2: return SHADE_BLINN;
		case 3: return SHADE_METAL;
		default: return SHADE_PHONG;
		}
	}

static int ListIDFromShade( int i) {
	switch (i) {
		case SHADE_CONST: return 0;
		case SHADE_PHONG: return 1;
		case SHADE_BLINN: return 2;
		case SHADE_METAL: return 3;
		default: return 1;
		}
	}

BOOL StdMtlDlg::BasicPanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			int i;
			
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			for (i=0; i<NCOLBOX; i++) {
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					MtlColor(i), ColorName(i));
				}

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)HiliteWndProc);

			HWND hwndShading = GetDlgItem(hwndDlg, IDC_SHADING);
			for (i=0; i<NSHADES; i++)
				SendMessage(hwndShading, CB_ADDSTRING, 0, (LPARAM)GetString(shadeNameID[i]));

			hSpin = SetupIntSpinner(hwndDlg, IDC_H_SPIN, IDC_H_EDIT, 0,255, 0);
			sSpin = SetupIntSpinner(hwndDlg, IDC_S_SPIN, IDC_S_EDIT, 0,255, 0);
			vSpin = SetupIntSpinner(hwndDlg, IDC_V_SPIN, IDC_V_EDIT, 0,255, 0);

			rSpin = SetupIntSpinner(hwndDlg, IDC_R_SPIN, IDC_R_EDIT, 0,255, 0);
			gSpin = SetupIntSpinner(hwndDlg, IDC_G_SPIN, IDC_G_EDIT, 0,255, 0);
			bSpin = SetupIntSpinner(hwndDlg, IDC_B_SPIN, IDC_B_EDIT, 0,255, 0);

			shSpin = SetupIntSpinner(hwndDlg, IDC_SH_SPIN, IDC_SH_EDIT, 0,100, 0);
			ssSpin = SetupIntSpinner(hwndDlg, IDC_SS_SPIN, IDC_SS_EDIT, 0,999, 0);
			siSpin = SetupIntSpinner(hwndDlg, IDC_SI_SPIN, IDC_SI_EDIT, 0,100, 0);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtons[j]));
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
				}

			softSpin = SetupFloatSpinner(hwndDlg, IDC_SOFT_SPIN, IDC_SOFT_EDIT, 0.0f,1.0f,0.0f,.01f);

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupLockButton(hwndDlg,IDC_LOCK_DS,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);
			return TRUE;
			}
			break;
		case WM_COMMAND: 
				{ 
				for ( int i=0; i<NMBUTS; i++) {
					if (id == texMButtons[i]) {
						PostMessage(hwmedit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)theMtl);
						goto exit;
						}
					}
				}
		    switch (id) {
				case IDC_SHADING: {
					if (code==CBN_SELCHANGE) {
						int newshade = ShadeFromListID(SendMessage( GetDlgItem(hwndDlg,IDC_SHADING), CB_GETCURSEL, 0, 0 ));
						int oldshade = theMtl->GetShaderId();
						if ( oldshade != newshade ) {
							theMtl->SetShaderId( newshade );
							softSpin->Enable(theMtl->shading!=SHADE_METAL);
							UpdateMtlDisplay();
							}
						}
					break;
					}

				case IDC_AMB:  
				case IDC_DIFF: 
				case IDC_SPEC: 
				case IDC_FILT: 
					// >>>> SELFI
					SetEditColor(id-IDC_AMB);
					break;

				case IDC_WIRE:
					theMtl->SetFlag(STDMTL_WIRE, GetCheckBox(hwndDlg, IDC_WIRE));			
					theMtl->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_FACE_MAP:
					theMtl->SetFlag(STDMTL_FACEMAP, GetCheckBox(hwndDlg, IDC_FACE_MAP));			
					UpdateMtlDisplay();
					theMtl->NotifyChanged();
					break;

				case IDC_2SIDE:
					theMtl->SetFlag(STDMTL_2SIDE, GetCheckBox(hwndDlg, IDC_2SIDE));			
					theMtl->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_SUPER_SAMP:
					theMtl->SetFlag(STDMTL_SSAMP, GetCheckBox(hwndDlg, IDC_SUPER_SAMP));			
					break;

				case IDC_SOFTEN:
					theMtl->SetFlag(STDMTL_SOFTEN, GetCheckBox(hwndDlg, id));			
					theMtl->NotifyChanged();
					UpdateMtlDisplay();
					break;

//				case IDC_OLDSPEC:
//					theMtl->SetFlag(STDMTL_OLDSPEC, GetCheckBox(hwndDlg, id));			
//					theMtl->NotifyChanged();
//					UpdateMtlDisplay();
//					break;

				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					break;
				case IDC_LOCK_DS:
					SetLockDS(IsButtonChecked(hwndDlg, IDC_LOCK_DS));
					break;
				case IDC_LOCK_ADTEX:
					SetLockADTex(IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX));
					break;
				}
			break;
		case CC_COLOR_SEL:
			{
			int id = LOWORD(wParam);
			SetEditColor(ColIDToIndex(id));
			}			
			break;
		case CC_COLOR_DROP:
			{
			int id = LOWORD(wParam);
			SetEditColor(ColIDToIndex(id));
			}			
			break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE:
			{			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColIDToIndex(id);
			if (buttonUp) theHold.Begin();
			SetRGB(cs[n]->GetColor());
			SetMtlColor(n,curRGB);
			UpdateColControls(SET_BOTH);
			theMtl->NotifyChanged();
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				UpdateMtlDisplay();				
				}
			}			
			break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
			break;       
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_R_SPIN: UpdateColFromSpin(hwndDlg, Rc, rSpin); break;
				case IDC_G_SPIN: UpdateColFromSpin(hwndDlg, Gc, gSpin); break;
				case IDC_B_SPIN: UpdateColFromSpin(hwndDlg, Bc, bSpin); break;
				case IDC_H_SPIN: UpdateColFromSpin(hwndDlg, Hc, hSpin); break;
				case IDC_S_SPIN: UpdateColFromSpin(hwndDlg, Sc, sSpin); break;
				case IDC_V_SPIN: UpdateColFromSpin(hwndDlg, Vc, vSpin); break;
				case IDC_SH_SPIN: 
					theMtl->SetShininess(PcToFrac(shSpin->GetIVal()), curTime); 
					UpdateHilite();
					break;
				case IDC_SS_SPIN: 
					theMtl->SetShinStr(PcToFrac(ssSpin->GetIVal()),curTime); 
					UpdateHilite();
					break;

					// >>>>
				case IDC_SI_SPIN: 
					theMtl->SetSelfIllum(PcToFrac(siSpin->GetIVal()),curTime); 
					//UpdateColControls(0);  // makes redraw smoother (black magic)
					break;

				case IDC_TR_SPIN: 
					theMtl->SetOpacity(PcToFrac(trSpin->GetIVal()),curTime); 
					//UpdateColControls(0);  // makes redraw smoother (black magic)
					break;
				case IDC_SOFT_SPIN: 
					theMtl->SetSoftenLevel(softSpin->GetFVal(),curTime); 
					break;
				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    	}
	exit:
	return FALSE;
	}

BOOL StdMtlDlg::ExtraPanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			wireSizeSpin = SetupFloatSpinner(hwndDlg, IDC_WIRE_SPIN, IDC_WIRE_EDIT, 0.0f, 10000.0f, 1.0f);
			wireSizeSpin->SetAutoScale();
			tfSpin = SetupIntSpinner(hwndDlg, IDC_TF_SPIN, IDC_TF_EDIT, 0,100, 0);
			iorSpin = SetupFloatSpinner(hwndDlg, IDC_IOR_SPIN, IDC_IOR_EDIT, 0.0f,10.0f,1.5f,.01f);
			dimSpin = SetupFloatSpinner(hwndDlg, IDC_DIM_AMTSPIN, IDC_DIM_AMT, 0.0f,1.0f,1.0f,.01f);
			dimMultSpin = SetupFloatSpinner(hwndDlg, IDC_DIM_MULTSPIN, IDC_DIM_MULT, 0.1f,10.0f,1.0f,.01f);
			SetCheckBox(hwndDlg,IDC_DIM_REFL,theMtl->dimReflect);
			break;
		case WM_COMMAND:  
		    switch (id) {
				case IDC_TR_ADD:
				case IDC_TR_SUB:
				case IDC_TR_SUB2:
					CheckRadioButton( hwndDlg, IDC_TR_ADD,IDC_TR_SUB2,id);
					theMtl->SetFlag(STDMTL_ADD_TRANSP, id==IDC_TR_ADD);
					theMtl->SetFlag(STDMTL_FILT_TRANSP, id==IDC_TR_SUB2);
					FixFilterButtons();
					theMtl->NotifyChanged();
					break;												 

				case IDC_TF_IN:
				case IDC_TF_OUT:
					CheckRadioButton( hwndDlg, IDC_TF_IN,IDC_TF_OUT,id);
					theMtl->SetFlag(STDMTL_FALLOFF_OUT, id==IDC_TF_OUT);
					theMtl->NotifyChanged();
					break;												 

				case IDC_PIXELS:
				case IDC_UNITS:
					CheckRadioButton( hwndDlg, IDC_PIXELS,IDC_UNITS,id);
					theMtl->SetFlag(STDMTL_WIRE_UNITS, id==IDC_UNITS);
					if (theMtl->GetFlag(STDMTL_WIRE)) {
						UpdateMtlDisplay();
						theMtl->NotifyChanged();
						}
					break;												 
				case IDC_DIM_REFL:
					theMtl->dimReflect = GetCheckBox(hwndDlg,IDC_DIM_REFL);
					theMtl->NotifyChanged();
					break;
				}
			break;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_DESTROY:		break;
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch(id) {
				case IDC_WIRE_SPIN: 
					theMtl->SetWireSize(wireSizeSpin->GetFVal(),curTime); 
					break;
				case IDC_TF_SPIN: theMtl->SetOpacFalloff(PcToFrac(tfSpin->GetIVal()),curTime); 
					break;
				case IDC_IOR_SPIN: 
					theMtl->SetIOR(iorSpin->GetFVal(),curTime); 
					break;
				case IDC_DIM_AMTSPIN: 
					theMtl->SetDimIntens(dimSpin->GetFVal(),curTime); 
					break;
				case IDC_DIM_MULTSPIN: 
					theMtl->SetDimMult(dimMultSpin->GetFVal(),curTime); 
					break;
				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));			
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;
    default:
        return FALSE;
    	}
	return FALSE;
	}

//----------------------------------------------------------------------------
// ---  Drag-and-drop for Texture Maps ----
//----------------------------------------------------------------------------


BOOL StdMtlDlg::TexmapPanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:{
			for (int i=0; i<NTEXMAPS; i++) {
				if (i==ID_BU||i==ID_DP)
					texAmtSpin[i] = SetupIntSpinner(hwndDlg, texSpinID[i],texAmtID[i], -999,999, 0);
				else 
					texAmtSpin[i] = SetupIntSpinner(hwndDlg, texSpinID[i],texAmtID[i], 0,100, 0);
				HWND hw = GetDlgItem(hwndDlg, texMapID[i]);
//				WNDPROC oldp = (WNDPROC)GetWindowLong(hw, GWL_WNDPROC);
//				SetWindowLong( hw, GWL_WNDPROC, (LONG)TexSlotWndProc);
//				SetWindowLong( hw, GWL_USERDATA, (LONG)oldp);
				iBut[i] = GetICustButton(GetDlgItem(hwndDlg, texMapID[i]));
				iBut[i]->SetDADMgr(&dadMgr);
				}
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);
			}
			break;
		case WM_COMMAND:  
			{
			for (int i=0; i<NTEXMAPS; i++) {
				if (id == texOnID[i]) {
					theMtl->EnableMap(i,GetCheckBox(hwndDlg, id));
					UpdateMBut(i);
					goto exit;
					}
				if (id == texMapID[i]) {
					PostMessage(hwmedit,WM_TEXMAP_BUTTON, i ,(LPARAM)theMtl);
					goto exit;
					}
				}
			}

		    switch (id) {
				case IDC_LOCK_ADTEX:
					SetLockADTex(IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX));
					break;
				}
			break;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_DESTROY:		break;
		case CC_SPINNER_CHANGE:    
			{
			if (!theHold.Holding()) theHold.Begin();
			for (int i=0; i<NTEXMAPS; i++) {
				if (id == texSpinID[i]) {
					theMtl->SetTexmapAmt(i,PcToFrac(texAmtSpin[i]->GetIVal()), curTime);
					texAmtSpin[i]->SetKeyBrackets(theMtl->AmtKeyAtTime(i,curTime));
					break;
					}
				}
			}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;
	    default:
    	    return FALSE;
    	}
	exit:
	return FALSE;
	}


BOOL StdMtlDlg::DynamPanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			iBounce =    SetupFloatSpinner(hwndDlg, IDC_BOUNCE_SPIN, IDC_BOUNCE_EDIT, 0.0f,1.0f,1.0f,.01f);
			iStatFrict = SetupFloatSpinner(hwndDlg, IDC_STATFRIC_SPIN, IDC_STATFRIC_EDIT, 0.0f,1.0f,0.0f,.01f);
			iSlidFrict = SetupFloatSpinner(hwndDlg, IDC_SLIDFRIC_SPIN, IDC_SLIDFRIC_EDIT, 0.0f,1.0f,0.0f,.01f);
			break;
		case WM_COMMAND:  
			break;
		case WM_DESTROY:		break;
		case CC_SPINNER_CHANGE:    
			{
			if (!theHold.Holding()) theHold.Begin();
			switch(id) {
				case IDC_BOUNCE_SPIN: 
					theMtl->SetDynamicsProperty(curTime,0,DYN_BOUNCE,iBounce->GetFVal()); 
					break;
				case IDC_STATFRIC_SPIN: 
					theMtl->SetDynamicsProperty(curTime,0,DYN_STATIC_FRICTION,iStatFrict->GetFVal()); 
					break;
				case IDC_SLIDFRIC_SPIN: 
					theMtl->SetDynamicsProperty(curTime,0,DYN_SLIDING_FRICTION,iSlidFrict->GetFVal()); 
					break;
				}
			}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			break;
	    default:
    	    return FALSE;

    	}
	return FALSE;
	}

static BOOL CALLBACK  BasicPanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StdMtlDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (StdMtlDlg*)lParam;
		theDlg->hPanelBasic = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (StdMtlDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	BOOL res;
	theDlg->isActive = 1;
	res = theDlg->BasicPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

static BOOL CALLBACK  ExtraPanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StdMtlDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (StdMtlDlg*)lParam;
		theDlg->hPanelExtra = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (StdMtlDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	BOOL res;
	theDlg->isActive = 1;
	res = theDlg->ExtraPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

static BOOL CALLBACK  TexmapPanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StdMtlDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (StdMtlDlg*)lParam;
		theDlg->hPanelTexmap = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (StdMtlDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	BOOL res;
	theDlg->isActive = 1;
	res = theDlg->TexmapPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}


static BOOL CALLBACK  DynamPanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StdMtlDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (StdMtlDlg*)lParam;
		theDlg->hPanelDynam = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (StdMtlDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	BOOL res;
	theDlg->isActive = 1;
	res = theDlg->DynamPanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

void StdMtlDlg::UpdateTexmapDisplay(int i) {
	texAmtSpin[i]->SetValue(FracToPc(theMtl->GetTexmapAmt(i)),FALSE);
	texAmtSpin[i]->SetKeyBrackets(theMtl->AmtKeyAtTime(i,curTime));
	SetCheckBox(hPanelTexmap, texOnID[i], theMtl->IsMapEnabled(i));
	Texmap *t = (*theMtl->maps)[i].map;
	TSTR nm;
	if (t) 
		nm = t->GetFullName();
	else 
		nm = GetString(IDS_DS_NONE);
	iBut[i]->SetText(nm.data());
//	SetDlgItemText(hPanelTexmap, texMapID[i], nm.data());
	UpdateMBut(i);
	}

void StdMtlDlg::UpdateTexmaps() {
	for (int i=0; i<NTEXMAPS; i++)
		UpdateTexmapDisplay(i);
	}

void  StdMtlDlg::LoadDialog(BOOL draw) {
	if (theMtl&&hPanelBasic) {
		Interval v;
//		assert(hPanelBasic);  

		// BASIC PANEL
		HWND hwndShading = GetDlgItem(hPanelBasic, IDC_SHADING);
		SendMessage( hwndShading, CB_SETCURSEL, ListIDFromShade((WPARAM)theMtl->GetShaderId()), (LPARAM)0 );
		ULONG flg = theMtl->flags;
		SetCheckBox(hPanelBasic,IDC_WIRE,  (flg&STDMTL_WIRE)?1:0); 
		SetCheckBox(hPanelBasic,IDC_2SIDE, (flg&STDMTL_2SIDE)?1:0); 
		SetCheckBox(hPanelBasic,IDC_SUPER_SAMP, (flg&STDMTL_SSAMP)?1:0); 

//		SetCheckBox(hPanelBasic,IDC_SOFTEN, (flg&STDMTL_SOFTEN)?1:0); 
//		SetCheckBox(hPanelBasic,IDC_OLD_SPEC, (flg&STDMTL_OLDSPEC)?1:0); 
		SetCheckBox(hPanelBasic,IDC_FACE_MAP, (flg&STDMTL_FACEMAP)?1:0); 
		CheckRadioButton( hPanelBasic, IDC_AMB,IDC_FILT, IDC_AMB+editingColor);
		shSpin->SetValue(FracToPc(theMtl->GetShininess()),FALSE);
		shSpin->SetKeyBrackets(KeyAtCurTime(PB_SHININESS));

		ssSpin->SetValue(FracToPc(theMtl->GetShinStr()),FALSE);
		ssSpin->SetKeyBrackets(KeyAtCurTime(PB_SHIN_STR));

		// >>>>
		siSpin->SetValue(FracToPc(theMtl->GetSelfIll()),FALSE);
		siSpin->SetKeyBrackets(KeyAtCurTime(PB_SELFI));

		trSpin->SetValue(FracToPc(theMtl->GetOpacity()),FALSE);
		trSpin->SetKeyBrackets(KeyAtCurTime(PB_OPAC));

		tfSpin->SetValue(FracToPc(theMtl->GetOpacFalloff()),FALSE);
		tfSpin->SetKeyBrackets(KeyAtCurTime(PB_OPFALL));

		softSpin->SetValue(theMtl->softThresh,FALSE);
		softSpin->SetKeyBrackets(KeyAtCurTime(PB_SOFTEN));
		softSpin->Enable(theMtl->shading!=SHADE_METAL);

		CheckButton(hPanelBasic, IDC_LOCK_AD, theMtl->GetFlag(STDMTL_LOCK_AD));
		CheckButton(hPanelBasic, IDC_LOCK_DS, theMtl->GetFlag(STDMTL_LOCK_DS));
	 	UpdateLockADTex();
		FixFilterButtons();
		EnablePhongStuff();

		curRGB = MtlColor(editingColor);
		RGBtoHSV(curRGB, &H, &S, &V);
		UpdateColControls(SET_HSV|SET_RGB);

		UpdateColSwatches();
		UpdateHilite();

		// EXTRA PANEL
		int b,c;
		b = theMtl->GetFlag(STDMTL_ADD_TRANSP);
		c = theMtl->GetFlag(STDMTL_FILT_TRANSP);
		CheckRadioButton(hPanelExtra,IDC_TR_ADD,IDC_TR_SUB2,b?IDC_TR_ADD:c?IDC_TR_SUB2:IDC_TR_SUB);

		b = theMtl->GetFlag(STDMTL_FALLOFF_OUT);
		CheckRadioButton(hPanelExtra,IDC_TF_IN,IDC_TF_OUT,b?IDC_TF_OUT:IDC_TF_IN);

		b = theMtl->GetFlag(STDMTL_WIRE_UNITS);
		CheckRadioButton(hPanelExtra,IDC_PIXELS,IDC_UNITS,b?IDC_UNITS:IDC_PIXELS);

		wireSizeSpin->SetValue( theMtl->WireSize(),FALSE);
		wireSizeSpin->SetKeyBrackets(KeyAtCurTime(PB_WIRESZ));

		iorSpin->SetValue( theMtl->GetIOR(),FALSE);
		iorSpin->SetKeyBrackets(KeyAtCurTime(PB_IOR));

		SetCheckBox(hPanelExtra,IDC_DIM_REFL,theMtl->dimReflect);

		dimSpin->SetValue( theMtl->GetDimIntens(curTime),FALSE);
		dimSpin->SetKeyBrackets(KeyAtCurTime(PB_DIMLEV));

		dimMultSpin->SetValue( theMtl->GetDimMult(curTime),FALSE);
		dimMultSpin->SetKeyBrackets(KeyAtCurTime(PB_DIMMULT));


		// TEXMAP PANEL & BASIC PANEL
		for (int i=0; i<NTEXMAPS; i++) 
			UpdateTexmapDisplay(i);

#ifndef	 DESIGN_VER
		// DYNAMICS PANEL
		iBounce->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_BOUNCE),FALSE); 
		iBounce->SetKeyBrackets(KeyAtCurTime(PB_BOUNCE));

		iStatFrict->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_STATIC_FRICTION),FALSE); 
		iStatFrict->SetKeyBrackets(KeyAtCurTime(PB_STATFRIC));

		iSlidFrict->SetValue(theMtl->GetDynamicsProperty(curTime,0,DYN_SLIDING_FRICTION),FALSE); 
		iSlidFrict->SetKeyBrackets(KeyAtCurTime(PB_SLIDFRIC));
#endif
		}
	}

void StdMtlDlg::SetRGB(DWORD rgb) {
	curRGB = rgb;
	RGBtoHSV (curRGB, &H, &S, &V);
	}


void StdMtlDlg::UpdateColSwatches() {
	for(int i=0; i<NCOLBOX; i++) {
		cs[i]->SetKeyBrackets(theMtl->KeyAtTime(PB_ID[i],curTime));
		cs[i]->SetColor(MtlColor(i));
		}
	}

void StdMtlDlg::UpdateColControls( int  which) {
	HDC hdc;
    hdc = GetDC (hPanelBasic);
	BOOL key = KeyAtCurTime(PB_ID[editingColor]);
    if (which & SET_HSV) {
		hSpin->SetValue((int)H,FALSE);
		sSpin->SetValue((int)S,FALSE);
		vSpin->SetValue((int)V,FALSE);
		hSpin->SetKeyBrackets(key);
		sSpin->SetKeyBrackets(key);
		vSpin->SetKeyBrackets(key);
	    }
    if (which & SET_RGB) {
		rSpin->SetValue((int)GetRValue (curRGB),FALSE);
		gSpin->SetValue((int)GetGValue (curRGB),FALSE);
		bSpin->SetValue((int)GetBValue (curRGB),FALSE);
		rSpin->SetKeyBrackets(key);
		gSpin->SetKeyBrackets(key);
		bSpin->SetKeyBrackets(key);
	    }
	ReleaseDC(hPanelBasic,hdc);
	}

void StdMtlDlg::UpdateColFromSpin(HWND hwndDlg,int indx, ISpinnerControl *spin ) {
    int r, g, b;
    int *vals[6] = {&H, &S, &V, &r, &g, &b};
    int update = 0;
    r = GetRValue (curRGB);
    g = GetGValue (curRGB);
    b = GetBValue (curRGB);
    *vals[indx] = spin->GetIVal();
    switch (indx) {
        case Hc: case Sc: case Vc:
            // Changing the HSV settings.  Compute new RGB. 
            curRGB = HSVtoRGB (H, S, V);
            update |= SET_RGB; // Update only the RGB controls. 
            break;
        case Rc: case Gc:  case Bc:
            // Changing the RGB settings.  Compute new HSV. 
			SetRGB(RGB(r,g,b));
            update |= SET_HSV; // Update only the HSV controls. 
            break;
	    }
	SetMtlColor(editingColor,curRGB);
	UpdateColControls(update);
	cs[editingColor]->SetColor(MtlColor(editingColor));
	}

void StdMtlDlg::UpdateMtlDisplay() {
	ip->MtlChanged(); // redraw viewports
	}


void StdMtlDlg::ActivateDlg(BOOL onOff) {
	UpdateColControls(0);
	for(int i=0; i<NCOLBOX; i++) 
		cs[i]->Activate(onOff);
//	UpdateColSwatches();
	}

void StdMtlDlg::SetEditColor(int i) {
	editingColor = i;
	cs[editingColor]->EditThis(FALSE);
	curRGB = MtlColor(i);
	RGBtoHSV(curRGB, &H, &S, &V);
	UpdateColControls(SET_HSV|SET_RGB);
	if (hPanelBasic) {
		CheckRadioButton( hPanelBasic, IDC_AMB,IDC_FILT, IDC_AMB+i);
		//cs[i]->SetCheck(check);
		}
	}


void StdMtlDlg::SetLockAD(BOOL lock) {
	if (lock) {
		if (IDYES!=MessageBox(hwmedit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hPanelBasic, IDC_LOCK_AD, FALSE);	
			return;	
			}
		if (editingColor==0) 
			SetMtlColor(1, MtlColor(0));
		else 
			SetMtlColor(0, MtlColor(1));
		UpdateColControls(SET_HSV|SET_RGB);
		UpdateColSwatches();
		}
	theMtl->SetFlag(STDMTL_LOCK_AD,lock);
	}

static int IndexForMapID(int id) {
	for (int i=0; i<NTEXMAPS; i++) if (id==texMapID[i]) return i;
	return 0;
	}
void StdMtlDlg::UpdateLockADTex() {
	int lock = 	theMtl->GetFlag(STDMTL_LOCK_ADTEX);
	CheckButton(hPanelBasic, IDC_LOCK_ADTEX,lock);
	CheckButton(hPanelTexmap, IDC_LOCK_ADTEX,lock);
	ShowWindow(GetDlgItem(hPanelBasic,IDC_MAPON_AM), !lock);
	iBut[IndexForMapID(IDC_MAP_AM)]->Enable(!lock);
	}

void StdMtlDlg::SetLockADTex(BOOL lock) {
	theMtl->SetFlag(STDMTL_LOCK_ADTEX,lock);
	UpdateLockADTex();
	theMtl->NotifyChanged();
	UpdateMtlDisplay();
	}

void StdMtlDlg::SetLockDS(BOOL lock) {
	if (lock) {
		if (IDYES!=MessageBox(hwmedit, GetString(IDS_DS_LOCK_DS),GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hPanelBasic, IDC_LOCK_DS, FALSE);	
			return;	
			}
		if (editingColor==2) 
			SetMtlColor(1, MtlColor(2));
		else
			SetMtlColor(2, MtlColor(1));
		UpdateColControls(SET_HSV|SET_RGB);
		UpdateColSwatches();
		}
	theMtl->SetFlag(STDMTL_LOCK_DS,lock);
	}

void StdMtlDlg::SetThing(ReferenceTarget *m) {
	assert (m->SuperClassID()==MATERIAL_CLASS_ID);
	assert (m->ClassID()==stdmtlClassID);
	if (theMtl) 
		theMtl->paramDlg = NULL;
	theMtl = (StdMtl *)m;
	if (theMtl)
		theMtl->paramDlg = this;
	LoadDialog(TRUE);
	if (hPanelBasic)
		for (int i=0; i<4; i++) cs[i]->InitColor(MtlColor(i));
	}

static void VertLine(HDC hdc,int x, int ystart, int yend) {
	MoveToEx(hdc,x,ystart,NULL); 
	if (ystart<=yend)
		LineTo(hdc, x, yend+1);
	else 
		LineTo(hdc, x, yend-1);
	}


//-------------------------------------------------------

//-------------------------------------------------------
void StdMtlDlg::GenDrawHilite(HDC hdc, Rect& rect, SShader &sh) {
	int w,h,npts,xcen,ybot,ytop,ylast,i,iy;
	HPEN linePen = (HPEN)GetStockObject(WHITE_PEN);
	HPEN fgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNFACE));
	HPEN bgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNSHADOW));
	w = rect.w();
	h = rect.h()-3;
	npts = (w-2)/2;
	xcen = rect.left+npts;
	ybot = rect.top+h;
	ytop = rect.top+2;
	ylast = -1;
	for (i=0; i<npts; i++) {
		float v = sh.EvalHilite((float)i/((float)npts*2.0f));
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = ybot-(int)(v*((float)h-2.0f));

		if (iy<ytop) iy = ytop;

		SelectPen(hdc, fgPen);
		VertLine(hdc,xcen+i,ybot,iy);
		VertLine(hdc,xcen-i,ybot,iy);

		if (iy-1>ytop) {
			// Fill in above curve
			SelectPen(hdc,bgPen);
			VertLine(hdc,xcen+i, ytop, iy-1);
			VertLine(hdc,xcen-i, ytop, iy-1);
			}
		if (ylast>=0) {
			SelectPen(hdc,linePen);
			VertLine(hdc,xcen+i-1,iy-1,ylast);
			VertLine(hdc,xcen-i+1,iy-1,ylast);
			}

		ylast = iy;
		}
	SelectObject( hdc, linePen );
	DeleteObject(fgPen);
	DeleteObject(bgPen);
	WhiteRect3D(hdc, rect, 1);
	}

void StdMtlDlg::DrawHilite(HDC hdc, Rect& rect) {
	if (theMtl==NULL) return;
	theMtl->UpdateShader();
	GenDrawHilite(hdc,rect,*theMtl->curShader);
	}

void StdMtlDlg::EnablePhongStuff() {
	BOOL b = theMtl->shading==SHADE_METAL?0:1;
	EnableWindow(GetDlgItem(hPanelBasic,IDC_SOFTEN), b);
	EnableWindow(GetDlgItem(hPanelBasic,IDC_SPEC), b);
	EnableWindow(GetDlgItem(hPanelBasic,IDC_MAPON_SP), b);
	EnableWindow(GetDlgItem(hPanelTexmap,IDC_USEMAP_SP), b);
	EnableWindow(GetDlgItem(hPanelTexmap,IDC_AMT_SP), b);
	EnableWindow(GetDlgItem(hPanelTexmap,IDC_SPIN_SP), b);
	EnableWindow(GetDlgItem(hPanelTexmap,IDC_MAP_SP), b);
	EnableWindow(GetDlgItem(hPanelTexmap,IDC_MAP_SP), b);
	if (b) cs[2]->Enable(); else cs[2]->Disable();
	}

void StdMtlDlg::UpdateHilite() {
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite(hdc, r);
	ReleaseDC(hwHilite,hdc);
	}


void StdMtlDlg::BuildDialog() {
	if ((theMtl->flags&(STDMTL_ROLLUP_FLAGS))==0) 
		theMtl->flags |= STDMTL_ROLLUP1_OPEN;
	hPanelBasic = ip->AddRollupPage( 
		hInstance,	//getResMgr().getHInst(RES_ID_DS), 
		MAKEINTRESOURCE(IDD_DMTL_BASIC),
		BasicPanelDlgProc, 
		GetString(IDS_DS_BASIC), 
		(LPARAM)this,
		theMtl->flags&STDMTL_ROLLUP1_OPEN?0:APPENDROLL_CLOSED
		);		

	hPanelExtra = ip->AddRollupPage( 
		hInstance,	//getResMgr().getHInst(RES_ID_DS), 
		MAKEINTRESOURCE(IDD_DMTL_EXTRA),
		ExtraPanelDlgProc, 
		GetString(IDS_DS_EXTRA), 
		(LPARAM)this,		
		theMtl->flags&STDMTL_ROLLUP2_OPEN?0:APPENDROLL_CLOSED
		);		

   	hPanelTexmap = ip->AddRollupPage( 
		hInstance,	//getResMgr().getHInst(RES_ID_DS), 
		MAKEINTRESOURCE(IDD_DMTL_TEXMAP),
		TexmapPanelDlgProc, 
		GetString(IDS_DS_TEXMAP), 
		(LPARAM)this,
		theMtl->flags&STDMTL_ROLLUP3_OPEN?0:APPENDROLL_CLOSED
		);		

#ifndef DESIGN_VER
   	hPanelDynam = ip->AddRollupPage( 
		hInstance,	//getResMgr().getHInst(RES_ID_DS), 
		MAKEINTRESOURCE(IDD_DMTL_DYNAM),
		DynamPanelDlgProc, 
		GetString(IDS_DS_DYNAMICS), 
		(LPARAM)this,
		theMtl->flags&STDMTL_ROLLUP4_OPEN?0:APPENDROLL_CLOSED
		);		
#endif

	ip->SetRollupScrollPos(theMtl->rollScroll);
	}


//-----------------------------------------------------------------------------
//  StdMtl
//-----------------------------------------------------------------------------


#define NPARAMS 17
#define STDMTL_PBVERSION   9

//Current Param Block Descriptor
static ParamBlockDescID stdmtlPB[NPARAMS] = {
	{ TYPE_RGBA, NULL, TRUE,1 },    // ambient
	{ TYPE_RGBA, NULL, TRUE,2 },    // diffuse
	{ TYPE_RGBA, NULL, TRUE,3 },    // specular
	{ TYPE_FLOAT, NULL, TRUE,4 },   // shininess
	{ TYPE_FLOAT, NULL, TRUE,5 },   // shini_strength
	{ TYPE_FLOAT, NULL, TRUE,6 },   // self-illum
	{ TYPE_FLOAT, NULL, TRUE,7 },   // opacity
	{ TYPE_FLOAT, NULL, TRUE,8 },	// opfalloff
	{ TYPE_RGBA,  NULL, TRUE,9 },   // filter
	{ TYPE_FLOAT, NULL, TRUE,10 },  // wireSize
	{ TYPE_FLOAT, NULL, TRUE,11 },  // index of refraction
	{ TYPE_FLOAT, NULL, TRUE,12 },  // bounce
	{ TYPE_FLOAT, NULL, TRUE,13 },  // static friction
	{ TYPE_FLOAT, NULL, TRUE,14 },  // sliding friction
	{ TYPE_FLOAT, NULL, TRUE,15 },  // reflect dim level
	{ TYPE_FLOAT, NULL, TRUE,16 },   // reflect dim multiplier 
	{ TYPE_FLOAT, NULL, TRUE,17 }   // soften
	}; 

#define NUMOLDVER 9

static ParamVersionDesc oldVersions[NUMOLDVER] = {
	ParamVersionDesc(stdmtlPB,8, 0),
	ParamVersionDesc(stdmtlPB,9, 1),
	ParamVersionDesc(stdmtlPB,9, 2),
	ParamVersionDesc(stdmtlPB,10,3),
	ParamVersionDesc(stdmtlPB,11,4),
	ParamVersionDesc(stdmtlPB,14,5),
	ParamVersionDesc(stdmtlPB,15,6),
	ParamVersionDesc(stdmtlPB,15,7),
	ParamVersionDesc(stdmtlPB,16,8)
	};

static ParamVersionDesc curVersion(stdmtlPB,NPARAMS,STDMTL_PBVERSION);

void StdMtl::Reset() {
//	shading = SHADE_PHONG;
	SetShadingNoNotify(SHADE_BLINN);
	flags = STDMTL_FILT_TRANSP|STDMTL_LOCK_ADTEX|STDMTL_SOFTEN;
	dimReflect = FALSE;
	ReplaceReference( 0, CreateParameterBlock( stdmtlPB, NPARAMS, STDMTL_PBVERSION ) );	
	ReplaceReference( 1, new Texmaps((MtlBase*)this));	
	ivalid.SetEmpty();
	SetDimIntens(0.0f,0);
	SetDimMult(3.0f,0);
	SetSoftenLevel(0.1f,0);
	SetAmbient(Color(0.1f,0.1f,0.1f),0);
	SetDiffuse(Color(0.5f,0.5f,0.5f),0);
	SetSpecular(Color(0.9f,0.9f,0.9f),0);
	SetOpacity(1.0f,0);
	SetFilter(Color(.5f,.5f,.5f),0);
	SetShininess(.25f,0);   // change from .4, 5-21-97
	SetShinStr(.05f,0);      // change from .3, 5-21-97   
// >>>> 
	SetSelfIllum(.0f,0);
	SetOpacFalloff(0.0f,0);
	SetWireSize(1.0f,0);
	SetIOR(1.5f,0);
	SetTexmapAmt(ID_BU, BUMP_DEF_AMT, 0);
	SetDynamicsProperty(0,0,DYN_BOUNCE,1.0f);
	SetDynamicsProperty(0,0,DYN_STATIC_FRICTION,0.0f);
	SetDynamicsProperty(0,0,DYN_SLIDING_FRICTION,0.0f);
	}

StdMtl::StdMtl(BOOL loading) {
	paramDlg = NULL;
	pblock = NULL;
	maps = NULL;
	ambient = diffuse = specular = filter = Color(0.0f,0.0f,0.0f);
	SetShadingNoNotify(SHADE_PHONG);
	flags = STDMTL_FILT_TRANSP|STDMTL_LOCK_ADTEX|STDMTL_SOFTEN;
	dimReflect = FALSE;
	dimIntens = 0.0f;
	dimMult = 2.0f;
	ivalid.SetEmpty();
	if (!loading)
		Reset();
	rollScroll = 0;
	flags |= STDMTL_ROLLUP1_OPEN;
	}

RefTargetHandle StdMtl::Clone(RemapDir &remap) {
	//DebugPrint(" Cloning STDMTL %d \n",++numStdMtls);
	StdMtl *mnew = new StdMtl();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->ReplaceReference(1,remap.CloneRef(maps));
	mnew->ivalid.SetEmpty();	
	mnew->flags = flags;
	mnew->ambient = ambient;
	mnew->diffuse = diffuse;
	mnew->specular = specular;
	mnew->filter = filter;
	mnew->shininess = shininess;
	mnew->phongexp = phongexp;
	mnew->shine_str = shine_str;
	mnew->self_illum = self_illum;
	mnew->opacity = opacity;
	mnew->opfall = opfall;
	mnew->wireSize = wireSize;
	mnew->ioRefract = ioRefract;
	mnew->dimReflect = dimReflect;
	mnew->softThresh = softThresh;
	mnew->SetShadingNoNotify(shading);
	return (RefTargetHandle)mnew;
	}

ParamDlg* StdMtl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	Interval v;
	Update(imp->GetTime(),v);
	StdMtlDlg *dm = new StdMtlDlg(hwMtlEdit, imp, this);
	LoadStdMtlResources();
	dm->BuildDialog();
	dm->LoadDialog(FALSE);	 
	SetParamDlg(dm);
	return dm;	
	}

#define LIMIT0_1(x) if (x<0.0f) x = 0.0f; else if (x>1.0f) x = 1.0f;
#define LIMITMINMAX(x,min,max) if (x<min) x = min; else if (x>max) x = max;

static Color LimitColor(Color c) {
	LIMIT0_1(c.r);
	LIMIT0_1(c.g);
	LIMIT0_1(c.b);
	return c;
	}

void StdMtl::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( PB_AMBIENT, t, p, ivalid );
		ambient = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_DIFFUSE, t, p, ivalid );
		diffuse= LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_SPECULAR, t, p, ivalid );
		specular = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_FILTER, t, p, ivalid );
		filter = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_SHININESS, t, shininess, ivalid );
		pblock->GetValue( PB_SHIN_STR, t, shine_str, ivalid );
		// >>>>>
		pblock->GetValue( PB_SELFI, t, self_illum, ivalid );
		pblock->GetValue( PB_OPAC, t, opacity, ivalid );

		pblock->GetValue( PB_OPFALL, t, opfall, ivalid );
		pblock->GetValue( PB_WIRESZ, t, wireSize, ivalid );
		pblock->GetValue( PB_IOR, t, ioRefract, ivalid );
		pblock->GetValue( PB_DIMLEV, t, dimIntens, ivalid );
		pblock->GetValue( PB_DIMMULT, t, dimMult, ivalid );
		pblock->GetValue( PB_SOFTEN, t, softThresh, ivalid); 

		LIMIT0_1(opacity);
		LIMIT0_1(self_illum);
		LIMIT0_1(shininess);
		LIMITMINMAX(shine_str,0.0f,9.99f);
		LIMIT0_1(opfall);
		LIMIT0_1(dimIntens);
		LIMIT0_1(softThresh);

		phongexp = (float)pow(2.0,shininess*10.0);
	
		for (int i=0; i<NTEXMAPS; i++) 	{
			if (MAPACTIVE(i)) 
				maps->txmap[i].Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

//-----------------------------------------------------------------------
// DS - 4/7/97: Changed Opacity, Self-illumination, SHininess, Shininess strengh
// so that the map amount blends between the corresponding slider 
// setting and the map value.  This code fixes up old files so they
// will render the same way. This does not correctly handle animated values
// for the amount or parameter sliders.
//-----------------------------------------------------------------------

void StdMtl::OldVerFix(int loadVer) {
	if (loadVer<8) {
		Interval v;
		Update(0,v);
		if (MAPACTIVE(ID_OP)) {
			if (maps->txmap[ID_OP].amount != 1.0f) 
				SetOpacity(0.0f,0);
			}
		if (MAPACTIVE(ID_SI)) {
			if (maps->txmap[ID_SI].amount != 1.0f) 
				// >>>>>
				SetSelfIllum(0.0f,0);
			}	
		if (MAPACTIVE(ID_SS)) {
			float amt = maps->txmap[ID_SS].amount;
			SetTexmapAmt(ID_SS,amt*shine_str,0);
			SetShinStr(0.0f,0);
			}
		if (MAPACTIVE(ID_SH)) {
			float amt = maps->txmap[ID_SH].amount;
			SetTexmapAmt(ID_SH,amt*shininess,0);
			SetShininess(0.0f,0);
			}
		}
	if (loadVer<9) {
		if (flags&STDMTL_SOFTEN) 
			SetSoftenLevel(.6f,0);
		else 
			SetSoftenLevel(0.0f,0);
		}
	}



ULONG StdMtl::Requirements(int subMtlNum) {
	ULONG req = 0;
	
	switch (shading) {
		case SHADE_CONST:
			req |= MTLREQ_DONTMERGE_FRAGMENTS;
			break;
		case SHADE_PHONG:
		case SHADE_BLINN:
		case SHADE_METAL: req |= MTLREQ_PHONG; break;
		}

	if (opacity!=1.0f||MAPACTIVE(ID_OP)||opfall>0.0f) 
		req |= MTLREQ_TRANSP;

	for (int i=0; i<NTEXMAPS; i++) {
		if (MAPACTIVE(i))	
			req |= (*maps)[i].map->Requirements(subMtlNum);
		}
	if (MAPACTIVE(ID_BU)) {
		ULONG bmpreq = (*maps)[ID_BU].map->Requirements(subMtlNum);
		if (bmpreq&MTLREQ_UV)
			req |= MTLREQ_BUMPUV;
		if (bmpreq&MTLREQ_UV2)
			req |= MTLREQ_BUMPUV2;
		}
	if (flags&STDMTL_WIRE) 	req|= MTLREQ_WIRE;
	if (flags&STDMTL_2SIDE) req|= MTLREQ_2SIDE;
	if (flags&STDMTL_SSAMP) req|= MTLREQ_SUPERSAMPLE;
	if (flags&STDMTL_WIRE_UNITS) req|= MTLREQ_WIRE_ABS;
	if (flags&STDMTL_FACEMAP) req |= MTLREQ_FACEMAP;
	if (flags&STDMTL_ADD_TRANSP) req |= MTLREQ_ADDITIVE_TRANSP;
	if (MAPACTIVE(ID_DP)) req |= MTLREQ_DISPLACEMAP;
	return req;		
	}

Interval StdMtl::Validity(TimeValue t) {
	Interval v;
	Update(t,v);
	return ivalid;
	}

void StdMtl::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void StdMtl::SetFlag(ULONG f, ULONG val) {
	if (val) flags|=f; 
	else flags &= ~f;
	}

void StdMtl::SetTransparencyType(int type) {
	switch (type) {
		case TRANSP_SUBTRACTIVE:  
			SetFlag(STDMTL_ADD_TRANSP,0); 
			SetFlag(STDMTL_FILT_TRANSP,0); 
			break;
		case TRANSP_ADDITIVE:  
			SetFlag(STDMTL_ADD_TRANSP,1); 
			SetFlag(STDMTL_FILT_TRANSP,0); 
			break;
		case TRANSP_FILTER:  
			SetFlag(STDMTL_ADD_TRANSP,0); 
			SetFlag(STDMTL_FILT_TRANSP,1); 
			break;
		}
	}

void StdMtl::DeleteThis() {
	//DebugPrint(" Deleting STDMTL %d \n",numStdMtls--);
    delete this;
	}

TSTR StdMtl::SubAnimName(int i) { 
	return TSTR(GetString(i==0?IDS_DS_PARAMETERS:IDS_DS_TEXMAPS));
	}		

Animatable* StdMtl::SubAnim(int i) {
	switch(i) {
		case 0: return pblock; 
		case 1: return maps;
		default: assert(0); return NULL;
		}
	 }

RefTargetHandle StdMtl::GetReference(int i) {
	switch(i) {
		case 0: return pblock;
		case 1: return maps;
		default: assert(0);	 return NULL;
		}
	}

void StdMtl::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock*)rtarg; return;
		case 1:	{
			maps = (Texmaps*)rtarg; 
			if (maps!=NULL)
				maps->client = this;
			return;
			}
		default: assert(0);
		}
	}

void StdMtl::SetSubTexmap(int i, Texmap *m) {
	assert(i<NTEXMAPS);
	maps->ReplaceReference(2*i+1,m);
	if (m!=NULL) {
		EnableMap(i,TRUE);
		if (maps->txmap[i].amtCtrl==NULL) {			
			maps->ReplaceReference(2*i, NewDefaultFloatController());
			maps->txmap[i].amtCtrl->SetValue(TimeValue(0),&maps->txmap[i].amount);
			}
		}
	else {
		if (maps->txmap[i].amtCtrl!=NULL)			
			maps->DeleteReference(2*i);
		SetTexmapAmt(i, i==ID_BU?BUMP_DEF_AMT:1.0f,TimeValue(0));
		EnableMap(i,FALSE);
		}
	if (m&&(i==ID_RL||i==ID_RR)) {
		UVGen* uvg0 = m->GetTheUVGen();
		if (uvg0&&uvg0->IsStdUVGen()) {
			StdUVGen *uvg = (StdUVGen*)uvg0;
			uvg->InitSlotType(MAPSLOT_ENVIRON);
			uvg->SetCoordMapping(UVMAP_SPHERE_ENV);
			}
		}
	if (paramDlg)
		paramDlg->UpdateTexmapDisplay(i);
	}

static int nameID[NPARAMS] = { 
	IDS_DS_AMBIENT, IDS_DS_DIFFUSE, IDS_DS_SPECULAR,  IDS_DS_SHININESS,IDS_DS_SHIN_STR,
	IDS_DS_SELFI,IDS_DS_OPACITY,IDS_DS_XPFALL,IDS_DS_FILTER,IDS_DS_WIRESZ,
    IDS_DS_IOR,IDS_DS_BOUNCE,IDS_DS_STATFRIC,IDS_DS_SLIDFRIC,IDS_DS_DIMLEV,IDS_DS_DIMMULT,
    IDS_DS_SOFTEN};

RefResult StdMtl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_WANT_SHOWPARAMLEVEL:
			{
			BOOL *pb = (BOOL *)(partID);
			*pb = TRUE;
			return REF_STOP;
			}
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (paramDlg) {
				if (hTarget==pblock) {
					int np =pblock->LastNotifyParamNum();
					paramDlg->UpdateControlFor(np);
					}
				else// if (!paramDlg->isActive)  
					paramDlg->Invalidate();
				}
			break;
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_AMBIENT: 
				case PB_DIFFUSE: 
				case PB_SPECULAR: 
				case PB_FILTER: 
					gpd->dim = stdColor255Dim; 
					break;
				case PB_BOUNCE:
				case PB_STATFRIC:
				case PB_SLIDFRIC:
				case PB_DIMLEV:
				case PB_DIMMULT:
				case PB_SOFTEN:
				case PB_WIRESZ:
				case PB_IOR:
					gpd->dim = defaultDim; 
					break;
				case PB_SHININESS:
				case PB_SHIN_STR:
				case PB_SELFI:
				case PB_OPAC:
				case PB_OPFALL:
				default:
					gpd->dim = stdPercentDim; 
					break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name =  GetString(nameID[gpn->index]);
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

Class_ID StdMtl::ClassID() { 
	return stdmtlClassID; 
	}

TSTR StdMtl::GetSubTexmapSlotName(int i) {
	return GetString(texNameID[i]);
	}


void StdMtl::EnableMap(int i, BOOL onoff) { 
	maps->txmap[i].mapOn = onoff;
	NotifyChanged();
	}

// forward
SShader *GetShaderFromId(int s);

void StdMtl::SetShadingNoNotify( int s) {
	shading = s;
	curShader = GetShaderFromId(shading);
	}

void StdMtl::SetShaderId( long s) {
	long old = shading;
	SetShadingNoNotify(s);
	if (old!=shading) {
		NotifyChanged();
		if (paramDlg) {
			paramDlg->UpdateHilite();
			paramDlg->EnablePhongStuff();
			}
		}
	}

void StdMtl::SetAmbient(Color c, TimeValue t) {
	ambient =c;
	pblock->SetValue( PB_AMBIENT, t, Point3(c.r,c.g,c.b));
	NotifyChanged();
	}
			
void StdMtl::SetDiffuse(Color c, TimeValue t) {
	Point3 p;
	Interval iv;
	pblock->SetValue( PB_DIFFUSE, t, Point3(c.r,c.g,c.b));
	pblock->GetValue( PB_DIFFUSE, t, p, ivalid );
	diffuse= LimitColor(Color(p.x,p.y,p.z));
	NotifyChanged();
	}
			
void StdMtl::SetSpecular(Color c, TimeValue t) {
    specular =c;
	pblock->SetValue( PB_SPECULAR, t, Point3(c.r,c.g,c.b));
	NotifyChanged();
	}
			
void StdMtl::SetFilter(Color c, TimeValue t) {
    filter =c;
	pblock->SetValue( PB_FILTER, t, Point3(c.r,c.g,c.b));
	if (opacity!=1.0f||MAPACTIVE(ID_OP)) 
		NotifyChanged();
	}
			
void StdMtl::SetShininess(float v, TimeValue t) {
	shininess =v;
	phongexp = (float)pow(2.0,shininess*10.0);
	pblock->SetValue( PB_SHININESS, t, v);
	NotifyChanged();
	}
			
void StdMtl::SetShinStr(float v, TimeValue t) {
	shine_str =v;
	pblock->SetValue( PB_SHIN_STR, t, v);
	NotifyChanged();
	}

// >>>>			
void StdMtl::SetSelfIllum(float v, TimeValue t) {
	self_illum =v;
	pblock->SetValue( PB_SELFI, t, v);
	NotifyChanged();
	}
			
void StdMtl::SetOpacity(float v, TimeValue t) {
    opacity = v;
	pblock->SetValue( PB_OPAC, t, v);
	NotifyChanged();
	}
			
void StdMtl::SetOpacFalloff(float v, TimeValue t) {
	opfall = v;
	pblock->SetValue( PB_OPFALL, t, v);
	if (opacity!=1.0f||MAPACTIVE(ID_OP)) 
		NotifyChanged();
	}		

void StdMtl::SetWireSize(float v, TimeValue t) {
	wireSize = v;
	pblock->SetValue( PB_WIRESZ, t, v);
	if (flags&STDMTL_WIRE) 
		NotifyChanged();
	}

void StdMtl::SetIOR(float v, TimeValue t) {
	ioRefract = v;
	pblock->SetValue( PB_IOR, t, v);
  	NotifyChanged();
	}

void StdMtl::SetDimIntens(float v, TimeValue t) {
	dimIntens = v;
	pblock->SetValue( PB_DIMLEV, t, v);
  	NotifyChanged();
	}

void StdMtl::SetDimMult(float v, TimeValue t) {
	dimMult = v;
	pblock->SetValue( PB_DIMMULT, t, v);
  	NotifyChanged();
	}

void StdMtl::SetSoftenLevel(float v, TimeValue t) {
	softThresh = v;
	pblock->SetValue( PB_SOFTEN, t, v);
  	NotifyChanged();
	}

void StdMtl::SetTexmapAmt(int imap, float amt, TimeValue t) {
	if (maps->txmap[imap].amtCtrl) 
		maps->txmap[imap].amtCtrl->SetValue(t,&amt);
	maps->txmap[imap].amount = amt;
	if (maps->txmap[imap].IsActive())
		NotifyChanged();
	}

BOOL StdMtl::AmtKeyAtTime(int i, TimeValue t) {
	if (maps->txmap[i].amtCtrl) 
		return 	maps->txmap[i].amtCtrl->IsKeyAtTime(t,0);
	else
		return FALSE;
	}

long StdMtl::GetShaderId() {
	return shading;
	}

void StdMtl::UpdateShader() {
	curShader->SetShininess(shininess,shine_str);
	}

Color StdMtl::GetAmbient(int mtlNum, BOOL backFace) {   return ambient;}
Color StdMtl::GetDiffuse(int mtlNum, BOOL backFace) { return diffuse;}
Color StdMtl::GetSpecular(int mtlNum, BOOL backFace) {	return specular;	}
Color StdMtl::GetFilter() {	return filter;	}

float StdMtl::GetTexmapAmt(int imap) {	return maps->txmap[imap].amount;	}

float StdMtl::GetTexmapAmt(int imap, TimeValue t) {	return maps->txmap[imap].GetAmount(t); 	}


Color StdMtl::GetAmbient(TimeValue t)  { return pblock->GetColor(PB_AMBIENT,t);}		
Color StdMtl::GetDiffuse(TimeValue t)  { return pblock->GetColor(PB_DIFFUSE,t);	}		
Color StdMtl::GetSpecular(TimeValue t) { return pblock->GetColor(PB_SPECULAR,t);	}
Color StdMtl::GetFilter(TimeValue t)   { return pblock->GetColor(PB_FILTER,t);	}
float StdMtl::GetShininess( TimeValue t) {return pblock->GetFloat(PB_SHININESS,t);  }		
float StdMtl::GetShinStr(TimeValue t)  { return  pblock->GetFloat(PB_SHIN_STR,t);	}
// >>>>
float StdMtl::GetSelfIllum(TimeValue t){ return  pblock->GetFloat(PB_SELFI,t);	}		
float StdMtl::GetOpacity( TimeValue t) { return  pblock->GetFloat(PB_OPAC,t); }		
float StdMtl::GetOpacFalloff(TimeValue t){ return  pblock->GetFloat(PB_OPFALL,t);}		
float StdMtl::GetWireSize(TimeValue t) { return  pblock->GetFloat(PB_WIRESZ,t);}
float StdMtl::GetIOR( TimeValue t)     { return  pblock->GetFloat(PB_IOR,t);}
float StdMtl::GetDimIntens( TimeValue t)   { return  pblock->GetFloat(PB_DIMLEV,t); }
float StdMtl::GetDimMult( TimeValue t)   { return  pblock->GetFloat(PB_DIMMULT,t); }
float StdMtl::GetSoftenLevel( TimeValue t)   { return  pblock->GetFloat(PB_SOFTEN,t); }
BOOL StdMtl::MapEnabled(int i)         { return maps->txmap[i].mapOn;}


float StdMtl::GetDynamicsProperty(TimeValue t, int mtlNum, int propID) {
	float val;
	Interval ivalid;
	switch(propID) {
		case DYN_BOUNCE:
			pblock->GetValue(PB_BOUNCE,t,val,ivalid);	
			return val;
		case DYN_STATIC_FRICTION:
			pblock->GetValue(PB_STATFRIC,t,val,ivalid);	
			return val;
		case DYN_SLIDING_FRICTION:
			pblock->GetValue(PB_SLIDFRIC,t,val,ivalid);	
			return val;
		default: 
			assert(0);
			return 0.0f;
		}
	}

void StdMtl::SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value){
	switch(propID) {
		case DYN_BOUNCE: 
			pblock->SetValue( PB_BOUNCE, t, value);
			break;
		case DYN_STATIC_FRICTION:
			pblock->SetValue( PB_STATFRIC, t, value);
			break;
		case DYN_SLIDING_FRICTION:
			pblock->SetValue( PB_SLIDFRIC, t, value);
			break;
		default:
			assert(0);
			break;
		}
	}

#define MTL_HDR_CHUNK 0x4000
#define STDMTL_FLAGS_CHUNK 0x5000
#define STDMTL_SHADING_CHUNK 0x5004
#define STDMTL_TEX_ONOFF_CHUNK 0x5002
#define STDMTL_TEX_AMT0 0x5100
#define STDMTL_TEX_AMT1 0x5101
#define STDMTL_TEX_AMT2 0x5102
#define STDMTL_TEX_AMT3 0x5103
#define STDMTL_TEX_AMT4 0x5104
#define STDMTL_TEX_AMT5 0x5105
#define STDMTL_TEX_AMT6 0x5106
#define STDMTL_TEX_AMT7 0x5107
#define STDMTL_TEX_AMT8 0x5108
#define STDMTL_TEX_AMT9 0x5109
#define STDMTL_TEX_AMTA 0x510A

//#define STDMTL_BUMP1_CHUNK 0x5200
#define STDMTL_VERS_CHUNK 0x5300
#define STDMTL_DIM_REFLECT 0x5400

#define STDMTL_VERSION  9 

// IO
IOResult StdMtl::Save(ISave *isave) { 
	ULONG nb;
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(STDMTL_FLAGS_CHUNK);
	isave->Write(&flags,sizeof(flags),&nb);			
	isave->EndChunk();

	isave->BeginChunk(STDMTL_SHADING_CHUNK);
	isave->Write(&shading,sizeof(shading),&nb);			
	isave->EndChunk();

	isave->BeginChunk(STDMTL_VERS_CHUNK);
	int version = STDMTL_VERSION;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();

	if (dimReflect) {
		isave->BeginChunk(STDMTL_DIM_REFLECT);
		isave->EndChunk();
		}
	return IO_OK;
	}		

class StdMtlCB: public PostLoadCallback {
	public:
		StdMtl *m;
		int loadVersion;
	    StdMtlCB(StdMtl *s, int loadVers) { m = s; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			m->OldVerFix(loadVersion);
			delete this; 
			} 
	};


IOResult StdMtl::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;
	IOResult res;
// .......... use this???
	iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUMOLDVER, &curVersion, this,0));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				ivalid.SetEmpty();
				break;
			case STDMTL_FLAGS_CHUNK:
				res = iload->Read(&flags,sizeof(flags), &nb);
				break;
			case STDMTL_SHADING_CHUNK:
				res = iload->Read(&shading,sizeof(shading), &nb);
				if (shading<0||shading>SHADE_BLINN) {
					shading = SHADE_PHONG;
					}
				SetShadingNoNotify(shading);
				break;
			case STDMTL_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case STDMTL_TEX_ONOFF_CHUNK:
				{
				ULONG f;
				res = iload->Read(&f,sizeof(f), &nb);
				for (int i=0; i<NTEXMAPS; i++) 
				    maps->txmap[i].mapOn = (f&(1<<i))?1:0;
				}
				break;
			case STDMTL_DIM_REFLECT:
				dimReflect = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	if (version<9) {
		iload->RegisterPostLoadCallback(new StdMtlCB(this,version));
		iload->SetObsolete();
		}

	return IO_OK;
                                                      
	}

// Composite  c_over on top of c. Assume c_over has pre-multiplied
// alpha.
inline void AlphaCompCol(Color& c,  RGBA c_over) {
	float ia = 1.0f - c_over.a;
	c.r = c.r*ia + c_over.r;
	c.g = c.g*ia + c_over.g;
	c.b = c.b*ia + c_over.b;
	} 

static inline float Intens(RGBA& c) {	return (c.r+c.g+c.b)/3.0f;	}

static Color blackCol(0.0f,0.0f,0.0f);
static Color whiteCol(1.0f,1.0f,1.0f);


#define MAX3(a,b,c) ((a)>(b)?((a)>(c)?(a):(c)):((b)>(c)?(b):(c)))

static inline float MaxRGB(Color c) { 	return MAX3(c.r,c.g,c.b); }

Color StdMtl::TranspColor(ShadeContext& sc, float opac, Color& diff) {
	// Compute the color of the transparent filter color
	if (flags&STDMTL_ADD_TRANSP) {
		float f = 1.0f - opac;
		return Color(f,f,f);   //XXX
		}
	else 
		{
		// Transparent Filter color mapping
		if (flags&STDMTL_FILT_TRANSP) {
			Color filt = filter;
			if (MAPACTIVE(ID_FI)) 
				AlphaCompCol(filt,(*maps)[ID_FI].Eval(sc)); 
#ifdef OLDFILTER
			if (opac>0.5f) {
				// lerp (filt --> black) as opac goes ( 0.5--> 1.0)
				float s= 2.0f*(opac-.5f);
				return (1.0f-s)*filt;
				}
			else {
				// lerp (white --> filt) as opac goes (0.0 --> .5 )
				float s = 2.0f*opac;
				return (1.0f-s) + filt*s;
				}
#else 
			if (opac>0.5f) {
				// darken as opac goes ( 0.5--> 1.0)
				// so that max component reaches 0.0f when opac reaches 1.0
				// find max component of filt
				float m = (filt.r>filt.g)?filt.r:filt.g;
				if(filt.b>m) m = filt.b;
				Color fc;
				float d = 2.0f*(opac-.5f)*m;
				fc = filt-d;
				if (fc.r<0.0f) fc.r = 0.0f;
				if (fc.g<0.0f) fc.g = 0.0f;
				if (fc.b<0.0f) fc.b = 0.0f;
				return fc;
				}
			else {
				// lighten as opac goes ( 0.5--> 0.0)
				// so that min component reaches 1.0f when opac reaches 1.0
				// find min component of filt
				float m = (filt.r<filt.g)?filt.r:filt.g;
				if(filt.b<m) m = filt.b;
				Color fc;
				float d = (1.0f-2.0f*opac)*(1.0f-m);
				fc = filt+d;
				if (fc.r>1.0f) fc.r = 1.0f;
				if (fc.g>1.0f) fc.g = 1.0f;
				if (fc.b>1.0f) fc.b = 1.0f;
				return fc;
				}
#endif
			}
		else {
			Color f = (1.0f-diff);  // original 3DS transparency 
			return  (1.0f-opac)*f;
			}
		}
	}



//----------------------------------------------------------------------------------------
//- Phong Shader  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------


class Phong: public SShader {
	float fs;
	float shin_str;
	public:
	void Illum(ShadeContext &sc, SIllumParams &ip);
	void AffectReflMap(ShadeContext &sc, SIllumParams &ip, Color &rcol) { rcol *= ip.spec; };
	void SetShininess(float shininess, float shineStr) {
		fs = (float)pow(2.0,shininess*10.0);
		shin_str = shineStr;
		}
	float EvalHilite(float x) {
		return shin_str*(float)pow((double)cos(x*PI),(double)fs);  
		}
	};

static void whoa(){}

void Phong::Illum(ShadeContext &sc, SIllumParams &ip) {
	LightDesc *l;
	Color lightCol;
	BOOL is_shiny;
	Point3 R;
	if (is_shiny=(ip.sh_str>0.0f)) 
    R = sc.ReflectVector();

//	IPoint2 sp = sc.ScreenCoord();
//	if (sp.x==260&&sp.y==180)
//		whoa();
	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (l->Illuminate(sc,ip.N,lightCol,L,NL,diffCoef)) {
			if (l->ambientOnly) {
				ip.ambIllum += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;
			// diffuse
			if (l->affectDiffuse)
				ip.diffIllum += diffCoef*lightCol;
			if (is_shiny&&l->affectSpecular) {
				// specular (Phong) 
				float c = DotProd(L,R);
				if (c>0.0f) {
					if (ip.softThresh!=0.0&&diffCoef<ip.softThresh) {
						float r = diffCoef/ip.softThresh;
						c *= Soften(r);
						}
					c = (float)pow((double)c, (double)ip.ph_exp); // could use table lookup for speed
					ip.specIllum += c*ip.sh_str*lightCol;
					}
				}
			}
		}
	ip.specIllum *= ip.spec; 
	}


//----------------------------------------------------------------------------------------
//- Blinn Shader  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------

class Blinn: public SShader {
	float fs;
	float shin_str;
	public:
	void Illum(ShadeContext &sc, SIllumParams &ip);
	void AffectReflMap(ShadeContext &sc, SIllumParams &ip, Color &rcol) { rcol *= ip.spec; };
	void SetShininess(float shininess, float shineStr) {
		fs = (float)pow(2.0,shininess*10.0);
		shin_str = shineStr;
		}
	float EvalHilite(float x) {
		return shin_str*(float)pow((double)cos(x*PI),(double)fs);  
		}
	};


void Blinn::Illum(ShadeContext &sc, SIllumParams &ip) {
	LightDesc *l;
	Color lightCol;

	// Blinn style phong
	BOOL is_shiny=(ip.sh_str>0.0f)?1:0; 
	double ph_exp = double(ip.ph_exp)*4.0; // This is to make the hilite compatible with normal phong
	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (l->Illuminate(sc,ip.N,lightCol,L,NL,diffCoef)) {
			if (l->ambientOnly) {
				ip.ambIllum += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// diffuse
			if (l->affectDiffuse)
				ip.diffIllum += diffCoef*lightCol;

			// specular (Phong) 
			if (is_shiny&&l->affectSpecular) {
				Point3 H = FNormalize(L-ip.V);
				float c = DotProd(ip.N,H);	 
				if (c>0.0f) {
					if (ip.softThresh!=0.0&&diffCoef<ip.softThresh) {
						c *= Soften(diffCoef/ip.softThresh);
						}
					c = (float)pow((double)c, ph_exp); // could use table lookup for speed
					ip.specIllum += c*ip.sh_str*lightCol;
					}
				}
 			}
		}
	ip.specIllum *= ip.spec; 
	}

//----------------------------------------------------------------------------------------
//- Metal Shader  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------

class Metal: public SShader {
	float fm2inv, fshin_str;
	public:
	void Illum(ShadeContext &sc, SIllumParams &ip);
	void AffectReflMap(ShadeContext &sc, SIllumParams &ip, Color &rcol) { rcol *= ip.diff; };
	void SetShininess(float shininess, float shineStr);
	float EvalHilite(float x);
	};

float CompK(float f0) {
	return float(2.0*sqrt(f0)/sqrt(1.0-f0));
	}

float fres_metal(float c, float k) {
	float b,rpl,rpp,c2;
	b = k*k + 1.0f;
	c2 = c*c;
	rpl = (b*c2-2*c+1)/(b*c2+2*c+1);
	rpp = (b-2*c+c2)/(b+2*c+c2);
	return(.5f*(rpl+rpp));
	}

void Metal::Illum(ShadeContext &sc, SIllumParams &ip) {
	LightDesc *l;
	Color lightCol;
	BOOL gotKav = FALSE;
	float kav, fav0, m2inv,NV;
	
	//IPoint2 sp = sc.ScreenCoord();

	BOOL is_shiny;
	if (ip.sh_str>0.0f) {
		NV = -DotProd(ip.N,ip.V);  // N dot V: view vector is TOWARDS us.
		is_shiny = 1;
		float r = 1.0f-ip.shine;
		if (r==0.0f) r = .00001f;
		m2inv = 1.0f/(r*r);  
		}
	else 
		is_shiny = 0;
	

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;

		if (!l->Illuminate(sc,ip.N,lightCol,L,NL,diffCoef)) 
			continue;

		if (l->ambientOnly) {
			ip.ambIllum += lightCol;
			continue;
			}

		// diffuse
		if (NL>0.0f&&l->affectDiffuse)  // TBD is the NL test necessary?
			ip.diffIllum += diffCoef*lightCol;

		if (is_shiny&&l->affectSpecular) { // SPECULAR 
			Color fcol;
			float LH,NH,VH;
		    float sec2;  // Was double?? TBD
			Point3 H;
	
			if (NV<0.0f) continue;

			H = FNormalize(L-ip.V);

			LH = DotProd(L,H);  // cos(phi)   
			NH = DotProd(ip.N,H);  // cos(alpha) 
			if (NH==0.0f) continue;
			VH = -DotProd(ip.V,H);

			// compute geometrical attenuation factor 
			float G = (NV<NL)? (2.0f*NV*NH/VH): (2.0f*NL*NH/VH);
			if (G>0.0f) {
				// Compute (approximate) indices of refraction
				//	this can be factored out for non-texture-mapped mtls
				if (!gotKav) {
					fav0 = Intens(ip.diff);
					if (fav0>=1.0f) fav0 = .9999f;
					kav = CompK(fav0);	
					gotKav = TRUE;
					}

				float fav = fres_metal(LH,kav);
				float t = (fav-fav0)/(1.0f-fav0);
				fcol = (1.0f-t)*ip.diff + Color(t,t,t);

				// Beckman distribution  (from Cook-Torrance paper)
				sec2 = 1.0f/(NH*NH);  // 1/sqr(cos) 
				float D = (.5f/PI)*sec2*sec2*m2inv*(float)exp((1.0f-sec2)*m2inv);  					
				if (G>1.0f) G = 1.0f;
				float Rs = ip.sh_str*D*G/(NV+.05f);	
				ip.specIllum += fcol*Rs*lightCol;
				}
			} 
		}
	ip.diffIllum *= 1.0f - ip.sh_str;
	}


void Metal::SetShininess(float shininess, float shineStr) {
	float r = 1.0f-shininess;
	if (r==0.0f) r = .00001f;
	fm2inv = 1.0f/(r*r);  
	fshin_str = shineStr;
	}
			
float Metal::EvalHilite(float x) {
	float c = (float)cos(x*PI);
	float sec2 = 1.0f/(c*c);	  /* 1/sqr(cos) */
	return fshin_str*(.5f/PI)*sec2*sec2*fm2inv*(float)exp((1.0f-sec2)*fm2inv);  					
	}

//-------------------------------------------------------------------------


static Phong phongShader;
static Blinn blinnShader;
static Metal metalShader;

static SShader *shaders[4] = {
	&phongShader, // CONST
	&phongShader,
	&metalShader,
	&blinnShader
	};

static SShader *GetShaderFromId(int s) { return shaders[s]; };

#define DOMAP(i) (sc.doMaps&&(*maps)[i].IsActive())

void StdMtl::Shade(ShadeContext& sc) {
	SIllumParams ip;
	Color lightCol,rescol, diffIllum0;
	float opac;
	RGBA mval;
	Point3 N0,P;
	BOOL bumped = FALSE;
	if (gbufID) sc.SetGBufferID(gbufID);

	ip.flags = flags;
	ip.softThresh = softThresh;
	ip.diffIllum = blackCol;
	ip.specIllum = blackCol;
	ip.ambIllum  = blackCol;
	ip.amb = ambient;
	ip.diff = diffuse;
	ip.spec = specular;

	opac =  opacity;

	if (sc.mode==SCMODE_SHADOW) {
		// Opacity mapping;
		if (DOMAP(ID_OP)) 
			opac = (*maps)[ID_OP].LerpEvalMono(sc,opac);

		// "Shadow mode": This just computes the transparency, which is all 
		// you need for shadowing.
		if (opac!=1.0f||opfall!=0.0f) {
			if (opfall!=0.0f) {	
				ip.N = (shading==SHADE_CONST)?sc.GNormal():sc.Normal();
				ip.V = sc.V();  // get unit view vector
				float d = (float)fabs(DotProd(ip.N,ip.V));
				if (flags&STDMTL_FALLOFF_OUT) d = 1.0f-d;
				opac *= (1.0f-opfall*d);
				}

		 	// Transparency may use diffuse color mapping
			if ((flags&STDMTL_ADD_TRANSP|STDMTL_FILT_TRANSP)==0) {
				if (DOMAP(ID_DI)) {
					mval = (*maps)[ID_DI].Eval(sc);
				    AlphaCompCol(ip.diff,mval); 
					}
				}
			// Compute the transpareny color
			sc.out.t = TranspColor(sc, opac, ip.diff);
			}
		else 
			sc.out.t = blackCol;
		return;
		}

	N0 = ip.N = sc.Normal();

	if (shading==SHADE_CONST) {
		ip.N = sc.GNormal();
		bumped = TRUE;
		sc.SetNormal(ip.N);
		}

	P = sc.P();
	ip.V = sc.V();  // get unit view vector

	// Do texture mapping

	// Bump mapping: Do this FIRST so other maps can use the perturbed normal
	if (DOMAP(ID_BU)) {
		Point3 dn = (*maps)[ID_BU].EvalNormalPerturb(sc);
		bumped = TRUE;
		ip.N = FNormalize(ip.N + (sc.backFace?-dn:dn));
		sc.SetNormal(ip.N);
		}

	// Diffuse color mapping
	if (DOMAP(ID_DI)) {
		mval = (*maps)[ID_DI].Eval(sc);
	    AlphaCompCol(ip.diff,mval); 
		if (flags&STDMTL_LOCK_ADTEX) 
		    AlphaCompCol(ip.amb,mval); 
		}

 	// Ambient color mapping
	if (!(flags&STDMTL_LOCK_ADTEX)) {
		if (DOMAP(ID_AM)) {
			AlphaCompCol(ip.amb, (*maps)[ID_AM].Eval(sc)); 
			}	
		}

	// Specular color mapping
	if (DOMAP(ID_SP)) 
	    AlphaCompCol(ip.spec,(*maps)[ID_SP].Eval(sc)); 

	// Opacity mapping;
	if (DOMAP(ID_OP)) {
		opac = (*maps)[ID_OP].LerpEvalMono(sc,opac);
		}

	// Shininess mapping
	if (DOMAP(ID_SH)) {
		//ip.shine = shininess*(*maps)[ID_SH].EvalMono(sc); 
		ip.shine = (*maps)[ID_SH].LerpEvalMono(sc,shininess); 
		ip.ph_exp = (float)pow(2.0,ip.shine*10.0); // expensive.!!	TBD
		}
	else {
		ip.shine = shininess;
		ip.ph_exp = phongexp;
		}

	// Shininess strength mapping
	ip.sh_str = (DOMAP(ID_SS))? (*maps)[ID_SS].LerpEvalMono(sc,shine_str): shine_str; 

	// Self illumination mapping
	float self_i = (DOMAP(ID_SI))? (*maps)[ID_SI].LerpEvalMono(sc,self_illum) : self_illum;

	curShader->Illum(sc,ip);

	diffIllum0 = ip.diffIllum; // save this for reflection dimming

	// Apply self illumination
	if (self_i>0.0f) {
		ip.diffIllum = (self_i>=1.0f) ?  whiteCol: ip.diffIllum*(1.0f-self_i) + self_i;
		}

	ip.diffIllum = ip.amb*(sc.ambientLight+ip.ambIllum) +  ip.diff*ip.diffIllum;		

	if (DOMAP(ID_RR)) {
		// Set up for opacity for Refraction map.
		opac *= 1.0f-(*maps)[ID_RR].amount;   

		// Make more opaque where specular hilite occurs:
		float a_s = MaxRGB(ip.specIllum);
		if (a_s>1.0f) a_s = 1.0f; 
		sc.out.c = opac*ip.diffIllum + ip.specIllum;
	   	opac = opac + a_s - opac*a_s;

		// Evaluate refraction map, filtered by filter color.
		Texmap *refrmap = (*maps)[ID_RR].map;
		AColor rcol;
		sc.SetIOR(ioRefract);
		if (refrmap->HandleOwnViewPerturb()) 
			rcol = refrmap->EvalColor(sc);
		else  
			rcol = sc.EvalEnvironMap(refrmap, sc.RefractVector(ioRefract));
		sc.out.c += Color(rcol.r,rcol.g,rcol.b)*TranspColor(sc, opac, ip.diff);
		sc.out.t.Black();  // no transparency when doing refraction
		}
	else {
		if (opac!=1.0f||opfall!=0.0f) {
			if (opfall!=0.0f) {	
				float d = (float)fabs(DotProd(ip.N,ip.V));
				if (flags&STDMTL_FALLOFF_OUT) d = 1.0f-d;
				opac *= (1.0f-opfall*d);
				}
			
			// Make more opaque where specular hilite occurs, so you
			// can still see the hilite:
			float a_s = MaxRGB(ip.specIllum);
			if (a_s>1.0f) a_s = 1.0f; 
			sc.out.c = opac*ip.diffIllum + ip.specIllum;
		   	opac = opac + a_s - opac*a_s;

			// Compute the color of the transparent filter color
			sc.out.t = TranspColor(sc, opac, ip.diff);
			}
		else {
			sc.out.t = blackCol;
			sc.out.c = ip.diffIllum + ip.specIllum;
			}
		}

	// Evaluate reflection map.
	if (DOMAP(ID_RL)) {
		AColor rcol;
		Texmap *reflmap = (*maps)[ID_RL].map;
		if (reflmap->HandleOwnViewPerturb()) {
			sc.TossCache(reflmap);
			rcol = reflmap->EvalColor(sc);
			}
		else 
			rcol = sc.EvalEnvironMap(reflmap, sc.ReflectVector());
		Color rc(rcol.r,rcol.g,rcol.b);
		curShader->AffectReflMap(sc,ip,rc);
		float r = rcol.a*(*maps)[ID_RL].amount;
		if (dimReflect) {
			float dimfact = ((1.0f-dimIntens)*Intens(diffIllum0)*dimMult + dimIntens);
			r *= dimfact;
			}
		sc.out.c += (rc*r);
		}
	if (bumped) sc.SetNormal(N0);
	}

float StdMtl::EvalDisplacement(ShadeContext& sc) {
	if (DOMAP(ID_DP))
		return (*maps)[ID_DP].EvalMono(sc);
	else return 0.0f; 
	}

Interval StdMtl::DisplacementValidity(TimeValue t) {
	if (MAPACTIVE(ID_DP)) { 
		Interval iv;
		iv.SetInfinite();
		maps->txmap[ID_DP].Update(t,iv);
		return iv;
		}
	else 
		return FOREVER;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\rgbmult.cpp ===
/**********************************************************************
 *<
	FILE: RGBMULT.CPP

	DESCRIPTION: RGBMULT Composite.

	CREATED BY: Dan Silva

	HISTORY: 12/3/98 Updated to Param Block2 Peter Watje

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

#define NSUBTEX 2    // number of texture map slots
#define NCOLS 2

static Class_ID rgbmultClassID(RGBMULT_CLASS_ID,0);

static int subTexId[NSUBTEX] = { IDC_MULT_TEX1, IDC_MULT_TEX2 };

#define ALPHA_FROM_1 0
#define ALPHA_FROM_2 1
#define ALPHA_FROM_MULT 2

//--------------------------------------------------------------
// RGBMult: A Composite texture map
//--------------------------------------------------------------
class RGBMult: public Texmap { 
	public:
	BOOL Param1;
	IParamBlock2 *pblock;   // ref #0
	Texmap* subTex[NSUBTEX];  // refs 1,2;
	BOOL mapOn[NSUBTEX];
	Color col[NCOLS];
	Interval ivalid;
	int alphaFrom;
	BOOL rollScroll;
	BOOL loadingOld;
		RGBMult();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void NotifyChanged();

		void SetColor(int i, Color c, TimeValue t);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return rgbmultClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_RGBMULT); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return NSUBTEX+1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return NSUBTEX+1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int RemapRefOnLoad(int iref); 

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock


	};

class RGBMultClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new RGBMult; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_RGBMULT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return rgbmultClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COMP;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("rgbMult"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static RGBMultClassDesc maskCD;

ClassDesc* GetRGBMultDesc() { return &maskCD;  }

enum { rgbmult_params };  // pblock ID
// rgbmult_params param IDs
enum 
{ 
	rgbmult_color1, rgbmult_color2,
	rgbmult_map1, rgbmult_map2,		
	rgbmult_map1_on, rgbmult_map2_on, // main grad params 
	rgbmult_type,
};


static ParamBlockDesc2 rgbmult_param_blk ( rgbmult_params, _T("parameters"),  0, &maskCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_RGBMULT, IDS_DS_RGBMULTPARAMS, 0, 0, NULL, 
	// params
	rgbmult_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_MULT_COL1, 
		end,
	rgbmult_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(0.5,0.5,0.5), 
		p_ui,			TYPE_COLORSWATCH, IDC_MULT_COL2, 
		end,
	rgbmult_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		1,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MULT_TEX1,
		end,
	rgbmult_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP2,
		p_refno,		2,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_MULT_TEX2,
		end,
	rgbmult_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	rgbmult_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	rgbmult_type, _T("alphaFrom"), TYPE_INT,				0,				IDS_PW_ALPHAFROM,
		p_default,		2,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 3, IDC_MULT_ALPHA1, IDC_MULT_ALPHA2, IDC_MULT_ALPHA3,
		end,

	end
);


//-----------------------------------------------------------------------------
//  RGBMult
//-----------------------------------------------------------------------------
#define NPARAMS 2

static int name_id[NPARAMS] = {IDS_DS_COLOR1, IDS_DS_COLOR2};

#define RGBMULT_VERSION 2
static ParamBlockDescID pbdesc[NPARAMS] = {
	{ TYPE_RGBA, NULL, TRUE,rgbmult_color1 },  // col1
	{ TYPE_RGBA, NULL, TRUE,rgbmult_color2 }   // col2
	};

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,2,1),	// Version 1 params
};


void RGBMult::Init() {
	ivalid.SetEmpty();
	alphaFrom = ALPHA_FROM_MULT;
	SetColor(0, Color(1.0f,1.0f,1.0f), TimeValue(0));
	SetColor(1, Color(1.0f,1.0f,1.0f), TimeValue(0));
	mapOn[0] = mapOn[1] = 1;
	}

void RGBMult::Reset() {
	maskCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(1);	// get rid of maps
	DeleteReference(2);	// get rid of maps
	Init();
	}

void RGBMult::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

RGBMult::RGBMult() {
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	pblock = NULL;
	maskCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}


static AColor white(1.0f,1.0f,1.0f,1.0f);

AColor RGBMult::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	AColor c0 = (subTex[0]&&mapOn[0])? subTex[0]->EvalColor(sc): col[0];
	AColor c1 = (subTex[1]&&mapOn[1])? subTex[1]->EvalColor(sc): col[1];
	AColor c;
	c.r = c0.r*c1.r;
	c.g = c0.g*c1.g;
	c.b = c0.b*c1.b;
	switch(alphaFrom) {
		case ALPHA_FROM_1: c.a = c0.a; break;
		case ALPHA_FROM_2: c.a = c1.a; break;
		case ALPHA_FROM_MULT: c.a = c0.a*c1.a; break;
		}
	return c;
	}

float RGBMult::EvalMono(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	float m = (subTex[1]&&mapOn[1])? subTex[1]->EvalMono(sc): Intens(col[0]);
	float c0 = (subTex[0]&&mapOn[0])? subTex[0]->EvalMono(sc): Intens(col[1]);
	return m*c0;
	}

Point3 RGBMult::EvalNormalPerturb(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	Point3 p0  = subTex[0]&&mapOn[0]? subTex[0]->EvalNormalPerturb(sc): Point3(0.0f,0.0f,0.0f);
	Point3 p1  = subTex[1]&&mapOn[1]? subTex[1]->EvalNormalPerturb(sc): Point3(0.0f,0.0f,0.0f);
	return p0+p1;
	}

RefTargetHandle RGBMult::Clone(RemapDir &remap) {
	RGBMult *mnew = new RGBMult();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+1,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	mnew->alphaFrom = alphaFrom;
	return (RefTargetHandle)mnew;
	}

ParamDlg* RGBMult::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	IAutoMParamDlg* masterDlg = maskCD.CreateParamDlgs(hwMtlEdit, imp, this);
	return masterDlg;

	}

void RGBMult::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( rgbmult_map1_on, 0, mapOn[0]);
		pblock->SetValue( rgbmult_map2_on, 0, mapOn[1]);
		pblock->SetValue( rgbmult_type, 0, alphaFrom);
		Param1 = FALSE;
		}

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( rgbmult_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( rgbmult_color2, t, col[1], ivalid );

		pblock->GetValue( rgbmult_map1_on, t, mapOn[0], ivalid );
		pblock->GetValue( rgbmult_map2_on, t, mapOn[1], ivalid );
		pblock->GetValue( rgbmult_type, t, alphaFrom, ivalid );


		col[1].ClampMinMax();
		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}

void RGBMult::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	int id = i==0?rgbmult_color1:rgbmult_color2;
	pblock->SetValue( id, t, c);
	}

RefTargetHandle RGBMult::GetReference(int i) {
	if (i==0) return pblock;
	else return subTex[i-1];
	}

int RGBMult::RemapRefOnLoad(int iref) { 
	if (loadingOld)  
		return iref+1;
	else return iref;
	}

void RGBMult::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-1] = (Texmap *)rtarg; break;
		} 
	}

void RGBMult::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+1,m);
	if (i==0)
		{
		rgbmult_param_blk.InvalidateUI(rgbmult_map1);
		ivalid.SetEmpty();
		}	
	else if (i==1)
		{
		rgbmult_param_blk.InvalidateUI(rgbmult_map2);
		ivalid.SetEmpty();
		}	

	}

TSTR RGBMult::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* RGBMult::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: return subTex[i-1]; 
		}
	}

TSTR RGBMult::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-1);
		}
	}

RefResult RGBMult::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock) 
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
				rgbmult_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define INVERT_RGBMULT_CHUNK 0x2000
#define ALPHA_FROM_CHUNK 0x2010
#define RGBMULT_VERSION_CHUNK  0x2020
#define PARAM2_CHUNK  0x2030

IOResult RGBMult::Save(ISave *isave) { 
	IOResult res;
	ULONG nb;

	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	int vers = RGBMULT_VERSION;
	isave->BeginChunk(RGBMULT_VERSION_CHUNK);
	isave->Write(&vers,sizeof(vers),&nb);			
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}	
	  
class RGBMultPostLoad : public PostLoadCallback {
	public:
		RGBMult *tm;
		RGBMultPostLoad(RGBMult *b) {tm=b;}
		void proc(ILoad *iload) {  tm->loadingOld = FALSE; delete this; } 
	};

class RGBMult2PostLoad : public PostLoadCallback {
	public:
		RGBMult *n;
		RGBMult2PostLoad(RGBMult *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->Param1)
				{
				n->pblock->SetValue( rgbmult_map1_on, 0, n->mapOn[0]);
				n->pblock->SetValue( rgbmult_map2_on, 0, n->mapOn[1]);
				n->pblock->SetValue( rgbmult_type, 0, n->alphaFrom);
				}
			delete this; 


			} 
	};



IOResult RGBMult::Load(ILoad *iload) { 
	ULONG nb;
	IOResult res;
	int id;
	loadingOld = TRUE;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case PARAM2_CHUNK:
				Param1= FALSE;
				break;
			case RGBMULT_VERSION_CHUNK:
				loadingOld = FALSE;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
			case ALPHA_FROM_CHUNK:
				res = iload->Read(&alphaFrom,sizeof(alphaFrom), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	if (loadingOld) 
		iload->RegisterPostLoadCallback(new RGBMultPostLoad(this));

	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &rgbmult_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

//	iload->RegisterPostLoadCallback(new RGBMult2PostLoad(this));



	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\TexMaps.h ===
//-----------------------------------------------------------------------------
//  Texmaps
//-----------------------------------------------------------------------------

#define MAPACTIVE(i) ((*maps)[i].IsActive())
#define MAX_TEXTURE_CHANNELS	32


class TexmapSlot {
	public:
		float amount;
		Control *amtCtrl;  // ref to controller
		Texmap	*map;       // ref to map
		BOOL	mapOn;
		TSTR	name;

		TexmapSlot();
		RGBA Eval(ShadeContext& sc) { 
			return amount * map->EvalColor(sc); 
			}
		float EvalMono(ShadeContext& sc) { 
			return amount * map->EvalMono(sc); 
			}
		float LerpEvalMono(ShadeContext& sc, float v) {
			if( amount<0.0f ){
				float b = 1.0f + amount;
				if ( b < 0.0f ) b = 0.0f;
				return -amount * (1.0f - map->EvalMono(sc)) + b*v; 
			} else {
				float b = 1.0f - amount;
				if ( b < 0.0f ) b = 0.0f;
				return amount * map->EvalMono(sc) + b*v; 
			}
//			float b = 1.0f - (amount<0.0f ? -amount : amount);
//			if ( b < 0.0f ) b = 0.0f;
//			return amount * map->EvalMono(sc) + b*v; 
		}
		Point3 EvalNormalPerturb(ShadeContext &sc) {
			return amount * map->EvalNormalPerturb(sc); 
			}
		BOOL IsActive() { return (map&&mapOn&&(amtCtrl||amount!=0.0f)); }
		void Update(TimeValue t, Interval &ivalid);				
		float GetAmount(TimeValue t);
};


class Texmaps: public TexmapContainer {
	public:  
		MtlBase *client;
		TexmapSlot txmap[32];
		BOOL loadingOld;

		Texmaps();
		Texmaps(MtlBase *mb);
		void SetClientPtr(MtlBase *mb) { client = mb; }
		TexmapSlot& operator[](int i) { return txmap[i]; }

		Class_ID ClassID();

		void DeleteThis();
		RefTargetHandle Clone(RemapDir &remap = NoRemap());	
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		void RescaleWorldUnits(float f);

		BOOL AssignController(Animatable *control,int subAnim) {
			ReplaceReference(SubNumToRefNum(subAnim),(ReferenceTarget *)control);
			return TRUE;
			}

		int NumSubs();
	    Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum; }
		BOOL InvisibleProperty() { return TRUE; }  // maps are made visible in scripter by pb_maps paramblock in the material so don't expose them as a subanim
		
//		int NumRefs() { return STD2_NMAX_TEXMAPS*2; }
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void SetName( long i, TSTR& nm ){txmap[i].name = nm; } 
		TSTR& GetName( long i ){return txmap[i].name; } 
		SvGraphNodeReference SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags);
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\TexMaps.cpp ===
//-----------------------------------------------------------------------------
//  Texmaps
//-----------------------------------------------------------------------------
#include	"mtlhdr.h"
#include	"mtlres.h"
#include	"shaders.h"
#include	"texmaps.h"
#include	"iparamm2.h"

#define MAX_TEXTURE_CHANNELS	32


#define TEXMAPS_CLASS_ID 0x001200

static Class_ID TexmapsClassID(TEXMAPS_CLASS_ID, 0);

class OldTexmapsClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { 	return new Texmaps(NULL); }
	const TCHAR *	ClassName() { return GetString(IDS_DS_CLASSTEXMAPS); }
	SClass_ID		SuperClassID() { return REF_MAKER_CLASS_ID; }
	Class_ID 		ClassID() { return TexmapsClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};


class TexmapsClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { 	return new Texmaps(NULL); }
	const TCHAR *	ClassName() { return GetString(IDS_DS_CLASSTEXMAPS); }
	SClass_ID		SuperClassID() { return TEXMAP_CONTAINER_CLASS_ID; }
	Class_ID 		ClassID() { return TexmapsClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};

TexmapSlot::TexmapSlot() { 
	amount = 1.0f; 
	map = NULL; 
	mapOn = FALSE; 
	amtCtrl=NULL; 
	}

void TexmapSlot::Update(TimeValue t,Interval& ivalid) {
	if (IsActive()) 
		map->Update(t,ivalid);			
	if (amtCtrl) {
		amtCtrl->GetValue(t,&amount,ivalid);	
		}
	}

float TexmapSlot::GetAmount(TimeValue t) {
	Interval v;
	float f;
	if (amtCtrl) {
		amtCtrl->GetValue(t,&f,v);	
		return f;
		}
	else return amount;
	} 

Texmaps::Texmaps() {
	loadingOld = FALSE;
	client = NULL;
	}

					
Texmaps::Texmaps(MtlBase *mb) {
	loadingOld = FALSE;
	client = mb;
	}

SvGraphNodeReference Texmaps::SvTraverseAnimGraph(IGraphObjectManager *gom, Animatable *owner, int id, DWORD flags)
	{
	int i, nUsedSlots;

	if (!gom->TestFilter(SV_FILTER_MAPS))
		return SvGraphNodeReference();

	nUsedSlots = 0;
	for (i = 0; i < STD2_NMAX_TEXMAPS; i++)
		if (txmap[i].map)
			nUsedSlots++;

	if (nUsedSlots)
		return SvStdTraverseAnimGraph(gom, owner, id, flags);
	else
		return SvGraphNodeReference();
	}

static TexmapsClassDesc texmapsCD;
ClassDesc* GetTexmapsDesc() { return &texmapsCD;  }

static OldTexmapsClassDesc oldtexmapsCD;
ClassDesc* GetOldTexmapsDesc() { return &oldtexmapsCD;  }

Class_ID Texmaps::ClassID() { return TexmapsClassID; }

int Texmaps::NumSubs() { return STD2_NMAX_TEXMAPS*2; }  

int Texmaps::NumRefs() { return STD2_NMAX_TEXMAPS*2; }

Animatable* Texmaps::SubAnim(int i) {
	if (i&1)
		return txmap[i/2].map;
	else 
		return txmap[i/2].amtCtrl;
	}

TSTR Texmaps::SubAnimName(int i) {
	if (i&1)
		return client->GetSubTexmapTVName(i/2);
	else  {
		TSTR nm;
//		nm = GetString(texNameID[i/2]);
//		nm = textureChannelNames[ i/2 ];
		nm = txmap[ i/2 ].name;
		nm += TSTR(" ");
		nm += TSTR(GetString(IDS_DS_AMOUNT));
		return nm;
		}
	}

RefTargetHandle Texmaps::GetReference(int i) {
	if (i&1)
		return txmap[i/2].map;
	else 
		return txmap[i/2].amtCtrl;
	}

void Texmaps::SetReference(int i, RefTargetHandle rtarg) {
	if (loadingOld)
		txmap[i].map = (Texmap*)rtarg;
	else {
		if (i&1)
			txmap[i/2].map = (Texmap*)rtarg;
		else 
			txmap[i/2].amtCtrl = (Control*)rtarg;
		}
	}

void Texmaps::DeleteThis() { delete this;}

RefResult Texmaps::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = defaultDim; 
			break;
			}
		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

void Texmaps::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	// This code will be replaced in particular implementations
	for (int i=0; i<NumRefs(); i++) {
		if ( (i&1) ==0) 
			continue;  // skip the amount controllers
		ReferenceMaker *srm = GetReference(i);
		if (srm) {
			srm->RescaleWorldUnits(f);
			}
		}
		
	}

RefTargetHandle Texmaps::Clone(RemapDir &remap) {
	Texmaps *tm = new Texmaps(NULL);
	for (int i = 0; i<STD2_NMAX_TEXMAPS; i++) {
		tm->txmap[i].amount = txmap[i].amount;
		tm->txmap[i].mapOn = txmap[i].mapOn;
		tm->txmap[i].map = NULL;
		if (txmap[i].amtCtrl) 
			tm->ReplaceReference(2*i,remap.CloneRef(txmap[i].amtCtrl));
		if (txmap[i].map) 
			tm->ReplaceReference(2*i+1,remap.CloneRef(txmap[i].map));
		}
	return tm;
	}

#define TEX_OLD_ONOFF_CHUNK 0x5002
#define TEX_ONOFF_CHUNK 0x5003
#define TEX_AMT0 0x5100
#define TEX_AMT1 0x5101
#define TEX_AMT2 0x5102
#define TEX_AMT3 0x5103
#define TEX_AMT4 0x5104
#define TEX_AMT5 0x5105
#define TEX_AMT6 0x5106
#define TEX_AMT7 0x5107
#define TEX_AMT8 0x5108
#define TEX_AMT9 0x5109
#define TEX_AMTA 0x510A
#define TEX_AMTB 0x510B
#define TEX_AMTC 0x510C
#define TEX_AMTD 0x510D
#define TEX_AMTE 0x510E
#define TEX_AMTF 0x510F

IOResult Texmaps::Save(ISave *isave) { 
	isave->BeginChunk(TEX_ONOFF_CHUNK);
	ULONG nb,f=0;
	for ( int i=0; i<STD2_NMAX_TEXMAPS; i++) 
		if (txmap[i].mapOn) f|= (1<<i);
	isave->Write(&f,sizeof(f),&nb);			
	isave->EndChunk();

	for ( i=0; i<STD2_NMAX_TEXMAPS; i++) {
		if (txmap[i].amount!=1.0f) {
			isave->BeginChunk(TEX_AMT0+i);
			isave->Write(&txmap[i].amount,sizeof(float),&nb);			
			isave->EndChunk();
			}
		}
	return IO_OK;
	}

class TexmapsPostLoad : public PostLoadCallback {
	public:
		Texmaps *tm;
		TexmapsPostLoad(Texmaps *b) {tm=b;}
		void proc(ILoad *iload) {  tm->loadingOld = FALSE; delete this; } 
	};

	
IOResult Texmaps::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case TEX_OLD_ONOFF_CHUNK:
				iload->SetObsolete();
				iload->RegisterPostLoadCallback(new TexmapsPostLoad(this));
				loadingOld = TRUE;
			case TEX_ONOFF_CHUNK:
				{
				ULONG f;
				res = iload->Read(&f,sizeof(f), &nb);
				for (int i=0; i<STD2_NMAX_TEXMAPS; i++) 
				    txmap[i].mapOn = (f&(1<<i))?1:0;
				}
				break;
			case TEX_AMT0: case TEX_AMT1:
			case TEX_AMT2:	case TEX_AMT3:
			case TEX_AMT4:	case TEX_AMT5:
			case TEX_AMT6:	case TEX_AMT7:
			case TEX_AMT8:	case TEX_AMT9:
			case TEX_AMTA:	case TEX_AMTB:
			case TEX_AMTC:	case TEX_AMTD:
			case TEX_AMTE:	case TEX_AMTF:
				res = iload->Read(&txmap[id-TEX_AMT0].amount,sizeof(float), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
                                                      
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\wood.cpp ===
/**********************************************************************
 *<
	FILE:			Wood.cpp

	DESCRIPTION:	Wood 3D Texture map.

	CREATED BY:		Suryan Stalin

	HISTORY:		Modified from Marble.cpp by adding IPAS wood stuff

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

				   
//Includes
#include "mtlhdr.h"
#include "woodres.h"
#include "iparamm2.h"
#include "stdmat.h"
#include "wooddent.h"
#include "wood.h"
#include "macrorec.h"


// JBW: IDs for ParamBlock2 blocks and parameters
// Parameter and ParamBlock IDs
enum { wood_params, };  // pblock ID
// dents_params param IDs
enum 
{ 
	wood_map1,wood_map2,wood_color1,wood_color2,
	wood_map1_on, wood_map2_on, // main grad params 

	wood_thickness,wood_rnoise, wood_anoise,
	wood_coords,
//	wood_seed

};

//externs
extern		HINSTANCE			hInstance;

ParamDlg *Wood::xyzGenDlg;

//Globals
static		WoodClassDesc		woodCD;
static		int					subTexId[NSUBTEX] = { IDC_WOOD_TEX1, IDC_WOOD_TEX2 };
static		ParamBlockDescID	pbdesc[] =	{
											{	TYPE_FLOAT, NULL, TRUE,wood_thickness }, 	// size
											{	TYPE_FLOAT, NULL, TRUE,wood_rnoise }, 	// r1
											{	TYPE_FLOAT, NULL, TRUE,wood_anoise }, 	// r2
											{	TYPE_RGBA, NULL, TRUE,wood_color1 },  // col1
											{	TYPE_RGBA, NULL, TRUE,wood_color2 }   // col2
											};
static		int					nameID[] =	{	IDS_DS_WOODSIZE, 
												IDS_DS_WOODR1, 
												IDS_DS_WOODR2, 
												IDS_DS_COLOR1, 
												IDS_DS_COLOR2 
											};
static		int					colID[2] =	{ IDC_WOOD_COL1, IDC_WOOD_COL2 };
static		Class_ID			woodClassID(WOOD_CLASS_ID,0);
static		float				noiseTable[NOISE_DIM+1][NOISE_DIM+1][NOISE_DIM+1];
static      int					noiseInited = 0;
// Array of old versions
static ParamVersionDesc versions[1] = {
	ParamVersionDesc(pbdesc,5,1)	
	};
// per instance gradient block
static ParamBlockDesc2 wood_param_blk ( wood_params, _T("parameters"),  0, &woodCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_WOOD, IDS_DS_WOOD_PARAMS, 0, 0, NULL, 
	// params
	wood_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_WOOD_TEX1,
		end,
	wood_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_WOOD_TEX2,
		end,
	wood_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR1,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_WOOD_COL1, 
		end,
	wood_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COLOR2,	
		p_default,		Color(1,1,1), 
		p_ui,			TYPE_COLORSWATCH, IDC_WOOD_COL2, 
		end,
	wood_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	wood_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP2ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,

	wood_thickness,	_T("thickness"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WOODSIZE,
		p_default,		7.0,
		p_range,		0.0, 999999999.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_WOODSIZE_EDIT, IDC_WOODSIZE_SPIN, 1.0f,
		end,
	wood_rnoise,	_T("radialNoise"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WOODR1,
		p_default,		1.0,
		p_range,		0.0, 100.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,  IDC_R1_EDIT, IDC_R1_SPIN, 1.0f,
		end,
	wood_anoise,	_T("axialNoise"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WOODR2,
		p_default,		1.0f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT,   IDC_R2_EDIT, IDC_R2_SPIN, 1.0f,
		end,
	wood_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_DS_COORDINATES,
		p_refno,		0, 
		end,
//	wood_seed,	_T("seed"),   TYPE_INT,			0,	IDS_PW_SEED,
//		p_default,		65432,
//		p_range,		0, 99999999,
//		p_ui, 			TYPE_SPINNER, EDITTYPE_INT,   IDC_WOODSEED_EDIT, IDC_WOODSEED_SPIN, 1.0f,
//		end,

	end
);

//Class Implementations

//dialog stuff to get the Set Ref button
class WoodDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Wood *wood;		
		WoodDlgProc(Wood *m) {wood = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			wood = (Wood*)m;
			}
	};



BOOL WoodDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_WOOD_SWAP:
					{
					wood->SwapInputs();
					}
				}
			break;
		}
	return FALSE;
	}


//  Wood
Wood::Wood() 
	{
	Param1 = FALSE;
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
	seed = 0;
	InitNoise();
	woodCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	vers = 0;
	}

void Wood::Init() 
	{
	if (xyzGen) xyzGen->Reset();
	else ReplaceReference( 0, GetNewDefaultXYZGen());	
	ivalid.SetEmpty();
	SetColor(0, Color(0.79f,0.69f,0.27f), TimeValue(0));
	SetColor(1, Color(0.51f,0.32f,0.05f), TimeValue(0));
	SetSize(7.0f, TimeValue(0));
	SetR1(1.0f, TimeValue(0));
	SetR2(1.0f, TimeValue(0));
	for (int i=0; i<NSUBTEX; i++) mapOn[i] = TRUE;
	}

void Wood::Reset() 
	{
	woodCD.Reset(this, TRUE); // reset pb2 params
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

void Wood::NotifyChanged() 
{
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

Class_ID Wood::ClassID() 
{	
	return woodClassID; 
}

RefTargetHandle Wood::Clone(RemapDir &remap) 
{
	Wood *mnew = new Wood();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(xyzGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];
	mnew->r1 = r1;
	mnew->r2 = r2;
	mnew->size = size;
//	mnew->seed = seed;
//	mnew->InitNoise();
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
}

ParamDlg* Wood::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) 
{
	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = woodCD.CreateParamDlgs(hwMtlEdit, imp, this);
// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
//attach a dlg proc to handle the swap button 
	wood_param_blk.SetUserDlgProc(new WoodDlgProc(this));

	return masterDlg;

}

BOOL Wood::SetDlgThing(ParamDlg* dlg)
{
	// PW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if (dlg == xyzGenDlg)
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}

void Wood::ReadSXPData(TCHAR *name, void *sxpdata) 
{
	WoodState *state = (WoodState*)sxpdata;
	if (state->version==WOOD_VERS) {
		SetColor(0, ColrFromCol24(state->col1),0);
		SetColor(1, ColrFromCol24(state->col2),0);
		SetR1(state->r1,0);
		SetR2(state->r2,0);
		SetSize(state->size,0);
		}
}

void Wood::Update(TimeValue t, Interval& valid) 
{		

/*	if (Param1)
		{
		pblock->SetValue(wood_map1_on,t,mapOn[0]);
		pblock->SetValue(wood_map2_on,t,mapOn[1]);
		pblock->SetValue(wood_seed,t,seed);
		Param1 = FALSE;
		}
*/

	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		xyzGen->Update(t,ivalid);
		pblock->GetValue( wood_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( wood_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( wood_rnoise, t, r1, ivalid );
		pblock->GetValue( wood_anoise, t, r2, ivalid );
		pblock->GetValue( wood_thickness, t, size, ivalid );
		pblock->GetValue( wood_map1_on, t, mapOn[0], ivalid );
		pblock->GetValue( wood_map2_on, t, mapOn[1], ivalid );

//		int rseed =-9876545;
//		pblock->GetValue( wood_seed, t, rseed, ivalid );
//		if (rseed != seed)
//			{
//			seed = rseed;
//			InitNoise();
//			}
//		else seed = rseed;
//
		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
}


void Wood:: SetColor(int i, Color c, TimeValue t) 
{
//    col[i] = c;
	col[i].r = c.r;
	col[i].g = c.g;
	col[i].b = c.b;
	pblock->SetValue( i==0?wood_color1:wood_color2, t, c);
}

void Wood::SwapInputs() 
{
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(wood_color1,0,wood_color2,0);
	wood_param_blk.InvalidateUI(wood_color1);
	wood_param_blk.InvalidateUI(wood_color2);
	wood_param_blk.InvalidateUI(wood_map1);
	wood_param_blk.InvalidateUI(wood_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);

}

void Wood::SetR1(float f, TimeValue t) 
{ 
	r1 = f; 
	pblock->SetValue( wood_rnoise, t, f);
}

void Wood::SetR2(float f, TimeValue t) 
{ 
	r2 = f; 
	pblock->SetValue( wood_anoise, t, f);
}

void Wood::SetSize(float f, TimeValue t) 
{ 
	size = f; 
	pblock->SetValue( wood_thickness, t, f);
}

RefTargetHandle Wood::GetReference(int i) 
{
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
		}
}

void Wood::SetReference(int i, RefTargetHandle rtarg) 
{
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
}

void Wood::SetSubTexmap(int i, Texmap *m) 
{
	ReplaceReference(i+2,m);
	if (i==0)
		{
		wood_param_blk.InvalidateUI(wood_map1);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		wood_param_blk.InvalidateUI(wood_map2);
		ivalid.SetEmpty();
		}

}

TSTR Wood::GetSubTexmapSlotName(int i) 
{
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_COLOR1)); 
		case 1:  return TSTR(GetString(IDS_DS_COLOR2)); 
		default: return TSTR(_T(""));
		}
}
	 
Animatable* Wood::SubAnim(int i) 
{
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
		}
}

TSTR Wood::SubAnimName(int i) 
{
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_COORDINATES));		
		case 1: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-2);
		}
}


RefResult Wood::NotifyRefChanged(	Interval changeInt, RefTargetHandle hTarget, 
									PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock ) 
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//			if (hTarget != xyzGen  && hTarget != pblock ) 
				wood_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}
			if (hTarget == xyzGen ) 
				{
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
}

#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Wood::Save(ISave *isave) 
{ 
//	ULONG nb;
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

//	isave->BeginChunk(WOOD_NOISE_CHUNK);
//	isave->Write(&seed,sizeof(int),&nb);			
//	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	
	return IO_OK;
}	

class WoodPostLoad : public PostLoadCallback 
{
	public:
		Wood *chk;
		WoodPostLoad(Wood *b) {chk=b;}
		void proc(ILoad *iload) {
			if (chk->vers<1) {
				if (chk->pblock) 
					chk->pblock->RescaleParam(wood_thickness, 0, 100.0f);
//					ScaleFloatController(chk->pblock, PB_SIZE, 100.0f);
//				iload->SetObsolete();
				}
			delete this;
			}
};
	  
//watje

class Wood2PostLoadCallback:public  PostLoadCallback
{
public:
	Wood      *s;
	int Param1;
	Wood2PostLoadCallback(Wood *r, BOOL b) {s=r;Param1 = b;}
	void proc(ILoad *iload);
};

void Wood2PostLoadCallback::proc(ILoad *iload)
{
	if (Param1)
		{
		TimeValue t  = 0;
		s->pblock->SetValue(wood_map1_on,t,s->mapOn[0]);
		s->pblock->SetValue(wood_map2_on,t,s->mapOn[1]);
//		s->pblock->SetValue(wood_seed,t,s->seed);
		Param1 = FALSE;
		}

//	Interval ivalid;
//	s->pblock->GetValue( wood_seed, 0, s->seed, ivalid );
//	s->InitNoise();

	delete this;
}


IOResult Wood::Load(ILoad *iload) 
{ 
//	ULONG		nb;
	IOResult res;
	int id;
	vers = 0;
	Param1 = TRUE;

	while (IO_OK==(res=iload->OpenChunk())) 
	{
		switch(id = iload->CurChunkID())  
		{
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case WOODVERS1_CHUNK:
				vers = 1;

				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;

#if 0
			case WOOD_NOISE_CHUNK:
				iload->Read(&seed,sizeof(int),&nb);			
//				InitNoise();
				break;
#endif
			case PARAM2_CHUNK:
				Param1 = FALSE;
				break;

			
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (Param1)
		{
		ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &wood_param_blk, this, 1);
		iload->RegisterPostLoadCallback(plcb);
		}
	Wood2PostLoadCallback* wood2plcb = new Wood2PostLoadCallback(this,Param1);
	iload->RegisterPostLoadCallback(wood2plcb);

	return IO_OK;
}

void Wood::InitNoise()
{
//	if(!seed)
//		seed = rand()+1;
	if (!noiseInited) {
		noiseInited = 1;
		srand(65432);
		int i, j, k, ii, jj, kk;
		for (i=0; i<=NOISE_DIM; i++)
			for (j=0; j<=NOISE_DIM; j++)
				for (k=0; k<=NOISE_DIM; k++)
				{
					noiseTable[i][j][k] = (float)(rand()&0x7FFF);
					ii = (i==NOISE_DIM)?0:i; 
					jj = (j==NOISE_DIM)?0:j; 
					kk = (k==NOISE_DIM)?0:k; 
					noiseTable[i][j][k] = noiseTable[ii][jj][kk];
				}
		}
}

float Wood::WoodNoise(float x)
{
   int ix;
   double fx, mx;
   double n0, n1;
   mx = fmod((double)x, FNOISE_DIM); 
   if (mx<0) mx += FNOISE_DIM;
   ix = (int)mx;
   fx = fmod(mx, 1.0);
   n0 = noiseTable[ix][0][0];
   n1 = noiseTable[ix+1][0][0];

   return (float)((n0+fx*(n1-n0))/32768.0);
}

/*
float noise(float x, float y, float z)
{
   int ix, iy, iz;
   float fx, fy, fz, mx, my, mz;
   float n, n00, n01, n10, n11, n0, n1;
   mx = fmod(x, FNOISE_DIM); if (mx<0) mx += FNOISE_DIM;
   my = fmod(y, FNOISE_DIM); if (my<0) my += FNOISE_DIM;
   mz = fmod(z, FNOISE_DIM); if (mz<0) mz += FNOISE_DIM;
   ix = (int)mx;
   iy = (int)my;
   iz = (int)mz;
   fx = fmod(mx, 1.0);
   fy = fmod(my, 1.0);
   fz = fmod(mz, 1.0);
   n = noise_table[ix][iy][iz];
   n00 = n + fx*(noise_table[ix+1][iy][iz]-n);
   n = noise_table[ix][iy][iz+1];
   n01 = n + fx*(noise_table[ix+1][iy][iz+1]-n);
   n = noise_table[ix][iy+1][iz];
   n10 = n + fx*(noise_table[ix+1][iy+1][iz]-n);
   n = noise_table[ix][iy+1][iz+1];
   n11 = n + fx*(noise_table[ix+1][iy+1][iz+1]-n);
   n0 = n00 + fy*(n10-n00);
   n1 = n01 + fy*(n11-n01);
   return(((float)(n0+fz*(n1-n0)))/32768.0);
}

*/

void Wood::LerpColor(RGBA *c, RGBA *a, RGBA *b, float f)
{
   int alph, ialph;
   
   if (f>1.0) f = 1.0f;
   alph = (int)(4096*f);
   ialph = 4096-alph;

   c->r = (float)(((int)(ialph*a->r + alph*b->r)*255)>>12);
   c->g = (float)(((int)(ialph*a->g + alph*b->g)*255)>>12);
   c->b = (float)(((int)(ialph*a->b + alph*b->b)*255)>>12);
   
   c->r /= 255.0f;
   c->g /= 255.0f;
   c->b /= 255.0f;

}

/* smooth step function with hermite interpolation*/
float Wood::SmoothStep(float x0, float x1, float v)
{
   if (v<=x0) return(0.0f);
   else if (v>=x1) return(1.0f);
   else {
      float u = (v-x0)/(x1-x0);
      return(u*u*(3-2*u));
   }
}

float Wood::WoodFunc(Point3 p) {
	float r;
	float px = p.x/size;
	float py = p.y/size;
	float pz = p.z/size;
	px += WoodNoise(px)*r1;
	py += WoodNoise(py)*r1;
	pz += WoodNoise(pz)*r1;
	r = (float) sqrt(py*py+pz*pz);
	r += WoodNoise(r)+r2*WoodNoise(px/4.0f);
	r = (float)fmod((double)r, 1.0); /* be periodic */
	r = SmoothStep(0.0f, 0.8f, r) - SmoothStep(0.83f, 1.0f, r);
	return(r);	
	}

static AColor black(0.0f,0.0f,0.0f,0.0f);

RGBA Wood::EvalColor(ShadeContext& sc) 
{
	Point3	p,dp;
	RGBA	c;
	if (!sc.doMaps) return black;
	if (gbufID) sc.SetGBufferID(gbufID);
	
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
//	p *= FACT/size;

	float d = WoodFunc(p);
	
	if (d<=.0005f) 
		return  (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	else 
		if (d>=.9995) 
			return  (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];
	c = (1.0f-d)*c0 + d*c1;
	return c;
}

Point3 Wood::EvalNormalPerturb(ShadeContext& sc) 
{
	float del,d;
	Point3 p,dp;
	
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	if (size==0.0f) size=.0001f;
//	p *= FACT/size;

	d = WoodFunc(p);
//	del = 20.0f;
	del = 0.1f;
	Point3 np;
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = (WoodFunc(p+del*M[0]) - d)/del;
	np.y = (WoodFunc(p+del*M[1]) - d)/del;
	np.z = (WoodFunc(p+del*M[2]) - d)/del;
//	return np*100.0f;
	return sc.VectorFromNoScale(np,REF_OBJECT);
	}

//WoodClassDesc
Class_ID WoodClassDesc::ClassID() 
{ 
	return woodClassID; 
}
ClassDesc* GetWoodDesc()		{ return &woodCD;  }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\vertcol.cpp ===
/**********************************************************************
 *<
	FILE: VERTCOL.CPP

	DESCRIPTION: Return interpolated vertex color

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"

extern HINSTANCE hInstance;

static LRESULT CALLBACK CurveWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );



static Class_ID vcolClassID(VCOL_CLASS_ID,0);


class VCol;

class VColDlg: public ParamDlg {
	public:
		HWND hwmedit;	 // window handle of the materials editor dialog
		IMtlParams *ip;
		VCol *theTex;	 // current VCol being edited.
		HWND hPanel; // Rollup pane
		TimeValue curTime; 
		int isActive;
		BOOL valid;

		//-----------------------------
		VColDlg(HWND hwMtlEdit, IMtlParams *imp, VCol *m); 
		~VColDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

		void LoadDialog(BOOL draw);  // stuff params into dialog
		void ReloadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void ActivateDlg(BOOL onOff);
		void Invalidate() { valid = FALSE;	InvalidateRect(hPanel,NULL,0); }

		// methods inherited from ParamDlg:
		Class_ID ClassID() {return vcolClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theTex; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);
	};



//--------------------------------------------------------------
// VCol: A Composite texture map
//--------------------------------------------------------------
class VCol: public Texmap { 
	friend class VColDlg;
	VColDlg *paramDlg;
	Interval ivalid;
	BOOL useUVW;
	public:
		VCol();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		ULONG Requirements(int subMtlNum) { return useUVW?MTLREQ_UV:MTLREQ_UV2; }
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }
		void NotifyChanged();

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		Class_ID ClassID() {	return vcolClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_VCOL); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 0; }  

		// From ref
 		int NumRefs() { return 0; }

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

	};

class VColClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new VCol; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_VCOL_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return vcolClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COLMOD;  }
	};

static VColClassDesc vcolCD;

ClassDesc* GetVColDesc() { return &vcolCD;  }

static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	VColDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (VColDlg*)lParam;
		theDlg->hPanel = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (VColDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->PanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

VColDlg::VColDlg(HWND hwMtlEdit, IMtlParams *imp, VCol *m) { 
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanel = NULL;
	theTex = m; 
	isActive = 0;
	valid = FALSE;
	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_VCOL1),
		PanelDlgProc, 
		GetString(IDS_DS_VCOLPARAMS), 
		(LPARAM)this );		
	curTime = imp->GetTime();
	}

void VColDlg::ReloadDialog() {
	Interval valid;
	theTex->Update(curTime, valid);
	LoadDialog(FALSE);
	}

void VColDlg::SetTime(TimeValue t) {
	Interval valid;
	if (t!=curTime) {
		curTime = t;
		theTex->Update(curTime, valid);
		LoadDialog(FALSE);
		InvalidateRect(hPanel,NULL,0);
		}
	}

VColDlg::~VColDlg() {
	theTex->paramDlg = NULL;
	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	}


BOOL VColDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			ShowWindow(GetDlgItem(hwndDlg,IDC_VC_VC),SW_HIDE);
			ShowWindow(GetDlgItem(hwndDlg,IDC_VC_UVW),SW_HIDE);
//			CheckRadioButton( hwndDlg, IDC_VC_VC, IDC_VC_UVW, IDC_VC_VC+theTex->useUVW);
			return TRUE;
			}
			break;
		case WM_COMMAND:  

//		    switch (id) {
//				case IDC_VC_VC:
//				case IDC_VC_UVW:
//					CheckRadioButton( hwndDlg, IDC_VC_VC, IDC_VC_UVW, id);
//					theTex->useUVW = id-IDC_VC_VC;
//					theTex->NotifyChanged();
//					break;
//				}
			break;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			break;
		case WM_CLOSE: 	break;       
		case WM_DESTROY:  	break;
		case CC_SPINNER_CHANGE: 
			break;
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			theTex->NotifyChanged();
		    UpdateMtlDisplay();
			break;

    	}
	return FALSE;
	}


void VColDlg::LoadDialog(BOOL draw) {
	if (theTex) {
		Interval valid;
		theTex->Update(curTime,valid);
//		CheckRadioButton( hPanel, IDC_VC_VC, IDC_VC_UVW, IDC_VC_VC+theTex->useUVW);
		}
	}

void VColDlg::SetThing(ReferenceTarget *m) {
	assert (m->ClassID()==vcolClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
	if (theTex) theTex->paramDlg = NULL;
	theTex = (VCol *)m;
	if (theTex) theTex->paramDlg = this;
	LoadDialog(TRUE);
	}

void VColDlg::ActivateDlg(BOOL onOff) {
	}


//-----------------------------------------------------------------------------
//  VCol
//-----------------------------------------------------------------------------

#define VCOL_VERSION 1


void VCol::Reset() {
	useUVW = FALSE;
	ivalid.SetEmpty();
	}

void VCol::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

VCol::VCol() {
	paramDlg = NULL;
	Reset();
	}

AColor VCol::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
//	Point3 p = sc.UVW(1-useUVW);
	Point3 p = sc.UVW(0);
	return AColor(p.x,p.y,p.z,1.0f);
	}

float VCol::EvalMono(ShadeContext& sc) {
	return Intens(EvalColor(sc));
	}

Point3 VCol::EvalNormalPerturb(ShadeContext& sc) {
	return Point3(0,0,0);
	}

RefTargetHandle VCol::Clone(RemapDir &remap) {
	VCol *mnew = new VCol();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	return (RefTargetHandle)mnew;
	}

ParamDlg* VCol::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	VColDlg *dm = new VColDlg(hwMtlEdit, imp, this);
	dm->LoadDialog(TRUE);	
	paramDlg = dm;
	return dm;	
	}


void VCol::Update(TimeValue t, Interval& valid) {		
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		}
	valid &= ivalid;
	}


RefResult VCol::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
//			if (paramDlg&&!paramDlg->isActive) 
			if (paramDlg) 
					paramDlg->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
//			gpn->name= TSTR(GetString(name_id[gpn->index]));
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define USE_UVW_CHUNK 0x5000

IOResult VCol::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();
	if (useUVW) {
		isave->BeginChunk(USE_UVW_CHUNK);
		isave->EndChunk();
		}
	return IO_OK;
	}	
	  

IOResult VCol::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
//			case USE_UVW_CHUNK:
//				useUVW = TRUE;
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\wooddent.h ===
/**********************************************************************
 *<
	FILE:			wooddent.h

	DESCRIPTION:	DLL Main for wood and dent 3D textures

	CREATED BY:		Suryan Stalin

	HISTORY:		Modified from mtlmain.cpp, 4th April 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __WOODDENT__H
#define __WOODDENT__H


struct	Col24	{	ULONG	r,g,b; };

extern	void	ScaleFloatController(IParamBlock *pblock, int index, float s);
extern  Color	ColrFromCol24(Col24 a); 
extern  TCHAR	*GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\tint.cpp ===
/**********************************************************************
 *<
	FILE: TINT.CPP

	DESCRIPTION: TINT Composite.

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "mtlres.h"
#include "stdmat.h"
#include "iparamm2.h"

extern HINSTANCE hInstance;

static LRESULT CALLBACK CurveWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );

#define NSUBTEX 1    // number of texture map slots
#define NCOLS 3      // number of color swatches

static Class_ID tintClassID(TINT_CLASS_ID,0);


//--------------------------------------------------------------
// Tint: A Composite texture map
//--------------------------------------------------------------
class Tint: public MultiTex { 
	friend class TintPostLoad;
	Color col[NCOLS];
	Texmap* subTex[NSUBTEX];  // More refs
	Interval ivalid;
	BOOL rollScroll;
	public:
		BOOL Param1;
		BOOL mapOn[NSUBTEX];
		IParamBlock2 *pblock;   // ref #0
		Tint();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetColor(int i, Color c, TimeValue t);
		void NotifyChanged();

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {	return tintClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_RGBTINT); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 1+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 1+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

	};

int numTints = 0;
class TintClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Tint; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_RGBTINT_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return tintClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_COLMOD;  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("rgbTint"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static TintClassDesc tintCD;

ClassDesc* GetTintDesc() { return &tintCD;  }

enum { rgbtint_params };  // pblock ID
// rgbtints param IDs
enum 
{ 
	rgbtint_color1, rgbtint_color2, rgbtint_color3,
	rgbtint_map1,
	rgbtint_map1_on, // main grad params 
};

static ParamBlockDesc2 rgbtint_param_blk ( rgbtint_params, _T("parameters"),  0, &tintCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_TINT, IDS_DS_TINTPARAMS, 0, 0, NULL, 
	// params
	rgbtint_color1,	 _T("red"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_RED,	
		p_default,		Color(1.f,0.f,0.f), 
		p_ui,			TYPE_COLORSWATCH, IDC_TINT_R, 
		end,
	rgbtint_color2,	 _T("green"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_GREEN,	
		p_default,		Color(0.f,1.f,0.f), 
		p_ui,			TYPE_COLORSWATCH, IDC_TINT_G, 
		end,
	rgbtint_color3,	 _T("blue"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_BLUE,	
		p_default,		Color(0.f,0.f,1.f), 
		p_ui,			TYPE_COLORSWATCH, IDC_TINT_B, 
		end,
	rgbtint_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_JW_MAP1,
		p_refno,		1,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TINT_MAP,
		end,
	rgbtint_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_JW_MAP1ENABLE,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON,
		end,
	end
);




//-----------------------------------------------------------------------------
//  Tint
//-----------------------------------------------------------------------------

#define TINT_VERSION 2

#define NPARAMS 3

static int name_id[NPARAMS] = {IDS_DS_COLOR1, IDS_DS_COLOR2, IDS_DS_COLOR3};

static ParamBlockDescID pbdesc[] = {
	{ TYPE_RGBA, NULL, TRUE,rgbtint_color1 },   // col1
	{ TYPE_RGBA, NULL, TRUE,rgbtint_color2 },   // col2
	{ TYPE_RGBA, NULL, TRUE,rgbtint_color3 }    // col3
	};   

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,3,1),	// Version 1 params
};


void Tint::Init() {
	ivalid.SetEmpty();
	SetColor(0, Color(1.0f,0.0f,0.0f), TimeValue(0));
	SetColor(1, Color(0.0f,1.0f,0.0f), TimeValue(0));
	SetColor(2, Color(0.0f,0.0f,1.0f), TimeValue(0));
	mapOn[0] = 1;
	}

void Tint::Reset() {
	tintCD.Reset(this, TRUE);	// reset all pb2's
	for (int i=0; i<NSUBTEX; i++) 
		DeleteReference(i+1);	// get rid of maps
	Init();
	}

void Tint::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Tint::Tint() {
	for (int i=0; i<NSUBTEX; i++) subTex[i] = NULL;
	pblock = NULL;
	tintCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	rollScroll=0;
	}

static AColor white(1.0f,1.0f,1.0f,1.0f);

AColor Tint::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	AColor c =  mapOn[0]&&subTex[0]? subTex[0]->EvalColor(sc): white;
	AColor c2;
	c2.r = c.r*col[0].r + c.g*col[1].r + c.b*col[2].r;		
	c2.g = c.r*col[0].g + c.g*col[1].g + c.b*col[2].g;		
	c2.b = c.r*col[0].b + c.g*col[1].b + c.b*col[2].b;
	c2.a = c.a;
	return c2;	
	}

float Tint::EvalMono(ShadeContext& sc) {
	return Intens(EvalColor(sc));
	}

Point3 Tint::EvalNormalPerturb(ShadeContext& sc) {
	return subTex[0]&&mapOn[0] ? subTex[0]->EvalNormalPerturb(sc): Point3(0,0,0);
	}

RefTargetHandle Tint::Clone(RemapDir &remap) {
	Tint *mnew = new Tint();
	*((MtlBase*)mnew) = *((MtlBase*)this);  // copy superclass stuff
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	for (int i=0; i<NCOLS; i++)
		mnew->col[i] = col[i];
	mnew->ivalid.SetEmpty();	
	for (i = 0; i<NSUBTEX; i++) {
	    mnew->subTex[i] = NULL;
		if (subTex[i])
			mnew->ReplaceReference(i+1,remap.CloneRef(subTex[i]));
		mnew->mapOn[i] = mapOn[i];
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Tint::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	IAutoMParamDlg* masterDlg = tintCD.CreateParamDlgs(hwMtlEdit, imp, this);
	return masterDlg;

	}

//static int pbId[NPARAMS] = { PB_COL1, PB_COL2, PB_COL3};

void Tint::Update(TimeValue t, Interval& valid) {		

	if (Param1)
		{
		pblock->SetValue( rgbtint_map1_on, 0, mapOn[0]);
		Param1 = FALSE;
		}
	
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		pblock->GetValue( rgbtint_color1, t, col[0], ivalid );
		col[0].ClampMinMax();
		pblock->GetValue( rgbtint_color2, t, col[1], ivalid );
		col[1].ClampMinMax();
		pblock->GetValue( rgbtint_color3, t, col[2], ivalid );
		col[2].ClampMinMax();
		pblock->GetValue( rgbtint_map1_on, t,mapOn[0], ivalid );

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}


void Tint::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	pblock->SetValue( i==0?rgbtint_color1:(i==1?rgbtint_color2:rgbtint_color3), t, c);
	}

RefTargetHandle Tint::GetReference(int i) {
	switch(i) {
		case 0:	return pblock ;
		default:return subTex[i-1];
		}
	}

void Tint::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-1] = (Texmap *)rtarg; break;
		}
	}

void Tint::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+1,m);
	if (i==0)
		{
		rgbtint_param_blk.InvalidateUI(rgbtint_map1);
		ivalid.SetEmpty();
		}	

	}

TSTR Tint::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_DS_MAP)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Tint::SubAnim(int i) {
	switch (i) {
		case 0: return pblock;
		default: return subTex[i-1]; 
		}
	}

TSTR Tint::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_DS_PARAMETERS));		
		default: return GetSubTexmapTVName(i-1);
		}
	}

RefResult Tint::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget== pblock)
				{
			// see if this message came from a changing parameter in the pblock,
			// if so, limit rollout update to the changing item and update any active viewport texture
				ParamID changing_param = pblock->LastNotifyParamID();
//			if (hTarget == pblock) 
				rgbtint_param_blk.InvalidateUI(changing_param);
			// notify our dependents that we've changed
				// NotifyChanged();  //DS this is redundant
				}

			break;
		}
	return(REF_SUCCEED);
	}


#define MTL_HDR_CHUNK 0x4000
#define MAPOFF_CHUNK 0x1000
#define PARAM2_CHUNK 0x1010

IOResult Tint::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
	return IO_OK;
	}	
	  
class RGBTint2PostLoad : public PostLoadCallback {
	public:
		Tint *n;
		RGBTint2PostLoad(Tint *ns) {n = ns;}
		void proc(ILoad *iload) {  
			if (n->Param1)
				{
				n->pblock->SetValue( rgbtint_map1_on, 0, n->mapOn[0]);
				}
			delete this; 


			} 
	};




IOResult Tint::Load(ILoad *iload) { 
//	ULONG nb;
	IOResult res;
	Param1 = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			case MAPOFF_CHUNK:
				mapOn[0] = 0; 
				break;
			case PARAM2_CHUNK:
				Param1 = FALSE; 
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &rgbtint_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

//load->RegisterPostLoadCallback(new RGBTint2PostLoad(this));

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\wood.h ===
/**********************************************************************
 *<
	FILE:			Wood.cpp

	DESCRIPTION:	Wood 3D Texture map Class Decl.

	CREATED BY:		Suryan Stalin

	HISTORY:		Modified from Marble.cpp by adding IPAS wood stuff

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __WOOD__H
#define __WOOD__H

#include "iparamm2.h"

//	defines
#define WOOD_CLASS_ID 		0x0000214
#define NSUBTEX				2
#define NCOLS				2
#define WOOD_VERSION		1

#define WOOD_VERS			0x3AE2
#define MTL_HDR_CHUNK		0x4000
#define WOODVERS1_CHUNK		0x4001
#define WOOD_NOISE_CHUNK	0x4002
#define WD					.02f
#define FACT				500.0f
#define SZ					1.0f //50.0


#define LIM255(c)			(((c)>=255)?255:(c))
#define SIZE				1
#define R1					2
#define R2					3
#define COL1				10		
#define COL2				11
#define NOISE_DIM			20    
#define FNOISE_DIM			20.0


//	C Prototypes
ClassDesc*		GetWoodDesc();
class Wood: public Tex3D 
{ 
	friend class WoodPostLoad;
	static ParamDlg *xyzGenDlg;
	XYZGen *xyzGen;		   // ref #0
	Texmap* subTex[NSUBTEX];  // More refs
	Interval ivalid;
	int rollScroll;

	float WoodFunc(Point3 p);

	public:
		BOOL Param1;
		Color col[NCOLS];
		float r1,r2,size;
		BOOL mapOn[NSUBTEX];
		int vers;
		int seed;
		IParamBlock2 *pblock;   // ref #1
		Wood();
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetColor(int i, Color c, TimeValue t);
		void SetSize(float f, TimeValue t);
		void SetR1(float f, TimeValue t);
		void SetR2(float f, TimeValue t);
		void NotifyChanged();
		void SwapInputs(); 

		void ReadSXPData(TCHAR *name, void *sxpdata);

		XYZGen *GetTheXYZGen() { return xyzGen; }

		// Wood noise functions
		void	InitNoise();
		float	WoodNoise(float x);
		void	LerpColor(RGBA *c, RGBA *a, RGBA *b, float f);
		float	SmoothStep(float x0, float x1, float v);

		// Evaluate the color of map for the context.
		RGBA EvalColor(ShadeContext& sc);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return xyzGen->Requirements(subMtlNum); }
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { return subTex[i]; }
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID();
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_WOOD); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

class WoodClassDesc:public ClassDesc2 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Wood; }
	const TCHAR *	ClassName() { return GetString(IDS_DS_WOOD_CDESC); } // mjm - 2.10.99
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID();
	const TCHAR* 	Category() { return TEXMAP_CAT_3D;  }
// PW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("wood"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};



#pragma pack(1)
struct WoodState 
{
	ulong version;
	float size;
	float dx, dy, dz;
	float r1;
	float r2;
	Col24 col1,col2;
};
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\wooddent.cpp ===
/**********************************************************************
 *<
	FILE:			wooddent.cpp

	DESCRIPTION:	DLL Main for wood and dent 3D textures

	CREATED BY:		Suryan Stalin

	HISTORY:		Modified from mtlmain.cpp, 4th April 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mtlhdr.h"
#include "stdmat.h"
#include "woodres.h"
#include "wooddent.h"
#include "wood.h"
#include "dent.h"


HINSTANCE	hInstance;
int			controlsInit = FALSE;

// public functions 
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
{
	hInstance = hinstDLL;

	if ( !controlsInit ) 
	{
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();

		// register SXP readers
		RegisterSXPReader(_T("WOOD_I.SXP"), Class_ID(WOOD_CLASS_ID,0));
		RegisterSXPReader(_T("DENTS_I.SXP"), Class_ID(DENT_CLASS_ID,0));
		RegisterSXPReader(_T("DENTS2_I.SXP"), Class_ID(DENT_CLASS_ID,0));
	}

	switch(fdwReason) 
	{
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
	}
	return(TRUE);
}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_WOODDENT);}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 2;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) 
{
	switch(i) 
	{
		case 0: return GetWoodDesc();
		case 1: return GetDentDesc();
		default: return 0;
	}
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

Color ColrFromCol24(Col24 a) 
{
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\Swirl\Swirl.h ===
#ifndef __MTLHDR__H
#define __MTLHDR__H

#ifdef BLD_MTL
#define MtlExport __declspec( dllexport )
#else
#define MtlExport __declspec( dllimport )
#endif

#include "max.h"
#include "imtl.h"
#include "texutil.h"
#include "resource.h"
#include <bmmlib.h>

extern ClassDesc* GetSwirlDesc();

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\Swirl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Swirl.rc
//
#define IDS_LIBDESC                     1
#define IDS_SWIRL                       2
#define IDS_BASE                        3
#define IDS_SWIRLPARAMS                 4
#define IDS_COLCHANGE                   5
#define IDS_PARAMCHANGE                 6
#define IDS_NONE                        7
#define IDS_COORDS                      8
#define IDS_PARAMS                      9
#define IDS_SWIRLINTENS                 10
#define IDS_TWIST                       11
#define IDS_COLCONTRAST                 12
#define IDS_CENTERY                     13
#define IDS_CENTERX                     14
#define IDS_RANDOMSEED                  15
#define IDS_SWIRLAMT                    16
#define IDS_DETAIL                      17
#define IDS_LOCK                        18
#define IDD_SWIRL                       124
#define IDB_LOCK2_M                     129
#define IDB_LOCK2                       130
#define IDB_LOCK1_M                     131
#define IDB_LOCK1                       132
#define IDC_HS_EDIT                     1099
#define IDC_HS_SPIN                     1100
#define IDC_VS_EDIT                     1101
#define IDC_VS_SPIN                     1102
#define IDC_CV_EDIT                     1103
#define IDC_CV_SPIN                     1104
#define IDC_LS_EDIT                     1105
#define IDC_LS_SPIN                     1106
#define IDC_H_EDIT                      1111
#define IDC_H_SPIN                      1112
#define IDC_RS_EDIT                     1113
#define IDC_RS_SPIN                     1114
#define IDC_HG_EDIT                     1115
#define IDC_HG_SPIN                     1116
#define IDC_VG_EDIT                     1117
#define IDC_VG_SPIN                     1118
#define IDC_TEX_SWAP                    1132
#define IDC_SWIRL_COL1                  1133
#define IDC_SWIRL_COL2                  1134
#define IDC_SWIRL_TEX1                  1135
#define IDC_SWIRL_TEX2                  1136
#define IDC_STATIC2                     1137
#define IDC_STATIC3                     1138
#define IDC_STATIC4                     1139
#define IDC_STATIC5                     1140
#define IDC_STATIC6                     1141
#define IDC_STATIC9                     1142
#define IDC_STATIC13                    1145
#define IDC_STATIC15                    1149
#define IDC_STATIC16                    1150
#define IDC_STATIC17                    1151
#define IDC_STATIC18                    1152
#define IDC_STATIC19                    1153
#define IDC_LOCK                        1157
#define IDC_STATIC23                    1160
#define IDC_STATIC24                    1161
#define IDC_CHKMAP2                     1192
#define IDC_CHKMAP1                     1193

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1196
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\Swirl\Tex.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Tex.cpp
 |			Plugin interface for SWIRL texture
 | 
 |
 |  AUTHOR: Harry Denholm
 |			All Rights Reserved. Copyright(c) Kinetix 1998
 |
 | 
\*===========================================================================*/

#include "swirl.h"


HINSTANCE hInstance;
int controlsInit = FALSE;


/*===========================================================================*\
 | Entry point
\*===========================================================================*/

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		InitCustomControls(hInstance);
		InitCommonControls();

		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);

}


/*===========================================================================*\
 | Interface to MAX
\*===========================================================================*/

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }


__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case  0: return GetSwirlDesc();
		default: return 0;
		}
	}

__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\woodres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wooddent.RC
//
#define IDS_DS_DENTPARMS                108
#define IDS_DS_WOODPARMS                112
#define IDS_DS_WOODSIZE                 113
#define IDS_DS_WOODR1                   114
#define IDS_DS_WOODR2                   115
#define IDS_DS_DENTSIZE                 116
#define IDS_DS_DENT_KM                  117
#define IDS_DS_DENT_NITS                118
#define IDB_DMTL_BUTTONS                122
#define IDB_DMTL_MASKBUTTONS            123
#define IDC_XSCL_EDIT                   225
#define IDC_XANG_EDIT                   226
#define IDC_XSCL_SPIN                   336
#define IDC_XANG_SPIN                   337
#define IDC_XOFFS_EDIT                  1016
#define IDC_XOFFS_SPIN                  1017
#define IDC_WOOD_COL1                   1027
#define IDC_WOOD_COL2                   1028
#define IDC_WOOD_TEX1                   1029
#define IDC_WOOD_TEX2                   1030
#define IDC_R1_SPIN                     1031
#define IDC_R1_EDIT                     1032
#define IDC_WOODSIZE_EDIT               1033
#define IDC_WOODSIZE_SPIN               1034
#define IDC_R2_EDIT                     1035
#define IDC_R2_SPIN                     1036
#define IDC_WOODSEED_SPIN               1037
#define IDC_WOODSEED_EDIT               1038
#define IDD_XYZGEN                      1052
#define IDD_WOOD                        1057
#define IDC_WOOD_SWAP                   1058
#define IDD_DENT                        1058
#define IDC_YOFFS_EDIT                  1114
#define IDC_ZOFFS_EDIT                  1115
#define IDC_YOFFS_SPIN                  1116
#define IDC_ZOFFS_SPIN                  1117
#define IDC_YSCL_EDIT                   1118
#define IDC_YSCL_SPIN                   1119
#define IDC_ZSCL_EDIT                   1120
#define IDC_ZSCL_SPIN                   1121
#define IDC_YANG_EDIT                   1122
#define IDC_YANG_SPIN                   1123
#define IDC_ZANG_EDIT                   1124
#define IDC_ZANG_SPIN                   1125
#define IDC_DENTSIZE_EDIT               1129
#define IDC_DENTSIZE_SPIN               1130
#define IDC_DENT_COL1                   1131
#define IDC_DENT_COL2                   1132
#define IDC_DENT_TEX1                   1133
#define IDC_DENT_TEX2                   1134
#define IDC_DENT_SWAP                   1135
#define IDC_KM_EDIT                     1136
#define IDC_KM_SPIN                     1137
#define IDC_NITS_EDIT                   1138
#define IDC_NITS_SPIN                   1139
#define IDC_DENTSEED_EDIT               1140
#define IDC_DENTSEED_SPIN               1141
#define IDC_MAPON1                      1142
#define IDC_MAPON2                      1143
#define IDC_COORD_XYZ                   1160
#define IDC_COORD_UVW                   1161
#define IDC_XLABEL                      1162
#define IDC_YLABEL                      1163
#define IDC_ZLABEL                      1164
#define IDS_DS_COORDINATES              10073
#define IDS_DS_COLOR1                   10080
#define IDS_DS_COLOR2                   10081
#define IDS_DS_PARAMETERS               10122
#define IDS_DS_PARAMCHG                 10183
#define IDS_DS_NONE                     30464
#define IDS_DS_WOOD                     30469
#define IDS_DS_DENT                     30470
#define IDS_WOODDENT                    30471
#define IDS_PW_MAP1                     30472
#define IDS_PW_MAP2                     30473
#define IDS_PW_MAP1ENABLE               30474
#define IDS_PW_MAP2ENABLE               30475
#define IDS_PW_SEED                     30476
#define IDS_DS_DENT_CDESC               30477
#define IDS_DS_WOOD_CDESC               30478
#define IDS_DS_WOOD_PARAMS              30479
#define IDS_DS_DENT_PARAMS              30480
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1144
#define _APS_NEXT_SYMED_VALUE           119
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\mtls\Swirl\Swirl.cpp ===
/*===========================================================================*\
 | 
 |  FILE:	Swirl.cpp
 |			Twirly Tornado-type material
 |			Main shader and plugin file
 | 
 |  AUTH:   Harry Denholm
 |			Copyright(c) Kinetix 1998
 |			All Rights Reserved.
 |
 |  HIST:	Started 31-7-98
 | 
\*===========================================================================*/


/*===========================================================================*\
 | Includes and global/macro setup
\*===========================================================================*/

#include "swirl.h"

#define NSUBTEX 2
#define NCOLS 2

#define RANDOM( a ) ( ( (float)rand()/(float)RAND_MAX)*(a) )

static Class_ID SwirlClassID(0x72c8577f, 0x39a00a1b);
extern HINSTANCE hInstance;

class Swirl;

#define SWIRL_VERSION 1

#define PB_COL1		0
#define PB_COL2		1
#define PB_HS		2
#define PB_VS		3
#define PB_CV		4
#define PB_VG		5
#define PB_HG		6
#define PB_LS		7
#define PB_SH		8
#define PB_H		9
#define PB_RS		10
#define PB_BF		11
#define PB_QUAD		12
#define PB_LOCK		13
#define PB_FV		14
#define PB_J		15

#define NPARAMS 16

/*===========================================================================*\
 | Dialog class
\*===========================================================================*/

class SwirlDlg: public ParamDlg {
	public:
		// Pointer to main texture class
		Swirl *theTex;

		IMtlParams *ip;

		// HWND Panels
		HWND hwmedit;
		HWND hPanel;

		// DragNDrop manager thingy
		TexDADMgr dadMgr;		

		// Construct/Destruct
		SwirlDlg(HWND hwMtlEdit, IMtlParams *imp, Swirl *m); 
		~SwirlDlg();

		// All those lovely spinners
		ISpinnerControl *HSSpin;
		ISpinnerControl *VSSpin;
		ISpinnerControl *CVSpin;
		ISpinnerControl *HGSpin;
		ISpinnerControl *VGSpin;
		ISpinnerControl *HSpin;
		ISpinnerControl *RSSpin;
		ISpinnerControl *LSSpin;

		IColorSwatch *cs[2];
		TimeValue curTime; 

		// Texture buttons
		ICustButton *iBut[2];

		// Lock-Mortar-Symmetry button + image list
		ICustButton *iLock;
		HIMAGELIST hImageLock;

		ParamDlg *uvGenDlg;
		int isActive;
		BOOL valid;

		// Panel procedure
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

		void UpdateSubTexNames();
		void LoadDialog(BOOL draw);
		void UpdateMtlDisplay();

		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void Invalidate() { valid = FALSE;	InvalidateRect(hPanel,NULL,0); }
		BOOL KeyAtCurTime(int id);

		Class_ID ClassID() {return SwirlClassID;  }
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing() { return (ReferenceTarget *)theTex; }
		void DeleteThis() { delete this;  }	
		void SetTime(TimeValue t);

		// DnD stuff
		int FindSubTexFromHWND(HWND hw);
};

int SwirlDlg::FindSubTexFromHWND(HWND hw)
	{
	if (hw==GetDlgItem(hPanel,IDC_SWIRL_TEX1)) return 0;
	if (hw==GetDlgItem(hPanel,IDC_SWIRL_TEX2)) return 1;
	return -1;
	}


/*===========================================================================*\
 | Material sampler
\*===========================================================================*/

class SwirlSampler: public MapSampler {
	// Pointer to main texture class
	Swirl *Swirler;
	public:
		SwirlSampler() { Swirler= NULL; }
		SwirlSampler(Swirl *c) { Swirler= c; }
		void Set(Swirl *c) { Swirler = c; }
		AColor Sample(ShadeContext& sc, float u,float v);
		AColor SampleFilter(ShadeContext& sc, float u,float v, float du, float dv);
		float SampleMono(ShadeContext& sc, float u,float v);
		float SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv);
	} ;


/*===========================================================================*\
 | Main texture class -- Swirl
\*===========================================================================*/

class Swirl: public Texmap { 
	friend class SwirlPostLoad;
	friend class SwirlDlg;
	Color col[NCOLS];
	float hs,vs,cv,hg,vg,ls,rs;
	int h,lock;
	
	// map enabled flag
	BOOL mapOn[2];

	UVGen *uvGen;
	IParamBlock *pblock;
	Texmap* subTex[NSUBTEX];
	TexHandle *texHandle;
	Interval texHandleValid;
	Interval ivalid;
	int rollScroll;
	SwirlSampler mysamp;
	SwirlDlg *paramDlg;
	public:
		Swirl();
		~Swirl() {
			DiscardTexHandle();
			}	
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t) { Interval v; Update(t,v); return ivalid; }

		void SetColor(int i, Color c, TimeValue t);

		void SetHS(float f, TimeValue t);
		void SetVS(float f, TimeValue t);
		void SetCV(float f, TimeValue t);
		void SetHG(float f, TimeValue t);
		void SetVG(float f, TimeValue t);
		void SetLS(float f, TimeValue t);
		void SetLOCK(int f, TimeValue t);

		void SetH(int f, TimeValue t);
		void SetRS(float f, TimeValue t);

		AColor SwirlFunc(float u,float v,ShadeContext& sc,float du,float dv);

		void NotifyChanged();
		void SwapInputs(); 
		Bitmap *BuildBitmap(int size);

		// Evaluate the color of map for the context.
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);
		float MonoEvalFunction(ShadeContext& sc, float u, float v, float du, float dv);
		AColor DispEvalFunc( float u, float v);

		// For Bump mapping, need a perturbation to apply to a normal.
		// Leave it up to the Texmap to determine how to do this.
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// Methods for interactive display
		void DiscardTexHandle();
		BOOL SupportTexDisplay() { return TRUE; }
		void ActivateTexDisplay(BOOL onoff);
		DWORD GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker);
		void GetUVTransform(Matrix3 &uvtrans) { uvGen->GetUVTransform(uvtrans); }
		int GetTextureTiling() { return  uvGen->GetTextureTiling(); }
		int GetUVWSource() { return uvGen->GetUVWSource(); }
		int GetMapChannel () { return uvGen->GetMapChannel(); }
		UVGen *GetTheUVGen() { return uvGen; }

		// Requirements
		ULONG LocalRequirements(int subMtlNum) { return uvGen->Requirements(subMtlNum); }
		
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			uvGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
			}

		// Methods to access texture maps of material
		int NumSubTexmaps() { return NSUBTEX; }
		Texmap* GetSubTexmap(int i) { 
			return subTex[i]; 
			}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		void InitSlotType(int sType) { if (uvGen) uvGen->InitSlotType(sType); }
		int SubTexmapOn(int i) { return (mapOn[i] && subTex[i]) ? 1 : 0; } // mjm - 9.30.99

		Class_ID ClassID() {	return SwirlClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_SWIRL); }  
		void DeleteThis() { delete this; }	

		int NumSubs() { return 2+NSUBTEX; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// From ref
 		int NumRefs() { return 2+NSUBTEX; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

	};

class SwirlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new Swirl; }
	const TCHAR *	ClassName() { return GetString(IDS_SWIRL); }
	SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
	Class_ID 		ClassID() { return SwirlClassID; }
	const TCHAR* 	Category() { return TEXMAP_CAT_2D;  }
	};

static SwirlClassDesc SwirlCD;

ClassDesc* GetSwirlDesc() { return &SwirlCD;  }

static BOOL CALLBACK  PanelDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	SwirlDlg *theDlg;
	if (msg==WM_INITDIALOG) {
		theDlg = (SwirlDlg*)lParam;
		theDlg->hPanel = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (theDlg = (SwirlDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	theDlg->isActive = 1;
	int	res = theDlg->PanelProc(hwndDlg,msg,wParam,lParam);
	theDlg->isActive = 0;
	return res;
	}

SwirlDlg::SwirlDlg(HWND hwMtlEdit, IMtlParams *imp, Swirl *m) { 
	hwmedit = hwMtlEdit;
	ip = imp;
	hPanel = NULL;
	theTex = m; 
	isActive = 0;
	valid = FALSE;
	curTime = ip->GetTime();
	uvGenDlg = theTex->uvGen->CreateParamDlg(hwmedit, imp);

	// Start up DnD and init the custButtons
	dadMgr.Init(this);
	for (int i=0; i<NSUBTEX; i++) 
	iBut[i] = NULL;
	iLock = NULL;

	hPanel = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_SWIRL),
		PanelDlgProc, 
		GetString(IDS_SWIRLPARAMS), 
		(LPARAM)this );		
	}

// Reload the dialog panel
void SwirlDlg::ReloadDialog() {
	Interval valid;
	theTex->Update(curTime, valid);
	LoadDialog(FALSE);
	}

// Set time
void SwirlDlg::SetTime(TimeValue t) {
	Interval valid;
	if (t!=curTime) {
		uvGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, valid);
		LoadDialog(FALSE);
		InvalidateRect(hPanel,NULL,0);
		}
	}

SwirlDlg::~SwirlDlg() {
	theTex->paramDlg = NULL;
	ReleaseISpinner(HSSpin);
	ReleaseISpinner(VSSpin);
	ReleaseISpinner(HGSpin);
	ReleaseISpinner(VGSpin);
	ReleaseISpinner(CVSpin);
	ReleaseISpinner(HSpin);
	ReleaseISpinner(RSSpin);
	ReleaseISpinner(LSSpin);

	ReleaseIColorSwatch(cs[0]);
	ReleaseIColorSwatch(cs[1]);

	for (int i=0; i<NSUBTEX; i++) 
		ReleaseICustButton(iBut[i]);
	ReleaseICustButton(iLock);
	ImageList_Destroy(hImageLock);

	SetWindowLong(hPanel, GWL_USERDATA, NULL);
	uvGenDlg->DeleteThis();
	hPanel =  NULL;
	}


// Dialog Code
static int colID[2] = { IDC_SWIRL_COL1, IDC_SWIRL_COL2 };
static int mapOnId[NSUBTEX] = { IDC_CHKMAP1, IDC_CHKMAP2 };
static int subTexId[NSUBTEX] = { IDC_SWIRL_TEX1, IDC_SWIRL_TEX2 };

BOOL SwirlDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg)    {
		case WM_INITDIALOG:
			{
			
			HSSpin = SetupFloatSpinner(hwndDlg, IDC_HS_SPIN, IDC_HS_EDIT,-10.0f,10.0f,0.1f);
			HSSpin->SetScale(0.05f);
			VSSpin = SetupFloatSpinner(hwndDlg, IDC_VS_SPIN, IDC_VS_EDIT,-20.0f,20.0f,0.1f);
			VSSpin->SetScale(0.05f);

			CVSpin = SetupFloatSpinner(hwndDlg, IDC_CV_SPIN, IDC_CV_EDIT,0.0f,4.0f,0.1f);
			CVSpin->SetScale(0.01f);
			VGSpin = SetupFloatSpinner(hwndDlg, IDC_VG_SPIN, IDC_VG_EDIT,-10.0f,10.0f,0.1f);
			HGSpin = SetupFloatSpinner(hwndDlg, IDC_HG_SPIN, IDC_HG_EDIT,-10.0f,10.0f,0.1f);
			LSSpin = SetupFloatSpinner(hwndDlg, IDC_LS_SPIN, IDC_LS_EDIT,0.0f,3.0f,0.1f);

			HSpin = SetupIntSpinner(hwndDlg, IDC_H_SPIN, IDC_H_EDIT,0,10,1);
			RSSpin = SetupFloatSpinner(hwndDlg, IDC_RS_SPIN, IDC_RS_EDIT,0.0f,65535.0f,1.0f);


			SetCheckBox(hwndDlg,IDC_LOCK,theTex->lock);
			hImageLock = ImageList_Create(15, 14, ILC_COLOR24| ILC_MASK , 2, 0);
			HBITMAP hLocked		= LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_LOCK1));
			HBITMAP hLockedM	= LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_LOCK1_M));

			HBITMAP hUnlocked	= LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_LOCK2));
			HBITMAP hUnlockedM	= LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_LOCK2_M));
			ImageList_Add(hImageLock, hLocked, hLockedM);
			ImageList_Add(hImageLock, hUnlocked, hUnlockedM);

			iLock = GetICustButton(GetDlgItem(hwndDlg,IDC_LOCK));
			iLock->SetType(CBT_CHECK);
			iLock->SetImage(hImageLock, 0,1,0,1, 15, 14);
			
			for (int i=0; i<NCOLS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					theTex->col[i],theTex->GetSubTexmapSlotName(i).data());

			for (i=0; i<NSUBTEX; i++) {
				iBut[i] = GetICustButton(GetDlgItem(hwndDlg,subTexId[i]));
				iBut[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hwndDlg, mapOnId[i], theTex->mapOn[i]);
				}

			return TRUE;
			}
			break;
		case WM_COMMAND:  
		    switch (id) {
				case IDC_SWIRL_TEX1: 
					PostMessage(hwmedit,WM_TEXMAP_BUTTON,0 ,(LPARAM)theTex);
					break;
				case IDC_SWIRL_TEX2: 
					PostMessage(hwmedit,WM_TEXMAP_BUTTON,1 ,(LPARAM)theTex);
					break;

				case IDC_TEX_SWAP:
					theTex->SwapInputs(); 
					cs[0]->SetColor(theTex->col[0]);
					cs[1]->SetColor(theTex->col[1]);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					UpdateSubTexNames();
					LoadDialog(FALSE);
					break;

					// Texture maps on/off
				case IDC_CHKMAP1:
					theTex->mapOn[0] = GetCheckBox(hwndDlg,id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					UpdateSubTexNames();
					LoadDialog(FALSE);
					break;
				case IDC_CHKMAP2:
					theTex->mapOn[1] = GetCheckBox(hwndDlg,id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					UpdateSubTexNames();
					LoadDialog(FALSE);
					break;

				case IDC_LOCK:
					theTex->SetLOCK(iLock->IsChecked(),curTime); 
					if( iLock->IsChecked() ){
						if(theTex->hg>theTex->vg){
							theTex->SetVG(HGSpin->GetFVal(),curTime); 
							VGSpin->SetValue(HGSpin->GetFVal(),TRUE);
						}
						if(theTex->vg>theTex->hg){
							theTex->SetHG(VGSpin->GetFVal(),curTime); 
							HGSpin->SetValue(VGSpin->GetFVal(),TRUE);
						}
					}
				break;
			}
			break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_COLCHANGE));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE:
			{
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = (id==IDC_SWIRL_COL1)?0:1;
			if (buttonUp) theHold.Begin();
			theTex->SetColor(n,cs[n]->GetColor(),curTime);
			cs[n]->SetKeyBrackets(KeyAtCurTime(n?PB_COL2:PB_COL1));
			if (buttonUp) {
				theHold.Accept(GetString(IDS_PARAMCHANGE));
				theTex->NotifyChanged();
			    UpdateMtlDisplay();
				}
			}
			break;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hwndDlg,msg,wParam,lParam);
			return FALSE;
		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			break;
		case WM_CLOSE: 	break;       
		case WM_DESTROY:		break;
		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_HS_SPIN: 
					theTex->SetHS(HSSpin->GetFVal(),curTime); 
					HSSpin->SetKeyBrackets(KeyAtCurTime(PB_HS));
					break;
				case IDC_VS_SPIN: 
					theTex->SetVS(VSSpin->GetFVal(),curTime); 
					VSSpin->SetKeyBrackets(KeyAtCurTime(PB_VS));
					break;
				case IDC_CV_SPIN: 
					theTex->SetCV(CVSpin->GetFVal(),curTime);
					CVSpin->SetKeyBrackets(KeyAtCurTime(PB_CV));
					break;
				case IDC_VG_SPIN: 
					theTex->SetVG(VGSpin->GetFVal(),curTime);
					if(theTex->lock==1) {
						theTex->SetHG(VGSpin->GetFVal(),curTime); 
						HGSpin->SetValue(VGSpin->GetFVal(),TRUE);
					}
					VGSpin->SetKeyBrackets(KeyAtCurTime(PB_VG));
					HGSpin->SetKeyBrackets(KeyAtCurTime(PB_HG));
					break;
				case IDC_HG_SPIN: 
					theTex->SetHG(HGSpin->GetFVal(),curTime); 
					if(theTex->lock==1) {
						theTex->SetVG(HGSpin->GetFVal(),curTime); 
						VGSpin->SetValue(HGSpin->GetFVal(),TRUE);
					}
					HGSpin->SetKeyBrackets(KeyAtCurTime(PB_HG));
					VGSpin->SetKeyBrackets(KeyAtCurTime(PB_VG));
					break;
				case IDC_LS_SPIN: 
					theTex->SetLS(LSSpin->GetFVal(),curTime); 
					LSSpin->SetKeyBrackets(KeyAtCurTime(PB_LS));
					break;
				case IDC_H_SPIN: 
					theTex->SetH(HSpin->GetIVal(),curTime); 
					HSpin->SetKeyBrackets(KeyAtCurTime(PB_H));
					break;
				case IDC_RS_SPIN: 
					theTex->SetRS(RSSpin->GetFVal(),curTime); 
					RSSpin->SetKeyBrackets(KeyAtCurTime(PB_RS));
					break;

			}
			break;
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_PARAMCHANGE));
			else theHold.Cancel();
			theTex->NotifyChanged();
		    UpdateMtlDisplay();
			break;

    	}
	return FALSE;
	}

BOOL SwirlDlg::KeyAtCurTime(int id) { return theTex->pblock->KeyFrameAtTime(id,ip->GetTime()); }

void SwirlDlg::UpdateSubTexNames() {
	for (int i=0; i<NSUBTEX; i++) {
		Texmap *m = theTex->subTex[i];
		TSTR nm;
		if (m) 	nm = m->GetFullName();
		else 	nm = GetString(IDS_NONE);
		iBut[i]->SetText(nm.data());
		}
	}


void SwirlDlg::LoadDialog(BOOL draw) {
	if (theTex) {
		Interval valid;
		theTex->Update(curTime,valid);
		BOOL kbON;

		HSSpin->SetValue(theTex->hs,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(2,curTime);
		HSSpin->SetKeyBrackets(kbON);

		VSSpin->SetValue(theTex->vs,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(3,curTime);
		VSSpin->SetKeyBrackets(kbON);

		CVSpin->SetValue(theTex->cv,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(4,curTime);
		CVSpin->SetKeyBrackets(kbON);

		VGSpin->SetValue(theTex->vg,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(5,curTime);
		VGSpin->SetKeyBrackets(kbON);

		HGSpin->SetValue(theTex->hg,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(6,curTime);
		HGSpin->SetKeyBrackets(kbON);

		LSSpin->SetValue(theTex->ls,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(7,curTime);
		LSSpin->SetKeyBrackets(kbON);

		RSSpin->SetValue(theTex->rs,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(10,curTime);
		RSSpin->SetKeyBrackets(kbON);

		HSpin->SetValue(theTex->h,FALSE);
		kbON = theTex->pblock->KeyFrameAtTime(9,curTime);
		HSpin->SetKeyBrackets(kbON);

		
		iLock->SetCheck( theTex->lock );

		SetCheckBox(hPanel, IDC_CHKMAP1, theTex->mapOn[0]);
		SetCheckBox(hPanel, IDC_CHKMAP2, theTex->mapOn[1]);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);
		UpdateSubTexNames();
		}
	}

void SwirlDlg::SetThing(ReferenceTarget *m) {
	assert (m->ClassID()==SwirlClassID);
	assert (m->SuperClassID()==TEXMAP_CLASS_ID);
	if (theTex) theTex->paramDlg = NULL;
	theTex = (Swirl *)m;
	uvGenDlg->SetThing(theTex->uvGen);
	if (theTex)
		theTex->paramDlg = this;
	LoadDialog(TRUE);
	}

void SwirlDlg::UpdateMtlDisplay() { 
	theTex->DiscardTexHandle();  
	ip->MtlChanged();  
	}

void SwirlDlg::ActivateDlg(BOOL onOff) {
	for (int i=0; i<NCOLS; i++)
		cs[i]->Activate(onOff);
	}

AColor SwirlSampler::SampleFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	return Swirler->EvalFunction(sc, u, v, du, dv);
	}
AColor SwirlSampler::Sample(ShadeContext& sc, float u,float v) {
	return Swirler->EvalFunction(sc, u, v, 0.0f, 0.0f);
	}

float SwirlSampler::SampleMonoFilter(ShadeContext& sc, float u,float v, float du, float dv) {
	return Swirler->MonoEvalFunction(sc, u, v, du, dv);
	}
float SwirlSampler::SampleMono(ShadeContext& sc, float u,float v) {
	return Swirler->MonoEvalFunction(sc, u, v, 0.0f, 0.0f);
	}



static ParamBlockDescID pbdesc2[] = {
	{ TYPE_RGBA, NULL, TRUE,0 },
	{ TYPE_RGBA, NULL, TRUE,1 },
	{ TYPE_FLOAT, NULL, TRUE,2 }, 
	{ TYPE_FLOAT, NULL, TRUE,3 }, 
	{ TYPE_FLOAT, NULL, TRUE,4 }, 
	{ TYPE_FLOAT, NULL, TRUE,5 }, 
	{ TYPE_FLOAT, NULL, TRUE,6 }, 
	{ TYPE_FLOAT, NULL, TRUE,7 }, 
	{ TYPE_FLOAT, NULL, FALSE,8 }, 
	{ TYPE_INT, NULL, TRUE,9 }, 
	{ TYPE_FLOAT, NULL, TRUE,10 },
	{ TYPE_FLOAT, NULL, FALSE,11}, 
	{ TYPE_INT, NULL, FALSE,12 },
	{ TYPE_INT, NULL, FALSE,13 },
	{ TYPE_FLOAT, NULL, FALSE,14}, 
	{ TYPE_FLOAT, NULL, FALSE,15}, 
	};


void Swirl::Reset() {
	if (uvGen) uvGen->Reset();
	else ReplaceReference( 0, GetNewDefaultUVGen());	
	ReplaceReference( 1, CreateParameterBlock( pbdesc2, NPARAMS, SWIRL_VERSION) );	
	ivalid.SetEmpty();
	DeleteReference(2);
	DeleteReference(3);

	SetColor(0, Color(0.0f,0.1f,0.2f), TimeValue(0));
	SetColor(1, Color(0.9f,0.58f,0.3f), TimeValue(0));

	SetHS(2.0f, TimeValue(0));
	SetVS(1.0f, TimeValue(0));
	SetCV(0.4f, TimeValue(0));

	SetVG(-0.5f, TimeValue(0));
	SetHG(-0.5f, TimeValue(0));

	SetLS(1.0f, TimeValue(0));
	SetH(4, TimeValue(0));
	SetRS(RANDOM(65535.0f), TimeValue(0));

	SetLOCK(1, TimeValue(0));
	mapOn[0] = mapOn[1] = 1;

	}

void Swirl::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Swirl::Swirl() {
	mysamp.Set(this);
	texHandle = NULL;
	subTex[0] = subTex[1] = NULL;
	mapOn[0] = mapOn[1] = FALSE; // mjm - 9.30.99 - just in case
	pblock = NULL;
	uvGen = NULL;
	paramDlg = NULL;
	Reset();
	rollScroll=0;
	}


void Swirl::DiscardTexHandle() {
	if (texHandle) {
		texHandle->DeleteThis();
		texHandle = NULL;
		}
	}

void Swirl::ActivateTexDisplay(BOOL onoff) {
	if (!onoff) 
		DiscardTexHandle();
	}

DWORD Swirl::GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {
	if (texHandle) {
		if (texHandleValid.InInterval(t))
			return texHandle->GetHandle();
		else DiscardTexHandle();
		}

	Bitmap *bm;
	Interval v;
	Update(t,v);
	bm = BuildBitmap(thmaker.Size());
	texHandle = thmaker.CreateHandle(bm,uvGen->SymFlags());
	texHandleValid.SetInfinite();
	bm->DeleteThis();

	Color ac;
	pblock->GetValue( PB_COL1, t, ac, texHandleValid );
	pblock->GetValue( PB_COL2, t, ac, texHandleValid );
	pblock->GetValue( PB_HS, t, hs, texHandleValid );
	pblock->GetValue( PB_VS, t, vs, texHandleValid );
	pblock->GetValue( PB_CV, t, cv, texHandleValid );
	pblock->GetValue( PB_VG, t, vg, texHandleValid );
	pblock->GetValue( PB_HG, t, hg, texHandleValid );
	pblock->GetValue( PB_RS, t, rs, texHandleValid );
	pblock->GetValue( PB_LS, t, ls, texHandleValid );
	pblock->GetValue( PB_H, t, h, texHandleValid );
	pblock->GetValue( PB_LOCK, t, lock, texHandleValid );
		
	return texHandle->GetHandle();
	}

inline UWORD FlToWord(float r) {
	return (UWORD)(65535.0f*r);
	}

Bitmap *Swirl::BuildBitmap(int size) {
	float u,v;
	BitmapInfo bi;
	bi.SetName(_T("SwrTemp"));
	bi.SetWidth(size);
	bi.SetHeight(size);
	bi.SetType(BMM_TRUE_32);
	Bitmap *bm = TheManager->Create(&bi);
	if (bm==NULL) return NULL;
	PixelBuf l64(size);
	float d = 1.0f/float(size);
	v = 1.0f - 0.5f*d;

	for (int y=0; y<size; y++) {
		BMM_Color_64 *p64=l64.Ptr();
		u = 0.0f;
		for (int x=0; x<size; x++, p64++) {
			AColor c = DispEvalFunc(u,v);
			p64->r = FlToWord(c.r); 
			p64->g = FlToWord(c.g); 
			p64->b = FlToWord(c.b);
			p64->a = 0xffff; 
			u += d;
			}
		bm->PutPixels(0,y, size, l64.Ptr()); 
		v -= d;
		}
	return bm;
	}


AColor Swirl::SwirlFunc(float u,float v,ShadeContext& sc,float du,float dv ){

	float offset = ls;
	float scale = hs;
	float twist = vs;
	float omega = cv;
	float octaves = (float)h;

	Point3 Ptexture,PtN;
	float rsq;                // Used in calculation of swirl 
	float angle;              // Swirl angle 
	float sine, cosine;       // sin and cos of angle 
	float l, o, a, i;         // Loop control for fractal sum 
	float value;              // Fractal sum is stored here 


	u+=hg; v+=vg;

		rsq = (u)*(u) + (v)*(v); 


	  angle = twist * TWOPI * rsq;
	  sine = (float)sin (angle);
	  cosine = (float)cos (angle);

	  Point3 PP (v*cosine - u*sine,
			  v*sine + u*cosine,(float)rs);

	  /* Compute VLfBm */
	  l = 1;  o = 1;  a = 0;
	  for (i = 0;  i < octaves;  i += 1) {
		  a += o * noise3 (PP * l);
		  l *= 2;
		  o *= omega;
		}

		value =  ((offset * scale) * a);
 
		AColor r1 = mapOn[0]&&subTex[0] ? subTex[0]->EvalColor(sc): col[0]; 
		AColor r2 = mapOn[1]&&subTex[1] ? subTex[1]->EvalColor(sc): col[1]; 

		AColor rslt = (r1*value)+(r2*(1.0f-value));
		rslt.ClampMinMax();

		return rslt;

}


AColor Swirl::DispEvalFunc( float u, float v) {
	
	float offset = ls;
	float scale = hs;
	float twist = vs;
	float omega = cv;
	float octaves = (float)h;

	Point3 Ptexture,PtN;
	float rsq;                // Used in calculation of twist 
	float angle;              // Twist angle 
	float sine, cosine;       // sin and cos of angle 
	float l, o, a, i;         // Loop control for fractal sum 
	float value;              // Fractal sum is stored here 


	u+=hg; v+=vg;

		rsq = (u)*(u) + (v)*(v); 

	  angle = twist * TWOPI * rsq;
	  sine = (float)sin (angle);
	  cosine = (float)cos (angle);

	  Point3 PP (v*cosine - u*sine,
			  v*sine + u*cosine,(float)rs);

	  /* Compute VLfBm */
	  l = 1;  o = 1;  a = 0;
	  for (i = 0;  i < octaves;  i += 1) {
		  a += o * noise3 (PP * l);
		  l *= 2;
		  o *= omega;
		}

		value =  ((offset * scale) * a);
 
		AColor r1 = col[0]; 
		AColor r2 = col[1]; 

		AColor k = (r1*value)+(r2*(1.0f-value));
		k.ClampMinMax();

	return k;
	
}


AColor Swirl::EvalFunction(ShadeContext& sc, float u, float v, float du, float dv) {

return SwirlFunc(u,v,sc,du,dv);

}



float Swirl::MonoEvalFunction(ShadeContext& sc, float u, float v, float du, float dv) {

	AColor k = SwirlFunc(u,v,sc,du,dv);
	k.ClampMinMax();
	
	return Intens(k); 
}


AColor Swirl::EvalColor(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	return uvGen->EvalUVMap(sc,&mysamp);
	}

float Swirl::EvalMono(ShadeContext& sc) {
	if (gbufID) sc.SetGBufferID(gbufID);
	return uvGen->EvalUVMapMono(sc,&mysamp);
	}

Point3 Swirl::EvalNormalPerturb(ShadeContext& sc) {
	Point3 dPdu, dPdv;
	if (gbufID) sc.SetGBufferID(gbufID);
	uvGen->GetBumpDP(sc,dPdu,dPdv);
	Point2 dM = (.02f)*uvGen->EvalDeriv(sc,&mysamp);
	return dM.x*dPdu+dM.y*dPdv;
	}

RefTargetHandle Swirl::Clone(RemapDir &remap) {
	Swirl *mnew = new Swirl();
	*((MtlBase*)mnew) = *((MtlBase*)this);
	mnew->ReplaceReference(0,remap.CloneRef(uvGen));
	mnew->ReplaceReference(1,remap.CloneRef(pblock));
	mnew->col[0] = col[0];
	mnew->col[1] = col[1];

	mnew->hs = hs;
	mnew->vs = vs;
	mnew->cv = cv;
	mnew->vg = vg;
	mnew->hg = hg;
	mnew->rs = rs;
	mnew->ls = ls;
	mnew->h = h;
	mnew->lock=lock;
	
	mnew->ivalid.SetEmpty();	
	for (int i = 0; i<NSUBTEX; i++) {
		mnew->subTex[i] = NULL;
		mnew->mapOn[i] = mapOn[i];
		if (subTex[i])
			mnew->ReplaceReference(i+2,remap.CloneRef(subTex[i]));
		}
	return (RefTargetHandle)mnew;
	}

ParamDlg* Swirl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	SwirlDlg *dm = new SwirlDlg(hwMtlEdit, imp, this);
	paramDlg = dm;
	dm->LoadDialog(TRUE);	
	return dm;	
	}


void Swirl::Update(TimeValue t, Interval& valid) {		
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();
		uvGen->Update(t,ivalid);
		pblock->GetValue( PB_COL1, t, col[0], ivalid );
		col[0].ClampMinMax();

		pblock->GetValue( PB_COL2, t, col[1], ivalid );
		col[1].ClampMinMax();

		pblock->GetValue( PB_HS, t, hs, ivalid );
		pblock->GetValue( PB_VS, t, vs, ivalid );
		pblock->GetValue( PB_CV, t, cv, ivalid );
		pblock->GetValue( PB_VG, t, vg, ivalid );
		pblock->GetValue( PB_HG, t, hg, ivalid );
		pblock->GetValue( PB_RS, t, rs, ivalid );
		pblock->GetValue( PB_LS, t, ls, ivalid );
		pblock->GetValue( PB_H, t, h, ivalid );
		pblock->GetValue( PB_LOCK, t, lock, ivalid );



		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}
		}
	valid &= ivalid;
	}


void Swirl::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
	pblock->SetValue( i==0?PB_COL1:PB_COL2, t, c);
	}

void Swirl::SwapInputs() {
	BOOL bt = mapOn[0]; mapOn[0] = mapOn[1]; mapOn[1] = bt;
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
	pblock->SwapControllers(PB_COL1,PB_COL2);
	}



void Swirl::SetHS(float f, TimeValue t) { 
	hs = f; 
	pblock->SetValue( PB_HS, t, f);
	}
void Swirl::SetVS(float f, TimeValue t) { 
	vs = f; 
	pblock->SetValue( PB_VS, t, f);
	}
void Swirl::SetCV(float f, TimeValue t) { 
	cv = f; 
	pblock->SetValue( PB_CV, t, f);
	}
void Swirl::SetVG(float f, TimeValue t) { 
	vg = f; 
	pblock->SetValue( PB_VG, t, f);
	}
void Swirl::SetHG(float f, TimeValue t) { 
	hg = f; 
	pblock->SetValue( PB_HG, t, f);
	}
void Swirl::SetLS(float f, TimeValue t) { 
	ls = f; 
	pblock->SetValue( PB_LS, t, f);
	}


void Swirl::SetH(int f, TimeValue t) { 
	h = f; 
	pblock->SetValue( PB_H, t, f);
	}
void Swirl::SetRS(float f, TimeValue t) { 
	rs = f; 
	pblock->SetValue( PB_RS, t, f);
	}
void Swirl::SetLOCK(int f, TimeValue t) { 
	lock = f; 
	pblock->SetValue( PB_LOCK, t, f);
	}



RefTargetHandle Swirl::GetReference(int i) {
	switch(i) {
		case 0: return uvGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
		}
	}

void Swirl::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: uvGen = (UVGen *)rtarg; break;
		case 1:	pblock = (IParamBlock *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
		}
	}

void Swirl::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2,m);
	if (paramDlg)
		paramDlg->UpdateSubTexNames();
	}

TSTR Swirl::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return TSTR(GetString(IDS_SWIRL)); 
		case 1:  return TSTR(GetString(IDS_BASE)); 
		default: return TSTR(_T(""));
		}
	}
	 
Animatable* Swirl::SubAnim(int i) {
	switch (i) {
		case 0: return uvGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
		}
	}

TSTR Swirl::SubAnimName(int i) {
	switch (i) {
		case 0: return TSTR(GetString(IDS_COORDS));		
		case 1: return TSTR(GetString(IDS_PARAMS));		
		default: return GetSubTexmapTVName(i-2);
		}
	}


/*===========================================================================*\
 | Notification handler
\*===========================================================================*/

RefResult Swirl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
   PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget!=uvGen) {
				if (paramDlg&&!paramDlg->isActive) 
					paramDlg->Invalidate();
				}
			break;

		case REFMSG_UV_SYM_CHANGE:
			DiscardTexHandle();  
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_HS: 
				case PB_VS: 
				case PB_CV: 
				case PB_VG: 
				case PB_HG: 
				case PB_LS: 
				case PB_RS: 
				case PB_LOCK: 
				case PB_H: gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
			case PB_COL1:	gpn->name= TSTR(GetString(IDS_SWIRL));break;
			case PB_COL2:	gpn->name= TSTR(GetString(IDS_BASE));break;
			case PB_HS:		gpn->name= TSTR(GetString(IDS_SWIRLINTENS));break;
			case PB_VS:		gpn->name= TSTR(GetString(IDS_TWIST));break;
			case PB_CV:		gpn->name= TSTR(GetString(IDS_COLCONTRAST));break;
			case PB_VG:		gpn->name= TSTR(GetString(IDS_CENTERY));break;
			case PB_HG:		gpn->name= TSTR(GetString(IDS_CENTERX));break;
			case PB_RS:		gpn->name= TSTR(GetString(IDS_RANDOMSEED));break;
			case PB_LS:		gpn->name= TSTR(GetString(IDS_SWIRLAMT));break;
			case PB_H:		gpn->name= TSTR(GetString(IDS_DETAIL));break;
			case PB_LOCK:	gpn->name= TSTR(GetString(IDS_LOCK));break;
			}
				return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


/*===========================================================================*\
 | ISave and ILoad stuff
\*===========================================================================*/

#define MTL_HDR_CHUNK 0x4000

IOResult Swirl::Save(ISave *isave) { 
	IOResult res;
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res!=IO_OK) return res;
	isave->EndChunk();

	return IO_OK;
	}	
	  
IOResult Swirl::Load(ILoad *iload) { 
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\notifdlg.cpp ===
// notifdlg.cpp : implementation file
//

#include "stdafx.h"
#include "Notify.h"
#include "notifdlg.h"
#include "helpsys.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CNotifyApp* theAppPtr;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {

public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) {
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNotifyDlg dialog

CNotifyDlg::CNotifyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNotifyDlg::IDD, pParent) {
	//{{AFX_DATA_INIT(CNotifyDlg)
	m_CompletionTarget = _T("");
	m_FailureTarget = _T("");
	m_ProgressTarget = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CNotifyDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNotifyDlg)
	DDX_Text(pDX, IDC_COMPLETION_ED, m_CompletionTarget);
	DDX_Text(pDX, IDC_FAILURE_ED, m_FailureTarget);
	DDX_Text(pDX, IDC_PROGRESS_ED, m_ProgressTarget);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNotifyDlg, CDialog)
	//{{AFX_MSG_MAP(CNotifyDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_EN_UPDATE(IDC_FAILURE_ED, OnUpdateFailureEd)
	ON_BN_CLICKED(IDC_BROWSE_FAILURE, OnBrowseFailure)
	ON_BN_CLICKED(IDC_BROWSE_PROGRESS, OnBrowseProgress)
	ON_BN_CLICKED(IDC_BROWSE_COMPLETION, OnBrowseCompletion)
	ON_BN_CLICKED(IDC_PLAY_FAILURE, OnPlayFailure)
	ON_BN_CLICKED(IDC_PLAY_COMPLETION, OnPlayCompletion)
	ON_BN_CLICKED(IDC_PLAY_PROGRESS, OnPlayProgress)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNotifyDlg message handlers

BOOL CNotifyDlg::OnInitDialog() {
	CDialog::OnInitDialog();
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL) {
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty()) {
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
//	SetIcon(m_hIcon, TRUE);
//	SetIcon(m_hIcon, FALSE);
	SetWindowContextHelpId(idh_notify_main_ui);
			

	SetClassLong(m_hWnd,GCL_HICON,(LONG)m_hIcon);

	return TRUE;
}

void CNotifyDlg::OnSysCommand(UINT nID, LPARAM lParam) {
	if ((nID & 0xFFF0) == IDM_ABOUTBOX) {
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	} else if((nID & 0xfff0) == SC_CONTEXTHELP)
		Help(HELP_CONTEXT,idh_notify_main_ui);
	else
		CDialog::OnSysCommand(nID, lParam);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CNotifyDlg::OnPaint() {
	if (IsIconic())	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	} else {
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CNotifyDlg::OnQueryDragIcon() {
	return (HCURSOR) m_hIcon;
}

void CNotifyDlg::OnUpdateFailureEd() {
#if 0
	CString text;
	CWnd* hDlg = GetDlgItem(IDC_TEST);
	GetDlgItemText(IDC_FAILURE_ED,text);
	if (text.IsEmpty())
		::EnableWindow(hDlg->m_hWnd,FALSE);
	else {
		::EnableWindow(hDlg->m_hWnd,TRUE);
		CString ta;
		GetDlgItemText(IDC_PROGRESS_ED,ta);
		if (ta.IsEmpty())
			SetDlgItemText(IDC_PROGRESS_ED,text);
		GetDlgItemText(IDC_COMPLETION_ED,ta);
		if (ta.IsEmpty())
			SetDlgItemText(IDC_PROGRESS_ED,text);
	}
#endif
}

BOOL CNotifyDlg::Browse(int type, TCHAR *filename) {

	static TCHAR initDir[MAX_PATH];
	
	OPENFILENAME ofn;
	memset(&ofn, 0, sizeof(OPENFILENAME));

	ofn.lpstrFilter	= "Sound Files\0*.wav\0\0";
	ofn.Flags		= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
	ofn.lStructSize	= sizeof(OPENFILENAME);
	ofn.hwndOwner	= m_hWnd;
	ofn.nMaxFile	= MAX_PATH;
	ofn.lpstrFile	= filename;

	CString title;

	switch (type) {
		case NOTIFY_PROGRESS:	title.LoadString(IDS_PROGRESS_TITLE);	break;
		case NOTIFY_COMPLETION:	title.LoadString(IDS_COMPLETION_TITLE);	break;
		case NOTIFY_FAILURE:	title.LoadString(IDS_FAILURE_TITLE);	break;
	}

	ofn.lpstrTitle	= (char *)(void *)LPCTSTR(title);

	if (!initDir[0]) {
		GetWindowsDirectory(initDir,MAX_PATH);
		_tcscat(initDir,"\\Media");
	}

	ofn.lpstrInitialDir	= initDir;

	if (GetOpenFileName(&ofn)) {
		_tcscpy(filename,ofn.lpstrFile);
		return TRUE;
	}

	return FALSE;

}

void CNotifyDlg::OnBrowseFailure() {
	CString filename;
	GetDlgItemText(IDC_FAILURE_ED,filename);
	if (Browse(NOTIFY_FAILURE,filename.GetBuffer(MAX_PATH)))
		SetDlgItemText(IDC_FAILURE_ED,filename);
}

void CNotifyDlg::OnBrowseProgress() {
	CString filename;
	GetDlgItemText(IDC_PROGRESS_ED,filename);
	if (Browse(NOTIFY_PROGRESS,filename.GetBuffer(MAX_PATH)))
		SetDlgItemText(IDC_PROGRESS_ED,filename);
}

void CNotifyDlg::OnBrowseCompletion() {
	CString filename;
	GetDlgItemText(IDC_COMPLETION_ED,filename);
	if (Browse(NOTIFY_COMPLETION,filename.GetBuffer(MAX_PATH)))
		SetDlgItemText(IDC_COMPLETION_ED,filename);
}

void CNotifyDlg::OnPlayFailure() {
	CString filename;
	GetDlgItemText(IDC_FAILURE_ED,filename);
	if (!filename.IsEmpty())
		sndPlaySound(filename,SND_ASYNC);
}

void CNotifyDlg::OnPlayCompletion() {
	CString filename;
	GetDlgItemText(IDC_COMPLETION_ED,filename);
	if (!filename.IsEmpty())
		sndPlaySound(filename,SND_ASYNC);
}

void CNotifyDlg::OnPlayProgress() {
	CString filename;
	GetDlgItemText(IDC_PROGRESS_ED,filename);
	if (!filename.IsEmpty())
		sndPlaySound(filename,SND_ASYNC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\notify.cpp ===
//-----------------------------------------------------------------------------
// Notify.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <direct.h>
#include "Notify.h"
#include "notifdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//-----------------------------------------------------------------------------
// Globals

	//MAPILOGON*			lpMapiLogon;
	//MAPILOGOFF*			lpMapiLogoff;
	//MAPISENDMAIL*			lpMapiSendMail;
	//MAPISENDDOCUMENTS*	lpMapiSendDocuments;
	//MAPIDETAILS*			lpMapiDetails;

//-----------------------------------------------------------------------------
// CNotifyApp

BEGIN_MESSAGE_MAP(CNotifyApp, CWinApp)
	//{{AFX_MSG_MAP(CNotifyApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------
// CNotifyApp construction

CNotifyApp::CNotifyApp() {
	
	//-- Set where the .INI file is located
	
	TCHAR szCurDir[_MAX_DIR];
	_getcwd(szCurDir,_MAX_DIR);
	m_sINIname.Format(_T("%s\\Notify.ini"),szCurDir);

}

//-----------------------------------------------------------------------------
// CNotifyApp destruction

CNotifyApp::~CNotifyApp() {
	//if (hlibMAPI) {
	//::FreeLibrary(hlibMAPI);
	//hlibMAPI = 0;
	//}
}
//-----------------------------------------------------------------------------
// The one and only CNotifyApp object

CNotifyApp	theApp;
CNotifyApp* theAppPtr = &theApp;

//-----------------------------------------------------------------------------
// CNotifyApp initialization

BOOL CNotifyApp::InitInstance() {

	AfxEnableControlContainer();

	#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
	#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
	#endif

	//-------------------------------------------------------------------------
	//-- Load INI Configuration

	TCHAR buffer[_MAX_DIR];
	
	GetPrivateProfileString(iniMAILTARGETS, iniFAILURE,"",
		(char*)&buffer,sizeof(buffer),m_sINIname);
	if (buffer[0])
		failureTarget = buffer;
	GetPrivateProfileString(iniMAILTARGETS, iniPROGRESS,"",
		(char*)&buffer,sizeof(buffer),m_sINIname);
	if (buffer[0])
		progressTarget = buffer;
	GetPrivateProfileString(iniMAILTARGETS, iniCOMPLETION,"",
		(char*)&buffer,sizeof(buffer),m_sINIname);
	if (buffer[0])
		completionTarget = buffer;

	//GetPrivateProfileString(iniMAILSOURCE, iniFROM,"",
	//	(char*)&buffer,sizeof(buffer),m_sINIname);
	//if (buffer[0])
	//	fromAddress = buffer;
	
	//-------------------------------------------------------------------------
	//-- Check Command Line Arguments

	CString	alertFile;

	if (__argc == 3) {
		
		//-- Get Arguments --------------------------------
		
		alertFile	= __argv[1];
		alertFlags	= (DWORD)(atoi(__argv[2]));
	
		//-- Setup Email Notification ---------------------

		CString notifyType;

		switch (alertFlags) {
			case NOTIFY_FAILURE:
				sndPlaySound(failureTarget,SND_SYNC);
				break;
			case NOTIFY_PROGRESS:
				sndPlaySound(progressTarget,SND_SYNC);
				break;
			case NOTIFY_COMPLETION:
				sndPlaySound(completionTarget,SND_SYNC);
				break;
		}

		return FALSE;
	
	}

	//-------------------------------------------------------------------------
	//-- Standard initialization (Running Interactively)

	CNotifyDlg	dlg;
	m_pMainWnd	= &dlg;
	
	dlg.m_CompletionTarget	= completionTarget;
	dlg.m_ProgressTarget	= progressTarget;
	dlg.m_FailureTarget		= failureTarget;
	//dlg.m_FromAddress		= fromAddress;

	if (dlg.DoModal() == IDOK) {

		//-- Save Settings

		WritePrivateProfileString(iniMAILTARGETS, iniFAILURE,
			dlg.m_FailureTarget, m_sINIname);
		WritePrivateProfileString(iniMAILTARGETS, iniPROGRESS,
			dlg.m_ProgressTarget, m_sINIname);
		WritePrivateProfileString(iniMAILTARGETS, iniCOMPLETION,
			dlg.m_CompletionTarget, m_sINIname);
		//WritePrivateProfileString(iniMAILSOURCE, iniFROM,
		//	dlg.m_FromAddress, m_sINIname);
	}

	//-- Since the dialog has been closed, return FALSE so that we exit the
	//-- application, rather than start the application's message pump.
	
	return FALSE;

}

#if 0

//-----------------------------------------------------------------------------
// CNotifyApp::SendMail()

BOOL CNotifyApp::SendMail( ) {

	static CString maxSubject = "3D Studio Max Notification";
	static CString maxBody;

	if (!InitMapi())
		return FALSE;

	//-- Init Mail Subsystem

	LHANDLE lhSession;
	ULONG res = (*lpMapiLogon)(0,NULL,NULL,0,0,(LPLHANDLE)&lhSession);
	if (res != SUCCESS_SUCCESS)
		return (FALSE);

	//-- Define Target

	CString target;

	switch (alertFlags) {
		case NOTIFY_PROGRESS:	target = progressTarget;	break;
		case NOTIFY_COMPLETION:	target = completionTarget;	break;
		case NOTIFY_FAILURE:
		default:				target = failureTarget;		break;
	}

	//-- Prepare Message Body

	maxBody	=	"3D Studio Max Notification Report\n\n";
	maxBody +=	"Message\n";

	//-- Prepare Message "From" Address

	CString sourceAddress;
	sourceAddress.Format("SMTP:%s",fromAddress);
	MapiRecipDesc sourceDesc;
	memset(&sourceDesc,0,sizeof(MapiRecipDesc));
	sourceDesc.ulRecipClass	= MAPI_ORIG;
	sourceDesc.lpszAddress	= (char *)(void *)LPCTSTR(sourceAddress);

	//-- Prepare Message "TO" Address

	CString targetAddress;
	targetAddress.Format("SMTP:%s",target);
	MapiRecipDesc targetDesc[2];
	memset(&targetDesc[0],0,sizeof(MapiRecipDesc) * 2);
	targetDesc[0].ulRecipClass	= MAPI_TO;
	targetDesc[0].lpszAddress	= (char *)(void *)LPCTSTR(targetAddress);

	//-- Prepeare Message Header

	MapiMessage msg;
	memset(&msg,0,sizeof(MapiMessage));
	msg.lpszSubject		= (char *)(void *)LPCTSTR(maxSubject);
	msg.lpszNoteText	= (char *)(void *)LPCTSTR(maxBody);
	msg.lpOriginator	= &sourceDesc;
	msg.nRecipCount		= 1;
	msg.lpRecips		= targetDesc;

	//-- Send the thing
	
	ULONG result = (*lpMapiSendMail)(lhSession,0,&msg,MAPI_DIALOG,0);
	
	(*lpMapiLogoff)(lhSession,0,0,0);

	if (result == SUCCESS_SUCCESS)
		return(TRUE);
	else
		return (FALSE);

}

//-----------------------------------------------------------------------------
// CNotifyApp::InitMapi()

BOOL CNotifyApp::InitMapi(void) {

    UINT fuError;
    if(!MapiInstalled())
        return FALSE;

    fuError		= ::SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hlibMAPI	= ::LoadLibraryEx("mapi32.dll", NULL, 0);
    ::SetErrorMode(fuError);
    
	if (!hlibMAPI)
	    return (FALSE);

	if (!(lpMapiLogon			= (MAPILOGON *)GetProcAddress (hlibMAPI,"MAPILogon")))
		return (FALSE);
    if (!(lpMapiLogoff			= (MAPILOGOFF *)GetProcAddress (hlibMAPI,"MAPILogoff")))
		return (FALSE);
    if (!(lpMapiSendMail		= (MAPISENDMAIL *)GetProcAddress (hlibMAPI,"MAPISendMail")))
		return (FALSE);
    if (!(lpMapiSendDocuments	= (MAPISENDDOCUMENTS *)GetProcAddress (hlibMAPI,"MAPISendDocuments")))
		return (FALSE);

    return (TRUE);

}

//-----------------------------------------------------------------------------
// CNotifyApp::MapiInstalled()

BOOL CNotifyApp::MapiInstalled(void) {
    OSVERSIONINFO osvinfo;
    LONG lr;
    HKEY hkWMS;
    #define MAPIVSize 8
    unsigned char szMAPIValue[MAPIVSize];
    DWORD dwType;
    DWORD cbMAPIValue = MAPIVSize;
    osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(!GetVersionEx(&osvinfo))
		return FALSE;
	if( osvinfo.dwMajorVersion > 3 || (osvinfo.dwMajorVersion == 3 && osvinfo.dwMinorVersion > 51)) {
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows Messaging Subsystem",0, KEY_READ, &hkWMS);
        if(ERROR_SUCCESS == lr) {
            lr = RegQueryValueEx(hkWMS,"MAPI",0,&dwType,szMAPIValue, &cbMAPIValue);
            RegCloseKey(hkWMS);
            if(ERROR_SUCCESS == lr) {
                //Assert(dwType == REG_SZ);
                if(lstrcmp((char *)(void *)szMAPIValue, "1") == 0)
                    return TRUE;
            }
        }
        return FALSE;
    }
    return GetProfileInt("Mail","MAPI",0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\notifdlg.h ===
// NotifyDlg.h : header file
//

#if !defined(AFX_NOTIFYDLG_H__25CB49CB_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
#define AFX_NOTIFYDLG_H__25CB49CB_AB8D_11D0_9667_00A0249611DC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CNotifyDlg dialog

class CNotifyDlg : public CDialog
{
// Construction
public:
	CNotifyDlg(CWnd* pParent = NULL);	// standard constructor
	BOOL Browse(int type, TCHAR *filename);

// Dialog Data
	//{{AFX_DATA(CNotifyDlg)
	enum { IDD = IDD_SOUNDS };
	CString	m_CompletionTarget;
	CString	m_FailureTarget;
	CString	m_ProgressTarget;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNotifyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CNotifyDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnUpdateFailureEd();
	afx_msg void OnBrowseFailure();
	afx_msg void OnBrowseProgress();
	afx_msg void OnBrowseCompletion();
	afx_msg void OnPlayFailure();
	afx_msg void OnPlayCompletion();
	afx_msg void OnPlayProgress();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NOTIFYDLG_H__25CB49CB_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Notify.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_NOTIFY_DIALOG               102
#define IDS_PROGRESS_TITLE              102
#define IDS_COMPLETION_TITLE            103
#define IDS_FAILURE_TITLE               104
#define IDR_MAINFRAME                   128
#define IDD_SOUNDS                      129
#define IDC_FAILURE_ED                  1000
#define IDC_PROGRESS_ED                 1001
#define IDC_COMPLETION_ED               1002
#define IDC_BROWSE_FAILURE              1004
#define IDC_BROWSE_PROGRESS             1005
#define IDC_BROWSE_COMPLETION           1006
#define IDC_PLAY_FAILURE                1007
#define IDC_PLAY_PROGRESS               1008
#define IDC_PLAY_COMPLETION             1009
#define IDC_LOGO                        1258

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\notify.h ===
//-----------------------------------------------------------------------------
// Notify.h : main header file for the NOTIFY application
//

#if !defined(AFX_NOTIFY_H__25CB49C9_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
#define AFX_NOTIFY_H__25CB49C9_AB8D_11D0_9667_00A0249611DC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include <alerts.h>
#include <mmsystem.h>
//#include <mapi.h>

//-----------------------------------------------------------------------------
// INI File Constants

#if 0

#define iniMAILTARGETS		"Mail Targets"
#define iniFAILURE			"Failure"
#define iniPROGRESS			"Progress"
#define iniCOMPLETION		"Completion"

#define iniMAILSOURCE		"Mail Source"
#define iniFROM				"From"

#else

#define iniMAILTARGETS		"Sounds"
#define iniFAILURE			"Failure"
#define iniPROGRESS			"Progress"
#define iniCOMPLETION		"Completion"

#endif

//-----------------------------------------------------------------------------
// CNotifyApp:
// See Notify.cpp for the implementation of this class
//

class CNotifyApp : public CWinApp {

public:

			CNotifyApp		( );
			~CNotifyApp		( );
	
	//BOOL	SendMail		( void );
	//BOOL	InitMapi		( void );
	//BOOL	MapiInstalled	( void );

	//HINSTANCE hlibMAPI;
	//CString fromAddress;

	CString	m_sINIname;

	CString failureTarget;
	CString progressTarget;
	CString completionTarget;
	
	DWORD	alertFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNotifyApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CNotifyApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NOTIFY_H__25CB49C9_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Notify.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Notify\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__25CB49CD_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
#define AFX_STDAFX_H__25CB49CD_AB8D_11D0_9667_00A0249611DC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__25CB49CD_AB8D_11D0_9667_00A0249611DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\3dsurfer.h ===
// 3dsurfer.h

#include "istdplug.h"

class SurferPatchDataReaderCallback : public ObjectDataReaderCallback {
public:
	char *DataName () { return "MinervaSoftware_Patch_3"; }
	Object *ReadData (TriObject *tri, void *data, DWORD len);
	void DeleteThis() { return; }
};

class SurferSplineDataReaderCallback : public ObjectDataReaderCallback {
public:
	char *DataName () { return "MinervaSoftware_Spline_2"; }
	Object *ReadData (TriObject *tri, void *data, DWORD len);
	void DeleteThis () { return; }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\3dsurfer.cpp ===
/*
	3dsurf.cpp
	By Steve Anderson
	Importing details for 3dsurfer models from 3ds classic.
*/

#include "prim.h" 
#include "splshape.h"
#include "linshape.h"
#include "iparamm.h"
#include "simpspl.h"
#include "3dsurfer.h"

/* Types of splines */
#define MSPL_LIN	0
#define MSPL_CARD	1
#define MSPL_BSPL	2

/* Macros for accessing parameter info, which is hidden in userdata: */

/* Spline macros */
#define MSPL_TYPE	vals[0]
#define MSPL_TENS	vals[1]	/* 1000x fixed-point */
#define MSPL_STEP	vals[2]
#define MSPL_CLOS	vals[3]

/* Patch macros */
#define MPAT_UNUM	vals[0]
#define MPAT_UTYPE	vals[1]
#define MPAT_UTENS	vals[2]	/* 1000x fixed-point */
#define MPAT_USTEP	vals[3]
#define MPAT_UCLOS	vals[4]
#define MPAT_VNUM	vals[5]
#define MPAT_VTYPE	vals[6]
#define MPAT_VTENS	vals[7]	/* 1000x fixed-point */
#define MPAT_VSTEP	vals[8]
#define MPAT_VCLOS	vals[9]
#define MPAT_TCAP	vals[10]
#define MPAT_TCAPH	vals[11]	/* 1000x fixed-point */
#define MPAT_BCAP	vals[12]
#define MPAT_BCAPH	vals[13]	/* 1000x fixed-point */

Point3 & InputVert (Mesh & mesh, int unum, int vnum, int u, int v)
{
	if (u<0) u=u+unum;
	if (u>unum-1) u=u%unum;
	if (v<0) v=v+vnum;
	if (v>vnum-1) v=v%vnum;
	return mesh.verts[u*vnum+v];
}

#define IN_VERT(u,v) InputVert(msh,unum,vnum,u,v)

Object *SurferPatchDataReaderCallback::ReadData (TriObject *tri, void *data, DWORD len)
{
	int i, vals[14];
	char *ptr;

	ptr = (char *) data;

	if (len != 107) return tri;
	memcpy (vals, ptr+50, 56);

	Mesh & msh = tri->GetMesh();
	if (msh.numVerts != MPAT_UNUM*MPAT_VNUM) return tri;

	int vrtnum, vecnum, pnum, cnum;

	PatchObject *pobj;
	pobj = new PatchObject;
	PatchMesh & pch = pobj->patch;
	PatchVert vtemp;
	vrtnum = msh.numVerts;
	vecnum = 8*vrtnum;
	pnum = vrtnum;
	if (!MPAT_UCLOS) pnum -= MPAT_VNUM;
	if (!MPAT_VCLOS) pnum -= MPAT_UNUM;
	if ((!MPAT_VCLOS) && (!MPAT_UCLOS)) pnum++;

	cnum = 0;
	if ((MPAT_VCLOS) && (!MPAT_UCLOS)) {
		cnum = MPAT_TCAP + MPAT_BCAP;
		pnum += MPAT_VNUM*cnum;
		vecnum += MPAT_VNUM*cnum*4;
	}
	if ((!MPAT_VCLOS) && (MPAT_UCLOS)) {
		cnum = MPAT_TCAP + MPAT_BCAP;
		pnum += MPAT_UNUM*cnum;
		vecnum += MPAT_UNUM*cnum*4;
	}
	vrtnum += cnum;
	pch.setNumVerts (vrtnum);
	pch.setNumVecs  (vecnum);
	pch.setNumPatches (pnum);

	int u, v, ustart, uend, vstart, vend, uoff, voff, vnum, unum, uu, vv;
	Point3 center, vup, vdown, uup, udown;

	unum = MPAT_UNUM;
	vnum = MPAT_VNUM;
	if (unum<3) MPAT_UTYPE = MSPL_LIN;
	if (vnum<3) MPAT_VTYPE = MSPL_LIN;

	float utens = MPAT_UTENS/3000.0f;
	float vtens = MPAT_VTENS/3000.0f;
	if (MPAT_UTYPE == MSPL_BSPL) utens = 1.0f/6.0f;
	if (MPAT_VTYPE == MSPL_BSPL) vtens = 1.0f/6.0f;

	pnum = vecnum = vrtnum = 0;
	int interior = unum*vnum*4;
	for (u=0; u<unum; u++) {
		ustart = !(MPAT_UCLOS || u);
		uend = !(MPAT_UCLOS || (u<unum-1));
		uoff = (!ustart) && (!uend) && (MPAT_UTYPE == MSPL_BSPL);
		for (v=0; v<vnum; v++) {
			vstart = !(MPAT_VCLOS || v);
			vend = !(MPAT_VCLOS || (v<vnum-1));
			voff = (!vstart) && (!vend) && (MPAT_VTYPE == MSPL_BSPL);
			if (voff && uoff) {
				center = IN_VERT(u,v)*4.0f;
				center += IN_VERT(u-1,v);
				center += IN_VERT(u+1,v);
				center += IN_VERT(u,v+1);
				center += IN_VERT(u,v-1);
				center *= 4.0f;
				center += IN_VERT(u-1,v-1);
				center += IN_VERT(u-1,v+1);
				center += IN_VERT(u+1,v-1);
				center += IN_VERT(u+1,v+1);
				center = center/36.0f;
			}
			if (uoff && (!voff)) {
				center = IN_VERT(u,v)*4.0f;
				center += IN_VERT(u-1,v);
				center += IN_VERT(u+1,v);
				center = center/6.0f;
			}
			if ((!uoff) && voff) {
				center = IN_VERT(u,v)*4.0f;
				center += IN_VERT(u,v-1);
				center += IN_VERT(u,v+1);
				center = center/6.0f;
			}
			if ((!uoff) && (!voff)) center = IN_VERT(u,v);
			
			pch.setVert (vrtnum++, center);
			
			switch (MPAT_UTYPE) {
			case MSPL_LIN:
				if (ustart)	udown = (IN_VERT(u,v) - IN_VERT(u+1,v))/3.0f;
				else		udown = (IN_VERT(u-1,v) - IN_VERT(u,v))/3.0f;
				if (uend)	uup   = (IN_VERT(u,v) - IN_VERT(u-1,v))/3.0f;
				else		uup   = (IN_VERT(u+1,v) - IN_VERT(u,v))/3.0f;
				break;
			case MSPL_CARD:
				if ((!ustart) && (!uend)) uup = (IN_VERT(u+1,v) - IN_VERT(u-1,v))*utens;
				if (ustart) uup = (3.0f*IN_VERT(u+1,v) - 2.0f*IN_VERT(u,v) - IN_VERT(u+2,v))*utens;
				if (uend)	uup = (2.0f*IN_VERT(u,v) + IN_VERT(u-2,v) - 3.0f*IN_VERT(u-1,v))*utens;
				udown = -uup;
				break;
			case MSPL_BSPL:
				if ((!ustart) && (!uend)) uup = (IN_VERT(u+1,v) - IN_VERT(u-1,v))*utens;
				if (ustart) uup = (IN_VERT(u+1,v) - IN_VERT(u,v))*2.0f*utens;
				if (uend)	uup = (IN_VERT(u,v) - IN_VERT(u-1,v))*2.0f*utens;
				udown = -uup;
				break;
			}
			udown += center;
			uup   += center;
			
			switch (MPAT_VTYPE) {
			case MSPL_LIN:
				if (vstart) vdown = (IN_VERT(u,v) - IN_VERT(u,v+1))/3.0f;
				else		vdown = (IN_VERT(u,v-1) - IN_VERT(u,v))/3.0f;
				if (vend)	vup   = (IN_VERT(u,v) - IN_VERT(u,v-1))/3.0f;
				else		vup   = (IN_VERT(u,v+1) - IN_VERT(u,v))/3.0f;
				break;
			case MSPL_CARD:
				if ((!vstart) && (!vend)) vup = (IN_VERT(u,v+1) - IN_VERT(u,v-1))*vtens;
				if (vstart) vup = (3.0f*IN_VERT(u,v+1) - 2.0f*IN_VERT(u,v) - IN_VERT(u,v+2))*2.0f*vtens;
				if (vend)	vup = (2.0f*IN_VERT(u,v) + IN_VERT(u,v-2) - 3.0f*IN_VERT(u,v-1))*2.0f*vtens;
				vdown = -vup;
				break;
			case MSPL_BSPL:
				if ((!vstart) && (!vend)) vup = (IN_VERT(u,v+1) - IN_VERT(u,v-1))*vtens;
				if (vstart) vup = (IN_VERT(u,v+1) - IN_VERT(u,v))*2.0f*vtens;
				if (vend)	vup = (IN_VERT(u,v) - IN_VERT(u,v-1))*2.0f*vtens;
				vdown = -vup;
				break;
			}
			vdown += center;
			vup   += center;

			pch.setVec (vecnum++, udown);
			pch.setVec (vecnum++, vdown);
			pch.setVec (vecnum++, uup);
			pch.setVec (vecnum++, vup);
			
			if ((!vend) && (!uend)) {
				uu=(u+1)%unum;
				vv=(v+1)%vnum;

				pch.patches[pnum].SetType (PATCH_QUAD);
				pch.patches[pnum].setVerts (u*vnum+v, u*vnum+vv, uu*vnum+vv, uu*vnum+v);
				pch.patches[pnum].setVecs ((u*vnum+v)*4+3, (u*vnum+vv)*4+1,
					(u*vnum+vv)*4+2, (uu*vnum+vv)*4, (uu*vnum+vv)*4+1,
					(uu*vnum+v)*4+3, (uu*vnum+v)*4, (u*vnum+v)*4+2);
				pch.patches[pnum].setInteriors (interior, interior+1, interior+2, interior+3);
				interior += 4;
				pch.patches[pnum].smGroup = 16;
				pnum++;
			}
		}
	}
	
	// Capping:
	float radius, area, veclen, dp, hfactor;
	Point3 normal, p0, newvec;
	int offset, offset2, offset3=unum*vnum*8;
	if ((cnum>0) && (MPAT_VCLOS)) {
		if (MPAT_TCAP) {
			normal = center = Point3(0.0f,0.0f,0.0f);
			offset=(unum-1)*vnum;
			for (v=0; v<vnum; v++) {
				center += pch.verts[offset+v].p;
			}
			center = center/((float)vnum);
			p0=pch.verts[offset].p;
			for (v=1; v<vnum-1; v++) {
				normal += (pch.verts[offset+v].p - p0)^(pch.verts[offset+v+1].p - p0); 
			}
			
			// normal now has the normal direction and the length of the area.
			// Area more or less equals pi r squared.
			area = Length(normal);
			normal = normal/area;
			radius = (float) sqrt(area/3.14159265);

			// Factor in dot products of upward-pointing vectors with normal.
			offset2 = (unum-1)*vnum*4;
			for (v=0,dp=0.0f; v<vnum; v++) {
				p0 = pch.vecs[offset2+v*4+2].p - pch.verts[offset+v].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				dp += DotProd (normal, p0)/veclen;
			}
			dp = dp/vnum;
			hfactor = radius*dp*MPAT_TCAPH/1000.0f;

			// Correct upward-pointing vectors to something better for capping.
			for (v=0; v<vnum; v++) {
				p0 = pch.vecs[offset2+v*4+2].p - pch.verts[offset+v].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				p0 *= (hfactor/veclen)/2.0f;
				pch.vecs[offset2+v*4+2].p = pch.verts[offset+v].p + p0;
			}

			// Produce correct cap point
			p0 = center + normal*hfactor;
			pch.setVert (vrtnum++, p0);

			// Construct tri patches between main patch and cap point.
			for (v=0; v<vnum; v++) {
				vv = (v+1)%vnum;
				newvec = (pch.verts[offset+v].p - p0)/2.0f;
				newvec = newvec - DotProd(newvec,normal)*normal;
				pch.setVec (offset3++, newvec+p0);

				pch.patches[pnum].SetType (PATCH_TRI);
				pch.patches[pnum].setVerts (offset+v, offset+vv, vrtnum-1);
				pch.patches[pnum].setVecs (offset2+v*4+3, offset2+vv*4+1,
					offset2+vv*4+2, offset3-1+(vv-v)*4, offset3-1, offset2+v*4+2);
				pch.patches[pnum].setInteriors (offset3, offset3+1, offset3+2);
				offset3 += 3;
				pch.patches[pnum].smGroup = 16;
				pnum++;
			}
		}

		if (MPAT_BCAP) {
			normal = center = Point3(0.0f,0.0f,0.0f);
			offset=0;
			for (v=0; v<vnum; v++) {
				center += pch.verts[offset+v].p;
			}
			center = center/((float)vnum);
			p0=pch.verts[offset].p;
			for (v=1; v<vnum-1; v++) {
				normal += (pch.verts[offset+v].p - p0)^(pch.verts[offset+v+1].p - p0); 
			}
			
			// normal now has the normal direction and the length of the area.
			// Area more or less equals pi r squared.
			area = Length(normal);
			normal = -normal/area;
			radius = (float) sqrt(area/3.14159265);

			// Factor in dot products of downward-pointing vectors with normal.
			offset2 = 0;
			for (v=0,dp=0.0f; v<vnum; v++) {
				p0 = pch.vecs[offset2+v*4+0].p - pch.verts[offset+v].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				dp += DotProd (normal, p0)/veclen;
			}
			dp = dp/vnum;
			hfactor = dp*radius*MPAT_BCAPH/1000.0f;

			// Correct downward-pointing vectors to something better for capping.
			for (v=0; v<vnum; v++) {
				p0 = pch.vecs[offset2+v*4+0].p - pch.verts[offset+v].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				p0 *= (hfactor/veclen)/2.0f;
				pch.vecs[offset2+v*4+0].p = pch.verts[offset+v].p + p0;
			}

			// Produce correct cap point
			p0 = center + normal*hfactor;
			pch.setVert (vrtnum++, p0);

			// Construct tri patches between main patch and cap point.
			for (v=0; v<vnum; v++) {
				vv = (v+1)%vnum;
				newvec = (pch.verts[offset+v].p - p0)/2.0f;
				newvec = newvec - DotProd(newvec,normal)*normal;
				pch.setVec (offset3++, newvec+p0);

				pch.patches[pnum].SetType (PATCH_TRI);
				pch.patches[pnum].setVerts (offset+vv, offset+v, vrtnum-1);
				pch.patches[pnum].setVecs (offset2+vv*4+1, offset2+v*4+3,
					offset2+v*4+0, offset3-1, offset3-1+(vv-v)*4, offset2+vv*4+0);
				pch.patches[pnum].setInteriors (offset3, offset3+1, offset3+2);
				offset3 += 3;
				pch.patches[pnum].smGroup = 16;
				pnum++;
			}
		}
	}

	if ((cnum>0) && (MPAT_UCLOS)) {	// Mutually exclusive with above.
		if (MPAT_TCAP) {
			normal = center = Point3(0.0f,0.0f,0.0f);
			offset = vnum-1;
			for (u=0; u<unum; u++) {
				center += pch.verts[offset+u*vnum].p;
			}
			center = center/((float)unum);
			p0=pch.verts[offset].p;
			for (u=1; u<unum-1; u++) {
				normal += (pch.verts[offset+u*vnum].p - p0)^(pch.verts[offset+(u+1)*vnum].p - p0); 
			}
			
			// normal now has the normal direction and the length of the area.
			// Area more or less equals pi r squared.
			area = Length(normal);
			normal = -normal/area;
			radius = (float) sqrt(area/3.14159265);

			// Factor in dot products of upward-pointing vectors with normal.
			offset2 = (vnum-1)*4;
			for (u=0,dp=0.0f; u<unum; u++) {
				p0 = pch.vecs[offset2+u*vnum*4+3].p - pch.verts[offset+u*vnum].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				dp += DotProd (normal, p0)/veclen;
			}
			dp = dp/unum;
			hfactor = radius*dp*MPAT_TCAPH/1000.0f;

			// Correct upward-pointing vectors to something better for capping.
			for (u=0; u<unum; u++) {
				p0 = pch.vecs[offset2+u*vnum*4+3].p - pch.verts[offset+u*vnum].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				p0 *= (hfactor/veclen)/2.0f;
				pch.vecs[offset2+u*vnum*4+3].p = pch.verts[offset+u*vnum].p + p0;
			}

			// Produce correct cap point
			p0 = center + normal*hfactor;
			pch.setVert (vrtnum++, p0);

			// Construct tri patches between main patch and cap point.
			for (u=0; u<unum; u++) {
				uu = (u+1)%unum;
				newvec = (pch.verts[offset+u*vnum].p - p0)/2.0f;
				newvec = newvec - DotProd(newvec,normal)*normal;
				pch.setVec (offset3++, newvec+p0);

				pch.patches[pnum].SetType (PATCH_TRI);
				pch.patches[pnum].setVerts (offset+uu*vnum, offset+u*vnum, vrtnum-1);
				pch.patches[pnum].setVecs (offset2+uu*vnum*4+0, offset2+u*vnum*4+2,
					offset2+u*vnum*4+3, offset3-1, offset3-1+(uu-u)*4, offset2+uu*vnum*4+3);
				pch.patches[pnum].setInteriors (offset3, offset3+1, offset3+2);
				offset3 += 3;
				pch.patches[pnum].smGroup = 16;
				pnum++;
			}
		}

		if (MPAT_BCAP) {
			normal = center = Point3(0.0f,0.0f,0.0f);
			for (u=0; u<unum; u++) {
				center += pch.verts[u*vnum].p;
			}
			center = center/((float)unum);
			p0=pch.verts[0].p;
			for (u=1; u<unum-1; u++) {
				normal += (pch.verts[u*vnum].p - p0)^(pch.verts[(u+1)*vnum].p - p0); 
			}
			
			// normal now has the normal direction and the length of the area.
			// Area more or less equals pi r squared.
			area = Length(normal);
			normal = normal/area;
			radius = (float) sqrt(area/3.14159265);

			// Factor in dot products of downward-pointing vectors with normal.
			for (u=0,dp=0.0f; u<unum; u++) {
				p0 = pch.vecs[u*vnum*4+1].p - pch.verts[u*vnum].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				dp += DotProd (normal, p0)/veclen;
			}
			dp = dp/unum;
			hfactor = dp*radius*MPAT_BCAPH/1000.0f;

			// Correct downward-pointing vectors to something better for capping.
			for (u=0; u<unum; u++) {
				p0 = pch.vecs[u*vnum*4+1].p - pch.verts[u*vnum].p;
				veclen = Length(p0);
				if (veclen<.001) continue;
				p0 *= (hfactor/veclen)/2.0f;
				pch.vecs[u*vnum*4+1].p = pch.verts[u*vnum].p + p0;
			}

			// Produce correct cap point
			p0 = center + normal*hfactor;
			pch.setVert (vrtnum++, p0);

			// Construct tri patches between main patch and cap point.
			for (u=0; u<unum; u++) {
				uu = (u+1)%unum;
				newvec = (pch.verts[u*vnum].p - p0)/2.0f;
				newvec = newvec - DotProd(newvec,normal)*normal;
				pch.setVec (offset3++, newvec+p0);

				pch.patches[pnum].SetType (PATCH_TRI);
				pch.patches[pnum].setVerts (u*vnum, uu*vnum, vrtnum-1);
				pch.patches[pnum].setVecs (u*vnum*4+2, uu*vnum*4+0,
					uu*vnum*4+1, offset3-1+(uu-u)*4, offset3-1, u*vnum*4+1);
				pch.patches[pnum].setInteriors (offset3, offset3+1, offset3+2);
				offset3 += 3;
				pch.patches[pnum].smGroup = 16;
				pnum++;
			}
		}
	}

	for (i=0; i<pnum; i++) pch.patches[i].computeInteriors (&pch);
	pch.SetMeshSteps ((MPAT_USTEP+MPAT_VSTEP)/2-1);
	pch.buildLinkages ();
	pch.InvalidateGeomCache ();
	
	return pobj;
}

Object *SurferSplineDataReaderCallback::ReadData (TriObject *tri, void *data, DWORD len)
{
	int i, vals[4];
	char *ptr;

	ptr = (char *) data;

	if (len != 69) return tri;
	memcpy (vals, ptr+52, 16);

	Mesh & mesh=tri->GetMesh();
	if (mesh.numVerts < 2) return tri;

	SplineShape *oshape;
	oshape = new SplineShape;
	BezierShape & shp = oshape->shape;
	shp.NewShape();
	shp.steps = MSPL_STEP-1;
	Spline3D *spl = shp.NewSpline();
	Point3 p, in, out, *pt=mesh.verts;

	int up, dn, start, end, vnum = mesh.numVerts;
	if (vnum<3) MSPL_TYPE = MSPL_LIN;
	float tens = MSPL_TENS/3000.0f;
	if (MSPL_TYPE == MSPL_BSPL) tens = 1.0f/6.0f;
	if (MSPL_TYPE == MSPL_LIN)  tens = 1.0f/3.0f;

	for (i=0; i<vnum; i++) {
		up = (i+1)%vnum;
		dn = (i+vnum-1)%vnum;
		start = ((!MSPL_CLOS) && (!i));
		end   = ((!MSPL_CLOS) && (i==vnum-1));
		if ((MSPL_TYPE != MSPL_BSPL) || start || end) {	p = pt[i]; }
		else { p = (pt[i]*4.0f + pt[up] + pt[dn])/6.0f; }

		switch (MSPL_TYPE) {
		case MSPL_CARD:
			if ((!start) && (!end)) out = (pt[up] - pt[dn])*tens;
			if (start)	out = (3.0f*pt[up]-2.0f*pt[i]-pt[i+2])*tens;
			if (end)	out = (2.0f*pt[i]+pt[i-2]-3.0f*pt[dn])*tens;
			in = -out;
			spl->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p+in,p+out));
			break;
		case MSPL_BSPL:
			if ((!start) && (!end)) out = (pt[up] - pt[dn])*tens;
			if (start)	out = (pt[up]-pt[i])*tens*2.0f;
			if (end)	out = (pt[i]-pt[dn])*tens*2.0f;
			in = -out;
			spl->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p+in,p+out));
			break;
		case MSPL_LIN:
			if (start)	in = (pt[i]-pt[up])*tens;
			else		in = (pt[dn]-pt[i])*tens;
			if (end)	out= (pt[i]-pt[dn])*tens;
			else		out= (pt[up]-pt[i])*tens;
			spl->AddKnot(SplineKnot(KTYPE_BEZIER_CORNER,LTYPE_CURVE,p,p+in,p+out));
		}
	}
	if (MSPL_CLOS)	spl->SetClosed();
	else			spl->SetOpen();
	spl->ComputeBezPoints ();
	shp.UpdateSels();
	shp.InvalidateGeomCache();
	return oshape;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\bones.cpp ===
/**********************************************************************
 *<
	FILE: bones.cpp

	DESCRIPTION:  Bone implementation

	HISTORY: created November 11 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include <props.h>
#include "ikctrl.h"

//------------------------------------------------------

class BoneClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return 0; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_BONES_CLASS); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	SClass_ID		SuperClassID() { return SYSTEM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0x001,0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset);
	};

static BoneClassDesc boneDesc;

ClassDesc* GetBonesDesc() { return &boneDesc; }

class BonesCreationManager : public MouseCallBack, ReferenceMaker {
	friend static BOOL CALLBACK BoneParamDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	friend class PickAutoBone;
	friend class BoneClassDesc;
	private:
		CreateMouseCallBack *createCB;		
		INode *curNode, *lastNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		IPoint2 lastpt;
		int ignoreSelectionChange;
		BOOL assignIK, assignIKRoot, assignEE, autoLink, copyJP, matchAlign;
		HWND hWnd;

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		void AutoBone(INode *cnode,INode *pnode);
		void DoAutoBone(INode *node);
		void MakeEndEffector();
		void AssignIKControllers(INode *cnode,INode *pnode,BOOL newParent,Matrix3 constTM);
		void SetButtonStates(HWND hWnd);

		BonesCreationManager()
			{
			ignoreSelectionChange = FALSE;
			hWnd         = NULL;
			assignIK     = TRUE;
			assignIKRoot = FALSE;
			assignEE     = TRUE; 
			autoLink     = TRUE;
			copyJP       = TRUE;
			matchAlign   = TRUE;
			}
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_BONECREATE	CID_USER + 1

class BonesCreateMode : public CommandMode {		
	public:
		BonesCreationManager proc;

		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		int Class() { return CREATE_COMMAND; }
		int ID() { return CID_BONECREATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints = 1000000; return &proc; }
		ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() {}
		void ExitMode() {}
		BOOL IsSticky() { return FALSE; }
	};

static BonesCreateMode theBonesCreateMode;

void BoneClassDesc::ResetClassParams(BOOL fileReset)
	{
	theBonesCreateMode.proc.assignIK     = TRUE;
	theBonesCreateMode.proc.assignIKRoot = FALSE;
	theBonesCreateMode.proc.assignEE     = TRUE; 
	theBonesCreateMode.proc.autoLink     = TRUE;
	theBonesCreateMode.proc.copyJP       = TRUE;
	theBonesCreateMode.proc.matchAlign   = TRUE;
	}

class PickAutoBone : 
		public PickModeCallback,
		public PickNodeCallback {
	public:				
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		BOOL Filter(INode *node) {return TRUE;}
		PickNodeCallback *GetFilter() {return this;}
	};
static PickAutoBone thePickAutoBone;

BOOL PickAutoBone::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	return node ? TRUE : FALSE;
	}

BOOL PickAutoBone::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	theBonesCreateMode.proc.DoAutoBone(node);
	ip->SetCommandMode(&theBonesCreateMode);
	ip->RedrawViews(ip->GetTime());
	return FALSE;
	}

void PickAutoBone::EnterMode(IObjParam *ip)
	{
	ICustButton *but = GetICustButton(GetDlgItem(
		theBonesCreateMode.proc.hWnd,IDC_BONES_AUTOBONE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	}

void PickAutoBone::ExitMode(IObjParam *ip)
	{
	ICustButton *but = GetICustButton(GetDlgItem(
		theBonesCreateMode.proc.hWnd,IDC_BONES_AUTOBONE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	}



static BOOL CALLBACK BoneParamDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	BonesCreationManager *mgr = (BonesCreationManager*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG: {
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mgr = (BonesCreationManager*)lParam;
			CheckDlgButton(hWnd,IDC_BONES_ASSIGNIK,mgr->assignIK);
			CheckDlgButton(hWnd,IDC_BONES_ASSIGNIKROOT,mgr->assignIKRoot);
			CheckDlgButton(hWnd,IDC_BONES_CREATEENDEFFECTOR,mgr->assignEE);
			CheckDlgButton(hWnd,IDC_BONE_AUTOLINK,mgr->autoLink);
			CheckDlgButton(hWnd,IDC_BONE_COPYIKPARAMS,mgr->copyJP);
			CheckDlgButton(hWnd,IDC_BONE_MATCHALIGNMENT,mgr->matchAlign);			

			mgr->SetButtonStates(hWnd);
			ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_BONES_AUTOBONE));
			but->SetType(CBT_CHECK);
			but->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(but);
			break;
			}
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_BONE_AUTOLINK:
					mgr->autoLink = 
						IsDlgButtonChecked(hWnd,LOWORD(wParam));
					break;
				case IDC_BONE_COPYIKPARAMS:
					mgr->copyJP =
						IsDlgButtonChecked(hWnd,LOWORD(wParam));
					break;
				case IDC_BONE_MATCHALIGNMENT:
					mgr->matchAlign =
						IsDlgButtonChecked(hWnd,LOWORD(wParam));
					break;

				case IDC_BONES_AUTOBONE:
					if (mgr->createInterface->GetCommandMode()->ID() 
						== CID_STDPICK) {
						mgr->createInterface->SetCommandMode(
							&theBonesCreateMode);
					} else {
						mgr->createInterface->SetPickMode(
							&thePickAutoBone);
						}
					break;

				case IDC_BONES_ASSIGNIK:
					mgr->assignIK = 
						IsDlgButtonChecked(hWnd,IDC_BONES_ASSIGNIK);
					mgr->SetButtonStates(hWnd);
					break;
				case IDC_BONES_ASSIGNIKROOT:
					mgr->assignIKRoot = 
						IsDlgButtonChecked(hWnd,IDC_BONES_ASSIGNIKROOT);
					mgr->SetButtonStates(hWnd);
					break;
				case IDC_BONES_CREATEENDEFFECTOR:
					mgr->assignEE = 
						IsDlgButtonChecked(hWnd,IDC_BONES_CREATEENDEFFECTOR);
					mgr->SetButtonStates(hWnd);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void BonesCreationManager::SetButtonStates(HWND hWnd)
	{
	if (assignIK) {
		EnableWindow(GetDlgItem(hWnd,IDC_BONES_ASSIGNIKROOT),TRUE);
		CheckDlgButton(hWnd,IDC_BONES_ASSIGNIKROOT,assignIKRoot);
		EnableWindow(GetDlgItem(hWnd,IDC_BONES_CREATEENDEFFECTOR),TRUE);
		CheckDlgButton(hWnd,IDC_BONES_CREATEENDEFFECTOR,assignEE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_BONES_ASSIGNIKROOT),FALSE);
		CheckDlgButton(hWnd,IDC_BONES_ASSIGNIKROOT,FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_BONES_CREATEENDEFFECTOR),FALSE);
		CheckDlgButton(hWnd,IDC_BONES_CREATEENDEFFECTOR,FALSE);
		}
	}

void BonesCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	createCB        = NULL;
	curNode			= NULL;
	lastNode        = NULL;
	hWnd = createInterface->AddRollupPage(
		hInstance, 
		MAKEINTRESOURCE(IDD_BONEPARAMS), 
		BoneParamDlgProc,
		GetString(IDS_RB_BONEPARAMS),
		(LPARAM)this);
	}

void BonesCreationManager::End()
	{
	createInterface->ClearPickMode();
	createInterface->DeleteRollupPage(hWnd);
	if (curNode) 
		DeleteReference(0);  // sets curNode = NULL
	}

void BonesCreationManager::AutoBone(INode *cnode,INode *pnode)
	{	
	// Create child node
	Object *ob = (Object *)createInterface->
		CreateInstance(HELPER_CLASS_ID,Class_ID(BONE_CLASS_ID,0)); 			
	INode *node = createInterface->CreateObjectNode(ob);
	node->ShowBone(1);		
	Matrix3 ntm = cnode->GetNodeTM(0);
	
	// Only match position if so desired
	if (!matchAlign) {
		Point3 pos = ntm.GetTrans();
		ntm = Matrix3(1);
		ntm.SetTrans(pos);
		}

	// Assign IK controllers
	if (assignIK && (pnode || assignIKRoot)) {
		IKMasterControl *master;
		IKSlaveControl *slave;

		// Either use existing master or make a new one
		Control *cont = NULL;
		if (pnode && (cont=pnode->GetTMController()) &&
			cont->ClassID()==IKSLAVE_CLASSID) {
			// Use its master
			slave  = (IKSlaveControl*)cont;
			master = slave->GetMaster();
		} else {
			// Make a new master
			master = CreateIKMasterControl();
			}

		// Create a slave and assign it to the new node
		slave = CreateIKSlaveControl(master,node);
		node->SetTMController(slave);
		}	
	
	// Set the nod TM and link to parent bone
	node->SetNodeTM(0,ntm);
	if (pnode) pnode->AttachChild(node);	

	// Recurse
	int nc = cnode->NumberOfChildren();
	for (int i=nc-1; i>=0; i--) {
		AutoBone(cnode->GetChildNode(i),node);
		}

	// Attach to bone
	if (autoLink) node->AttachChild(cnode);	

	// Copy IK params
	if (copyJP) {
		IKClipObject *clip = NULL;
		Control *src = cnode->GetTMController();
		Control *dst = node->GetTMController();

		// Do position
		if (src->CanCopyIKParams(COPYPASTE_IKPOS)) 
			clip = src->CopyIKParams(COPYPASTE_IKPOS);
		if (clip && dst->CanPasteIKParams(clip,COPYPASTE_IKPOS)) {
			dst->PasteIKParams(clip,COPYPASTE_IKPOS);
			}
		if (clip) clip->DeleteThis();
		clip = NULL;

		// Do Rotation
		if (src->CanCopyIKParams(COPYPASTE_IKROT)) 
			clip = src->CopyIKParams(COPYPASTE_IKROT);
		if (clip && dst->CanPasteIKParams(clip,COPYPASTE_IKROT)) {
			dst->PasteIKParams(clip,COPYPASTE_IKROT);
			}
		if (clip) clip->DeleteThis();
		clip = NULL;
		}

	// Last nodes in the chain become end effectors
	if (!nc) {
		lastNode = node;
		MakeEndEffector();
		lastNode = NULL;
		}
	}

void BonesCreationManager::DoAutoBone(INode *node)
	{
	theHold.Begin();
	AutoBone(node,NULL);
	createInterface->RedrawViews(createInterface->GetTime());
	theHold.Accept(IDS_DS_CREATE);	 
	}

void BonesCreationManager::MakeEndEffector()
	{
	if (!lastNode || !assignEE) return;
	IKSlaveControl *slave;
	Control *cont = lastNode->GetTMController();
	if (cont && cont->ClassID()==IKSLAVE_CLASSID) {			
		slave  = (IKSlaveControl*)cont;
	} else return;

	Matrix3 tm = lastNode->GetNodeTM(createInterface->GetTime());
	slave->MakeEE(TRUE,1,tm.GetTrans(),Quat());
	}

void BonesCreationManager::AssignIKControllers(
		INode *cnode,INode *pnode,BOOL newParent,Matrix3 constTM)
	{
	Point3 pos;
	IKMasterControl *master;
	IKSlaveControl *slave;
	int axis = 0;
	float projX, projY, projZ, best;

	// Find the world axis that's closest to the construction plane's Z axis
	projX = (float)fabs(DotProd(constTM.GetRow(2),Point3(1,0,0)));
	projY = (float)fabs(DotProd(constTM.GetRow(2),Point3(0,1,0)));
	projZ = (float)fabs(DotProd(constTM.GetRow(2),Point3(0,0,1)));
	best  = projX;
	if (projY>best) {
		axis = 1;
		best = projY;
		}
	if (projZ>best) axis = 2;

	if (newParent && assignIKRoot) {
		// Need to create a new master controller
		master = CreateIKMasterControl();
		slave  = CreateIKSlaveControl(master,pnode);
		pos    = pnode->GetNodeTM(0).GetTrans();
		slave->SetInitPos(pos);
		slave->SetDOF(axis+3,TRUE);
		pnode->SetTMController(slave);
	} else {
		// See if the parent has an IK controller
		Control *cont = pnode->GetTMController();
		if (cont->ClassID()==IKSLAVE_CLASSID) {
			// Use its master
			slave  = (IKSlaveControl*)cont;
			master = slave->GetMaster();
		} else {
			// Make a new master
			master = CreateIKMasterControl();
			}
		}

	// Create a slave for the child node
	slave = CreateIKSlaveControl(master,cnode);
	pos   = cnode->GetNodeTM(0).GetTrans();
	slave->SetInitPos(pos);
	slave->SetDOF(axis+3,TRUE);
	cnode->SetTMController(slave);
	}


void BonesCreationManager::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case 0: curNode = (INode *)rtarg; break;
		default: assert(0); 
		}
	}

RefTargetHandle BonesCreationManager::GetReference(int i) { 
	switch(i) {
		case 0: return (RefTargetHandle)curNode;
		default: assert(0); 
		}
	return NULL;
	}


RefResult BonesCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( curNode==hTarget ) {
				// this will set curNode== NULL;
				DeleteReference(0);
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if ( curNode==hTarget ) {				
				endEdit:
				curNode    = NULL;
				}
			break;		
		}
	return REF_SUCCEED;
	}

static int DSQ(IPoint2 p, IPoint2 q) {
	return (p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y);
	}


class BonesPicker: public PickNodeCallback {
	BOOL Filter(INode *node) {
		Object* obj = node->GetObjectRef();
		if (obj && obj->SuperClassID()==HELPER_CLASS_ID && obj->ClassID()==Class_ID(BONE_CLASS_ID,0))
			return 1;
		return 0;
		}
	};
			
int BonesCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
	{	
	int res;
	INode *newNode,*parNode;	
	BonesPicker bonePick;
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );
	Matrix3 constTM;
	vpx->GetConstructionTM(constTM);


	switch ( msg ) {

		case MOUSE_POINT:
				{
				Object *ob;
				if (point==0) {
					mat.IdentityMatrix();
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}
					}
				else  {
					if (DSQ(m,lastpt)<10) {
						res = TRUE;
						goto done;
						}
					
					theHold.SuperAccept(IDS_DS_CREATE);	 
					}

				if (createInterface->IsCPEdgeOnInView()) { 
					res = FALSE;
					goto done;
					}

				
			   	theHold.SuperBegin();	 // begin hold for undo
				theHold.Begin();

				mat.IdentityMatrix();
#ifdef _3D_CREATE
				mat.SetTrans(constTM*vpx->SnapPoint(m,m,NULL,SNAP_IN_3D));
#else
				//mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
				mat.SetTrans(constTM*vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
#endif

				BOOL newParent = FALSE;
				if (curNode==NULL) 	{
					INode* overBone = createInterface->PickNode(hwnd,m,&bonePick);
					if (overBone) {
						parNode = overBone;
						}
					else {
						// Make first node 
						ob = (Object *)createInterface->
							CreateInstance(HELPER_CLASS_ID,Class_ID(BONE_CLASS_ID,0)); 			
						parNode = createInterface->CreateObjectNode(ob);
						//createInterface->SetNodeTMRelConstPlane(parNode, mat);
						parNode->SetNodeTM(0,mat);
						newParent = TRUE;
						}
					parNode->ShowBone(1);
					}
				else {
					lastNode = parNode = curNode;
					DeleteReference(0);
					}

				// Make new node 
				ob = (Object *)createInterface->
					CreateInstance(HELPER_CLASS_ID,Class_ID(BONE_CLASS_ID,0)); 			
				newNode = createInterface->CreateObjectNode(ob);
				newNode->ShowBone(1);
				
				//createInterface->SetNodeTMRelConstPlane(newNode, mat);
				newNode->SetNodeTM(0,mat);				

				parNode->AttachChild(newNode); // make node a child of prev 
				curNode = newNode;

				// Reference the new node so we'll get notifications.
				MakeRefByID( FOREVER, 0, curNode);
	
				// Assign IK controllers
				if (assignIK) 
					AssignIKControllers(curNode,parNode,newParent,constTM);

			   	ignoreSelectionChange = TRUE;
			   	createInterface->SelectNode( curNode);
			   	ignoreSelectionChange = FALSE;
	
 				createInterface->RedrawViews(createInterface->GetTime());  
				theHold.Accept(IDS_DS_CREATE);	 
				lastpt = m;
				res = TRUE; 
				}
				break;
		case MOUSE_MOVE:
			// The user can loose capture by switching to another app.
			if (!GetCapture()) {				
				theHold.SuperAccept(IDS_DS_CREATE);
				return FALSE;
				}
			
			if (curNode) {
#ifdef _3D_CREATE
				mat.SetTrans(constTM*vpx->SnapPoint(m,m,NULL,SNAP_IN_3D));
#else
				//mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
				mat.SetTrans(constTM*vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
#endif
				//createInterface->SetNodeTMRelConstPlane(curNode, mat);
				curNode->SetNodeTM(0,mat);
				createInterface->RedrawViews(createInterface->GetTime());
				}
			res = TRUE;
			break;

		case MOUSE_FREEMOVE: {
			INode* overNode = createInterface->PickNode(hwnd,m,&bonePick);
			if (overNode) {
				SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
				}
			else {
				SetCursor(LoadCursor(NULL, IDC_ARROW));
				}
			}
#ifdef _OSNAP
		#ifdef _3D_CREATE
				vpx->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
				vpx->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
#endif
			break;

// mjm - 3.1.99
		case MOUSE_PROPCLICK:
			// right click while between creations
			createInterface->RemoveMode(NULL);
			break;
// mjm - end

		case MOUSE_ABORT:
			if (curNode) {				
				theHold.SuperCancel(); // this deletes curNode and everything
				curNode = NULL;	 
				MakeEndEffector();
				createInterface->RedrawViews(createInterface->GetTime()); 
				}
			res = FALSE;
			break;
		}
	
	done:
	createInterface->ReleaseViewport(vpx); 
	return res;
	}

int BoneClassDesc::BeginCreate(Interface *i)
	{
	IObjCreate *iob = i->GetIObjCreate();
	
	theBonesCreateMode.Begin( iob, this );
	iob->PushCommandMode( &theBonesCreateMode );
	
	return TRUE;
	}

int BoneClassDesc::EndCreate(Interface *i)
	{
	
	theBonesCreateMode.End();
	i->RemoveMode( &theBonesCreateMode );

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\arc.cpp ===
/**********************************************************************
 *<
	FILE: arc.cpp

	DESCRIPTION:  An Arc object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 29 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"


#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)

#define MIN_ANGLE		float(0.0)
#define MAX_ANGLE		float(360.0)

#define DEF_RADIUS		float(0.0)
#define DEF_START		float(0.0)
#define DEF_END			float(360.0)
#define DEF_REVERSE		FALSE

#define CREATE_EEC 0
#define CREATE_CEE 1

class ArcObjCreateCallBack;

class ArcObject: public SimpleSpline, public IParamArray {			   

	friend class ArcObjCreateCallBack;
	
	public:
		BOOL halfBaked;		// If TRUE, the arc is in the creation phase and needs a special draw
		Point3 hb;			// The halfBaked line endpoint

		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static int dlgPie;
		static BOOL dlgReverse;
		static Point3 crtPos;		
		static float crtRadius;
		static float crtFrom;
		static float crtTo;
		static int crtPie;		// Probable future enhancement
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		ArcObject();
		~ArcObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_ARC); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_ARC); }		
		Class_ID ClassID() { return Class_ID(ARC_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_ARC_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);
		BOOL ValidForDisplay(TimeValue t);

 		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class ArcObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ArcObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_ARC_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
   	Class_ID		ClassID() { return Class_ID(ARC_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static ArcObjClassDesc arcObjDesc;

ClassDesc* GetArcDesc() { return &arcObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for arc class.
IParamMap *ArcObject::pmapCreate = NULL;
IParamMap *ArcObject::pmapParam  = NULL;
IParamMap *ArcObject::pmapTypeIn = NULL;
IObjParam *ArcObject::ip         = NULL;
Point3 ArcObject::crtPos         = Point3(0,0,0);
float ArcObject::crtRadius       = 0.0f;
float ArcObject::crtFrom         = 0.0f;
float ArcObject::crtTo           = 360.0f;
int ArcObject::crtPie            = 0;
int ArcObject::dlgCreateMeth = CREATE_EEC;
int ArcObject::dlgPie = 0;
BOOL ArcObject::dlgReverse = FALSE;

void ArcObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	ArcObject::crtPos         = Point3(0,0,0);
	ArcObject::crtRadius      = 0.0f;
	ArcObject::crtFrom        = 0.0f;
	ArcObject::crtTo          = 360.0f;
	ArcObject::crtPie         = 0;
	ArcObject::dlgCreateMeth  = CREATE_EEC;
	ArcObject::dlgPie         = 0;
	ArcObject::dlgReverse     = FALSE;
	}

// Parameter map indices
#define PB_RADIUS		0
#define PB_FROM			1
#define PB_TO			2
#define PB_PIE			3
#define PB_REVERSE		4

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_FROM			3
#define PB_TI_TO			4

// Vector length for unit arc
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATE_EEC,IDC_CREATE_CEE};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
			
	// From Angle
	ParamUIDesc(
		PB_TI_FROM,
		EDITTYPE_POS_FLOAT,
		IDC_TI_ARCFROM,IDC_TI_ARCFROMSPINNER,
		MIN_ANGLE,MAX_ANGLE,
		SPIN_AUTOSCALE),
			
	// To Angle
	ParamUIDesc(
		PB_TI_TO,
		EDITTYPE_POS_FLOAT,
		IDC_TI_ARCTO,IDC_TI_ARCTOSPINNER,
		MIN_ANGLE,MAX_ANGLE,
		SPIN_AUTOSCALE)
			
	};
#define TYPEINDESC_LENGTH 4

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// From Angle
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_FLOAT,
		IDC_ARCFROM,IDC_ARCFROMSPINNER,
		MIN_ANGLE,MAX_ANGLE,
		SPIN_AUTOSCALE),
			
	// To Angle
	ParamUIDesc(
		PB_TO,
		EDITTYPE_FLOAT,
		IDC_ARCTO,IDC_ARCTOSPINNER,
		MIN_ANGLE,MAX_ANGLE,
		SPIN_AUTOSCALE),

	// Pie Slice
	ParamUIDesc(PB_PIE,TYPE_SINGLECHEKBOX,IDC_ARCPIE),	
				
	// Reverse
	ParamUIDesc(PB_REVERSE,TYPE_SINGLECHEKBOX,IDC_REVERSE),	
	};
#define PARAMDESC_LENGTH 5


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },		
	{ TYPE_FLOAT, NULL, TRUE, 2 },		
	{ TYPE_INT, NULL, FALSE, 3 } };
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },		
	{ TYPE_FLOAT, NULL, TRUE, 2 },		
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4} };
#define PBLOCK_LENGTH	5

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class ArcTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		ArcObject *ao;

		ArcTypeInDlgProc(ArcObject *c) {ao=c;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ArcTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ao->crtRadius==0.0 || ao->crtFrom == ao->crtTo) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ao->TestAFlag(A_OBJ_CREATING)) {
						ao->pblock->SetValue(PB_RADIUS,0,ao->crtRadius);
						ao->pblock->SetValue(PB_FROM,0,ao->crtFrom);
						ao->pblock->SetValue(PB_TO,0,ao->crtTo);
						ao->pblock->SetValue(PB_PIE,0,ao->crtPie);
						}

					Matrix3 tm(1);
					tm.SetTrans(ao->crtPos);
					ao->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void ArcObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last arc ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_ARCPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_ARCPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_ARCPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new ArcTypeInDlgProc(this));
		}
	}
		
void ArcObject::EndEditParams( IObjParam *ip,ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_PIE,ip->GetTime(),dlgPie,FOREVER);
	pblock->GetValue(PB_REVERSE,ip->GetTime(),dlgReverse,FOREVER);
	}

/* Find the vector length for a circle segment	*/
/* Returns a unit value (radius=1.0)		*/
/* Angle expressed in radians			*/

static float
veccalc(float angstep) {
	static float lastin = -9999.0f,lastout;
	if(lastin == angstep)
		return lastout;

	float lo,hi,totdist;
	float sinfac=(float)sin(angstep),cosfac=(float)cos(angstep),test;
	int ix,count;
	Spline3D work;
	Point3 k1((float)cos(0.0f),(float)sin(0.0f),0.0f);
	Point3 k2(cosfac,sinfac,0.0f);

	hi=1.5f;
	lo=0.0f;
	count=200;

	/* Loop thru test vectors */

	loop:
	work.NewSpline();
	test=(hi+lo)/2.0f;
	Point3 out = k1 + Point3(0.0f, test, 0.0f);
	Point3 in = k2 + Point3(sinfac * test, -cosfac * test, 0.0f);

 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k1,k1,out));
 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k2,in,k2));

	totdist=0.0f;
	for(ix=0; ix<10; ++ix) {
		Point3 terp = work.InterpBezier3D(0,(float)ix/10.0f);
		totdist += (float)sqrt(terp.x * terp.x + terp.y * terp.y);
		}
	
	totdist /= 10.0f;
	count--;
	if(totdist==1.0f || count<=0)
		goto done;
	if(totdist>1.0f) {
		hi=test;
		goto loop;
		}
	lo=test;
	goto loop;

	done:
	lastin = angstep;
	lastout = test;
	return test;
	}

static void MakeArc(BezierShape& ashape, float radius, float from, float to, ArcObject *ob, BOOL pie, BOOL reverse) {
	// Delete all points in the existing spline
	Spline3D *spline = ashape.NewSpline();
	if(ob->halfBaked) {		// Special construction during creation
		Point3 origin(0,0,0);
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_LINE,origin,origin,origin));
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_LINE,ob->hb,ob->hb,ob->hb));
		}
	else {
		Point3 origin(0,0,0);
		// Order angles properly
		if(from > to)
			to += TWOPI;
		float totAngle = to - from;
		float vector = veccalc(totAngle / 3.0f) * radius;
		// Now add all the necessary points
		float angStep = totAngle / 3.0f;
		for(int ix=0; ix<4; ++ix) {
			float angle = from + (float)ix * angStep;
			float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
			Point3 p(cosfac * radius, sinfac * radius, 0.0f);
			Point3 rotvec = Point3(sinfac * vector, -cosfac * vector, 0.0f);
			Point3 invec = (ix==0) ? p : p + rotvec;
			Point3 outvec = (ix==3) ? p : p - rotvec;
			spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,invec,outvec));
			}
		if(pie) {
			spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,origin,origin,origin));
			spline->SetClosed();
			}
		}
	spline->ComputeBezPoints();
	if(reverse)
		spline->Reverse(TRUE);
	}

void ArcObject::BuildShape(TimeValue t, BezierShape& ashape) {
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float radius, from, to;
	int pie;
	BOOL reverse;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_FROM, t, from, ivalid);
	pblock->GetValue(PB_TO, t, to, ivalid);
	pblock->GetValue(PB_PIE, t, pie, ivalid);
	pblock->GetValue(PB_REVERSE, t, reverse, ivalid);
	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	LimitValue( from, MIN_ANGLE, MAX_ANGLE );
	LimitValue( to, MIN_ANGLE, MAX_ANGLE );

	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	MakeArc(ashape, radius, from * DEG_TO_RAD, to * DEG_TO_RAD, this, pie, reverse);
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

ArcObject::ArcObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_FROM,0,crtFrom);
	pblock->SetValue(PB_TO,0,crtTo);
	pblock->SetValue(PB_PIE,0,dlgPie);
	pblock->SetValue(PB_REVERSE,0,dlgReverse);

	halfBaked = FALSE;
 	}

ArcObject::~ArcObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

// Determine where the line segments p1-p2 and p3-p4 intersect
static int FindIntercept(Point2& p1, Point2& p2, Point2& p3, Point2& p4, Point2& icpt) {
	float C1,C2,DENOM;
	Point2 d1,d2;
	float test1,test2;

	d1 = p2 - p1;
	C1= -(p1.y * d1.x - p1.x * d1.y);

	d2 = p4 - p3;
	C2= -(p3.y * d2.x - p3.x * d2.y);

	DENOM= -d1.y * d2.x + d2.y * d1.x;

	if(DENOM==0.0)		/* Lines parallel!!! */
	 {
	 test1 = p1.x * -d2.y + p1.y * d2.x + C2;
	 test2 = p3.x * -d1.y + p3.y * d1.x + C1;
	 if(test1==test2)	/* Lines collinear! */
	  return(2);
	 return(0);
	 }

	if(p1.x == p2.x)
	 icpt.x = p1.x;
	else
	if(p3.x == p4.x)
	 icpt.x = p3.x;
	else
	icpt.x = (d1.x * C2 - d2.x * C1) / DENOM;

	if(p1.y == p2.y)
	 icpt.y = p1.y;
	else
	if(p3.y == p4.y)
	 icpt.y = p3.y;
	else
	icpt.y = (C1 * (-d2.y) - C2 * (-d1.y)) / DENOM;

	return(1);
	}

static float ComputeAngle(Point3 pt, Point3 origin) {
	Point3 vec = Normalize(pt - origin);
	// Dot product gives us the angle
	float dot = DotProd(vec, Point3(1,0,0));
	float angle = 0.0f;
	if(dot >= -1.0f && dot < 1.0f)
		angle = (float)-acos(dot);
	if(vec.y > 0.0f)
		angle = -angle;
	if(angle < 0.0f)
		angle += TWOPI;
	return angle;
	}

class ArcObjCreateCallBack: public CreateMouseCallBack {
	ArcObject *ob;
	IPoint2 sp0, sp1, sp2;
	Point3 center, end1, end2, middle;
	int createType;
	float lastAngle, baseAngle, sumAng;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(ArcObject *obj) { ob = obj; }
	};

int ArcObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	static float r = 0.0f;
	Point3 wp;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	static int dir;
#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				ob->halfBaked = TRUE;
				sp0 = m;
				createType = ob->dlgCreateMeth;
				wp = vpt->SnapPoint(m,m,NULL,snapdim);
				if(createType == CREATE_CEE) {
					center = end1 = wp;
					ob->hb = Point3(0,0,0);
					}
				else {
					end1 = wp;
					ob->hb = Point3(0,0,0);
					}
				mat.SetTrans(wp); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1: 
				sp1 = m;
				wp = vpt->SnapPoint(m,m,NULL,snapdim);
				if ( createType == CREATE_CEE ) {
					ob->hb = wp - center;		// Update half-baked coord
					r = Length(wp - center);
					end1 = wp;
					// Compute the 'from' angle
					float angle = ComputeAngle(end1, center);
					baseAngle = lastAngle = angle;
					ob->pblock->SetValue(PB_FROM,0,angle * RAD_TO_DEG);
					ob->pblock->SetValue(PB_TO,0,angle * RAD_TO_DEG);
					sumAng = 0.0f;
					if(msg==MOUSE_POINT && end1==center)
						return CREATE_ABORT;
					}
				else {
					ob->hb = wp - end1;		// Update half-baked coord
					middle = end2 = wp;
					if(msg==MOUSE_POINT && end1==end2)
						return CREATE_ABORT;
					}
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();
				break;
			case 2:
				sp2 = m;
				wp = vpt->SnapPoint(m,m,NULL,snapdim);
				if(createType == CREATE_CEE) {
					ob->halfBaked = FALSE;
					end2 = wp;
					// Compute the 'to' angle
					float angle = ComputeAngle(end2, center);
					float dang = angle - lastAngle;
					if(dang > PI)
						dang -= TWOPI;
					else
					if(dang < -PI)
						dang += TWOPI;
					sumAng += dang;
					if(sumAng < 0.0f) {
						ob->pblock->SetValue(PB_TO,0,baseAngle * RAD_TO_DEG);
						ob->pblock->SetValue(PB_FROM,0,angle * RAD_TO_DEG);
						}
					else {
						ob->pblock->SetValue(PB_FROM,0,baseAngle * RAD_TO_DEG);
						ob->pblock->SetValue(PB_TO,0,angle * RAD_TO_DEG);
						}
					lastAngle = angle;
					}
				else {
					// Need to compute the center.  This is done by getting the perpendicular
					// bisector of the endpoints and intersecting it with the perpendicular
					// bisector of one endpoint and the mouse position.
					Point2 e1 = Point2(end1.x,end1.y);
					Point2 e2 = Point2(end2.x,end2.y);
					Point2 w = Point2(wp.x,wp.y);
					Point2 ec = (e1 + e2) / 2.0f;	// Point between two endpoints
					Point2 v1 = e2 - e1;
					Point2 pv1 = ec + Point2(-v1.y,v1.x);
					Point2 mc = (w + e1) / 2.0f;	// Point between mouse and endpoint 1
					Point2 v2 = e1 - w;
					Point2 pv2 = mc + Point2(-v2.y,v2.x);
					// Now find their intersection
					Point2 c;
					if(FindIntercept(ec,pv1,mc,pv2,c) == 1) {
						center = Point3(c.x,c.y,end1.z);
						r = Length(center - end1);
						mat.SetTrans(center); // Set Node's transform
						ob->halfBaked = FALSE;				
						
						// Now compute the various angles
						float e1Angle = ComputeAngle(end1, center);
						float e2Angle = ComputeAngle(end2, center);
						float wpAngle = ComputeAngle(wp, center);
						// Figure out which is which
						if(e2Angle > e1Angle) {
							if(wpAngle > e1Angle && wpAngle < e2Angle) {
								ob->pblock->SetValue(PB_FROM,0,e1Angle * RAD_TO_DEG);
								ob->pblock->SetValue(PB_TO,0,e2Angle * RAD_TO_DEG);
								}
							else {
								ob->pblock->SetValue(PB_FROM,0,e2Angle * RAD_TO_DEG);
								ob->pblock->SetValue(PB_TO,0,e1Angle * RAD_TO_DEG);
								}
							}
						else
						if(e1Angle > e2Angle) {
							if(wpAngle > e2Angle && wpAngle < e1Angle) {
								ob->pblock->SetValue(PB_FROM,0,e2Angle * RAD_TO_DEG);
								ob->pblock->SetValue(PB_TO,0,e1Angle * RAD_TO_DEG);
								}
							else {
								ob->pblock->SetValue(PB_FROM,0,e1Angle * RAD_TO_DEG);
								ob->pblock->SetValue(PB_TO,0,e2Angle * RAD_TO_DEG);
								}
							}
						else
							r = 0.0f;	// Bad arc!
						}
					else {
						r = 0.0f;
						ob->halfBaked = TRUE;
						}
					ob->pblock->SetValue(PB_RADIUS,0,r);
					}
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					if((Length(sp0-sp1)<3 && Length(sp1-sp2)<3 && Length(sp0-sp2)<3) || r == 0.0f)
						return CREATE_ABORT;
					return (ob->halfBaked) ? CREATE_ABORT : CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static ArcObjCreateCallBack arcCreateCB;

CreateMouseCallBack* ArcObject::GetCreateMouseCallBack() {
	arcCreateCB.SetObj(this);
	return(&arcCreateCB);
	}

RefTargetHandle ArcObject::Clone(RemapDir& remap) {
	ArcObject* newob = new ArcObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

IOResult ArcObject::Load(ILoad *iload)
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return SimpleSpline::Load(iload);
	}

BOOL ArcObject::ValidForDisplay(TimeValue t) {
	if(halfBaked)
		return TRUE;
	float radius, from, to;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_FROM, t, from, ivalid);
	pblock->GetValue(PB_TO, t, to, ivalid);
	return (radius == 0.0f || from==to) ? FALSE : TRUE;
	}

ParamDimension *ArcObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		case PB_FROM:
		case PB_TO:
			return defaultDim;	// This is an angle but is stored in degrees, not radians
		case PB_PIE:
			return stdNormalizedDim;
		default:
			return defaultDim;
		}
	}

TSTR ArcObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return TSTR(GetString(IDS_TH_RADIUS));			
		case PB_FROM:
			return TSTR(GetString(IDS_TH_FROM));
		case PB_TO:
			return TSTR(GetString(IDS_TH_TO));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL ArcObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		case PB_PIE: dlgPie = v; break;
		case PB_REVERSE: dlgReverse = v; break;
		}		
	return TRUE;
	}

BOOL ArcObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_FROM: crtFrom = v; break;
		case PB_TI_TO: crtTo = v; break;
		}	
	return TRUE;
	}

BOOL ArcObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL ArcObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		case PB_PIE: v = dlgPie; break;
		case PB_REVERSE: v = dlgReverse; break;
		}
	return TRUE;
	}

BOOL ArcObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_FROM: v = crtFrom; break;
		case PB_TI_TO: v = crtTo; break;
		}
	return TRUE;
	}

BOOL ArcObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\boolobj.cpp ===
/**********************************************************************
 *<
	FILE: BoolObj.cpp

	DESCRIPTION:  A Boolean object

	CREATED BY: Rolf Berteig

	HISTORY: created 21 August 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "buildver.h"
#include "istdplug.h"


#define CID_CREATEBOOLMODE		0x7F26A6B1

#define REF_OP1		0
#define REF_OP2		1
#define REF_CONT1	2
#define REF_CONT2	3

// Flag bits
#define BOOL_OB1SEL			(1<<0)
#define BOOL_OB2SEL			(1<<1)
#define BOOL_ANYSEL			(BOOL_OB1SEL|BOOL_OB2SEL)

#define BOOL_DISPRESULT		(1<<2)
#define BOOL_DISPHIDDEN		(1<<12)

#define BOOL_UPDATEALWAYS	(1<<3)
#define BOOL_UPDATERENDER	(1<<4)
#define BOOL_UPDATEMANUAL	(1<<5)
#define BOOL_UPDATESELECT	(1<<11)

#define BOOL_UNION			(1<<6)
#define BOOL_INTERSECTION	(1<<7)
#define BOOL_DIFFERENCEA	(1<<8)
#define BOOL_DIFFERENCEB	(1<<9)
#define BOOL_OPERATION		(BOOL_UNION|BOOL_INTERSECTION|BOOL_DIFFERENCEA|BOOL_DIFFERENCEB)

#define BOOL_OPTIMIZE		(1<<10)

#define BOOL_FIRSTUPDATE	(1<<13)

#define BOOL_INRENDER		(1<<14)

#define BOOL_ABORTED		(1<<15)

#define BOOL_NEEDSUPDATE	(1<<16)


// When more than this number of faces is being booleaned an hour glass
// cursor is put up.
#define LOTSOFACES	2000

class PickOperand;

class BoolObject : public IBoolObject, public MeshOpProgress {
		
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
				
	public:
		TSTR opaName, opbName;
		Object *ob1, *ob2;
		Control *tm1, *tm2;
		Matrix3 obOffset;
		DWORD flags;
		Interval ivalid;
		Mesh mesh;		

		static IObjParam *ip;
		static HWND hParams1;
		static HWND hParams2;		
		static int addOppMethod;
		static Matrix3 createTM;
		static PickOperand pickCB;
		static BOOL creating;
		static BoolObject *editOb;
		static DWORD lastOp;
		static int extractCopy;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;

		BoolObject();
		~BoolObject();
		
		void SetupUI1();
		void SetupUI2(BOOL useName=FALSE);
		void SetExtractButtonState();

		void SetFlag(DWORD mask) { flags|=mask; }
		void ClearFlag(DWORD mask) { flags &= ~mask; }
		int TestFlag(DWORD mask) { return(flags&mask?1:0); }
		DWORD BoolOp(int &order);

		void SetOperandA (TimeValue t, INode *node);
		void SetOperandB (TimeValue t, INode *node, INode *boolNode,
			int addOpMethod=0, int matMergeMethod=0, bool *canUndo=NULL);
		BOOL UpdateMesh(TimeValue t,BOOL force=FALSE,BOOL sel=FALSE);
		Object *GetPipeObj(TimeValue t,int which);
		Matrix3 GetOpTM(TimeValue t,int which,Interval *iv=NULL);
		void Invalidate() {ivalid.SetEmpty();}
		void ExtractOperand(int which);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		TCHAR *GetObjectName() { return GetString(IDS_RB_BOOLEAN); }

		// For sub-object selection
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
		void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc);
		
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert);
		void ClearSelection(int selLevel);

		int SubObjectIndex(HitRecord *hitRec);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);

		void ActivateSubobjSel(int level, XFormModes& modes);


		// From Object		
		void InitNodeName(TSTR& s) {s = GetString(IDS_RB_BOOLEAN);}
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
        BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts);
		ObjectState Eval(TimeValue time);
		int NumPipeBranches();
		Object *GetPipeBranch(int i);
		INode *GetBranchINode(TimeValue t,INode *node,int i);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel);
		void GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt, Box3& box);
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);

		// From GeomObject		
		ObjectHandle CreateTriObjRep(TimeValue t) {return NULL;}
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		// Animatable methods
		Class_ID ClassID() {return Class_ID(BOOLOBJ_CLASS_ID,0);}  
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_BOOLEAN_CLASS);}
		void DeleteThis() {delete this;}				
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum);

		// From ref
		RefTargetHandle Clone(RemapDir& remap);
		int NumRefs() {return 4;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// From MeshOpProgress
		void Init(int total);
		BOOL Progress(int p);

		// From IBoolObject
		BOOL GetOperandSel(int which);
		void SetOperandSel(int which,BOOL sel);
		int GetBoolOp();
		void SetBoolOp(int op);
		int GetBoolCutType () { return 0; }
		void SetBoolCutType (int ct) { }
		BOOL GetDisplayResult();
		void SetDisplayResult(BOOL onOff);
		BOOL GetShowHiddenOps();
		void SetShowHiddenOps(BOOL onOff);
		int GetUpdateMode();
		void SetUpdateMode(int mode);
		BOOL GetOptimize();
		void SetOptimize(BOOL onOff);
	};				

class PickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		BoolObject *bo;
		
		PickOperand() {bo=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
		
		PickNodeCallback *GetFilter() {return this;}
	};

IObjParam *BoolObject::ip                   = NULL;
HWND BoolObject::hParams1                   = NULL;
HWND BoolObject::hParams2                   = NULL;
int BoolObject::addOppMethod                = IDC_TARG_MOVE;
DWORD BoolObject::lastOp                    = BOOL_DIFFERENCEA;
BOOL BoolObject::creating                   = FALSE;
BoolObject *BoolObject::editOb              = NULL;
MoveModBoxCMode*    BoolObject::moveMode    = NULL;
RotateModBoxCMode*  BoolObject::rotMode 	= NULL;
UScaleModBoxCMode*  BoolObject::uscaleMode  = NULL;
NUScaleModBoxCMode* BoolObject::nuscaleMode = NULL;
SquashModBoxCMode*  BoolObject::squashMode  = NULL;
SelectModBoxCMode*  BoolObject::selectMode  = NULL;
Matrix3 BoolObject::createTM;
PickOperand BoolObject::pickCB;
int BoolObject::extractCopy = FALSE;

class BoolObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return FALSE;}
	void *			Create(BOOL loading = FALSE) {return new BoolObject;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_BOOLEAN_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(BOOLOBJ_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_COMPOUNDOBJECTS);}
	BOOL			OkToCreate(Interface *i);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	};

void BoolObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	BoolObject::addOppMethod = IDC_TARG_MOVE;
	BoolObject::lastOp       = BOOL_DIFFERENCEA;
	}

BOOL BoolObjClassDesc::OkToCreate(Interface *i)
	{
	if (i->GetSelNodeCount()!=1) return FALSE;
	
	ObjectState os = i->GetSelNode(0)->GetObjectRef()->Eval(i->GetTime());
	if (os.obj->IsParticleSystem() ||
		os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
		return FALSE;
		}

	return TRUE;	
	}

static BoolObjClassDesc boolObjDesc;

ClassDesc* GetBoolObjDesc() { return &boolObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

//----------------------------------------------------------------------

class CreateBoolProc : public MouseCallBack {
	public:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		int proc( 
			HWND hWnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

int CreateBoolProc::proc( 
		HWND hWnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m ) 
	{
	switch (msg) {
		case MOUSE_POINT:
			ip->SetActiveViewport(hWnd);
			break;
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
// mjm - 3.1.99
		case MOUSE_PROPCLICK:
			// right click while between creations
			ip->RemoveMode(NULL);
			break;
// mjm - end
		}	
	return TRUE;
	}

class CreateBoolMode : public CommandMode, ReferenceMaker {		
	public:		
		CreateBoolProc proc;
		INode *node, *svNode;
		IObjParam *ip;
		BoolObject *obj;

		void Begin(INode *n,IObjParam *i);
		void End(IObjParam *i);
		void JumpStart(IObjParam *i,BoolObject *o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEBOOLMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 1; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG(CommandMode *oldMode) {return TRUE;}
		void EnterMode() {/*MakeRefByID(FOREVER,0,svNode);*/}
		void ExitMode() {/*DeleteAllRefsFromMe();*/}
		
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return node;}
		void SetReference(int i, RefTargetHandle rtarg) {node = (INode*)rtarg;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);		
	};
static CreateBoolMode theCreateBoolMode;

RefResult CreateBoolMode::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,
		RefMessage message)
	{
	switch (message) {		
		case REFMSG_TARGET_SELECTIONCHANGE:		
		case REFMSG_TARGET_DELETED:			
			if (ip) ip->StopCreating();
			break;

		}
	return REF_SUCCEED;
	}

class CreateBoolRestore : public RestoreObj {
	public:   		
		void Restore(int isUndo) {
			if (theCreateBoolMode.ip) {
				// Jump out of boolean create mode.
				theCreateBoolMode.ip->SetStdCommandMode(CID_OBJMOVE);
				}
			}	
		void Redo() {}
		TSTR Description() {return TSTR(_T("Create Boolean"));}
	};

// Sending the REFMSG_NOTIFY_PASTE message notifies the modify
// panel that the Node's object reference has changed when
// undoing or redoing.
class CreateBoolNotify : public RestoreObj {
	public:   		
		BoolObject *obj;
		BOOL which;
		CreateBoolNotify(BoolObject *o, BOOL w) {
			obj = o; which = w;
			}
		void Restore(int isUndo) {
			if (which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}	
		void Redo() {
			if (!which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}
		TSTR Description() {return TSTR(_T("Create Bool Notify"));}
	};

void CreateBoolMode::Begin(INode *n,IObjParam *i) 
	{
	MakeRefByID(FOREVER,0,n);
	svNode = node;
	assert(node);
	ip = i;
	proc.Init(ip);

	theHold.Begin();
	theHold.Put(new CreateBoolRestore);

	obj = new BoolObject;

	theHold.Put(new CreateBoolNotify(obj,1));

	obj->createTM = node->GetObjectTM(i->GetTime());
	obj->SetOperandA (i->GetTime(), node);
	node->SetObjectRef(obj);
	
	theHold.Put(new CreateBoolNotify(obj,0));

	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

void CreateBoolMode::End(IObjParam *i)
	{
	svNode = node;
	if (obj) obj->EndEditParams(i,END_EDIT_REMOVEUI,NULL);
	DeleteAllRefsFromMe();
	ip  = NULL;
	obj = NULL;
	}

void CreateBoolMode::JumpStart(IObjParam *i,BoolObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int BoolObjClassDesc::BeginCreate(Interface *i)
	{	
	assert(i->GetSelNodeCount()==1);

	theCreateBoolMode.Begin(i->GetSelNode(0),(IObjParam*)i);
	i->PushCommandMode(&theCreateBoolMode);
	return TRUE;
	}

int BoolObjClassDesc::EndCreate(Interface *i)
	{
	theCreateBoolMode.End((IObjParam*)i);
	i->RemoveMode(&theCreateBoolMode);
	return TRUE;
	}

//----------------------------------------------------------------------


BoolObject::BoolObject()
	{	
	obOffset  = Matrix3(1);
	ob1 = ob2 = NULL;
	tm1 = tm2 = NULL;
	flags = 0;
	ivalid.SetEmpty();
	SetFlag(BOOL_UPDATEALWAYS|BOOL_DISPRESULT|
		BOOL_OPTIMIZE|BOOL_FIRSTUPDATE|lastOp);
	}

BoolObject::~BoolObject()
	{
	DeleteAllRefsFromMe();
	}


DWORD BoolObject::BoolOp(int &order) 
	{
	order = 0;
	switch (flags&BOOL_OPERATION) {
		case BOOL_UNION: 		return MESHBOOL_UNION;
		case BOOL_INTERSECTION:	return MESHBOOL_INTERSECTION;
		case BOOL_DIFFERENCEA:	return MESHBOOL_DIFFERENCE;
		case BOOL_DIFFERENCEB:
			order = 1;
			return MESHBOOL_DIFFERENCE;			
		}
	return 0;
	}

void BoolObject::ExtractOperand(int which)
	{
	if (creating) return;

	// Compute a node TM for the new object
	assert(ip);
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	Matrix3 tm = nodes[0]->GetObjectTM(ip->GetTime());
	Matrix3 tmOp = GetOpTM(ip->GetTime(),which);
	Object *obj = which ? ob2 : ob1;
	if (!obj) return;
	tm = tmOp * tm;

	// Clone the object if specified
	if (extractCopy) obj = (Object*)obj->Clone();

	// Create the new node
	INode *node = ip->CreateObjectNode(obj);

	// Set the node TM.
	SuspendAnimate();
	AnimateOff();
	node->SetNodeTM(0,tm);
	ResumeAnimate();

	nodes.DisposeTemporary();
	}


class SetOperandRestore : public RestoreObj {	
	public:
		BoolObject *bo;
		TSTR uname, rname;
		int which;

		SetOperandRestore(BoolObject *b,int w) 
			{bo=b;uname=(w?bo->opbName:bo->opaName);}   		
		void Restore(int isUndo) {
			if (which) {
				rname = bo->opbName;
				bo->opbName = uname;
			} else {
				rname = bo->opaName;
				bo->opaName = uname;
				}
			if (bo->hParams2 && bo->editOb==bo) bo->SetupUI2(TRUE);
			}
		void Redo() {
			if (which) {				
				bo->opbName = rname;
			} else {				
				bo->opaName = rname;
				}
			if (bo->hParams2 && bo->editOb==bo) bo->SetupUI2(TRUE);
			}		
	};

void BoolObject::SetOperandA (TimeValue t, INode *node) {
	Object *obj = node->GetObjectRef();
	theHold.Put(new SetOperandRestore(this,0));
	opaName = TSTR(_T("B_")) + TSTR(node->GetName());

	// Plug in the object
	ReplaceReference (0, obj);
	// Make a new controller
	ReplaceReference (2, NewDefaultMatrix3Controller());	

	ivalid.SetEmpty();
	theHold.Accept(GetString(IDS_RB_PICKOPERAND));
}

void BoolObject::SetOperandB (TimeValue t, INode *node, INode *boolNode,
							 int addOpMethod, int matMergeMethod, bool *canUndo) {
	BOOL delnode = FALSE;
	Matrix3 oppTm = node->GetObjectTM(t);
	Matrix3 boolTm = boolNode->GetObjectTM(t);
	Object *obj = node->GetObjectRef();

	switch (addOppMethod) {
	case IDC_TARG_REFERENCE:
		obj = MakeObjectDerivedObject(obj);
		break;
	case IDC_TARG_COPY:
		obj = (Object*)obj->Clone();
		break;
	case IDC_TARG_MOVE:
		delnode = TRUE;
		break;
	}
	
	theHold.Put(new SetOperandRestore(this,1));

	opbName = TSTR(_T("B_")) + TSTR(node->GetName());

	// Plug in the object
	ReplaceReference(1,obj);
	
	// Grab the TM controller from the node and make a copy of it
	Control *opCont = node->GetTMController();
	opCont          = (Control*)opCont->Clone();
	
	// Get the object offset
	obOffset = node->GetObjTMBeforeWSM(t) * Inverse(node->GetNodeTM(t));

	// Adjust the trasform to be relative to us.
	opCont->ChangeParents(t,node->GetParentTM(t),boolTm,oppTm);
	ReplaceReference(3,opCont);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	ivalid.SetEmpty();
	if (delnode) ip->DeleteNode(node);
	
	theHold.Accept(GetString(IDS_RB_PICKOPERAND));
}		

Object *BoolObject::GetPipeObj(TimeValue t,int which)
	{
	ObjectState os;
	if (which==0) {
		if (ob1) {
			os = ob1->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
	} else {
		if (ob2) {
			os = ob2->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
		}
	return os.obj;
	}

Matrix3 BoolObject::GetOpTM(TimeValue t,int which,Interval *iv)
	{
	Matrix3 tm(1);
	Interval valid, *v;
	if (iv) v = iv;
	else v = &valid;

	if (which==0) {
		if (tm1) {
			tm1->GetValue(t,&tm,*v,CTRL_RELATIVE);
			}
	} else {
		if (tm2) {			
			tm2->GetValue(t,&tm,*v,CTRL_RELATIVE);
			tm = obOffset * tm;
			}
		}
	return tm;
	}


static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

int BoolObject::RenderBegin(TimeValue t, ULONG flags)
	{
	SetFlag(BOOL_INRENDER);
	if (TestFlag(BOOL_UPDATERENDER)) {
		ivalid.SetEmpty();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
	}

int BoolObject::RenderEnd(TimeValue t)
	{
	ClearFlag(BOOL_INRENDER);	
	return 0;
	}

void BoolObject::Init(int total)
	{
	}

BOOL BoolObject::Progress(int p)
	{
	SHORT res = GetAsyncKeyState(VK_ESCAPE);
	if (res&1) {
		SetFlag(BOOL_ABORTED);
		return FALSE;
		}
	else return TRUE;
	}

BOOL BoolObject::UpdateMesh(TimeValue t,BOOL force,BOOL sel)
	{
	if ((!ivalid.InInterval(t) || TestFlag(BOOL_NEEDSUPDATE)) &&
		(TestFlag(BOOL_UPDATEALWAYS) || 
		(TestFlag(BOOL_UPDATESELECT)&sel) || 
		(TestFlag(BOOL_UPDATERENDER)&&TestFlag(BOOL_INRENDER)) ||
		force)) {
		
		ClearFlag(BOOL_NEEDSUPDATE);

		// Build the boolean result mesh
		ivalid = FOREVER;
		BOOL needsDel1, needsDel2;

		TriObject *tob1, *tob2;
		tob1 = GetTriObject(t,ob1,ivalid,needsDel1);
		tob2 = GetTriObject(t,ob2,ivalid,needsDel2);

		if (tob1 && tob2) {
			Matrix3 mat1 = GetOpTM(t,0,&ivalid);
			Matrix3 mat2 = GetOpTM(t,1,&ivalid);
			int order, op, res, faces = tob1->GetMesh().getNumFaces() + tob2->GetMesh().getNumFaces();
			HCURSOR hCur;
			if (faces > LOTSOFACES) hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
			GetAsyncKeyState(VK_ESCAPE);
			ClearFlag(BOOL_ABORTED);
			op = BoolOp(order);
			if (order) {
				res = CalcBoolOp(
					mesh, tob2->GetMesh(), tob1->GetMesh(),
					op, this, &mat2, &mat1, -1, TestFlag(BOOL_OPTIMIZE));
			} else {
				res = CalcBoolOp(
					mesh, tob1->GetMesh(), tob2->GetMesh(),
					op, this, &mat1, &mat2, -1, TestFlag(BOOL_OPTIMIZE));
				}
			if (faces > LOTSOFACES) SetCursor(hCur);

			if (!res) {
				// Boolean Failed!!!
				if (ip) {
					if (TestFlag(BOOL_ABORTED)) {
						ip->DisplayTempPrompt(GetString(IDS_RB_BOOLEANABORTED),500);
					} else {
						ip->DisplayTempPrompt(GetString(IDS_RB_INVALIDBOOLEAN),500);
						}
					}
				if (TestFlag(BOOL_ABORTED)) {
					// Put in manual update mode.
					ClearFlag(BOOL_UPDATEALWAYS|BOOL_UPDATERENDER|BOOL_UPDATEMANUAL|BOOL_UPDATESELECT);
					SetFlag(BOOL_UPDATEMANUAL);					
					if (ip && editOb==this) SetupUI2();
					}
				if (TestFlag(BOOL_FIRSTUPDATE)) {
					// Turn on show operands.
					ClearFlag(BOOL_DISPRESULT);
					}
				
				//RB: 2/29/96:
				// If the boolean op failed don't set the validity to be empty.
				// this will just cause it to re-evaluate over and over again.
				// When the user changes it in some way which may allow the boolen
				// to succeed, that change should invalidate the interval.
				//ivalid.SetEmpty();
			} else {
				if (ip) ip->DisplayTempPrompt(GetString(IDS_RB_BOOLEACOMPLETED),500);
				ClearFlag(BOOL_FIRSTUPDATE);
				mesh.InvalidateEdgeList();
				mesh.InvalidateGeomCache();
				mesh.InvalidateTopologyCache();
				}
			}
		
		//if (needsDel1 && tob1->IsObjectLocked()==0) tob1->DeleteThis();
		//if (needsDel2 && tob2->IsObjectLocked()==0) tob2->DeleteThis();
		if (needsDel1) tob1->DeleteThis();
		if (needsDel2) tob2->DeleteThis();
	} else {
		// RB 4-2-96: We must be set to manual update.
		// The object should be considered valid
		if (!ivalid.InInterval(t)) {			
			ivalid.SetInstant(t);
			SetFlag(BOOL_NEEDSUPDATE);
			}		
		}

	return ivalid.InInterval(t);
	}

Interval BoolObject::ObjectValidity(TimeValue t)
	{
	UpdateMesh(t);
	if (ivalid.Empty()) return Interval(t,t);
	else return ivalid;
	}

int BoolObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 && ob2) return 1;
		else if (ob1) return ob1->CanConvertToType(obtype);
		else if (ob2) return ob2->CanConvertToType(obtype);
		else return 0;
		}
	return Object::CanConvertToType(obtype);
	}

Object* BoolObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 && ob2) {
			TriObject *triob;
			UpdateMesh(t);
			triob = CreateNewTriObject();
			triob->GetMesh() = mesh;
			triob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
			triob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
			return triob;
		} else {
			// RB 4-11-96:
			// There was a bug where if one of the operands was a tri-object
			// it would convert itself to a tri-object by just returning itself (as it should)
			// The problem is that there are places in the system where the
			// the system would think it needed to delete the tri-object
			// becuase it was not equal to the boolean object. In other words,
			// it thinks that the boolean convert itself to a tri-object and
			// therefore the tri-object was a temporary object.
			// So what this code does is clone the tri-object in this case
			// so that the boolean object will always return a temporary
			// object.
			Object *obj = NULL;
			if (ob1) {
				obj = ob1->ConvertToType(t,obtype);
				if (obj && (obj==ob1 || obj->IsObjectLocked())) {
					return (Object*)obj->Clone();
				} else {
					return obj;
					}
				}
			if (ob2) {
				obj = ob2->ConvertToType(t,obtype);
				if (obj && (obj==ob2 || obj->IsObjectLocked())) {
					return (Object*)obj->Clone();
				} else {
					return obj;
					}
				}			
			return NULL;
			}
	} else {
		return Object::ConvertToType(t,obtype);
		}
	}

BOOL 
BoolObject::PolygonCount(TimeValue t, int& numFaces, int& numVerts) 
{
    UpdateMesh(t);
    numFaces = mesh.getNumFaces();
    numVerts = mesh.getNumVerts();
    return TRUE;
}

ObjectState BoolObject::Eval(TimeValue time)
	{
	return ObjectState(this);
	}


void BoolObject::SetupUI1()
	{
	CheckRadioButton(hParams1,IDC_TARG_REFERENCE,IDC_TARG_INSTANCE,addOppMethod);
	}

void BoolObject::SetupUI2(BOOL useName)
	{	
	HWND hList = GetDlgItem(hParams2,IDC_BOOL_OPERANDS);
	SendMessage(hList,LB_RESETCONTENT,0,0);
	TSTR name = TSTR(_T("A: ")) + ((ob1||useName) ? opaName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	name = TSTR(_T("B: ")) + ((ob2||useName) ? opbName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	if (flags&BOOL_OB1SEL) {
		SendMessage(hList,LB_SETSEL,TRUE,0);
		}
	if (flags&BOOL_OB2SEL) {
		SendMessage(hList,LB_SETSEL,TRUE,1);
		}

	ICustEdit *edit = GetICustEdit(GetDlgItem(hParams2,IDC_BOOL_ANAME));
	edit->SetText(opaName);
	ReleaseICustEdit(edit);

	edit = GetICustEdit(GetDlgItem(hParams2,IDC_BOOL_BNAME));
	edit->SetText(opbName);
	ReleaseICustEdit(edit);

	int order;
	switch (BoolOp(order)) {
		case MESHBOOL_UNION:
			CheckRadioButton(hParams2,IDC_BOOL_UNION,IDC_BOOL_DIFFERENCEBA,IDC_BOOL_UNION);
			break;
		case MESHBOOL_INTERSECTION:
			CheckRadioButton(hParams2,IDC_BOOL_UNION,IDC_BOOL_DIFFERENCEBA,IDC_BOOL_INTERSECTION);
			break;
		case MESHBOOL_DIFFERENCE:
			if (order) {
				CheckRadioButton(hParams2,IDC_BOOL_UNION,IDC_BOOL_DIFFERENCEBA,IDC_BOOL_DIFFERENCEBA);
			} else {
				CheckRadioButton(hParams2,IDC_BOOL_UNION,IDC_BOOL_DIFFERENCEBA,IDC_BOOL_DIFFERENCEAB);
				}
			break;
		}	
	
	CheckDlgButton(hParams2,IDC_BOOL_DISPRESULT,TestFlag(BOOL_DISPRESULT));
	CheckDlgButton(hParams2,IDC_BOOL_DISPOPS,!TestFlag(BOOL_DISPRESULT));	

	if (TestFlag(BOOL_UPDATERENDER)) CheckDlgButton(hParams2,IDC_BOOL_UPDATERENDER,TRUE);
	else CheckDlgButton(hParams2,IDC_BOOL_UPDATERENDER,FALSE);
	if (TestFlag(BOOL_UPDATEMANUAL)) CheckDlgButton(hParams2,IDC_BOOL_UPDATEMANUAL,TRUE);
	else CheckDlgButton(hParams2,IDC_BOOL_UPDATEMANUAL,FALSE);
	if (TestFlag(BOOL_UPDATEALWAYS)) CheckDlgButton(hParams2,IDC_BOOL_UPDATEALWAYS,TRUE);
	else CheckDlgButton(hParams2,IDC_BOOL_UPDATEALWAYS,FALSE);
	if (TestFlag(BOOL_UPDATESELECT)) CheckDlgButton(hParams2,IDC_BOOL_UPDATESELECT,TRUE);
	else CheckDlgButton(hParams2,IDC_BOOL_UPDATESELECT,FALSE);	
			
	CheckDlgButton(hParams2,IDC_BOOL_OPTIMIZE,TestFlag(BOOL_OPTIMIZE));
	CheckDlgButton(hParams2,IDC_BOOL_SHOWHIDDENOPS,TestFlag(BOOL_DISPHIDDEN));

	ICustButton *iBut = GetICustButton(GetDlgItem(hParams2,IDC_BOOL_RECALC));
	if (!TestFlag(BOOL_UPDATEALWAYS)) {
		iBut->Enable();
	} else {
		iBut->Disable();
		}
	ReleaseICustButton(iBut);		
	
	SetExtractButtonState();
	}

void BoolObject::SetExtractButtonState()
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(hParams2,IDC_BOOL_EXTRACTOP));
	if (!creating && (flags & (BOOL_OB1SEL|BOOL_OB2SEL))) {
		iBut->Enable();
		EnableWindow(GetDlgItem(hParams2,IDC_BOOL_EXTRACT_INTANCE),TRUE);
		EnableWindow(GetDlgItem(hParams2,IDC_BOOL_EXTRACT_COPY),TRUE);
	} else {
		iBut->Disable();
		EnableWindow(GetDlgItem(hParams2,IDC_BOOL_EXTRACT_INTANCE),FALSE);
		EnableWindow(GetDlgItem(hParams2,IDC_BOOL_EXTRACT_COPY),FALSE);
		}
	ReleaseICustButton(iBut);	

	CheckDlgButton(hParams2,IDC_BOOL_EXTRACT_INTANCE,!extractCopy);
	CheckDlgButton(hParams2,IDC_BOOL_EXTRACT_COPY,extractCopy);
	}

BOOL PickOperand::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(bo->ip->GetTime());
		if (os.obj->IsParticleSystem() || 
			os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}

		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL PickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if (os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}

		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL PickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);

	ModContextList mcList;
	INodeTab nodes;
	INode *ourNode = NULL;
	if (!bo->creating) {
		// Grab the node for the first intance of us.
		ip->GetModContexts(mcList,nodes);
		if (nodes.Count()) ourNode = nodes[0];
	}

	theHold.Begin();
	bo->SetOperandB (ip->GetTime(), node, ourNode, 1);		
	theHold.Accept(IDS_DS_CREATE);

	nodes.DisposeTemporary ();

	// Automatically check show result and do one update
	bo->SetFlag(BOOL_DISPRESULT);
	bo->SetFlag(BOOL_FIRSTUPDATE);
	CheckRadioButton(bo->hParams2,IDC_BOOL_DISPRESULT,IDC_BOOL_DISPOPS,IDC_BOOL_DISPRESULT);
	bo->UpdateMesh(ip->GetTime(),TRUE);
	bo->SetupUI2();	
	
	if (bo->creating) {
		theCreateBoolMode.JumpStart(ip,bo);
		ip->SetCommandMode(&theCreateBoolMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
	}
}

void PickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(bo->hParams1,IDC_PICK_BOOLOPERAND));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void PickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(bo->hParams1,IDC_PICK_BOOLOPERAND));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}


static BOOL CALLBACK BoolParamDlgProc1( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	BoolObject *bo = (BoolObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!bo && message!=WM_INITDIALOG) return FALSE;

	switch (message) {
		case WM_INITDIALOG: {
			bo = (BoolObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			bo->hParams1 = hWnd;			
			
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_PICK_BOOLOPERAND));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);

			bo->SetupUI1();
			return FALSE;	// stop default keyboard focus - DB 2/27
			}

		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_PICK_BOOLOPERAND:
					if (bo->ip->GetCommandMode()->ID() == CID_STDPICK) {
						if (bo->creating) {
							theCreateBoolMode.JumpStart(bo->ip,bo);
							bo->ip->SetCommandMode(&theCreateBoolMode);
						} else {
							bo->ip->SetStdCommandMode(CID_OBJMOVE);
							}
					} else {
						bo->pickCB.bo = bo;						
						bo->ip->SetPickMode(&bo->pickCB);
						}
					break;

				case IDC_TARG_REFERENCE:
				case IDC_TARG_COPY:
				case IDC_TARG_MOVE:
				case IDC_TARG_INSTANCE:
					bo->addOppMethod = LOWORD(wParam);
					break;				
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			bo->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK BoolParamDlgProc2( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	BoolObject *bo = (BoolObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!bo && message!=WM_INITDIALOG) return FALSE;

	switch (message) {
		case WM_INITDIALOG: {
			bo = (BoolObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			bo->hParams2 = hWnd;			
			bo->SetupUI2();
			return FALSE;	// DB 2/27
			}

		
		case WM_CUSTEDIT_ENTER: {
			ICustEdit *edit;
			TCHAR buf[256];
			
			switch (LOWORD(wParam)) {
				case IDC_BOOL_ANAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_BOOL_ANAME));					
					edit->GetText(buf,256);
					bo->opaName = TSTR(buf);					
					if (bo->ob1) bo->ob1->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;
					
				case IDC_BOOL_BNAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_BOOL_BNAME));					
					edit->GetText(buf,256);
					bo->opbName = TSTR(buf);
					if (bo->ob2) bo->ob2->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;					
				}
			
			bo->SetupUI2();			
			break;
			}

		case WM_COMMAND:
			switch(LOWORD(wParam)) {				
				case IDC_BOOL_RECALC:
					bo->ivalid.SetEmpty();
					bo->UpdateMesh(bo->ip->GetTime(),TRUE);
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;

				case IDC_BOOL_DISPOPS:
				case IDC_BOOL_DISPRESULT:
					if (IsDlgButtonChecked(hWnd,IDC_BOOL_DISPRESULT)) {						
						bo->SetFlag(BOOL_DISPRESULT);
					} else {
						bo->ClearFlag(BOOL_DISPRESULT);
						}
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				
				case IDC_BOOL_UPDATEALWAYS:
					bo->ClearFlag(BOOL_UPDATEALWAYS|BOOL_UPDATERENDER|BOOL_UPDATEMANUAL|BOOL_UPDATESELECT);
					bo->SetFlag(BOOL_UPDATEALWAYS);					
					bo->ip->RedrawViews(bo->ip->GetTime());
					bo->SetupUI2();
					break;

				case IDC_BOOL_UPDATESELECT:
					bo->ClearFlag(BOOL_UPDATEALWAYS|BOOL_UPDATERENDER|BOOL_UPDATEMANUAL|BOOL_UPDATESELECT);
					bo->SetFlag(BOOL_UPDATESELECT);					
					bo->ip->RedrawViews(bo->ip->GetTime());
					bo->SetupUI2();
					break;				

				case IDC_BOOL_UPDATERENDER:
					bo->ClearFlag(BOOL_UPDATEALWAYS|BOOL_UPDATERENDER|BOOL_UPDATEMANUAL|BOOL_UPDATESELECT);
					bo->SetFlag(BOOL_UPDATERENDER);					
					bo->SetupUI2();
					break;

				case IDC_BOOL_UPDATEMANUAL:
					bo->ClearFlag(BOOL_UPDATEALWAYS|BOOL_UPDATERENDER|BOOL_UPDATEMANUAL|BOOL_UPDATESELECT);
					bo->SetFlag(BOOL_UPDATEMANUAL);					
					bo->SetupUI2();
					break;
				
				case IDC_BOOL_UNION:
					bo->ClearFlag(BOOL_OPERATION);
					bo->SetFlag(BOOL_UNION);
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				case IDC_BOOL_INTERSECTION:
					bo->ClearFlag(BOOL_OPERATION);
					bo->SetFlag(BOOL_INTERSECTION);
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				case IDC_BOOL_DIFFERENCEAB:
					bo->ClearFlag(BOOL_OPERATION);
					bo->SetFlag(BOOL_DIFFERENCEA);
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				case IDC_BOOL_DIFFERENCEBA:
					bo->ClearFlag(BOOL_OPERATION);
					bo->SetFlag(BOOL_DIFFERENCEB);
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;

				case IDC_BOOL_OPTIMIZE:
					if (IsDlgButtonChecked(hWnd,IDC_BOOL_OPTIMIZE)) {
						bo->SetFlag(BOOL_OPTIMIZE);
					} else {
						bo->ClearFlag(BOOL_OPTIMIZE);
						}
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				
				case IDC_BOOL_SHOWHIDDENOPS:
					if (IsDlgButtonChecked(hWnd,IDC_BOOL_SHOWHIDDENOPS)) {
						bo->SetFlag(BOOL_DISPHIDDEN);
					} else {
						bo->ClearFlag(BOOL_DISPHIDDEN);
						}
					bo->Invalidate();
					bo->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				

				case IDC_BOOL_OPERANDS:
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						bo->flags &= ~BOOL_ANYSEL;
						
						if (SendMessage((HWND)lParam,LB_GETSEL,0,0)) {
							bo->flags |= BOOL_OB1SEL;
							}
							
						if (SendMessage((HWND)lParam,LB_GETSEL,1,0)) {
							bo->flags |= BOOL_OB2SEL;
							}
						bo->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
						bo->NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
						bo->ip->RedrawViews(bo->ip->GetTime());
						bo->SetExtractButtonState();
						}
					break;

				case IDC_BOOL_EXTRACT_INTANCE:
					bo->extractCopy = FALSE;
					break;
				case IDC_BOOL_EXTRACT_COPY:
					bo->extractCopy = TRUE;
					break;
				case IDC_BOOL_EXTRACTOP:
					theHold.Begin();
					if (bo->flags&BOOL_OB1SEL) bo->ExtractOperand(0);
					if (bo->flags&BOOL_OB2SEL) bo->ExtractOperand(1);
					theHold.Accept(GetString(IDS_RB_EXTRACTOP));
					bo->ip->RedrawViews(bo->ip->GetTime());
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			bo->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void BoolObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	this->ip = ip;	
	editOb   = this;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else {
		creating = FALSE;
		// Create sub object editing modes.
		moveMode       = new MoveModBoxCMode(this,ip);
		rotMode        = new RotateModBoxCMode(this,ip);
		uscaleMode     = new UScaleModBoxCMode(this,ip);
		nuscaleMode    = new NUScaleModBoxCMode(this,ip);
		squashMode     = new SquashModBoxCMode(this,ip);
		selectMode     = new SelectModBoxCMode(this,ip);
		
		// Add our sub object type
		TSTR type(GetString(IDS_RB_OPERANDS));
		const TCHAR *ptype[] = {type};
		ip->RegisterSubObjectTypes(ptype, 1);
		}

	if (!hParams1) {
		hParams1 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_BOOLPARAM1),
				BoolParamDlgProc1, 
				GetString(IDS_RB_PICKBOOLEAN), 
				(LPARAM)this);		
		ip->RegisterDlgWnd(hParams1);
		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_BOOLPARAM2),
				BoolParamDlgProc2, 
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this);		
		ip->RegisterDlgWnd(hParams1);
	} else {
		SetWindowLong(hParams1,GWL_USERDATA,(LONG)this);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
		SetupUI1();
		SetupUI2();
		}
	}

void BoolObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	editOb = NULL;

	if (flags&END_EDIT_REMOVEUI) {
		ip->UnRegisterDlgWnd(hParams1);
		ip->DeleteRollupPage(hParams1);
		hParams1 = NULL;
		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;
	} else {
		SetWindowLong(hParams1,GWL_USERDATA,(LONG)NULL);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
		}	
	
	if (!creating) {
		ip->DeleteMode(moveMode);
		ip->DeleteMode(rotMode);
		ip->DeleteMode(uscaleMode);
		ip->DeleteMode(nuscaleMode);
		ip->DeleteMode(squashMode);
		ip->DeleteMode(selectMode);
		if ( moveMode ) delete moveMode;
		moveMode = NULL;
		if ( rotMode ) delete rotMode;
		rotMode = NULL;
		if ( uscaleMode ) delete uscaleMode;
		uscaleMode = NULL;
		if ( nuscaleMode ) delete nuscaleMode;
		nuscaleMode = NULL;
		if ( squashMode ) delete squashMode;
		squashMode = NULL;
		if ( selectMode ) delete selectMode;
		selectMode = NULL;	
	} else {
		lastOp = BOOL_OPERATION&this->flags;
		}

	ip->ClearPickMode();
	ip = NULL;
	creating = FALSE;
	}

int BoolObject::NumPipeBranches() 
	{
	int num=0;
	if (TestFlag(BOOL_OB1SEL) && ob1) num++;
	if (TestFlag(BOOL_OB2SEL) && ob2) num++;
	return num;
	}

Object *BoolObject::GetPipeBranch(int i) 
	{
	if (i) return ob2;	
	if (TestFlag(BOOL_OB1SEL)) return ob1;
	return ob2;
	}

INode *BoolObject::GetBranchINode(TimeValue t,INode *node,int i)
	{
	assert(i<2);
	int index = 0;
	if (i) index = 1;
	else if (TestFlag(BOOL_OB1SEL)) index = 0;
	else index = 1;
	return CreateINodeTransformed(node,GetOpTM(t,index));
	}

int BoolObject::NumSubs()
	{
	return 4;
	}

Animatable* BoolObject::SubAnim(int i)
	{
	switch (i) {
		case 0:  return ob1;
		case 1:  return tm1;
		case 2:	 return ob2;
		case 3:	 return tm2;
		default: return NULL;
		}	
	}

TSTR BoolObject::SubAnimName(int i)
	{	
	switch (i) {
		case 0: return opaName;//GetString(IDS_RB_OPERANDA);
		case 1: return GetString(IDS_RB_OPERANDATRANSFORM);
		case 2: return opbName;//GetString(IDS_RB_OPERANDB);
		case 3: return GetString(IDS_RB_OPERANDBTRANSFORM);
		}
	return _T("Error");
	}

int BoolObject::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case 0:  return REF_OP1;
		case 1:  return REF_CONT1;
		case 2:	 return REF_OP2;
		case 3:	 return REF_CONT2;
		default: return -1;
		}	
	}

RefTargetHandle BoolObject::GetReference(int i)
	{
	switch (i) {
		case REF_OP1: 	return ob1;
		case REF_OP2: 	return ob2;
		case REF_CONT1:	return tm1;
		case REF_CONT2:	return tm2;
		default:        return NULL;
		}
	}

void BoolObject::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case REF_OP1: 	 
			ob1 = (Object*)rtarg;
			/*
			if (rtarg==NULL) {				
				if (editOb==this) {
					SetupUI2();
					}
				}
			*/
			break;

		case REF_OP2: 	 
			ob2 = (Object*)rtarg;  
			/*
			if (rtarg==NULL) {
				if (editOb==this) {
					SetupUI2();
					}
				}
			*/
			break;

		case REF_CONT1:	 tm1 = (Control*)rtarg; break;
		case REF_CONT2:	 tm2 = (Control*)rtarg; break;
		}
	}

RefTargetHandle BoolObject::Clone(RemapDir& remap)
	{
	BoolObject *obj = new BoolObject;
	if (ob1) obj->ReplaceReference(REF_OP1,remap.CloneRef(ob1));
	if (ob2) obj->ReplaceReference(REF_OP2,remap.CloneRef(ob2));
	if (tm1) obj->ReplaceReference(REF_CONT1,remap.CloneRef(tm1));
	if (tm2) obj->ReplaceReference(REF_CONT2,remap.CloneRef(tm2));
	obj->flags = flags;
	obj->opaName = opaName;
	obj->opbName = opbName;
	return obj;
	}

int BoolObject::IntersectRay(
		TimeValue t, Ray& r, float& at, Point3& norm)
	{
	if (TestFlag(BOOL_DISPRESULT)) {
		UpdateMesh(t);
		return mesh.IntersectRay(r,at,norm);
	} else {
		return 0;
		}
	}

Mesh* BoolObject::GetRenderMesh(
		TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{	
	if (!ob1 || !ob2) {
		if (ob1) {
			Object *obj =
				GetPipeObj(t,0);
			if (obj && obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
				return ((GeomObject*)obj)->
					GetRenderMesh(t,inode,view,needDelete);
				}
			}
		if (ob2) {
			Object *obj =
				GetPipeObj(t,1);
			if (obj && obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
				return ((GeomObject*)obj)->
					GetRenderMesh(t,inode,view,needDelete);
				}
			}
		}
	UpdateMesh(t);
	needDelete = FALSE;
	return &mesh;	
	}

int BoolObject::HitTest(
		TimeValue t, INode* inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt)
	{
	int res = 0;
	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		HitRegion hitRegion;
		GraphicsWindow *gw = vpt->getGW();	
		Material *mtl = gw->getMaterial();		
		gw->setTransform(inode->GetObjectTM(t));
		MakeHitRegion(hitRegion, type, crossing, 4, p);
		res = mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return res;
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		if (ob=GetPipeObj(t,1)) {
			INodeTransformed n(inode,GetOpTM(t,1));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		}
	return res;
	}

void BoolObject::Snap(
		TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{
	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();		
		gw->setTransform(tm);
		mesh.snap( gw, snap, p, tm );
	} else {	
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->Snap(t,&n,snap,p,vpt);
			}	
		if (ob=GetPipeObj(t,1)) {
			INodeTransformed n(inode,GetOpTM(t,1));
			ob->Snap(t,&n,snap,p,vpt);
			}
		}
	}

#define DRAW_A (1<<1)
#define DRAW_B (1<<2)

int BoolObject::
		Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{	
	int disp = 0;
	GraphicsWindow *gw = vpt->getGW();
	BOOL showHidden = TestFlag(BOOL_DISPHIDDEN);

	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());		
		gw->setTransform(inode->GetObjectTM(t));
		mesh.render(gw, inode->Mtls(),(flags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL, COMP_ALL, inode->NumMtls());
	
		// Show hidden ops?
		if (showHidden && TestFlag(BOOL_DIFFERENCEA)) {
			disp = DRAW_B;
			}
		if (showHidden && TestFlag(BOOL_DIFFERENCEB)) {
			disp = DRAW_A;
			}
		if (showHidden && TestFlag(BOOL_INTERSECTION)) {
			disp = DRAW_B|DRAW_A;
			}
	} else {
		disp = 1;		
		}
			
	if (disp) {	
		Object *ob;
		
		DWORD rlim = gw->getRndLimits();

		if (disp&DRAW_A || disp&DRAW_B) {
			if (!(rlim&GW_ILLUM)) return 0;
			gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL|(rlim&GW_Z_BUFFER?GW_Z_BUFFER:0));
			if (inode->NumMtls()) {
				Point3 c = inode->Mtls()->Kd;
				gw->setColor(LINE_COLOR,c.x,c.y,c.z);
			} else {
				gw->setColor(LINE_COLOR,0.7f,0.7f,0.7f);
				}
			}

		if ((disp==1 || disp&DRAW_A) && (ob=GetPipeObj(t,0))) {
			 INodeTransformed n(inode,GetOpTM(t,0));
			 if (inode->Selected()) {
				 if (TestFlag(BOOL_OB1SEL)) {
					vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
				 } else {
					Point3 selClr = GetUIColor(COLOR_SELECTION); 
					vpt->getGW()->setColor( LINE_COLOR, selClr.x, selClr.y, selClr.z);
				 	}
				}
			 ob->Display(t,&n,vpt,flags);
			 }
		if ((disp==1 || disp&DRAW_B) && (ob=GetPipeObj(t,1))) {
			INodeTransformed n(inode,GetOpTM(t,1));
			if (inode->Selected()) {
				if (TestFlag(BOOL_OB2SEL)) {
					vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
				 } else {
					vpt->getGW()->setColor( LINE_COLOR, GetSelColor());
				 	}
				}
			ob->Display(t,&n,vpt,flags);
			}
		
		if (disp&DRAW_A || disp&DRAW_B) {
			gw->setRndLimits(rlim);
			}
		}
	return 0;
	}

void BoolObject::GetDeformBBox(
		TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
	{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t);
		box = mesh.getBoundingBox(tm);
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {				
			if (tm) {
				Matrix3 mat = GetOpTM(t,0) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		if (ob=GetPipeObj(t,1)) {
			if (tm) {
				Matrix3 mat = GetOpTM(t,1) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		}
	}

void BoolObject::GetLocalBoundBox(
		TimeValue t, INode *inode,ViewExp* vpt, Box3& box) 
	{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		box = mesh.getBoundingBox();	
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,0);
			box += abox;
			}
		if (ob=GetPipeObj(t,1)) {
			INodeTransformed n(inode,GetOpTM(t,1));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,1);
			box += abox;
			}
		}
	}

void BoolObject::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{
	Box3 abox;
	int disp = 0;
	abox.Init();
	box.Init();
	BOOL showHidden = TestFlag(BOOL_DISPHIDDEN);

	if (TestFlag(BOOL_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 mat = inode->GetObjectTM(t);	
		box = mesh.getBoundingBox();
		if (!box.IsEmpty()) box = box * mat;

		// Show hidden ops?
		if (showHidden && TestFlag(BOOL_DIFFERENCEA)) {
			disp = DRAW_B;
			}
		if (showHidden && TestFlag(BOOL_DIFFERENCEB)) {
			disp = DRAW_A;
			}
		if (showHidden && TestFlag(BOOL_INTERSECTION)) {
			disp = DRAW_B|DRAW_A;
			}
	} else {
		disp = 1;
		}

	if (disp) {	
		Object *ob;
		
		if ((disp==1 || disp&DRAW_A) && (ob=GetPipeObj(t,0))) {		
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetWorldBoundBox(t,&n,vpt,abox);
			box += abox;
			}
		
		if ((disp==1 || disp&DRAW_B) && (ob=GetPipeObj(t,1))) {		
			INodeTransformed n(inode,GetOpTM(t,1));
			ob->GetWorldBoundBox(t,&n,vpt,abox);
			box += abox;
			}
		}
	}

RefResult BoolObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message ) 
	{
	switch (message) {
		case REFMSG_SELECT_BRANCH:
			if (hTarget==ob1 || hTarget==ob2) {
				ClearFlag(BOOL_OB1SEL|BOOL_OB2SEL);
				if (hTarget==ob1) SetFlag(BOOL_OB1SEL);
				if (hTarget==ob2) SetFlag(BOOL_OB2SEL);
				NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
				NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
				}
			break;

		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			break;
		}
	return REF_SUCCEED;
	}




//--Subobject Selection-------------------------------------------------------------


void BoolObject::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(BOOL_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(BOOL_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

void BoolObject::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(BOOL_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(BOOL_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

void BoolObject::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(BOOL_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(BOOL_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

int BoolObject::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{	
	int res = 0;
	Object *ob;
	if ((ob=GetPipeObj(t,0)) &&
		!(flags&HIT_SELONLY && !TestFlag(BOOL_OB1SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(BOOL_OB1SEL)) ) {
		
		INodeTransformed n(inode,GetOpTM(t,0));
		
		if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,0,NULL);
			res = TRUE;
			if (flags & HIT_ABORTONHIT) return TRUE;
			}		
		}
	if ((ob=GetPipeObj(t,1)) &&
		!(flags&HIT_SELONLY && !TestFlag(BOOL_OB2SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(BOOL_OB2SEL)) ) {
		
		INodeTransformed n(inode,GetOpTM(t,1));
		
		if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,1,NULL);
			res = TRUE;			
			}		
		}
	
	return res;
	}

int BoolObject::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flags, ModContext* mc)
	{
	/*
	if (TestFlag(BOOL_DISPRESULT)) {
		
		if (TestFlag(BOOL_OB1SEL) && ob1) {
			INodeTransformed *tnode = 
				CreateINodeTransformed(inode,GetOpTM(t,0));
			ob1->Display(t,tnode,vpt,flags,mc);
			tnode->DisposeTemporary();
			}

		if (TestFlag(BOOL_OB2SEL) && ob2) {
			INodeTransformed *tnode = 
				CreateINodeTransformed(inode,GetOpTM(t,1));
			ob1->Display(t,tnode,vpt,flags,mc);
			tnode->DisposeTemporary();
			}		
		}
		*/
	return 0;
	}

void BoolObject::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	while (hitRec) {
		if (hitRec->hitInfo) {
			if (selected) SetFlag(BOOL_OB2SEL);
			else ClearFlag(BOOL_OB2SEL);
		} else {
			if (selected) SetFlag(BOOL_OB1SEL);
			else ClearFlag(BOOL_OB1SEL);
			}
		if (all) hitRec = hitRec->Next();
		else break;
		}
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
	if (ip) SetupUI2();
	}

void BoolObject::ClearSelection(int selLevel)
	{
	ClearFlag(BOOL_OB1SEL|BOOL_OB2SEL);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip) SetupUI2();
	}

int BoolObject::SubObjectIndex(HitRecord *hitRec)
	{
	return hitRec->hitInfo;
	}

void BoolObject::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 tm;
	if (TestFlag(BOOL_OB1SEL)) {
		tm = GetOpTM(t,0) * node->GetObjectTM(t);
		cb->Center(tm.GetTrans(),0);
		}
	if (TestFlag(BOOL_OB2SEL)) {
		tm = GetOpTM(t,1) * node->GetObjectTM(t);
		cb->Center(tm.GetTrans(),1);
		}
	}

void BoolObject::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 tm;
	if (TestFlag(BOOL_OB1SEL)) {
		tm = GetOpTM(t,0) * node->GetObjectTM(t);
		cb->TM(tm,0);
		}
	if (TestFlag(BOOL_OB2SEL)) {
		tm = GetOpTM(t,1) * node->GetObjectTM(t);
		cb->TM(tm,1);
		}
	}

void BoolObject::ActivateSubobjSel(int level, XFormModes& modes)
	{
	if (level) {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		NotifyDependents(
			FOREVER, 
			PART_SUBSEL_TYPE|PART_DISPLAY, 
			REFMSG_CHANGE);		
		ip->PipeSelLevelChanged();
		}
	}


#define BOOL_FLAGS_CHUNK	0x0100
#define BOOL_OPANAME_CHUNK	0x0110
#define BOOL_OPBNAME_CHUNK	0x0120
#define BOOL_OFFSET_CHUNK	0x0130

IOResult BoolObject::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(BOOL_FLAGS_CHUNK);		
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_OPANAME_CHUNK);		
	isave->WriteWString(opaName);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_OPBNAME_CHUNK);		
	isave->WriteWString(opbName);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_OFFSET_CHUNK);		
	obOffset.Save(isave);
	isave->EndChunk();	

	return IO_OK;
	}


IOResult BoolObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	
	// Default names
	opaName = GetString(IDS_RB_OPERAND);
	opbName = GetString(IDS_RB_OPERAND);

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case BOOL_OFFSET_CHUNK:
				obOffset.Load(iload);
				break;

			case BOOL_FLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			
			case BOOL_OPANAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opaName = TSTR(buf);
				break;
				}

			case BOOL_OPBNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opbName = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	Invalidate();
	return IO_OK;
	}



BOOL BoolObject::GetOperandSel(int which)
	{
	if (which) 
		 return TestFlag(BOOL_OB2SEL);
	else return TestFlag(BOOL_OB1SEL);
	}

void BoolObject::SetOperandSel(int which,BOOL sel)
	{
	if (which)
		 SetFlag(BOOL_OB2SEL);
	else SetFlag(BOOL_OB1SEL);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

int BoolObject::GetBoolOp()
	{
	if (TestFlag(BOOL_UNION)) return BOOLOP_UNION;
	if (TestFlag(BOOL_INTERSECTION)) return BOOLOP_INTERSECTION;
	if (TestFlag(BOOL_DIFFERENCEA)) return BOOLOP_SUB_AB;
	if (TestFlag(BOOL_DIFFERENCEB)) return BOOLOP_SUB_BA;
	return 0;
	}

void BoolObject::SetBoolOp(int op)
	{
	ClearFlag(BOOL_OPERATION);
	switch (op) {
		case BOOLOP_UNION:
			SetFlag(BOOL_UNION); break;
		case BOOLOP_INTERSECTION:
			SetFlag(BOOL_INTERSECTION); break;
		case BOOLOP_SUB_AB:
			SetFlag(BOOL_DIFFERENCEA); break;
		case BOOLOP_SUB_BA:
			SetFlag(BOOL_DIFFERENCEB); break;
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

BOOL BoolObject::GetDisplayResult()
	{
	return TestFlag(BOOL_DISPRESULT);
	}

void BoolObject::SetDisplayResult(BOOL onOff)
	{
	if (onOff) 
		 SetFlag(BOOL_DISPRESULT);
	else ClearFlag(BOOL_DISPRESULT);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

BOOL BoolObject::GetShowHiddenOps()
	{
	return TestFlag(BOOL_DISPHIDDEN);
	}

void BoolObject::SetShowHiddenOps(BOOL onOff)
	{
	if (onOff) 
		 SetFlag(BOOL_DISPHIDDEN);
	else ClearFlag(BOOL_DISPHIDDEN);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}


int BoolObject::GetUpdateMode()
	{
	if (TestFlag(BOOL_UPDATEALWAYS)) return BOOLUPDATE_ALWAYS;
	if (TestFlag(BOOL_UPDATERENDER)) return BOOLUPDATE_RENDER;
	if (TestFlag(BOOL_UPDATEMANUAL)) return BOOLUPDATE_MANUAL;
	if (TestFlag(BOOL_UPDATESELECT)) return BOOLUPDATE_SELECTED;
	return 0;
	}
 
void BoolObject::SetUpdateMode(int mode)
	{
	ClearFlag(BOOL_UPDATEALWAYS);
	ClearFlag(BOOL_UPDATERENDER);
	ClearFlag(BOOL_UPDATEMANUAL);
	ClearFlag(BOOL_UPDATESELECT);
	switch (mode) {
		case BOOLUPDATE_ALWAYS:
			SetFlag(BOOL_UPDATEALWAYS); break;
		case BOOLUPDATE_SELECTED:
			SetFlag(BOOL_UPDATESELECT); break;
		case BOOLUPDATE_RENDER:
			SetFlag(BOOL_UPDATERENDER); break;
		case BOOLUPDATE_MANUAL:
			SetFlag(BOOL_UPDATEMANUAL); break;
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

BOOL BoolObject::GetOptimize()
	{
	return TestFlag(BOOL_OPTIMIZE);
	}

void BoolObject::SetOptimize(BOOL onOff)
	{
	if (onOff) 
		 SetFlag(BOOL_OPTIMIZE);
	else ClearFlag(BOOL_OPTIMIZE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\camera.h ===
/**********************************************************************
 *<
	FILE: camera.h

	DESCRIPTION:  Defines a simple Camera

	CREATED BY: Dan Silva

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CAMERA__H__ 

#define __CAMERA__H__

// reference #s
#define PBLOCK_REF 0
#define DOF_REF 1

#define MIN_FOV 	0.000025f
#define MAX_FOV 	175.0f

#define MIN_LENS	9.857142f
#define MAX_LENS	100000.0f

#define MIN_TDIST	1.0f
#define MAX_TDIST	100000.0f

#define FIXED_CONE_DIST  160.0f

#define FOV_W 0	  // width-related FOV
#define FOV_H 1   // height-related FOV
#define FOV_D 2   // diagonal-related FOV

class CamMtl: public Material {
	public:
	CamMtl();
	};

extern CamMtl camMtl;

class SCamCreateCallBack;
class SetCamTypeRest;

class SimpleCamera: public GenCamera {			   
		friend class SCamCreateCallBack;
		friend class CameraPostLoad;
		friend class SetCamTypeRest;
		friend BOOL CALLBACK SimpleCamParamDialogProc( HWND hDlg, UINT message,
			 WPARAM wParam, LPARAM lParam );
		friend void resetCameraParams();

		// Class vars
		static Mesh mesh;
		static short meshBuilt;
		static short dlgIsOrtho;
		static BOOL inCreate;
		static float dlgFOV;
		static short dlgShowCone;
		static short dlgShowHorzLine;
		static float dlgTDist;
		static short dlgClip;
		static float dlgHither;
		static float dlgYon;
		static short dlgRangeDisplay;
		static float dlgNearRange;
		static float dlgFarRange;
		static short dlgDOFEnable;
		static float dlgDOFFStop;
		static HWND hSimpleCamParams;
		static HWND hDepthOfFieldParams;
		static IObjParam* iObjParams;		
		static ISpinnerControl *fovSpin;
		static ISpinnerControl *lensSpin;
		static ISpinnerControl *tdistSpin;
		static ISpinnerControl *hitherSpin;
		static ISpinnerControl *yonSpin;
		static ISpinnerControl *envNearSpin;
		static ISpinnerControl *envFarSpin;
		static ISpinnerControl *fStopSpin;
		static ICustButton *iFovType;
		
		IParamBlock *pblock;
		IParamBlock *depthOfFieldPB;
		short isOrtho;
		short enable;
		short hasTarget;
		short coneState;
		short horzLineState;
		short manualClip;
		short rangeDisplay;
		int extDispFlags;
		float targDist; // for target cameras
		int fovType;
		short dofEnable;
		float fStop;

	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );
		void BuildMesh();
		void UpdateUI(TimeValue t);
		void GetMat(TimeValue t, INode* inod, ViewExp *vpt, Matrix3& mat);
		void GetConePoints(TimeValue t, Point3* q, float dist);
		void DrawCone(TimeValue t, GraphicsWindow *gw, float dist, int colid=0, BOOL drawSides=FALSE, BOOL drawDiags=FALSE);
		int DrawConeAndLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing);
		int DrawRange(TimeValue t, INode *inode, GraphicsWindow *gw);
		
		BOOL IsCompatibleRenderer ( void );
	public:
		SimpleCamera(int look = 0);
		~SimpleCamera();
		GenCamera *NewCamera(int type) { return new SimpleCamera(type); }
		void SetOrtho(BOOL b);
		BOOL IsOrtho()	{ return isOrtho; }
		void SetFOV(TimeValue t, float f);
		float GetFOV(TimeValue t, Interval& valid = Interval(0,0));
		void SetLens(TimeValue t, float f);
		float GetLens(TimeValue t, Interval& valid = Interval(0,0));
		void SetTDist(TimeValue t, float f);
		float GetTDist(TimeValue t, Interval& valid = Interval(0,0));
		void SetConeState(int s);
		int GetConeState() {return coneState;}
		void SetHorzLineState(int s);
		int GetHorzLineState() {return horzLineState;}
		int GetManualClip() { return manualClip; }
		void SetManualClip(int onOff);
		float GetClipDist(TimeValue t, int which, Interval &valid = Interval(0,0));
		void SetClipDist(TimeValue t, int which, float f);
		float MMtoFOV(float mm);  
		float FOVtoMM(float fov); 
		float CurFOVtoWFOV(float cfov);
		float WFOVtoCurFOV(float wfov);
		void  SetFOVType(int ft);
		int GetFOVType() {return fovType;}
		void  SetDOFEnable(TimeValue t, BOOL onOff);
		BOOL GetDOFEnable(TimeValue t, Interval& valid = Interval(0,0));
		void  SetDOFFStop(TimeValue t, float fS);
		float GetDOFFStop(TimeValue t, Interval& valid = Interval(0,0));

		BOOL SetFOVControl(Control *c);
		Control *GetFOVControl();

		void SetEnvRange(TimeValue time, int which, float f);
		float GetEnvRange(TimeValue t, int which, Interval& valid = Interval(0,0));
		void SetEnvDisplay(BOOL b, int notify=TRUE);
		BOOL GetEnvDisplay(void)	{ return rangeDisplay; }
		void RenderApertureChanged(TimeValue t);
		void UpdateTargDistance(TimeValue t, INode* inode);

		void UpdateKeyBrackets(TimeValue t);

		void Enable(int enab) { enable = enab; }

		//  inherited virtual methods:

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		void SetExtendedDisplay(int flags);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return hasTarget ? GetString(IDS_DB_TARGET_CAM) : GetString(IDS_DB_FREE_CAM); }
		int  Type() { return hasTarget ? TARGETED_CAMERA:FREE_CAMERA; }
		void SetType(int tp);
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp* vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp* vpt, Box3& box );
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_DB_CAMERA); }		
		Interval ObjectValidity();
		int DoOwnSelectHilite() { return 1; }
		Interval ObjectValidity(TimeValue time);
		
		// From Camera
		RefResult EvalCameraState(TimeValue t, Interval& valid, CameraState* cs);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(hasTarget?LOOKAT_CAM_CLASS_ID:SIMPLE_CAM_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_SIMPLECAM_CLASS)); }
		
		int NumSubs() { return IsCompatibleRenderer () ? 2 : 1; }
		Animatable* SubAnim(int i) {
			switch(i) {
				case PBLOCK_REF: return (Animatable*)pblock;
				case DOF_REF: return IsCompatibleRenderer () ? (Animatable*)depthOfFieldPB : NULL;
				default: return NULL;
			}
		}

		TSTR SubAnimName(int i) { 
			switch(i) {
				case PBLOCK_REF: return TSTR(GetString(IDS_RB_PARAMETERS));
				case DOF_REF: return IsCompatibleRenderer () ? TSTR(GetString(IDS_DOF)) : _T("");
				default: return _T("");
			}
		}

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i) {
			switch(i) {
				case PBLOCK_REF: return (RefTargetHandle)pblock;
				case DOF_REF: return (RefTargetHandle)depthOfFieldPB;
				default: return NULL;
			}
		}

		void SetReference(int i, RefTargetHandle rtarg) {
			switch(i) {
				case PBLOCK_REF:
					pblock=(IParamBlock*)rtarg; 
					break;
				case DOF_REF:
					depthOfFieldPB = (IParamBlock*)rtarg; 
					break;
				default:
					break;
			}
		}

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\camera.cpp ===
/**********************************************************************
 *<
	FILE: camera.cpp

	DESCRIPTION:  A Simple Camera implementation

	CREATED BY: Dan Silva

	HISTORY: created 14 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "gencam.h"
#include "camera.h"
#include "target.h"
#include "macrorec.h"


// Parameter block indices
#define PB_FOV		0
#define PB_TDIST	1
#define PB_HITHER	2
#define PB_YON		3
#define PB_NRANGE	4
#define PB_FRANGE	5

// Depth of Field parameter block indicies
#define PB_DOF_ENABLE	0
#define PB_DOF_FSTOP	1

#define WM_SET_TYPE		WM_USER + 0x04002

#define MIN_CLIP	0.000001f
#define MAX_CLIP	1.0e32f

#define NUM_CIRC_PTS	28
#define SEG_INDEX		7

#define RELEASE_SPIN(x)   if (so->x) { ReleaseISpinner(so->x); so->x = NULL;}
#define RELEASE_BUT(x)   if (so->x) { ReleaseICustButton(so->x); so->x = NULL;}

static int waitPostLoad = 0;
static void resetCameraParams();
static HIMAGELIST hCamImages = NULL;

//------------------------------------------------------
class SimpleCamClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SimpleCamera; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_FREE_CLASS); }
	SClass_ID		SuperClassID() { return CAMERA_CLASS_ID; }
	Class_ID 		ClassID() { return Class_ID(SIMPLE_CAM_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetCameraParams(); }
	};

static SimpleCamClassDesc simpleCamDesc;

ClassDesc* GetSimpleCamDesc() { return &simpleCamDesc; }


// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

#define DEF_HITHER_CLIP		1.0f
#define DEF_YON_CLIP		1000.0f

// Class variables of SimpleCamera
Mesh SimpleCamera::mesh;
short SimpleCamera::meshBuilt=0;
float SimpleCamera::dlgFOV = DegToRad(45.0);
short SimpleCamera::dlgShowCone =0;
short SimpleCamera::dlgShowHorzLine =0;
float SimpleCamera::dlgTDist = FIXED_CONE_DIST;
short SimpleCamera::dlgClip = 0;
float SimpleCamera::dlgHither = DEF_HITHER_CLIP;
float SimpleCamera::dlgYon = DEF_YON_CLIP;
float SimpleCamera::dlgNearRange = 0.0f;
float SimpleCamera::dlgFarRange = 1000.0f;
short SimpleCamera::dlgRangeDisplay = 0;
short SimpleCamera::dlgIsOrtho = 0;

short SimpleCamera::dlgDOFEnable = 1;
float SimpleCamera::dlgDOFFStop = 2.0f;

BOOL SimpleCamera::inCreate=FALSE;

void resetCameraParams() 
{
	SimpleCamera::dlgFOV = DegToRad(45.0);
	SimpleCamera::dlgShowCone =0;
	SimpleCamera::dlgShowHorzLine =0;
	SimpleCamera::dlgTDist = FIXED_CONE_DIST;
	SimpleCamera::dlgClip = 0;
	SimpleCamera::dlgHither = DEF_HITHER_CLIP;
	SimpleCamera::dlgYon = DEF_YON_CLIP;
	SimpleCamera::dlgNearRange = 0.0f;
	SimpleCamera::dlgFarRange = 1000.0f;
	SimpleCamera::dlgRangeDisplay = 0;
	SimpleCamera::dlgIsOrtho = 0;

	SimpleCamera::dlgDOFEnable = 1;
	SimpleCamera::dlgDOFFStop = 2.0f;

}

HWND SimpleCamera::hSimpleCamParams = NULL;
HWND SimpleCamera::hDepthOfFieldParams = NULL;
IObjParam *SimpleCamera::iObjParams;
ISpinnerControl *SimpleCamera::fovSpin = NULL;
ISpinnerControl *SimpleCamera::lensSpin = NULL;
ISpinnerControl *SimpleCamera::tdistSpin = NULL;
ISpinnerControl *SimpleCamera::hitherSpin = NULL;
ISpinnerControl *SimpleCamera::yonSpin = NULL;
ISpinnerControl *SimpleCamera::envNearSpin = NULL;
ISpinnerControl *SimpleCamera::envFarSpin = NULL;
ISpinnerControl *SimpleCamera::fStopSpin = NULL;
ICustButton *SimpleCamera::iFovType = NULL;

static float mmTab[9] = {
	15.0f, 20.0f, 24.0f, 28.0f, 35.0f, 50.0f, 85.0f, 135.0f, 200.0f
	};


static float GetAspect() {
	return GetCOREInterface()->GetRendImageAspect();
	};

static float GetApertureWidth() {
	return GetCOREInterface()->GetRendApertureWidth();
	}


static int GetTargetPoint(TimeValue t, INode *inode, Point3& p) {
	Matrix3 tmat;
	if (inode->GetTargetTM(t,tmat)) {
		p = tmat.GetTrans();
		return 1;
		}
	else 
		return 0;
	}

static int is_between(float a, float b, float c) 
{
	float t;
	if (b>c) { t = b; b = c; c = t;}
	return((a>=b)&&(a<=c));
}

static float interp_vals(float m, float *mtab, float *ntab, int n) 
{
	float frac;
	for (int i=1; i<n; i++) {
		if (is_between(m,mtab[i-1],mtab[i])) {
			frac = (m - mtab[i-1])/(mtab[i]-mtab[i-1]);
			return((1.0f-frac)*ntab[i-1] + frac*ntab[i]);
		}
	}
	return 0.0f;
}


// This changes the relation between FOV and Focal length.
void SimpleCamera::RenderApertureChanged(TimeValue t) {
	UpdateUI(t);
	}

void SimpleCamera::SetFOVType(int ft) {
	fovType = ft;
	if (fovSpin&&iObjParams)
		fovSpin->SetValue( RadToDeg(WFOVtoCurFOV(GetFOV(iObjParams->GetTime()))), FALSE );
	}


float SimpleCamera::MMtoFOV(float mm) {
	return float(2.0f*atan(0.5f*GetApertureWidth()/mm));
	}

float SimpleCamera::FOVtoMM(float fov)	{
	float w = GetApertureWidth();
	float mm = float((0.5f*w)/tan(fov/2.0f));
	return mm;
	}


float SimpleCamera::CurFOVtoWFOV(float cfov) {
	switch (fovType) {
		case FOV_H: {
			return float(2.0*atan(GetAspect()*tan(cfov/2.0f)));
			}
		case FOV_D: {
			float w = GetApertureWidth();
			float h = w/GetAspect();
			float d = (float)sqrt(w*w + h*h);	
			return float(2.0*atan((w/d)*tan(cfov/2.0f)));
			}
		default:
			return cfov;
		}
	}	


float SimpleCamera::WFOVtoCurFOV(float fov) {
	switch (fovType) {
		case FOV_H: {
			return float(2.0*atan(tan(fov/2.0f)/GetAspect()));
			}
		case FOV_D: {
			float w = GetApertureWidth();
			float h = w/GetAspect();
			float d = (float)sqrt(w*w + h*h);	
			return float(2.0*atan((d/w)*tan(fov/2.0f)));
			}
		default:
			return fov;
		}
	}	


static void LoadCamResources() {
	static BOOL loaded=FALSE;
	if (loaded) return;
	HBITMAP hBitmap;
	HBITMAP hMask;
	hCamImages = ImageList_Create(14,14, ILC_COLOR4|ILC_MASK, 3, 0);
	hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_FOV));
	hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_FOVMASK));
	ImageList_Add(hCamImages,hBitmap,hMask);
	DeleteObject(hBitmap);	
	DeleteObject(hMask);	
	}

class DeleteCamResources {
	public:
		~DeleteCamResources() {
			ImageList_Destroy(hCamImages);
			}
	};

static DeleteCamResources theDelete;

static int typeName[NUM_CAM_TYPES] = {
	IDS_DB_FREE_CAM,
	IDS_DB_TARGET_CAM
	};

BOOL CALLBACK SimpleCamParamDialogProc( 
	HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	SimpleCamera *so = (SimpleCamera *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !so && message != WM_INITDIALOG ) return FALSE;
	TimeValue t = so->iObjParams->GetTime();

	float tmpSmall, tmpLarge;

	switch ( message ) {
		case WM_INITDIALOG:
			LoadCamResources();
			so = (SimpleCamera *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)so );
			SetDlgFont( hDlg, so->iObjParams->GetAppHFont() );
//			if(so->iObjParams->GetCommandMode()->ID() == CID_OBJSELECT)
//				EnableWindow(GetDlgItem(hDlg, IDC_CREATE_VIEW), FALSE);
			
			
			CheckDlgButton( hDlg, IDC_SHOWCAMCONE, so->coneState );
			CheckDlgButton( hDlg, IDC_SHOWHORZLINE, so->horzLineState );
			CheckDlgButton( hDlg, IDC_SHOW_RANGES, so->rangeDisplay );
			CheckDlgButton( hDlg, IDC_IS_ORTHO, so->isOrtho );
			CheckDlgButton( hDlg, IDC_MANUAL_CLIP, so->manualClip );
			EnableWindow( GetDlgItem(hDlg, IDC_HITHER), so->manualClip);
			EnableWindow( GetDlgItem(hDlg, IDC_HITHER_SPIN), so->manualClip);
			EnableWindow( GetDlgItem(hDlg, IDC_YON), so->manualClip);
			EnableWindow( GetDlgItem(hDlg, IDC_YON_SPIN), so->manualClip);

			{
			HWND hwndType = GetDlgItem(hDlg, IDC_CAM_TYPE);
			for (int i=0; i<NUM_CAM_TYPES; i++)
				SendMessage(hwndType, CB_ADDSTRING, 0, (LPARAM)GetString(typeName[i]));
				SendMessage( hwndType, CB_SETCURSEL, i, (LPARAM)0 );
				EnableWindow(hwndType,!so->inCreate);		
				}

			if(so->hasTarget) {
				TCHAR buf[40];
				_stprintf(buf,_T("%0.3f"),so->targDist);
				SetWindowText(GetDlgItem(hDlg,IDC_TARG_DISTANCE),buf);
				}
			
			CheckDlgButton( hDlg, IDC_DOF_ENABLE, so->GetDOFEnable(t) );
			
			return FALSE;

		case WM_DESTROY:
			RELEASE_SPIN ( fovSpin );
			RELEASE_SPIN ( lensSpin );
			RELEASE_SPIN ( hitherSpin );
			RELEASE_SPIN ( yonSpin );
			RELEASE_SPIN ( envNearSpin );
			RELEASE_SPIN ( envFarSpin );
			RELEASE_SPIN ( fStopSpin );
			RELEASE_BUT ( iFovType );
			if(!so->hasTarget)
				RELEASE_SPIN ( tdistSpin );
			return FALSE;

		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch ( LOWORD(wParam) ) {
				case IDC_FOVSPINNER:
					so->SetFOV(t, so->CurFOVtoWFOV(DegToRad(so->fovSpin->GetFVal())));	
					so->lensSpin->SetValue(so->FOVtoMM(so->GetFOV(t)), FALSE);
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
				case IDC_LENSSPINNER:
					so->SetFOV(t, so->MMtoFOV(so->lensSpin->GetFVal()));	
					so->fovSpin->SetValue(RadToDeg(so->WFOVtoCurFOV(so->GetFOV(t))), FALSE);
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
				case IDC_TDISTSPINNER:
					so->SetTDist(t, so->tdistSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
#if 0	// this section leaves the spinners unconstrained
				case IDC_HITHER_SPIN:
					so->SetClipDist(t, CAM_HITHER_CLIP, so->hitherSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
				case IDC_YON_SPIN:
					so->SetClipDist(t, CAM_YON_CLIP, so->yonSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
#else	// here, we constrain hither <= yon
				case IDC_HITHER_SPIN:
				case IDC_YON_SPIN:
					tmpSmall = so->hitherSpin->GetFVal();
					tmpLarge = so->yonSpin->GetFVal();

					if(tmpSmall > tmpLarge) {
						if(LOWORD(wParam) == IDC_HITHER_SPIN) {
							so->yonSpin->SetValue(tmpSmall, FALSE);
							so->SetClipDist(t, CAM_YON_CLIP, so->yonSpin->GetFVal());	
						}
						else	{
							so->hitherSpin->SetValue(tmpLarge, FALSE);
							so->SetClipDist(t, CAM_HITHER_CLIP, so->hitherSpin->GetFVal());	
						}
					}
					if(LOWORD(wParam) == IDC_HITHER_SPIN)
						so->SetClipDist(t, CAM_HITHER_CLIP, so->hitherSpin->GetFVal());	
					else
						so->SetClipDist(t, CAM_YON_CLIP, so->yonSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
#endif
#if 0	// similar constraint comments apply here
				case IDC_NEAR_RANGE_SPIN:
					so->SetEnvRange(t, ENV_NEAR_RANGE, so->envNearSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
				case IDC_FAR_RANGE_SPIN:
					so->SetEnvRange(t, ENV_FAR_RANGE, so->envFarSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
#else
				case IDC_NEAR_RANGE_SPIN:
				case IDC_FAR_RANGE_SPIN:
					tmpSmall = so->envNearSpin->GetFVal();
					tmpLarge = so->envFarSpin->GetFVal();

					if(tmpSmall > tmpLarge) {
						if(LOWORD(wParam) == IDC_NEAR_RANGE_SPIN) {
							so->envFarSpin->SetValue(tmpSmall, FALSE);
							so->SetEnvRange(t, ENV_FAR_RANGE, so->envFarSpin->GetFVal());	
						}
						else	{
							so->envNearSpin->SetValue(tmpLarge, FALSE);
							so->SetEnvRange(t, ENV_NEAR_RANGE, so->envNearSpin->GetFVal());	
						}
					}
					if(LOWORD(wParam) == IDC_NEAR_RANGE_SPIN)
						so->SetEnvRange(t, ENV_NEAR_RANGE, so->envNearSpin->GetFVal());	
					else
						so->SetEnvRange(t, ENV_FAR_RANGE, so->envFarSpin->GetFVal());	
					so->UpdateKeyBrackets(t);
					so->iObjParams->RedrawViews(t,REDRAW_INTERACTIVE);
					break;
#endif
				case IDC_DOF_FSTOP_SPIN:
					so->SetDOFFStop ( t, so->fStopSpin->GetFVal ());
					so->UpdateKeyBrackets (t);
					break;
				}
			return TRUE;

		case WM_SET_TYPE:
			theHold.Begin();
			so->SetType(wParam);
			theHold.Accept(GetString(IDS_DS_SETCAMTYPE));
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			so->iObjParams->RedrawViews(t,REDRAW_END);
			return TRUE;

		case WM_MOUSEACTIVATE:
			so->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MOUSEMOVE:
			so->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:			
			switch( LOWORD(wParam) ) {
#if 0	// no longer support creating cams from views
				case IDC_CREATE_VIEW:
				{
					ViewExp *vpt;
					SimpleCamera *camObject;
					TargetObject *targObject;
					INode *camNode, *targNode;
					TSTR targName;
					Matrix3 m, targM;
					vpt = so->iObjParams->GetActiveViewport();
					if(!vpt->IsPerspView()) {
						MessageBox(hDlg, _T("No way, Jose"), _T("Camera Creation Failure"), MB_OK);
						break;
					}
					camObject = new SimpleCamera(so->hasTarget);
				   	theHold.Begin();	 // begin hold for undo
					// link it up
					so->iObjParams->SelectNode(camNode = so->iObjParams->CreateObjectNode( camObject));
					camNode->InvalidateTM();
					vpt->GetAffineTM(m);
					m = Inverse(m);
					camObject->SetFOV(t, vpt->GetFOV());
					if(!so->hasTarget)
						camObject->SetTDist(t, vpt->GetFocalDist());
					else {
						// Create target object and node
						targObject = new TargetObject;
						assert(targObject);
						targNode = so->iObjParams->CreateObjectNode( targObject);
						targName = camNode->GetName();
						targName += GetString(IDS_DB_DOT_TARGET);
						targNode->SetName(targName);

						// hook up camera to target using lookat controller.
						so->iObjParams->BindToTarget(camNode,targNode);

						// set the target point based on the lookat direction and dist
						targM = m;
						targM.PreTranslate(Point3(0.0f, 0.0f, -vpt->GetFocalDist()));
						targNode->SetNodeTM(t, targM);
					}
					camNode->SetNodeTM(t, m);
					camObject->Enable(1);
					so->iObjParams->RedrawViews(so->iObjParams->GetTime());  
				    theHold.Accept(GetString(IDS_DS_CREATE));	 
					so->iObjParams->ReleaseViewport(vpt);
					break;
				}
#endif
				case IDC_MANUAL_CLIP:
					so->SetManualClip( IsDlgButtonChecked( hDlg, IDC_MANUAL_CLIP) );
					EnableWindow( GetDlgItem(hDlg, IDC_HITHER), so->manualClip);
					EnableWindow( GetDlgItem(hDlg, IDC_HITHER_SPIN), so->manualClip);
					EnableWindow( GetDlgItem(hDlg, IDC_YON), so->manualClip);
					EnableWindow( GetDlgItem(hDlg, IDC_YON_SPIN), so->manualClip);
					so->iObjParams->RedrawViews(t);
					break;
				case IDC_SHOWCAMCONE:
					so->SetConeState( IsDlgButtonChecked( hDlg, IDC_SHOWCAMCONE ) );
					so->iObjParams->RedrawViews(t);
					break;
				case IDC_SHOWHORZLINE:
					so->SetHorzLineState( IsDlgButtonChecked( hDlg, IDC_SHOWHORZLINE ) );
					so->iObjParams->RedrawViews(t);
					break;
				case IDC_SHOW_RANGES:
					so->SetEnvDisplay( IsDlgButtonChecked( hDlg, IDC_SHOW_RANGES ) );
					so->iObjParams->RedrawViews(t);
					break;
				case IDC_IS_ORTHO:
					so->SetOrtho( IsDlgButtonChecked( hDlg, IDC_IS_ORTHO ) );
					so->iObjParams->RedrawViews(t);
					break;
				case IDC_15MM:
				case IDC_20MM:
				case IDC_24MM:
				case IDC_28MM:
				case IDC_35MM:
				case IDC_50MM:
				case IDC_85MM:
				case IDC_135MM:
				case IDC_200MM:
					so->SetFOV(t, so->MMtoFOV(mmTab[LOWORD(wParam) - IDC_15MM]));	
					so->fovSpin->SetValue(RadToDeg(so->WFOVtoCurFOV(so->GetFOV(t))), FALSE);
					so->lensSpin->SetValue(so->FOVtoMM(so->GetFOV(t)), FALSE);
					so->iObjParams->RedrawViews(t,REDRAW_END);
					break;
				case IDC_FOV_TYPE: 
					so->SetFOVType(so->iFovType->GetCurFlyOff());
					break;
				case IDC_CAM_TYPE: {
					int code = HIWORD(wParam);
					if (code==CBN_SELCHANGE) {
						int newType = SendMessage( GetDlgItem(hDlg,IDC_CAM_TYPE), CB_GETCURSEL, 0, 0 );
						PostMessage(hDlg,WM_SET_TYPE,newType,0);
						}
					break;
					}
				case IDC_DOF_ENABLE:
					so->SetDOFEnable(t, IsDlgButtonChecked ( hDlg, IDC_DOF_ENABLE ));
					break;
				}
			return FALSE;

		default:
			return FALSE;
		}
	}



void SimpleCamera::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	iObjParams = ip;	

	inCreate = (flags&BEGIN_EDIT_CREATE)?1:0;

	if ( !hSimpleCamParams ) {
		hSimpleCamParams = ip->AddRollupPage( 
				hInstance, 
				hasTarget ? MAKEINTRESOURCE(IDD_SCAMERAPARAM) : MAKEINTRESOURCE(IDD_FCAMERAPARAM),
				SimpleCamParamDialogProc, 
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this );		
		
		ip->RegisterDlgWnd(hSimpleCamParams);

		{
			iFovType = GetICustButton(GetDlgItem(hSimpleCamParams,IDC_FOV_TYPE));
			iFovType->SetType(CBT_CHECK);
			iFovType->SetImage(hCamImages,0,0,0,0,14,14);
			FlyOffData fod[3] = {
				{ 0,0,0,0 },
				{ 1,1,1,1 },
				{ 2,2,2,2 }
				};
			iFovType->SetFlyOff(3,fod,0/*timeout*/,0/*init val*/,FLY_DOWN);
//			ttips[2] = GetResString(IDS_DB_BACKGROUND);
//			iFovType->SetTooltip(1, ttips[2]);
		}

		fovSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_FOVSPINNER));
		fovSpin->SetLimits( MIN_FOV, MAX_FOV, FALSE );
		fovSpin->SetValue(RadToDeg(WFOVtoCurFOV(GetFOV(ip->GetTime()))), FALSE);
		fovSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_FOV), EDITTYPE_FLOAT );
			
		lensSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_LENSSPINNER));
		lensSpin->SetLimits( MIN_LENS, MAX_LENS, FALSE );
		lensSpin->SetValue(FOVtoMM(GetFOV(ip->GetTime())), FALSE);
		lensSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_LENS), EDITTYPE_FLOAT );
			
		hitherSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_HITHER_SPIN));
		hitherSpin->SetLimits( MIN_CLIP, MAX_CLIP, FALSE );
		hitherSpin->SetValue(GetClipDist(ip->GetTime(), CAM_HITHER_CLIP), FALSE);
		hitherSpin->SetScale( 1.0f );
		hitherSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_HITHER), EDITTYPE_UNIVERSE );
			
		yonSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_YON_SPIN));
		yonSpin->SetLimits( MIN_CLIP, MAX_CLIP, FALSE );
		yonSpin->SetValue(GetClipDist(ip->GetTime(), CAM_YON_CLIP), FALSE);
		yonSpin->SetScale( 1.0f );
		yonSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_YON), EDITTYPE_UNIVERSE );
			
		envNearSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_NEAR_RANGE_SPIN));
		envNearSpin->SetLimits( 0.0f, 999999.0f, FALSE );
		envNearSpin->SetValue(GetEnvRange(ip->GetTime(), ENV_NEAR_RANGE), FALSE);
		envNearSpin->SetScale( 1.0f );
		envNearSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_NEAR_RANGE), EDITTYPE_UNIVERSE );
			
		envFarSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_FAR_RANGE_SPIN));
		envFarSpin->SetLimits( 0.0f, 999999.0f, FALSE );
		envFarSpin->SetValue(GetEnvRange(ip->GetTime(), ENV_FAR_RANGE), FALSE);
		envFarSpin->SetScale( 1.0f );
		envFarSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_FAR_RANGE), EDITTYPE_UNIVERSE );

		if(!hasTarget) {
			tdistSpin = GetISpinner(GetDlgItem(hSimpleCamParams,IDC_TDISTSPINNER));

			tdistSpin->SetLimits( MIN_TDIST, MAX_TDIST, FALSE );
			tdistSpin->SetValue(GetTDist(ip->GetTime()), FALSE);
			tdistSpin->LinkToEdit( GetDlgItem(hSimpleCamParams,IDC_TDIST), EDITTYPE_FLOAT );
			}
			
		if ( IsCompatibleRenderer () )
		{
			hDepthOfFieldParams = ip->AddRollupPage( 
								hInstance, 
								MAKEINTRESOURCE(IDD_CAMERA_DOF),
								SimpleCamParamDialogProc, 
								GetString(IDS_DOF), 
								(LPARAM)this 
								);		
			ip->RegisterDlgWnd(hDepthOfFieldParams);				
			fStopSpin = GetISpinner(GetDlgItem(hDepthOfFieldParams,IDC_DOF_FSTOP_SPIN));
			fStopSpin->SetLimits( 0.000001f, 100.0f, FALSE );
			fStopSpin->SetValue(GetDOFFStop(ip->GetTime()), FALSE);
			fStopSpin->SetScale( 0.1f );
			fStopSpin->LinkToEdit( GetDlgItem(hDepthOfFieldParams,IDC_DOF_FSTOP), EDITTYPE_FLOAT );
		}
		
	} else {
		SetWindowLong( hSimpleCamParams, GWL_USERDATA, (LONG)this );
		
		fovSpin->SetValue(RadToDeg(WFOVtoCurFOV(GetFOV(ip->GetTime()))),FALSE);
		hitherSpin->SetValue(GetClipDist(ip->GetTime(), CAM_HITHER_CLIP),FALSE);
		yonSpin->SetValue(GetClipDist(ip->GetTime(), CAM_YON_CLIP),FALSE);
		envNearSpin->SetValue(GetEnvRange(ip->GetTime(), ENV_NEAR_RANGE),FALSE);
		envFarSpin->SetValue(GetEnvRange(ip->GetTime(), ENV_FAR_RANGE),FALSE);
		if(!hasTarget)
			tdistSpin->SetValue(GetTDist(ip->GetTime()),FALSE);

		SetConeState( IsDlgButtonChecked(hSimpleCamParams,IDC_SHOWCAMCONE) );
		SetHorzLineState( IsDlgButtonChecked(hSimpleCamParams,IDC_SHOWHORZLINE) );
		SetEnvDisplay( IsDlgButtonChecked(hSimpleCamParams,IDC_SHOW_RANGES) );
		SetManualClip( IsDlgButtonChecked(hSimpleCamParams,IDC_MANUAL_CLIP) );
		if ( hDepthOfFieldParams )
			fStopSpin->SetValue ( GetDOFFStop (ip->GetTime()), FALSE );
		}
		
	SendMessage( GetDlgItem(hSimpleCamParams, IDC_CAM_TYPE), CB_SETCURSEL, hasTarget, (LPARAM)0 );
	}
		
void SimpleCamera::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	dlgFOV = GetFOV(ip->GetTime());
	dlgShowCone = IsDlgButtonChecked(hSimpleCamParams, IDC_SHOWCAMCONE );
	dlgRangeDisplay = IsDlgButtonChecked(hSimpleCamParams, IDC_SHOW_RANGES );
	dlgIsOrtho = IsDlgButtonChecked(hSimpleCamParams, IDC_IS_ORTHO);
	dlgShowHorzLine = IsDlgButtonChecked(hSimpleCamParams, IDC_SHOWHORZLINE );
	dlgClip = IsDlgButtonChecked(hSimpleCamParams, IDC_MANUAL_CLIP );
	dlgTDist = GetTDist(ip->GetTime());
	dlgHither = GetClipDist(ip->GetTime(), CAM_HITHER_CLIP);
	dlgYon = GetClipDist(ip->GetTime(), CAM_YON_CLIP);
	dlgNearRange = GetEnvRange(ip->GetTime(), ENV_NEAR_RANGE);
	dlgFarRange = GetEnvRange(ip->GetTime(), ENV_FAR_RANGE);

	// Depth of Field
	dlgDOFEnable = GetDOFEnable (ip->GetTime());
	dlgDOFFStop = GetDOFFStop(ip->GetTime());
	if ( flags&END_EDIT_REMOVEUI ) {
		if ( hDepthOfFieldParams )
		{
			ip->UnRegisterDlgWnd ( hDepthOfFieldParams );
			ip->DeleteRollupPage ( hDepthOfFieldParams );
			hDepthOfFieldParams = NULL;
		}

		ip->UnRegisterDlgWnd(hSimpleCamParams);
		ip->DeleteRollupPage(hSimpleCamParams);
		hSimpleCamParams = NULL;				
	} else {
		SetWindowLong( hSimpleCamParams, GWL_USERDATA, 0 );
		SetWindowLong( hDepthOfFieldParams, GWL_USERDATA, 0 );
		}
	
	iObjParams = NULL;
	}


static void MakeQuad(Face *f, int a,  int b , int c , int d, int sg, int dv = 0) {
	f[0].setVerts( a+dv, b+dv, c+dv);
	f[0].setSmGroup(sg);
	f[0].setEdgeVisFlags(1,1,0);
	f[1].setVerts( c+dv, d+dv, a+dv);
	f[1].setSmGroup(sg);
	f[1].setEdgeVisFlags(1,1,0);
	}

void SimpleCamera::BuildMesh()	{
	int nverts = 16;
	int nfaces = 24;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	float len = (float)5.0;
	float w = (float)8.0;
	float d = w*(float).8;
	float e = d*(float).5;
	float f = d*(float).8;
	float l = w*(float).8;

	mesh.setVert(0, Point3( -d, -d, -len));
	mesh.setVert(1, Point3(  d, -d, -len));
	mesh.setVert(2, Point3( -d,  d, -len));
	mesh.setVert(3, Point3(  d,  d, -len));
	mesh.setVert(4, Point3( -d, -d,  len));
	mesh.setVert(5, Point3(  d, -d,  len));
	mesh.setVert(6, Point3( -d,  d,  len));
	mesh.setVert(7, Point3(  d,  d,  len));
	MakeQuad(&(mesh.faces[ 0]), 0,2,3,1,  1);
	MakeQuad(&(mesh.faces[ 2]), 2,0,4,6,  2);
	MakeQuad(&(mesh.faces[ 4]), 3,2,6,7,  4);
	MakeQuad(&(mesh.faces[ 6]), 1,3,7,5,  8);
	MakeQuad(&(mesh.faces[ 8]), 0,1,5,4, 16);
	MakeQuad(&(mesh.faces[10]), 4,5,7,6, 32);
	
	mesh.setVert(8+0, Point3( -e, -e, len));
	mesh.setVert(8+1, Point3(  e, -e, len));
	mesh.setVert(8+2, Point3( -e,  e, len));
	mesh.setVert(8+3, Point3(  e,  e, len));
	mesh.setVert(8+4, Point3( -f, -f, len+l));
	mesh.setVert(8+5, Point3(  f, -f, len+l));
	mesh.setVert(8+6, Point3( -f,  f, len+l));
	mesh.setVert(8+7, Point3(  f,  f, len+l));

	Face* fbase = &mesh.faces[12];
	MakeQuad(&fbase[0],0,2,3,1,   1, 8);
	MakeQuad(&fbase[2], 2,0,4,6,  2, 8);
	MakeQuad(&fbase[4], 3,2,6,7,  4, 8);
	MakeQuad(&fbase[6], 1,3,7,5,  8, 8);
	MakeQuad(&fbase[8], 0,1,5,4, 16, 8);
	MakeQuad(&fbase[10],4,5,7,6, 32, 8);

	// whoops- rotate 180 about x to get it facing the right way
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.RotateX(DegToRad(180.0));
	for (int i=0; i<nverts; i++)
		mesh.getVert(i) = mat*mesh.getVert(i);
	mesh.buildNormals();
	mesh.EnableEdgeList(1);
	meshBuilt = 1;
	}

void SimpleCamera::UpdateKeyBrackets(TimeValue t) {
	fovSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_FOV,t));
	lensSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_FOV,t));
	hitherSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_HITHER,t));
	yonSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_YON,t));
	envNearSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_NRANGE,t));
	envFarSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_FRANGE,t));
	}

void SimpleCamera::UpdateUI(TimeValue t)
	{
	if ( hSimpleCamParams && !waitPostLoad &&
		GetWindowLong(hSimpleCamParams,GWL_USERDATA)==(LONG)this ) {
		fovSpin->SetValue( RadToDeg(WFOVtoCurFOV(GetFOV(t))), FALSE );
		lensSpin->SetValue(FOVtoMM(GetFOV(t)), FALSE);
		hitherSpin->SetValue( GetClipDist(t, CAM_HITHER_CLIP), FALSE );
		yonSpin->SetValue( GetClipDist(t, CAM_YON_CLIP), FALSE );
		envNearSpin->SetValue( GetEnvRange(t, ENV_NEAR_RANGE), FALSE );
		envFarSpin->SetValue( GetEnvRange(t, ENV_FAR_RANGE), FALSE );
		
		UpdateKeyBrackets(t);

		if(!hasTarget)
			tdistSpin->SetValue( GetTDist(t), FALSE );
		}	
	}

#define CAMERA_VERSION 2		// current version
#define DOF_VERSION 1		// current version

static ParamBlockDescID descV0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// FOV
	{ TYPE_FLOAT, NULL, TRUE, 2 } };	// TDIST

static ParamBlockDescID descV1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// FOV
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// TDIST
	{ TYPE_FLOAT, NULL, TRUE, 3 },		// HITHER
	{ TYPE_FLOAT, NULL, TRUE, 4 } };	// YON

static ParamBlockDescID descV2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// FOV
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// TDIST
	{ TYPE_FLOAT, NULL, TRUE, 3 },		// HITHER
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// YON
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// NEAR ENV RANGE
	{ TYPE_FLOAT, NULL, TRUE, 6 } };	// FAR ENV RANGE

static ParamBlockDescID dofV0[] = {
	{ TYPE_BOOL,  NULL, TRUE,  1 },		// ENABLE
	{ TYPE_FLOAT, NULL, TRUE, 2 } };	// FSTOP

SimpleCamera::SimpleCamera(int look) 
	{
	
	MakeRefByID( FOREVER, 0, CreateParameterBlock( descV2, 6, CAMERA_VERSION ) );	
	MakeRefByID( FOREVER, DOF_REF, CreateParameterBlock( dofV0, 2, DOF_VERSION ) );	
	
	SetFOV( TimeValue(0), dlgFOV );	
	SetTDist( TimeValue(0), dlgTDist );	
	SetClipDist( TimeValue(0), CAM_HITHER_CLIP, dlgHither );	
	SetClipDist( TimeValue(0), CAM_YON_CLIP, dlgYon );	
	SetEnvRange( TimeValue(0), ENV_NEAR_RANGE, dlgNearRange );	
	SetEnvRange( TimeValue(0), ENV_FAR_RANGE, dlgFarRange );	
	SetDOFEnable ( TimeValue(0), dlgDOFEnable );
	SetDOFFStop ( TimeValue(0), dlgDOFFStop );
	fovType = FOV_W;

	hasTarget = look;
	enable = 0;
	coneState = dlgShowCone;
	rangeDisplay = dlgRangeDisplay;
	horzLineState = dlgShowHorzLine;
	manualClip = dlgClip;
	isOrtho = dlgIsOrtho;
	
	BuildMesh();	
	}

BOOL SimpleCamera::IsCompatibleRenderer ( void )
{
	Class_ID	rclass = Class_ID ( 0x58f67d6c, 0x4fcf3bc3 );
	ClassDesc	*cd = GetCOREInterface()->GetDllDir().ClassDir().FindClass(RENDERER_CLASS_ID, rclass );

	if ( cd != NULL )
		return TRUE;

	return FALSE;
}

BOOL SimpleCamera::SetFOVControl(Control *c)
	{
	pblock->SetController(PB_FOV,c);
	return TRUE;
	}
Control * SimpleCamera::GetFOVControl() {
	return 	pblock->GetController(PB_FOV);
	}

void SimpleCamera::SetConeState(int s) {
	coneState = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void SimpleCamera::SetHorzLineState(int s) {
	horzLineState = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}



//--------------------------------------------

static INode* FindNodeRef(ReferenceTarget *rt);

static INode* GetNodeRef(ReferenceMaker *rm) {
	if (rm->SuperClassID()==BASENODE_CLASS_ID) return (INode *)rm;
	else return rm->IsRefTarget()?FindNodeRef((ReferenceTarget *)rm):NULL;
	}

static INode* FindNodeRef(ReferenceTarget *rt) {
	DependentIterator di(rt);
	ReferenceMaker *rm;
	INode *nd = NULL;
	while (rm=di.Next()) {	
		nd = GetNodeRef(rm);
		if (nd) return nd;
		}
	return NULL;
	}

static INode* FindSelNodeRef(ReferenceTarget *rt) {
	DependentIterator di(rt);
	ReferenceMaker *rm;
	INode *nd = NULL;
	while (rm=di.Next()) {	
		if (rm->SuperClassID()==BASENODE_CLASS_ID) {
			nd = (INode *)rm;
			if(nd->Selected()) return nd;
			}
		}
	return NULL;
	}

//----------------------------------------------------------------

class SetCamTypeRest: public RestoreObj {
	public:
		SimpleCamera *theLight;
		int oldHasTarget;
		SetCamTypeRest(SimpleCamera *lt, int newt) {
			theLight = lt;
			oldHasTarget = lt->hasTarget;
			}
		~SetCamTypeRest() { }
		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		virtual TSTR Description() { return TSTR(_T("Set Camera Type")); }
	};


void SetCamTypeRest::Restore(int isUndo) {
	theLight->hasTarget = oldHasTarget;
	theLight->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void SetCamTypeRest::Redo() {
	theLight->hasTarget = !oldHasTarget;
	theLight->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

/*----------------------------------------------------------------*/

void SimpleCamera::SetType(int tp) {     
	if (hasTarget == tp) 
		return;

	Interface *iface = GetCOREInterface();
	TimeValue t = iface->GetTime();
	INode *selnode = NULL;
	INode *nd = FindNodeRef(this);
	if (nd==NULL) 
		return;

	if (hSimpleCamParams) {
		selnode = FindSelNodeRef(this);
		if (selnode)
			iface->DeSelectNode(selnode);  // this removes the rollups in a clean way
		}

	if (theHold.Holding())
		theHold.Put(new SetCamTypeRest(this,tp));

	int oldtype = hasTarget;
	Interval v;
	float tdist = GetTDist(t,v);
	hasTarget = tp;

	if(oldtype==TARGETED_CAMERA) {
		tdist = targDist;
		// get rid of target, assign a PRS controller for all instances
		DependentIterator di(this);
		ReferenceMaker *rm;
		// iterate through the instances
		while (rm=di.Next()) {
			nd = GetNodeRef(rm);
			if (nd) {
				INode* tn = nd->GetTarget(); 
				Matrix3 tm = nd->GetNodeTM(0);
				if (tn) iface->DeleteNode(tn);  // JBW, make it safe if no target
				Control *tmc = NewDefaultMatrix3Controller();
				tmc->Copy(nd->GetTMController()); // doesn't copy rotation, only scale and position.
				nd->SetTMController(tmc);
				nd->SetNodeTM(0,tm);		// preserve rotation if not animated at least
				SetTDist(0,tdist);	 //?? which one should this be for
				}
			}

		}
	else  {
		DependentIterator di(this);
		ReferenceMaker *rm;
		// iterate through the instances
		while (rm=di.Next()) {	
			nd = GetNodeRef(rm);
			if (nd) {
				// create a target, assign lookat controller
				Matrix3 tm = nd->GetNodeTM(t);
				Matrix3 targtm = tm;
				targtm.PreTranslate(Point3(0.0f,0.0f,-tdist));
				Object *targObject = new TargetObject;
				INode *targNode = iface->CreateObjectNode( targObject);
				TSTR targName;
				targName = nd->GetName();
				targName += GetString(IDS_DB_DOT_TARGET);
				targNode->SetName(targName);
				targNode->SetNodeTM(0,targtm);
				Control *laControl= CreateLookatControl();
				laControl->SetTarget(targNode);
				laControl->Copy(nd->GetTMController());
				nd->SetTMController(laControl);
				targNode->SetIsTarget(1);   
				}
			}
		}
	if (selnode)
		iface->SelectNode(selnode);

	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	iface->RedrawViews(iface->GetTime());
	}


//---------------------------------------
void SimpleCamera::SetFOV(TimeValue t, float f) {
	pblock->SetValue( PB_FOV, t, f );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float SimpleCamera::GetFOV(TimeValue t,Interval& valid) {	
	float f;
	pblock->GetValue( PB_FOV, t, f, valid );
	if ( f < float(0) ) f = float(0);
	return f;
	}

void SimpleCamera::SetTDist(TimeValue t, float f) {
	pblock->SetValue( PB_TDIST, t, f );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float SimpleCamera::GetTDist(TimeValue t,Interval& valid) {	
	float f;
	pblock->GetValue( PB_TDIST, t, f, valid );
	if ( f < MIN_TDIST ) f = MIN_TDIST;
	return f;
}

void SimpleCamera::SetManualClip(int onOff)
{
	manualClip = onOff;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

float SimpleCamera::GetClipDist(TimeValue t, int which, Interval &valid)
{
	float f;
	pblock->GetValue( PB_HITHER+which-1, t, f, valid );
	if ( f < MIN_CLIP ) f = MIN_CLIP;
	if ( f > MAX_CLIP ) f = MAX_CLIP;
	return f;
}

void SimpleCamera::SetClipDist(TimeValue t, int which, float f)
{
	pblock->SetValue( PB_HITHER+which-1, t, f );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}


void SimpleCamera::SetEnvRange(TimeValue t, int which, float f)
{
	pblock->SetValue( PB_NRANGE+which, t, f );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

float SimpleCamera::GetEnvRange(TimeValue t, int which, Interval &valid)
{
	float f;
	pblock->GetValue( PB_NRANGE+which, t, f, valid );
	return f;
}

void SimpleCamera::SetEnvDisplay(BOOL b, int notify) {
	rangeDisplay = b;
	if(notify)
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void SimpleCamera::SetDOFEnable (TimeValue t, BOOL onOff) {
	depthOfFieldPB->SetValue( PB_DOF_ENABLE, t, onOff );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

BOOL SimpleCamera::GetDOFEnable(TimeValue t,Interval& valid) {	
	BOOL f;
	depthOfFieldPB->GetValue( PB_DOF_ENABLE, t, f, valid );
	return f;
	}

void SimpleCamera::SetDOFFStop (TimeValue t, float f) {
	depthOfFieldPB->SetValue( PB_DOF_FSTOP, t, f );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float SimpleCamera::GetDOFFStop(TimeValue t,Interval& valid) {	
	float f;
	depthOfFieldPB->GetValue( PB_DOF_FSTOP, t, f, valid );
	return f;
	}

void SimpleCamera::SetOrtho(BOOL b) {
	isOrtho = b;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

SimpleCamera::~SimpleCamera() {
	DeleteAllRefsFromMe();
	pblock = NULL;
	}

class SCamCreateCallBack: public CreateMouseCallBack {
	SimpleCamera *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(SimpleCamera *obj) { ob = obj; }
	};

int SCamCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	ob->enable = 1;
#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		//mat[3] = vpt->GetPointOnCP(m);
#ifdef _3D_CREATE
		mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_3D) );
#else
		mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE) );
#endif
		if (point==1 && msg==MOUSE_POINT) 
			return 0;
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
	}

static SCamCreateCallBack sCamCreateCB;

CreateMouseCallBack* SimpleCamera::GetCreateMouseCallBack() {
	sCamCreateCB.SetObj(this);
	return(&sCamCreateCB);
	}

void SimpleCamera::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm) {
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	if (scaleFactor!=(float)1.0)
		tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
	}

void SimpleCamera::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	box = mesh.getBoundingBox(tm);
	}

void SimpleCamera::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ){
	Matrix3 m = inode->GetObjectTM(t);
	Point3 pt;
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(m.GetTrans())/(float)360.0;
	box = mesh.getBoundingBox();
#if 0
	if (!hasTarget) {
		if (coneState) {
			Point3 q[4];
			GetConePoints(t,q,scaleFactor*FIXED_CONE_DIST);
			box.IncludePoints(q,4);
			}
		}
#endif
	box.Scale(scaleFactor);
	Point3 q[4];

	if (GetTargetPoint(t,inode,pt)){
		float d = Length(m.GetTrans()-pt)/Length(inode->GetObjectTM(t).GetRow(2));
		box += Point3(float(0),float(0),-d);
		if (coneState || (extDispFlags & EXT_DISP_ONLY_SELECTED)) {
			if(manualClip) {
				GetConePoints(t,q,GetClipDist(t,CAM_YON_CLIP));
				box.IncludePoints(q,4);
			}
			GetConePoints(t,q,d);
			box.IncludePoints(q,4);
			}
		}
#if 1
	else {
		if (coneState || (extDispFlags & EXT_DISP_ONLY_SELECTED)) {
			float d = GetTDist(t);
			box += Point3(float(0),float(0),-d);
			GetConePoints(t,q,d);
			box.IncludePoints(q,4);
			}
		}
#endif
	if( rangeDisplay) {
		Point3 q[4];
		float rad = max(GetEnvRange(t, ENV_NEAR_RANGE), GetEnvRange(t, ENV_FAR_RANGE));
		GetConePoints(t, q, rad);
		box.IncludePoints(q,4);
		}
	}

void SimpleCamera::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	int i,nv;
	Matrix3 tm;
	float dtarg;
	Point3 pt;
	GetMat(t,inode,vpt,tm);
	nv = mesh.getNumVerts();
	box.Init();
	if(!(extDispFlags & EXT_DISP_ZOOM_EXT))
		for (i=0; i<nv; i++) 
			box += tm*mesh.getVert(i);
	else
		box += tm.GetTrans();

	tm = inode->GetObjectTM(t);
	if (hasTarget) {
		if (GetTargetPoint(t,inode,pt)) {
			dtarg = Length(tm.GetTrans()-pt)/Length(tm.GetRow(2));
			box += tm*Point3(float(0),float(0),-dtarg);
			}
		}
#if 0
	else dtarg = FIXED_CONE_DIST;
#else
	else dtarg = GetTDist(t);
#endif
	if (coneState || (extDispFlags & EXT_DISP_ONLY_SELECTED)) {
		Point3 q[4];
		if(manualClip) {
			GetConePoints(t,q,GetClipDist(t,CAM_YON_CLIP));
			box.IncludePoints(q,4,&tm);
			}
		GetConePoints(t,q,dtarg);
		box.IncludePoints(q,4,&tm);
		}
	if( rangeDisplay) {
		Point3 q[4];
		float rad = max(GetEnvRange(t, ENV_NEAR_RANGE), GetEnvRange(t, ENV_FAR_RANGE));
		GetConePoints(t, q,rad);
		box.IncludePoints(q,4,&tm);
		}
	}

void SimpleCamera::UpdateTargDistance(TimeValue t, INode* inode) {
	if (hasTarget&&hSimpleCamParams) {
		Point3 pt,v[2];
		if (GetTargetPoint(t,inode,pt)){
			Matrix3 tm = inode->GetObjectTM(t);
			float den = Length(tm.GetRow(2));
			targDist = (den!=0)?Length(tm.GetTrans()-pt)/den : 0.0f;
			TCHAR buf[40];
			_stprintf(buf,_T("%0.3f"),targDist);
			SetWindowText(GetDlgItem(hSimpleCamParams,IDC_TARG_DISTANCE),buf);
			}
		}
	}

int SimpleCamera::DrawConeAndLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing ) {
	Matrix3 tm = inode->GetObjectTM(t);
	gw->setTransform(tm);
	if (hasTarget) {
		Point3 pt,v[3];
		if (GetTargetPoint(t,inode,pt)){
			float den = Length(tm.GetRow(2));
			float dist = (den!=0)?Length(tm.GetTrans()-pt)/den : 0.0f;
			targDist = dist;
			if (hSimpleCamParams) {
				TCHAR buf[40];
				_stprintf(buf,_T("%0.3f"),targDist);
				SetWindowText(GetDlgItem(hSimpleCamParams,IDC_TARG_DISTANCE),buf);
				}
			if ((drawing != -1) && (coneState || (extDispFlags & EXT_DISP_ONLY_SELECTED))) {
				if(manualClip) {
					DrawCone(t, gw, GetClipDist(t, CAM_HITHER_CLIP),COLOR_CAMERA_CLIP,0,1);
					DrawCone(t, gw, GetClipDist(t, CAM_YON_CLIP),COLOR_CAMERA_CLIP,1,1);
					}
				else
					DrawCone(t,gw,dist,COLOR_CAMERA_CONE,TRUE);
			}
			if(!inode->IsFrozen())
				gw->setColor( LINE_COLOR, GetUIColor(COLOR_TARGET_LINE));
			v[0] = Point3(0,0,0);
			if (drawing == -1)
				v[1] = Point3(0.0f, 0.0f, -0.9f * dist);
			else
				v[1] = Point3(0.0f, 0.0f, -dist);
			gw->polyline( 2, v, NULL, NULL, FALSE, NULL );	
			}
		}
	else {
		if (coneState || (extDispFlags & EXT_DISP_ONLY_SELECTED))
			if(manualClip) {
				DrawCone(t, gw, GetClipDist(t, CAM_HITHER_CLIP),COLOR_CAMERA_CLIP,0,1);
				DrawCone(t, gw, GetClipDist(t, CAM_YON_CLIP),COLOR_CAMERA_CLIP,1,1);
				}
			else
				DrawCone(t,gw,GetTDist(t),COLOR_CAMERA_CONE,TRUE);
		}
	return gw->checkHitCode();
	}

// From BaseObject
int SimpleCamera::HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	HitRegion hitRegion;
	DWORD	savedLimits;
	int res;
	Matrix3 m;
	if (!enable) return  0;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	gw->clearHitCode();
	res = mesh.select( gw, gw->getMaterial(), &hitRegion, flags & HIT_ABORTONHIT ); 
	// if not, check the target line, and set the pair flag if it's hit
	if( !res )	{
		// this special case only works with point selection of targeted lights
		if((type != HITTYPE_POINT) || !inode->GetTarget())
			return 0;
		// don't let line be active if only looking at selected stuff and target isn't selected
		if((flags & HIT_SELONLY) && !inode->GetTarget()->Selected() )
			return 0;
		gw->clearHitCode();
		if(res = DrawConeAndLine(t, inode, gw, -1))
			inode->SetTargetNodePair(1);
	}
	gw->setRndLimits(savedLimits);
	return res;
}

void SimpleCamera::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();	
   	
		gw->setTransform(tm);

		Point2 fp = Point2((float)p->x, (float)p->y);
		IPoint3 screen3;
		Point2 screen2;
		Point3 vert(0.0f,0.0f,0.0f);

		gw->wTransPoint(&vert,&screen3);

		screen2.x = (float)screen3.x;
		screen2.y = (float)screen3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			else // Closer than the best of this priority?
			if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			}
		}
	}


int SimpleCamera::DrawRange(TimeValue t, INode *inode, GraphicsWindow *gw)
{
	if(!rangeDisplay)
		return 0;
	Matrix3 tm = inode->GetObjectTM(t);
	gw->setTransform(tm);
	int cnear = 0;
	int cfar = 0;
	if(!inode->IsFrozen()) { 
		cnear = COLOR_NEAR_RANGE;
		cfar = COLOR_FAR_RANGE;
		}
	DrawCone(t, gw, GetEnvRange(t, ENV_NEAR_RANGE),cnear);
	DrawCone(t, gw, GetEnvRange(t, ENV_FAR_RANGE), cfar, TRUE);
	return gw->checkHitCode();
	}

#define MAXVP_DIST 1.0e8f

void SimpleCamera::GetConePoints(TimeValue t, Point3* q, float dist) {
	if (dist>MAXVP_DIST)
		dist = MAXVP_DIST;
	float ta = (float)tan(0.5*(double)GetFOV(t));
	float w = dist * ta;
//	float h = w * (float).75; //  ASPECT ??
	float h = w / GetAspect();
	q[0] = Point3( w, h,-dist);				
	q[1] = Point3(-w, h,-dist);				
	q[2] = Point3(-w,-h,-dist);				
	q[3] = Point3( w,-h,-dist);				
	}

void SimpleCamera::DrawCone(TimeValue t, GraphicsWindow *gw, float dist, int colid, BOOL drawSides, BOOL drawDiags) {
	Point3 q[5], u[3];
	GetConePoints(t,q,dist);
	if (colid)	gw->setColor( LINE_COLOR, GetUIColor(colid));
	if (drawDiags) {
		u[0] =  q[0];	u[1] =  q[2];	
		gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
		u[0] =  q[1];	u[1] =  q[3];	
		gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
		}
	gw->polyline( 4, q, NULL, NULL, TRUE, NULL );	
	if (drawSides) {
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_CAMERA_CONE));
		u[0] = Point3(0,0,0);
		for (int i=0; i<4; i++) {
			u[1] =  q[i];	
			gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
			}
		}
	}

void SimpleCamera::SetExtendedDisplay(int flags)
{
	extDispFlags = flags;
}


int SimpleCamera::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	if (!enable) return  0;

	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
	if (inode->Selected())
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_CAMERA_OBJ));
	mesh.render( gw, gw->getMaterial(), NULL, COMP_ALL);	
	DrawConeAndLine(t,inode,gw,1);
#if 0
	if(horzLineState) {
		Point3 eye, tgt;
		eye = inode->GetObjTMAfterWSM(t).GetTrans();
		if(inode->GetTarget())
			tgt = inode->GetTarget()->GetObjTMAfterWSM(t).GetTrans();
		else {
			m = inode->GetObjTMAfterWSM(t);
			m.PreTranslate(Point3(0.0f, 0.0f, -GetTDist(t)));
			tgt = m.GetTrans();
		}
		tgt[1] = eye[1];
        Point3 pt[10];
        float camDist;
		float ta = (float)tan(0.5*(double)GetFOV(t));

        camDist = (float)sqrt((tgt[0]-eye[0]) * (tgt[0]-eye[0]) + (tgt[2]-eye[2]) * (tgt[2]-eye[2]));
               
        pt[0][0] = -camDist * ta;
        pt[0][1] = 0.0f;
        pt[0][2] = -camDist;
        pt[1][0] = camDist * ta;
        pt[1][1] = 0.0f;
        pt[1][2] = -camDist;
		gw->polyline(2, pt, NULL, NULL, 0, NULL);

	}
#endif
	DrawRange(t, inode, gw);
	gw->setRndLimits(rlim);
	return(0);
	}


RefResult SimpleCamera::EvalCameraState(TimeValue t, Interval& valid, CameraState* cs) {
	cs->isOrtho = IsOrtho();	
	cs->fov = GetFOV(t,valid);
	cs->tdist = GetTDist(t,valid);
	cs->horzLine = horzLineState;
	cs->manualClip = manualClip;
	cs->hither = GetClipDist(t, CAM_HITHER_CLIP, valid);
	cs->yon = GetClipDist(t, CAM_YON_CLIP, valid);
	cs->nearRange = GetEnvRange(t, ENV_NEAR_RANGE, valid);
	cs->farRange = GetEnvRange(t, ENV_FAR_RANGE, valid);
	return REF_SUCCEED;
	}

//
// Reference Managment:
//

RefResult SimpleCamera::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	PartID& partID, RefMessage message ) 
	{
	switch (message) {		
		case REFMSG_WANT_SHOWPARAMLEVEL: {
			BOOL	*pb = ( BOOL * )partID;
			if ( hTarget == ( RefTargetHandle )depthOfFieldPB )
				*pb = TRUE;
			else
				*pb = FALSE;

			return REF_STOP;
			}

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			if ( hTarget == ( RefTargetHandle )pblock )
			{
				switch (gpd->index) {
					case PB_FOV:
						gpd->dim = stdAngleDim;
						break;				
					case PB_TDIST:
					case PB_HITHER:
					case PB_YON:
					case PB_NRANGE:
					case PB_FRANGE:
						gpd->dim = stdWorldDim;
						break;				
					}
			}
			else
			if ( hTarget == ( RefTargetHandle )depthOfFieldPB )
			{
				switch (gpd->index) {
					case PB_DOF_ENABLE:
					case PB_DOF_FSTOP:
						gpd->dim = defaultDim;
						break;		
				}
			}

			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			if ( hTarget == ( RefTargetHandle )pblock )
			{
				switch (gpn->index) {
					case PB_FOV:
						gpn->name = TSTR(GetString(IDS_RB_FOV));
						break;												
					case PB_TDIST:
						gpn->name = TSTR(GetString(IDS_DB_TDIST));
						break;												
					case PB_HITHER:
						gpn->name = TSTR(GetString(IDS_RB_NEARPLANE));
						break;												
					case PB_YON:
						gpn->name = TSTR(GetString(IDS_RB_FARPLANE));
						break;												
					case PB_NRANGE:
						gpn->name = TSTR(GetString(IDS_DB_NRANGE));
						break;												
					case PB_FRANGE:
						gpn->name = TSTR(GetString(IDS_DB_FRANGE));
						break;												
					}
			}
			else
			if ( hTarget == ( RefTargetHandle )depthOfFieldPB )
			{
				switch (gpn->index) {
					case PB_DOF_ENABLE:
						gpn->name = TSTR(GetString(IDS_DOF_ENABLE));
						break;												
					case PB_DOF_FSTOP:
						gpn->name = TSTR(GetString(IDS_DOF_FSTOP));
						break;
				}
			}
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}


ObjectState SimpleCamera::Eval(TimeValue time){
	// UpdateUI(time);
	return ObjectState(this);
	}

Interval SimpleCamera::ObjectValidity(TimeValue time) {
	Interval ivalid;
	ivalid.SetInfinite();
	if (!waitPostLoad) {
		GetFOV(time,ivalid);
		GetTDist(time,ivalid);
		GetClipDist(time, CAM_HITHER_CLIP, ivalid);
		GetClipDist(time, CAM_YON_CLIP, ivalid);
		GetEnvRange(time, ENV_NEAR_RANGE, ivalid);
		GetEnvRange(time, ENV_FAR_RANGE, ivalid);
		GetDOFEnable(time, ivalid);
		GetDOFFStop(time, ivalid);
		UpdateUI(time);
		}
	return ivalid;	
	}


//********************************************************
// LOOKAT CAMERA
//********************************************************


//------------------------------------------------------
class LACamClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SimpleCamera(1); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	const TCHAR *	ClassName() { return GetString(IDS_DB_TARGET); }
    SClass_ID		SuperClassID() { return CAMERA_CLASS_ID; }
   	Class_ID		ClassID() { return Class_ID(LOOKAT_CAM_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetCameraParams(); }
	};

static LACamClassDesc laCamClassDesc;

extern ClassDesc* GetLookatCamDesc() {return &laCamClassDesc; }

class LACamCreationManager : public MouseCallBack, ReferenceMaker {
	private:
		CreateMouseCallBack *createCB;	
		INode *camNode,*targNode;
		SimpleCamera *camObject;
		TargetObject *targObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		IPoint2 pt0;
		int ignoreSelectionChange;
		int lastPutCount;

		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)camNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { camNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		LACamCreationManager()
			{
			ignoreSelectionChange = FALSE;
			}
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_SIMPLECAMCREATE	CID_USER + 1

class LACamCreateMode : public CommandMode {
		LACamCreationManager proc;
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }

		int Class() { return CREATE_COMMAND; }
		int ID() { return CID_SIMPLECAMCREATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints = 1000000; return &proc; }
		ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() {}
		void ExitMode() {}
		BOOL IsSticky() { return FALSE; }
	};

static LACamCreateMode theLACamCreateMode;

//LACamCreationManager::LACamCreationManager( IObjCreate *ioc, ClassDesc *desc )
void LACamCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	camNode         = NULL;
	targNode        = NULL;
	camObject       = NULL;
	targObject      = NULL;
	CreateNewObject();
	}

//LACamCreationManager::~LACamCreationManager
void LACamCreationManager::End()
	{
	if ( camObject ) {
		camObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) {
			// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete camObject;
			camObject = NULL;
			theHold.Resume();
			// RB 7/28/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
			macroRec->Cancel();  // JBW 4/23/99
		} else if ( camNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
		}	
	}

RefResult LACamCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( camObject && camNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if ( camObject && camNode==hTarget ) {
				endEdit:
				camObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				camObject  = NULL;				
				camNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			else if (targNode==hTarget) {
				targNode = NULL;
				targObject = NULL;
				}
			break;		
		}
	return REF_SUCCEED;
	}


void LACamCreationManager::CreateNewObject()
	{
	camObject = (SimpleCamera*)cDesc->Create();
	lastPutCount = theHold.GetGlobalPutCount();

    macroRec->BeginCreate(cDesc);  // JBW 4/23/99
	// Start the edit params process
	if ( camObject ) {
		camObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
		}	
	}

static BOOL needToss;
			
int LACamCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
	{	
	int res;	
	TSTR targName;
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					pt0 = m;
					assert( camObject );					
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					// if cameras were hidden by category, re-display them
					GetCOREInterface()->SetHideByCategoryFlags(
							GetCOREInterface()->GetHideByCategoryFlags() & ~HIDE_CAMERAS);

					if ( attachedToNode ) {
				   		// send this one on its way
				   		camObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						macroRec->EmitScript();  // JBW 4/23/99
						
						// Get rid of the reference.
						if (camNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates camObject
						}

					needToss = theHold.GetGlobalPutCount()!=lastPutCount;

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					camNode = createInterface->CreateObjectNode( camObject);
					attachedToNode = TRUE;
					assert( camNode );					
					createCB = camObject->GetCreateMouseCallBack();
					createInterface->SelectNode( camNode );
					
					// Create target object and node
					targObject = new TargetObject;
					assert(targObject);
					targNode = createInterface->CreateObjectNode( targObject);
					assert(targNode);
					targName = camNode->GetName();
					targName += GetString(IDS_DB_DOT_TARGET);
					targNode->SetName(targName);

					// hook up camera to target using lookat controller.
					createInterface->BindToTarget(camNode,targNode);					

					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, camNode);
					theHold.Resume();

					// Position camera and target at first point then drag.
					mat.IdentityMatrix();
					//mat[3] = vpx->GetPointOnCP(m);
#ifdef _3D_CREATE
					mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
#else
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
#endif
					createInterface->SetNodeTMRelConstPlane(camNode, mat);
					createInterface->SetNodeTMRelConstPlane(targNode, mat);
					camObject->Enable(1);

				   	ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( targNode,0);
				   	ignoreSelectionChange = FALSE;
					res = TRUE;
					break;
					
				case 1:
					if (Length(m-pt0)<2)
						goto abort;
					//mat[3] = vpx->GetPointOnCP(m);
#ifdef _3D_CREATE
					mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
#else
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
#endif
					macroRec->Disable();   // JBW 4/23/99
					createInterface->SetNodeTMRelConstPlane(targNode, mat);
					macroRec->Enable();
				   	ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( camNode);
				   	ignoreSelectionChange = FALSE;
					
					createInterface->RedrawViews(createInterface->GetTime());  

				    theHold.Accept(GetString(IDS_DS_CREATE));	 

					res = FALSE;	// We're done
					break;
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
#ifdef _3D_CREATE
			mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
#else
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
#endif
			macroRec->Disable();   // JBW 4/23/99
			createInterface->SetNodeTMRelConstPlane(targNode, mat);
			macroRec->Enable();
			createInterface->RedrawViews(createInterface->GetTime());	   

			macroRec->SetProperty(camObject, _T("target"),   // JBW 4/23/99
				mr_create, Class_ID(TARGET_CLASS_ID, 0), GEOMOBJECT_CLASS_ID, 1, _T("transform"), mr_matrix3, &mat);

			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP
			//Snap Preview
			#ifdef _3D_CREATE
			vpx->SnapPreview(m,m,NULL, SNAP_IN_3D);
			#else
			vpx->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
			#endif
#endif
			break;

	    case MOUSE_PROPCLICK:
			// right click while between creations
			createInterface->RemoveMode(NULL);
			break;

		case MOUSE_ABORT:
			abort:
			assert( camObject );
			camObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
			macroRec->Cancel();  // JBW 4/23/99
			theHold.Cancel();	 // deletes both the camera and target.
			// Toss the undo stack if param changes have been made
			if (needToss) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
			camNode = NULL;			
			targNode = NULL;	 	
			createInterface->RedrawViews(createInterface->GetTime()); 
			CreateNewObject();	
			attachedToNode = FALSE;
			res = FALSE;						
		}
	
	done:
	createInterface->ReleaseViewport(vpx); 
	return res;
	}

int LACamClassDesc::BeginCreate(Interface *i)
	{
	IObjCreate *iob = i->GetIObjCreate();
	
	//iob->SetMouseProc( new LACamCreationManager(iob,this), 1000000 );

	theLACamCreateMode.Begin( iob, this );
	iob->PushCommandMode( &theLACamCreateMode );
	
	return TRUE;
	}

int LACamClassDesc::EndCreate(Interface *i)
	{
	
	theLACamCreateMode.End();
	i->RemoveMode( &theLACamCreateMode );
	macroRec->EmitScript();  // JBW 4/23/99

	return TRUE;
	}

RefTargetHandle SimpleCamera::Clone(RemapDir& remap) {
	SimpleCamera* newob = new SimpleCamera();
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->enable = enable;
	newob->hasTarget = hasTarget;
	newob->coneState = coneState;
	newob->manualClip = manualClip;
	newob->rangeDisplay = rangeDisplay;
	newob->isOrtho = isOrtho;
	return(newob);
	}

#define CAMERA_FOV_CHUNK 	0x2680
#define CAMERA_TARGET_CHUNK 0x2682
#define CAMERA_CONE_CHUNK 	0x2684
#define CAMERA_MANUAL_CLIP	0x2686
#define CAMERA_HORIZON		0x2688
#define CAMERA_RANGE_DISP	0x268a
#define CAMERA_IS_ORTHO		0x268c

// IO
IOResult SimpleCamera::Save(ISave *isave) {
		
#if 0
	ULONG nb;
	Interval valid;
	float fov;
	pblock->GetValue( 0, 0, fov, valid );
	
	isave->BeginChunk(CAMERA_FOV_CHUNK);
	isave->Write(&fov, sizeof(FLOAT), &nb);
	isave->EndChunk();
#endif

	if (hasTarget) {
		isave->BeginChunk(CAMERA_TARGET_CHUNK);
		isave->EndChunk();
		}
	if (coneState) {
		isave->BeginChunk(CAMERA_CONE_CHUNK);
		isave->EndChunk();
		}
	if (rangeDisplay) {
		isave->BeginChunk(CAMERA_RANGE_DISP);
		isave->EndChunk();
		}
	if (isOrtho) {
		isave->BeginChunk(CAMERA_IS_ORTHO);
		isave->EndChunk();
		}
	if (manualClip) {
		isave->BeginChunk(CAMERA_MANUAL_CLIP);
		isave->EndChunk();
		}
	if (horzLineState) {
		isave->BeginChunk(CAMERA_HORIZON);
		isave->EndChunk();
		}
	return IO_OK;
	}

class CameraPostLoad : public PostLoadCallback {
public:
	SimpleCamera *sc;
	Interval valid;
	CameraPostLoad(SimpleCamera *cam) { sc = cam;}
	void proc(ILoad *iload) {
		if (sc->pblock->GetVersion() != CAMERA_VERSION) {
			switch (sc->pblock->GetVersion()) {
			case 0:
				sc->ReplaceReference(0,
						UpdateParameterBlock(
							descV0, 2, sc->pblock,
							descV2, 6, CAMERA_VERSION));
				iload->SetObsolete();
				break;

			case 1:
				sc->ReplaceReference(0,
						UpdateParameterBlock(
							descV1, 4, sc->pblock,
							descV2, 6, CAMERA_VERSION));
				iload->SetObsolete();
				break;

			default:
				assert(0);
				break;
			}
		}
		waitPostLoad--;
		delete this;
	}
};

IOResult  SimpleCamera::Load(ILoad *iload) {
	IOResult res;
#if 0
	ULONG nb;
	float fov;
#endif
	enable = TRUE;
	coneState = 0;
	manualClip = 0;
	horzLineState = 0;
	rangeDisplay = 0;
	isOrtho = 0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
#if 0
			case CAMERA_FOV_CHUNK:
				res = iload->Read(&fov,sizeof(FLOAT), &nb);
				pblock->SetValue( 0, 0, fov );
				break;
#endif
			case CAMERA_TARGET_CHUNK:
				hasTarget = 1;
				break;
			case CAMERA_CONE_CHUNK:
				coneState = 1;
				break;
			case CAMERA_RANGE_DISP:
				rangeDisplay = 1;
				break;
			case CAMERA_IS_ORTHO:
				isOrtho = 1;
				break;
			case CAMERA_MANUAL_CLIP:
				manualClip = 1;
				break;
			case CAMERA_HORIZON:
				horzLineState = 1;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	waitPostLoad++;
	iload->RegisterPostLoadCallback(new CameraPostLoad(this));
	return IO_OK;
	}

#ifdef DESIGN_VER
// parallel only camera classes

#include <iparamm.h>
#include <float.h>
#include <polyshp.h>

const Class_ID PARALLEL_CAMERA_CLASS_ID(0x2bc22a1e, 0x621207d);

class ParallelCamera;

class PcamCustomPanel : public ParamMapUserDlgProc // abstract base class
{
private:
  HWND _hPanel;
  ParallelCamera *_pCam;

public:
/*  void FillCombo(const int toFill,const int numItems,const int items[],const int startItem = 0) const;
  void Disable(const int item) const {EnableWindow(GetDlgItem(_hPanel,item),FALSE);}
  void Enable(const int item) const {EnableWindow(GetDlgItem(_hPanel,item),TRUE);}
  void DisableButton(int item) const;
  void EnableButton(int item) const;*/
  void DisableEdit(int item) const;
  void EnableEdit(int item) const;
  void DisableSpinner(int item) const;
  void EnableSpinner(int item) const;

  // inherited from ParamMapUserDlgProc
  BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
	void DeleteThis() {delete this;}
  void SetCam(ParallelCamera *pc) {_pCam = pc;}
};

BOOL CALLBACK StandardPanelDlgProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

class ParallelCameraCreateCallBack : public CreateMouseCallBack // singleton pattern
{
private:
  static ParallelCameraCreateCallBack* _instance;
  ParallelCamera *_pCam;

protected:
  ParallelCameraCreateCallBack(void) {;}

public:
  static ParallelCameraCreateCallBack* Instance(void);
  ParallelCamera *GetObj(void) const {return _pCam;}

  // --- Inherited virtual methods of CreateMouseCallBack ---
  int proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat);
  void SetCam(ParallelCamera *pc) {_pCam = pc;}
};

class ParallelCamera: public GenCamera
{
  friend BOOL CALLBACK StandardPanelDlgProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
  friend int ParallelCameraCreateCallBack::proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat);
	friend BOOL PcamCustomPanel::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

private:
  static ParamBlockDescID _parameterBlock[];
  static ParamUIDesc _customPanelData[];
  static ParamVersionDesc *_versions,_curVersion;
  //  static ParamVersionDesc _versions[],_curVersion; // if more than 0 versions

  static IParamMap *_customMap;
  static PcamCustomPanel *_customPanel;

  static float _axisAngleX;
  static float _axisAngleY;
  static float _axisAngleZ;
  static float _clipNear;
  static float _clipFar;
  static bool _showSection;
  static float _height;
  static float _width;
  static float _aspect;
  static bool _showVolume;
  static float _nearEnv;
  static float _farEnv;
  static bool _showEnv;

	IObjParam *_ip;
  bool _isCreating;
  static HWND _hStandardPanel;

  IParamBlock *_pblock;
	Mesh _mesh;
	BOOL _suspendSnap;
	int _extDispFlags;		
  int _enable;
  Box3 _selBox;

	enum Fixed{FIX_ASPECT,FIX_HEIGHT,FIX_WIDTH};
	Fixed _fixed;

	// sectioning front view plane
	PolyShape _shape;
	TimeValue	_curTime;			// the current time
	Matrix3	_sliceTM_inv;		// inverse of tm
	INode* _curNode;			// the curent node being sliced
	Point3 _tmBbox[8];		// corners of an object's bbox, in slice space
	Mesh* _curMesh;			// the mesh of an object
	PolyLine _faceLines[3];		// for computing face intersection lines
	Tab<Point3>	_pointList;			// for storing up the segment list points
	bool _update;

public:
  ParallelCamera(void);
  ~ParallelCamera(void){;}

  // inherited virtual methods

  // inherited from GenCamera
  GenCamera *NewCamera(int type) {return new SimpleCamera(type);}
  void SetFOV(TimeValue t, float f);
  float GetFOV(TimeValue t, Interval& valid = Interval(0,0));
  void SetLens(TimeValue t, float f); // unipmlemented
  float GetLens(TimeValue t, Interval& valid = Interval(0,0)); // unipmlemented
  void SetTDist(TimeValue t, float f);
  float GetTDist(TimeValue t, Interval& valid = Interval(0,0));
  void SetConeState(int s);
  int GetConeState();
  void SetHorzLineState(int s){;} // no horizon by definition
  int GetHorzLineState(){return 0;} // ditto
  int GetManualClip(){return !0;} // always on
  void SetManualClip(int onOff){;} // ditto
  float GetClipDist(TimeValue t, int which, Interval &valid = Interval(0,0));
  void SetClipDist(TimeValue t, int which, float f);
  float MMtoFOV(float mm) {return 0.0f;}
  float FOVtoMM(float fov)  {return 0.0f;}
  float CurFOVtoWFOV(float cfov) {return cfov;} // always FOV_W
  float WFOVtoCurFOV(float wfov) {return wfov;} // ditto
  void SetEnvRange(TimeValue time, int which, float f);
  float GetEnvRange(TimeValue t, int which, Interval& valid = Interval(0,0));
  void SetEnvDisplay(BOOL b, int notify=TRUE);
  BOOL GetEnvDisplay(void);
  void Enable(int e) {_enable = e;}
  BOOL SetFOVControl(Control *c){return FALSE;} //!!
  Control *GetFOVControl(){return 	_pblock->GetController(0);} //!!
  void  SetFOVType(int ft) {;} // always FOV_W
  int GetFOVType() {return FOV_W;} // ditto
	int  Type() {return PARALLEL_CAMERA;}
	void SetType(int tp);

  // inherited from CameraObject
  void SetOrtho(BOOL b) {;} // true by definition
  BOOL IsOrtho() {return TRUE;} // ditto
  void RenderApertureChanged(TimeValue t){;} // parallel cam setting will override this

  // From BaseObject
	int HitTest(TimeValue t,INode* inode,int type,int crossing,int flags,IPoint2 *p,ViewExp *vpt);
	void Snap(TimeValue t,INode* inode,SnapInfo *snap,IPoint2 *p,ViewExp *vpt);
  void SetExtendedDisplay(int flags) {_extDispFlags = flags;}
	int Display(TimeValue t,INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack(void);
	void BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
  TCHAR *GetObjectName(void) {return GetString(IDS_PARALLEL_CAMERA);}
	void GetWorldBoundBox(TimeValue t,INode *mat,ViewExp* vpt,Box3& box);
	void GetLocalBoundBox(TimeValue t,INode *mat,ViewExp* vpt,Box3& box);
	void GetDeformBBox(TimeValue t,Box3& box,Matrix3 *tm,BOOL useSel);

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s) {s = GetString(IDS_DB_CAMERA);}		
	int DoOwnSelectHilite(void) {return 1;}
		
	// From Camera
	RefResult EvalCameraState(TimeValue t,Interval& valid,CameraState* cs);

	// Animatable methods
	void DeleteThis(void) {delete this;}
  Class_ID ClassID(void) {return PARALLEL_CAMERA_CLASS_ID;}
  void GetClassName(TSTR& s) {s = TSTR(GetString(IDS_PARALLEL_CAMERA_CLASS));}
		
	int NumSubs() {return 1;}  
	Animatable* SubAnim(int i) {return _pblock;}
	TSTR SubAnimName(int i) {return TSTR(GetString(IDS_RB_PARAMETERS));}

	// From ref
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	int NumRefs(void) {return 1;}
	RefTargetHandle GetReference(int i) {return _pblock;}
	void SetReference(int i, RefTargetHandle rtarg) {_pblock = (IParamBlock*)rtarg;}
	RefResult NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget,PartID& partID,RefMessage message);

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

  LRESULT CALLBACK TrackViewWinProc(HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam){return(0);}

  // NOT inherited
  IObjParam *Ip(void) const {return _ip;}
  static void Reset(void);
  void InvalidateUI(void) {if(_customMap) _customMap->Invalidate();}

  // temp
	void Set(Point3 dir,Box3 &box,TimeValue t);

private:
	void SceneGeomBoundBox(INode *node,Box3 &box);

  // viewport utilities
  void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
  void ComputeRectPoints(TimeValue t,float dist,Point3 *pts);
  int DrawWires(TimeValue t,INode *inode,GraphicsWindow *gw);
  void DrawVolume(TimeValue t,GraphicsWindow *gw,float dist,int colid,bool drawSides,bool drawDiags);
  void MakeQuad(Face *f,int a,int b,int c,int d,int sg,int dv = 0);
  void BuildMesh(void);

	// sectioning front clip plane - predominantly stolen from section & simplified
	void	TraverseWorld(INode *node,const int level,Box3& boundBox);
	void	DoMeshSlice(void);				// computes the slice thru an object's mesh
	int		CrossCheck(const Point3& pt1,	// checks that a line segment p1-p2 crosses the plane
		               const Point3& pt2,	// if so, puts cross in cross_pt	
					   Point3* cross_pt);	// returns 0 for no slice, 1 for one pt, 2 for coplanar
	void	CrossPoint(const Point3& pt1,	// same as CrossCheck, but we know the points cross the xy plane
		               const Point3& pt2, 
					   Point3* cross_pt);
	bool EqualPoint3(const Point3 p1,const Point3 p2);
	TriObject *GetTriObjectFromNode(INode *node,const TimeValue t,bool &deleteIt);
	void SliceASceneNode(void); // compute slice thru a node
	void SliceFace(Point3* t_verts, const DWORD f_index); // compute a slice trun a mesh's face
	void UpdateSlice(INode *sectionNode,const TimeValue t,const bool force = false);
	bool EqualMatrices(const Matrix3& m1,const Matrix3& m2); 
	// FLT_EPSILON from float.h: 1.192092896e-07F	- smallest such that 1.0+FLT_EPSILON != 1.0
  int Sign(float f) {return fabs(f)<=FLT_EPSILON?0:(f>0.0f?1:-1);}
};

// class descriptor, singleton pattern
class ParallelCamClassDesc : public ClassDesc
{
public:
  static ParallelCamClassDesc *Instance(void);
  //  int IsPublic() {return(GetAppID()==kAPP_VIZ?1:0);} //plug-in is for VIZ only
  int IsPublic() {return(GetAppID()==0);} //make this unavailable from the creation panel
  void *Create(BOOL loading = FALSE) {return new ParallelCamera;}
  const TCHAR	*ClassName() {return GetString(IDS_PARALLEL_CAMERA_CLASS);}
  SClass_ID	SuperClassID() {return CAMERA_CLASS_ID;}
  Class_ID ClassID() {return PARALLEL_CAMERA_CLASS_ID;}
  const TCHAR	*Category() {return _T("Standard");}
  void ResetClassParams(BOOL fileReset) {ParallelCamera::Reset();}
protected:
  ParallelCamClassDesc(void) {;}
private:
  static ParallelCamClassDesc *_instance;
};

// declare the single instance of the class descriptor.
ParallelCamClassDesc *ParallelCamClassDesc::_instance = NULL;

ParallelCamClassDesc *ParallelCamClassDesc::Instance(void)
{
  if(!_instance)
    _instance = new ParallelCamClassDesc;
  return _instance;
}

ClassDesc* GetParallelCamDesc() {return ParallelCamClassDesc::Instance();}

// parameter block indices
const int PB_PCAM_AXIS_ANGLE_X = 0;
const int PB_PCAM_AXIS_ANGLE_Y = 1;
const int PB_PCAM_AXIS_ANGLE_Z = 2;
const int PB_PCAM_CLIP_NEAR = 3;
const int PB_PCAM_CLIP_FAR = 4;
const int PB_PCAM_SHOW_SECTION = 5;
const int PB_PCAM_HEIGHT = 6;
const int PB_PCAM_WIDTH = 7;
const int PB_PCAM_ASPECT = 8;
const int PB_PCAM_SHOW_VOLUME = 9;
const int PB_PCAM_NEAR_ENV = 10;
const int PB_PCAM_FAR_ENV = 11;
const int PB_PCAM_SHOW_ENV = 12;

const int PCAM_PBLOCK_LENGTH	= 13;

const int PCAM_CURRENT_VERSION = 0;
const int PCAM_OLDVERSIONS = 0;

ParamBlockDescID ParallelCamera::_parameterBlock[] = 
{
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_AXIS_ANGLE_X},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_AXIS_ANGLE_Y},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_AXIS_ANGLE_Z},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_CLIP_NEAR},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_CLIP_FAR},
  {TYPE_BOOL,NULL,FALSE,PB_PCAM_SHOW_SECTION},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_HEIGHT},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_WIDTH},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_ASPECT},
  {TYPE_BOOL,NULL,FALSE,PB_PCAM_SHOW_VOLUME},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_NEAR_ENV},
  {TYPE_FLOAT,NULL,TRUE,PB_PCAM_FAR_ENV},
  {TYPE_BOOL,NULL,FALSE,PB_PCAM_SHOW_ENV}
};

// Array of old versions
ParamVersionDesc *ParallelCamera::_versions = NULL;
//ParamVersionDesc ParallelCamera::versions[] = {};

// Current version
ParamVersionDesc ParallelCamera::_curVersion(_parameterBlock,PCAM_PBLOCK_LENGTH,0);

static const float NINETY = 90.0f;
static const float MAX_FLT = 1.0e30f;

ParamUIDesc ParallelCamera::_customPanelData[] =
{
  ParamUIDesc(PB_PCAM_AXIS_ANGLE_X,EDITTYPE_UNIVERSE,
		IDC_PCAM_ANGLE_X,IDC_PCAM_ANGLE_X_SPINNER,
		-NINETY,NINETY,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_AXIS_ANGLE_Y,EDITTYPE_UNIVERSE,
		IDC_PCAM_ANGLE_Y,IDC_PCAM_ANGLE_Y_SPINNER,
		-NINETY,NINETY,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_AXIS_ANGLE_Z,EDITTYPE_UNIVERSE,
		IDC_PCAM_ANGLE_Z,IDC_PCAM_ANGLE_Z_SPINNER,
		-NINETY,NINETY,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_CLIP_NEAR,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_CLIP_NEAR,IDC_PCAM_CLIP_NEAR_SPINNER,
		MIN_CLIP,MAX_CLIP,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_CLIP_FAR,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_CLIP_FAR,IDC_PCAM_CLIP_FAR_SPINNER,
		MIN_CLIP,MAX_CLIP,SPIN_AUTOSCALE),
	ParamUIDesc(PB_PCAM_SHOW_SECTION,TYPE_SINGLECHEKBOX,IDC_PCAM_SHOW_SECTION),
  ParamUIDesc(PB_PCAM_HEIGHT,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_HEIGHT,IDC_PCAM_HEIGHT_SPINNER,
		0.0f,MAX_FLT,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_WIDTH,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_WIDTH,IDC_PCAM_WIDTH_SPINNER,
		0.0f,MAX_FLT,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_ASPECT,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_ASPECT,IDC_PCAM_ASPECT_SPINNER,
		0.0f,MAX_FLT,SPIN_AUTOSCALE),
	ParamUIDesc(PB_PCAM_SHOW_VOLUME,TYPE_SINGLECHEKBOX,IDC_PCAM_SHOW_VOLUME),
  ParamUIDesc(PB_PCAM_NEAR_ENV,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_NEAR_ENV,IDC_PCAM_NEAR_ENV_SPINNER,
		0.0f,MAX_FLT,SPIN_AUTOSCALE),
  ParamUIDesc(PB_PCAM_FAR_ENV,EDITTYPE_POS_UNIVERSE,
		IDC_PCAM_FAR_ENV,IDC_PCAM_FAR_ENV_SPINNER,
		0.0f,MAX_FLT,SPIN_AUTOSCALE),
	ParamUIDesc(PB_PCAM_SHOW_ENV,TYPE_SINGLECHEKBOX,IDC_PCAM_SHOW_ENV)
};

const int CUSTOM_PANEL_LENGTH = 13;

IParamMap *ParallelCamera::_customMap = NULL;
PcamCustomPanel *ParallelCamera::_customPanel = NULL;
HWND ParallelCamera::_hStandardPanel = NULL;

float ParallelCamera::_axisAngleX = 0.0f;
float ParallelCamera::_axisAngleY = 0.0f;
float ParallelCamera::_axisAngleZ = 0.0f;
float ParallelCamera::_clipNear = 1.0f;
float ParallelCamera::_clipFar = 1000.0f;
bool ParallelCamera::_showSection = false;
float ParallelCamera::_height = 100.0f;
float ParallelCamera::_width = 100.0f;
float ParallelCamera::_aspect = 1.0f;
bool ParallelCamera::_showVolume = true;
float ParallelCamera::_nearEnv = 1.0f;
float ParallelCamera::_farEnv = 1000.0f;
bool ParallelCamera::_showEnv = false;

ParallelCameraCreateCallBack *ParallelCameraCreateCallBack::_instance = NULL;

ParallelCameraCreateCallBack *ParallelCameraCreateCallBack::Instance(void)
{
  if(!_instance)
    _instance = new ParallelCameraCreateCallBack;
  return _instance;
}

int ParallelCameraCreateCallBack::proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat)
{
  Point3 p0,p1;
  Box3 box;
  
  int ret = CREATE_CONTINUE;

	if(msg == MOUSE_FREEMOVE)
    vpt->SnapPreview(m,m,NULL,SNAP_IN_3D);

	if(msg==MOUSE_POINT||msg==MOUSE_MOVE)
  {
    switch(point)
    {
    case 0:  // only happens with MOUSE_POINT msg
		{
      _pCam->_suspendSnap = TRUE;				
      p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);

			p0.z = _pCam->_selBox.Center().z;

			Point3 diff = _pCam->_selBox.Center()-p0;
			diff = Normalize(diff);
			// build a new basis matrix
			mat.SetRow(2,-diff);
			mat.SetRow(1,Point3(0.0f,0.0f,1.0f));
			mat.SetRow(0,diff^mat.GetRow(1));

      _pCam->Set(Normalize(-p0),(_pCam->_selBox)*Inverse(mat),_pCam->Ip()->GetTime());

			mat.SetTrans(p0);

      if(msg==MOUSE_POINT)
      {
        _pCam->_suspendSnap = FALSE;
        ret = CREATE_STOP;
      }
      _pCam->InvalidateUI();

      break;
    }
		case 1:
			/*p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
			Point3 diff = p1-p0;
			diff = Normalize(diff);
			// build a new basis matrix
			mat.SetRow(0,diff);
			mat.SetRow(1,diff^mat.GetRow(2));
			_pCam->InvalidateUI();*/
      break;
    default:
      ret = CREATE_ABORT;
      break;
    }
  }

	else if(msg == MOUSE_ABORT)
		ret = CREATE_ABORT;
  return ret;
}





void ParallelCamera::Set(Point3 dir,Box3 &box,TimeValue t)
{
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_X,t,(float)RadToDeg(acos(dir.x)));
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_Y,t,(float)RadToDeg(acos(dir.y)));
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_Z,t,(float)RadToDeg(acos(dir.z)));

	float width = box.pmax.x-box.pmin.x,height = box.pmax.y-box.pmin.y;
  _pblock->SetValue(PB_PCAM_HEIGHT,t,height);
  _pblock->SetValue(PB_PCAM_WIDTH,t,width);
  _pblock->SetValue(PB_PCAM_ASPECT,t,width/height);

  //_pblock->SetValue(PB_PCAM_CLIP_NEAR,t,);
  //_pblock->SetValue(PB_PCAM_CLIP_FAR,t,);
}





ParallelCamera::ParallelCamera(void)
{
  // Create the parameter block and make a reference to it
  MakeRefByID(FOREVER,0,_pblock = CreateParameterBlock(_parameterBlock,PCAM_PBLOCK_LENGTH,PCAM_CURRENT_VERSION));
  assert(_pblock);
  // initial values
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_X,0,_axisAngleX);
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_Y,0,_axisAngleY);
  _pblock->SetValue(PB_PCAM_AXIS_ANGLE_Z,0,_axisAngleZ);
  _pblock->SetValue(PB_PCAM_CLIP_NEAR,0,_clipNear);
  _pblock->SetValue(PB_PCAM_CLIP_FAR,0,_clipFar);
  _pblock->SetValue(PB_PCAM_SHOW_SECTION,0,_showSection);
  _pblock->SetValue(PB_PCAM_HEIGHT,0,_height);
  _pblock->SetValue(PB_PCAM_WIDTH,0,_width);
  _pblock->SetValue(PB_PCAM_ASPECT,0,_aspect);
  _pblock->SetValue(PB_PCAM_SHOW_VOLUME,0,_showVolume);
  _pblock->SetValue(PB_PCAM_NEAR_ENV,0,_nearEnv);
  _pblock->SetValue(PB_PCAM_FAR_ENV,0,_farEnv);
  _pblock->SetValue(PB_PCAM_SHOW_ENV,0,_showEnv);

  BuildMesh(); // for the display

	// used for construction face slices
	_faceLines[0].SetNumPts(2,FALSE);
	_faceLines[1].SetNumPts(2,FALSE);
	_faceLines[2].SetNumPts(2,FALSE);

	_curTime = TimeValue(0);
	_curNode = NULL;
	_curMesh = NULL;
	_update = false;

	_fixed = FIX_ASPECT; // initially aspect is fixed
}

void ParallelCamera::Reset(void)
{
  _axisAngleX = 0.0f;
  _axisAngleY = 0.0f;
  _axisAngleZ = 0.0f;
  _clipNear = 1.0f;
  _clipFar = 1000.0f;
  _showSection = false;
  _height = 100.0f;
  _width = 100.0f;
  _aspect = 1.0f;
  _showVolume = true;
  _nearEnv = 1.0f;
  _farEnv = 1000.0f;
  _showEnv = false;
}

void ParallelCamera::SetFOV(TimeValue t,float fov)
{
  Interval valid;
  float front;
  _pblock->GetValue(PB_PCAM_CLIP_NEAR,t,front,valid);
  _pblock->SetValue(PB_PCAM_WIDTH,t,float(tan(fov*0.5)*2.0*front));
}

float ParallelCamera::GetFOV(TimeValue t,Interval& valid)
 {	
  float front,width;
  _pblock->GetValue(PB_PCAM_CLIP_NEAR,t,front,valid);
	_pblock->GetValue(PB_PCAM_WIDTH,t,width,valid);
	float fov = float(2.0f*atan(0.5f*width/front));
	if(fov < 0.0f)
    fov = 0.0f;
  return fov;
}

void ParallelCamera::SetTDist(TimeValue t,float f)
{
	_pblock->SetValue(PB_PCAM_CLIP_NEAR,t,f);
}

float ParallelCamera::GetTDist(TimeValue t,Interval& valid)
 {	
	float f;
	_pblock->GetValue(PB_PCAM_CLIP_NEAR,t,f,valid);
	if(f < MIN_CLIP)
    f = MIN_CLIP;
	if(f > MAX_CLIP)
    f = MAX_CLIP;
	return f;
}

void ParallelCamera::SetClipDist(TimeValue t,int which,float f)
{
	_pblock->SetValue(PB_PCAM_CLIP_NEAR+which-1,t,f);
}

float ParallelCamera::GetClipDist(TimeValue t,int which,Interval &valid)
{
	float f;
	_pblock->GetValue(PB_PCAM_CLIP_NEAR+which-1,t,f,valid);
	if(f < MIN_CLIP)
    f = MIN_CLIP;
	if(f > MAX_CLIP)
    f = MAX_CLIP;
	return f;
}

float ParallelCamera::GetEnvRange(TimeValue t,int which,Interval &valid)
{
	float f;
	_pblock->GetValue(PB_PCAM_NEAR_ENV+which,t,f,valid);
	return f;
}

void ParallelCamera::SetEnvRange(TimeValue t,int which,float f)
{
	_pblock->SetValue(PB_PCAM_NEAR_ENV+which,t,f);
}

BOOL ParallelCamera::GetEnvDisplay(void)
{
	int b;
  Interval valid;
	_pblock->GetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),b,valid);
	return b;
}

void ParallelCamera::SetEnvDisplay(BOOL b,int notify)
{
	_pblock->SetValue(PB_PCAM_SHOW_ENV,TimeValue(0),b);
}

int ParallelCamera::GetConeState(void)
{
	int s;
  Interval valid;
	_pblock->GetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),s,valid);
	return s;
}

void ParallelCamera::SetConeState(int s)
{
	_pblock->SetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),s);
}

void ParallelCamera::SceneGeomBoundBox(INode *node,Box3 &box)
{
	// find this node's box
	Box3 dBox;
	Interval valid;
	ObjectState os = node->EvalWorldState(_ip->GetTime(),FALSE);
	if(os.obj && os.obj->SuperClassID() == GEOMOBJECT_CLASS_ID)
	{
		Matrix3	m = node->GetObjectTM(_ip->GetTime(),&valid);
		os.obj->GetDeformBBox(_ip->GetTime(),dBox,&m);
	
		// add it to the running sum
		box += dBox;
	}

  for(int c = 0;c<node->NumberOfChildren();c++)
	{
		// now add in the children's boxes
		SceneGeomBoundBox(node->GetChildNode(c),box);
	}
}

void ParallelCamera::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
{
	_ip = ip;
	_isCreating = (flags&BEGIN_EDIT_CREATE)?true:false;

  // save the size of the current selection bounding box
  _selBox.Init();
  _ip->GetSelectionWorldBox(_ip->GetTime(),_selBox);

	// if empty use the entire scene
	if(_selBox.IsEmpty())
		SceneGeomBoundBox(_ip->GetRootNode(),_selBox);

  if(_customMap) // left over from last time
  {
    SetWindowLong(_hStandardPanel,GWL_USERDATA,(LONG)this);
    _customMap->SetParamBlock(_pblock);
		_customPanel->SetCam(this);
  }
  else
  {
		// make new ones
    _hStandardPanel = ip->AddRollupPage(hInstance,MAKEINTRESOURCE(IDD_PCAM_STANDARD),StandardPanelDlgProc,
                                        GetString(IDS_PCAM_STANDARD_GROUP),(LPARAM)this,_isCreating?0:APPENDROLL_CLOSED);
    ip->RegisterDlgWnd(_hStandardPanel);    

    _customMap = CreateCPParamMap(_customPanelData,CUSTOM_PANEL_LENGTH,
      _pblock,ip,hInstance,
      MAKEINTRESOURCE(IDD_PCAM_CUSTOM),
      GetString(IDS_PCAM_CUSTOM_GROUP),_isCreating?APPENDROLL_CLOSED:0);

    if(_customMap)
		{
      _customMap->SetUserDlgProc(_customPanel = new PcamCustomPanel());
			_customPanel->SetCam(this);
		}
  } 
}

void ParallelCamera::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{		
	_ip = NULL;

	if(flags&END_EDIT_REMOVEUI)
  {
		// Remove the rollup pages from the command panel
    // which in turn deletes the idividual panels
		if(_customMap)
    {
      DestroyCPParamMap(_customMap);
    }
	  if(_hStandardPanel)
    {
      ip->UnRegisterDlgWnd(_hStandardPanel);
      ip->DeleteRollupPage(_hStandardPanel);
    }
    _customMap = NULL;
		_customPanel = NULL;
    _hStandardPanel = NULL;
	}
  else
		SetWindowLong(_hStandardPanel,GWL_USERDATA,0);

	// Save these values in static variables so the next object created will inherit them.
//  _pblock->GetValue(PB_PCAM_AXIS_ANGLE_X,ip->GetTime(),_axisAngleX,FOREVER);
//  _pblock->GetValue(PB_PCAM_AXIS_ANGLE_Y,ip->GetTime(),_axisAngleY,FOREVER);
//  _pblock->GetValue(PB_PCAM_AXIS_ANGLE_Z,ip->GetTime(),_axisAngleZ,FOREVER);
  _pblock->GetValue(PB_PCAM_CLIP_NEAR,ip->GetTime(),_clipNear,FOREVER);
  _pblock->GetValue(PB_PCAM_CLIP_FAR,ip->GetTime(),_clipFar,FOREVER);
  _pblock->GetValue(PB_PCAM_SHOW_SECTION,ip->GetTime(),(int&)_showSection,FOREVER);
//  _pblock->GetValue(PB_PCAM_HEIGHT,ip->GetTime(),_height,FOREVER);
//  _pblock->GetValue(PB_PCAM_WIDTH,ip->GetTime(),_width,FOREVER);
//  _pblock->GetValue(PB_PCAM_ASPECT,ip->GetTime(),_aspect,FOREVER);
  _pblock->GetValue(PB_PCAM_SHOW_VOLUME,ip->GetTime(),(int&)_showVolume,FOREVER);
  _pblock->GetValue(PB_PCAM_NEAR_ENV,ip->GetTime(),_nearEnv,FOREVER);
  _pblock->GetValue(PB_PCAM_FAR_ENV,ip->GetTime(),_farEnv,FOREVER);
  _pblock->GetValue(PB_PCAM_SHOW_ENV,ip->GetTime(),(int&)_showEnv,FOREVER);
}

void ParallelCamera::SetType(int tp)
{
  return;
}

int ParallelCamera::HitTest(TimeValue t,INode* inode,int type,int crossing,int flags,IPoint2 *p,ViewExp *vpt)
{
	HitRegion hitRegion;
	DWORD	savedLimits;
	int res;
	Matrix3 m;

	if(!_enable)
    return  0;

	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	gw->clearHitCode();
	
  res = _mesh.select(gw,gw->getMaterial(),&hitRegion,flags & HIT_ABORTONHIT); 

	if(!res)
  {
    gw->clearHitCode();
    Matrix3 tm = inode->GetObjectTM(t);
    gw->setTransform(tm);
		if(res = DrawWires(t,inode,gw))
			inode->SetTargetNodePair(1);
	}
	
  gw->setRndLimits(savedLimits);
	
  return res;
}

void ParallelCamera::Snap(TimeValue t,INode* inode,SnapInfo *snap,IPoint2 *p,ViewExp *vpt)
{ // stolen from simple camera
	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority)
  {
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();	
   	
		gw->setTransform(tm);

		Point2 fp = Point2((float)p->x,(float)p->y);
		IPoint3 screen3;
		Point2 screen2;
		Point3 vert(0.0f,0.0f,0.0f);

		gw->wTransPoint(&vert,&screen3);

		screen2.x = (float)screen3.x;
		screen2.y = (float)screen3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2-fp);
		if(len <= snap->strength)
    {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority)
      {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert*tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			else // Closer than the best of this priority?
			if(len < snap->bestDist)
      {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert*tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
      }
    }
  }
}

void ParallelCamera::GetLocalBoundBox(TimeValue t,INode* inode,ViewExp* vpt,Box3& box)
{
	Matrix3 m = inode->GetObjectTM(t);
	Point3 pt;
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(m.GetTrans())/(float)360.0;
	box = _mesh.getBoundingBox();
	box.Scale(scaleFactor);
	Point3 q[4];

  // the camera volume
  Interval valid;
  int showVolume;
  _pblock->GetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),showVolume,valid);
	if(showVolume || (_extDispFlags & EXT_DISP_ONLY_SELECTED))
  {
    ComputeRectPoints(t,0.0f,q);
    box.IncludePoints(q,4);
		ComputeRectPoints(t,max(GetClipDist(t,CAM_HITHER_CLIP),GetClipDist(t,CAM_YON_CLIP)),q);
		box.IncludePoints(q,4);
  }

  // the environment range
  int showEnv;
  _pblock->GetValue(PB_PCAM_SHOW_ENV,TimeValue(0),showEnv,valid);
	if(showEnv)
  {
		ComputeRectPoints(t,max(GetEnvRange(t,ENV_NEAR_RANGE),GetEnvRange(t,ENV_FAR_RANGE)),q);
		box.IncludePoints(q,4);
	}
}

void ParallelCamera::GetWorldBoundBox(TimeValue t,INode* inode,ViewExp* vpt,Box3& box)
{
	Matrix3 tm;
	Point3 q[4];
  
  box.Init();

  // the camera itself
  GetMat(t,inode,vpt,tm);
	int nv = _mesh.getNumVerts();

  if(!(_extDispFlags & EXT_DISP_ZOOM_EXT))
  {
    for(int i=0; i<nv; i++) 
			box += tm*_mesh.getVert(i);
  }
	else
		box += tm.GetTrans();

	tm = inode->GetObjectTM(t);

  // the camera volume
  Interval valid;
  int showVolume;
  _pblock->GetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),showVolume,valid);
	if(showVolume || (_extDispFlags & EXT_DISP_ONLY_SELECTED))
  {
    ComputeRectPoints(t,0.0f,q);
    box.IncludePoints(q,4,&tm);
		ComputeRectPoints(t,max(GetClipDist(t,CAM_HITHER_CLIP),GetClipDist(t,CAM_YON_CLIP)),q);
		box.IncludePoints(q,4,&tm);
  }

  // the environment range
  int showEnv;
  _pblock->GetValue(PB_PCAM_SHOW_ENV,TimeValue(0),showEnv,valid);
	if(showEnv)
  {
		ComputeRectPoints(t,max(GetEnvRange(t,ENV_NEAR_RANGE),GetEnvRange(t,ENV_FAR_RANGE)),q);
		box.IncludePoints(q,4,&tm);
	}
}

void ParallelCamera::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{ // stolen from simple camera - used to keep constant sizes despite viewport zoom changes
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scale = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	if(scale != 1.0f)
		tm.Scale(Point3(scale,scale,scale));
}

void ParallelCamera::MakeQuad(Face *f,int a,int b,int c,int d,int sg,int dv)
{ // stolen from simple camera
	f[0].setVerts(a+dv,b+dv,c+dv);
	f[0].setSmGroup(sg);
	f[0].setEdgeVisFlags(1,1,0);
	f[1].setVerts(c+dv,d+dv,a+dv);
	f[1].setSmGroup(sg);
	f[1].setEdgeVisFlags(1,1,0);
}

void ParallelCamera::BuildMesh(void)
{ // stolen from simple camera
	int nverts = 16;
	int nfaces = 24;
	_mesh.setNumVerts(nverts);
	_mesh.setNumFaces(nfaces);
	float len = (float)5.0;
	float w = (float)8.0;
	float d = w*(float).8;
	float e = d*(float).5;
	float f = d*(float).8;
	float l = w*(float).8;

	_mesh.setVert(0,Point3(-d,-d,-len));
	_mesh.setVert(1,Point3( d,-d,-len));
	_mesh.setVert(2,Point3(-d, d,-len));
	_mesh.setVert(3,Point3( d, d,-len));
	_mesh.setVert(4,Point3(-d,-d, len));
	_mesh.setVert(5,Point3( d,-d, len));
	_mesh.setVert(6,Point3(-d, d, len));
	_mesh.setVert(7,Point3( d, d, len));
	MakeQuad(&(_mesh.faces[ 0]),0,2,3,1, 1);
	MakeQuad(&(_mesh.faces[ 2]),2,0,4,6, 2);
	MakeQuad(&(_mesh.faces[ 4]),3,2,6,7, 4);
	MakeQuad(&(_mesh.faces[ 6]),1,3,7,5, 8);
	MakeQuad(&(_mesh.faces[ 8]),0,1,5,4,16);
	MakeQuad(&(_mesh.faces[10]),4,5,7,6,32);
	
	_mesh.setVert(8+0,Point3(-e,-e,len));
	_mesh.setVert(8+1,Point3( e,-e,len));
	_mesh.setVert(8+2,Point3(-e, e,len));
	_mesh.setVert(8+3,Point3( e, e,len));
	_mesh.setVert(8+4,Point3(-f,-f,len+l));
	_mesh.setVert(8+5,Point3( f,-f,len+l));
	_mesh.setVert(8+6,Point3(-f, f,len+l));
	_mesh.setVert(8+7,Point3( f, f,len+l));

	Face* fbase = &_mesh.faces[12];
	MakeQuad(&fbase[0], 0,2,3,1,  1,8);
	MakeQuad(&fbase[2], 2,0,4,6,  2,8);
	MakeQuad(&fbase[4], 3,2,6,7,  4,8);
	MakeQuad(&fbase[6], 1,3,7,5,  8,8);
	MakeQuad(&fbase[8], 0,1,5,4, 16,8);
	MakeQuad(&fbase[10],4,5,7,6, 32,8);

	// whoops- rotate 180 about x to get it facing the right way
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.RotateX(DegToRad(180.0));
	for (int i=0;i<nverts;i++)
		_mesh.getVert(i) = mat*_mesh.getVert(i);
	_mesh.buildNormals();
	_mesh.EnableEdgeList(1);
	}

void ParallelCamera::ComputeRectPoints(TimeValue t,float dist,Point3 *pts)
{
  // a cross section of the volume
  Interval valid;
  float w,h;
  _pblock->GetValue(PB_PCAM_WIDTH,t,w,valid);
  _pblock->GetValue(PB_PCAM_HEIGHT,t,h,valid);

  // halve since centred
  w *= 0.5f;
  h *= 0.5f;
  
  // quadrilateral
	pts[0] = Point3( w, h,-dist);				
	pts[1] = Point3(-w, h,-dist);				
	pts[2] = Point3(-w,-h,-dist);				
	pts[3] = Point3( w,-h,-dist);				
}

void ParallelCamera::DrawVolume(TimeValue t,GraphicsWindow *gw,float dist,int colid,bool drawSides,bool drawDiags)
{
	Point3 pts[4],tmp[2];

  ComputeRectPoints(t,dist,pts);

  // set the colour
  if(colid)
    gw->setColor(LINE_COLOR,GetUIColor(colid));

  // diagonals if desired
  if(drawDiags)
  {
    tmp[0] = pts[0];
    tmp[1] = pts[2];	
		gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);	
		tmp[0] = pts[1];
    tmp[1] = pts[3];	
		gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);	
	}

  // draw the quad
	gw->polyline(4,pts,NULL,NULL,TRUE,NULL);	

  // sides of volume (always camera colour)
  if(drawSides)
  {
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_CAMERA_CONE));
		for(int i=0;i<4;i++)
    {
			tmp[0] = pts[i];	
			tmp[1] = pts[i];
      tmp[1].z = 0.0f;
			gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);	
    }
	}
}

int ParallelCamera::DrawWires(TimeValue t,INode *inode,GraphicsWindow *gw)
{
    Interval valid;
    int showVolume,showSection;
    _pblock->GetValue(PB_PCAM_SHOW_VOLUME,TimeValue(0),showVolume,valid);
    _pblock->GetValue(PB_PCAM_SHOW_SECTION,TimeValue(0),showSection,valid);

    // the camera volume
		if(showVolume || (_extDispFlags & EXT_DISP_ONLY_SELECTED))
    {
			DrawVolume(t,gw,0.0f,COLOR_CAMERA_CONE,false,true);
			DrawVolume(t,gw,GetClipDist(t,CAM_HITHER_CLIP),COLOR_CAMERA_CLIP,false,!bool(showSection&1));
			DrawVolume(t,gw,GetClipDist(t,CAM_YON_CLIP),COLOR_CAMERA_CLIP,true,true);
    }

    // the front clip section
		if(showSection)
		{
			//  Make sure the slice is up to date.
			UpdateSlice(inode,t,_update);
			_update = false;

			// draw the slice with the right color
			gw->setColor(LINE_COLOR,GetUIColor(COLOR_CAMERA_CLIP));
			//			_shape.Render(gw,gw->getMaterial(),NULL,COMP_ALL);  //commented out since this stopped compiling. mdl 3/8/99
			//(flags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL,COMP_ALL|(inode->Selected()?COMP_OBJSELECTED:0));	
		}

    // the environment range
    int showEnv;
    _pblock->GetValue(PB_PCAM_SHOW_ENV,TimeValue(0),showEnv,valid);
    if(showEnv)
    {
      int cnear = 0;
      int cfar = 0;
      if(!inode->IsFrozen())
      { 
        cnear = COLOR_NEAR_RANGE;
        cfar = COLOR_FAR_RANGE;
      }
      DrawVolume(t,gw,GetEnvRange(t,ENV_NEAR_RANGE),cnear,false,false);
      DrawVolume(t,gw,GetEnvRange(t,ENV_FAR_RANGE),cfar,true,false);
    }

    return gw->checkHitCode();
}

int ParallelCamera::Display(TimeValue t,INode* inode,ViewExp *vpt,int flags)
{
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	if(_enable)
  {
    // a matrix that is viewport scale independent
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);

    // save the current rendering settings, then set to wireframe
    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);

    // set an appropriate line colour
    if(inode->Selected())
      gw->setColor(LINE_COLOR,GetSelColor());
    else
    {
      if(!inode->IsFrozen())
        gw->setColor(LINE_COLOR,GetUIColor(COLOR_CAMERA_OBJ));
    }

    // draw the camera itself
    _mesh.render(gw,gw->getMaterial(),NULL,COMP_ALL);	

    // a matrix that scales with the viewport
    Matrix3 tm = inode->GetObjectTM(t);
    gw->setTransform(tm);

    DrawWires(t,inode,gw);

    // restore the rendering settings saved previously
	  gw->setRndLimits(rlim);
  }
  return 0;
}

CreateMouseCallBack* ParallelCamera::GetCreateMouseCallBack() 
{
  ParallelCameraCreateCallBack::Instance()->SetCam(this);
	return(ParallelCameraCreateCallBack::Instance());
}

void ParallelCamera::GetDeformBBox(TimeValue t,Box3& box,Matrix3 *tm,BOOL useSel)
{
//	box = mesh.getBoundingBox(tm);
}

ObjectState ParallelCamera::Eval(TimeValue time)
{
	return ObjectState(this);
}

RefResult ParallelCamera::EvalCameraState(TimeValue t,Interval& valid,CameraState* cs)
{
	cs->isOrtho = true;	
	cs->fov = GetFOV(t,valid);
	cs->tdist = GetTDist(t,valid);
	cs->horzLine = false;
	cs->manualClip = true;
	cs->hither = GetClipDist(t,CAM_HITHER_CLIP,valid);
	cs->yon = GetClipDist(t,CAM_YON_CLIP,valid);
	cs->nearRange = GetEnvRange(t,ENV_NEAR_RANGE,valid);
	cs->farRange = GetEnvRange(t,ENV_FAR_RANGE,valid);
  return REF_SUCCEED;
}

IOResult ParallelCamera::Load(ILoad *iload) 
{
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the file being loaded.
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(_versions,PCAM_OLDVERSIONS,&_curVersion,this,0));
  
	return IO_OK;
}

IOResult ParallelCamera::Save(ISave *isave)
{
 	return IO_OK;
}

RefTargetHandle ParallelCamera::Clone(RemapDir& remap)
{
	ParallelCamera* newob = new ParallelCamera();
	newob->ReplaceReference(0,_pblock->Clone(remap));	
	newob->_enable = _enable;
	return(newob);
}

RefResult ParallelCamera::NotifyRefChanged(Interval changeInt,RefTargetHandle hTarget,PartID& partID,RefMessage message) 
{
  switch(message)
  {		
	case REFMSG_GET_PARAM_DIM:
    {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch(gpd->index)
			{
			case PB_PCAM_AXIS_ANGLE_X:
			case PB_PCAM_AXIS_ANGLE_Y:
			case PB_PCAM_AXIS_ANGLE_Z:
				gpd->dim = stdAngleDim;
				break;				
			case PB_PCAM_CLIP_NEAR:
			case PB_PCAM_CLIP_FAR:
			case PB_PCAM_HEIGHT:
			case PB_PCAM_WIDTH:
			case PB_PCAM_ASPECT:
			case PB_PCAM_NEAR_ENV:
			case PB_PCAM_FAR_ENV:
				gpd->dim = stdWorldDim;
				break;				
			}
			return REF_STOP; 
		}
		    
    case REFMSG_GET_PARAM_NAME:
      {
        GetParamName *gpn = (GetParamName*)partID;
        switch(gpn->index)
        {
        case PB_PCAM_AXIS_ANGLE_X:
          gpn->name = TSTR(GetString(IDS_PCAM_AXIS_ANGLE_X));
          break;
        case PB_PCAM_AXIS_ANGLE_Y:
          gpn->name = TSTR(GetString(IDS_PCAM_AXIS_ANGLE_Y));
          break;
        case PB_PCAM_AXIS_ANGLE_Z:
          gpn->name = TSTR(GetString(IDS_PCAM_AXIS_ANGLE_Z));
          break;
        case PB_PCAM_HEIGHT:
          gpn->name = TSTR(GetString(IDS_PCAM_HEIGHT));
          break;
        case PB_PCAM_WIDTH:
          gpn->name = TSTR(GetString(IDS_PCAM_WIDTH));
          break;
        case PB_PCAM_ASPECT:
          gpn->name = TSTR(GetString(IDS_PCAM_ASPECT));
          break;
        case PB_PCAM_CLIP_NEAR:
          gpn->name = TSTR(GetString(IDS_RB_NEARPLANE));
          break;												
        case PB_PCAM_CLIP_FAR:
          gpn->name = TSTR(GetString(IDS_RB_FARPLANE));
          break;												
        case PB_PCAM_NEAR_ENV:
          gpn->name = TSTR(GetString(IDS_DB_NRANGE));
          break;												
        case PB_PCAM_FAR_ENV:
          gpn->name = TSTR(GetString(IDS_DB_FRANGE));
          break;												
        }
        return REF_STOP; 
      }
		}
  return(REF_SUCCEED);
}

static BOOL CALLBACK StandardPanelDlgProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
  ICustButton *btn = NULL;
	Matrix3 tm(true);
	bool buttonMsg;
	ParallelCamera *pCam = NULL;

  switch(msg)
  {
  case WM_INITDIALOG:
    // create button tops
    btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_UPDATE));
    if(btn)
    {
      btn->SetTooltip(TRUE,GetString(IDS_SECTION_UPDATE));
      ReleaseICustButton(btn);
    }
		pCam = (ParallelCamera*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,(LONG)pCam);
		break;
  case WM_COMMAND:
		buttonMsg = true;
    switch(LOWORD(wParam))
    {
    case IDC_PCAM_PLAN:
			tm.SetRow(0,Point3(1.0f,0.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,1.0f,0.0f));
			tm.SetRow(2,Point3(0.0f,0.0f,1.0f));
			break;
    case IDC_PCAM_BOTTOM:
			tm.SetRow(0,Point3(1.0f,0.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,-1.0f,0.0f));
			tm.SetRow(2,Point3(0.0f,0.0f,-1.0f));
      break;
    case IDC_PCAM_LEFT:
			tm.SetRow(0,Point3(0.0f,-1.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,0.0f,1.0f));
			tm.SetRow(2,Point3(-1.0f,0.0f,0.0f));
      break;
    case IDC_PCAM_RIGHT:
			tm.SetRow(0,Point3(0.0f,1.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,0.0f,1.0f));
			tm.SetRow(2,Point3(1.0f,0.0f,0.0f));
      break;
    case IDC_PCAM_FRONT:
			tm.SetRow(0,Point3(1.0f,0.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,0.0f,1.0f));
			tm.SetRow(2,Point3(0.0f,-1.0f,0.0f));
      break;
    case IDC_PCAM_BACK:
			tm.SetRow(0,Point3(-1.0f,0.0f,0.0f));
			tm.SetRow(1,Point3(0.0f,0.0f,1.0f));
			tm.SetRow(2,Point3(0.0f,1.0f,0.0f));
      break;
    case IDC_PCAM_QUADRANT1:
			tm.SetRow(0,Normalize(Point3(1.0f,-1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(1.0f,1.0f,1.0f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    case IDC_PCAM_QUADRANT2:
			tm.SetRow(0,Normalize(Point3(-1.0f,-1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(-1.0f,1.0f,1.0f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    case IDC_PCAM_QUADRANT3:
			tm.SetRow(0,Normalize(Point3(1.0f,-1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(-1.0f,-1.0f,1.0f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    case IDC_PCAM_QUADRANT4:
			tm.SetRow(0,Normalize(Point3(1.0f,1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(1.0f,-1.0f,1.0f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    case IDC_PCAM_DIMETRIC15:
			tm.SetRow(0,Normalize(Point3(1.0f,1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(1.0f,-1.0f,0.5f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    case IDC_PCAM_DIMETRIC45:
			tm.SetRow(0,Normalize(Point3(1.0f,1.0f,0.0f)));
			tm.SetRow(2,Normalize(Point3(1.0f,-1.0f,2.0f)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
      break;
    default:
			buttonMsg = false;
      break;
    }
		if(buttonMsg)
		{
			pCam = (ParallelCamera*)GetWindowLong(hWnd,GWL_USERDATA); // retrieve current
			TimeValue t = pCam->_ip?pCam->_ip->GetTime():GetCOREInterface()->GetTime();
			Box3 box = (pCam->_selBox)*Inverse(tm);

			float width = box.pmax.x-box.pmin.x,height = box.pmax.y-box.pmin.y;
			pCam->_pblock->SetValue(PB_PCAM_HEIGHT,t,height);
			pCam->_pblock->SetValue(PB_PCAM_WIDTH,t,width);
			pCam->_pblock->SetValue(PB_PCAM_ASPECT,t,width/height);

			tm.SetTrans(box.Center()*tm+(tm.GetRow(2)*(box.pmax.z-box.pmin.z)));
			pCam->_ip->NonMouseCreate(tm);
			pCam->_suspendSnap = FALSE;
			return TRUE;
		}			
	default:
    break;
  }
  return TRUE;
}

void PcamCustomPanel::DisableEdit(const int item) const
{
  ICustEdit *edit = GetICustEdit(GetDlgItem(_hPanel,item));
  if(edit)
  {
    edit->Disable();
    ReleaseICustEdit(edit);
  }
}

void PcamCustomPanel::EnableEdit(const int item) const
{
  ICustEdit *edit = GetICustEdit(GetDlgItem(_hPanel,item));
  if(edit)
  {
    edit->Enable();
    ReleaseICustEdit(edit);
  }
}

void PcamCustomPanel::DisableSpinner(const int item) const
{
  ISpinnerControl *spin = GetISpinner(GetDlgItem(_hPanel,item));
  if(spin)
  {
    spin->Disable();
    ReleaseISpinner(spin);
  }
}

void PcamCustomPanel::EnableSpinner(const int item) const
{
  ISpinnerControl *spin = GetISpinner(GetDlgItem(_hPanel,item));
  if(spin)
  {
    spin->Enable();
    ReleaseISpinner(spin);
  }
}

BOOL PcamCustomPanel::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
  ICustButton *btn = NULL;
  HIMAGELIST hList;
  HBITMAP	hBMP;

  switch(msg)
  {
  case WM_INITDIALOG:
		// create button tops
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_LOCK_X2Z));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_LOCK_SEPERATED));
      hList = ImageList_Create(16,32,ILC_COLORDDB,2,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,16,32);
      btn->SetTooltip(TRUE,GetString(IDS_LOCK_X2Z));
      ReleaseICustButton(btn);
    }
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_LOCK_X2Y));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_LOCK_ADJACENT));
      hList = ImageList_Create(16,15,ILC_COLORDDB,2,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,16,15);
      btn->SetTooltip(TRUE,GetString(IDS_LOCK_X2Y));
      ReleaseICustButton(btn);
    }
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_LOCK_Y2Z));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_LOCK_ADJACENT));
      hList = ImageList_Create(16,15,ILC_COLORDDB,2,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,16,15);
      btn->SetTooltip(TRUE,GetString(IDS_LOCK_Y2Z));
      ReleaseICustButton(btn);
    }
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_HEIGHT));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PUSHPIN));
      hList = ImageList_Create(12,11,ILC_COLORDDB,4,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,12,12);
      btn->SetTooltip(TRUE,GetString(IDS_PCAM_FIX_HEIGHT));
			btn->SetType(CBT_CHECK);
      ReleaseICustButton(btn);
    }
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_WIDTH));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PUSHPIN));
      hList = ImageList_Create(12,11,ILC_COLORDDB,4,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,12,12);
      btn->SetTooltip(TRUE,GetString(IDS_PCAM_FIX_WIDTH));
			btn->SetType(CBT_CHECK);
      ReleaseICustButton(btn);
    }
		btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_ASPECT));
		if(btn)
    {
      hBMP = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PUSHPIN));
      hList = ImageList_Create(12,11,ILC_COLORDDB,4,0);
      ImageList_Add(hList,hBMP,NULL);
      DeleteObject(hBMP);
      btn->SetImage(hList,0,1,0,0,12,12);
      btn->SetTooltip(TRUE,GetString(IDS_PCAM_FIX_ASPECT));
			btn->SetType(CBT_CHECK);
			btn->SetCheck(TRUE); // initially aspect is fixed
      ReleaseICustButton(btn);
    }
		_hPanel = hWnd;

		// initially aspect is fixed
		DisableEdit(IDC_PCAM_ASPECT);
		DisableSpinner(IDC_PCAM_ASPECT_SPINNER);
    break;
	case CC_SPINNER_CHANGE: 
		{
			ISpinnerControl *widthSpin = GetISpinner(GetDlgItem(_hPanel,IDC_PCAM_WIDTH_SPINNER));
			ISpinnerControl *heightSpin = GetISpinner(GetDlgItem(_hPanel,IDC_PCAM_HEIGHT_SPINNER));
			ISpinnerControl *aspectSpin = GetISpinner(GetDlgItem(_hPanel,IDC_PCAM_ASPECT_SPINNER));
			switch(LOWORD(wParam))
			{
			case IDC_PCAM_WIDTH_SPINNER:
				if(_pCam->_fixed == ParallelCamera::FIX_ASPECT)
				{
					float height = widthSpin->GetFVal()/aspectSpin->GetFVal();
					heightSpin->SetValue(height,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_HEIGHT,t,height);
				}
				else // _fixed == FIX_HEIGHT
				{
					float aspect = widthSpin->GetFVal()/heightSpin->GetFVal();
					aspectSpin->SetValue(aspect,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_ASPECT,t,aspect);
				}
				break;
			case IDC_PCAM_HEIGHT_SPINNER:
				if(_pCam->_fixed == ParallelCamera::FIX_ASPECT)
				{
					float width = heightSpin->GetFVal()*aspectSpin->GetFVal();
					widthSpin->SetValue(width,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_WIDTH,t,width);
				}
				else // _fixed == FIX_WIDTH
				{
					float aspect = widthSpin->GetFVal()/heightSpin->GetFVal();
					aspectSpin->SetValue(aspect,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_ASPECT,t,aspect);
				}
				break;
			case IDC_PCAM_ASPECT_SPINNER:
				if(_pCam->_fixed == ParallelCamera::FIX_WIDTH)
				{
					float height = widthSpin->GetFVal()/aspectSpin->GetFVal();
					heightSpin->SetValue(height,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_HEIGHT,t,height);
				}
				else // _fixed == FIX_HEIGHT
				{
					float width = heightSpin->GetFVal()*aspectSpin->GetFVal();
					widthSpin->SetValue(width,FALSE);
					_pCam->_pblock->SetValue(PB_PCAM_WIDTH,t,width);
				}
				break;
			}
		}
	case WM_COMMAND:
    switch(LOWORD(wParam))
    {
    case IDC_PCAM_UPDATE:
			_pCam->_update = true;
			_pCam->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
      break;
    case IDC_PCAM_LOCK_X2Z:
      break;
    case IDC_PCAM_LOCK_X2Y:
      break;
    case IDC_PCAM_LOCK_Y2Z:
      break;
    case IDC_PCAM_FIX_HEIGHT:
			if(_pCam->_fixed != ParallelCamera::FIX_HEIGHT)
			{
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_ASPECT));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_WIDTH));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				_pCam->_fixed = ParallelCamera::FIX_HEIGHT;
				EnableEdit(IDC_PCAM_ASPECT);
				EnableSpinner(IDC_PCAM_ASPECT_SPINNER);
				EnableEdit(IDC_PCAM_WIDTH);
				EnableSpinner(IDC_PCAM_WIDTH_SPINNER);
				DisableEdit(IDC_PCAM_HEIGHT);
				DisableSpinner(IDC_PCAM_HEIGHT_SPINNER);
			}
      break;
    case IDC_PCAM_FIX_WIDTH:
			if(_pCam->_fixed != ParallelCamera::FIX_WIDTH)
			{
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_ASPECT));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_HEIGHT));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				_pCam->_fixed = ParallelCamera::FIX_WIDTH;
				EnableEdit(IDC_PCAM_ASPECT);
				EnableSpinner(IDC_PCAM_ASPECT_SPINNER);
				DisableEdit(IDC_PCAM_WIDTH);
				DisableSpinner(IDC_PCAM_WIDTH_SPINNER);
				EnableEdit(IDC_PCAM_HEIGHT);
				EnableSpinner(IDC_PCAM_HEIGHT_SPINNER);
			}
      break;
    case IDC_PCAM_FIX_ASPECT:
			if(_pCam->_fixed != ParallelCamera::FIX_ASPECT)
			{
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_WIDTH));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				btn = GetICustButton(GetDlgItem(hWnd,IDC_PCAM_FIX_HEIGHT));
				if(btn)
				{
					btn->SetCheck(FALSE);
					ReleaseICustButton(btn);
				}
				_pCam->_fixed = ParallelCamera::FIX_ASPECT;
				DisableEdit(IDC_PCAM_ASPECT);
				DisableSpinner(IDC_PCAM_ASPECT_SPINNER);
				EnableEdit(IDC_PCAM_WIDTH);
				EnableSpinner(IDC_PCAM_WIDTH_SPINNER);
				EnableEdit(IDC_PCAM_HEIGHT);
				EnableSpinner(IDC_PCAM_HEIGHT_SPINNER);
			}
      break;
    default:
      break;
    }
  default:
    break;
  }
  return TRUE;
}

// sectioning front clip plane below here
void ParallelCamera::UpdateSlice(INode *sectionNode,const TimeValue t,const bool force)
{
	static float lastLength = 0.0f,lastWidth = 0.0f,lastDist = 0.0f;
	static Matrix3 sliceTM; // the slice's tm

	if(!force) // do we need to update anyway
	{
		// update if relevant parameters have changed since last update
		float length,width,dist;
		_pblock->GetValue(PB_PCAM_HEIGHT,t,length,FOREVER);
		_pblock->GetValue(PB_PCAM_WIDTH,t,width,FOREVER);
		_pblock->GetValue(PB_PCAM_CLIP_NEAR,t,dist,FOREVER);
		
		Matrix3 curTM = sectionNode->GetNodeTM(t);
		if(EqualMatrices(curTM,sliceTM) && length == lastLength && width == lastWidth && dist == lastDist)
		{
			sliceTM = curTM;
			return;
		}
	}

	assert(_pointList.Count()==0);

	sliceTM	= sectionNode->GetNodeTM(t);
	_pblock->GetValue(PB_PCAM_CLIP_NEAR,t,lastDist,FOREVER);

	// allow for clip distance in sectioning plane
	Matrix3 shift(sliceTM);
	shift.PreTranslate(Point3(0.0f,0.0f,-lastDist));
	_sliceTM_inv = Inverse(shift);
	_curTime = t;

	// to slice only nodes within the section rectangle
	_pblock->GetValue(PB_PCAM_HEIGHT,t,lastLength,FOREVER);
	_pblock->GetValue(PB_PCAM_WIDTH,t,lastWidth,FOREVER);

	float w2 = lastWidth*0.5f;
	float h2 = lastLength*0.5f;

	// include the bounding rectangle
	Box3 boundBox;
	boundBox += Point3(-w2,-h2,0.0f);
	boundBox += Point3( w2,-h2,0.0f);
	boundBox += Point3(-w2, h2,0.0f);
	boundBox += Point3( w2, h2,0.0f);

	boundBox = boundBox*shift;

	INode *rootNode = GetCOREInterface()->GetRootNode();
	assert(rootNode);

	// generate the point list
  TraverseWorld(rootNode,0,boundBox);

	_shape.NewShape();
	_shape.bdgBox.Init();
	// largest possible shape uses every point pair
	_shape.SetNumLines(_pointList.Count()/2,FALSE);

	PolyLine pl;
	pl.SetNumPts(2);

	for(int lines = 0,vert = 0;vert< _pointList.Count()/2;++vert)
	{
		// traverse the list of points pairwise
		pl.pts[0] = _pointList[vert*2];
		pl.pts[1] = _pointList[vert*2+1];

		// shift them 
		pl.pts[0].p.z = -lastDist;
		pl.pts[1].p.z = -lastDist;

		// if adjacent vertices are approx. distinct make a polyline of them
		if(!EqualPoint3(pl.pts[0].p,pl.pts[1].p))
    {
			_shape.bdgBox += pl.pts[0].p;
			_shape.bdgBox += pl.pts[1].p;
			_shape.lines[lines++] = pl; // and add it to the shape
		} // otherwise point pair is discarded
	}

	_shape.SetNumLines(lines,TRUE);
	_shape.UpdateSels();
	_shape.InvalidateGeomCache(FALSE);
	_shape.BuildBoundingBox();

	_pointList.Resize(0); // blows away the memory associated with the point list
}

// slice this node and recurse thru it's children
void ParallelCamera::TraverseWorld(INode *node,const int level,Box3& boundBox)
{
	Object *obj = node->EvalWorldState(_curTime).obj;
	if(obj)
  {
		Box3 nodeBBox;
		obj->GetDeformBBox(_curTime,nodeBBox,&node->GetObjectTM(_curTime));
		if(boundBox.Contains(nodeBBox))
		{
			_curNode = node;
			SliceASceneNode();
		}
	}

	// TraverseWorld other nodes
	const int num = node->NumberOfChildren();
	for(int i = 0;i<num;++i)
	{
		INode* child = node->GetChildNode(i);
		TraverseWorld(child,level+1,boundBox);
	}
}

// slice this node
void ParallelCamera::SliceASceneNode(void)
{
	// Get the object from the node
	ObjectState os = _curNode->EvalWorldState(_curTime);
	if(!_curNode->IsHidden() && 
		 !_curNode->IsFrozen() && 
		 os.obj &&
     os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) 
	{
		Box3 bbox;
		const float LOCAL_MAX_FLOAT = 1e30F;
		float	minz = LOCAL_MAX_FLOAT,maxz = -LOCAL_MAX_FLOAT;
		
		GeomObject* geo_obj = (GeomObject*)os.obj; // the current object being sliced
		geo_obj->GetWorldBoundBox(_curTime,_curNode,GetCOREInterface()->GetActiveViewport(),bbox);

		// transform the corners of the object's world bbox in slice space
		// store into _t_bbox and get min, max z
		for(int corner = 0;corner<8;corner++)
		{
			_tmBbox[corner] = _sliceTM_inv * bbox[corner];
			if(_tmBbox[corner].z < minz)
				minz = _tmBbox[corner].z;
			if(_tmBbox[corner].z > maxz)
				maxz = _tmBbox[corner].z;
		}

		// see if we touch or intersect the bounding box
		int sminz = Sign(minz);
		int smaxz = Sign(maxz);
		if(sminz == 0 || smaxz == 0 || sminz != smaxz)
		{
      bool needDelete;
			TriObject* tri = GetTriObjectFromNode(_curNode,_curTime,needDelete);
			if(tri)
      {
				_curMesh = &tri->GetMesh();
				if(_curMesh) 
					DoMeshSlice();

				if(needDelete)
					delete tri;
			}
		}
	}
}

// slice the current mesh 
void ParallelCamera::DoMeshSlice(void)
{
	const Matrix3 objToWorldTM = _curNode->GetObjTMAfterWSM(_curTime);
	const Matrix3 objToSliceTM = objToWorldTM * _sliceTM_inv;

	// make and fill an array of mesh points in slice coordinate system
	// also compute the sign's of all the z coords
	// TODO: move this memory allocation outside object traversal
	Point3* t_verts  = new Point3[_curMesh->numVerts];
	assert(t_verts);

  // transform the vertices of the mesh to slice space
	for(int vert = 0;vert<_curMesh->numVerts;vert++)
		t_verts[vert] = objToSliceTM*_curMesh->getVert(vert);

	// slice each face
	for(int face = 0;face<_curMesh->numFaces;face++)
  {
		if(!(_curMesh->faces[face].flags & FACE_HIDDEN))
			SliceFace(t_verts,face);
  }

	delete[] t_verts;
}

//-------------------------------------------------------------------
// slice the cutting plane thru a mesh face
//
// if the face is on the slice, add all the edges to the slice edge list
// if one edge is on the slice, add that edge
// if one vertex is on the slice, see if the opposite edge is sliced
//     if so, add that segment
// if no vertices are on the slice, find the two points of intersection and
//		add the segment between those two points
// 
// add the resulting line segment(s) to the section object's _shape list 
//
void ParallelCamera::SliceFace(Point3* t_verts, const DWORD f_index)
{
	Face*		face;						// the face being intersected
	Point3*	vv[3];						// pointers to vertices of each face
	int			nu_coplanar = 0;
	int			cnt,check;
	int			nonz_verts[2];
	int			sign_vvz[3];
	Point3	crossPt;
	int			nu_neg=0,nu_pos=0;
	face	= &_curMesh->faces[f_index];

	// find number of coplanar vertices 
	// store sign of vertices z values in sign_vvz
	for(int jj = 0;jj<3;++jj)
	{
		vv[jj] = &t_verts[face->v[jj]];
		sign_vvz[jj] = Sign(vv[jj]->z);
		if(sign_vvz[jj] == 0)
			nu_coplanar++;
		else if(sign_vvz[jj] < 0)
			nu_neg++;
		else
			nu_pos++;
	}

	// if all on one side or other, return
	if(nu_neg==3 || nu_pos==3)
		return;

	// decide which segment to add based on how many vertices are coplanar to the slice
	switch (nu_coplanar)
	{
	case 3:
		// the whole face is on the slice
		// add all edges to the segment list (as long as they're visible)
		cnt=0;
		if(face->getEdgeVis(0))
		{
			_faceLines[cnt].pts[0] = *vv[0];
			_faceLines[cnt].pts[1] = *vv[1];
			cnt++;
		}
		if(face->getEdgeVis(1))
		{
			_faceLines[cnt].pts[0] = *vv[1];
			_faceLines[cnt].pts[1] = *vv[2];
			cnt++;
		}
		if(face->getEdgeVis(2))
		{
			_faceLines[cnt].pts[0] = *vv[2];
			_faceLines[cnt].pts[1] = *vv[0];
			cnt++;
		}

		for(jj=0;jj<cnt;jj++)
		{
			_pointList.Append(1,&_faceLines[jj].pts[0].p,256);
			_pointList.Append(1,&_faceLines[jj].pts[1].p,256);
		}
		break;

	case 2:
		// one edge is on the slice
		// add the edge who's z values are zero (as long as it's visible)
		cnt = 0;
		if(sign_vvz[0]==0)
			_faceLines[0].pts[cnt++] = *vv[0];
		else if(!face->getEdgeVis(1))
				break;
		if(sign_vvz[1]==0)
			_faceLines[0].pts[cnt++] = *vv[1];
		else if(!face->getEdgeVis(0))
				break;
		if(sign_vvz[2]==0)
			_faceLines[0].pts[cnt++] = *vv[2];
		else if(!face->getEdgeVis(2))
				break;

		assert(cnt==2);

		_pointList.Append(1,&_faceLines[0].pts[0].p,256);
		_pointList.Append(1,&_faceLines[0].pts[1].p,256);
    break;

	case 1:
		// one vertex is on the slice
		// if the signs of the other vertices are not different,
		//      have a single point intersection and ignore it
		// otherwise, 
		//      compute the intersection point between the vertices
		//      add line between intersection point and point on slice
		cnt=0;
		if(sign_vvz[0]!=0)
			nonz_verts[cnt++] = 0;
		else
			_faceLines[0].pts[0] = *vv[0];
		if(sign_vvz[1]!=0)
			nonz_verts[cnt++] = 1;
		else
			_faceLines[0].pts[0] = *vv[1];
		if(sign_vvz[2]!=0)
			nonz_verts[cnt++] = 2;
		else
			_faceLines[0].pts[0] = *vv[2];

		assert(cnt==2);
		assert(sign_vvz[nonz_verts[0]]!=0 && sign_vvz[nonz_verts[1]]!=0);

		if(sign_vvz[nonz_verts[0]] == sign_vvz[nonz_verts[1]])
			break;

		CrossPoint(*vv[nonz_verts[0]],*vv[nonz_verts[1]],&crossPt);

		_faceLines[0].pts[1] = PolyPt(crossPt);

		_pointList.Append(1,&_faceLines[0].pts[0].p,256);
		_pointList.Append(1,&_faceLines[0].pts[1].p,256);
		break;

	case 0:
		// no vertices are on the plane
		// look for zero or two intersection points
		cnt = 0;

		check = CrossCheck(*vv[0],*vv[1],&crossPt);
		assert(check != 2);
		if(check==1)
			_faceLines[0].pts[cnt++] = PolyPt(crossPt);

		check = CrossCheck(*vv[0],*vv[2],&crossPt);
		assert(check != 2);
		if(check==1)
			_faceLines[0].pts[cnt++] = PolyPt(crossPt);

		check = CrossCheck(*vv[1],*vv[2],&crossPt);
		assert(check != 2);
		if(check==1)
			_faceLines[0].pts[cnt++] = PolyPt(crossPt);

		assert(cnt==0 || cnt == 2);

		if(cnt==2)
		{
			_pointList.Append(1,&_faceLines[0].pts[0].p,256);
			_pointList.Append(1,&_faceLines[0].pts[1].p,256);

		}
		break;

	default:
		assert(FALSE);
	}
}

// return a pointer to a TriObject given an INode or NULL if inconvertable
TriObject *ParallelCamera::GetTriObjectFromNode(INode *node,const TimeValue t,bool &deleteIt)
{
	deleteIt = false;
	Object *obj = node->EvalWorldState(t).obj;
	if(obj->CanConvertToType(Class_ID(TRIOBJ_CLASS_ID,0)))
  { 
		TriObject *tri = (TriObject *) obj->ConvertToType(0,Class_ID(TRIOBJ_CLASS_ID,0));
		// Note that the TriObject should only be deleted
		// if the pointer to it is not equal to the object
		// pointer that called ConvertToType()
		if(obj != tri)
      deleteIt = true;
		return tri;
	}
	else
		return NULL;
}

// Not truly the correct way to compare floats of arbitary magnitude...
bool ParallelCamera::EqualPoint3(const Point3 p1,const Point3 p2)
{
	const float FUZZ_FACTOR  = 1.0e-6f;

	if(fabs(p1.x - p2.x) > FUZZ_FACTOR)
		return false;
	if(fabs(p1.y - p2.y) > FUZZ_FACTOR)
		return false;
	if(fabs(p1.z - p2.z) > FUZZ_FACTOR)
		return false;

	return true;
}

// checks that the two points cross the XY plane.  
// If so, computes the crossing point.
// 
// return values:
//		2  both points are on the plane (cross_pt is not changed)
//		1  cross_pt contains the one point of intersection
//		0  no points of intersection (cross_pt not changed)
int ParallelCamera::CrossCheck(const Point3& pt1,const Point3& pt2,Point3* cross_pt)
{
	const float	z1 = pt1.z;
	const float	z2 = pt2.z;
	const int	sign_z1 = Sign(z1);
	const int	sign_z2 = Sign(z2);

	// check for corners straddling the plane
	if(sign_z1 == 0 && sign_z2 == 0)
		return 2;
	else if(sign_z1 != sign_z2)
	{
		// straddle!  compute intersection pt
		if(cross_pt)
		{
			float dd = z1 / (z1 - z2);
			cross_pt->x = pt1.x + dd * (pt2.x - pt1.x);
			cross_pt->y = pt1.y + dd * (pt2.y - pt1.y);
			cross_pt->z = 0.0f;
		}
		return 1;
	}
	return 0;
}

// computes crossing point when we know that the two points cross the XY plane
void ParallelCamera::CrossPoint(const Point3& pt1,const Point3& pt2,Point3* cross_pt)
{
	const float	z1 = pt1.z;
	const float	z2 = pt2.z;
	const int	sign_z1 = Sign(z1);
	const int	sign_z2 = Sign(z2);

	assert(Sign(pt1.z) != Sign(pt2.z));

	float dd = z1 / (z1 - z2);
	cross_pt->x = pt1.x + dd * (pt2.x - pt1.x);
	cross_pt->y = pt1.y + dd * (pt2.y - pt1.y);
	cross_pt->z = 0.0f;
}

bool ParallelCamera::EqualMatrices(const Matrix3& m1,const Matrix3& m2) 
{
	return m1.GetRow(0)==m2.GetRow(0) && 
		     m1.GetRow(1)==m2.GetRow(1) && 
		     m1.GetRow(2)==m2.GetRow(2) && 
		     m1.GetRow(3)==m2.GetRow(3);
}
#endif // DESIGN_VER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\boxobj.cpp ===
/**********************************************************************
 *<
	FILE: boxobj.cpp

	DESCRIPTION:  A Box object implementation

	CREATED BY: Dan Silva
	MODIFIED BY: Rolf Berteig

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"
#include "MNMath.h"
#include "PolyObj.h"

class BoxObject : public GenBoxObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static int dlgLSegs;
		static int dlgWSegs;
		static int dlgHSegs;
		static int createMeth;
		static Point3 crtPos;		
		static float crtWidth, crtHeight, crtLength;

		BoxObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_BOX); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID( BOXOBJ_CLASS_ID, 0); }  
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		Object *BuildPolyBox (TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

		// From GenBoxObject
		void SetParams(float width, float height, float length, int wsegs,int lsegs, 
			int hsegs, BOOL genUV); 
	};				



#define BOTTOMPIV

#define BMIN_LENGTH		float(0)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)
#define BMIN_HEIGHT		float(-1.0E30)
#define BMAX_HEIGHT		float(1.0E30)

#define BDEF_DIM		float(0)
#define BDEF_SEGS		1

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

//--- ClassDescriptor and class vars ---------------------------------

class BoxObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new BoxObject;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_BOX_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(BOXOBJ_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES);}	
	void			ResetClassParams(BOOL fileReset);
	};

static BoxObjClassDesc boxObjDesc;

ClassDesc* GetBoxobjDesc() { return &boxObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IObjParam *BoxObject::ip         = NULL;
int BoxObject::dlgLSegs          = BDEF_SEGS;
int BoxObject::dlgWSegs          = BDEF_SEGS;
int BoxObject::dlgHSegs          = BDEF_SEGS;
IParamMap *BoxObject::pmapCreate = NULL;
IParamMap *BoxObject::pmapTypeIn = NULL;
IParamMap *BoxObject::pmapParam  = NULL;	
Point3 BoxObject::crtPos         = Point3(0,0,0);		
float BoxObject::crtWidth        = 0.0f; 
float BoxObject::crtHeight       = 0.0f;
float BoxObject::crtLength       = 0.0f;
int BoxObject::createMeth        = 0;

void BoxObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	BoxObject::dlgLSegs   = BDEF_SEGS;
	BoxObject::dlgWSegs   = BDEF_SEGS;
	BoxObject::dlgHSegs   = BDEF_SEGS;
	BoxObject::crtWidth   = 0.0f; 
	BoxObject::crtHeight  = 0.0f;
	BoxObject::crtLength  = 0.0f;
	BoxObject::createMeth = 0;
	BoxObject::crtPos     = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_LENGTH	0
#define PB_WIDTH	1
#define PB_HEIGHT	2
#define PB_WSEGS	3
#define PB_LSEGS	4
#define PB_HSEGS	5
#define PB_GENUVS	6

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_LENGTH		2
#define PB_TI_WIDTH			3
#define PB_TI_HEIGHT		4


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEBOX,IDC_CREATECUBE};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1



//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_HEIGHTEDIT,IDC_HEIGHTSPINNER,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGH 4


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_HEIGHTEDIT,IDC_HEIGHTSPINNER,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	
	// Length Segments
	ParamUIDesc(
		PB_LSEGS,
		EDITTYPE_INT,
		IDC_LSEGS,IDC_LSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_WSEGS,IDC_WSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_HSEGS,IDC_HSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGH 7


ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 }, 
	{ TYPE_INT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 } 
	};

ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 }, 
	{ TYPE_INT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } 
	};

#define PBLOCK_LENGTH	7

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,6,0),	
	};
#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class BoxTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		BoxObject *ob;

		BoxTypeInDlgProc(BoxObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL BoxTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_LENSPINNER:
				case IDC_WIDTHSPINNER:
				case IDC_HEIGHTSPINNER:
					if (ob->createMeth) {
						ISpinnerControl *spin = (ISpinnerControl*)lParam;
						ob->crtLength = ob->crtWidth = ob->crtHeight =
							spin->GetFVal();
						map->Invalidate();
						}
					break;
				}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_LENGTH,0,ob->crtLength);
						ob->pblock->SetValue(PB_WIDTH,0,ob->crtWidth);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);					
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Box methods -------------------------------


BoxObject::BoxObject()
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_LSEGS,0,dlgLSegs);
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);	
	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	}

IOResult BoxObject::Load(ILoad *iload)
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

void BoxObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Box ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_BOXPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_BOXPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_BOXPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new BoxTypeInDlgProc(this));
		}
	}
		
void BoxObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.	
	pblock->GetValue(PB_LSEGS,ip->GetTime(),dlgLSegs,FOREVER);
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);	
	}

void BoxObject::SetParams(float width, float height, float length, int wsegs,int lsegs, 
			int hsegs, BOOL genUV) {
	pblock->SetValue(PB_WIDTH,0,width);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_LENGTH,0,length);
	pblock->SetValue(PB_LSEGS,0,lsegs);
	pblock->SetValue(PB_WSEGS,0,wsegs);
	pblock->SetValue(PB_HSEGS,0,hsegs);		
	pblock->SetValue(PB_GENUVS,0, genUV);	
	} 

// vertices ( a b c d ) are in counter clockwise order when viewd from 
// outside the surface unless bias!=0 in which case they are clockwise
static void MakeQuad(int nverts, Face *f, int a, int b , int c , int d, int sg, int bias) {
	int sm = 1<<sg;
	assert(a<nverts);
	assert(b<nverts);
	assert(c<nverts);
	assert(d<nverts);
	if (bias) {
		f[0].setVerts( b, a, c);
		f[0].setSmGroup(sm);
		f[0].setEdgeVisFlags(1,0,1);
		f[1].setVerts( d, c, a);
		f[1].setSmGroup(sm);
		f[1].setEdgeVisFlags(1,0,1);
	} else {
		f[0].setVerts( a, b, c);
		f[0].setSmGroup(sm);
		f[0].setEdgeVisFlags(1,1,0);
		f[1].setVerts( c, d, a);
		f[1].setSmGroup(sm);
		f[1].setEdgeVisFlags(1,1,0);
		}
	}


#define POSX 0	// right
#define POSY 1	// back
#define POSZ 2	// top
#define NEGX 3	// left
#define NEGY 4	// front
#define NEGZ 5	// bottom

int direction(Point3 *v) {
	Point3 a = v[0]-v[2];
	Point3 b = v[1]-v[0];
	Point3 n = CrossProd(a,b);
	switch(MaxComponent(n)) {
		case 0: return (n.x<0)?NEGX:POSX;
		case 1: return (n.y<0)?NEGY:POSY;
		case 2: return (n.z<0)?NEGZ:POSZ;
		}
	return 0;
	}

// Remap the sub-object material numbers so that the top face is the first one
// The order now is:
// Top / Bottom /  Left/ Right / Front / Back
static int mapDir[6] ={ 3, 5, 0, 2, 4, 1 };

#define MAKE_QUAD(na,nb,nc,nd,sm,b) {MakeQuad(nverts,&(mesh.faces[nf]),na, nb, nc, nd, sm, b);nf+=2;}

BOOL BoxObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void BoxObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}


void BoxObject::BuildMesh(TimeValue t)
	{
	int ix,iy,iz,nf,kv,mv,nlayer,topStart,midStart;
	int nverts,wsegs,lsegs,hsegs,nv,nextk,nextm,wsp1;
	int nfaces;
	Point3 va,vb,p;
	float l, w, h;
	int genUVs = 1;
	BOOL bias = 0;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;	
	pblock->GetValue(PB_LENGTH,t,l,ivalid);
	pblock->GetValue(PB_WIDTH,t,w,ivalid);
	pblock->GetValue(PB_HEIGHT,t,h,ivalid);
	pblock->GetValue(PB_LSEGS,t,lsegs,ivalid);
	pblock->GetValue(PB_WSEGS,t,wsegs,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	if (h<0.0f) bias = 1;
	
	LimitValue(lsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);

	// Number of verts
      // bottom : (lsegs+1)*(wsegs+1)
	  // top    : (lsegs+1)*(wsegs+1)
	  // sides  : (2*lsegs+2*wsegs)*(hsegs-1)

	// Number of rectangular faces.
      // bottom : (lsegs)*(wsegs)
	  // top    : (lsegs)*(wsegs)
	  // sides  : 2*(hsegs*lsegs)+2*(wsegs*lsegs)

	wsp1 = wsegs + 1;
	nlayer  =  2*(lsegs+wsegs);
	topStart = (lsegs+1)*(wsegs+1);
	midStart = 2*topStart;

	nverts = midStart+nlayer*(hsegs-1);
	nfaces = 4*(lsegs*wsegs + hsegs*lsegs + wsegs*hsegs);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.InvalidateTopologyCache();

	nv = 0;
	
	vb =  Point3(w,l,h)/float(2);   
	va = -vb;

#ifdef BOTTOMPIV
	va.z = float(0);
	vb.z = h;
#endif

	float dx = w/wsegs;
	float dy = l/lsegs;
	float dz = h/hsegs;

	// do bottom vertices.
	p.z = va.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}
	
	nf = 0;

	// do bottom faces.
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+wsegs+1, kv+wsegs+2, kv+1, 1, bias);
			kv++;
			}
		}
	assert(nf==lsegs*wsegs*2);

	// do top vertices.
	p.z = vb.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}

	// do top faces (lsegs*wsegs);
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1)+topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, kv+wsegs+2,kv+wsegs+1, 2, bias);
			kv++;
			}
		}
	assert(nf==lsegs*wsegs*4);

	// do middle vertices 
	for(iz=1; iz<hsegs; iz++) {
		
		p.z = va.z + dz * iz;

		// front edge
		p.x = va.x;  p.y = va.y;
		for (ix=0; ix<wsegs; ix++) { mesh.setVert(nv++, p);  p.x += dx;	}

		// right edge
		p.x = vb.x;	  p.y = va.y;
		for (iy=0; iy<lsegs; iy++) { mesh.setVert(nv++, p);  p.y += dy;	}

		// back edge
		p.x =  vb.x;  p.y =  vb.y;
		for (ix=0; ix<wsegs; ix++) { mesh.setVert(nv++, p);	 p.x -= dx;	}

		// left edge
		p.x = va.x;  p.y =  vb.y;
		for (iy=0; iy<lsegs; iy++) { mesh.setVert(nv++, p);	 p.y -= dy;	}
		}

	if (hsegs==1) {
		// do FRONT faces -----------------------
		kv = 0;
		mv = topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, mv+1, mv, 3, bias);
			kv++;
			mv++;
			}

		// do RIGHT faces.-----------------------
		kv = wsegs;  
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+wsp1, mv+wsp1, mv, 4, bias);
			kv += wsp1;
			mv += wsp1;
			}	

		// do BACK faces.-----------------------
		kv = topStart - 1;
		mv = midStart - 1;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv-1, mv-1, mv, 5, bias);
			kv --;
			mv --;
			}

		// do LEFT faces.----------------------
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv-wsp1, mv-wsp1, mv, 6, bias);
			kv -= wsp1;
			mv -= wsp1;
			}
		}

	else {
		// do front faces.
		kv = 0;
		mv = midStart;
		for(iz=0; iz<hsegs; iz++) {
			if (iz==hsegs-1) mv = topStart;
			for (ix=0; ix<wsegs; ix++) 
				MAKE_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix, 3, bias);
			kv = mv;
			mv += nlayer;
			}

		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*2);
	 
		// do RIGHT faces.-------------------------
		// RIGHT bottom row:
		kv = wsegs; // into bottom layer. 
		mv = midStart + wsegs; // first layer of mid verts


		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+wsp1, mv+1, mv, 4, bias);
			kv += wsp1;
			mv ++;
			}

		// RIGHT middle part:
		kv = midStart + wsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				MAKE_QUAD(kv+iy, kv+iy+1, mv+iy+1, mv+iy, 4, bias);
				}
			kv += nlayer;
			}

		// RIGHT top row:
		kv = midStart + wsegs + (hsegs-2)*nlayer; 
		mv = topStart + wsegs;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+1, mv+wsp1, mv, 4, bias);
			mv += wsp1;
			kv++;
			}
		
		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*2 + lsegs*hsegs*2);

		// do BACK faces. ---------------------
		// BACK bottom row:
		kv = topStart - 1;
		mv = midStart + wsegs + lsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv-1, mv+1, mv, 5, bias);
			kv --;
			mv ++;
			}

		// BACK middle part:
		kv = midStart + wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (ix=0; ix<wsegs; ix++) {
				MAKE_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix, 5, bias);
				}
			kv += nlayer;
			}

		// BACK top row:
		kv = midStart + wsegs + lsegs + (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1)+wsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, mv-1, mv, 5, bias);
			mv --;
			kv ++;
			}

		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*4 + lsegs*hsegs*2);

		// do LEFT faces. -----------------
		// LEFT bottom row:
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = midStart + 2*wsegs +lsegs;
		for (iy=0; iy<lsegs; iy++) {
			nextm = mv+1;
			if (iy==lsegs-1) 
				nextm -= nlayer;
			MAKE_QUAD(kv, kv-wsp1, nextm, mv, 6, bias);
			kv -=wsp1;
			mv ++;
			}

		// LEFT middle part:
		kv = midStart + 2*wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				nextm = mv+1;
				nextk = kv+iy+1;
				if (iy==lsegs-1) { 
					nextm -= nlayer;
					nextk -= nlayer;
					}
				MAKE_QUAD(kv+iy, nextk, nextm, mv, 6, bias);
				mv++;
				}
			kv += nlayer;
			}

		// LEFT top row:
		kv = midStart + 2*wsegs + lsegs+ (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1);
		for (iy=0; iy<lsegs; iy++) {
			nextk = kv+1;
			if (iy==lsegs-1) 
				nextk -= nlayer;
			MAKE_QUAD(kv, nextk, mv-wsp1, mv, 6, bias);
			mv -= wsp1;
			kv++;
			}
		}

	if (genUVs) {
		int ls = lsegs+1;
		int ws = wsegs+1;
		int hs = hsegs+1;
		int ntverts = ls*hs + hs*ws + ws*ls ;
		mesh.setNumTVerts( ntverts ) ;
		mesh.setNumTVFaces(nfaces);		

		int xbase = 0;
		int ybase = ls*hs;
		int zbase = ls*hs + hs*ws;
	
		float dw = 1.0f/float(wsegs);
		float dl = 1.0f/float(lsegs);
		float dh = 1.0f/float(hsegs);

		if (w==0.0f) w = .0001f;
		if (l==0.0f) l = .0001f;
		if (h==0.0f) h = .0001f;
		float u,v;

		nv = 0;
		v = 0.0f;
		// X axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f; 
			for (iy =0; iy<ls; iy++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dl;
				}
			v += dh;
			}

		v = 0.0f; 
		//Y Axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f;
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dh;
			}

		v = 0.0f; 
		for (iy =0; iy<ls; iy++) {
			u = 0.0f; 
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dl;
			}

		assert(nv==ntverts);

		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = direction(v);
			int ntv[3];
			for (ix=0; ix<3; ix++) {
				int iu,iv;
				switch(dir) {
					case POSX: case NEGX:
						iu = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f);  
						if (dir==NEGX) iu = lsegs-iu;
						ntv[ix] = (xbase + iv*ls + iu);
						break;
					case POSY: case NEGY:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f); 
						if (dir==POSY) iu = wsegs-iu;
						ntv[ix] = (ybase + iv*ws + iu);
						break;
					case POSZ: case NEGZ:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						if (dir==NEGZ) iu = wsegs-iu;
						ntv[ix] = (zbase + iv*ws + iu);
						break;
					}
			 	}
			assert(ntv[0]<ntverts);
			assert(ntv[1]<ntverts);
			assert(ntv[2]<ntverts);
			
			mesh.tvFace[nf].setTVerts(ntv[0],ntv[1],ntv[2]);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
    else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = direction(v);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
 
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}


#define Tang(vv,ii) ((vv)*3+(ii))
inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}
inline Point3 operator-(const PatchVert &pv1,const PatchVert &pv2)
	{
	return pv1.p-pv2.p;
	}
inline Point3 operator+(const PatchVert &pv1,const PatchVert &pv2)
	{
	return pv1.p+pv2.p;
	}

void BuildBoxPatch(
		PatchMesh &patch, 
		float width, float length, float height, int textured)
	{
	int nverts = 8;
	int nvecs = 48;
	int npatches = 6;
	patch.setNumVerts(nverts);	
	patch.setNumTVerts(textured ? 4 : 0);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);
	patch.setNumTVPatches(textured ? npatches : 0);

	float w2 = width/2.0f, w3 = width/3.0f;
	float l2 = length/2.0f, l3 = length/3.0f;
	float h2 = height/2.0f, h3 = height/3.0f;
	int i;
	Point3 v;
	DWORD a, b, c, d;

	patch.setVert(0, -w2, -l2, 0.0f);
	patch.setVert(1,  w2, -l2, 0.0f);
	patch.setVert(2,  w2,  l2, 0.0f);
	patch.setVert(3, -w2,  l2, 0.0f);
	patch.setVert(4, -w2, -l2, height);
	patch.setVert(5,  w2, -l2, height);
	patch.setVert(6,  w2,  l2, height);
	patch.setVert(7, -w2,  l2, height);
	
	if(textured) {
		patch.setTVert(0, UVVert(1,0,0));
		patch.setTVert(1, UVVert(1,1,0));
		patch.setTVert(2, UVVert(0,1,0));
		patch.setTVert(3, UVVert(0,0,0));
		}

	int ix=0;
	for (i=0; i<4; i++) {
		v = (patch.verts[(i+1)%4] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		v = (patch.verts[i+4] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		v = (patch.verts[i==0?3:i-1] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		}
	for (i=0; i<4; i++) {
		v = (patch.verts[(i+1)%4+4] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		v = (patch.verts[i] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		v = (patch.verts[i==0?7:i+3] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		}
	
	int px = 0;
	for (i=0; i<4; i++) {
		Patch &p = patch.patches[px];
		a = i+4;
		b = i;
		c = (i+1)%4;
		d = (i+1)%4+4;
		p.SetType(PATCH_QUAD);
		p.setVerts(a, b, c, d);
		p.setVecs(
			Tang(a,1),Tang(b,1),Tang(b,0),Tang(c,2),
			Tang(c,1),Tang(d,1),Tang(d,2),Tang(a,0));
		p.setInteriors(ix, ix+1, ix+2, ix+3);
		p.smGroup = 1<<px;
		if(textured)
			patch.getTVPatch(px).setTVerts(2,3,0,1);

		ix+=4;
		px++;
		}
	
	a = 0;
	b = 3;
	c = 2;
	d = 1;
	patch.patches[px].SetType(PATCH_QUAD);
	patch.patches[px].setVerts(a, b, c, d);
	patch.patches[px].setVecs(
		Tang(a,2),Tang(b,0),Tang(b,2),Tang(c,0),
		Tang(c,2),Tang(d,0),Tang(d,2),Tang(a,0));
	patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
	patch.patches[px].smGroup = 1<<px;
	if(textured)
		patch.getTVPatch(px).setTVerts(0,1,2,3);
//watje 3-17-99 to support patch matids
	patch.patches[px].setMatID(1);

	ix+=4;
	px++;

	a = 7;
	b = 4;
	c = 5;
	d = 6;
	patch.patches[px].SetType(PATCH_QUAD);
	patch.patches[px].setVerts(a, b, c, d);
	patch.patches[px].setVecs(
		Tang(a,0),Tang(b,2),Tang(b,0),Tang(c,2),
		Tang(c,0),Tang(d,2),Tang(d,0),Tang(a,2));
	patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
	patch.patches[px].smGroup = 1<<px;
	if(textured)
		patch.getTVPatch(px).setTVerts(2,3,0,1);
//watje 3-17-99 to support patch matids
	patch.patches[px].setMatID(0);

	patch.patches[0].setMatID(4);
	patch.patches[1].setMatID(3);
	patch.patches[2].setMatID(5);
	patch.patches[3].setMatID(2);

	ix+=4;
	px++;

	assert(patch.buildLinkages());
	patch.computeInteriors();
	patch.InvalidateGeomCache();
	}


#ifndef NO_NURBS

Object*
BuildNURBSBox(float width, float length, float height, int genUVs)
{
	int cube_faces[6][4] = {{0, 1, 2, 3}, // bottom
							{5, 4, 7, 6}, // top
							{2, 3, 6, 7}, // back
							{1, 0, 5, 4}, // front
							{3, 1, 7, 5}, // left
							{0, 2, 4, 6}};// right
	Point3 cube_verts[8] = {Point3(-0.5, -0.5, 0.0),
							Point3( 0.5, -0.5, 0.0),
							Point3(-0.5,  0.5, 0.0),
							Point3( 0.5,  0.5, 0.0),
							Point3(-0.5, -0.5, 1.0),
							Point3( 0.5, -0.5, 1.0),
							Point3(-0.5,  0.5, 1.0),
							Point3( 0.5,  0.5, 1.0)};
	int faceIDs[6] = { 2, 1, 6, 5, 4, 3 };

	NURBSSet nset;

	for (int face = 0; face < 6; face++) {
		Point3 bl = cube_verts[cube_faces[face][0]];
		Point3 br = cube_verts[cube_faces[face][1]];
		Point3 tl = cube_verts[cube_faces[face][2]];
		Point3 tr = cube_verts[cube_faces[face][3]];

		Matrix3 size;
		size.IdentityMatrix();
		Point3 lwh(width, length, height);
		size.Scale(lwh);

		bl = bl * size;
		br = br * size;
		tl = tl * size;
		tr = tr * size;

		NURBSCVSurface *surf = new NURBSCVSurface();
		nset.AppendObject(surf);
		surf->SetUOrder(4);
		surf->SetVOrder(4);
		surf->SetNumCVs(4, 4);
		surf->SetNumUKnots(8);
		surf->SetNumVKnots(8);

		Point3 top, bot;
		for (int r = 0; r < 4; r++) {
			top = tl + (((float)r/3.0f) * (tr - tl));
			bot = bl + (((float)r/3.0f) * (br - bl));
			for (int c = 0; c < 4; c++) {
				NURBSControlVertex ncv;
				ncv.SetPosition(0, bot + (((float)c/3.0f) * (top - bot)));
				ncv.SetWeight(0, 1.0f);
				char bname[40];
				char sname[40];
				strcpy(bname, GetString(IDS_RB_BOX));
				sprintf(sname, "%s%s%02dCV%02d", bname, GetString(IDS_CT_SURF), face, r * 4 + c);
				ncv.SetName(sname);
				surf->SetCV(r, c, ncv);
			}
		}

		for (int k = 0; k < 4; k++) {
			surf->SetUKnot(k, 0.0);
			surf->SetVKnot(k, 0.0);
			surf->SetUKnot(k + 4, 1.0);
			surf->SetVKnot(k + 4, 1.0);
		}

		surf->Renderable(TRUE);
		surf->SetGenerateUVs(genUVs);
		if (height > 0.0f)
			surf->FlipNormals(TRUE);
		else
			surf->FlipNormals(FALSE);

		surf->MatID(faceIDs[face]);

		surf->SetTextureUVs(0, 0, Point2(1.0f, 0.0f));
		surf->SetTextureUVs(0, 1, Point2(0.0f, 0.0f));
		surf->SetTextureUVs(0, 2, Point2(1.0f, 1.0f));
		surf->SetTextureUVs(0, 3, Point2(0.0f, 1.0f));

		char bname[40];
		char sname[40];
		strcpy(bname, GetString(IDS_RB_BOX));
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_SURF), face);
		surf->SetName(sname);
	}

#define NF(s1, s2, s1r, s1c, s2r, s2c) \
	fuse.mSurf1 = (s1); \
	fuse.mSurf2 = (s2); \
	fuse.mRow1 = (s1r); \
	fuse.mCol1 = (s1c); \
	fuse.mRow2 = (s2r); \
	fuse.mCol2 = (s2c); \
	nset.mSurfFuse.Append(1, &fuse);

	NURBSFuseSurfaceCV fuse;

	// Bottom(0) to Back (2)
	NF(0, 2, 3, 3, 3, 0);
	NF(0, 2, 2, 3, 2, 0);
	NF(0, 2, 1, 3, 1, 0);
	NF(0, 2, 0, 3, 0, 0);

	// Top(1) to Back (2)
	NF(1, 2, 0, 3, 3, 3);
	NF(1, 2, 1, 3, 2, 3);
	NF(1, 2, 2, 3, 1, 3);
	NF(1, 2, 3, 3, 0, 3);

	// Bottom(0) to Front (3)
	NF(0, 3, 0, 0, 3, 0);
	NF(0, 3, 1, 0, 2, 0);
	NF(0, 3, 2, 0, 1, 0);
	NF(0, 3, 3, 0, 0, 0);

	// Top(1) to Front (3)
	NF(1, 3, 3, 0, 3, 3);
	NF(1, 3, 2, 0, 2, 3);
	NF(1, 3, 1, 0, 1, 3);
	NF(1, 3, 0, 0, 0, 3);

	// Bottom(0) to Left (4)
	NF(0, 4, 3, 0, 3, 0);
	NF(0, 4, 3, 1, 2, 0);
	NF(0, 4, 3, 2, 1, 0);
	NF(0, 4, 3, 3, 0, 0);

	// Top(1) to Left (4)
	NF(1, 4, 0, 0, 3, 3);
	NF(1, 4, 0, 1, 2, 3);
	NF(1, 4, 0, 2, 1, 3);
	NF(1, 4, 0, 3, 0, 3);

	// Bottom(0) to Right (5)
	NF(0, 5, 0, 0, 0, 0);
	NF(0, 5, 0, 1, 1, 0);
	NF(0, 5, 0, 2, 2, 0);
	NF(0, 5, 0, 3, 3, 0);

	// Top(1) to Right (5)
	NF(1, 5, 3, 0, 0, 3);
	NF(1, 5, 3, 1, 1, 3);
	NF(1, 5, 3, 2, 2, 3);
	NF(1, 5, 3, 3, 3, 3);

	// Front (3)  to Right (5)
	NF(3, 5, 3, 1, 0, 1);
	NF(3, 5, 3, 2, 0, 2);

	// Right (5) to Back (2)
	NF(5, 2, 3, 1, 0, 1);
	NF(5, 2, 3, 2, 0, 2);

	// Back (2) to Left (4)
	NF(2, 4, 3, 1, 0, 1);
	NF(2, 4, 3, 2, 0, 2);

	// Left (4) to Front (3)
	NF(4, 3, 3, 1, 0, 1);
	NF(4, 3, 3, 2, 0, 2);


	Matrix3 mat;
	mat.IdentityMatrix();
	Object *obj = CreateNURBSObject(NULL, &nset, mat);
	return obj;
}

#endif



Object* BoxObject::ConvertToType(TimeValue t, Class_ID obtype)
{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float length, width, height;
		int genUVs;
		pblock->GetValue(PB_LENGTH,t,length,valid);
		pblock->GetValue(PB_WIDTH,t,width,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildBoxPatch(ob->patch,width,length,height,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	}

#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float length, width, height;
		int genUVs;
		pblock->GetValue(PB_LENGTH,t,length,valid);
		pblock->GetValue(PB_WIDTH,t,width,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSBox(width, length, height, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	}
#endif

	if (obtype == polyObjectClassID) {
		Object *ob = BuildPolyBox (t);
		ob->UnlockObject ();
		return ob;
	}

#ifdef DESIGN_VER
	if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		float length, width, height;
		pblock->GetValue(PB_LENGTH,t,length,valid);
		pblock->GetValue(PB_WIDTH,t,width,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		Point3 p(width, length, height);
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = cacheptr->createBox(p);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif

	return SimpleObject::ConvertToType(t,obtype);
}

int BoxObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==patchObjectClassID) return 1;
#ifndef NO_NURBS
	if (obtype==EDITABLE_SURF_CLASS_ID) return 1;
#endif
	if (obtype==polyObjectClassID) return 1;
#ifdef DESIGN_VER
	if(obtype == GENERIC_AMSOLID_CLASS_ID)
		return 1;
#endif
	return SimpleObject::CanConvertToType(obtype);
	}

void BoxObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);

#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}

class BoxObjCreateCallBack: public CreateMouseCallBack {
	BoxObject *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1;
	BOOL square;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(BoxObject *obj) { ob = obj; }
	};

int BoxObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;
	if (msg == MOUSE_FREEMOVE)
	{
				vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
	}

	else if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->pblock->SetValue(PB_WIDTH,0,0.0f);
				ob->pblock->SetValue(PB_LENGTH,0,0.0f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.0f);
				ob->suspendSnap = TRUE;								
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
#ifdef BOTTOMPIV
				{
				Point3 xyz = mat.GetTrans();
				xyz.z = p0.z;
				mat.SetTrans(xyz);
				}
#endif
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				p1.z = p0.z +(float).01; 
				if (ob->createMeth || (flags&MOUSE_CTRL)) {
					mat.SetTrans(p0);
				} else {
					mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV 					
					Point3 xyz = mat.GetTrans();
					xyz.z = p0.z;
					mat.SetTrans(xyz);					
					}
#endif
				d = p1-p0;
				
				square = FALSE;
				if (ob->createMeth) {
					// Constrain to cube
					d.x = d.y = d.z = Length(d)*2.0f;
				} else 
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					square = TRUE;
					}

				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_HEIGHT,0,float(fabs(d.z)));
				ob->pmapParam->Invalidate();										

				if (msg==MOUSE_POINT && ob->createMeth) {
					ob->suspendSnap = FALSE;
					return (Length(sp1-sp0)<3)?CREATE_ABORT:CREATE_STOP;					
				} else if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) {
					return CREATE_ABORT;
					}
				break;
			case 2:
#ifdef _OSNAP
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p0,Point3(0,0,1),sp1,m,TRUE));
#else
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
#endif				
				if (!square) {
					mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV
					mat.SetTrans(2,p0.z); // set the Z component of translation
#endif
					}

				d = p1-p0;
				if (square) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;					
					}

				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_HEIGHT,0,float(d.z));
				ob->pmapParam->Invalidate();				
					
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;					
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static BoxObjCreateCallBack boxCreateCB;

CreateMouseCallBack* BoxObject::GetCreateMouseCallBack() {
	boxCreateCB.SetObj(this);
	return(&boxCreateCB);
	}


BOOL BoxObject::OKtoDisplay(TimeValue t) 
	{
	/*
	float l, w, h;
	pblock->GetValue(PB_LENGTH,t,l,FOREVER);
	pblock->GetValue(PB_WIDTH,t,w,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,h,FOREVER);
	if (l==0.0f || w==0.0f || h==0.0f) return FALSE;
	else return TRUE;
	*/
	return TRUE;
	}


// From ParamArray
BOOL BoxObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: createMeth = v; break;
		}		
	return TRUE;
	}

BOOL BoxObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH:  crtWidth = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL BoxObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL BoxObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = createMeth; break;
		}
	return TRUE;
	}

BOOL BoxObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {				
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH:  v = crtWidth; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL BoxObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void BoxObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *BoxObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:return stdWorldDim;
		case PB_WIDTH: return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_LSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;		
		default: return defaultDim;
		}
	}

TSTR BoxObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH: return TSTR(GetString(IDS_RB_LENGTH));
		case PB_WIDTH:  return TSTR(GetString(IDS_RB_WIDTH));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_LSEGS:  return TSTR(GetString(IDS_RB_LSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle BoxObject::Clone(RemapDir& remap) 
{
	BoxObject* newob = new BoxObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
}

void MakePQuad (MNFace *mf, int v1, int v2, int v3, int v4, DWORD smG, MtlID mt, int bias) {
	int vv[4];
	vv[0] = v1;
	vv[1+bias] = v2;
	vv[2] = v3;
	vv[3-bias] = v4;
	mf->MakePoly (4, vv);
	mf->smGroup = smG;
	mf->material = mt;
}

// Face materials:
/*
#define MAT_TOP 0
#define MAT_BOTTOM 1
#define MAT_LEFT 2
#define MAT_RIGHT 3
#define MAT_FRONT 4
#define MAT_BACK 5

#define SMG_TOP (1<<1)
#define SMG_BOTTOM (1<<2)
#define SMG_LEFT (1<<6)
#define SMG_RIGHT (1<<4)
#define SMG_FRONT (1<<3)
#define SMG_BACK (1<<5)
*/

#define MAKE_TOP_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<1),0,bias)
#define MAKE_BOTTOM_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<2),1,bias)
#define MAKE_LEFT_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<6),2,bias)
#define MAKE_RIGHT_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<4),3,bias)
#define MAKE_FRONT_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<3),4,bias)
#define MAKE_BACK_QUAD(v1,v2,v3,v4) MakePQuad(mm.F(nf++),v1,v2,v3,v4,(1<<5),5,bias)

Object *BoxObject::BuildPolyBox (TimeValue t) {
	PolyObject *pobj = new PolyObject;
	MNMesh & mm = pobj->mm;
	int wsegs, lsegs, hsegs;
	float l, w, h;
	int genUVs = 1;
	int bias = 0;

	// Start the validity interval at forever and widdle it down.
	Interval gValid, tValid;
	tValid.SetInfinite();
	pblock->GetValue(PB_LSEGS,t,lsegs,tValid);
	pblock->GetValue(PB_WSEGS,t,wsegs,tValid);
	pblock->GetValue(PB_HSEGS,t,hsegs,tValid);
	pblock->GetValue(PB_GENUVS,t,genUVs,tValid);
	LimitValue(lsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);

	gValid = tValid;
	pblock->GetValue(PB_LENGTH,t,l,gValid);
	pblock->GetValue(PB_WIDTH,t,w,gValid);
	pblock->GetValue(PB_HEIGHT,t,h,gValid);
	if (h<0.0f) bias = 2;

	DWORD tParts = genUVs ? PART_TOPO|PART_TEXMAP : PART_TOPO;
	DWORD otherStuff = OBJ_CHANNELS & ~(PART_GEOM|tParts);
	pobj->SetPartValidity (otherStuff, FOREVER);
	pobj->SetPartValidity (PART_GEOM, gValid);
	pobj->SetPartValidity (tParts, tValid);

	// Number of verts
      // bottom : (lsegs+1)*(wsegs+1)
	  // top    : (lsegs+1)*(wsegs+1)
	  // sides  : (2*lsegs+2*wsegs)*(hsegs-1)

	// Number of rectangular faces.
      // bottom : (lsegs)*(wsegs)
	  // top    : (lsegs)*(wsegs)
	  // sides  : 2*(hsegs*lsegs)+2*(wsegs*lsegs)

	mm.Clear();

	int wsp1 = wsegs + 1;
	int nlayer = 2*(lsegs+wsegs);
	int topStart = (lsegs+1)*(wsegs+1);
	int midStart = 2*topStart;

	int nverts = midStart+nlayer*(hsegs-1);
	int nfaces = 2*(lsegs*wsegs + hsegs*lsegs + wsegs*hsegs);

	mm.setNumVerts(nverts);
	mm.setNumFaces(nfaces);
	mm.InvalidateTopoCache();

	int nv = 0;
	
	Point3 vb(w/2.0f,l/2.0f,h);
	Point3 va(-vb.x, -vb.y, 0.0f);

	float dx = w/wsegs;
	float dy = l/lsegs;
	float dz = h/hsegs;

	// do bottom vertices.
	Point3 p;
	p.z = va.z;
	p.y = va.y;
	int ix, iy, iz;
	for (iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mm.P(nv) = p;
			nv++;
			p.x += dx;
		}
		p.y += dy;
	}

	int kv, nf = 0;

	// do bottom faces.
	for (iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		for (ix=0; ix<wsegs; ix++) {
			MAKE_BOTTOM_QUAD(kv,kv+wsegs+1,kv+wsegs+2,kv+1);
			kv++;
		}
	}
	assert(nf==lsegs*wsegs);

	// do top vertices.
	p.z = vb.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mm.P(nv) = p;
			p.x += dx;
			nv++;
		}
		p.y += dy;
	}

	// do top faces (lsegs*wsegs);
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1)+topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_TOP_QUAD(kv,kv+1,kv+wsegs+2,kv+wsegs+1);
			kv++;
		}
	}
	assert(nf==lsegs*wsegs*2);

	// do middle vertices
	for(iz=1; iz<hsegs; iz++) {
		p.z = va.z + dz * iz;
		// front edge
		p.x = va.x;  p.y = va.y;
		for (ix=0; ix<wsegs; ix++) { mm.P(nv)=p; p.x += dx; nv++; }
		// right edge
		p.x = vb.x;	  p.y = va.y;
		for (iy=0; iy<lsegs; iy++) { mm.P(nv)=p; p.y += dy; nv++; }
		// back edge
		p.x =  vb.x;  p.y =  vb.y;
		for (ix=0; ix<wsegs; ix++) { mm.P(nv)=p; p.x -= dx; nv++; }
		// left edge
		p.x = va.x;  p.y =  vb.y;
		for (iy=0; iy<lsegs; iy++) { mm.P(nv)=p; p.y -= dy; nv++; }
	}

	int mv;
	if (hsegs==1) {
		// do FRONT faces -----------------------
		kv = 0;
		mv = topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_FRONT_QUAD (kv, kv+1, mv+1, mv);
			kv++;
			mv++;
		}

		// do RIGHT faces.-----------------------
		kv = wsegs;  
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_RIGHT_QUAD(kv, kv+wsp1, mv+wsp1, mv);
			kv += wsp1;
			mv += wsp1;
		}	

		// do BACK faces.-----------------------
		kv = topStart - 1;
		mv = midStart - 1;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_BACK_QUAD(kv, kv-1, mv-1, mv);
			kv --;
			mv --;
		}

		// do LEFT faces.----------------------
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_LEFT_QUAD(kv, kv-wsp1, mv-wsp1, mv);
			kv -= wsp1;
			mv -= wsp1;
		}
	} else {
		// do FRONT faces.
		kv = 0;
		mv = midStart;
		for(iz=0; iz<hsegs; iz++) {
			if (iz==hsegs-1) mv = topStart;
			for (ix=0; ix<wsegs; ix++) 
				MAKE_FRONT_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix);
			kv = mv;
			mv += nlayer;
		}

		assert(nf==lsegs*wsegs*2 + wsegs*hsegs);
	 
		// do RIGHT faces.-------------------------
		// RIGHT bottom row:
		kv = wsegs; // into bottom layer. 
		mv = midStart + wsegs; // first layer of mid verts


		for (iy=0; iy<lsegs; iy++) {
			MAKE_RIGHT_QUAD(kv, kv+wsp1, mv+1, mv);
			kv += wsp1;
			mv ++;
		}

		// RIGHT middle part:
		kv = midStart + wsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				MAKE_RIGHT_QUAD(kv+iy, kv+iy+1, mv+iy+1, mv+iy);
			}
			kv += nlayer;
		}

		// RIGHT top row:
		kv = midStart + wsegs + (hsegs-2)*nlayer; 
		mv = topStart + wsegs;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_RIGHT_QUAD(kv, kv+1, mv+wsp1, mv);
			mv += wsp1;
			kv++;
		}
		
		assert(nf==lsegs*wsegs*2 + wsegs*hsegs + lsegs*hsegs);

		// do BACK faces. ---------------------
		// BACK bottom row:
		kv = topStart - 1;
		mv = midStart + wsegs + lsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_BACK_QUAD(kv, kv-1, mv+1, mv);
			kv --;
			mv ++;
		}

		// BACK middle part:
		kv = midStart + wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (ix=0; ix<wsegs; ix++) {
				MAKE_BACK_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix);
			}
			kv += nlayer;
		}

		// BACK top row:
		kv = midStart + wsegs + lsegs + (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1)+wsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_BACK_QUAD(kv, kv+1, mv-1, mv);
			mv --;
			kv ++;
		}

		assert(nf==lsegs*wsegs*2 + wsegs*hsegs*2 + lsegs*hsegs);

		// do LEFT faces. -----------------
		// LEFT bottom row:
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = midStart + 2*wsegs +lsegs;
		for (iy=0; iy<lsegs; iy++) {
			int nextm = mv+1;
			if (iy==lsegs-1) nextm -= nlayer;
			MAKE_LEFT_QUAD(kv, kv-wsp1, nextm, mv);
			kv -=wsp1;
			mv ++;
		}

		// LEFT middle part:
		kv = midStart + 2*wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				int nextm = mv+1;
				int nextk = kv+iy+1;
				if (iy==lsegs-1) { 
					nextm -= nlayer;
					nextk -= nlayer;
				}
				MAKE_LEFT_QUAD(kv+iy, nextk, nextm, mv);
				mv++;
			}
			kv += nlayer;
		}

		// LEFT top row:
		kv = midStart + 2*wsegs + lsegs+ (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1);
		for (iy=0; iy<lsegs; iy++) {
			int nextk = kv+1;
			if (iy==lsegs-1) nextk -= nlayer;
			MAKE_LEFT_QUAD(kv, nextk, mv-wsp1, mv);
			mv -= wsp1;
			kv++;
		}
	}

	/*
	if (genUVs) {
		int ls = lsegs+1;
		int ws = wsegs+1;
		int hs = hsegs+1;
		int ntverts = ls*hs + hs*ws + ws*ls ;
		mm.setNumTVerts( ntverts ) ;
		mesh.setNumTVFaces(nfaces);		

		int xbase = 0;
		int ybase = ls*hs;
		int zbase = ls*hs + hs*ws;
	
		float dw = 1.0f/float(wsegs);
		float dl = 1.0f/float(lsegs);
		float dh = 1.0f/float(hsegs);

		if (w==0.0f) w = .0001f;
		if (l==0.0f) l = .0001f;
		if (h==0.0f) h = .0001f;
		float u,v;

		nv = 0;
		v = 0.0f;
		// X axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f; 
			for (iy =0; iy<ls; iy++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dl;
				}
			v += dh;
			}

		v = 0.0f; 
		//Y Axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f;
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dh;
			}

		v = 0.0f; 
		for (iy =0; iy<ls; iy++) {
			u = 0.0f; 
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dl;
			}

		assert(nv==ntverts);

		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = direction(v);
			int ntv[3];
			for (ix=0; ix<3; ix++) {
				int iu,iv;
				switch(dir) {
					case POSX: case NEGX:
						iu = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f);  
						if (dir==NEGX) iu = lsegs-iu;
						ntv[ix] = (xbase + iv*ls + iu);
						break;
					case POSY: case NEGY:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f); 
						if (dir==POSY) iu = wsegs-iu;
						ntv[ix] = (ybase + iv*ws + iu);
						break;
					case POSZ: case NEGZ:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						if (dir==NEGZ) iu = wsegs-iu;
						ntv[ix] = (zbase + iv*ws + iu);
						break;
					}
			 	}
			assert(ntv[0]<ntverts);
			assert(ntv[1]<ntverts);
			assert(ntv[2]<ntverts);
			
			mesh.tvFace[nf].setTVerts(ntv[0],ntv[1],ntv[2]);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
		}
	} else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++) v[ix] = mesh.getVert(nv[ix]);
			int dir = direction(v);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
		}
	}
 */
	mm.InvalidateGeomCache();
	mm.FillInMesh();
	return (Object *) pobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\circle.cpp ===
/**********************************************************************
 *<
	FILE: circle.cpp

	DESCRIPTION:  A Circle object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 29 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"


#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)

#define DEF_RADIUS		float(0.0)

class CircleObjCreateCallBack;

class CircleObject: public SimpleSpline, public IParamArray {			   

	friend class CircleObjCreateCallBack;
	
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		static float crtRadius;
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		CircleObject();
		~CircleObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_CIRCLE); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_CIRCLE); }		
		Class_ID ClassID() { return Class_ID(CIRCLE_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_CIRCLE_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

 		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }

		// IO
		IOResult Load(ILoad *iload);
	};				

//------------------------------------------------------

class CircleObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new CircleObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_CIRCLE_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
   	Class_ID		ClassID() { return Class_ID(CIRCLE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static CircleObjClassDesc circleObjDesc;

ClassDesc* GetCircleDesc() { return &circleObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for circle class.
IParamMap *CircleObject::pmapCreate = NULL;
IParamMap *CircleObject::pmapParam  = NULL;
IParamMap *CircleObject::pmapTypeIn = NULL;
IObjParam *CircleObject::ip         = NULL;
Point3 CircleObject::crtPos         = Point3(0,0,0);
float CircleObject::crtRadius       = 0.0f;
int CircleObject::dlgCreateMeth = 1; // create_radius

void CircleObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	CircleObject::crtPos          = Point3(0,0,0);
	CircleObject::crtRadius       = 0.0f;
	CircleObject::dlgCreateMeth   = 1; // create_radius
	}

// Parameter map indices
#define PB_RADIUS		0

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2

// Vector length for unit circle
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)
			
	};
#define TYPEINDESC_LENGTH 2

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	};
#define PARAMDESC_LENGTH 1


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 } };		
#define PBLOCK_LENGTH	1

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,2,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class CircleTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		CircleObject *co;

		CircleTypeInDlgProc(CircleObject *c) {co=c;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL CircleTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (co->crtRadius==0.0) return TRUE;

					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (co->TestAFlag(A_OBJ_CREATING)) {
						co->pblock->SetValue(PB_RADIUS,0,co->crtRadius);
						}

					Matrix3 tm(1);
					tm.SetTrans(co->crtPos);
					co->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void CircleObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last circle ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CIRCLEPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CIRCLEPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_CIRCLEPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new CircleTypeInDlgProc(this));
		}
	}
		
void CircleObject::EndEditParams( IObjParam *ip,ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	}

static void MakeCircle(BezierShape& ashape, float radius) {
	float vector = CIRCLE_VECTOR_LENGTH * radius;
	// Delete all points in the existing spline
	Spline3D *spline = ashape.NewSpline();

	// Now add all the necessary points
	for(int ix=0; ix<4; ++ix) {
		float angle = 6.2831853f * (float)ix / 4.0f;
		float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
		Point3 p(cosfac * radius, sinfac * radius, 0.0f);
		Point3 rotvec = Point3(sinfac * vector, -cosfac * vector, 0.0f);
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p + rotvec,p - rotvec));
		}
	spline->SetClosed();
	spline->ComputeBezPoints();
	}

void CircleObject::BuildShape(TimeValue t, BezierShape& ashape) {
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float radius;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	MakeCircle(ashape,radius);
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

CircleObject::CircleObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
 	}

CircleObject::~CircleObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class CircleObjCreateCallBack: public CreateMouseCallBack {
	CircleObject *ob;
	Point3 p[2];
	IPoint2 sp0;
	Point3 center;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(CircleObject *obj) { ob = obj; }
	};

int CircleObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				sp0 = m;
				createType = ob->dlgCreateMeth;
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1: 
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if ( createType ) {	// radius	
					r = Length(p[1]-p[0]);
					center = p[0];
					}
				else {// diameter
					center = (p[0]+p[1]) / 2.0f;
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3 || 
						Length(p[1]-p[0])<0.1f) ? CREATE_ABORT: CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static CircleObjCreateCallBack circleCreateCB;

CreateMouseCallBack* CircleObject::GetCreateMouseCallBack() {
	circleCreateCB.SetObj(this);
	return(&circleCreateCB);
	}

RefTargetHandle CircleObject::Clone(RemapDir& remap) {
	CircleObject* newob = new CircleObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL CircleObject::ValidForDisplay(TimeValue t) {
	float radius;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	return (radius == 0.0f) ? FALSE : TRUE;
	}

ParamDimension *CircleObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR CircleObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return TSTR(GetString(IDS_TH_RADIUS));			
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL CircleObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL CircleObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		}	
	return TRUE;
	}

BOOL CircleObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL CircleObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL CircleObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		}
	return TRUE;
	}

BOOL CircleObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}

IOResult CircleObject::Load(ILoad *iload)
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return SimpleSpline::Load(iload);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\cone.cpp ===
/**********************************************************************
 *<
	FILE: cone.cpp

	DESCRIPTION:  Cone object

	CREATED BY: Rolf Berteig

	HISTORY: created November 11 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"


class ConeObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static int dlgSegments, dlgSides, dlgCapSegments;
		static int dlgCreateMeth;
		static int dlgSmooth;
		static Point3 crtPos;		
		static float crtRadius1;
		static float crtRadius2;
		static float crtHeight;
		
		ConeObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		BOOL IsParamSurface() {return TRUE;}
		Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);
		
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_CONE); }
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(CONE_CLASS_ID,0); }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_PIESLICE	float(-1.0E30)
#define MAX_PIESLICE	float( 1.0E30)

#define DEF_SEGMENTS 	5
#define DEF_SIDES		24

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class ConeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ConeObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_CONE_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(CONE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
	void			ResetClassParams(BOOL fileReset);
	};

static ConeClassDesc coneDesc;

ClassDesc* GetConeDesc() { return &coneDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Cone class.
IObjParam *ConeObject::ip         = NULL;
int ConeObject::dlgSegments       = DEF_SEGMENTS;
int ConeObject::dlgCapSegments    = 1;
int ConeObject::dlgSides          = DEF_SIDES;
int ConeObject::dlgCreateMeth     = 1; // create_radius
int ConeObject::dlgSmooth         = SMOOTH_ON;
IParamMap *ConeObject::pmapCreate = NULL;
IParamMap *ConeObject::pmapTypeIn = NULL;
IParamMap *ConeObject::pmapParam  = NULL;
Point3 ConeObject::crtPos         = Point3(0,0,0);
float ConeObject::crtRadius1      = 0.0f;
float ConeObject::crtRadius2      = 0.0f;
float ConeObject::crtHeight       = 0.0f;

void ConeClassDesc::ResetClassParams(BOOL fileReset)
	{
	ConeObject::dlgSegments     = DEF_SEGMENTS;
	ConeObject::dlgCapSegments  = 1;
	ConeObject::dlgSides        = DEF_SIDES;
	ConeObject::dlgCreateMeth   = 1; // create_radius
	ConeObject::dlgSmooth       = SMOOTH_ON;
	ConeObject::crtRadius1      = 0.0f;
	ConeObject::crtRadius2      = 0.0f;
	ConeObject::crtHeight       = 0.0f;
	ConeObject::crtPos          = Point3(0,0,0);
	}


//--- Parameter map/block descriptors -------------------------------

// Parameter map indices
#define PB_RADIUS1		0
#define PB_RADIUS2		1
#define PB_HEIGHT		2
#define PB_SEGMENTS		3
#define PB_CAPSEGMENTS	4
#define PB_SIDES		5
#define PB_SMOOTH		6
#define PB_SLICEON		7
#define PB_PIESLICE1	8
#define PB_PIESLICE2	9
#define PB_GENUVS		10

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3
#define PB_TI_HEIGHT		4


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RADSPINNER2,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),

	// Height 
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,		
		SPIN_AUTOSCALE)	
	};
#define TYPEINDESC_LENGH 4


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius 1
	ParamUIDesc(
		PB_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Radius 2
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RADSPINNER2,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Height 
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,		
		SPIN_AUTOSCALE),	
	
	// Circle Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Cap Segments
	ParamUIDesc(
		PB_CAPSEGMENTS,
		EDITTYPE_INT,
		IDC_CAPSEGMENTS,IDC_CAPSEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Smooth
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),
	
	// Slice on
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SLICEON),	

	// Pie slice from
	ParamUIDesc(
		PB_PIESLICE1,
		EDITTYPE_FLOAT,
		IDC_PIESLICE1,IDC_PIESLICESPIN1,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),	

	// Pie slice to
	ParamUIDesc(
		PB_PIESLICE2,
		EDITTYPE_FLOAT,
		IDC_PIESLICE2,IDC_PIESLICESPIN2,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),		
	
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 11

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },	
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_BOOL, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 10 } };
#define PBLOCK_LENGTH	11


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,9,0),	
	ParamVersionDesc(descVer1,10,0),	
	};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);



//--- TypeInDlgProc --------------------------------

class ConeTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		ConeObject *ob;

		ConeTypeInDlgProc(ConeObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ConeTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ob->crtRadius1==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS1,0,ob->crtRadius1);
						ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Cone methods -------------------------------

ConeObject::ConeObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
		
	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGMENTS,0,dlgSegments);
	pblock->SetValue(PB_CAPSEGMENTS,0,dlgCapSegments);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_RADIUS1,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);
	}

IOResult ConeObject::Load(ILoad *iload) 
	{	
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}


void ConeObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Cone ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CONEPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CONEPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_CONEPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new ConeTypeInDlgProc(this));
		}
	}
		
void ConeObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
	pblock->GetValue(PB_SEGMENTS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_CAPSEGMENTS,ip->GetTime(),dlgCapSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	}


// In cyl,cpp
extern void BuildCylinderMesh(Mesh &mesh,
		int segs, int smooth, int llsegs, int capsegs, int doPie,
		float radius1, float radius2, float height, float pie1, float pie2,
		int genUVs);



BOOL ConeObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void ConeObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

Point3 ConeObject::GetSurfacePoint(
		TimeValue t, float u, float v,Interval &iv)
	{
	float radius1, radius2, height;
	pblock->GetValue(PB_RADIUS1,t,radius1,iv);
	pblock->GetValue(PB_RADIUS2,t,radius2,iv);
	pblock->GetValue(PB_HEIGHT,t,height,iv);
	Point3 p;
	float sn = -(float)cos(u*TWOPI);
	float cs = (float)sin(u*TWOPI);
	p.x = (1.0f-v)*radius1*cs + v*radius2*cs;
	p.y = (1.0f-v)*radius1*sn + v*radius2*sn;
	p.z = height * v;
	return p;
	}

void ConeObject::BuildMesh(TimeValue t)
	{	
	int segs,llsegs,smooth,capsegs;
	float radius1,radius2,height,pie1, pie2;
	int doPie, genUVs;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,llsegs,ivalid);
	pblock->GetValue(PB_CAPSEGMENTS,t,capsegs,ivalid);
	pblock->GetValue(PB_RADIUS1,t,radius1,ivalid);
	pblock->GetValue(PB_RADIUS2,t,radius2,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);	
	pblock->GetValue(PB_PIESLICE1,t,pie1,ivalid);
	pblock->GetValue(PB_PIESLICE2,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	LimitValue(radius1, MIN_RADIUS, MAX_RADIUS);
	LimitValue(radius2, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(llsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(capsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(smooth, 0, 1);	
	
	BuildCylinderMesh(mesh,
		segs, smooth, llsegs, capsegs, doPie,
		radius1, radius2, height, pie1, pie2, genUVs);
	}

// In cyl,cpp
extern void BuildCylinderPatch(
		TimeValue t, PatchMesh &patch, 
		float radius1, float radius2, float height, int genUVs);




#ifndef NO_NURBS

Object *
BuildNURBSCone(float radius1, float radius2, float height, BOOL sliceon, float pie1, float pie2, BOOL genUVs)
{
	BOOL flip = FALSE;

    if (radius1 == 0.0f)
        radius1 = 0.001f;
    if (radius2 == 0.0f)
        radius2 = 0.001f;

	if (height < 0.0f)
		flip = !flip;

	NURBSSet nset;

	Point3 origin(0,0,0);
	Point3 symAxis(0,0,1);
	Point3 refAxis(0,1,0);

	float startAngle = 0.0f;
	float endAngle = TWOPI;
	if (sliceon && pie1 != pie2) {
		float sweep = TWOPI - (pie2-pie1);
		if (sweep > TWOPI) sweep -= TWOPI;
		refAxis = Point3(Point3(1,0,0) * RotateZMatrix(pie2));
		endAngle = sweep;
	}


	// first the main surface
	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	surf->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
	surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
	surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	surf->FlipNormals(!flip);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_CONE));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));

	if (sliceon && pie1 != pie2) {
		surf->SetName(sname);
		GenNURBSConeSurface(radius1, radius2, height, origin, symAxis, refAxis,
						startAngle, endAngle, TRUE, *surf);

#define F(s1, s2, s1r, s1c, s2r, s2c) \
		fuse.mSurf1 = (s1); \
		fuse.mSurf2 = (s2); \
		fuse.mRow1 = (s1r); \
		fuse.mCol1 = (s1c); \
		fuse.mRow2 = (s2r); \
		fuse.mCol2 = (s2c); \
		nset.mSurfFuse.Append(1, &fuse);

		NURBSFuseSurfaceCV fuse;

		NURBSCVSurface *s0 = (NURBSCVSurface*)nset.GetNURBSObject(0);

		Point3 cen;

		// next the two caps
		for (int c = 0; c < 2; c++) {
			if (c == 0) {
				cen = Point3(0,0,0);
			} else {
				cen = Point3(0.0f, 0.0f, height);
			}
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll be cubic in on direction and match the sphere in the other
			s->SetUOrder(4);
			s->SetNumUKnots(8);
			for (int i = 0; i < 4; i++) {
				s->SetUKnot(i, 0.0);
				s->SetUKnot(i+4, 1.0);
			}

			s->SetVOrder(s0->GetVOrder());
			s->SetNumVKnots(s0->GetNumVKnots());
			for (i = 0; i < s->GetNumVKnots(); i++)
				s->SetVKnot(i, s0->GetVKnot(i));

			int numU, numV;
			s0->GetNumCVs(numU, numV);
			s->SetNumCVs(4, numV);

			for (int v = 0; v < numV; v++) {
				Point3 edge;
				if (c == 0)
					edge = s0->GetCV(0, v)->GetPosition(0);
				else
					edge = s0->GetCV(numU-1, v)->GetPosition(0);
				double w = s0->GetCV(0, v)->GetWeight(0);
				for (int u = 0; u < 4; u++) {
					NURBSControlVertex ncv;
					ncv.SetPosition(0, cen + ((edge - cen)*((float)u/3.0f)));
					ncv.SetWeight(0, w);
					s->SetCV(u, v, ncv);
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(1.0f, 1.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));

			if (c == 0)
				s->FlipNormals(!flip);
			else
				s->FlipNormals(flip);
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), c+1);
			s->SetName(sname);
		}

		NURBSCVSurface *s1 = (NURBSCVSurface *)nset.GetNURBSObject(1);
		NURBSCVSurface *s2 = (NURBSCVSurface *)nset.GetNURBSObject(2);

		// next the two pie slices
		for (c = 0; c < 2; c++) {
			if (c == 0)
				cen = Point3(0,0,0);
			else
				cen = Point3(0.0f, 0.0f, height);
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll match the cylinder in on dimention and the caps in the other.
			s->SetUOrder(s0->GetUOrder());
			int numKnots = s0->GetNumUKnots();
			s->SetNumUKnots(numKnots);
			for (int i = 0; i < numKnots; i++)
				s->SetUKnot(i, s0->GetUKnot(i));

			s->SetVOrder(s1->GetUOrder());
			numKnots = s1->GetNumUKnots();
			s->SetNumVKnots(numKnots);
			for (i = 0; i < numKnots; i++)
				s->SetVKnot(i, s1->GetUKnot(i));

			int s0u, s0v, s1u, s1v, s2u, s2v;
			s0->GetNumCVs(s0u, s0v);
			s1->GetNumCVs(s1u, s1v);
			s2->GetNumCVs(s2u, s2v);
			int uNum = s0u, vNum = s1u;
			s->SetNumCVs(uNum, vNum);
			for (int v = 0; v < vNum; v++) {
				for (int u = 0; u < uNum; u++) {
					// we get get the ends from the caps and the edge from the main sheet
					if (u == 0) {  // bottom
						if (c == 0) {
							s->SetCV(u, v, *s1->GetCV(v, 0));
							F(1, 3, v, 0, u, v);
						} else {
							s->SetCV(u, v, *s1->GetCV(v, s1v-1));
							F(1, 4, v, s1v-1, u, v);
						}
					} else if (u == uNum-1) { // top
						if (c == 0) {
							s->SetCV(u, v, *s2->GetCV(v, 0));
							F(2, 3, v, 0, u, v);
						} else {
							s->SetCV(u, v, *s2->GetCV(v, s2v-1));
							F(2, 4, v, s2v-1, u, v);
						}
					} else { // middle
						if (v == vNum-1) { // outer edge
							if (c == 0) {
								s->SetCV(u, v, *s0->GetCV(u, 0));
								F(0, 3, u, 0, u, v);
							} else {
								s->SetCV(u, v, *s0->GetCV(u, s0v-1));
								F(0, 4, u, s0v-1, u, v);
							}
						} else { // inside
							float angle;
							if (c == 0) angle = pie2;
							else angle = pie1;
							float hrad1 = radius1 * (float)v / (float)(vNum-1);
							float hrad2 = radius2 * (float)v / (float)(vNum-1);
							float rad = hrad1 + ((hrad2 - hrad1) * (float)u / (float)(uNum-1));
							NURBSControlVertex ncv;
							ncv.SetPosition(0, Point3(rad, 0.0f, height * (float)u / (float)(uNum-1)) * RotateZMatrix(angle));
							ncv.SetWeight(0, 1.0f);
							s->SetCV(u, v, ncv);
						}
					}
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

			if (c == 0)
				s->FlipNormals(!flip);
			else
				s->FlipNormals(flip);
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_SLICE), c+1);
			s->SetName(sname);
		}

		NURBSCVSurface *s3 = (NURBSCVSurface *)nset.GetNURBSObject(3);
		NURBSCVSurface *s4 = (NURBSCVSurface *)nset.GetNURBSObject(4);

		// now fuse up the rest
		// Fuse the edges
		for (int v = 0; v < s0->GetNumVCVs(); v++) {
			F(0, 1, 0, v, s1->GetNumUCVs()-1, v);
			F(0, 2, s0->GetNumUCVs()-1, v, s2->GetNumUCVs()-1, v);
		}

		// Fuse the cap centers
		for (v = 1; v < s1->GetNumVCVs(); v++) {
			F(1, 1, 0, 0, 0, v);
			F(2, 2, 0, 0, 0, v);
		}

		// Fuse the core
		for (int u = 0; u < s3->GetNumUCVs(); u++) {
			F(3, 4, u, 0, u, 0);
		}
	} else {
		GenNURBSConeSurface(radius1, radius2, height, origin, symAxis, refAxis,
					startAngle, endAngle, FALSE, *surf);

		// now create caps on the ends
		if (radius1 != 0.0) {
			NURBSCapSurface *cap0 = new NURBSCapSurface();
			nset.AppendObject(cap0);
			cap0->SetGenerateUVs(genUVs);
			cap0->SetParent(0);
			cap0->SetEdge(0);
			cap0->FlipNormals(!flip);
			cap0->Renderable(TRUE);
			char sname[80];
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
			cap0->SetName(sname);
		}

		if (radius2 != 0.0) {
			NURBSCapSurface *cap1 = new NURBSCapSurface();
			nset.AppendObject(cap1);
			cap1->SetGenerateUVs(genUVs);
			cap1->SetParent(0);
			cap1->SetEdge(1);
			cap1->FlipNormals(flip);
			cap1->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 1);
			cap1->SetName(sname);
		}
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

#endif



Object* ConeObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius1, radius2, height;
		int genUVs;
		pblock->GetValue(PB_RADIUS1,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		PatchObject *ob = new PatchObject();
		BuildCylinderPatch(t,ob->patch,radius1,radius2,height,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 

#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius1, radius2, height, pie1, pie2;
		int sliceon, genUVs;
		pblock->GetValue(PB_RADIUS1,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		Object *ob = BuildNURBSCone(radius1, radius2, height, sliceon, pie1, pie2, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
		
	}
#endif

#ifdef DESIGN_VER
	if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		float radius1, radius2, height, pie1, pie2;
		int sliceon, genUVs, sides;
		pblock->GetValue(PB_RADIUS1,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		pblock->GetValue(PB_SIDES,t,sides,valid);
		int smooth;
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = cacheptr->createCone(height, radius1, radius2, sides, smooth);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif
	else {
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int ConeObject::CanConvertToType(Class_ID obtype)
	{
#ifdef DESIGN_VER
	if(obtype == GENERIC_AMSOLID_CLASS_ID)
		return 1;
#endif
	if (obtype==patchObjectClassID || obtype==defObjectClassID
		|| obtype==triObjectClassID) {
		return 1;
	}
#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID )
        return 1;
#endif
    return SimpleObject::CanConvertToType(obtype);
	}

void ConeObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}


class ConeObjCreateCallBack: public CreateMouseCallBack {
	ConeObject *ob;	
	Point3 p[4];
	IPoint2 sp0,sp1,sp2,sp3;	
	float r1;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(ConeObject *obj) { ob = obj; }
	};

int ConeObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				#ifdef _3D_CREATE	
					p[0] = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p[0] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RADIUS1,0,0.01f);
				ob->pblock->SetValue(PB_RADIUS2,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				#ifdef _3D_CREATE	
					p[1] = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p[1] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS1,0,r);
				ob->pblock->SetValue(PB_RADIUS2,0,r+1.0f);
				ob->pmapParam->Invalidate();
				r1 = r;

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 || 
						Length(p[1]-p[0]) < 0.1f) {						
						return CREATE_ABORT;
						}
					}
				break;
			
			case 2: {
				sp2 = m;
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();				
				}
				break;

			case 3:
				r = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp2,m))
						+ r1;				
				ob->pblock->SetValue(PB_RADIUS2,0,r);
				ob->pmapParam->Invalidate();
				
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				break;			
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static ConeObjCreateCallBack coneCreateCB;

CreateMouseCallBack* ConeObject::GetCreateMouseCallBack() 
	{
	coneCreateCB.SetObj(this);
	return(&coneCreateCB);
	}

BOOL ConeObject::OKtoDisplay(TimeValue t) 
	{
	float radius1, radius2;
	pblock->GetValue(PB_RADIUS1,t,radius1,FOREVER);
	pblock->GetValue(PB_RADIUS2,t,radius2,FOREVER);
	if (radius1==0.0f && radius2==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL ConeObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL ConeObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL ConeObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL ConeObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL ConeObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL ConeObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void ConeObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *ConeObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
		case PB_RADIUS2: 		return stdWorldDim;
		case PB_HEIGHT: 		return stdWorldDim;
		case PB_SEGMENTS: 		return stdSegmentsDim;
		case PB_CAPSEGMENTS:	return stdSegmentsDim;
		case PB_SIDES: 			return stdSegmentsDim;
		case PB_SMOOTH: 		return stdNormalizedDim;
		case PB_SLICEON: 		return stdNormalizedDim;
		case PB_PIESLICE1: 		return stdAngleDim;
		case PB_PIESLICE2: 		return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR ConeObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:	 	return GetString(IDS_RB_RADIUS1);
		case PB_RADIUS2: 		return GetString(IDS_RB_RADIUS2);
		case PB_HEIGHT: 		return GetString(IDS_RB_HEIGHT);
		case PB_SEGMENTS:		return GetString(IDS_RB_CIRCLESEGMENTS);
		case PB_CAPSEGMENTS:	return GetString(IDS_RB_CAPSEGMENTS);
		case PB_SIDES: 			return GetString(IDS_RB_SIDES);
		case PB_SMOOTH: 		return GetString(IDS_RB_SMOOTH);
		case PB_SLICEON: 		return GetString(IDS_RB_SLICEON);
		case PB_PIESLICE1: 		return GetString(IDS_RB_SLICEFROM);
		case PB_PIESLICE2: 		return GetString(IDS_RB_SLICETO);
		//case PB_GENUVS:			return GetString(IDS_RB_GENTEXCOORDS);
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle ConeObject::Clone(RemapDir& remap) 
	{
	ConeObject* newob = new ConeObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\ellipse.cpp ===
/**********************************************************************
 *<
	FILE: rectangl.cpp

	DESCRIPTION:  An rectangular spline object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"


#define MIN_LENGTH		float(0)
#define MAX_LENGTH		float( 1.0E30)
#define MIN_WIDTH		float(0)
#define MAX_WIDTH		float( 1.0E30)

#define DEF_LENGTH		float(0.0)
#define DEF_WIDTH		float(0.0)

#define CREATE_EDGE 0
#define CREATE_CENTER 1

class EllipseObjCreateCallBack;

class EllipseObject: public SimpleSpline, public IParamArray {			   
		friend class EllipseObjCreateCallBack;

	public:	
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		static float crtLength;
		static float crtWidth;
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		EllipseObject();
		~EllipseObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_ELLIPSE); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_ELLIPSE); }		
		Class_ID ClassID() { return Class_ID(ELLIPSE_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_ELLIPSE_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class EllipseObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new EllipseObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_ELLIPSE_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(ELLIPSE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static EllipseObjClassDesc ellipseObjDesc;

ClassDesc* GetEllipseDesc() { return &ellipseObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IParamMap *EllipseObject::pmapCreate = NULL;
IParamMap *EllipseObject::pmapParam  = NULL;
IParamMap *EllipseObject::pmapTypeIn = NULL;
IObjParam *EllipseObject::ip         = NULL;
int EllipseObject::dlgCreateMeth     = CREATE_EDGE;
Point3 EllipseObject::crtPos         = Point3(0,0,0);
float EllipseObject::crtLength       = 0.0f;
float EllipseObject::crtWidth        = 0.0f;

void EllipseObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	EllipseObject::dlgCreateMeth = CREATE_EDGE;
	EllipseObject::crtPos        = Point3(0,0,0);
	EllipseObject::crtLength     = 0.0f;
	EllipseObject::crtWidth      = 0.0f;
	}

// Parameter map indices
#define PB_LENGTH		0
#define PB_WIDTH		1

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_LENGTH		2
#define PB_TI_WIDTH			3

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEEDGE,IDC_CREATECENTER};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		MIN_LENGTH,MAX_LENGTH,
		SPIN_AUTOSCALE),	

	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE)
			
	};
#define TYPEINDESC_LENGTH 3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		MIN_LENGTH,MAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE)	
	
	};
#define PARAMDESC_LENGTH 2


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 } };
#define PBLOCK_LENGTH	2

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)			// This is a dummy entry!!!
	};
#define NUM_OLDVERSIONS	0	// No old ones yet!

// Current version
#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class EllipseTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		EllipseObject *ro;

		EllipseTypeInDlgProc(EllipseObject *d) {ro=d;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL EllipseTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ro->crtLength==0.0 && ro->crtWidth==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ro->TestAFlag(A_OBJ_CREATING)) {
						ro->pblock->SetValue(PB_LENGTH,0,ro->crtLength);
						ro->pblock->SetValue(PB_WIDTH,0,ro->crtWidth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ro->crtPos);
					ro->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void EllipseObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last shape ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_ELLIPSEPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_ELLIPSEPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_ELLIPSEPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new EllipseTypeInDlgProc(this));
		}
	}
		
void EllipseObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	}

// Vector length for unit circle
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

static void MakeCircle(BezierShape& ashape, float radius, float xmult, float ymult) {
	float vector = CIRCLE_VECTOR_LENGTH * radius;
	// Delete all points in the existing spline
	Spline3D *spline = ashape.NewSpline();
	// Now add all the necessary points
	Point3 mult = Point3(xmult, ymult, 1.0f);
	for(int ix=0; ix<4; ++ix) {
		float angle = 6.2831853f * (float)ix / 4.0f;
		float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
		Point3 p(cosfac * radius, sinfac * radius, 0.0f);
		Point3 rotvec = Point3(sinfac * vector, -cosfac * vector, 0.0f);
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p * mult,(p + rotvec) * mult,(p - rotvec) * mult));
		}
	spline->SetClosed();
	spline->ComputeBezPoints();
	}

void EllipseObject::BuildShape(TimeValue t, BezierShape& ashape) {

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float length;
	float width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	LimitValue( length, MIN_LENGTH, MAX_LENGTH );
	LimitValue( width, MIN_WIDTH, MAX_WIDTH );

	// Delete the existing shape and create a new spline in it
	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	float radius, xmult, ymult;
	if(length < width) {
		radius = width;
		xmult = 1.0f;
		ymult = length / width;
		}
	else
	if(width < length) {
		radius = length;
		xmult = width / length;
		ymult = 1.0f;
		}
	else {
		radius = length;
		xmult = ymult = 1.0f;
		}
	MakeCircle(ashape, radius / 2.0f, xmult, ymult);
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

EllipseObject::EllipseObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);	
 	}

EllipseObject::~EllipseObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class EllipseObjCreateCallBack: public CreateMouseCallBack {
	EllipseObject *ob;
	Point3 p0,p1;
	IPoint2 sp0;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(EllipseObject *obj) { ob = obj; }
	};

int EllipseObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _OSNAP
			vpt->SnapPreview(m,m,NULL, snapdim);
		#endif
	}
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->suspendSnap = TRUE;
				createType = ob->dlgCreateMeth;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1 = p0 + Point3(.01,.01,.0);
				if(createType == CREATE_EDGE)
					mat.SetTrans(float(.5)*(p0+p1));
				else
					mat.SetTrans(p0);
				break;
			case 1: { 
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1.z = p0.z; 
				d = p1-p0;
				float w = float(fabs(d.x));
				float l = float(fabs(d.y));
				if(flags & MOUSE_CTRL) {
					if(createType == CREATE_EDGE) {
						float ysign = (d.y < 0.0f) ? -1.0f : 1.0f;
						mat.SetTrans(float(.5)*(p0+Point3(p1.x,p0.y+ysign*w,0.0f)));
						}
					else {
						mat.SetTrans(p0);
						w = w * 2.0f;
						}
					ob->pblock->SetValue(PB_LENGTH,0,w);
					ob->pblock->SetValue(PB_WIDTH,0,w);
					}
				else {
					if(createType == CREATE_EDGE)
						mat.SetTrans(float(.5)*(p0+p1));
					else {
						mat.SetTrans(p0);
						w = w * 2.0f;
						l = l * 2.0f;
						}
					ob->pblock->SetValue(PB_WIDTH,0,w);
					ob->pblock->SetValue(PB_LENGTH,0,l);
					}
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f) ? CREATE_ABORT: CREATE_STOP;
					}
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static EllipseObjCreateCallBack ellipseCreateCB;

CreateMouseCallBack* EllipseObject::GetCreateMouseCallBack() {
	ellipseCreateCB.SetObj(this);
	return(&ellipseCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle EllipseObject::Clone(RemapDir& remap) {
	EllipseObject* newob = new EllipseObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL EllipseObject::ValidForDisplay(TimeValue t) {
	float length, width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	return (length == 0 || width == 0) ? FALSE : TRUE;
	}

ParamDimension *EllipseObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
		case PB_WIDTH:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR EllipseObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
			return TSTR(GetString(IDS_RB_LENGTH));			
		case PB_WIDTH:
			return TSTR(GetString(IDS_RB_WIDTH));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL EllipseObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL EllipseObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH: crtWidth = v; break;
		}	
	return TRUE;
	}

BOOL EllipseObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL EllipseObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL EllipseObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH: v = crtWidth; break;
		}
	return TRUE;
	}

BOOL EllipseObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\donut.cpp ===
/**********************************************************************
 *<
	FILE: donut.cpp

	DESCRIPTION:  A Donut object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 25 April 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)

#define DEF_RADIUS		float(0.0)

class DonutObjCreateCallBack;

class DonutObject: public SimpleSpline, public IParamArray {			   

	friend class DonutObjCreateCallBack;
	
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		static float crtRadius1, crtRadius2;
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		DonutObject();
		~DonutObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_DONUT); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_DONUT); }		
		Class_ID ClassID() { return Class_ID(DONUT_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_DONUT_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

 		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class DonutObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new DonutObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_DONUT_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
   	Class_ID		ClassID() { return Class_ID(DONUT_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static DonutObjClassDesc donutObjDesc;

ClassDesc* GetDonutDesc() { return &donutObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for donut class.
IParamMap *DonutObject::pmapCreate = NULL;
IParamMap *DonutObject::pmapParam  = NULL;
IParamMap *DonutObject::pmapTypeIn = NULL;
IObjParam *DonutObject::ip         = NULL;
Point3 DonutObject::crtPos         = Point3(0,0,0);
float DonutObject::crtRadius1      = 0.0f;
float DonutObject::crtRadius2      = 0.0f;
int DonutObject::dlgCreateMeth = 1; // create_radius

void DonutObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	DonutObject::crtPos         = Point3(0,0,0);
	DonutObject::crtRadius1     = 0.0f;
	DonutObject::crtRadius2     = 0.0f;
	DonutObject::dlgCreateMeth  = 1; // create_radius
	}

// Parameter map indices
#define PB_RADIUS1		0
#define PB_RADIUS2		1

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3

// Vector length for unit circle
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)
			
	};
#define TYPEINDESC_LENGTH 3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius 1
	ParamUIDesc(
		PB_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Radius 2
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)	
	
	};
#define PARAMDESC_LENGTH 2


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 } };
#define PBLOCK_LENGTH	2

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)			// This is a dummy entry!!!
	};
#define NUM_OLDVERSIONS	0	// No old ones yet!

// Current version
#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class DonutTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		DonutObject *dob;

		DonutTypeInDlgProc(DonutObject *d) {dob=d;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL DonutTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (dob->crtRadius1==0.0 && dob->crtRadius2==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (dob->TestAFlag(A_OBJ_CREATING)) {
						dob->pblock->SetValue(PB_RADIUS1,0,dob->crtRadius1);
						dob->pblock->SetValue(PB_RADIUS2,0,dob->crtRadius2);
						}

					Matrix3 tm(1);
					tm.SetTrans(dob->crtPos);
					dob->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void DonutObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last donut ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_DONUTPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_DONUTPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_DONUTPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);

		
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new DonutTypeInDlgProc(this));
		}
	}
		
void DonutObject::EndEditParams( IObjParam *ip,ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	}

static void MakeCircle(BezierShape& ashape, float radius) {
	float vector = CIRCLE_VECTOR_LENGTH * radius;
	// Delete all points in the existing spline
	Spline3D *spline = ashape.NewSpline();
	// Now add all the necessary points
	for(int ix=0; ix<4; ++ix) {
		float angle = 6.2831853f * (float)ix / 4.0f;
		float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
		Point3 p(cosfac * radius, sinfac * radius, 0.0f);
		Point3 rotvec = Point3(sinfac * vector, -cosfac * vector, 0.0f);
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p + rotvec,p - rotvec));
		}
	spline->SetClosed();
	spline->ComputeBezPoints();
	}

void DonutObject::BuildShape(TimeValue t, BezierShape& ashape) {
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float radius1;
	float radius2;
	pblock->GetValue(PB_RADIUS1, t, radius1, ivalid);
	pblock->GetValue(PB_RADIUS2, t, radius2, ivalid);
	LimitValue( radius1, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );

	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	MakeCircle(ashape,radius1);
	MakeCircle(ashape,radius2);
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

DonutObject::DonutObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS1,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);
 	}

DonutObject::~DonutObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class DonutObjCreateCallBack: public CreateMouseCallBack {
	DonutObject *ob;
	Point3 p[3];
	IPoint2 sp0;
	Point3 center;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(DonutObject *obj) { ob = obj; }
	};

int DonutObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				sp0 = m;
				createType = ob->dlgCreateMeth;
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS1,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1: 
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if ( createType ) {	// radius	
					r = Length(p[1]-p[0]);
					center = p[0];
					}
				else {// diameter
					center = (p[0]+p[1]) / 2.0f;
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				ob->pblock->SetValue(PB_RADIUS1,0,r);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if(Length(m-sp0)<3 || Length(p[1]-p[0])<0.1f) {
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				p[2] = vpt->SnapPoint(m,m,NULL,snapdim);
				r = Length(p[2] - center);
				ob->pblock->SetValue(PB_RADIUS2,0,r);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3) ? CREATE_ABORT : CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static DonutObjCreateCallBack donutCreateCB;

CreateMouseCallBack* DonutObject::GetCreateMouseCallBack() {
	donutCreateCB.SetObj(this);
	return(&donutCreateCB);
	}

RefTargetHandle DonutObject::Clone(RemapDir& remap) {
	DonutObject* newob = new DonutObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL DonutObject::ValidForDisplay(TimeValue t) {
	float radius1, radius2;
	pblock->GetValue(PB_RADIUS1, t, radius1, ivalid);
	pblock->GetValue(PB_RADIUS2, t, radius2, ivalid);
	return (radius1 == 0.0f && radius2 == 0.0f) ? FALSE : TRUE;
	}

ParamDimension *DonutObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
		case PB_RADIUS2:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR DonutObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
			return TSTR(GetString(IDS_TH_RADIUS1));
		case PB_RADIUS2:
			return TSTR(GetString(IDS_TH_RADIUS2));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL DonutObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL DonutObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		}	
	return TRUE;
	}

BOOL DonutObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL DonutObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL DonutObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		}
	return TRUE;
	}

BOOL DonutObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\cyl.cpp ===
/**********************************************************************
 *<
	FILE: cyl.cpp

	DESCRIPTION:  Cylinder object, Revised implementation

	CREATED BY: Rolf Berteig

	HISTORY: created November 11 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"

class CylinderObject : public GenCylinder, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static int dlgSegments, dlgSides, dlgCapSegments;
		static int dlgCreateMeth;
		static int dlgSmooth;
		static Point3 crtPos;		
		static float crtRadius;
		static float crtHeight;
		
		CylinderObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		BOOL IsParamSurface() {return TRUE;}
		Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);
		
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_CYLINDER); }
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID( CYLINDER_CLASS_ID,0); }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

		// From GenCylinder
		void SetParams(float rad, float height, int segs, int sides, int capsegs=1, BOOL smooth=TRUE, 
			BOOL genUV=TRUE, BOOL sliceOn= FALSE, float slice1 = 0.0f, float slice2 = 0.0f);
	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_PIESLICE	float(-1.0E30)
#define MAX_PIESLICE	float( 1.0E30)

#define DEF_SEGMENTS 	5	// 1
#define DEF_SIDES		18	// 24

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class CylClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new CylinderObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_CYLINDER_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(CYLINDER_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static CylClassDesc cylDesc;

ClassDesc* GetCylinderDesc() { return &cylDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Cylinder class.
IObjParam *CylinderObject::ip         = NULL;
int CylinderObject::dlgSegments       = DEF_SEGMENTS;
int CylinderObject::dlgCapSegments    = 1;
int CylinderObject::dlgSides          = DEF_SIDES;
int CylinderObject::dlgCreateMeth     = 1; // create_radius
int CylinderObject::dlgSmooth         = SMOOTH_ON;
IParamMap *CylinderObject::pmapCreate = NULL;
IParamMap *CylinderObject::pmapTypeIn = NULL;
IParamMap *CylinderObject::pmapParam  = NULL;
Point3 CylinderObject::crtPos         = Point3(0,0,0);
float CylinderObject::crtRadius       = 0.0f;
float CylinderObject::crtHeight       = 0.0f;

void CylClassDesc::ResetClassParams(BOOL fileReset)
	{
	CylinderObject::dlgSegments     = DEF_SEGMENTS;
	CylinderObject::dlgCapSegments  = 1;
	CylinderObject::dlgSides        = DEF_SIDES;
	CylinderObject::dlgCreateMeth   = 1; // create_radius
	CylinderObject::dlgSmooth       = SMOOTH_ON;
	CylinderObject::crtRadius       = 0.0f;
	CylinderObject::crtHeight       = 0.0f;
	CylinderObject::crtPos          = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter map indices
#define PB_RADIUS		0
#define PB_HEIGHT		1
#define PB_SEGMENTS		2
#define PB_CAPSEGMENTS	3
#define PB_SIDES		4
#define PB_SMOOTH		5
#define PB_SLICEON		6
#define PB_PIESLICE1	7
#define PB_PIESLICE2	8
#define PB_GENUVS		9

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_HEIGHT		3


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Height 
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,		
		SPIN_AUTOSCALE)	
	};
#define TYPEINDESC_LENGH 3


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Height 
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,		
		SPIN_AUTOSCALE),	
	
	// Circle Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Cap Segments
	ParamUIDesc(
		PB_CAPSEGMENTS,
		EDITTYPE_INT,
		IDC_CAPSEGMENTS,IDC_CAPSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Smooth
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),
	
	// Slice on
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SLICEON),	

	// Pie slice from
	ParamUIDesc(
		PB_PIESLICE1,
		EDITTYPE_FLOAT,
		IDC_PIESLICE1,IDC_PIESLICESPIN1,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),	

	// Pie slice to
	ParamUIDesc(
		PB_PIESLICE2,
		EDITTYPE_FLOAT,
		IDC_PIESLICE2,IDC_PIESLICESPIN2,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),		
	
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 10


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },	
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_BOOL, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, FALSE, 9 } };

#define PBLOCK_LENGTH	10

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,5,0),
	ParamVersionDesc(descVer1,8,1),
	ParamVersionDesc(descVer2,9,2)
	};
#define NUM_OLDVERSIONS	3

// Current version
#define CURRENT_VERSION	3
static ParamVersionDesc curVersion(descVer3,PBLOCK_LENGTH,CURRENT_VERSION);



//--- TypeInDlgProc --------------------------------

class CylTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		CylinderObject *ob;

		CylTypeInDlgProc(CylinderObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL CylTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ob->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Cylinder methods -------------------------------

CylinderObject::CylinderObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer3, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
		
	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGMENTS,0,dlgSegments);
	pblock->SetValue(PB_CAPSEGMENTS,0,dlgCapSegments);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_RADIUS,0,crtRadius);	
	}

IOResult CylinderObject::Load(ILoad *iload) 
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}


void CylinderObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last cylinder ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CYLINDERPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CYLINDERPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_CYLINDERPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new CylTypeInDlgProc(this));
		}
	}
		
void CylinderObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
	pblock->GetValue(PB_SEGMENTS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_CAPSEGMENTS,ip->GetTime(),dlgCapSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	}

void CylinderObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	BOOL genUV, BOOL sliceOn, float slice1, float slice2) {
	pblock->SetValue(PB_RADIUS,0,rad);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_SEGMENTS,0,segs);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_SLICEON,0, sliceOn);
	pblock->SetValue(PB_PIESLICE1,0,slice1);
	pblock->SetValue(PB_PIESLICE2,0,slice2);
	pblock->SetValue(PB_GENUVS,0,genUV);
	}

Point3 CylinderObject::GetSurfacePoint(
		TimeValue t, float u, float v,Interval &iv)
	{
	float radius, height;
	pblock->GetValue(PB_RADIUS,t,radius,iv);
	pblock->GetValue(PB_HEIGHT,t,height,iv);
	Point3 p;
	p.x = (float)cos(u*TWOPI)*radius;
	p.y = (float)sin(u*TWOPI)*radius;
	p.z = height * v;
	return p;
	}

// Cone also uses this function
void BuildCylinderMesh(Mesh &mesh,
		int segs, int smooth, int llsegs, int capsegs, int doPie,
		float radius1, float radius2, float height, float pie1, float pie2,
		int genUVs)
	{
	Point3 p;
	int ix,na,nb,nc,nd,jx,kx, ic = 1;
	int nf=0,nv=0, lsegs;
	float delta,ang, u;	
	float totalPie, startAng = 0.0f;	

	if (doPie) doPie = 1;
	else doPie = 0; 

	lsegs = llsegs-1 + 2*capsegs;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;	

	if (doPie) {
		delta    = totalPie/(float)(segs-1);
		startAng = (height<0) ? pie1 : pie2;	// mjm - 2.16.99
//		startAng = pie2;						// mjm - 2.16.99
	} else {
		delta = (float)2.0*PI/(float)segs;
		}

	if (height<0) delta = -delta;

	int nverts;
	int nfaces;
	if (doPie) {
		nverts = (segs+1)*(lsegs);		
		nfaces = 2*(segs+1)*(lsegs-1) + 2*(segs-1);		
	} else {
		nverts = 2+segs*(lsegs);
		nfaces = 2*segs*(lsegs);	
		}
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags((smooth != 0) | ((doPie != 0) << 1));
	if (0/*genUVs*/) {
		mesh.setNumTVerts(nverts);
		mesh.setNumTVFaces(nfaces);
	} else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		}
	
	// bottom vertex 
	mesh.setVert(nv, Point3(0.0,0.0,0.0));
	//if (genUVs) mesh.setTVert(nv,0.5f,1.0f,0.0f);
	nv++;
		
	// Bottom cap vertices	
	for(ix=0; ix<capsegs; ix++) {
		
		// Put center vertices all the way up
		if (ix && doPie) {
			p.z = height*((float)ic/float(lsegs-1));
			p.x = p.y = 0.0f;
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,0.5f, (float)ic/float(lsegs-1), 0.0f);
			nv++;
			ic++;
			}
		
		p.z = 0.0f;
		u   = float(ix+1)/float(capsegs);
		ang = startAng;
		for (jx = 0; jx<segs; jx++) {			
			p.x = (float)cos(ang)*radius1*u;
			p.y = (float)sin(ang)*radius1*u;	
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,float(jx)/float(segs),1.0f-u,0.0f);
			nv++;
			ang += delta;
			}	
		}

	// Middle vertices 
	for(ix=1; ix<llsegs; ix++) {
			
		// Put center vertices all the way up
		if (doPie) {
			p.z = height*((float)ic/float(lsegs-1));
			p.x = p.y = 0.0f;
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,0.5f, (float)ic/float(lsegs-1), 0.0f);
			nv++;
			ic++;
			}
		
		float   u = float(ix)/float(llsegs);
		float rad = (radius1*(1.0f-u) + radius2*u);
		p.z = height*((float)ix/float(llsegs));
		ang = startAng;
		for (jx = 0; jx<segs; jx++) {
			p.x = (float)cos(ang)*rad;
			p.y = (float)sin(ang)*rad;
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,float(jx)/float(segs),(float)ix/float(llsegs),0.0f);
			nv++;
			ang += delta;
			}	
		}

	// Top cap vertices	
	for(ix=0; ix<capsegs; ix++) {
		
		// Put center vertices all the way up
		if (doPie) {
			p.z = height*((float)ic/float(lsegs-1));
			p.x = p.y = 0.0f;
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,0.5f, (float)ic/float(lsegs-1), 0.0f);
			ic++;
			nv++;
			}
		
		p.z = height;
		u   = 1.0f-float(ix)/float(capsegs);
		ang = startAng;
		for (jx = 0; jx<segs; jx++) {			
			p.x = (float)cos(ang)*radius2*u;		
			p.y = (float)sin(ang)*radius2*u;	
			mesh.setVert(nv, p);
			//if (genUVs) mesh.setTVert(nv,float(jx)/float(segs),u,0.0f);
			nv++;
			ang += delta;
			}	
		}

	/* top vertex */
	if (!doPie) {
		mesh.setVert(nv, (float)0.0, (float)0.0, height);
		//if (genUVs) mesh.setTVert(nv,0.5f,0.0f,0.0f);
		nv++;
		}	

	// Now make faces ---

	// Make bottom cap		

	for(ix=1; ix<=segs - doPie; ++ix) {
		nc=(ix==segs)?1:ix+1;
		if (doPie && ix==1) 
			 mesh.faces[nf].setEdgeVisFlags(capsegs>1,1,1);
		else if (doPie && ix==segs - doPie) 
			 mesh.faces[nf].setEdgeVisFlags(1,1,0);
		else mesh.faces[nf].setEdgeVisFlags(capsegs>1,1,0);
		mesh.faces[nf].setSmGroup(1);
		mesh.faces[nf].setVerts(0,nc,ix);
		mesh.faces[nf].setMatID(1);
		//if (genUVs) mesh.tvFace[nf].setTVerts(0,nc,ix);
		nf++;
		}

	/* Make midsection */
	for(ix=0; ix<lsegs-1; ++ix) {
		if (doPie) {
			jx = ix*(segs+1);
		} else {
			jx=ix*segs+1;
			}
				
		for(kx=0; kx<segs+doPie; ++kx) {			
			DWORD grp = 0;
			int mtlid;
			BOOL inSlice = FALSE;

			if (kx==0 && doPie) {
				mtlid = 3;
				grp = (1<<1);
				inSlice = TRUE;
			} else 
			if (kx==segs) {
				mtlid = 4;
				grp = (1<<2);
				inSlice = TRUE;
			} else
			if (ix < capsegs-1 || ix >= capsegs+llsegs-1) {
				grp = 1;
				mtlid = (ix<capsegs-1)?0:1;
			} else	{		
				mtlid = 2;
				if (smooth) {				
					grp = (1<<3);	
					}			
				}

			na = jx+kx;
			nb = na+segs+doPie;
			nc = (kx==(segs+doPie-1))? jx+segs+doPie: nb+1;
			nd = (kx==(segs+doPie-1))? jx : na+1;			
			mesh.faces[nf].setEdgeVisFlags(0,!inSlice,1);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setVerts(na,nc,nb);
			mesh.faces[nf].setMatID(mtlid);
			//if (genUVs) mesh.tvFace[nf].setTVerts(na,nc,nb);
			nf++;
			mesh.faces[nf].setEdgeVisFlags(!inSlice,1,0);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setVerts(na,nd,nc);
			mesh.faces[nf].setMatID(mtlid);
			//if (genUVs) mesh.tvFace[nf].setTVerts(na,nd,nc);
			nf++;
			}
	 	}

	//Make Top cap 			
	if (doPie) {		
		na = (lsegs-1)*(segs+1);	
		jx = na + 1;
	} else {
		na = mesh.getNumVerts()-1;	
		jx = (lsegs-1)*segs+1;
		}
	for(ix=0; ix<segs-doPie; ++ix) {
		nb = jx+ix;
		nc = (ix==segs-1)? jx: nb+1;		
		if (doPie && ix==0) 
			 mesh.faces[nf].setEdgeVisFlags(1,1,0);
		else if (doPie && ix==segs-doPie-1) 
			 mesh.faces[nf].setEdgeVisFlags(capsegs>1,1,1);
		else mesh.faces[nf].setEdgeVisFlags(capsegs>1,1,0);		
		mesh.faces[nf].setSmGroup( 1);
		mesh.faces[nf].setVerts(na,nb,nc);
		mesh.faces[nf].setMatID(0);
		//if (genUVs) mesh.tvFace[nf].setTVerts(na,nb,nc);
		nf++;
		}

	if (genUVs) {
		Matrix3 tm(1);
		float r = fabs(radius1) > fabs(radius2) ? (float)fabs(radius1) : (float)fabs(radius2);
		float h = height;
		if (r==0.0f) r = 1.0f;
		else r = 1.0f/r;
		if (h==0.0f) h = 1.0f;
		else h = 1.0f/h;
		tm.Scale(Point3(r,r,h));
		tm.RotateZ(HALFPI);
		tm.SetTrans(Point3(0.0f,0.0f,-0.5f));
		mesh.ApplyUVWMap(MAP_CYLINDRICAL,
			1.0f, 1.0f, 1.0f,
			0, 0, 0, 0,
			tm);
		}

	assert(nf==mesh.numFaces);
	assert(nv==mesh.numVerts);
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

BOOL CylinderObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void CylinderObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				

	}

void CylinderObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, llsegs, capsegs;
	float radius,height,pie1, pie2;
	int doPie, genUVs;	

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,llsegs,ivalid);
	pblock->GetValue(PB_CAPSEGMENTS,t,capsegs,ivalid);
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);	
	pblock->GetValue(PB_PIESLICE1,t,pie1,ivalid);
	pblock->GetValue(PB_PIESLICE2,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(llsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(capsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
	
	BuildCylinderMesh(mesh,
		segs, smooth, llsegs, capsegs, doPie,
		radius, radius, height, pie1, pie2, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f

void BuildCylinderPatch(
		TimeValue t, PatchMesh &patch, 
		float radius1, float radius2, float height, int genUVs)
	{
	int nverts = 10;
	int nvecs = 80;
	int npatches = 12;
	patch.setNumVerts(nverts);
	patch.setNumTVerts(genUVs ? 12 : 0);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);	
	patch.setNumTVPatches(genUVs ? 12 : 0);

	// Center of base
	patch.setVert(0, 0.0f, 0.0f, 0.0f);
	
	// Base
	patch.setVert(1, radius1, 0.0f, 0.0f);
	patch.setVert(2, 0.0f, radius1, 0.0f);
	patch.setVert(3, -radius1, 0.0f, 0.0f);
	patch.setVert(4, 0.0f, -radius1, 0.0f);

	// Center of top
	patch.setVert(5, 0.0f, 0.0f, height);

	// Top
	patch.setVert(6, radius2, 0.0f, height);
	patch.setVert(7, 0.0f, radius2, height);
	patch.setVert(8, -radius2, 0.0f, height);
	patch.setVert(9, 0.0f, -radius2, height);

	// Tangents	
	Point3 vecs[] = {
		Point3(0.0f, CIRCLE_VECTOR_LENGTH,  0.0f),
		Point3(-CIRCLE_VECTOR_LENGTH, 0.0f, 0.0f),
		Point3(0.0f, -CIRCLE_VECTOR_LENGTH,  0.0f),
		Point3(CIRCLE_VECTOR_LENGTH, 0.0f, 0.0f)};
	
	float len = 1.0f/3.0f;
	Point3 vecs2[] = {
		Point3(0.0f, len,  0.0f),
		Point3(-len, 0.0f, 0.0f),
		Point3(0.0f, -len,  0.0f),
		Point3( len, 0.0f, 0.0f)};
	
	float rr = (radius1-radius2)/3.0f;
	float hh = height/3.0f;
	Point3 hvecs1[] = {
		Point3( -rr, 0.0f, hh),
		Point3( 0.0f, -rr, hh),
		Point3( rr, 0.0f, hh),
		Point3( 0.0f, rr, hh)};
	Point3 hvecs2[] = {
		Point3( rr, 0.0f, -hh),
		Point3( 0.0f, rr, -hh),
		Point3( -rr, 0.0f, -hh),
		Point3( 0.0f, -rr, -hh)};

	int ix=0;
	for (int j=0; j<4; j++) {
		patch.setVec(ix++,patch.verts[0] + vecs2[j]*radius1);
		}
	for (int i=0; i<4; i++) {		
		patch.setVec(ix++,patch.verts[i+1] + vecs[(i)%4]*radius1);
		patch.setVec(ix++,patch.verts[i+1] + vecs2[(1+i)%4]*radius1);
		patch.setVec(ix++,patch.verts[i+1] + vecs[(2+i)%4]*radius1);		
		patch.setVec(ix++,patch.verts[i+1] + hvecs1[i]);
		}
	for (j=0; j<4; j++) {
		patch.setVec(ix++,patch.verts[5] + vecs2[j]*radius2);
		}
	for (i=0; i<4; i++) {
		patch.setVec(ix++,patch.verts[i+6] + vecs[(i)%4]*radius2);
		patch.setVec(ix++,patch.verts[i+6] + vecs2[(1+i)%4]*radius2);
		patch.setVec(ix++,patch.verts[i+6] + vecs[(2+i)%4]*radius2);		
		patch.setVec(ix++,patch.verts[i+6] + hvecs2[i]);
		}	
	
#define Tang(vv,ii) ((vv)*4+(ii))
	
	// Build the patches
	int interior = 40;
	for (i=0; i<4; i++) {
		patch.patches[i].SetType(PATCH_QUAD);
		patch.patches[i].setVerts(i+6, i+1, (i+1)%4+1, (i+1)%4+6);		
		patch.patches[i].setVecs(
			Tang(i+6,3), Tang(i+1,3), 
			Tang(i+1,0), Tang((i+1)%4+1,2), 
			Tang((i+1)%4+1,3), Tang((i+1)%4+6,3), 
			Tang((i+1)%4+6,2), Tang(i+6,0));
		patch.patches[i].setInteriors(interior,interior+1,interior+2,interior+3);
		patch.patches[i].smGroup = 1;
//watje 3-17-99 to support patch matids
		patch.patches[i].setMatID(2);

		interior += 4;
		}
	
	for (i=0; i<4; i++) {
		patch.patches[i+4].SetType(PATCH_TRI);
		patch.patches[i+4].setVerts(0,(i+1)%4+1,i+1);
		patch.patches[i+4].setVecs(
			Tang(0,i),Tang((i+1)%4+1,1),
			Tang((i+1)%4+1,2),Tang(i+1,0),
			Tang(i+1,1),Tang(0,(i+3)%4));
		patch.patches[i+4].setInteriors(interior,interior+1,interior+2);
		patch.patches[i].smGroup = 2;
//watje 3-17-99 to support patch matids
		patch.patches[i+4].setMatID(1);

		interior += 3;		
		}

	for (i=0; i<4; i++) {
		patch.patches[i+8].SetType(PATCH_TRI);
		patch.patches[i+8].setVerts(5,i+6,(i+1)%4+6);
		patch.patches[i+8].setVecs(
			Tang(5,(i+3)%4),Tang(i+6,1),
			Tang(i+6,0),Tang((i+1)%4+6,2),
			Tang((i+1)%4+6,1),Tang(5,i));			
		patch.patches[i+8].setInteriors(interior,interior+1,interior+2);
		patch.patches[i].smGroup = 2;
//watje 3-17-99 to support patch matids
		patch.patches[i+8].setMatID(0);

		interior += 3;
		}

	if(genUVs) {
		Matrix3 tm(1);
		float r = fabs(radius1) > fabs(radius2) ? (float)fabs(radius1) : (float)fabs(radius2);
		float h = height;
		if (r==0.0f) r = 1.0f;
		else r = 1.0f/r;
		if (h==0.0f) h = 1.0f;
		else h = 1.0f/h;
		tm.Scale(Point3(r,r,h));
		tm.RotateZ(HALFPI);
		tm.SetTrans(Point3(0.0f,0.0f,-0.5f));
		patch.ApplyUVWMap(MAP_CYLINDRICAL,
			1.0f, 1.0f, 1.0f,
			0, 0, 0, 0,
			tm);
		}
	
	assert(patch.buildLinkages());
	patch.computeInteriors();
	patch.InvalidateGeomCache();
	}


#ifndef NO_NURBS

Object *
BuildNURBSCylinder(float radius, float height, BOOL sliceon, float pie1, float pie2, BOOL genUVs)
{
	BOOL flip = FALSE;

	if (height < 0.0f)
		flip = !flip;

	NURBSSet nset;

	Point3 origin(0,0,0);
	Point3 symAxis(0,0,1);
	Point3 refAxis(0,1,0);

	float startAngle = 0.0f;
	float endAngle = TWOPI;
	if (sliceon && pie1 != pie2) {
		float sweep = TWOPI - (pie2-pie1);
		if (sweep > TWOPI) sweep -= TWOPI;
		refAxis = Point3(Point3(1,0,0) * RotateZMatrix(pie2));
		endAngle = sweep;
	}


	// first the main surface
	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	surf->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
	surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
	surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	surf->FlipNormals(!flip);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_CYLINDER));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);

	if (sliceon && pie1 != pie2) {
		GenNURBSCylinderSurface(radius, height, origin, symAxis, refAxis,
						startAngle, endAngle, TRUE, *surf);

		NURBSCVSurface *s0 = (NURBSCVSurface*)nset.GetNURBSObject(0);

		Point3 cen;
		// next the two caps
		for (int c = 0; c < 2; c++) {
			if (c == 0)
				cen = Point3(0,0,0);
			else
				cen = Point3(0.0f, 0.0f, height);
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll be cubic in on direction and match the sphere in the other
			s->SetUOrder(4);
			s->SetNumUKnots(8);
			for (int i = 0; i < 4; i++) {
				s->SetUKnot(i, 0.0);
				s->SetUKnot(i+4, 1.0);
			}

			s->SetVOrder(s0->GetVOrder());
			s->SetNumVKnots(s0->GetNumVKnots());
			for (i = 0; i < s->GetNumVKnots(); i++)
				s->SetVKnot(i, s0->GetVKnot(i));

			int numU, numV;
			s0->GetNumCVs(numU, numV);
			s->SetNumCVs(4, numV);

			for (int v = 0; v < numV; v++) {
				Point3 edge;
				if (c == 0)
					edge = s0->GetCV(0, v)->GetPosition(0);
				else
					edge = s0->GetCV(numU-1, v)->GetPosition(0);
				double w = s0->GetCV(0, v)->GetWeight(0);
				for (int u = 0; u < 4; u++) {
					NURBSControlVertex ncv;
					ncv.SetPosition(0, cen + ((edge - cen)*((float)u/3.0f)));
					ncv.SetWeight(0, w);
					s->SetCV(u, v, ncv);
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(1.0f, 1.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));

			if (c == 0)
				s->FlipNormals(!flip);
			else
				s->FlipNormals(flip);
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), c+1);
			s->SetName(sname);
		}

		// now the pie slices
#define F(s1, s2, s1r, s1c, s2r, s2c) \
		fuse.mSurf1 = (s1); \
		fuse.mSurf2 = (s2); \
		fuse.mRow1 = (s1r); \
		fuse.mCol1 = (s1c); \
		fuse.mRow2 = (s2r); \
		fuse.mCol2 = (s2c); \
		nset.mSurfFuse.Append(1, &fuse);

		NURBSFuseSurfaceCV fuse;

		NURBSCVSurface *s1 = (NURBSCVSurface*)nset.GetNURBSObject(1);
		NURBSCVSurface *s2 = (NURBSCVSurface*)nset.GetNURBSObject(2);

		// next the two pie slices
		for (c = 0; c < 2; c++) {
			if (c == 0)
				cen = Point3(0,0,0);
			else
				cen = Point3(0.0f, 0.0f, height);
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll match the cylinder in on dimention and the caps in the other.
			s->SetUOrder(s0->GetUOrder());
			int numKnots = s0->GetNumUKnots();
			s->SetNumUKnots(numKnots);
			for (int i = 0; i < numKnots; i++)
				s->SetUKnot(i, s0->GetUKnot(i));

			s->SetVOrder(s1->GetUOrder());
			numKnots = s1->GetNumUKnots();
			s->SetNumVKnots(numKnots);
			for (i = 0; i < numKnots; i++)
				s->SetVKnot(i, s1->GetUKnot(i));

			int s0u, s0v, s1u, s1v, s2u, s2v;
			s0->GetNumCVs(s0u, s0v);
			s1->GetNumCVs(s1u, s1v);
			s2->GetNumCVs(s2u, s2v);
			int uNum = s0u, vNum = s1u;
			s->SetNumCVs(uNum, vNum);
			for (int v = 0; v < vNum; v++) {
				for (int u = 0; u < uNum; u++) {
					// we get get the ends from the caps and the edge from the main sheet
					if (u == 0) {  // bottom
						if (c == 0) {
							s->SetCV(u, v, *s1->GetCV(v, 0));
							F(1, 3, v, 0, u, v);
						} else {
							s->SetCV(u, v, *s1->GetCV(v, s1v-1));
							F(1, 4, v, s1v-1, u, v);
						}
					} else if (u == uNum-1) { // top
						if (c == 0) {
							s->SetCV(u, v, *s2->GetCV(v, 0));
							F(2, 3, v, 0, u, v);
						} else {
							s->SetCV(u, v, *s2->GetCV(v, s2v-1));
							F(2, 4, v, s2v-1, u, v);
						}
					} else { // middle
						if (v == vNum-1) { // outer edge
							if (c == 0) {
								s->SetCV(u, v, *s0->GetCV(u, 0));
								F(0, 3, u, 0, u, v);
							} else {
								s->SetCV(u, v, *s0->GetCV(u, s0v-1));
								F(0, 4, u, s0v-1, u, v);
							}
						} else { // inside
							// get x and y from a cap and z from the main sheet.
							Point3 p;
							if (c == 0)
								p = Point3(s1->GetCV(v, 0)->GetPosition(0).x,
											s1->GetCV(v, 0)->GetPosition(0).y,
											s0->GetCV(u, v)->GetPosition(0).z);
							else
								p = Point3(s1->GetCV(v, s1v-1)->GetPosition(0).x,
											s1->GetCV(v, s1v-1)->GetPosition(0).y,
											s0->GetCV(u, v)->GetPosition(0).z);
							NURBSControlVertex ncv;
							ncv.SetPosition(0, p);
							ncv.SetWeight(0, 1.0f);
							s->SetCV(u, v, ncv);
						}
					}
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

			if (c == 0)
				s->FlipNormals(!flip);
			else
				s->FlipNormals(flip);
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_SLICE), c+1);
			s->SetName(sname);
		}

		NURBSCVSurface *s3 = (NURBSCVSurface*)nset.GetNURBSObject(3);
		NURBSCVSurface *s4 = (NURBSCVSurface*)nset.GetNURBSObject(4);

		// now fuse up the rest
		// Fuse the edges
		for (int v = 0; v < s0->GetNumVCVs(); v++) {
			F(0, 1, 0, v, s1->GetNumUCVs()-1, v);
			F(0, 2, s0->GetNumUCVs()-1, v, s2->GetNumUCVs()-1, v);
		}

		// Fuse the cap centers
		for (v = 1; v < s1->GetNumVCVs(); v++) {
			F(1, 1, 0, 0, 0, v);
			F(2, 2, 0, 0, 0, v);
		}

		// Fuse the core
		for (int u = 0; u < s3->GetNumUCVs(); u++) {
			F(3, 4, u, 0, u, 0);
		}
	} else {
		GenNURBSCylinderSurface(radius, height, origin, symAxis, refAxis,
						startAngle, endAngle, FALSE, *surf);

		// now create caps on the ends
		NURBSCapSurface *cap0 = new NURBSCapSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0);
		cap0->SetEdge(0);
		cap0->FlipNormals(!flip);
		cap0->Renderable(TRUE);
		char sname[80];
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
		cap0->SetName(sname);

		NURBSCapSurface *cap1 = new NURBSCapSurface();
		nset.AppendObject(cap1);
		cap1->SetGenerateUVs(genUVs);
		cap1->SetParent(0);
		cap1->SetEdge(1);
		cap1->FlipNormals(flip);
		cap1->Renderable(TRUE);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 1);
		cap1->SetName(sname);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

#endif

Object* CylinderObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius, height;
		int genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildCylinderPatch(t,ob->patch,radius,radius,height,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 

#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius, height, pie1, pie2;
		int sliceon, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSCylinder(radius, height, sliceon, pie1, pie2, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
		
	}
#endif

#ifdef DESIGN_VER
	else if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		int sides;
		float radius, height;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_SIDES,t,sides,valid);	
		int smooth;
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = cacheptr->createCylinder(height, radius,sides, smooth);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif
	else {
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int CylinderObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==patchObjectClassID || obtype==defObjectClassID
		|| obtype==triObjectClassID) {
		return 1;
	}
#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID )
        return 1;
#endif

#ifdef DESIGN_VER
	else if(obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		return 1;
	}
#endif
	else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

void CylinderObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}

class CylinderObjCreateCallBack: public CreateMouseCallBack {
	CylinderObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1;	
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(CylinderObject *obj) { ob = obj; }
	};

int CylinderObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _OSNAP
			#ifdef _3D_CREATE
				vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
			#else
				vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
			#endif
		#endif
	}
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				#ifdef _3D_CREATE	
					p[0] = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p[0] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				#ifdef _3D_CREATE	
					p[1] = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p[1] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 ||
						Length(p[1]-p[0])<0.1f) {						
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				{
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
					}
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static CylinderObjCreateCallBack cylCreateCB;

CreateMouseCallBack* CylinderObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL CylinderObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL CylinderObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL CylinderObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL CylinderObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL CylinderObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL CylinderObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL CylinderObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void CylinderObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *CylinderObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: 	return stdWorldDim;
		case PB_HEIGHT: 	return stdWorldDim;
		case PB_SEGMENTS: 	return stdSegmentsDim;
		case PB_CAPSEGMENTS:return stdSegmentsDim;
		case PB_SIDES:		return stdSegmentsDim;
		case PB_SMOOTH:		return stdNormalizedDim;
		case PB_SLICEON:	return stdNormalizedDim;
		case PB_PIESLICE1:	return stdAngleDim;
		case PB_PIESLICE2:	return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR CylinderObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:		return GetString(IDS_RB_RADIUS);
		case PB_HEIGHT:		return GetString(IDS_RB_HEIGHT);
		case PB_SEGMENTS:	return GetString(IDS_RB_CIRCLESEGMENTS);
		case PB_CAPSEGMENTS:return GetString(IDS_RB_CAPSEGMENTS);
		case PB_SIDES:		return GetString(IDS_RB_SIDES);
		case PB_SMOOTH:		return GetString(IDS_RB_SMOOTH);
		case PB_SLICEON:	return GetString(IDS_RB_SLICEON);
		case PB_PIESLICE1:	return GetString(IDS_RB_SLICEFROM);
		case PB_PIESLICE2:	return GetString(IDS_RB_SLICETO);
		//case PB_GENUVS:		return GetString(IDS_RB_GENTEXCOORDS);
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle CylinderObject::Clone(RemapDir& remap) 
	{
	CylinderObject* newob = new CylinderObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\helix.cpp ===
/**********************************************************************
 *<
	FILE: helix.cpp

	DESCRIPTION:  A Helix object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 19 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpshp.h"

// This controls how fine the helix object is
#define POINTS_PER_TURN 40

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float( -1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_TURNS		float(0)
#define MAX_TURNS		float(100)
#define MIN_BIAS		float(-1)
#define MAX_BIAS		float(1)

#define DEF_TURNS		float(1)
#define DEF_BIAS		float(0)

class HelixObjCreateCallBack;

class HelixObject: public SimpleShape, public IParamArray {			   
		friend class HelixObjCreateCallBack;

	public:	
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static float dlgTurns;
		static float dlgBias;
		static int dlgDirection;
		static Point3 crtPos;		
		static float crtHeight;
		static float crtRadius1;
		static float crtRadius2;

		// Interpolation parameters and validity
		Interval interpValid;
		float radius1, radius2, height, turns, bias, power;
		int direction;
		// Useful pre-computed values
		float totalRadians,deltaRadius;
		float perPiece, lengthOfCurve;
		int numberOfPieces;
						
		void BuildShape(TimeValue t,PolyShape& ashape);

		HelixObject();
		~HelixObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_HELIX); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_HELIX); }		
		Class_ID ClassID() { return Class_ID(HELIX_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_HELIX_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

		// From SimpleShape
		Point3 InterpCurve3D(TimeValue t, int curve, float param, int ptype);
		Point3 TangentCurve3D(TimeValue t, int curve, float param, int ptype);
		float LengthOfCurve(TimeValue t, int curve);

		// Interpolation parameter functions -- This subsystem maintains
		// a separate interval for precomputed values that we maintain
		// for rapid analysis of our procedural curve!
		void ReadyInterpParams(TimeValue t);
		void UpdateInterpParams(TimeValue t);
		
		// Here are some optional methods.
		// You should _really_ implement these, because they just do the bare-minimum job
		// (Chopping your curve up into manageable pieces makes things look better)
		int NumberOfPieces(TimeValue t, int curve);
		Point3 InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype);
		Point3 TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

// Directions
#define DIR_CW	0
#define DIR_CCW	1

//------------------------------------------------------

class HelixObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new HelixObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_HELIX_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
   	Class_ID		ClassID() { return Class_ID(HELIX_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static HelixObjClassDesc helixObjDesc;

ClassDesc* GetHelixDesc() { return &helixObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for helix class.
IParamMap *HelixObject::pmapCreate = NULL;
IParamMap *HelixObject::pmapParam  = NULL;
IParamMap *HelixObject::pmapTypeIn = NULL;
IObjParam *HelixObject::ip         = NULL;
Point3 HelixObject::crtPos         = Point3(0,0,0);
float HelixObject::crtHeight       = 0.0f;
float HelixObject::crtRadius1      = 0.0f;
float HelixObject::crtRadius2      = 0.0f;
int HelixObject::dlgCreateMeth     = 1; // create_radius
float HelixObject::dlgTurns        = DEF_TURNS;
float HelixObject::dlgBias         = DEF_BIAS;
int HelixObject::dlgDirection      = DIR_CW;

void HelixObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	HelixObject::crtPos          = Point3(0,0,0);
	HelixObject::crtHeight       = 0.0f;
	HelixObject::crtRadius1      = 0.0f;
	HelixObject::crtRadius2      = 0.0f;
	HelixObject::dlgCreateMeth   = 1; // create_radius
	HelixObject::dlgTurns        = DEF_TURNS;
	HelixObject::dlgBias         = DEF_BIAS;
	HelixObject::dlgDirection    = DIR_CW;
	}

// Parameter map indices
#define PB_RADIUS1		0
#define PB_RADIUS2		1
#define PB_HEIGHT		2
#define PB_TURNS		3
#define PB_BIAS			4
#define PB_DIRECTION	5

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3
#define PB_TI_HEIGHT		4

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_HEIGHT,IDC_HEIGHTSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,
		SPIN_AUTOSCALE),
			
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)

	};
#define TYPEINDESC_LENGTH 4

//
//
// Parameters

static int directionIDs[] = {IDC_HELIX_CW,IDC_HELIX_CCW};

static ParamUIDesc descParam[] = {
	// Radius 1
	ParamUIDesc(
		PB_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Radius 2
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_HEIGHTEDIT,IDC_HEIGHTSPINNER,
		MIN_HEIGHT,MAX_HEIGHT,
		SPIN_AUTOSCALE),	
	
	// Turns
	ParamUIDesc(
		PB_TURNS,
		EDITTYPE_POS_FLOAT,
		IDC_TURNSEDIT,IDC_TURNSSPINNER,
		MIN_TURNS,MAX_TURNS,
		SPIN_AUTOSCALE),	
	
	// Bias
	ParamUIDesc(
		PB_BIAS,
		EDITTYPE_FLOAT,
		IDC_BIASEDIT,IDC_BIASSPINNER,
		MIN_BIAS,MAX_BIAS,
		SPIN_AUTOSCALE),
		
	// Direction
	ParamUIDesc(PB_DIRECTION,TYPE_RADIO,directionIDs,2)	
	
	};
#define PARAMDESC_LENGTH 6


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },		
	{ TYPE_FLOAT, NULL, TRUE, 2 },		
	{ TYPE_FLOAT, NULL, TRUE, 3 },		
	{ TYPE_FLOAT, NULL, TRUE, 4 },		
	{ TYPE_INT, NULL, FALSE, 5 } };
#define PBLOCK_LENGTH	6

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,6,0)			// This is a dummy entry!!!
	};
#define NUM_OLDVERSIONS	0	// No old ones yet!

// Current version
#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class HelixTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		HelixObject *dob;

		HelixTypeInDlgProc(HelixObject *d) {dob=d;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL HelixTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (dob->crtRadius1==0.0 && dob->crtRadius2==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (dob->TestAFlag(A_OBJ_CREATING)) {
						dob->pblock->SetValue(PB_RADIUS1,0,dob->crtRadius1);
						dob->pblock->SetValue(PB_RADIUS2,0,dob->crtRadius2);
						dob->pblock->SetValue(PB_HEIGHT,0,dob->crtHeight);
						}

					Matrix3 tm(1);
					tm.SetTrans(dob->crtPos);
					dob->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void HelixObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleShape::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last object ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_HELIXPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_HELIXPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_HELIXPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new HelixTypeInDlgProc(this));
		}
	}
		
void HelixObject::EndEditParams( IObjParam *ip,ULONG flags,Animatable *next )
	{
	SimpleShape::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_TURNS,ip->GetTime(),dlgTurns,FOREVER);
	pblock->GetValue(PB_BIAS,ip->GetTime(),dlgBias,FOREVER);
	pblock->GetValue(PB_DIRECTION,ip->GetTime(),dlgDirection,FOREVER);
	}

void HelixObject::BuildShape(TimeValue t, PolyShape& ashape) {
	// Set the object's interpolation parameters
	ReadyInterpParams(t);
	// Set the general interval to the one we just got
	ivalid = interpValid;
	ashape.NewShape();
	// Start a PolyLine for our helix...
	PolyLine *line = ashape.NewLine();
	// Compute some helpful stuff...
	int points = (int)(turns * (float)POINTS_PER_TURN);
	if(points == 0)
		points = 1;
	float fPoints = (float)points;
	numberOfPieces = 0;
	for(int i = 0; i <= points; ++i) {
		float pct = (float)i / fPoints;
		float r = radius1 + deltaRadius * pct;
		float hpct = pct;
		if(bias > 0.0f)
			hpct = 1.0f - (float)pow(1.0f - pct, power );
		else
		if(bias < 0.0f)
			hpct = (float)pow(pct, power);
			
		float z = height * hpct;
		float angle = totalRadians * pct;
		float x = r * (float)cos(angle);
		float y = r * (float)sin(angle);
		DWORD flags = POLYPT_SMOOTH;
		if((i % 10) == 0 || i == points) {
			flags |= POLYPT_KNOT;	// Let it know the piece boundary
			if(i > 0)
				numberOfPieces++;
			}
		line->Append(PolyPt(Point3(x,y,z), flags));
		}
	perPiece = 1.0f / (float)numberOfPieces;
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache(FALSE);
	lengthOfCurve = ashape.lines[0].CurveLength();
	}

HelixObject::HelixObject() : SimpleShape() 
	{
	ReadyGeneralParameters();		// Build the general parameter block in SimpleShape
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS1,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_TURNS,0,dlgTurns);
	pblock->SetValue(PB_BIAS,0,dlgBias);
	pblock->SetValue(PB_DIRECTION,0,dlgDirection);

	interpValid.SetEmpty();
 	}

HelixObject::~HelixObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}

class HelixObjCreateCallBack: public CreateMouseCallBack {
	HelixObject *ob;
	Point3 p[3];
	IPoint2 sp0, sp1, sp2;
	Point3 center;
	float r1, ht;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(HelixObject *obj) { ob = obj; }
	};

int HelixObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				sp0 = m;
				createType = ob->dlgCreateMeth;
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS1,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1:
				sp1 = m; 
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if ( createType ) {	// radius	
					r = Length(p[1]-p[0]);
					center = p[0];
					}
				else {// diameter
					center = (p[0]+p[1]) / 2.0f;
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				ob->pblock->SetValue(PB_RADIUS1,0,r);
				ob->pblock->SetValue(PB_RADIUS2,0,r);	// Make this the same for now
				ob->pmapParam->Invalidate();
				r1 = r;
				if (msg==MOUSE_POINT) {
					if(Length(m-sp0)<3 ||
					   Length(p[1]-p[0])<0.1f) {
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				sp2 = m;
#ifdef _OSNAP
				ht = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));  
#else
				ht = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));  
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,float(ht));
				ob->pmapParam->Invalidate();
				break;
			case 3:
				r = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp2,m))
						+ r1;
				ob->pblock->SetValue(PB_RADIUS2,0,r);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static HelixObjCreateCallBack helixCreateCB;

CreateMouseCallBack* HelixObject::GetCreateMouseCallBack() {
	helixCreateCB.SetObj(this);
	return(&helixCreateCB);
	}


//
// Reference Managment:
//

RefTargetHandle HelixObject::Clone(RemapDir& remap) {
	HelixObject* newob = new HelixObject();
	newob->SimpleShapeClone(this);
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL HelixObject::ValidForDisplay(TimeValue t) {
	float radius1, radius2;
	pblock->GetValue(PB_RADIUS1, t, radius1, ivalid);
	pblock->GetValue(PB_RADIUS2, t, radius2, ivalid);
	LimitValue( radius1, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	return (radius1 == 0.0f && radius2 == 0.0f) ? FALSE : TRUE;
	}

void HelixObject::ReadyInterpParams(TimeValue t) {
	interpValid = FOREVER;
	pblock->GetValue(PB_RADIUS1,t,radius1,interpValid);
	pblock->GetValue(PB_RADIUS2,t,radius2,interpValid);
	pblock->GetValue(PB_HEIGHT,t,height,interpValid);
	pblock->GetValue(PB_TURNS,t,turns,interpValid);
	pblock->GetValue(PB_BIAS,t,bias,interpValid);
	pblock->GetValue(PB_DIRECTION,t,direction,interpValid);
	LimitValue( radius1, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	LimitValue( height, MIN_HEIGHT, MAX_HEIGHT );
	LimitValue( turns, MIN_TURNS, MAX_TURNS );
	LimitValue( bias, MIN_BIAS, MAX_BIAS );
	totalRadians = TWOPI * turns * ((direction == DIR_CCW) ? 1.0f : -1.0f);
	deltaRadius = radius2 - radius1;
	float quarterTurns = turns * 4.0f;
	power = 1.0f;
	if(bias > 0.0f)
		power = bias * 9.0f + 1.0f;
	else
	if(bias < 0.0f)
		power = -bias * 9.0f + 1.0f;
	}

void HelixObject::UpdateInterpParams(TimeValue t) {
	if(interpValid.InInterval(t))
		return;
	ReadyInterpParams(t);
	}

Point3 HelixObject::InterpCurve3D(TimeValue t, int curve, float param, int ptype) {
	if(param < 0.0f)
		param = 0.0f;
	else
	if(param > 1.0f)
		param = 1.0f;
	assert(curve==0);
	UpdateShape(t);
	switch(ptype) {
		case PARAM_SIMPLE: {
			float r = radius1 + deltaRadius * param;
			float angle = totalRadians * param;
			float hpct = param;
			if(bias > 0.0f)
				hpct = 1.0f - (float)pow(1.0f - param, power );
			else
			if(bias < 0.0f)
				hpct = (float)pow(param, power);
			return Point3(r * (float)cos(angle),r * (float)sin(angle),height * hpct);
			}
		case PARAM_NORMALIZED:
			return shape.lines[0].InterpCurve3D(param, POLYSHP_INTERP_NORMALIZED);
		}
	assert(0);
	return Point3(0,0,0);
	}

Point3 HelixObject::TangentCurve3D(TimeValue t, int curve, float param, int ptype) {
	assert(curve==0);
	UpdateShape(t);
	float pp = param - perPiece / 100.0f;
	if(pp < 0.0f)
		pp = 0.0f;
	float np = param + perPiece / 100.0f;
	if(np < 0.0f)
		np = 0.0f;
	Point3 prev = InterpCurve3D(t, 0, pp, ptype);
	Point3 next = InterpCurve3D(t, 0, np, ptype);
	return(Normalize(next-prev));
	}

float HelixObject::LengthOfCurve(TimeValue t, int curve) {
	UpdateShape(t);
	return lengthOfCurve;
	}

int HelixObject::NumberOfPieces(TimeValue t, int curve) {
	assert(curve==0);
	UpdateShape(t);
	return numberOfPieces;
	}

Point3 HelixObject::InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype) {
	assert(curve==0);
	UpdateShape(t);
	return InterpCurve3D(t, 0, (float)piece * perPiece + param * perPiece, ptype);
	}

Point3 HelixObject::TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype) {
	assert(curve==0);
	UpdateShape(t);
	return TangentCurve3D(t, curve, (float)piece * perPiece + param * perPiece, ptype);
	}

ParamDimension *HelixObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
		case PB_RADIUS2:
		case PB_HEIGHT:
			return stdWorldDim;			
		case PB_TURNS:
			return defaultDim;
		case PB_BIAS:
			return defaultDim;
		case PB_DIRECTION:
			return stdNormalizedDim; 
		default:
			return defaultDim;
		}
	}

TSTR HelixObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
			return TSTR(GetString(IDS_RB_RADIUS1));
		case PB_RADIUS2:
			return TSTR(GetString(IDS_RB_RADIUS2));
		case PB_HEIGHT:
			return TSTR(GetString(IDS_TH_HEIGHT));
		case PB_TURNS:
			return TSTR(GetString(IDS_TH_TURNS));
		case PB_BIAS:
			return TSTR(GetString(IDS_TH_BIAS));
		case PB_DIRECTION:
			return TSTR(GetString(IDS_TH_DIRECTION));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL HelixObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL HelixObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL HelixObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL HelixObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL HelixObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL HelixObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\hedraobj.cpp ===
/**********************************************************************
 *<
	FILE: hedraobj.cpp

	DESCRIPTION:  Hedra

	CREATED BY: Rolf Berteig (from Dan's hedra code)

	HISTORY: created 10/14/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"


class HedraObject : public SimpleObject {
	public:			
		// Class vars
		static IParamMap *pmapParam;
		static int dlgFamily;		
		static IObjParam *ip;

		HedraObject();		
		
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_HEDRA);}
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(HEDRA_CLASS_ID,0); } 
		
		// From ReferenceTarget
		IOResult Load(ILoad *iload);
						
		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
	};




//--- ClassDescriptor and class vars ---------------------------------

// The class descriptor for hedra
class HedraClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new HedraObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_HEDRA_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(HEDRA_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_AP_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static HedraClassDesc hedraDesc;
extern ClassDesc* GetHedraDesc() { return &hedraDesc; }


// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

int HedraObject::dlgFamily        = 0;
IParamMap *HedraObject::pmapParam = NULL;
IObjParam *HedraObject::ip        = NULL;

void HedraClassDesc::ResetClassParams(BOOL fileReset)
	{
	HedraObject::dlgFamily = 0;
	}


//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS	0
#define PB_FAMILY	1
#define PB_P		2
#define PB_Q		3
#define PB_SCALEP	4
#define PB_SCALEQ	5
#define PB_SCALER	6
#define PB_VERTS	7
#define PB_GENUVS	8

//
//
// Parameters

static int familyIDs[] = {IDC_FAM_TETRA,IDC_FAM_OCTA,IDC_FAM_DODEC,IDC_FAM_STAR1,IDC_FAM_STAR2};
static int vertIDs[] = {IDC_VERT_BASIC,IDC_VERT_CENTER,IDC_VERT_SIDES};

static ParamUIDesc descParam[] = {
	// Family
	ParamUIDesc(PB_FAMILY,TYPE_RADIO,familyIDs,5),

	// P
	ParamUIDesc(
		PB_P,
		EDITTYPE_FLOAT,
		IDC_PARAM_P,IDC_PARAM_PSPIN,
		0.0f, 1.0f,
		0.01f),	
	
	// Q
	ParamUIDesc(
		PB_Q,
		EDITTYPE_FLOAT,
		IDC_PARAM_Q,IDC_PARAM_QSPIN,
		0.0f, 1.0f,
		0.01f),	
	
	// Axis scale P
	ParamUIDesc(
		PB_SCALEP,
		EDITTYPE_FLOAT,
		IDC_SCALE_P,IDC_SCALE_PSPIN,
		0.0f, float(1.0E30),
		0.5f,
		stdPercentDim),	
	
	// Axis scale Q
	ParamUIDesc(
		PB_SCALEQ,
		EDITTYPE_FLOAT,
		IDC_SCALE_Q,IDC_SCALE_QSPIN,
		0.0f, float(1.0E30),
		0.5f,
		stdPercentDim),
	
	// Axis scale R
	ParamUIDesc(
		PB_SCALER,
		EDITTYPE_FLOAT,
		IDC_SCALE_R,IDC_SCALE_RSPIN,
		0.0f, float(1.0E30),
		0.5f,
		stdPercentDim),	
	
	// Vertices
	ParamUIDesc(PB_VERTS,TYPE_RADIO,vertIDs,3),

	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADIUSSPIN,
		0.0f, float(1.0E30),
		SPIN_AUTOSCALE),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 9

#define PB_RADIUS	0
#define PB_FAMILY	1
#define PB_P		2
#define PB_Q		3
#define PB_SCALEP	4
#define PB_SCALEQ	5
#define PB_SCALER	6
#define PB_VERTS	7

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		// radius
	{ TYPE_INT, NULL, TRUE, 1 },		// family
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// P
	{ TYPE_FLOAT, NULL, TRUE, 3 },		// Q
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// Scale P
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// Scale Q
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// Scale R
	{ TYPE_INT, NULL, FALSE, 7 },		// verts
	{ TYPE_INT, NULL, FALSE, 8 } };		// gen UVs

#define PBLOCK_LENGTH	9

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,8,0),
	ParamVersionDesc(descVer1,9,1)	
	};
#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


// --- HedraDlgProc ------------------------------
//
// Constrain P+Q < 1

class HedraDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};

BOOL HedraDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SCALE_RESET: {
					IParamArray *pa = map->GetParamBlock();
					pa->SetValue(PB_SCALEP,t,1.0f);
					pa->SetValue(PB_SCALEQ,t,1.0f);
					pa->SetValue(PB_SCALER,t,1.0f);
					map->Invalidate();
					return REDRAW_VIEWS;
					}
				}
			break;

		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {				
				case IDC_PARAM_PSPIN: {
					IParamArray *pa = map->GetParamBlock();
					float p, q;
					pa->GetValue(PB_P,t,p,FOREVER);
					pa->GetValue(PB_Q,t,q,FOREVER);
					if (p+q>1.0f) {
						q = 1.0f-p;
						pa->SetValue(PB_Q,t,q);
						map->Invalidate();
						}
					return TRUE;
					}

				case IDC_PARAM_QSPIN: {
					IParamArray *pa = map->GetParamBlock();
					float p, q;
					pa->GetValue(PB_P,t,p,FOREVER);
					pa->GetValue(PB_Q,t,q,FOREVER);
					if (p+q>1.0f) {
						p = 1.0f-q;
						pa->SetValue(PB_P,t,p);
						map->Invalidate();
						}
					return TRUE;
					}
				}
			break;
		}
	return FALSE;
	}
static HedraDlgProc theHedraProc;


//--- Hedra methods -------------------------------

HedraObject::HedraObject()
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
		
	pblock->SetValue(PB_FAMILY,0,dlgFamily);		
	pblock->SetValue(PB_SCALEP,0,1.0f);
	pblock->SetValue(PB_SCALEQ,0,1.0f);
	pblock->SetValue(PB_SCALER,0,1.0f);
	}

IOResult HedraObject::Load(ILoad *iload) 
	{	
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

void HedraObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {
		
		// Left over from last Hedra ceated		
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.		
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_HEDRAPARAM),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
	
	pmapParam->SetUserDlgProc(&theHedraProc);
	}
		
void HedraObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;		
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_FAMILY,ip->GetTime(),dlgFamily,FOREVER);	
	}


extern void CreateHedron(Mesh &mesh, 
		int family, float fp, float fq, float radius,
		int axis, int vts, float *scale_axis);


BOOL HedraObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void HedraObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}


void HedraObject::BuildMesh(TimeValue t)
	{
	int family;
	float fp, fq, radius, scale_axis[3];
	int axis = 0, vts;
	int genUVs = TRUE;
	
	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_FAMILY, t, family, ivalid);
	pblock->GetValue(PB_P, t, fp, ivalid);
	pblock->GetValue(PB_Q, t, fq, ivalid);
	pblock->GetValue(PB_SCALEP, t, scale_axis[0], ivalid);
	pblock->GetValue(PB_SCALEQ, t, scale_axis[1], ivalid);
	pblock->GetValue(PB_SCALER, t, scale_axis[2], ivalid);
	pblock->GetValue(PB_VERTS, t, vts, ivalid);
	pblock->GetValue(PB_GENUVS, t, genUVs, ivalid);
	
	LimitValue(radius, 0.0f, float(1.0E30));
	LimitValue(family, 0, 4);
	LimitValue(vts, 0, 2);
	LimitValue(fp, 0.0f, 1.0f);
	LimitValue(fq, 0.0f, 1.0f);

	// Constrain p+q < 1
	if (fp+fq>1.0f) {
		float s = 1.0f/(fp+fq);
		fp *= s;
		fq *= s;
		}

	CreateHedron(mesh, family, fp, fq, radius, axis, vts, scale_axis);
	mesh.InvalidateGeomCache();
	Box3 box = mesh.getBoundingBox();

	if (genUVs) {
		// Do a simple box mapping on individual faces
		mesh.setNumTVerts(mesh.getNumFaces()*3);
		mesh.setNumTVFaces(mesh.getNumFaces());
		int nv=0, nf=0;
		for (int i=0; i<mesh.getNumFaces(); i++) {
			Point3 v[] = {mesh.verts[mesh.faces[i].v[0]],mesh.verts[mesh.faces[i].v[1]],mesh.verts[mesh.faces[i].v[2]]};			
			Point3 norm = Normalize((v[1]-v[0])^(v[2]-v[1]));
			int m=0;
			if (fabs(norm[1])>fabs(norm[m])) m = 1;
			if (fabs(norm[2])>fabs(norm[m])) m = 2;
			int i1 = (m+1)%3;
			int i2 = (m+2)%3;
			mesh.setTVert(nv++,
				v[0][i1]/box.Width()[i1],
				v[0][i2]/box.Width()[i2],
				v[0][m]/box.Width()[m]);
			mesh.setTVert(nv++,
				v[1][i1]/box.Width()[i1],
				v[1][i2]/box.Width()[i2],
				v[1][m]/box.Width()[m]);
			mesh.setTVert(nv++,
				v[2][i1]/box.Width()[i1],
				v[2][i2]/box.Width()[i2],
				v[2][m]/box.Width()[m]);
			mesh.tvFace[nf++].setTVerts(nv-3,nv-2,nv-1);
			}
		}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

class HedraObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	HedraObject *ob;
	Point3 p0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(HedraObject *obj) {ob = obj;}
	};

int HedraObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1,center;
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _OSNAP
			#ifdef _3D_CREATE
				vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
			#else
				vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
			#endif
		#endif
	}
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				ob->pblock->SetValue(PB_RADIUS,0,0.0f);
				ob->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			
			case 1:
				mat.IdentityMatrix();				
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				r = Length(p1-p0);
				mat.SetTrans(p0);
				 
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {										
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f)?CREATE_ABORT:CREATE_STOP;
					}
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static HedraObjCreateCallBack hedraCreateCB;

CreateMouseCallBack* HedraObject::GetCreateMouseCallBack() 
	{
	hedraCreateCB.SetObj(this);
	return(&hedraCreateCB);
	}


BOOL HedraObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}

void HedraObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *HedraObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:	return stdWorldDim;
		case PB_FAMILY:	return defaultDim;
		case PB_P:		return stdNormalizedDim;
		case PB_Q:		return stdNormalizedDim;
		case PB_SCALEP:	return stdPercentDim;
		case PB_SCALEQ:	return stdPercentDim;
		case PB_SCALER:	return stdPercentDim;		
		default: return defaultDim;
		}
	}

TSTR HedraObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:	return GetString(IDS_RB_RADIUS);
		case PB_FAMILY:	return GetString(IDS_RB_FAMILY);
		case PB_P:		return GetString(IDS_RB_PVALUE);
		case PB_Q:		return GetString(IDS_RB_QVALUE);
		case PB_SCALEP:	return GetString(IDS_RB_PSCALE);
		case PB_SCALEQ:	return GetString(IDS_RB_QSCALE);
		case PB_SCALER:	return GetString(IDS_RB_RSCALE);
		default: return TSTR(_T("Parameter"));
		}
	}

RefTargetHandle HedraObject::Clone(RemapDir& remap) 
	{
	HedraObject* newob = new HedraObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\light.cpp ===
/**********************************************************************
 *<
	FILE: light.cpp

	DESCRIPTION:  Omni light implementation

	CREATED BY: Dan Silva

	HISTORY: Created 2 January 1995.
			 Almost total rewrite, Don Brittain, Oct 95.
			 Added attenuation to dir light, target direct light,
			    near attenuation ranges, new atten range display, 
			    shadowing omni lights, etc-- Dan Silva, Jan 1997.
			 Made light type dynamically changable-- Dan Silva, July 1998.

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "target.h"
#include "hsv.h"
#include "render.h"
#include "shadgen.h"
#include "genlight.h"
#include "light.h"
#include "notify.h"
#include <bmmlib.h>
#include "macrorec.h"

#define USE_DLG_COLOR

#define WM_SET_TYPE		WM_USER + 0x04002
#define WM_SET_SHADTYPE		WM_USER + 0x04003

#define OMNI_MESH		0
#define DIR_MESH		1

#define NUM_HALF_ARC	5
#define NUM_ARC_PTS	    (2*NUM_HALF_ARC+1)
#define NUM_CIRC_PTS	28
#define SEG_INDEX		7


// Parameter block indices
#define PB_COLOR		0	   
#define PB_INTENSITY	1
#define PB_CONTRAST		2
#define PB_DIFFSOFT		3
#define PB_HOTSIZE		4   
#define PB_FALLSIZE		5  
#define PB_ASPECT		6   
#define PB_ATTENSTART1	7	
#define PB_ATTENEND1 	8	
#define PB_ATTENSTART	9
#define PB_ATTENEND		10
#define PB_DECAY		11
#define PB_SHADCOLOR    12
#define PB_ATMOS_SHAD	 13 // Atmospheric shadows
#define PB_ATMOS_OPACITY 14 // Atmosphere opacity
#define PB_ATMOS_COLAMT	 15 // Atmosphere color influence
#define PB_SHADMULT 	 16
#define PB_SHAD_COLMAP	 17
#define PB_TDIST		 18

// indices for OMNI only
#define PB_OMNIATSTART1      4
#define PB_OMNIATEND1        5
#define PB_OMNIATSTART       6
#define PB_OMNIATEND         7
#define PB_OMNIDECAY   	     8
#define PB_OMNISHADCOLOR     9
#define PB_OMNIATMOS_SHAD	 10 // Atmospheric shadows
#define PB_OMNIATMOS_OPACITY 11 // Atmosphere opacity
#define PB_OMNIATMOS_COLAMT	 12 // Atmosphere color influence
#define PB_OMNISHADMULT 	 13 // Atmosphere color influence
#define PB_OMNISHAD_COLMAP	 14

#define PB_ATM_SHAD(gl)   (gl->type==OMNI_LIGHT? PB_OMNIATMOS_SHAD: PB_ATMOS_SHAD)
#define PB_ATM_OPAC(gl)   (gl->type==OMNI_LIGHT? PB_OMNIATMOS_OPACITY: PB_ATMOS_OPACITY)
#define PB_ATM_COLAMT(gl) (gl->type==OMNI_LIGHT? PB_OMNIATMOS_COLAMT: PB_ATMOS_COLAMT)
#define PB_SHAD_MULT(gl)  (gl->type==OMNI_LIGHT? PB_OMNISHADMULT: PB_SHADMULT)
#define PB_USE_SHAD_COLMAP(gl)   (gl->type==OMNI_LIGHT? PB_OMNISHAD_COLMAP: PB_SHAD_COLMAP)

// Emitter parameter block indices
#define PB_EMITTER_ENABLE		0
#define PB_EMITTER_ENERGY		1
#define PB_EMITTER_DECAY_TYPE	2
#define PB_EMITTER_CA_PHOTONS	3
#define PB_EMITTER_GI_PHOTONS	4

#define DEF_TDIST		240.0f // 160.0f

static int waitPostLoad = 0;

#if 0
#define FLto255i(x)	((int)((x)*255.0f + 0.5f))
#define FLto255f(x)	((float)((x)*255.0f + 0.5f))
#else
#define FLto255i(x)	((int)((x)*255.0f))
#define FLto255f(x)	((float)((x)*255.0f))
#endif

inline float MaxF(float a, float b) { return a>b?a:b; }
inline float MinF(float a, float b) { return a<b?a:b; }

inline float MaxAbs(float x, float y, float z) {
	float ax = (float)fabs(x);
	float ay = (float)fabs(y);
	float az = (float)fabs(z);
	return ax>ay? (ax?az:ax):ay>az?ay:az;
	}

#ifdef SIMPLEDIR
static 	BOOL IsSpot(int type)	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT; }
#else
static 	BOOL IsSpot(int type)	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT || type == DIR_LIGHT || type==TDIR_LIGHT; }
#endif

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;
void resetLightParams();

//-------------------------------------------------------------------------
static INode* FindNodeRef(ReferenceTarget *rt);

static INode* GetNodeRef(ReferenceMaker *rm) {
	if (rm->SuperClassID()==BASENODE_CLASS_ID) return (INode *)rm;
	else return rm->IsRefTarget()?FindNodeRef((ReferenceTarget *)rm):NULL;
	}

static INode* FindNodeRef(ReferenceTarget *rt) {
	DependentIterator di(rt);
	ReferenceMaker *rm;
	INode *nd = NULL;
	while (rm=di.Next()) {	
		nd = GetNodeRef(rm);
		if (nd) return nd;
		}
	return NULL;
	}

static INode* FindSelNodeRef(ReferenceTarget *rt) {
	DependentIterator di(rt);
	ReferenceMaker *rm;
	INode *nd = NULL;
	while (rm=di.Next()) {	
		if (rm->SuperClassID()==BASENODE_CLASS_ID) {
			nd = (INode *)rm;
			if(nd->Selected()) return nd;
			}
		}
	return NULL;
	}
//-------------------------------------------------------------------------
class OmniLightClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GeneralLight(OMNI_LIGHT); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_OMNI_CLASS); }
	SClass_ID		SuperClassID() { return LIGHT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID( OMNI_LIGHT_CLASS_ID, 0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetLightParams(); }
	DWORD			InitialRollupPageState() { return 0xfffe;}
};

static OmniLightClassDesc omniLightDesc;

ClassDesc *GetOmniLightDesc() { return &omniLightDesc; }


class TSpotLightClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GeneralLight(TSPOT_LIGHT); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	const TCHAR *	ClassName() { return GetString(IDS_DB_TARGET_SPOT_CLASS); }
	SClass_ID		SuperClassID() { return LIGHT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID( SPOT_LIGHT_CLASS_ID, 0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetLightParams(); }
	// Class IO
	BOOL			NeedsToSave() { return TRUE; }
	IOResult 		Save(ISave *isave);
	IOResult 		Load(ILoad *iload);
	DWORD			InitialRollupPageState() { return 0xfffe;}
	
};

static TSpotLightClassDesc tspotLightDesc;

ClassDesc *GetTSpotLightDesc() { return &tspotLightDesc; }


class DirLightClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GeneralLight(DIR_LIGHT); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_DIRECTIONAL_CLASS); }
	SClass_ID		SuperClassID() { return LIGHT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID( DIR_LIGHT_CLASS_ID, 0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetLightParams(); }
	DWORD			InitialRollupPageState() { return 0xfffe;}
};

static DirLightClassDesc dirLightDesc;

ClassDesc *GetDirLightDesc() { return &dirLightDesc; }

class TDirLightClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GeneralLight(TDIR_LIGHT); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	const TCHAR *	ClassName() { return GetString(IDS_DS_TDIRECTIONAL_CLASS); }
	SClass_ID		SuperClassID() { return LIGHT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TDIR_LIGHT_CLASS_ID, 0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetLightParams(); }
	DWORD			InitialRollupPageState() { return 0xfffe;}
};

static TDirLightClassDesc tdirLightDesc;

ClassDesc *GetTDirLightDesc() { return &tdirLightDesc; }

class FSpotLightClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GeneralLight(FSPOT_LIGHT); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_FREE_SPOT_CLASS); }
	SClass_ID		SuperClassID() { return LIGHT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID( FSPOT_LIGHT_CLASS_ID, 0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetLightParams(); }
	DWORD			InitialRollupPageState() { return 0xfffe;}
};

static FSpotLightClassDesc fspotLightDesc;

ClassDesc *GetFSpotLightDesc() { return &fspotLightDesc; }


#define INITINTENS 255

// Class variables of GeneralLight
BOOL GeneralLight::inCreate=FALSE;
Mesh GeneralLight::staticMesh[2];
short GeneralLight::meshBuilt = 0;
int GeneralLight::dlgRed = INITINTENS;
int GeneralLight::dlgGreen = INITINTENS;
int GeneralLight::dlgBlue = INITINTENS;
int GeneralLight::dlgH = 0;
int GeneralLight::dlgS = 0;
int GeneralLight::dlgV = INITINTENS;
float GeneralLight::dlgIntensity = 1.0f;
float GeneralLight::dlgContrast = 0.0f;
float GeneralLight::dlgDiffsoft = 50.0f;	 // DS 8/11/98
float GeneralLight::dlgHotsize = 43.0f;
float GeneralLight::dlgFallsize = 45.0f;
float GeneralLight::dlgTDist = DEF_TDIST;
float GeneralLight::dlgAtten1Start = 0.0f;
float GeneralLight::dlgAtten1End = 40.0f; 
float GeneralLight::dlgAttenStart = 80.0f;
float GeneralLight::dlgAttenEnd = 200.0f; //320.0f;
short GeneralLight::dlgShowCone = 0;
short GeneralLight::dlgUseAtten = 0;
short GeneralLight::dlgShowAtten = 0;
short GeneralLight::dlgShowAttenNear = 0;
short GeneralLight::dlgShowDecay = 0;
short GeneralLight::dlgShape = CIRCLE_LIGHT;
float GeneralLight::dlgAspect = 1.0f;
float GeneralLight::dlgDecayRadius = 40.0f;
short GeneralLight::dlgAtmosShadows = FALSE;
float GeneralLight::dlgAtmosOpacity = 1.0f;
float GeneralLight::dlgAtmosColamt = 1.0f;
short GeneralLight::dlgLightAffectShadColor = 0;
Color24 GeneralLight::dlgShadColor = {0,0,0};
float GeneralLight::dlgShadMult = 1.0f;
Class_ID GeneralLight::dlgShadType = Class_ID(STD_SHADOW_MAP_CLASS_ID,0);
short GeneralLight::dlgUseGlobalShadowParams=0;

short GeneralLight::dlgEmitterEnable = TRUE;
float GeneralLight::dlgEmitterEnergy = 1000.0;
short GeneralLight::dlgEmitterDecayType = DECAY_NONE;
int	  GeneralLight::dlgEmitterCAPhotons = 10000;
int	  GeneralLight::dlgEmitterGIPhotons = 10000;


// Global shadow settings
short GeneralLight::globShadowType = 0;  // 0: ShadowMap   1: RayTrace
short GeneralLight::globAbsMapBias = 0;
float GeneralLight::globMapBias = 1.0f;
float GeneralLight::globMapRange = 4.0f;
int   GeneralLight::globMapSize = 512;
float GeneralLight::globRayBias = .2f;
short GeneralLight::globAtmosShadows = FALSE;
float GeneralLight::globAtmosOpacity = 1.0f;
float GeneralLight::globAtmosColamt = 1.0f;

HWND GeneralLight::hGeneralLight = NULL;
HWND GeneralLight::hSpotLight = NULL;
HWND GeneralLight::hOmni = NULL;
HWND GeneralLight::hShadow = NULL;
HWND GeneralLight::hAttenLight = NULL;
HWND GeneralLight::hEmitter = NULL;

void resetLightParams()
{
	GeneralLight::dlgRed = INITINTENS;
	GeneralLight::dlgGreen = INITINTENS;
	GeneralLight::dlgBlue = INITINTENS;
	GeneralLight::dlgH = 0;
	GeneralLight::dlgS = 0;
	GeneralLight::dlgV = INITINTENS;
	GeneralLight::dlgIntensity = 1.0f;
	GeneralLight::dlgContrast = 0.0f;
	GeneralLight::dlgDiffsoft = 50.0f;    // DS 8/11/98
	GeneralLight::dlgHotsize = 43.0f;
	GeneralLight::dlgFallsize = 45.0f;
	GeneralLight::dlgTDist = DEF_TDIST;
	GeneralLight::dlgAtten1Start = 0.0f;
	GeneralLight::dlgAtten1End = 40.0f;
	GeneralLight::dlgAttenStart = 80.0f;
	GeneralLight::dlgAttenEnd = 200.0f;
	GeneralLight::dlgShowCone = 0;
	GeneralLight::dlgUseAtten = 0;
	GeneralLight::dlgShowAtten = 0;
	GeneralLight::dlgShowAttenNear = 0;
	GeneralLight::dlgShowDecay = 0;
	GeneralLight::dlgShape = CIRCLE_LIGHT;
	GeneralLight::dlgAspect = 1.0f;
	GeneralLight::dlgDecayRadius = 40.0f;
	GeneralLight::dlgAtmosShadows = FALSE;
	GeneralLight::dlgAtmosOpacity = 1.0f;
	GeneralLight::dlgAtmosColamt = 1.0f;
	GeneralLight::dlgEmitterEnable = TRUE;
	GeneralLight::dlgEmitterEnergy = 1000.0;
	GeneralLight::dlgEmitterDecayType = DECAY_NONE;
	GeneralLight::dlgEmitterCAPhotons = 10000;
	GeneralLight::dlgEmitterGIPhotons = 10000;

	// Global shadow settings
	GeneralLight::globAtmosShadows = FALSE;
	GeneralLight::globAtmosOpacity = 1.0f;
	GeneralLight::globAtmosColamt = 1.0f;

	// Common shadow parameters
	GeneralLight::dlgShadColor.r = 0;
	GeneralLight::dlgShadColor.g = 0;
	GeneralLight::dlgShadColor.b = 0;
	GeneralLight::dlgShadMult = 1.0f;
	GeneralLight::dlgLightAffectShadColor = 0;
	GeneralLight::dlgShadType = Class_ID(STD_SHADOW_MAP_CLASS_ID,0);
	GeneralLight::dlgUseGlobalShadowParams = 0;

	HWND hl = GetDlgItem(GeneralLight::hGeneralLight, IDC_LIGHT_COLOR);
	if(hl)
		InvalidateRect(hl, NULL, TRUE);
}

IObjParam *GeneralLight::iObjParams;
ISpinnerControl *GeneralLight::redSpin;
ISpinnerControl *GeneralLight::greenSpin;
ISpinnerControl *GeneralLight::blueSpin;
ISpinnerControl *GeneralLight::hSpin;
ISpinnerControl *GeneralLight::sSpin;
ISpinnerControl *GeneralLight::vSpin;
ISpinnerControl *GeneralLight::intensitySpin;
ISpinnerControl *GeneralLight::contrastSpin;
ISpinnerControl *GeneralLight::diffsoftSpin;
ISpinnerControl *GeneralLight::hotsizeSpin;
ISpinnerControl *GeneralLight::fallsizeSpin;
ISpinnerControl *GeneralLight::tDistSpin;
ISpinnerControl *GeneralLight::attenStartSpin;
ISpinnerControl *GeneralLight::attenEndSpin;
ISpinnerControl *GeneralLight::attenStart1Spin;
ISpinnerControl *GeneralLight::attenEnd1Spin;
ISpinnerControl *GeneralLight::aspectSpin;
ISpinnerControl *GeneralLight::decaySpin;
ISpinnerControl *GeneralLight::atmosOpacitySpin;
ISpinnerControl *GeneralLight::atmosColAmtSpin;
ISpinnerControl *GeneralLight::shadMultSpin;
ISpinnerControl *GeneralLight::emitterEnergySpin;
ISpinnerControl *GeneralLight::emitterCAPhotonsSpin;
ISpinnerControl *GeneralLight::emitterGIPhotonsSpin;
IColorSwatch *GeneralLight::colorSwatch;
IColorSwatch *GeneralLight::shadColorSwatch;
ICustButton *GeneralLight::projMapName;
ICustButton *GeneralLight::shadProjMapName;
ProjMapDADMgr GeneralLight::projDADMgr;
ShadowParamDlg * GeneralLight::shadParamDlg=NULL;


//------------------------------------------------------------------------------
//
// Projection Map Drag and Drop manager;
//
//------------------------------------------------------------------------------
SClass_ID ProjMapDADMgr::GetDragType(HWND hwnd, POINT p) {
	return TEXMAP_CLASS_ID;
	}

BOOL ProjMapDADMgr::OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
	if (hfrom==hto) return FALSE;
	return (type==TEXMAP_CLASS_ID)?1:0;
	}

ReferenceTarget *ProjMapDADMgr::GetInstance(HWND hwnd, POINT p, SClass_ID type) {
	if  (hwnd==gl->projMapName->GetHwnd())
		return gl->projMap;						
	if  (hwnd==gl->shadProjMapName->GetHwnd())
		return gl->shadProjMap;						
	return NULL;
	}

void ProjMapDADMgr::Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
	Texmap *m = (Texmap *)dropThis;
	if  (hwnd==gl->projMapName->GetHwnd())
		gl->AssignProjectorMap(m, FALSE);
	else 
	if  (hwnd==gl->shadProjMapName->GetHwnd())
		gl->AssignShadProjMap(m, FALSE);
	}


// This generic snap routine is used to snap to the 0,0,0 point of the given node.  For lights,
// this works to snap all types.

static void GenericSnap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
{
	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();	
   	
		gw->setTransform(tm);

		Point2 fp = Point2((float)p->x, (float)p->y);
		IPoint3 screen3;
		Point2 screen2;
		Point3 vert(0.0f,0.0f,0.0f);

		gw->wTransPoint(&vert,&screen3);

		screen2.x = (float)screen3.x;
		screen2.y = (float)screen3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
			}
			// Closer than the best of this priority?
			else if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = vert * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
			}
		}
	}
}

static void InitColorSpinner( HWND hDlg, ISpinnerControl *spin, int editID, float v) 
{
	spin->SetLimits(0.0f, 255.0f, FALSE );
	spin->SetValue(v,FALSE);
	spin->SetScale( 1.0f );
	spin->LinkToEdit( GetDlgItem(hDlg,editID), EDITTYPE_INT );
}

static void InitAngleSpinner( HWND hDlg, ISpinnerControl *spin, int editID, float v)
{
	spin->SetLimits(0.5f, 179.5f, FALSE);
	spin->SetValue(v,FALSE);
	spin->SetScale(.1f);
	spin->LinkToEdit( GetDlgItem(hDlg, editID), EDITTYPE_FLOAT );
}

static void InitRangeSpinner( HWND hDlg, ISpinnerControl *spin, int editID, float v, BOOL allowNegative)
{
//	spin->SetLimits(allowNegative?-999999.0f:0.0f, 999999.0f, FALSE);
	spin->SetLimits(0.0f, 999999.0f, FALSE);
	spin->SetValue(v,FALSE);
	spin->SetScale(1.0f);
	spin->LinkToEdit( GetDlgItem(hDlg, editID), EDITTYPE_UNIVERSE );
}

#define RELEASE_SPIN(x)   if (gl->x) { ReleaseISpinner(gl->x); gl->x = NULL;}
#define RELEASE_COLSW(x)   if (gl->x) { ReleaseIColorSwatch(gl->x); gl->x = NULL;}
#define RELEASE_BUT(x)   if (gl->x) { ReleaseICustButton(gl->x); gl->x = NULL;}


static int AttenFromID(int id) {
	switch (id) {
		case IDC_START_RANGE1_SPIN: return ATTEN1_START;
		case IDC_END_RANGE1_SPIN:   return ATTEN1_END;
		case IDC_START_RANGE_SPIN:  return ATTEN_START;
		case IDC_END_RANGE_SPIN:    return ATTEN_END;
		default: return 0;
		}
	}

ISpinnerControl *GeneralLight::AttenSpinner(int atype) {
	switch (atype) {
		case ATTEN1_START: return attenStart1Spin; break;
		case ATTEN1_END:   return attenEnd1Spin;   break;
		case ATTEN_START:  return attenStartSpin;  break;
		case ATTEN_END:    return attenEndSpin;    break;
		default: return attenStartSpin;
		}
	}

void GeneralLight::ChangeAtten(int atype) {
	float val = AttenSpinner(atype)->GetFVal();
	ISpinnerControl *isp;
	TimeValue t = iObjParams->GetTime();
	SetAtten(t, atype, val);	
	
	for (int i = atype+1; i<4; i++) {
		isp = AttenSpinner(i);
		float f = isp->GetFVal();
		if (val>f) {
			isp->SetValue(val,FALSE);
			SetAtten(t, i, val);	
			}
		}
	for (i = atype-1; i>=0; i--) {
		isp = AttenSpinner(i);
		float f = isp->GetFVal();
		if (val<f) {
			isp->SetValue(val,FALSE);
			SetAtten(t, i, val);	
			}
		}
	}

void GeneralLight::SetSpinnerBracket(ISpinnerControl *spin, int pbid) {
	spin->SetKeyBrackets(pblock->KeyFrameAtTime(pbid,iObjParams->GetTime()));
	}

static int typeName[NUM_LIGHT_TYPES] = {
	IDS_DB_OMNI,
	IDS_DB_TARGET_SPOT,
	IDS_DB_DIRECTIONAL,
	IDS_DB_FREE_SPOT,
	IDS_DS_TDIRECTIONAL
	};

static int typeFromID[NUM_LIGHT_TYPES] = {
	OMNI_LIGHT,
	TSPOT_LIGHT,
	FSPOT_LIGHT,
	TDIR_LIGHT,
	DIR_LIGHT	
	};

#define NUM_DECAY_TYPES 3

int decayName[NUM_DECAY_TYPES] = { IDS_DECAY_NONE, IDS_DECAY_INVERSE, IDS_DECAY_INVSQ };

static int idFromType(int t) {
	for (int i=0; i<NUM_LIGHT_TYPES; i++)
		if (typeFromID[i]==t) return i;
	return -1;
	}

static ShadowType *GetShadowTypeForIndex(int n) {
	SubClassList *scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SHADOW_TYPE_CLASS_ID);
	int count = 0;
	for ( long i = 0; i < scList->Count(ACC_ALL); ++i) {
		if ( (*scList)[ i ].IsPublic() ) {
			ClassDesc* pClassD = (*scList)[ i ].CD();
			if (count==n) {
				return (ShadowType*)pClassD->Create();
				}
			count++;
			}
		}
	return NULL;
	}

BOOL CALLBACK GeneralLightParamDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{	
	int id;
	GeneralLight *gl = (GeneralLight *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !gl && message != WM_INITDIALOG ) 
		return FALSE;
	TimeValue t = gl->iObjParams->GetTime();
	float tmpHot, tmpFall;

	switch ( message ) {
	case WM_INITDIALOG:
		gl = (GeneralLight *)lParam;
	
		SetWindowLong( hDlg, GWL_USERDATA, (LONG)gl );
		SetDlgFont( hDlg, gl->iObjParams->GetAppHFont() );
		CheckDlgButton( hDlg, IDC_LIGHT_ON, gl->GetUseLight() );
		CheckDlgButton( hDlg, IDC_AFFECT_DIFFUSE, gl->affectDiffuse);
		//CheckDlgButton( hDlg, IDC_SOFTEN_DIFFUSE, gl->softenDiffuse);
		CheckDlgButton( hDlg, IDC_AFFECT_SPECULAR, gl->affectSpecular);
		CheckDlgButton( hDlg, IDC_AMBIENT_ONLY, gl->ambientOnly);


		CheckDlgButton( hDlg, IDC_SHOW_CONE, gl->GetConeDisplay() );
		CheckRadioButton( hDlg, IDC_RECT_LIGHT, IDC_CIRCLE_LIGHT, IDC_RECT_LIGHT+gl->GetSpotShape());
		CheckDlgButton( hDlg, IDC_SHOW_RANGES, gl->GetAttenDisplay() );
		CheckDlgButton( hDlg, IDC_SHOW_RANGES1, gl->GetAttenNearDisplay() );
		CheckDlgButton( hDlg, IDC_USE_ATTEN, gl->GetUseAtten() );
		CheckDlgButton( hDlg, IDC_USE_ATTEN1, gl->GetUseAttenNear() );
		CheckDlgButton( hDlg, IDC_SHOW_DECAY, gl->GetAttenDisplay() );

		{
		HWND hwndType = GetDlgItem(hDlg, IDC_LIGHT_DECAY);
		for (int i=0; i<NUM_DECAY_TYPES; i++)
			SendMessage(hwndType, CB_ADDSTRING, 0, (LPARAM)GetString(decayName[i]));
		SendMessage( hwndType, CB_SETCURSEL, gl->GetDecayType(), (LPARAM)0 );
		}

		CheckDlgButton( hDlg, IDC_GLOBAL_SET, gl->GetUseGlobal() );
		CheckDlgButton( hDlg, IDC_CAST_SHADOWS, gl->GetShadow() );
		CheckDlgButton( hDlg, IDC_OBJECT_SHADOWS, gl->GetShadow() );

		CheckRadioButton( hDlg, IDC_SHADOW_MAPS, IDC_RAY_TRACED_SHADOWS, 
			IDC_SHADOW_MAPS + gl->GetShadowType());
		CheckDlgButton( hDlg, IDC_ABS_MAP_BIAS, gl->GetAbsMapBias() );
		CheckDlgButton( hDlg, IDC_LT_EFFECT_SHADCOL, gl->GetLightAffectsShadow() );
		CheckDlgButton( hDlg, IDC_ATMOS_SHADOWS, gl->GetAtmosShadows(t) );
		CheckDlgButton( hDlg, IDC_USE_SHAD_COLMAP, gl->GetUseShadowColorMap(t) );

		EnableWindow(GetDlgItem(hDlg, IDC_LASPECT), !gl->GetSpotShape());
		EnableWindow(GetDlgItem(hDlg, IDC_LASPECT_SPIN), !gl->GetSpotShape());
		EnableWindow(GetDlgItem(hDlg, IDC_BITMAP_FIT), !gl->GetSpotShape());
		SetDlgItemText(hDlg,IDC_EXCLUDE_DLG, 
			GetString(gl->Include()?IDS_DS_INCLUDE__: IDS_DS_EXCLUDE__));

		CheckDlgButton( hDlg, IDC_OVERSHOOT, gl->GetOvershoot() );
		CheckDlgButton( hDlg, IDC_PROJECTOR, gl->GetProjector() );
		{
		HWND hwndType = GetDlgItem(hDlg, IDC_LIGHT_TYPE);
		for (int i=0; i<NUM_LIGHT_TYPES; i++)
			SendMessage(hwndType, CB_ADDSTRING, 0, (LPARAM)GetString(typeName[typeFromID[i]]));
		SendMessage( hwndType, CB_SETCURSEL, idFromType(gl->type), (LPARAM)0 );
		EnableWindow(hwndType,!gl->inCreate);		
		}

//		gl->FixHotFallConstraint();

		if (gl->type==TSPOT_LIGHT || gl->type==TDIR_LIGHT) {
			TCHAR buf[40];
			_stprintf(buf,_T("%0.3f"),gl->targDist);
			SetWindowText(GetDlgItem(hDlg,IDC_TARG_DISTANCE),buf);
			}
		if (gl->hotsizeSpin)
			gl->hotsizeSpin->Enable(!gl->overshoot);

//		if ( gl->hEmitter )
		{
			CheckDlgButton( hDlg, IDC_EMITTER_ENABLE, gl->GetEmitterEnable(t) );
			{
				HWND hwndType = GetDlgItem( hDlg, IDC_EMITTER_DECAY);
				for (int i=0; i<NUM_DECAY_TYPES; i++)
					SendMessage(hwndType, CB_ADDSTRING, 0, (LPARAM)GetString(decayName[i]));
				SendMessage( hwndType, CB_SETCURSEL, (WPARAM)gl->GetEmitterDecayType(t), (LPARAM)0 );
			}
		}
		return FALSE;

	case WM_DESTROY:
		RELEASE_SPIN( redSpin);
		RELEASE_SPIN( greenSpin );
		RELEASE_SPIN( blueSpin );
		RELEASE_SPIN( hSpin );
		RELEASE_SPIN( sSpin );
		RELEASE_SPIN( vSpin );
		RELEASE_SPIN( intensitySpin );
		RELEASE_SPIN( contrastSpin );
		RELEASE_SPIN( diffsoftSpin );
		RELEASE_COLSW( colorSwatch);
		RELEASE_COLSW( shadColorSwatch);
		RELEASE_SPIN( hotsizeSpin );
		RELEASE_SPIN( fallsizeSpin );
		RELEASE_SPIN( tDistSpin );
		RELEASE_SPIN( aspectSpin );
		RELEASE_SPIN( decaySpin );
		RELEASE_SPIN( attenStartSpin); 
		RELEASE_SPIN( attenEndSpin); 
		RELEASE_SPIN( attenStart1Spin); 
		RELEASE_SPIN( attenEnd1Spin); 
		RELEASE_SPIN( atmosOpacitySpin );
		RELEASE_SPIN( atmosColAmtSpin );
		RELEASE_SPIN( shadMultSpin );
		RELEASE_SPIN( emitterEnergySpin );
		RELEASE_SPIN( emitterCAPhotonsSpin );
		RELEASE_SPIN( emitterGIPhotonsSpin );
		RELEASE_BUT( projMapName); 
		RELEASE_BUT( shadProjMapName); 
		
		return FALSE;

	case WM_SET_TYPE:
		theHold.Begin();
		gl->SetType(wParam);
		theHold.Accept(GetString(IDS_DS_SETTYPE));
		return FALSE;

	case WM_SET_SHADTYPE:
		theHold.Begin();
		gl->SetShadowGenerator(GetShadowTypeForIndex(wParam));
		theHold.Accept(GetString(IDS_DS_SETSHADTYPE));
		return FALSE;


	case CC_SPINNER_CHANGE:			
		{
		int id = LOWORD(wParam);
		if (!theHold.Holding()) theHold.Begin();
		BOOL redraw = TRUE;
		switch ( id ) {
		case IDC_LREDSPINNER:
		case IDC_LGREENSPINNER:
		case IDC_LBLUESPINNER:
			gl->SetRGBColor(t, Point3(gl->redSpin->GetFVal()/255.0f, 
					gl->greenSpin->GetFVal()/255.0f, gl->blueSpin->GetFVal()/255.0f ));
			gl->UpdateColBrackets(gl->iObjParams->GetTime());
			break;
		case IDC_LHSPINNER:
		case IDC_LSSPINNER:
		case IDC_LVSPINNER:
			gl->SetUpdateHSVSpin(FALSE);
			gl->SetHSVColor(t, Point3(gl->hSpin->GetFVal()/255.0, 
					gl->sSpin->GetFVal()/255.0, gl->vSpin->GetFVal()/255.0 ));
			gl->UpdateColBrackets(gl->iObjParams->GetTime());
			break;
		case IDC_LMULTSPINNER:
			gl->SetIntensity(t, gl->intensitySpin->GetFVal());
			gl->SetSpinnerBracket(gl->intensitySpin,PB_INTENSITY);
			break;
		case IDC_LCONTRASTSPIN2:
			gl->SetContrast(t, gl->contrastSpin->GetFVal());
			gl->SetSpinnerBracket(gl->contrastSpin,PB_CONTRAST);
			break;
		case IDC_DIFFSOFTSPIN:
			gl->SetDiffuseSoft(t, gl->diffsoftSpin->GetFVal());
			gl->SetSpinnerBracket(gl->diffsoftSpin,PB_DIFFSOFT);
			break;

		case IDC_LHOTSIZESPINNER:
		case IDC_LFALLOFFSPINNER:
			tmpHot = gl->hotsizeSpin->GetFVal();
			tmpFall = gl->fallsizeSpin->GetFVal();

			if((tmpHot > tmpFall - gl->iObjParams->GetLightConeConstraint())) {
				if(LOWORD(wParam) == IDC_LHOTSIZESPINNER)
					tmpFall = tmpHot + gl->iObjParams->GetLightConeConstraint();
				else
					tmpHot = tmpFall - gl->iObjParams->GetLightConeConstraint();
				gl->hotsizeSpin->SetValue(tmpHot, FALSE);
				gl->fallsizeSpin->SetValue(tmpFall, FALSE);
				gl->SetHotspot(t, tmpHot);
				gl->SetFallsize(t, tmpFall);
			}
			else {
				if(LOWORD(wParam) == IDC_LHOTSIZESPINNER)
					gl->SetHotspot(t, tmpHot);
				else
					gl->SetFallsize(t, tmpFall);
			}
			gl->SetSpinnerBracket(gl->hotsizeSpin,PB_HOTSIZE);
			gl->SetSpinnerBracket(gl->fallsizeSpin,PB_FALLSIZE);
			gl->BuildSpotMesh(max(gl->hotsizeSpin->GetFVal(), gl->fallsizeSpin->GetFVal()));
			break;
		case IDC_LTDISTSPINNER:
			gl->SetTDist(t, gl->tDistSpin->GetFVal());
			gl->SetSpinnerBracket(gl->tDistSpin,PB_TDIST);
			break;				   
		case IDC_START_RANGE_SPIN:
			gl->ChangeAtten(ATTEN_START);
			gl->SetSpinnerBracket(gl->attenStartSpin, gl->type==OMNI_LIGHT? PB_OMNIATSTART:PB_ATTENSTART);
			break;
		case IDC_END_RANGE_SPIN:
			gl->ChangeAtten(ATTEN_END);
			gl->SetSpinnerBracket(gl->attenEndSpin, gl->type==OMNI_LIGHT? PB_OMNIATEND:PB_ATTENEND);
			break;
		case IDC_START_RANGE1_SPIN:
			gl->ChangeAtten(ATTEN1_START);
			gl->SetSpinnerBracket(gl->attenStart1Spin, gl->type==OMNI_LIGHT? PB_OMNIATSTART1:PB_ATTENSTART1);
			break;
		case IDC_END_RANGE1_SPIN:
			gl->ChangeAtten(ATTEN1_END);
			gl->SetSpinnerBracket(gl->attenEnd1Spin, gl->type==OMNI_LIGHT? PB_OMNIATEND1:PB_ATTENEND1);
			break;
		case IDC_LASPECT_SPIN:
			gl->SetAspect( t, gl->aspectSpin->GetFVal());
			gl->SetSpinnerBracket(gl->aspectSpin,PB_ASPECT);
			break;
		case IDC_DECAY_SPIN:
			gl->SetDecayRadius( t, gl->decaySpin->GetFVal());
			gl->SetSpinnerBracket(gl->decaySpin, gl->type==OMNI_LIGHT? PB_OMNIDECAY: PB_DECAY);
			break;

		case IDC_ATM_OPACITY_SPIN:
			gl->SetAtmosOpacity( t, gl->atmosOpacitySpin->GetFVal()/100.0f);
			gl->SetSpinnerBracket(gl->atmosOpacitySpin, PB_ATM_OPAC(gl));
			redraw = FALSE;
			break;

		case IDC_ATM_COLAMT_SPIN:
			gl->SetAtmosColAmt( t, gl->atmosColAmtSpin->GetFVal()/100.0f);
			gl->SetSpinnerBracket(gl->atmosColAmtSpin, PB_ATM_COLAMT(gl));
			redraw = FALSE;
			break;
		case IDC_SHAD_MULT_SPIN:
			gl->SetShadMult( t, gl->shadMultSpin->GetFVal());
			gl->SetSpinnerBracket(gl->shadMultSpin, PB_SHAD_MULT(gl));
			redraw = FALSE;
			break;
		case IDC_EMITTER_CA_PHOTONS_SPIN:
			gl->SetEmitterCausticPhotons( t, gl->emitterCAPhotonsSpin->GetIVal());
			gl->SetSpinnerBracket(gl->emitterCAPhotonsSpin, PB_EMITTER_CA_PHOTONS);
			redraw = FALSE;
			break;
		case IDC_EMITTER_GI_PHOTONS_SPIN:
			gl->SetEmitterGlobalIllumPhotons( t, gl->emitterGIPhotonsSpin->GetIVal());
			gl->SetSpinnerBracket(gl->emitterGIPhotonsSpin, PB_EMITTER_GI_PHOTONS);
			redraw = FALSE;
			break;
		case IDC_EMITTER_ENERGY_SPIN:
			gl->SetEmitterEnergy( t, gl->emitterEnergySpin->GetFVal());
			gl->SetSpinnerBracket(gl->emitterEnergySpin, PB_EMITTER_ENERGY);
			redraw = FALSE;
			break;
		}				
		if (redraw)
			gl->iObjParams->RedrawViews(gl->iObjParams->GetTime(),REDRAW_INTERACTIVE);
		}
		gl->SetUpdateHSVSpin(TRUE);
		return TRUE;

	case CC_SPINNER_BUTTONDOWN:
		theHold.Begin();
		return TRUE;

	case CC_COLOR_CHANGE:
		id = LOWORD(wParam);
		if(HIWORD(wParam))  {	// button up
			DWORD rgb;
			theHold.Begin();
			switch (id) {
				case IDC_LIGHT_COLOR:
					rgb = gl->colorSwatch->GetColor();
					gl->SetRGBColor(t, Point3(GetRValue(rgb)/255.0f, GetGValue(rgb)/255.0f, GetBValue(rgb)/255.0f));
					break;
				case IDC_SHADOW_COLOR:
					rgb = gl->shadColorSwatch->GetColor();
					gl->SetShadColor(t, Point3(GetRValue(rgb)/255.0f, GetGValue(rgb)/255.0f, GetBValue(rgb)/255.0f));
					break;
				}
			theHold.Accept(GetString(IDS_DS_PARAMCHG));
			gl->iObjParams->RedrawViews(gl->iObjParams->GetTime(),REDRAW_END);
			gl->UpdateUI(t);
			}
		return TRUE;

	case WM_CUSTEDIT_ENTER:
	case CC_SPINNER_BUTTONUP:
		if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) 
			theHold.Accept(GetString(IDS_DS_PARAMCHG));
		else 
			theHold.Cancel();
		gl->iObjParams->RedrawViews(gl->iObjParams->GetTime(),REDRAW_END);
		return TRUE;

	case WM_MOUSEACTIVATE:
		gl->iObjParams->RealizeParamPanel();
		return FALSE;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MOUSEMOVE:
		gl->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
		return FALSE;

	case WM_COMMAND:			
		switch( id = LOWORD(wParam) ) {
		case IDC_LIGHT_ON:
			gl->SetUseLight( IsDlgButtonChecked( hDlg, IDC_LIGHT_ON ) );
			gl->iObjParams->RedrawViews(t);
			break;
//		case IDC_SOFTEN_DIFFUSE:
//			gl->softenDiffuse = IsDlgButtonChecked( hDlg, IDC_SOFTEN_DIFFUSE );
//			gl->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
//			gl->iObjParams->RedrawViews(t);
//			break;
		case IDC_LIGHT_TYPE: {
			int code = HIWORD(wParam);
			if (code==CBN_SELCHANGE) {
				int newType = typeFromID[SendMessage( GetDlgItem(hDlg,IDC_LIGHT_TYPE), CB_GETCURSEL, 0, 0 )];
				PostMessage(hDlg,WM_SET_TYPE,newType,0);
				}
			break;
			}

		case IDC_SHADOW_TYPE: {
			int code = HIWORD(wParam);
			if (code==CBN_SELCHANGE) {
				int newShadType = SendMessage( GetDlgItem(hDlg,IDC_SHADOW_TYPE), CB_GETCURSEL, 0, 0 );
				PostMessage(hDlg,WM_SET_SHADTYPE,newShadType,0);
				}
			break;
			}
		
		case IDC_AFFECT_DIFFUSE:
			gl->affectDiffuse = IsDlgButtonChecked( hDlg, IDC_AFFECT_DIFFUSE );
			gl->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_AFFECT_SPECULAR:
			gl->affectSpecular =  IsDlgButtonChecked( hDlg, IDC_AFFECT_SPECULAR );
			gl->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_AMBIENT_ONLY:
			gl->ambientOnly =  IsDlgButtonChecked( hDlg, IDC_AMBIENT_ONLY );
			gl->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			gl->iObjParams->RedrawViews(t);
			gl->UpdateForAmbOnly();
			break;
		case IDC_SHOW_CONE:
			gl->SetConeDisplay( IsDlgButtonChecked( hDlg, IDC_SHOW_CONE ) );
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_USE_ATTEN1:
			gl->SetUseAttenNear( IsDlgButtonChecked( hDlg, IDC_USE_ATTEN1 ) );
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_SHOW_RANGES1:
			gl->SetAttenNearDisplay( IsDlgButtonChecked( hDlg, IDC_SHOW_RANGES1 ) );
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_USE_ATTEN:
			gl->SetUseAtten( IsDlgButtonChecked( hDlg, IDC_USE_ATTEN ) );
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_SHOW_RANGES:
			gl->SetAttenDisplay( IsDlgButtonChecked( hDlg, IDC_SHOW_RANGES ) );
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_SHOW_DECAY:
			gl->SetDecayDisplay( IsDlgButtonChecked( hDlg, IDC_SHOW_DECAY) );
			gl->iObjParams->RedrawViews(t);
			break;


		case IDC_LIGHT_DECAY: {
			int code = HIWORD(wParam);
			if (code==CBN_SELCHANGE) {
				int newType = SendMessage( GetDlgItem(hDlg,IDC_LIGHT_DECAY), CB_GETCURSEL, 0, 0 );
				gl->SetDecayType(newType);
				gl->iObjParams->RedrawViews(t);
				}
			}
			break;
		case IDC_RECT_LIGHT:
		case IDC_CIRCLE_LIGHT:
			if(wParam > 2048)
				break;		// spurious message sent by dbl-clicking the blue spinner
							// some how ends up here with wParam > 2048 -- so punt it
			CheckRadioButton(hDlg, IDC_RECT_LIGHT, IDC_CIRCLE_LIGHT, id);
			gl->SetSpotShape((id == IDC_RECT_LIGHT)?RECT_LIGHT:CIRCLE_LIGHT);
			EnableWindow(GetDlgItem(hDlg, IDC_LASPECT), !gl->GetSpotShape());
			EnableWindow(GetDlgItem(hDlg, IDC_LASPECT_SPIN), !gl->GetSpotShape());
			EnableWindow(GetDlgItem(hDlg, IDC_BITMAP_FIT), !gl->GetSpotShape());
			gl->UpdateUI(t);
			gl->iObjParams->RedrawViews(t);
			break;
		case IDC_SHADOW_MAPS:
		case IDC_RAY_TRACED_SHADOWS:
			CheckRadioButton( hDlg, IDC_SHADOW_MAPS, IDC_RAY_TRACED_SHADOWS, id);
			gl->SetShadowType((id==IDC_SHADOW_MAPS)?0:1);
			break;
		case IDC_GLOBAL_SET:
			gl->SetUseGlobal( IsDlgButtonChecked( hDlg, id));
			gl->ReloadShadCtrls(hDlg,t);
			break;
		case IDC_OBJECT_SHADOWS:
		case IDC_CAST_SHADOWS: {
			int b = IsDlgButtonChecked(hDlg,id);
			gl->SetShadow(b);
			CheckDlgButton( gl->hGeneralLight, IDC_CAST_SHADOWS, b );
			CheckDlgButton( gl->hShadow, IDC_OBJECT_SHADOWS, b );
			}
			break;
		case IDC_ABS_MAP_BIAS:
			gl->SetAbsMapBias( IsDlgButtonChecked( hDlg, id));
			break;
		case IDC_ATMOS_SHADOWS:
			gl->SetAtmosShadows( t, IsDlgButtonChecked( hDlg, id ) );
			break;
		case IDC_USE_SHAD_COLMAP:
			gl->SetUseShadowColorMap( t, IsDlgButtonChecked( hDlg, id ) );
			break;
		case IDC_OVERSHOOT:
			gl->SetOvershoot( IsDlgButtonChecked( hDlg, id));
			gl->iObjParams->RedrawViews(t);
			if (gl->hotsizeSpin)
				gl->hotsizeSpin->Enable(!gl->overshoot);
			break;
		case IDC_PROJECTOR:
			gl->SetProjector(IsDlgButtonChecked( hDlg, id));
			break;
		case IDC_PROJ_MAPNAME:
			gl->BrowseProjectorMap(hDlg);
//			gl->iObjParams->PutMtlToMtlEditor(gl->projMap);
			break;
		case IDC_SHADPROJ_MAPNAME:
			gl->BrowseShadProjMap(hDlg);
			break;
		case IDC_EXCLUDE_DLG:
			gl->iObjParams->DoExclusionListDialog(&gl->exclList, TRUE /*gl->IsSpot()*/ );
			SetDlgItemText(hDlg,IDC_EXCLUDE_DLG, 
				GetString(gl->Include()?IDS_DS_INCLUDE__: IDS_DS_EXCLUDE__));
			return TRUE;
		case IDC_BITMAP_FIT:
			gl->DoBitmapFit(hDlg,t);
			break;
		case IDC_LT_EFFECT_SHADCOL:
			gl->SetLightAffectsShadow(IsDlgButtonChecked( hDlg, IDC_LT_EFFECT_SHADCOL ));
			break;
		case IDC_EMITTER_ENABLE:
			gl->SetEmitterEnable( t, IsDlgButtonChecked( hDlg, IDC_EMITTER_ENABLE ) );
			break;
		case IDC_EMITTER_DECAY: {
			int code = HIWORD(wParam);
			if (code==CBN_SELCHANGE) {
				int newType = SendMessage( GetDlgItem( hDlg,IDC_EMITTER_DECAY), CB_GETCURSEL, 0, 0 );
				gl->SetEmitterDecayType(t, newType);
				gl->iObjParams->RedrawViews(t);
				}
			}
			break;
		return FALSE;
		}
	default:
		return FALSE;
	}
}

void GeneralLight::FixHotFallConstraint() {
	if (iObjParams==NULL)
		return;
	TimeValue t = iObjParams->GetTime();
	if(IsSpot()) {
		if(GetFallsize(t) < GetHotspot(t) + iObjParams->GetLightConeConstraint())
			SetFallsize(t, GetHotspot(t) + iObjParams->GetLightConeConstraint());
		}
	}

void GeneralLight::ReloadShadCtrls(HWND hDlg, TimeValue t) {
//	EnableWindow(GetDlgItem(hDlg, IDC_SHADOW_MAPS), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_RAY_TRACED_SHADOWS), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_BIAS), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_BIAS_SPIN), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_SIZE), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_SIZE_SPIN), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_RANGE), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_MAP_RANGE_SPIN), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_RT_BIAS), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_RT_BIAS_SPIN), onOff);
//	EnableWindow(GetDlgItem(hDlg, IDC_ABS_MAP_BIAS), onOff);
	CheckRadioButton( hDlg, IDC_SHADOW_MAPS, IDC_RAY_TRACED_SHADOWS, 
		IDC_SHADOW_MAPS + GetShadowType());
	CheckDlgButton( hDlg, IDC_ABS_MAP_BIAS, GetAbsMapBias() );
//	mapSizeSpin->SetValue( GetMapSize(t),FALSE );
//	mapBiasSpin->SetValue( GetMapBias(t),FALSE );
//	mapRangeSpin->SetValue( GetMapRange(t),FALSE );
//	rayBiasSpin->SetValue( GetRayBias(t),FALSE );
	decaySpin->SetValue( GetDecayRadius(t),FALSE );
	CheckDlgButton( hDlg, IDC_ATMOS_SHADOWS, GetAtmosShadows(t) );
	atmosOpacitySpin->SetValue( GetAtmosOpacity(t)*100.0f,FALSE);
	atmosColAmtSpin->SetValue( GetAtmosColAmt(t)*100.0f,FALSE);
	shadMultSpin->SetValue( GetShadMult(t),FALSE);
	}

void GeneralLight::UpdtShadowTypeSel() {
	if (hShadow==NULL) return;
	HWND hwShadType = GetDlgItem(hShadow, IDC_SHADOW_TYPE);
	ShadowType *actShad = ActiveShadowType();
	SubClassList *scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SHADOW_TYPE_CLASS_ID);
	int cursel = -1;
	for ( long i = 0; i < scList->Count(ACC_ALL); ++i) {
		if ( (*scList)[ i ].IsPublic() ) {
			ClassDesc* pClassD = (*scList)[ i ].CD();
			if (actShad->ClassID()==pClassD->ClassID())
				cursel = i;
			}
		}
	if (cursel>=0)
	    SendMessage(hwShadType, CB_SETCURSEL, (WPARAM)cursel, 0L);
	}


void GeneralLight::UpdtShadowTypeList(HWND hwndDlg) {
	HWND hwShadType = GetDlgItem(hwndDlg, IDC_SHADOW_TYPE);
	SendMessage(hwShadType, CB_RESETCONTENT, 0L, 0L);
	SubClassList *scList = GetCOREInterface()->GetDllDir().ClassDir().GetClassList(SHADOW_TYPE_CLASS_ID);
	int cursel = -1;
	ShadowType *actShad = ActiveShadowType();
	for ( long i = 0; i < scList->Count(ACC_ALL); ++i) {
		if ( (*scList)[ i ].IsPublic() ) {
			ClassDesc* pClassD = (*scList)[ i ].CD();
			SendMessage(hwShadType, CB_ADDSTRING, 0L, (LPARAM)(pClassD->ClassName()) );
			if (actShad->ClassID()==pClassD->ClassID())
				cursel = i;
			}
		}
	if (cursel>=0)
	    SendMessage(hwShadType, CB_SETCURSEL, (WPARAM)cursel, 0L);
	}


void GeneralLight::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	iObjParams = ip;
	TimeValue t = ip->GetTime();
	Point3 color;
	inCreate = (flags&BEGIN_EDIT_CREATE)?1:0;

	projDADMgr.Init(this);

	if ( !hGeneralLight ) {
		hGeneralLight = ip->AddRollupPage( 
				hInstance, 
				/*type == DIR_LIGHT ? MAKEINTRESOURCE(IDD_DIRLIGHTPARAM) :*/ MAKEINTRESOURCE(IDD_LIGHT_PARAM),
				GeneralLightParamDialogProc, 
				GetString(IDS_DB_GENERAL_PARAMS), 
				(LPARAM)this );		
		ip->RegisterDlgWnd(hGeneralLight);

		redSpin   =	GetISpinner( GetDlgItem(hGeneralLight, IDC_LREDSPINNER) );
		greenSpin = GetISpinner( GetDlgItem(hGeneralLight, IDC_LGREENSPINNER) );
		blueSpin  = GetISpinner( GetDlgItem(hGeneralLight, IDC_LBLUESPINNER) );
		hSpin 	  = GetISpinner( GetDlgItem(hGeneralLight, IDC_LHSPINNER) );
		sSpin 	  = GetISpinner( GetDlgItem(hGeneralLight, IDC_LSSPINNER) );
		vSpin 	  = GetISpinner( GetDlgItem(hGeneralLight, IDC_LVSPINNER) );
		color = GetRGBColor(t);
		InitColorSpinner(hGeneralLight, redSpin, IDC_LRED, FLto255f(color.x));
		InitColorSpinner(hGeneralLight, greenSpin, IDC_LGREEN, FLto255f(color.y));
		InitColorSpinner(hGeneralLight, blueSpin, IDC_LBLUE, FLto255f(color.z));
		colorSwatch = GetIColorSwatch(GetDlgItem(hGeneralLight, IDC_LIGHT_COLOR), 
				RGB(FLto255i(color.x), FLto255i(color.y), FLto255i(color.z)), 
				GetString(IDS_DS_LIGHTCOL));
		colorSwatch->ForceDitherMode(1);
		//colorSwatch->SetModal();
		color = GetHSVColor(t);
		InitColorSpinner(hGeneralLight, hSpin, IDC_LH, FLto255f(color.x));
		InitColorSpinner(hGeneralLight, sSpin, IDC_LS, FLto255f(color.y));
		InitColorSpinner(hGeneralLight, vSpin, IDC_LV, FLto255f(color.z));
		intensitySpin = GetISpinner( GetDlgItem(hGeneralLight, IDC_LMULTSPINNER) );
		intensitySpin->SetLimits(-(float)1.0e30, (float)1.0e30, FALSE);
		intensitySpin->SetValue(GetIntensity(t),FALSE);
		intensitySpin->SetScale(0.01f);
		intensitySpin->SetAutoScale(TRUE);
		intensitySpin->LinkToEdit( GetDlgItem(hGeneralLight, IDC_LMULT), EDITTYPE_FLOAT );

		contrastSpin = SetupFloatSpinner(hGeneralLight, IDC_LCONTRASTSPIN2, IDC_LCONTRAST2,0.0f,100.0f,
			0.0f,1.0f);
		diffsoftSpin = SetupFloatSpinner(hGeneralLight, IDC_DIFFSOFTSPIN, IDC_DIFFSOFT,0.0f,100.0f,
			0.0f,1.0f);

		contrastSpin->SetValue(GetContrast(t), FALSE);
		diffsoftSpin->SetValue(GetDiffuseSoft(t), FALSE);
		if(IsSpot()) {
			hSpotLight = ip->AddRollupPage( 
					hInstance, 
					(type == FSPOT_LIGHT||type==DIR_LIGHT) ? MAKEINTRESOURCE(IDD_FREE_SPOTLIGHT) : MAKEINTRESOURCE(IDD_SPOTLIGHT),
					GeneralLightParamDialogProc, 
					IsDir() ? GetString(IDS_DB_DIR_PARAMS) : GetString(IDS_DB_SPOT_PARAMS), 
					(LPARAM)this
					);		
			ip->RegisterDlgWnd(hSpotLight);				

			projMapName = GetICustButton(GetDlgItem(hSpotLight, IDC_PROJ_MAPNAME));	
			projMapName->SetText(projMap?projMap->GetFullName().data():GetString(IDS_DB_NONE));
			projMapName->SetDADMgr(&projDADMgr);
			
			if (type == FSPOT_LIGHT||type==DIR_LIGHT) {
				tDistSpin = GetISpinner( GetDlgItem(hSpotLight, IDC_LTDISTSPINNER) );
				tDistSpin->SetLimits(1.0f, 10000.0f, FALSE);
				tDistSpin->SetValue(GetTDist(t),FALSE);
				tDistSpin->SetScale(1.0f);
				tDistSpin->LinkToEdit( GetDlgItem(hSpotLight, IDC_LTDIST), EDITTYPE_UNIVERSE );
				}

			aspectSpin = GetISpinner( GetDlgItem(hSpotLight, IDC_LASPECT_SPIN) );
			aspectSpin->SetLimits(0.001f, 100.0f, FALSE);
			aspectSpin->SetValue(GetAspect(t),FALSE);
			aspectSpin->SetScale(0.01f);
			aspectSpin->LinkToEdit( GetDlgItem(hSpotLight, IDC_LASPECT), EDITTYPE_FLOAT );

			ShowWindow(GetDlgItem(hSpotLight, IDC_LTDIST), type == FSPOT_LIGHT||type==DIR_LIGHT ? SW_SHOW : SW_HIDE);
			ShowWindow(GetDlgItem(hSpotLight, IDC_LTDISTSPINNER), type == FSPOT_LIGHT||type==DIR_LIGHT ? SW_SHOW : SW_HIDE);
			SetConeDisplay( IsDlgButtonChecked(hSpotLight, IDC_SHOW_CONE) );

			hotsizeSpin = GetISpinner( GetDlgItem(hSpotLight,IDC_LHOTSIZESPINNER) );
			fallsizeSpin = GetISpinner( GetDlgItem(hSpotLight,IDC_LFALLOFFSPINNER) );

			if(IsDir()) {
				hotsizeSpin->SetLimits(.001f, (float)1.0e30, FALSE);
				hotsizeSpin->SetValue(GetHotspot(t),FALSE);
				hotsizeSpin->SetScale(1.0f);
				hotsizeSpin->LinkToEdit( GetDlgItem(hSpotLight, IDC_LHOTSIZE), EDITTYPE_UNIVERSE );
	
				fallsizeSpin->SetLimits(.001f, (float)1.0e30, FALSE);
				fallsizeSpin->SetValue(GetFallsize(t),FALSE);
				fallsizeSpin->SetScale(1.0f);
				fallsizeSpin->LinkToEdit( GetDlgItem(hSpotLight, IDC_LFALLOFF), EDITTYPE_UNIVERSE );
				}
			else {
				InitAngleSpinner(hSpotLight, hotsizeSpin, IDC_LHOTSIZE, GetHotspot(t) );
				InitAngleSpinner(hSpotLight, fallsizeSpin, IDC_LFALLOFF, GetFallsize(t) );
				}
			}			
		if (type == OMNI_LIGHT) {
			hOmni = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_OMNI),
				GeneralLightParamDialogProc, 
				GetString(IDS_DS_PROJ_PARAMS), 
				(LPARAM)this 
				);		
			ip->RegisterDlgWnd(hOmni);				
			projMapName = GetICustButton(GetDlgItem(hOmni, IDC_PROJ_MAPNAME));		
			projMapName->SetText(projMap?projMap->GetFullName().data():GetString(IDS_DB_NONE));
			projMapName->SetDADMgr(&projDADMgr);
			}

		hAttenLight = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_LIGHT_ATTEN),
				GeneralLightParamDialogProc, 
				GetString(IDS_ATTEN_PARAM), 
				(LPARAM)this 
				);		
		ip->RegisterDlgWnd(hAttenLight);


		attenStartSpin = GetISpinner( GetDlgItem(hAttenLight,IDC_START_RANGE_SPIN) );
		attenEndSpin = GetISpinner( GetDlgItem(hAttenLight,IDC_END_RANGE_SPIN) );
		InitRangeSpinner(hAttenLight, attenStartSpin, IDC_START_RANGE, GetAtten(t, ATTEN_START), IsDir());
		InitRangeSpinner(hAttenLight, attenEndSpin, IDC_END_RANGE, GetAtten(t, ATTEN_END), IsDir());
		SetAttenDisplay( IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES) );
		SetUseAtten( IsDlgButtonChecked(hAttenLight, IDC_USE_ATTEN) );

		attenStart1Spin = GetISpinner( GetDlgItem(hAttenLight,IDC_START_RANGE1_SPIN) );
		attenEnd1Spin = GetISpinner( GetDlgItem(hAttenLight,IDC_END_RANGE1_SPIN) );
		InitRangeSpinner(hAttenLight, attenStart1Spin, IDC_START_RANGE1, GetAtten(t, ATTEN1_START),IsDir());
		InitRangeSpinner(hAttenLight, attenEnd1Spin, IDC_END_RANGE1, GetAtten(t, ATTEN1_END),IsDir());
		SetAttenNearDisplay( IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES1) );
		SetUseAttenNear( IsDlgButtonChecked(hAttenLight, IDC_USE_ATTEN1) );

		decaySpin = GetISpinner( GetDlgItem(hAttenLight,IDC_DECAY_SPIN) );
		InitRangeSpinner( hAttenLight, decaySpin, IDC_DECAY_EDIT, GetDecayRadius(t), IsDir());
				
		//--Shadow Rollup ---------------------------------------------------

		hShadow = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_LIGHT_SHADOW2),
				GeneralLightParamDialogProc, 
				GetString(IDS_DB_SHADOW_PARAMS), 
				(LPARAM)this 
				);		
		ip->RegisterDlgWnd(hShadow);				

		color = GetShadColor(t);
		shadColorSwatch = GetIColorSwatch(GetDlgItem(hShadow, IDC_SHADOW_COLOR), 
				RGB(FLto255i(color.x), FLto255i(color.y), FLto255i(color.z)), 
				GetString(IDS_DS_SHADCOL));
		shadColorSwatch->ForceDitherMode(1);
		//shadColorSwatch->SetModal();

		shadProjMapName = GetICustButton(GetDlgItem(hShadow, IDC_SHADPROJ_MAPNAME));	
		shadProjMapName->SetText(shadProjMap?shadProjMap->GetFullName().data():GetString(IDS_DB_NONE));
		shadProjMapName->SetDADMgr(&projDADMgr);
 
		atmosOpacitySpin = SetupFloatSpinner(hShadow, IDC_ATM_OPACITY_SPIN, IDC_ATM_OPACITY,
			0.0f, 100.0f, GetAtmosOpacity(t)*100.0f,1.0f); 
		atmosColAmtSpin = SetupFloatSpinner(hShadow, IDC_ATM_COLAMT_SPIN, IDC_ATM_COLAMT,
			0.0f, 100.0f, GetAtmosColAmt(t)*100.0f,1.0f); 
		shadMultSpin = SetupFloatSpinner(hShadow, IDC_SHAD_MULT_SPIN, IDC_SHAD_MULT,
			-10000.0f, 10000.0f, GetShadMult(t),0.01f); 

		UpdtShadowTypeList(hShadow);
	
		shadParamDlg = ActiveShadowType()->CreateShadowParamDlg(ip); 

		if(IsSpot()) {
			if(GetFallsize(t) < GetHotspot(t) + ip->GetLightConeConstraint())
				SetFallsize(t, GetHotspot(t) + ip->GetLightConeConstraint());
			}

		if ( IsCompatibleRenderer () )
		{
			hEmitter = ip->AddRollupPage( 
							hInstance, 
							MAKEINTRESOURCE(IDD_LIGHT_EMITTER),
							GeneralLightParamDialogProc, 
							GetString(IDS_EMITTER), 
							(LPARAM)this 
							);		
			ip->RegisterDlgWnd(hEmitter);				

			emitterEnergySpin = SetupFloatSpinner(hEmitter, IDC_EMITTER_ENERGY_SPIN, IDC_EMITTER_ENERGY,
						0.0f, 100000.0f, GetEmitterEnergy(t),10.0f); 
			emitterEnergySpin->SetAutoScale ( TRUE );
			emitterCAPhotonsSpin = SetupIntSpinner(hEmitter, IDC_EMITTER_CA_PHOTONS_SPIN, IDC_EMITTER_CA_PHOTONS, 
						0, 10000000, GetEmitterCausticPhotons (t) );
			emitterCAPhotonsSpin->SetAutoScale ( TRUE );
			emitterGIPhotonsSpin = SetupIntSpinner(hEmitter, IDC_EMITTER_GI_PHOTONS_SPIN, IDC_EMITTER_GI_PHOTONS, 
						0, 10000000, GetEmitterGlobalIllumPhotons (t) );
			emitterGIPhotonsSpin->SetAutoScale ( TRUE );
		}
		} 
	else {
		// Plug in new values to UI 
		SetWindowLong( hGeneralLight, GWL_USERDATA, (LONG)this );
		if(IsSpot())
			SetWindowLong( hSpotLight, GWL_USERDATA, (LONG)this );
		if(type==OMNI_LIGHT)
			SetWindowLong( hOmni, GWL_USERDATA, (LONG)this );
		SetWindowLong( hShadow, GWL_USERDATA, (LONG)this );
		if (hAttenLight)
			SetWindowLong( hAttenLight, GWL_USERDATA, (LONG)this );
		
		color = GetRGBColor(t);
		redSpin->SetValue(FLto255f(color.x), FALSE);
		greenSpin->SetValue(FLto255f(color.y), FALSE);
		blueSpin->SetValue(FLto255f(color.z), FALSE);
		color = GetHSVColor(t);
		hSpin->SetValue(FLto255f(color.x), FALSE);
		sSpin->SetValue(FLto255f(color.y), FALSE);
		vSpin->SetValue(FLto255f(color.z), FALSE);
		intensitySpin->SetValue(GetIntensity(t), FALSE);


		attenStartSpin->SetValue(GetAtten(t, ATTEN_START), FALSE);
		attenEndSpin->SetValue(GetAtten(t, ATTEN_END), FALSE);
		SetAttenDisplay( IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES) );
		SetUseAtten( IsDlgButtonChecked(hAttenLight, IDC_USE_ATTEN) );

		attenStart1Spin->SetValue(GetAtten(t, ATTEN1_START), FALSE);
		attenEnd1Spin->SetValue(GetAtten(t, ATTEN1_END), FALSE);
		SetAttenNearDisplay( IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES1) );
		SetUseAttenNear( IsDlgButtonChecked(hAttenLight, IDC_USE_ATTEN1) );
		decaySpin->SetValue( GetDecayRadius(t),FALSE );

		if(IsSpot()) {
			hotsizeSpin->SetValue(GetHotspot(t), FALSE);
			fallsizeSpin->SetValue(GetFallsize(t), FALSE);
			if (type == FSPOT_LIGHT||type==DIR_LIGHT) 
				tDistSpin->SetValue(GetTDist(t), FALSE);
			SetConeDisplay( IsDlgButtonChecked(hSpotLight, IDC_SHOW_CONE) );
			}

		if (projMapName)
			projMapName->SetDADMgr(&projDADMgr);
		if (shadProjMapName)
			shadProjMapName->SetDADMgr(&projDADMgr);

		if (shadParamDlg) {
			shadParamDlg->DeleteThis();
			}
		shadParamDlg = ActiveShadowType()->CreateShadowParamDlg(ip); 

		if ( hEmitter )
		{
			emitterEnergySpin->SetValue ( GetEmitterEnergy (t), FALSE );
			emitterCAPhotonsSpin->SetValue ( GetEmitterCausticPhotons (t), FALSE );
			emitterGIPhotonsSpin->SetValue ( GetEmitterGlobalIllumPhotons (t), FALSE );
		}
		}
	SendMessage( GetDlgItem(hGeneralLight, IDC_LIGHT_TYPE), CB_SETCURSEL, idFromType(type), (LPARAM)0 );
	UpdateForAmbOnly();
	if (!inCreate)
		ip->AddSFXRollupPage(0);
	}

		
void GeneralLight::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	Point3 color;
	TimeValue t = ip->GetTime();
	if (projMapName)
		projMapName->SetDADMgr(NULL);
	if (shadProjMapName)
		shadProjMapName->SetDADMgr(NULL);
	color = GetRGBColor(t);
	dlgRed =   FLto255i(color.x);
	dlgGreen = FLto255i(color.y);
	dlgBlue =  FLto255i(color.z);
	color = GetHSVColor(t);
	dlgH = FLto255i(color.x);
	dlgS = FLto255i(color.y);
	dlgV = FLto255i(color.z);
	dlgIntensity = GetIntensity(t);
	dlgContrast = GetContrast(t);
	dlgDiffsoft = GetDiffuseSoft(t);
	if(IsSpot()) {
		dlgHotsize = GetHotspot(t);
		dlgFallsize = GetFallsize(t);
		dlgTDist = GetTDist(t);
		dlgShowCone = IsDlgButtonChecked(hSpotLight, IDC_SHOW_CONE );
		dlgShape = GetSpotShape();
		dlgAspect = GetAspect(t);
		}

	dlgAtten1Start = GetAtten(t, ATTEN1_START);
	dlgAtten1End = GetAtten(t, ATTEN1_END);
	dlgAttenStart = GetAtten(t, ATTEN_START);
	dlgAttenEnd = GetAtten(t, ATTEN_END);
	dlgShowAtten = IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES );
	dlgShowAttenNear = IsDlgButtonChecked(hAttenLight, IDC_SHOW_RANGES1 );
	dlgShowDecay = IsDlgButtonChecked(hAttenLight, IDC_SHOW_DECAY );
	dlgDecayRadius = GetDecayRadius(t);
	dlgAtmosOpacity = GetAtmosOpacity(t);
	dlgAtmosColamt = GetAtmosColAmt(t);
	dlgAtmosShadows = GetAtmosShadows(t);
	Point3 col = GetShadColor(t);
	dlgShadColor.r  = int(col.x*255.0f);
	dlgShadColor.g  = int(col.y*255.0f);
	dlgShadColor.b  = int(col.z*255.0f);
	dlgLightAffectShadColor = GetLightAffectsShadow();
	dlgShadMult = GetShadMult(t);
	dlgShadType = shadType->ClassID();
	dlgUseGlobalShadowParams = useGlobalShadowParams;

	// Emitter
	dlgEmitterEnable	= GetEmitterEnable ( t );
	dlgEmitterEnergy	= GetEmitterEnergy ( t );
	dlgEmitterDecayType	= GetEmitterDecayType ( t );
	dlgEmitterCAPhotons	= GetEmitterCausticPhotons ( t );
	dlgEmitterGIPhotons	= GetEmitterGlobalIllumPhotons ( t );

	if ( flags&END_EDIT_REMOVEUI ) {
		HWND hwgl = hGeneralLight;
		hGeneralLight = NULL; // This keeps UpdateUI from jumping in

		if ( IsSpot()&&hSpotLight ) {
			ip->UnRegisterDlgWnd(hSpotLight);		
			ip->DeleteRollupPage(hSpotLight);
			hSpotLight = NULL;
			}

		if ((type==OMNI_LIGHT)&&hOmni) {
			ip->UnRegisterDlgWnd(hOmni);		
			ip->DeleteRollupPage(hOmni);
			hOmni = NULL;
			}
		ip->UnRegisterDlgWnd(hAttenLight);		
		ip->DeleteRollupPage(hAttenLight);

		ip->UnRegisterDlgWnd(hShadow);		
		ip->DeleteRollupPage(hShadow);
		hShadow = NULL;

		if ( hEmitter )
		{
			ip->UnRegisterDlgWnd ( hEmitter );
			ip->DeleteRollupPage ( hEmitter );
			hEmitter = NULL;
		}

		ip->UnRegisterDlgWnd(hwgl);		
		ip->DeleteRollupPage(hwgl);

		if (shadParamDlg)
			shadParamDlg->DeleteThis(); 

		ip->DeleteSFXRollupPage();
		} 
	else {
		SetWindowLong( hGeneralLight, GWL_USERDATA, 0 );
		if( IsSpot() ) {
			SetWindowLong( hSpotLight, GWL_USERDATA, 0 );
			}
		if (type==OMNI_LIGHT) {
			SetWindowLong( hOmni, GWL_USERDATA, 0 );
			}		
		SetWindowLong( hAttenLight, GWL_USERDATA, 0 );
		SetWindowLong( hShadow, GWL_USERDATA, 0 );
		SetWindowLong( hEmitter, GWL_USERDATA, 0 );
		}
	iObjParams = NULL;
	}


void GeneralLight::EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) {
	if ((flags&FILE_ENUM_INACTIVE)||projector)
		if (projMap) projMap->EnumAuxFiles(nameEnum,flags);
	} 

void GeneralLight::DoBitmapFit(HWND hwnd, TimeValue t) {
	if(!(IsSpot()&&shape==RECT_LIGHT)) return;
	BitmapInfo bi;
	TheManager->SelectFileInputEx(&bi, hwnd, GetString(IDS_DB_SELECT_TO_FIT));
	if (bi.Name()[0]) {
		TheManager->GetImageInfo(&bi, bi.Name());
       	int w = bi.Width();
        int h = bi.Height();
		if (h) {
			SetAspect(t,float(w)/float(h));
			iObjParams->RedrawViews(t,REDRAW_END);
			}
		}
	}

void GeneralLight::AssignProjectorMap(Texmap *m, BOOL newmat) {	
	assert(!m || IsTex(m));
	ReplaceReference(PROJMAP_REF,m);
	if (projMap) {
		projMapName->SetText(projMap->GetFullName().data());
		if (newmat) 
			projMap->RecursInitSlotType(type==OMNI_LIGHT?MAPSLOT_ENVIRON:MAPSLOT_TEXTURE);
		} 
	else {
		projMapName->SetText(GetString(IDS_DB_NONE));
		}		
	if (projMap) {
		projector = TRUE;
		CheckDlgButton(type==OMNI_LIGHT?hOmni:hSpotLight,IDC_PROJECTOR, projector);
		}
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}


void GeneralLight::AssignShadProjMap(Texmap *m, BOOL newmat) {	
	assert(!m || IsTex(m));
	ReplaceReference(SHADPROJMAP_REF,m);
	if (shadProjMap) {
		shadProjMapName->SetText(shadProjMap->GetFullName().data());
		if (newmat) 
			shadProjMap->RecursInitSlotType(type==OMNI_LIGHT?MAPSLOT_ENVIRON:MAPSLOT_TEXTURE);
		} 
	else {
		shadProjMapName->SetText(GetString(IDS_DB_NONE));
		}		
	if (shadProjMap) {
		SetUseShadowColorMap( 0, TRUE);
		CheckDlgButton(hShadow, IDC_USE_SHAD_COLMAP, TRUE);
		}
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}


void GeneralLight::BrowseProjectorMap(HWND hWnd) {	
	BOOL newMat, cancel;
	Texmap *m = (Texmap *)iObjParams->DoMaterialBrowseDlg(
		hWnd,BROWSE_MAPSONLY|BROWSE_INCNONE,newMat,cancel);
	if (!cancel)
		AssignProjectorMap(m,newMat);
	}

void GeneralLight::BrowseShadProjMap(HWND hWnd) {	
	BOOL newMat, cancel;
	Texmap *m = (Texmap *)iObjParams->DoMaterialBrowseDlg(
		hWnd,BROWSE_MAPSONLY|BROWSE_INCNONE,newMat,cancel);
	if (!cancel) {
		AssignShadProjMap(m,newMat);
		//SetUseShadowColorMap(TimeValue(0),1);
		}
	}

void GeneralLight::SetProjMap(Texmap* pmap)
	{
	ReplaceReference(PROJMAP_REF,pmap);
	if (projMap) projector = TRUE;	
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

void GeneralLight::SetShadowProjMap(Texmap* pmap)
	{
	ReplaceReference(SHADPROJMAP_REF,pmap);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

static int GetTargetPoint(TimeValue t, INode *inode, Point3& p) 
{
	Matrix3 tmat;
	if (inode->GetTargetTM(t,tmat)) {
		p = tmat.GetTrans();
		return 1;
	}
	else 
		return 0;
}


void GeneralLight::UpdateTargDistance(TimeValue t, INode* inode) {
	if (type == TSPOT_LIGHT&&hSpotLight) {
		Point3 pt,v[3];
		if (GetTargetPoint(t, inode, pt)) {
			Matrix3 tm = inode->GetObjectTM(t);
			float den = FLength(tm.GetRow(2));
			float dist = (den!=0) ? FLength(tm.GetTrans()-pt) / den : 0.0f;
			targDist = dist;
			TCHAR buf[40];
			_stprintf(buf,_T("%0.3f"),targDist);
			SetWindowText(GetDlgItem(hSpotLight,IDC_TARG_DISTANCE),buf);
			}
		}
	}

TCHAR *GeneralLight::GetObjectName()
{ 
	switch(type) {
	case OMNI_LIGHT:
		return GetString(IDS_DB_OMNI_LIGHT);
	case DIR_LIGHT:
		return GetString(IDS_DB_DIR_LIGHT);
	case TDIR_LIGHT:
		return GetString(IDS_DS_TDIR_LIGHT);
	case FSPOT_LIGHT:
		return GetString(IDS_DB_FREE_SPOT);
	case TSPOT_LIGHT:
		return GetString(IDS_DB_TARGET_SPOT);
	default:
		return NULL;
	}
}

void GeneralLight::InitNodeName(TSTR& s)
{
	switch(type) {
	case OMNI_LIGHT:
		s = GetString(IDS_DB_OMNI);
		return; 
	case DIR_LIGHT:
		s = GetString(IDS_DB_DIRECT);
		return;
	case TDIR_LIGHT:
		s = GetString(IDS_DS_TDIRECT);
		return;
	case FSPOT_LIGHT:
		s = GetString(IDS_DB_FSPOT); 
		return;
	case TSPOT_LIGHT:
		s = GetString(IDS_DB_SPOT); 
		return;
	default:
		s = GetString(IDS_DB_LIGHT); 
	}
	return;
}

#define FZ (0.0f)

#define SET_QUAD(face, v0, v1, v2, v3) \
	staticMesh[DIR_MESH].faces[face].setVerts(v0, v1, v2); \
	staticMesh[DIR_MESH].faces[face].setEdgeVisFlags(1,1,0); \
	staticMesh[DIR_MESH].faces[face+1].setVerts(v0, v2, v3); \
	staticMesh[DIR_MESH].faces[face+1].setEdgeVisFlags(0,1,1);

void GeneralLight::BuildStaticMeshes()
{
	if(!meshBuilt) {
		int nverts = 6;
		int nfaces = 8;
		// Build a leetle octahedron
		staticMesh[OMNI_MESH].setNumVerts(nverts);
		staticMesh[OMNI_MESH].setNumFaces(nfaces);
		float s = 8.0f;
		staticMesh[OMNI_MESH].setVert(0, Point3( FZ,FZ, -s));
		staticMesh[OMNI_MESH].setVert(1, Point3( s, FZ, FZ));
		staticMesh[OMNI_MESH].setVert(2, Point3( FZ, s, FZ));
		staticMesh[OMNI_MESH].setVert(3, Point3(-s, FZ, FZ));
		staticMesh[OMNI_MESH].setVert(4, Point3( FZ,-s, FZ));
		staticMesh[OMNI_MESH].setVert(5, Point3( FZ,FZ,  s));
		staticMesh[OMNI_MESH].faces[0].setVerts(0,1,4);
		staticMesh[OMNI_MESH].faces[1].setVerts(0,4,3);
		staticMesh[OMNI_MESH].faces[2].setVerts(0,3,2);
		staticMesh[OMNI_MESH].faces[3].setVerts(0,2,1);
		staticMesh[OMNI_MESH].faces[4].setVerts(5,1,2);
		staticMesh[OMNI_MESH].faces[5].setVerts(5,2,3);
		staticMesh[OMNI_MESH].faces[6].setVerts(5,3,4);
		staticMesh[OMNI_MESH].faces[7].setVerts(5,4,1);
		for (int i=0; i<nfaces; i++) {
			staticMesh[OMNI_MESH].faces[i].setSmGroup(i);
			staticMesh[OMNI_MESH].faces[i].setEdgeVisFlags(1,1,1);
			}
		staticMesh[OMNI_MESH].buildNormals();
		staticMesh[OMNI_MESH].EnableEdgeList(1);

		// Build an "arrow"
		nverts = 13;
		nfaces = 16;
		staticMesh[DIR_MESH].setNumVerts(nverts);
		staticMesh[DIR_MESH].setNumFaces(nfaces);
		s = 4.0f;
		float s4 = 16.0f;
		staticMesh[DIR_MESH].setVert( 0, Point3( -s,-s, FZ));
		staticMesh[DIR_MESH].setVert( 1, Point3(  s,-s, FZ));
		staticMesh[DIR_MESH].setVert( 2, Point3(  s, s, FZ));
		staticMesh[DIR_MESH].setVert( 3, Point3( -s, s, FZ));
		staticMesh[DIR_MESH].setVert( 4, Point3( -s,-s, -s4));
		staticMesh[DIR_MESH].setVert( 5, Point3(  s,-s, -s4));
		staticMesh[DIR_MESH].setVert( 6, Point3(  s, s, -s4));
		staticMesh[DIR_MESH].setVert( 7, Point3( -s, s, -s4));
		s *= (float)2.0;
		staticMesh[DIR_MESH].setVert( 8, Point3( -s,-s, -s4));
		staticMesh[DIR_MESH].setVert( 9, Point3(  s,-s, -s4));
		staticMesh[DIR_MESH].setVert(10, Point3(  s, s, -s4));
		staticMesh[DIR_MESH].setVert(11, Point3( -s, s, -s4));
		staticMesh[DIR_MESH].setVert(12, Point3( FZ,FZ, -s4-s));
		SET_QUAD( 0, 1, 0, 4, 5);
		SET_QUAD( 2, 0, 3, 7, 4);
		SET_QUAD( 4, 3, 2, 6, 7);
		SET_QUAD( 6, 2, 1, 5, 6);
		SET_QUAD( 8, 0, 1, 2, 3);
		SET_QUAD(10, 8, 9, 10, 11);
		staticMesh[DIR_MESH].faces[12].setVerts(8,12,9);
		staticMesh[DIR_MESH].faces[12].setEdgeVisFlags(1,1,1);
		staticMesh[DIR_MESH].faces[13].setVerts(9,12,10);
		staticMesh[DIR_MESH].faces[13].setEdgeVisFlags(1,1,1);
		staticMesh[DIR_MESH].faces[14].setVerts(10,12,11);
		staticMesh[DIR_MESH].faces[14].setEdgeVisFlags(1,1,1);
		staticMesh[DIR_MESH].faces[15].setVerts(11,12,8);
		staticMesh[DIR_MESH].faces[15].setEdgeVisFlags(1,1,1);
		for (i=0; i<nfaces; i++)
			staticMesh[DIR_MESH].faces[i].setSmGroup(i);
		staticMesh[DIR_MESH].buildNormals();
		staticMesh[DIR_MESH].EnableEdgeList(1);

		meshBuilt = 1;
	}
}


void GeneralLight::BuildSpotMesh(float coneSize)
{
	// build a cone
	if(coneSize < 0.0f)
		return;
	int nverts = 9;
	int nfaces = 8;
	spotMesh.setNumVerts(nverts);
	spotMesh.setNumFaces(nfaces);
	double radang = 3.1415926 * coneSize / 360.0;
	float h = 20.0f;					// hypotenuse
	float d = -h * (float)cos(radang);	// dist from origin to cone circle
	float r = h * (float)sin(radang);	// radius of cone circle
	float s = 0.70711f * r;  			// sin(45) * r
	spotMesh.setVert(0, Point3( FZ, FZ, FZ));
	spotMesh.setVert(1, Point3( -r, FZ, d));
	spotMesh.setVert(2, Point3( -s, -s, d));
	spotMesh.setVert(3, Point3( FZ, -r, d));
	spotMesh.setVert(4, Point3(  s, -s, d));
	spotMesh.setVert(5, Point3(  r, FZ, d));
	spotMesh.setVert(6, Point3(  s,  s, d));
	spotMesh.setVert(7, Point3( FZ,  r, d));
	spotMesh.setVert(8, Point3( -s,  s, d));
	spotMesh.faces[0].setVerts(0,1,2);
	spotMesh.faces[1].setVerts(0,2,3);
	spotMesh.faces[2].setVerts(0,3,4);
	spotMesh.faces[3].setVerts(0,4,5);
	spotMesh.faces[4].setVerts(0,5,6);
	spotMesh.faces[5].setVerts(0,6,7);
	spotMesh.faces[6].setVerts(0,7,8);
	spotMesh.faces[7].setVerts(0,8,1);
	for (int i=0; i<nfaces; i++) {
		spotMesh.faces[i].setSmGroup(i);
		spotMesh.faces[i].setEdgeVisFlags(1,1,1);
	}
	spotMesh.buildNormals();
	spotMesh.EnableEdgeList(1);
}

void GeneralLight::UpdateColBrackets(TimeValue t) {
	BOOL isKey = pblock->KeyFrameAtTime(PB_COLOR,t); 
	redSpin->SetKeyBrackets(isKey);
	greenSpin->SetKeyBrackets(isKey);
	blueSpin->SetKeyBrackets(isKey);
	colorSwatch->SetKeyBrackets(isKey);
	hSpin->SetKeyBrackets(isKey);
	sSpin->SetKeyBrackets(isKey);
	vSpin->SetKeyBrackets(isKey);
	isKey = pblock->KeyFrameAtTime(type==OMNI_LIGHT?PB_OMNISHADCOLOR:PB_SHADCOLOR,t); 
	shadColorSwatch->SetKeyBrackets(isKey);
	}

void GeneralLight::UpdateForAmbOnly() {
	BOOL b = !ambientOnly;
	if(hGeneralLight) {
		EnableWindow(GetDlgItem(hGeneralLight, IDC_AFFECT_SPECULAR), b);
		EnableWindow(GetDlgItem(hGeneralLight, IDC_AFFECT_DIFFUSE), b);
		EnableWindow(GetDlgItem(hGeneralLight, IDC_CONTRAST_T), b);
		EnableWindow(GetDlgItem(hGeneralLight, IDC_DIFFSOFT_T), b);
		EnableWindow(GetDlgItem(hGeneralLight, IDC_CAST_SHADOWS), b);
		}	
	if (contrastSpin)
		contrastSpin->Enable(b);
	if (diffsoftSpin)
		diffsoftSpin->Enable(b);
	if (hShadow) {
		EnableWindow(GetDlgItem(hShadow, IDC_GLOBAL_SET), b);
		EnableWindow(GetDlgItem(hShadow, IDC_SHADOW_MAPS), b);
		EnableWindow(GetDlgItem(hShadow, IDC_RAY_TRACED_SHADOWS), b);
		EnableWindow(GetDlgItem(hShadow, IDC_ABS_MAP_BIAS), b);
		EnableWindow(GetDlgItem(hShadow, IDC_LT_EFFECT_SHADCOL), b);
		EnableWindow(GetDlgItem(hShadow, IDC_OBJECT_SHADOWS), b);
		if (shadColorSwatch) shadColorSwatch->Enable(b);
		if (shadProjMapName) shadProjMapName->Enable(b);
		}
	}

void GeneralLight::UpdateUI(TimeValue t)
	{
	Point3 color;

	if ( hGeneralLight && !waitPostLoad &&
		GetWindowLong(hGeneralLight,GWL_USERDATA)==(LONG)this) {
		color = GetRGBColor(t);
		redSpin->SetValue( FLto255f(color.x), FALSE );
		greenSpin->SetValue( FLto255f(color.y), FALSE );
		blueSpin->SetValue( FLto255f(color.z), FALSE );
		colorSwatch->SetColor(RGB(FLto255i(color.x), FLto255i(color.y), FLto255i(color.z)));

		if(updateHSVSpin) {
			color = GetHSVColor(t);
			hSpin->SetValue( FLto255f(color.x), FALSE );
			sSpin->SetValue( FLto255f(color.y), FALSE );
			vSpin->SetValue( FLto255f(color.z), FALSE );
			}

		UpdateColBrackets(t);

		CheckDlgButton( hGeneralLight, IDC_CAST_SHADOWS, GetShadow() );
		CheckDlgButton( hShadow, IDC_OBJECT_SHADOWS, GetShadow() );

		intensitySpin->SetValue( GetIntensity(t), FALSE);
		intensitySpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_INTENSITY,t));

		contrastSpin->SetValue( GetContrast(t), FALSE);
		contrastSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_CONTRAST,t));

		diffsoftSpin->SetValue(GetDiffuseSoft(t), FALSE);
		diffsoftSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_DIFFSOFT,t));

		CheckDlgButton( hGeneralLight, IDC_LIGHT_ON, GetUseLight());
		SetDlgItemText(hGeneralLight,IDC_EXCLUDE_DLG, 
			GetString(exclList.TestFlag(NT_INCLUDE)?IDS_DS_INCLUDE__: IDS_DS_EXCLUDE__));

		if(attenStartSpin) {
			attenStartSpin->SetValue( GetAtten(t, ATTEN_START), FALSE);
			attenStartSpin->SetKeyBrackets(pblock->KeyFrameAtTime(type== OMNI_LIGHT? PB_OMNIATSTART:PB_ATTENSTART,t));
			}
		if(attenEndSpin) {
			attenEndSpin->SetValue( GetAtten(t, ATTEN_END), FALSE);
			attenEndSpin->SetKeyBrackets(pblock->KeyFrameAtTime(type== OMNI_LIGHT? PB_OMNIATEND:PB_ATTENEND,t));
			}
		CheckDlgButton( hAttenLight, IDC_SHOW_RANGES, GetAttenDisplay() );
		CheckDlgButton( hAttenLight, IDC_USE_ATTEN, GetUseAtten() );

		if(attenStart1Spin) {
			attenStart1Spin->SetValue( GetAtten(t, ATTEN1_START), FALSE);
			attenStart1Spin->SetKeyBrackets(pblock->KeyFrameAtTime(type== OMNI_LIGHT? PB_OMNIATSTART1:PB_ATTENSTART1,t));
			}
		if(attenEnd1Spin) {
			attenEnd1Spin->SetValue( GetAtten(t, ATTEN1_END), FALSE);
			attenEnd1Spin->SetKeyBrackets(pblock->KeyFrameAtTime(type== OMNI_LIGHT? PB_OMNIATEND1:PB_ATTENEND1,t));
			}
		if(decaySpin) {
			decaySpin->SetValue( GetDecayRadius(t), FALSE);
			decaySpin->SetKeyBrackets(pblock->KeyFrameAtTime(type==OMNI_LIGHT? PB_OMNIDECAY: PB_DECAY,t));
			}
		CheckDlgButton( hAttenLight, IDC_SHOW_RANGES1, GetAttenNearDisplay() );
		CheckDlgButton( hAttenLight, IDC_USE_ATTEN1, GetUseAttenNear() );

		if( IsSpot() ) {
			float hot, fall;
			if (hotsizeSpin) {
				hotsizeSpin->SetValue( hot = GetHotspot(t), FALSE );
				hotsizeSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_HOTSIZE,t));
				}

			if (fallsizeSpin) {
				fallsizeSpin->SetValue( fall = GetFallsize(t), FALSE );
				fallsizeSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_FALLSIZE,t));
				}

			if (tDistSpin&&(type == FSPOT_LIGHT||type==DIR_LIGHT)) {
				tDistSpin->SetValue( GetTDist(t), FALSE );
				tDistSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_TDIST,t));
				}

			if (aspectSpin) {
				aspectSpin->SetValue( GetAspect(t), FALSE );
				aspectSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_ASPECT,t));
				}

			CheckDlgButton( hSpotLight, IDC_SHOW_CONE, GetConeDisplay() );

			BuildSpotMesh(max(hot, fall));
			CheckDlgButton( hSpotLight, IDC_OVERSHOOT, GetOvershoot() ); 
			CheckDlgButton( hSpotLight, IDC_PROJECTOR, GetProjector() ); 
			}
	
		CheckDlgButton( hShadow, IDC_LT_EFFECT_SHADCOL, GetLightAffectsShadow() );
		CheckRadioButton( hShadow, IDC_SHADOW_MAPS, IDC_RAY_TRACED_SHADOWS, 
			IDC_SHADOW_MAPS+GetShadowType());
		CheckDlgButton( hShadow, IDC_GLOBAL_SET, GetUseGlobal() ); 
		CheckDlgButton( hShadow, IDC_ABS_MAP_BIAS, GetAbsMapBias() ); 
		color = GetShadColor(t);
		shadColorSwatch->SetColor(RGB(FLto255i(color.x), FLto255i(color.y), FLto255i(color.z)));

		CheckDlgButton( hShadow, IDC_ATMOS_SHADOWS, GetAtmosShadows(t) ); 
		atmosOpacitySpin->SetValue( GetAtmosOpacity(t)*100.0f, FALSE );
		atmosOpacitySpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_ATM_OPAC(this),t));
		atmosColAmtSpin->SetValue( GetAtmosColAmt(t)*100.0f, FALSE );
		atmosColAmtSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_ATM_COLAMT(this),t));
		shadMultSpin->SetValue( GetShadMult(t), FALSE );
		shadMultSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_SHAD_MULT(this),t));
		if (projMapName)
			projMapName->SetText(projMap?projMap->GetFullName().data():GetString(IDS_DB_NONE));
		if (shadProjMapName)
			shadProjMapName->SetText(shadProjMap?shadProjMap->GetFullName().data():GetString(IDS_DB_NONE));
		if ( hEmitter )
		{
			// Emitter
			CheckDlgButton( hEmitter, IDC_EMITTER_ENABLE, GetEmitterEnable( t ) );
			emitterEnergySpin->SetValue( GetEmitterEnergy(t), FALSE );
			emitterEnergySpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_EMITTER_ENERGY,t));
			emitterCAPhotonsSpin->SetValue( GetEmitterCausticPhotons(t), FALSE );
			emitterCAPhotonsSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_EMITTER_CA_PHOTONS,t));
			emitterGIPhotonsSpin->SetValue( GetEmitterGlobalIllumPhotons(t), FALSE );
			emitterGIPhotonsSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_EMITTER_GI_PHOTONS,t));
		}
		}
	}


// description for version 0
static ParamBlockDescID descV0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// red
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// green
	{ TYPE_FLOAT, NULL, TRUE, 3 },		// blue
	{ TYPE_FLOAT, NULL, TRUE, 7 } };	// hotsize

// description for version 1
static ParamBlockDescID descV1[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// tdist
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 12 } };	// blur

// description for version 2
static ParamBlockDescID descV2[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// tdist
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 12 },  	// blur
	{ TYPE_INT, NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }};  	// raytrace bias

// description for version 3 -- all but omni
static ParamBlockDescID descV3[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 12 },  	// blur
	{ TYPE_INT, NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start		<- atten comes last because dir light doesn't have it
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }};		// tdist

// description for version 3 -- only omni
static ParamBlockDescID descV3Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start
	{ TYPE_FLOAT, NULL, TRUE, 6 }};		// atten end

// description for versions 4 -- all but omni

static ParamBlockDescID descV4[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT, NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start		<- atten comes last because dir light doesn't have it
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }};		// tdist

// description for version 4 -- only omni
static ParamBlockDescID descV4Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start
	{ TYPE_FLOAT, NULL, TRUE, 6 }};		// atten end

// description for versions 5 - all but omni
static ParamBlockDescID descV5[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }};		// tdist


// description for version 5 -- only omni
static ParamBlockDescID descV5Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 }};	 // atten end 


// description for versions 6 - all but omni
static ParamBlockDescID descV6[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }};		// tdist

// description for version 6 -- only omni
static ParamBlockDescID descV6Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_INT,   NULL, TRUE, 13 }, 	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 }, 	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 }, 	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }, 	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 }};		// atten end 


// description for versions 7 - all but omni
static ParamBlockDescID descV7[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }};		// tdist

// description for version 7 -- only omni
static ParamBlockDescID descV7Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_INT,   NULL, TRUE, 13 }, 	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 }, 	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 }, 	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }, 	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 }};		// atten end 


// ---------------- Version 8  ( Max 2.0 )

// description for versions 8  - all but omni
static ParamBlockDescID descV8[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 9 }	   	// TDIST
	};		


//-------- Version 9:  6/1/98----------------

// description for versions 9  - all but omni
static ParamBlockDescID descV9[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_FLOAT, NULL, TRUE, 9 }	   	// TDIST
	};		

// description for version 9 -- only omni
static ParamBlockDescID descV9Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_INT,   NULL, TRUE, 13 }, 	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 }, 	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 }, 	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }, 	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_RGBA,  NULL, TRUE, 21 }		// shad color
	};


//-------- Version 10:  8/14/98----------------

// description for version 10  - all but omni
static ParamBlockDescID descV10[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_FLOAT, NULL, TRUE, 9 }	   	// TDIST
	};		

static ParamBlockDescID descV10Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_INT,   NULL, TRUE, 13 }, 	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 }, 	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 }, 	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }, 	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius 
	{ TYPE_RGBA,  NULL, TRUE, 21 }		// shad color
	};


//-------- Version 11:  9/16/98----------------

// description for version 11  - all but omni 
static ParamBlockDescID descV11[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_INT,   NULL, TRUE, 13 },  	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 },  	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 },  	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 },  	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 9 }	   	// TDIST
	};		

static ParamBlockDescID descV11Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_INT,   NULL, TRUE, 13 }, 	// mapSize
	{ TYPE_FLOAT, NULL, TRUE, 14 }, 	// mapBias
	{ TYPE_FLOAT, NULL, TRUE, 15 }, 	// mapRange
	{ TYPE_FLOAT, NULL, TRUE, 16 }, 	// raytrace bias
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius 
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 }		// atmosphere color influence
	};


//-------- Version 12:  11/2/98----------------
// Shadow Generator plugins added.
// description for version 12  - all but omni 
static ParamBlockDescID descV12[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 9 }	   	// TDIST
	};		

// description for version 12  - omni's 
static ParamBlockDescID descV12Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius 
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 }		// atmosphere color influence
	};


//-------- Version 13:  11/9/98----------------
// Added shad mult
// description for version 13  - all but omni 
static ParamBlockDescID descV13[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 26 },	   	// shadow multiplier
	{ TYPE_FLOAT, NULL, TRUE, 9 }   	// TDIST
	};		

// description for version 13  - omni's 
static ParamBlockDescID descV13Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius 
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 26 }	   	// shadow multiplier
	};

//-------- Version 14:  11/20/98----------------
// Added shad mult
// description for version 14  - all but omni 
static ParamBlockDescID descV14[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },	// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// hotsize
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// fallsize
	{ TYPE_FLOAT, NULL, TRUE, 11 },		// aspect
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 	
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 26 },	   	// shadow multiplier
	{ TYPE_INT,   NULL, FALSE, 27 },	// use shadow colormap
	{ TYPE_FLOAT, NULL, TRUE, 9 }   	// TDIST
	};		

// description for version 14  - omni's 
static ParamBlockDescID descV14Omni[] = {
	{ TYPE_RGBA, NULL, TRUE, 10 },		// color
	{ TYPE_FLOAT, NULL, TRUE, 4 },		// intensity
	{ TYPE_FLOAT, NULL, TRUE, 19},		// contrast
	{ TYPE_FLOAT, NULL, TRUE, 20},		// diffsoft
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// atten start near
	{ TYPE_FLOAT, NULL, TRUE, 18 },		// atten end near
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// atten start 
	{ TYPE_FLOAT, NULL, TRUE, 6 },		// atten end 
	{ TYPE_FLOAT, NULL, TRUE, 22 },		// decay radius 
	{ TYPE_RGBA,  NULL, TRUE, 21 },		// shad color
	{ TYPE_INT,   NULL, FALSE, 23 },	// atmosphere shadows
	{ TYPE_FLOAT, NULL, TRUE, 24 },		// atmosphere opacity
	{ TYPE_FLOAT, NULL, TRUE, 25 },		// atmosphere color influence
	{ TYPE_FLOAT, NULL, TRUE, 26 },	   	// shadow multiplier
	{ TYPE_INT,   NULL, FALSE, 27 }	// use shadow colormap
	};

static ParamBlockDescID emitterV01[] = {
	{ TYPE_BOOL,  NULL, TRUE, PB_EMITTER_ENABLE },		// PB_EMITTER_ENABLE
	{ TYPE_FLOAT, NULL, TRUE, PB_EMITTER_ENERGY },		// PB_EMITTER_ENERGY
	{ TYPE_INT,	  NULL, FALSE, PB_EMITTER_DECAY_TYPE },	// PB_EMITTER_DECAY_TYPE
	{ TYPE_INT,   NULL, TRUE, PB_EMITTER_CA_PHOTONS },	// PB_EMITTER_CA_PHOTONS
	};		
static numEmitterV01Params = sizeof ( emitterV01 ) / sizeof ( ParamBlockDescID );

// Added global illumination photons
static ParamBlockDescID emitterV02[] = {
	{ TYPE_BOOL,  NULL, TRUE, PB_EMITTER_ENABLE },		// PB_EMITTER_ENABLE
	{ TYPE_FLOAT, NULL, TRUE, PB_EMITTER_ENERGY },		// PB_EMITTER_ENERGY
	{ TYPE_INT,	  NULL, FALSE, PB_EMITTER_DECAY_TYPE },	// PB_EMITTER_DECAY_TYPE
	{ TYPE_INT,   NULL, TRUE, PB_EMITTER_CA_PHOTONS },	// PB_EMITTER_CA_PHOTONS
	{ TYPE_INT,   NULL, TRUE, PB_EMITTER_GI_PHOTONS },	// PB_EMITTER_GI_PHOTONS
	};		
static numEmitterV02Params = sizeof ( emitterV02 ) / sizeof ( ParamBlockDescID );


#define LIGHT_VERSION 14		// current version
#define EMITTER_VERSION 2		// current version

ParamBlockDescID *descs[LIGHT_VERSION+1] = {
	  descV0, 
	  descV1, 
	  descV2, 
	  descV3, 
	  descV4,  
	  descV5, 
	  descV6,
	  descV7, 
	  descV8, 
	  descV9,
	  descV10,
	  descV11, 
	  descV12, 
	  descV13, 
	  descV14 
	  };	 

ParamBlockDescID *omniDescs[LIGHT_VERSION+1] = {
	  descV0,     //0
	  descV1,     //1
	  descV2,     //2
	  descV3Omni, //3	
	  descV4Omni, //4	
	  descV5Omni, //5	
	  descV6Omni, //6	
	  descV7Omni, //7	
	  descV9Omni, //8	
	  descV9Omni,  //9
	  descV10Omni, //10
	  descV11Omni,  //11
	  descV12Omni,  //12
	  descV13Omni,  //13
	  descV14Omni  //14
	  };	
	
static ParamVersionDesc emitterVersions[] = {
	ParamVersionDesc ( emitterV01, numEmitterV01Params, 1 )
};

static numEmitterVersions = sizeof ( emitterVersions ) / sizeof ( ParamVersionDesc );

static ParamVersionDesc curEmitterVersion ( emitterV02, numEmitterV02Params, EMITTER_VERSION );

// number of parameters for different light types (omni, target spot, free directional, free spot, target directional )
static int pbDim1[5] = { 4,  9,  2,  9,  4};
static int pbDim2[5] = { 4, 13,  2, 13, 13};
static int pbDim3[5] = { 4, 12, 10, 13, 12};
static int pbDim4[5] = { 4, 11,  9, 12, 11};
static int pbDim5[5] = { 6, 13, 14, 14, 13};  
static int pbDim6[5] = { 10, 13, 14, 14, 13};  
static int pbDim7[5] = { 11, 14, 15, 15, 14};  
static int pbDim8[5] = { 12, 15, 16, 16, 15};  
static int pbDim9[5] = { 13, 16, 17, 17, 16};  
static int pbDim10[5] = { 14, 17, 18, 18, 17};  
static int pbDim11[5] = { 17, 20, 21, 21, 20};  
static int pbDim12[5] = { 13, 16, 17, 17, 16};  
static int pbDim13[5] = { 14, 17, 18, 18, 17};  
static int pbDim14[5] = { 15, 18, 19, 19, 18};  

static int *pbdims[LIGHT_VERSION+1] = {
	pbDim1,	pbDim1,	pbDim2, pbDim3,	pbDim4,
	pbDim5,	pbDim6,	pbDim7,	pbDim8,	pbDim9, 
	pbDim10, pbDim11, pbDim12, pbDim13, pbDim14
	};

static int GetDim(int vers, int type) {
	return pbdims[vers][type];
	}

static  ParamBlockDescID* GetDesc(int vers, int type) {
	return type == OMNI_LIGHT ? omniDescs[vers] : descs[vers];
	}

//====================================================================



void GeneralLight::BuildMeshes(BOOL isnew) {
	if( IsSpot() ) {
		if (isnew) {
			SetHotspot( TimeValue(0), dlgHotsize);
			SetFallsize( TimeValue(0), dlgFallsize);
			if(dlgTDist < 1.0f)
				SetTDist( TimeValue(0), DEF_TDIST);
			else
				SetTDist( TimeValue(0), dlgTDist);
			SetAspect( TimeValue(0), dlgAspect);
			coneDisplay = dlgShowCone;
			shape = dlgShape;
			}
		BuildSpotMesh(GetHotspot(TimeValue(0)));
		if(type == DIR_LIGHT||type == TDIR_LIGHT) {
			BuildStaticMeshes();
			mesh = &staticMesh[DIR_MESH];
			}
		else
			mesh = &spotMesh;
		}
	else {
		BuildStaticMeshes();
		mesh = &staticMesh[type == OMNI_LIGHT ? OMNI_MESH : DIR_MESH];
		}
	}

//static void NotifyPreSaveOld(void *param, NotifyInfo *info) {
//	((GeneralLight *)param)->PreSaveOld();
//	}

//static void NotifyPostSaveOld(void *param, NotifyInfo *info) {
//	((GeneralLight *)param)->PostSaveOld();
//	}

void GeneralLight::PreSaveOld() { 
//	if (GetSavingVersion()==2000) {
//		int oldver = 8;
//		temppb = UpdateParameterBlock(GetDesc(LIGHT_VERSION,type),GetDim(LIGHT_VERSION,type),
//			pblock,	GetDesc(oldver,type),GetDim(oldver,type), oldver);
//		}
	}

void GeneralLight::PostSaveOld() { 
//	if (temppb) {
//		temppb->DeleteThis();
//		temppb = NULL;
//		}
	}

struct NChange {
	TCHAR *oldname;
	TCHAR *newname;
	}; 

static void NameChangeNotify(void *param, NotifyInfo *info) {
	GeneralLight *lt = (GeneralLight *)param;
	NChange *nc = (NChange *)info->callParam;
	NameTab* nt = lt->GetExclList();
	int i = nt->FindName(nc->oldname);
	if (i>=0)  
		nt->SetName(i,nc->newname);
	}

GeneralLight::GeneralLight(int tp)
{

	type = tp;
	temppb = NULL;
	MakeRefByID( FOREVER, 0, 
		CreateParameterBlock( GetDesc(LIGHT_VERSION,type), GetDim(LIGHT_VERSION,type), LIGHT_VERSION ) );	

	MakeRefByID( FOREVER, EMITTER_REF, 
		CreateParameterBlock( emitterV02, sizeof ( emitterV02 ) / sizeof ( ParamBlockDescID ), EMITTER_VERSION ));	

#ifdef USE_DLG_COLOR
	SetRGBColor( TimeValue(0), Point3(dlgRed/255.0f, dlgGreen/255.0f, dlgBlue/255.0f));
#else
	SetRGBColor( TimeValue(0), Point3(float(INITINTENS)/255.0f, float(INITINTENS)/255.0f, float(INITINTENS)/255.0f));
#endif
	SetShadColor( TimeValue(0), Point3(0,0,0));
	SetIntensity( TimeValue(0), dlgIntensity);	
	SetContrast( TimeValue(0), dlgContrast);
	SetDiffuseSoft( TimeValue(0), dlgDiffsoft);
	coneDisplay = 0;
	shape = CIRCLE_LIGHT;
	useLight = TRUE;
	attenDisplay = 0;
	decayDisplay = 0;
	useAtten = 0;
	attenNearDisplay = 0;
	useAttenNear = 0;
	enable=FALSE;
#ifndef DESIGN_VER
	shadow = FALSE;
#else
	shadow = TRUE;
#endif
	shadowType = 0;
	useGlobalShadowParams = FALSE;
	absMapBias = FALSE;	 // DS 7/27/98
	overshoot = FALSE;
	projector= FALSE;
	projMap = NULL;
    shadProjMap = NULL;

	shadType = NULL;
	MakeRefByID( FOREVER, SHADTYPE_REF, (ShadowType *)CreateInstance(SHADOW_TYPE_CLASS_ID, dlgShadType));

	updateHSVSpin = TRUE;
	softenDiffuse = FALSE;
	affectDiffuse = TRUE;
	affectSpecular = TRUE;
	ambientOnly = FALSE;
	decayType = DECAY_NONE;
	ltAffectsShadow = FALSE; 
	targDist = 0.0f;

	SetAtten( TimeValue(0), ATTEN1_START, dlgAtten1Start);
	SetAtten( TimeValue(0), ATTEN1_END, dlgAtten1End);
	SetAtten( TimeValue(0), ATTEN_START, dlgAttenStart);
	SetAtten( TimeValue(0), ATTEN_END, dlgAttenEnd);
	attenDisplay = dlgShowAtten;
	attenNearDisplay = dlgShowAttenNear;
	decayDisplay = dlgShowDecay;
	useAtten = dlgUseAtten;

	SetDecayRadius( TimeValue(0), dlgDecayRadius);
	SetAtmosOpacity( TimeValue(0), dlgAtmosOpacity);
	SetAtmosColAmt( TimeValue(0), dlgAtmosColamt);
	SetAtmosShadows( TimeValue(0), dlgAtmosShadows);
	SetShadColor(TimeValue(0), Point3(float(dlgShadColor.r)/255.0f, float(dlgShadColor.g)/255.0f, float(dlgShadColor.b)/255.0f));
	SetShadMult( TimeValue(0), dlgShadMult);
	SetLightAffectsShadow(dlgLightAffectShadColor);
	SetUseGlobal(dlgUseGlobalShadowParams);

	SetEmitterEnable ( TimeValue (0), dlgEmitterEnable );
	SetEmitterEnergy  ( TimeValue (0), dlgEmitterEnergy );
	SetEmitterDecayType	( TimeValue (0), dlgEmitterDecayType );
	SetEmitterCausticPhotons ( TimeValue (0), dlgEmitterCAPhotons );
	SetEmitterGlobalIllumPhotons ( TimeValue (0), dlgEmitterGIPhotons );

	BuildMeshes();	
//	RegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
//	RegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);
	RegisterNotification(NameChangeNotify, (void *)this, NOTIFY_NODE_RENAMED);
	}

BOOL GeneralLight::IsCompatibleRenderer ( void )
{
	Class_ID	rclass = Class_ID ( 0x58f67d6c, 0x4fcf3bc3 ); // From Ganesh translator
	ClassDesc	*cd = GetCOREInterface()->GetDllDir().ClassDir().FindClass(RENDERER_CLASS_ID, rclass );

	if ( cd != NULL )
		return TRUE;

	return FALSE;
}


//----------------------------------------------------------------
static BOOL HasTarg(int tp) {
	switch (tp) {
		case OMNI_LIGHT: return FALSE;
		case TSPOT_LIGHT: return TRUE;
		case DIR_LIGHT: return FALSE;
		case FSPOT_LIGHT: return FALSE;
		case TDIR_LIGHT: return TRUE;
		}
	return FALSE;
	}


//----------------------------------------------------------------

class SetTypeRest: public RestoreObj {
	public:
		GeneralLight *theLight;
		int oldtype,newtype;
		SetTypeRest(GeneralLight *lt, int newt) {
			theLight = lt;
			oldtype = lt->Type();
			newtype = newt;
			}
		~SetTypeRest() { }
		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		virtual TSTR Description() { return TSTR(_T("Set Light Type")); }
	};


void SetTypeRest::Restore(int isUndo) {
	theLight->type = oldtype;
	theLight->BuildMeshes(0);
	theLight->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void SetTypeRest::Redo() {
	theLight->type = newtype;
	theLight->BuildMeshes(0);
	theLight->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

/*----------------------------------------------------------------*/

void GeneralLight::SetType(int tp) {     
	if (type == tp) 
		return;
	// This is here to notify the viewports that the light type is changing.
	// It has to come before the change so that the viewport parameters don't
	// get screwed up.		// DB 4/29/99
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_OBREF_CHANGE);

	BOOL oldHasTarg = HasTarg(type);
	BOOL newHasTarg = HasTarg(tp);

	Interface *iface = GetCOREInterface();
	TimeValue t = iface->GetTime();
	INode *selnode = NULL;
	INode *nd = FindNodeRef(this);
	if (nd==NULL) 
		return;

	if (hGeneralLight) {
		selnode = FindSelNodeRef(this);
		if (selnode)
			iface->DeSelectNode(selnode);  // this removes the rollups in a clean way
		}

	if (theHold.Holding())
		theHold.Put(new SetTypeRest(this,tp));

	int oldtype = type;
	Interval v;
	float tdist = GetTDist(t,v);
	if (oldtype==OMNI_LIGHT) 
		tdist = 100.0f;
	else if(HasTarg(oldtype))
		tdist = targDist;
	type = tp;
	int *pbd = pbdims[LIGHT_VERSION];
	if (pbd[oldtype]!=pbd[type]) {
		IParamBlock *pbnew = UpdateParameterBlock(
			GetDesc(LIGHT_VERSION,oldtype), GetDim(LIGHT_VERSION, oldtype), pblock,
			GetDesc(LIGHT_VERSION,type), GetDim(LIGHT_VERSION,type), LIGHT_VERSION);
		ReplaceReference( 0, pbnew);	
		}

	HWND hwgl = hGeneralLight;
	hGeneralLight = NULL; // This keeps UpdateUI from jumping in
	
	BuildMeshes(oldtype==OMNI_LIGHT?1:0);

	hGeneralLight = hwgl;

	if (oldHasTarg && !newHasTarg) {
		// get rid of target, assign a PRS controller for all instances
		DependentIterator di(this);
		ReferenceMaker *rm;
		// iterate through the instances
		while (rm=di.Next()) {
			nd = GetNodeRef(rm);
			if (nd) {
				INode* tn = nd->GetTarget(); 
				Matrix3 tm = nd->GetNodeTM(0);
				iface->DeleteNode(tn);
				Control *tmc = NewDefaultMatrix3Controller();
				tmc->Copy(nd->GetTMController()); // didn't work!!?
				nd->SetTMController(tmc);
				nd->SetNodeTM(0,tm);
				SetTDist(t,tdist);	 //?? which one should this be for
				}
			}

		
		}
	if (newHasTarg && !oldHasTarg) {
		DependentIterator di(this);
		ReferenceMaker *rm;
		// iterate through the instances
		while (rm=di.Next()) {	
			nd = GetNodeRef(rm);
			if (nd) {
				// create a target, assign lookat controller
				Matrix3 tm = nd->GetNodeTM(t);
				Matrix3 targtm = tm;
				targtm.PreTranslate(Point3(0.0f,0.0f,-tdist));
				Object *targObject = new TargetObject;
				INode *targNode = iface->CreateObjectNode( targObject);
				TSTR targName;
				targName = nd->GetName();
				targName += GetString(IDS_DB_DOT_TARGET);
				targNode->SetName(targName);
				Control *laControl= CreateLookatControl();
				targNode->SetNodeTM(0,targtm);
				laControl->SetTarget(targNode);
				laControl->Copy(nd->GetTMController());
				nd->SetTMController(laControl);
				targNode->SetIsTarget(1);   
				}
			}
		}
	if (selnode)
		iface->SelectNode(selnode);

	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	iface->RedrawViews(iface->GetTime());
	}

//----------------------------------------------------------------

class ShadTypeRest: public RestoreObj, public ReferenceMaker {
	public:
		GeneralLight *theLight;
		ShadowType *oldtype,*newtype;
		ShadTypeRest(GeneralLight *lt, ShadowType *s) {
			oldtype = newtype = NULL;
			theLight = lt;
			theHold.Suspend();
			ReplaceReference(0,lt->GetShadowGenerator());
			ReplaceReference(1,s);
			theHold.Resume();
			}
		~ShadTypeRest() {
			DeleteAllRefsFromMe();
			}
		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		TSTR Description() { return TSTR(_T("Set Shadow Type")); }
		// ReferenceMaker 
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) { 
			if (message==REFMSG_TARGET_DELETED) {
				if (hTarget==oldtype) 
				    oldtype = NULL;
				if (hTarget==newtype) 
				    newtype = NULL;
				}
		   	return REF_SUCCEED; 
		   	}
		int NumRefs() { return 2; }
		RefTargetHandle GetReference(int i) { return i==0?oldtype:newtype; }
		void SetReference(int i, RefTargetHandle rtarg) { 
			if (i==0) oldtype = (ShadowType *)rtarg; else newtype = (ShadowType *)rtarg;
			}
		BOOL CanTransferReference(int i) { return FALSE;}
	};


void ShadTypeRest::Restore(int isUndo) {
	theHold.Suspend();
	theLight->SetShadowGenerator(oldtype);
	theHold.Resume();
	}

void ShadTypeRest::Redo() {
	theHold.Suspend();
	theLight->SetShadowGenerator(newtype);
	theHold.Resume();
	}

static int ShadTypeFromGen(ShadowType *s) {	
	if (s) {
		if (s->ClassID()==Class_ID(STD_SHADOW_MAP_CLASS_ID,0))
			return 0;
		if (s->ClassID()==Class_ID(STD_RAYTRACE_SHADOW_CLASS_ID,0))
			return 1;
		else
			return 0xFFFF;
		}
	return -1;
	}

int GeneralLight::GetShadowType() { 
	return useGlobalShadowParams? ShadTypeFromGen(GetCOREInterface()->GetGlobalShadowGenerator()):
		 ShadTypeFromGen(shadType); 
	}

void GeneralLight::SetShadowType(int a) { 
	ShadowType *s = a ?NewDefaultRayShadowType() : NewDefaultShadowMapType();
	if (useGlobalShadowParams) {
		GetCOREInterface()->SetGlobalShadowGenerator(s); 	
		globShadowType = a; 
		}
	else {
		SetShadowGenerator(s); 	
		shadowType = a;
		}
	}

/*----------------------------------------------------------------*/
void GeneralLight::SetShadowGenerator(ShadowType *s) {
	if (s==NULL) 
		return; 
	Interface *ip = GetCOREInterface();
	if (theHold.Holding())
		theHold.Put(new ShadTypeRest(this,s));
	theHold.Suspend();
	if (hGeneralLight) {
		if (!inCreate)
			ip->DeleteSFXRollupPage();
		shadParamDlg->DeleteThis(); 
		}
	if (useGlobalShadowParams) 
		ip->SetGlobalShadowGenerator(s);
	else 
		ReplaceReference(SHADTYPE_REF,s);
	if (hGeneralLight) {
		shadParamDlg = ActiveShadowType()->CreateShadowParamDlg(ip);  
		if (!inCreate)
			ip->AddSFXRollupPage();
		UpdtShadowTypeSel();
		}
	shadowType = ShadTypeFromGen(shadType);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);	
	theHold.Resume();
	}

void GeneralLight::SetUseGlobal(int a) { 
	if (useGlobalShadowParams==a) return;
	Interface *ip = GetCOREInterface();
	if (hGeneralLight) {
		if (!inCreate)
			ip->DeleteSFXRollupPage();
		shadParamDlg->DeleteThis(); 
		}
	useGlobalShadowParams =a; 
	if (hGeneralLight) {
		shadParamDlg = ActiveShadowType()->CreateShadowParamDlg(ip);  
		if (!inCreate)
			ip->AddSFXRollupPage();
		UpdtShadowTypeList(hShadow);
		}
	}

ShadowType * GeneralLight::ActiveShadowType() { 
	if (useGlobalShadowParams) {
		Interface *ip = GetCOREInterface();
		return ip->GetGlobalShadowGenerator();		
		}
	else 
		return shadType; 
	}

BOOL GeneralLight::SetHotSpotControl(Control *c)
	{
	pblock->SetController(PB_HOTSIZE,c);
	return TRUE;
	}

BOOL GeneralLight::SetFalloffControl(Control *c)
	{
	pblock->SetController(PB_FALLSIZE,c);
	return TRUE;
	}

BOOL GeneralLight::SetColorControl(Control *c)
	{
	pblock->SetController(PB_COLOR,c);
	return TRUE;
	}


Control* GeneralLight::GetHotSpotControl(){
	return	pblock->GetController(PB_HOTSIZE);
	}

Control* GeneralLight::GetFalloffControl(){
	return	pblock->GetController(PB_FALLSIZE);
	}

Control* GeneralLight::GetColorControl() {
	return	pblock->GetController(PB_COLOR);
	}

void GeneralLight::SetIntensity(TimeValue t, float f)
{
	pblock->SetValue( PB_INTENSITY, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetIntensity(TimeValue t, Interval& valid)
{
	float f;
	pblock->GetValue( PB_INTENSITY, t, f, valid );
	return f;
}



void GeneralLight::SetContrast(TimeValue t, float f)
{
	pblock->SetValue( PB_CONTRAST, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetContrast(TimeValue t, Interval& valid)
{
	float f;
	pblock->GetValue( PB_CONTRAST, t, f, valid );
	return f;
}

void GeneralLight::SetDiffuseSoft(TimeValue t, float f)
{
	pblock->SetValue( PB_DIFFSOFT, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetDiffuseSoft(TimeValue t, Interval& valid)
{
	float f;
	pblock->GetValue( PB_DIFFSOFT, t, f, valid );
	return f;
}


void GeneralLight::SetHotspot(TimeValue t, float f)
{
	if(!IsSpot())
		return;
	if(f < 0.5f)
		f = 0.5f;
	if(!IsDir() && (f > 179.5f))
		f = 179.5f;
	pblock->SetValue( PB_HOTSIZE, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetHotspot(TimeValue t, Interval& valid)
{
	Interval iv;

	if(!IsSpot())
		return -1.0f;
	float f;
	pblock->GetValue( PB_HOTSIZE, t, f, valid );
	if(GetFallsize(t, iv) < f )
		return GetFallsize(t, iv);
	return f;
}

void GeneralLight::SetFallsize(TimeValue t, float f)
{
	if(!IsSpot())
		return;
	if(f < 0.5f)
		f = 0.5f;
	if(!IsDir() && (f > 179.5f))
		f = 179.5f;
	pblock->SetValue( PB_FALLSIZE, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetFallsize(TimeValue t, Interval& valid)
{
	if(!IsSpot())
		return -1.0f;
	float f;
	pblock->GetValue( PB_FALLSIZE, t, f, valid );
	return f;
}

void GeneralLight::SetAtten(TimeValue t, int which, float f)
{
//	if(type == DIR_LIGHT)
//		return;
	pblock->SetValue( (type == OMNI_LIGHT ? PB_OMNIATSTART1 : PB_ATTENSTART1) + which, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetAtten(TimeValue t, int which, Interval& valid)
{
//	if(type == DIR_LIGHT)
//		return -1.0f;
	float f;
	pblock->GetValue( (type == OMNI_LIGHT ? PB_OMNIATSTART1 : PB_ATTENSTART1) + which, t, f, valid );
	return f;
}

void GeneralLight::SetTDist(TimeValue t, float f)
{
	if(type != FSPOT_LIGHT&&type != DIR_LIGHT)
		return;
	pblock->SetValue( PB_TDIST, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetTDist(TimeValue t, Interval& valid)
{
	if(!IsSpot())
		return -1.0f;
	if( type == TDIR_LIGHT || type == TSPOT_LIGHT)
		return 0.0f;
	float f;
	pblock->GetValue( PB_TDIST, t, f, valid );
	return f;
}

void GeneralLight::SetDecayRadius(TimeValue t, float f)
	{
	pblock->SetValue( type==OMNI_LIGHT? PB_OMNIDECAY: PB_DECAY, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

float GeneralLight::GetDecayRadius(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue( type==OMNI_LIGHT? PB_OMNIDECAY: PB_DECAY, t, f, valid );
	return f;
	}


void GeneralLight::SetRGBColor(TimeValue t, Point3 &rgb) 
{
	pblock->SetValue( PB_COLOR, t, rgb );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

Point3 GeneralLight::GetRGBColor(TimeValue t, Interval& valid) 
{	
	Point3 rgb;
	pblock->GetValue( PB_COLOR, t, rgb, valid );
	return rgb;
}

void GeneralLight::SetShadColor(TimeValue t, Point3 &rgb) 
	{
	pblock->SetValue( type == OMNI_LIGHT ? PB_OMNISHADCOLOR : PB_SHADCOLOR, t, rgb );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Point3 GeneralLight::GetShadColor(TimeValue t, Interval& valid) 
	{	
	Point3 rgb;
	pblock->GetValue( type == OMNI_LIGHT ?PB_OMNISHADCOLOR : PB_SHADCOLOR, t, rgb, valid );
	return rgb;
	}

void GeneralLight::SetShadMult(TimeValue t, float m) {
	pblock->SetValue( PB_SHAD_MULT(this), t, m );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}
	
float GeneralLight::GetShadMult(TimeValue t, Interval &valid) {
	float f;
	pblock->GetValue( PB_SHAD_MULT(this), t, f, valid );
	return f;
	}

void GeneralLight::SetHSVColor(TimeValue t, Point3& hsv) 
{
	DWORD rgb = HSVtoRGB ((int)(hsv[0]*255.0f), (int)(hsv[1]*255.0f), (int)(hsv[2]*255.0f));
	Point3 rgbf;
	rgbf[0] = GetRValue(rgb) / 255.0f;
	rgbf[1] = GetGValue(rgb) / 255.0f;
	rgbf[2] = GetBValue(rgb) / 255.0f;
	SetRGBColor(t, rgbf);
}

Point3 GeneralLight::GetHSVColor(TimeValue t, Interval& valid) 
{	
	int h, s, v;
	Point3 rgbf = GetRGBColor(t, valid);
	DWORD rgb = RGB((int)(rgbf[0]*255.0f), (int)(rgbf[1]*255.0f), (int)(rgbf[2]*255.0f));
	RGBtoHSV (rgb, &h, &s, &v);
	return Point3(h/255.0f, s/255.0f, v/255.0f);
}

void GeneralLight::SetUseLight(int onOff)
{
	useLight = onOff;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}


void GeneralLight::SetConeDisplay(int s, int notify) 
{
	coneDisplay = s;
	if(notify && IsSpot())
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

void GeneralLight::SetOvershoot(int a)
{
	overshoot = a;
	if(IsSpot())
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

void GeneralLight::SetSpotShape(int s)
{
	shape = s;
	if(IsSpot())
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

void GeneralLight::SetAspect(TimeValue t, float f)
{
	if(!IsSpot())
		return;
	pblock->SetValue( PB_ASPECT, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

float GeneralLight::GetAspect(TimeValue t, Interval& valid)
{
	if(!IsSpot())
		return -1.0f;
	float f;
	pblock->GetValue( PB_ASPECT, t, f, valid );
	return f;
}

void GeneralLight::SetMapBias(TimeValue t, float f) {
	ActiveShadowType()->SetMapBias(t,f);
	}

float GeneralLight::GetMapBias(TimeValue t, Interval& valid) {
	return ActiveShadowType()->GetMapBias(t,valid);
	}

void GeneralLight::SetMapRange(TimeValue t, float f) {
	ActiveShadowType()->SetMapRange(t,f);
	}

float GeneralLight::GetMapRange(TimeValue t, Interval& valid){
	return ActiveShadowType()->GetMapRange(t,valid);
	}

void GeneralLight::SetMapSize(TimeValue t, int f) {
	ActiveShadowType()->SetMapSize(t,f);
	}

int GeneralLight::GetMapSize(TimeValue t, Interval& v){
	return ActiveShadowType()->GetMapSize(t,v);
	}

void GeneralLight::SetRayBias(TimeValue t, float f) {
	ActiveShadowType()->SetRayBias(t,f);
	}

float GeneralLight::GetRayBias(TimeValue t, Interval& v){
	return ActiveShadowType()->GetRayBias(t,v);
	}

void GeneralLight::SetAtmosShadows(TimeValue t, int onOff)
	{
	atmosShadows = onOff;
	pblock->SetValue( PB_ATM_SHAD(this), t, onOff );
	}

int GeneralLight::GetAtmosShadows(TimeValue t)
	{
	int onOff;
	Interval valid = Interval(0,0);
	pblock->GetValue( PB_ATM_SHAD(this), t, onOff, valid );
	return onOff;
	}

void GeneralLight::SetUseShadowColorMap(TimeValue t, int onOff) {
	pblock->SetValue( PB_USE_SHAD_COLMAP(this), t, onOff );
	}

int GeneralLight::GetUseShadowColorMap(TimeValue t) {
	int onOff;
	Interval valid = Interval(0,0);
	pblock->GetValue( PB_USE_SHAD_COLMAP(this), t, onOff, valid );
	return onOff;
	}

void GeneralLight::SetAtmosOpacity(TimeValue t, float f)
	{
	atmosOpacity = f;
//	if (useGlobalShadowParams)  globAtmosOpacity = f;
//	else 
		pblock->SetValue( PB_ATM_OPAC(this), t, f );
	}

float GeneralLight::GetAtmosOpacity(TimeValue t, Interval& valid)
{
	float f;
//	if (useGlobalShadowParams)  return globAtmosOpacity;
	pblock->GetValue( PB_ATM_OPAC(this), t, f, valid );
	return f;
}

void GeneralLight::SetAtmosColAmt(TimeValue t, float f)
{
	atmosColAmt = f;
//	if (useGlobalShadowParams)  globAtmosColamt = f;
//	else 
		pblock->SetValue( PB_ATM_COLAMT(this), t, f );
}

float GeneralLight::GetAtmosColAmt(TimeValue t, Interval& valid)
{
	float f;
//	if (useGlobalShadowParams)  return globAtmosColamt;
	pblock->GetValue( PB_ATM_COLAMT(this), t, f, valid );
	return f;
}


void GeneralLight::SetEmitterEnable(TimeValue t, BOOL f)
{
	emitter->SetValue( PB_EMITTER_ENABLE, t, f );
}

BOOL GeneralLight::GetEmitterEnable(TimeValue t, Interval& valid)
{
	BOOL f;
	emitter->GetValue( PB_EMITTER_ENABLE, t, f, valid );
	return f;
}

void GeneralLight::SetEmitterCausticPhotons(TimeValue t, int f)
{
	emitter->SetValue( PB_EMITTER_CA_PHOTONS, t, f );
}

int GeneralLight::GetEmitterCausticPhotons(TimeValue t, Interval& valid)
{
	int f;
	emitter->GetValue( PB_EMITTER_CA_PHOTONS, t, f, valid );
	return f;
}

void GeneralLight::SetEmitterGlobalIllumPhotons(TimeValue t, int f)
{
	emitter->SetValue( PB_EMITTER_GI_PHOTONS, t, f );
}

int GeneralLight::GetEmitterGlobalIllumPhotons(TimeValue t, Interval& valid)
{
	int f;
	emitter->GetValue( PB_EMITTER_GI_PHOTONS, t, f, valid );
	return f;
}

void GeneralLight::SetEmitterEnergy(TimeValue t, float f)
{
	emitter->SetValue( PB_EMITTER_ENERGY, t, f );
}

float GeneralLight::GetEmitterEnergy(TimeValue t, Interval& valid)
{
	float f;
	emitter->GetValue( PB_EMITTER_ENERGY, t, f, valid );
	return f;
}

void GeneralLight::SetEmitterDecayType(TimeValue t, int f)
{
	emitter->SetValue( PB_EMITTER_DECAY_TYPE, t, f );
}

int GeneralLight::GetEmitterDecayType(TimeValue t, Interval& valid)
{
	int f;
	emitter->GetValue( PB_EMITTER_DECAY_TYPE, t, f, valid );
	return f;
}


// aspect <= 0   ==>  circular cone	(NUM_CIRC_PTS returned)
// aspect  > 0	 ==>  rectangular cone (4+2 points returned)
void GeneralLight::GetConePoints(TimeValue t, float aspect, float angle, float dist, Point3 *q) 
	{
	float ta = (float)tan(0.5*DegToRad(angle));   
	if(aspect <= 0.0f) { 
		// CIRCULAR
		float rad = dist * ta;
		double a;
		if(IsDir())
			rad = angle;
		for(int i = 0; i < NUM_CIRC_PTS; i++) {
			a = (double)i * 2.0 * 3.1415926 / (double)NUM_CIRC_PTS;
			q[i] = Point3(rad*(float)sin(a), rad*(float)cos(a), -dist);
			}
		q[i] = q[0] + Point3(0.0f, 15.0f, 0.0f);
		}
	else {		 
		// RECTANGULAR
		float w = IsDir()? angle : dist * ta * (float)sqrt((double)aspect);
		float h = w / aspect;
		q[0] = Point3( w, h,-dist);				
		q[1] = Point3(-w, h,-dist);				
		q[2] = Point3(-w,-h,-dist);				
		q[3] = Point3( w,-h,-dist);
		q[4] = Point3( 0.0f, h+15.0f, -dist);
		q[5] = Point3( 0.0f, h, -dist);
		}
	}

#define HOTCONE		0
#define FALLCONE	1

void GeneralLight::DrawCone(TimeValue t, GraphicsWindow *gw, float dist) 
	{
	Point3 q[NUM_CIRC_PTS+1], u[3];
	int dirLight = IsDir();
	int i;
	BOOL dispAtten = (useAtten && (extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:attenDisplay;
	BOOL dispAttenNear = (useAttenNear && (extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:attenNearDisplay;
	BOOL dispDecay = (GetDecayType()&&(extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:decayDisplay;

	GetConePoints(t, GetSpotShape() ? -1.0f : GetAspect(t), GetHotspot(t), dist, q);
	gw->setColor( LINE_COLOR, GetUIColor(COLOR_HOTSPOT));
	if(GetSpotShape()) {  
		// CIRCULAR
		if(GetHotspot(t) >= GetFallsize(t)) {
			// draw (far) hotspot circle
			u[0] = q[0];
			u[1] = q[NUM_CIRC_PTS];
			gw->polyline( 2, u, NULL, NULL, FALSE, NULL);
			}
		gw->polyline(NUM_CIRC_PTS, q, NULL, NULL, TRUE, NULL);
		if (dirLight) {
			// draw 4 axial hotspot lines
			for (i = 0; i < NUM_CIRC_PTS; i += SEG_INDEX) {
				u[0] =  q[i]; 	u[1] =  q[i]; u[1].z += dist;
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			GetConePoints(t, -1.0f, GetHotspot(t), 0.0f, q);
			// draw (near) hotspot circle
			gw->polyline(NUM_CIRC_PTS, q, NULL, NULL, TRUE, NULL);
			}
		else  {
			// draw 4 axial lines
			u[0] = Point3(0,0,0);
			for (i = 0; i < NUM_CIRC_PTS; i += SEG_INDEX) {
				u[1] =  q[i];
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			}
	
		GetConePoints(t, -1.0f, GetFallsize(t), dist, q);
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_FALLOFF));
		if(GetHotspot(t) < GetFallsize(t)) {
			// draw (far) fallsize circle
			u[0] = q[0];	u[1] = q[NUM_CIRC_PTS];
			gw->polyline( 2, u, NULL, NULL, FALSE, NULL);
			u[0] = Point3(0,0,0);
			}
		gw->polyline(NUM_CIRC_PTS, q, NULL, NULL, TRUE, NULL);
		if (dirLight) {
			float dfar = q[0].z;
			float dnear = 0.0f;
			if (dispAtten) {
				dfar  = MinF(-GetAtten(t,ATTEN_END),dfar);
				dnear = MaxF(-GetAtten(t,ATTEN_START),dnear);
				}
			if (dispAttenNear) {
				dfar  = MinF(-GetAtten(t,ATTEN1_END),dfar);
				dnear = MaxF(-GetAtten(t,ATTEN1_START),dnear);
				}
			if (dispDecay) {
				dfar  = MinF(-GetDecayRadius(t),dfar);
				}
			// draw axial fallsize lines
			for (i = 0; i < NUM_CIRC_PTS; i += SEG_INDEX) {
				u[0] =  q[i];  u[0].z = dfar;	u[1] =  q[i]; u[1].z = dnear;
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			GetConePoints(t, -1.0f, GetFallsize(t), 0.0f, q);
			// draw (near) fallsize circle
			gw->polyline(NUM_CIRC_PTS, q, NULL, NULL, TRUE, NULL);
			}
		else {
			float cs = (float)cos(DegToRad(GetFallsize(t)*0.5f));
			float dfar = q[0].z;
			if (dispAtten) 
				dfar  = MinF(-cs*GetAtten(t,ATTEN_END),dfar);
			if (dispAttenNear) 
				dfar  = MinF(-cs*GetAtten(t,ATTEN1_END),dfar);
			if (dispDecay) 
				dfar  = MinF(-cs*GetDecayRadius(t),dfar);
			for (i = 0; i < NUM_CIRC_PTS; i += SEG_INDEX) {
				u[1] =  -q[i]*dfar/dist;	
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			}
		}
	else { 
		// RECTANGULAR
		if(GetHotspot(t) >= GetFallsize(t))
			gw->polyline( 2, q+4, NULL, NULL, FALSE, NULL);
		gw->polyline(4, q, NULL, NULL, TRUE, NULL);
		if (dirLight) { //DIRLIGHT
			// draw axial hotspot lines
			for (i = 0; i < 4; i += 1) {
				u[0] =  q[i]; 	u[1] =  q[i]; u[1].z += dist;
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			GetConePoints(t, GetAspect(t), GetHotspot(t), 0.0f, q);
			// draw (near) hotspot circle
			gw->polyline(4, q, NULL, NULL, TRUE, NULL);
			}
		else {
			u[0] = Point3(0,0,0);
			for (i = 0; i < 4; i++) {
				u[1] =  q[i];
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			}
		GetConePoints(t, GetAspect(t), GetFallsize(t), dist, q);
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_FALLOFF));
		if(GetHotspot(t) < GetFallsize(t))
			gw->polyline( 2, q+4, NULL, NULL, FALSE, NULL);
		gw->polyline(4, q, NULL, NULL, TRUE, NULL);
		if (dirLight) {
			// draw axial fallsize lines
			for (i = 0; i < 4; i += 1) {
				u[0] =  q[i]; 	u[1] =  q[i]; u[1].z += dist;
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			GetConePoints(t, GetAspect(t), GetFallsize(t), 0.0f, q);
			// draw (near) fallsize circle
			gw->polyline(4, q, NULL, NULL, TRUE, NULL);
			}
		else {
			for (i = 0; i < 4; i += 1) {
				u[1] =  q[i];
				gw->polyline( 2, u, NULL, NULL, FALSE, NULL );	
				}
			}
		}
	}

int GeneralLight::DrawConeAndLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing ) 
	{
	if(!IsSpot())
		return 0;
	Matrix3 tm = inode->GetObjectTM(t);
	gw->setTransform(tm);
	if (type == TSPOT_LIGHT) {
		Point3 pt,v[3];
		if (GetTargetPoint(t, inode, pt)) {
			float den = FLength(tm.GetRow(2));
			float dist = (den!=0) ? FLength(tm.GetTrans()-pt) / den : 0.0f;
			targDist = dist;
			if (hSpotLight) {
				TCHAR buf[40];
				_stprintf(buf,_T("%0.3f"),targDist);
				SetWindowText(GetDlgItem(hSpotLight,IDC_TARG_DISTANCE),buf);
				}
			if ((drawing != -1) && (coneDisplay || (extDispFlags & EXT_DISP_ONLY_SELECTED))) 
				DrawCone(t, gw, dist);
			if(!inode->IsFrozen())
				gw->setColor( LINE_COLOR, GetUIColor(COLOR_TARGET_LINE));
			v[0] = Point3(0,0,0);
			v[1] = Point3(0.0f, 0.0f, (drawing == -1)? (-0.9f * dist): -dist);
			gw->polyline( 2, v, NULL, NULL, FALSE, NULL );	
			}
		}
	else if (type == FSPOT_LIGHT) {
		if ((drawing != -1) && (coneDisplay || (extDispFlags & EXT_DISP_ONLY_SELECTED)))
			DrawCone(t, gw, GetTDist(t));
		}
	else if (type == DIR_LIGHT) {
		if ((drawing != -1) && (coneDisplay || (extDispFlags & EXT_DISP_ONLY_SELECTED)))
			DrawCone(t, gw, GetTDist(t));
		}
	else if (type == TDIR_LIGHT) {
		Point3 pt,v[3];
		if (GetTargetPoint(t, inode, pt)) {
			float den = FLength(tm.GetRow(2));
			float dist = (den!=0) ? FLength(tm.GetTrans()-pt) / den : 0.0f;
			targDist = dist;
			if (hSpotLight) {
				TCHAR buf[40];
				_stprintf(buf,_T("%0.3f"),targDist);
				SetWindowText(GetDlgItem(hSpotLight,IDC_TARG_DISTANCE),buf);
				}
			if ((drawing != -1) && (coneDisplay || (extDispFlags & EXT_DISP_ONLY_SELECTED)))
				DrawCone(t, gw, dist);
			v[0] = Point3(0,0,0);
			v[1] = Point3(0.0f, 0.0f, (drawing == -1)? (-0.9f * dist): -dist);
			gw->polyline( 2, v, NULL, NULL, FALSE, NULL );	
			}
		}
	return gw->checkHitCode();
	}

void GeneralLight::SetUseAtten(int s) 
{
	useAtten = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

void GeneralLight::SetUseAttenNear(int s) 
	{
	useAttenNear = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GeneralLight::SetAttenDisplay(int s) 
	{
	attenDisplay = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GeneralLight::SetAttenNearDisplay(int s) 
	{
	attenNearDisplay = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GeneralLight::SetDecayDisplay(int s) 
	{
	decayDisplay = s;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GeneralLight::GetAttenPoints(TimeValue t, float rad, Point3 *q)
	{
	double a;
	float sn, cs;
	for(int i = 0; i < NUM_CIRC_PTS; i++) {
		a = (double)i * 2.0 * 3.1415926 / (double)NUM_CIRC_PTS;
		sn = rad * (float)sin(a);
		cs = rad * (float)cos(a);
		q[i+0*NUM_CIRC_PTS] = Point3(sn, cs, 0.0f);
		q[i+1*NUM_CIRC_PTS] = Point3(sn, 0.0f, cs);
		q[i+2*NUM_CIRC_PTS] = Point3(0.0f, sn, cs);
		}
	}

void GeneralLight::DrawX(TimeValue t, float asp, int npts, float dist, GraphicsWindow *gw, int indx) {
	Point3 q[3*NUM_CIRC_PTS+1];
	Point3 u[2];
	GetConePoints(t, asp, GetFallsize(t), dist, q);
	gw->polyline(npts, q,NULL, NULL, TRUE, NULL);
	u[0] = q[0]; u[1] = q[2*indx];
	gw->polyline(2, u,NULL, NULL, FALSE, NULL);
	u[0] = q[indx]; u[1] = q[3*indx];
	gw->polyline(2, u,NULL, NULL, FALSE, NULL);
	}

int GeneralLight::GetCirXPoints(TimeValue t, float angle, float dist, Point3 *q) {
	int i;
	float ang = DegToRad(angle)/2.0f;
	float da = ang/float(NUM_HALF_ARC);
	// first draw circle:
	float d = dist*(float)cos(ang);
	GetConePoints(t, -1.0f, angle, d, q);
	int j=NUM_CIRC_PTS;
	// then draw Arc X
	float a = -ang;
	for(i = -NUM_HALF_ARC; i<= NUM_HALF_ARC; i++, a+=da) 
		q[j++] = Point3(0.0f, dist*(float)sin(a), -dist*(float)cos(a));
	a = -ang;	
	for(i = -NUM_HALF_ARC; i<= NUM_HALF_ARC; i++, a+=da) 
		q[j++] = Point3(dist*(float)sin(a), 0.0f, -dist*(float)cos(a));
	return NUM_CIRC_PTS + 2*NUM_ARC_PTS;
	}

void GeneralLight::DrawSphereArcs(TimeValue t, GraphicsWindow *gw, float r, Point3 *q) {
	GetAttenPoints(t, r, q);
	gw->polyline(NUM_CIRC_PTS, q,				NULL, NULL, TRUE, NULL);
	gw->polyline(NUM_CIRC_PTS, q+NUM_CIRC_PTS,	NULL, NULL, TRUE, NULL);
	gw->polyline(NUM_CIRC_PTS, q+2*NUM_CIRC_PTS,NULL, NULL, TRUE, NULL);
	}

// Draw the the arcs cut out of the sphere by the viewing cone.
int GeneralLight::GetRectXPoints(TimeValue t, float angle, float dist, Point3 *q) {
	int i;
	if(dist==0.0f) dist = .00001f;
	float ang = DegToRad(angle)/2.0f;
	float da,sn,cs,x,y,z,a;
	float aspect = GetAspect(t);
	float w = dist * (float)tan(ang) * (float)sqrt((double)aspect);
	float h = w/aspect;
	float wang = (float)atan(w/dist);
	float hang = (float)atan(h/dist);
	float aw = float(atan(w/dist)*cos(hang));  // half-angle of top and bottom arcs
	float ah = float(atan(h/dist)*cos(wang));  // half-angle of left and right arcs
	int j = 0;

	// draw horizontal and vertical center lines
	da = wang/float(NUM_HALF_ARC);
	for(i = -NUM_HALF_ARC, a = -wang; i<= NUM_HALF_ARC; i++, a+=da) 
		q[j++] = Point3(dist*(float)sin(a), 0.0f, -dist*(float)cos(a));
	da = hang/float(NUM_HALF_ARC);
	for(i = -NUM_HALF_ARC, a = -hang; i<= NUM_HALF_ARC; i++, a+=da) 
		q[j++] = Point3(0.0f, dist*(float)sin(a), -dist*(float)cos(a));


	// draw top and bottom arcs
	da = aw/float(NUM_HALF_ARC);
	sn = (float)sin(hang);
	cs = (float)cos(hang);
	for (i = -NUM_HALF_ARC, a = -aw; i<= NUM_HALF_ARC; i++, a+=da) {
		x =  dist*(float)sin(a); 
		z = -dist*(float)cos(a);
		q[j]             = Point3(x, z*sn, z*cs);  				
		q[j+NUM_ARC_PTS] = Point3(x,-z*sn, z*cs);  				
		j++;
		}
	
	j+= NUM_ARC_PTS;

	// draw left and right arcs
	da = ah/float(NUM_HALF_ARC);
	sn = (float)sin(wang);
	cs = (float)cos(wang);
	for (i = -NUM_HALF_ARC, a = -ah; i<= NUM_HALF_ARC; i++, a+=da) {
		y =  dist*(float)sin(a); 
		z = -dist*(float)cos(a);
		q[j]             = Point3( z*sn, y, z*cs);  				
		q[j+NUM_ARC_PTS] = Point3(-z*sn, y, z*cs);  				
		j++;
		}

	return 6*NUM_ARC_PTS;
	}

// Draw warped rectangle
void GeneralLight::DrawWarpRect(TimeValue t, GraphicsWindow *gw, float angle, float dist, Point3 *q) {
 	GetRectXPoints(t, angle,dist,q);
	for (int i=0; i<6; i++)
		gw->polyline(NUM_ARC_PTS, q+i*NUM_ARC_PTS,NULL, NULL, FALSE, NULL);  
	}

void GeneralLight::DrawCircleX(TimeValue t, GraphicsWindow *gw, float angle, float dist, Point3 *q) {
 	GetCirXPoints(t, angle,dist,q);
	gw->polyline(NUM_CIRC_PTS, q,NULL, NULL, TRUE, NULL);  // circle 
	gw->polyline(NUM_ARC_PTS, q+NUM_CIRC_PTS,NULL, NULL, FALSE, NULL); // vert arc
	gw->polyline(NUM_ARC_PTS, q+NUM_CIRC_PTS+NUM_ARC_PTS,NULL, NULL, FALSE, NULL);  // horiz arc
	}

void GeneralLight::DrawAttenCirOrRect(TimeValue t, GraphicsWindow *gw, float dist, BOOL froze, int uicol) {
	if (!froze) gw->setColor( LINE_COLOR, GetUIColor(uicol));
	if (IsDir()) {
		int npts,indx;
		float asp;
		if (GetSpotShape()) { npts = NUM_CIRC_PTS; 	asp  = -1.0f; 	indx = SEG_INDEX; 	}
		else { 	npts = 4;  	asp  = GetAspect(t); 	indx = 1; 	} 
		DrawX(t, asp, npts, dist, gw, indx);
		}
	else {
		Point3 q[3*NUM_CIRC_PTS+1];
		if (type==OMNI_LIGHT||(IsSpot()&&overshoot)) 
			DrawSphereArcs(t, gw, dist, q);
		else {
			if (GetSpotShape())  
				DrawCircleX(t, gw, GetFallsize(t),dist,q);
			else 
				DrawWarpRect(t, gw, GetFallsize(t),dist,q);
			}
		}
	}


int GeneralLight::DrawAtten(TimeValue t, INode *inode, GraphicsWindow *gw)
	{
	BOOL dispAtten = (useAtten && (extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:attenDisplay;
	BOOL dispAttenNear = (useAttenNear && (extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:attenNearDisplay;
	BOOL dispDecay = (GetDecayType()&&(extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:decayDisplay;

	if (dispAtten||dispAttenNear||dispDecay) {
		Matrix3 tm = inode->GetObjectTM(t);
		gw->setTransform(tm);
		BOOL froze = inode->IsFrozen();
	 	if (dispAtten) {
	 		DrawAttenCirOrRect(t, gw, GetAtten(t,ATTEN_START), froze, COLOR_START_RANGE);
	 		DrawAttenCirOrRect(t, gw, GetAtten(t,ATTEN_END), froze, COLOR_END_RANGE);
	 		}
	 	if (dispAttenNear) {
	 		DrawAttenCirOrRect(t, gw, GetAtten(t,ATTEN1_START), froze, COLOR_START_RANGE1);
	 		DrawAttenCirOrRect(t, gw, GetAtten(t,ATTEN1_END), froze, COLOR_END_RANGE1);
	 		}
	 	if (dispDecay) {
	 		DrawAttenCirOrRect(t, gw, GetDecayRadius(t), froze, COLOR_DECAY_RADIUS);
	 		}
		}
	return 0;
	}

GeneralLight::~GeneralLight() 
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
//	UnRegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
//	UnRegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);
	UnRegisterNotification(NameChangeNotify, (void *)this, NOTIFY_NODE_RENAMED);
	}

class GeneralLightCreateCallBack: public CreateMouseCallBack 
{
	GeneralLight *ob;
public:
	int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(GeneralLight *obj) { ob = obj; }
};

int GeneralLightCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) 
{
	Point3 p0;
	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT || msg==MOUSE_MOVE) {		
		//mat.SetTrans(vpt->GetPointOnCP(m));
		#ifdef _3D_CREATE
			mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_3D) );
		#else
			mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE) );
		#endif

		ob->enable = TRUE;
		if (point==1) {
			if (msg==MOUSE_POINT) 
					return 0;
		}
	}
	else if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
}

static GeneralLightCreateCallBack sGeneralLgtCreateCB;

CreateMouseCallBack* GeneralLight::GetCreateMouseCallBack() 
{
	sGeneralLgtCreateCB.SetObj(this);

	return &sGeneralLgtCreateCB;
}


void GeneralLight::GetMat(TimeValue t, INode* inode, ViewExp *vpt, Matrix3& tm) 
{
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
}

void GeneralLight::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
{
	box = mesh->getBoundingBox(tm);
}


void GeneralLight::BoxCircle(TimeValue t, float r, float d, Box3& box, int extraPt, Matrix3 *tm) {
	Point3 q[3*NUM_CIRC_PTS];
	int npts;
	float asp;
	if ( GetSpotShape()) { 	npts =  NUM_CIRC_PTS+extraPt; 	asp = -1.0f; }
	else { npts = 4+extraPt;  asp = GetAspect(t); } 
 	GetConePoints(t, asp , r, d, q);
 	box.IncludePoints(q,npts,tm);
	}

void GeneralLight::BoxDirPoints(TimeValue t, float angle, float dist, Box3 &box, Matrix3 *tm) {
	int npts;
	Point3 q[3*NUM_CIRC_PTS];
	npts = GetSpotShape()? GetCirXPoints(t,angle,dist,q): GetRectXPoints(t,angle,dist,q);
	box.IncludePoints(q,npts,tm);
	}


void GeneralLight::BoxPoints(TimeValue t, float angle, float dist, Box3 &box, Matrix3 *tm) {
	if (IsDir())
		BoxCircle(t, angle, dist, box, 0,tm);
	else 
		BoxDirPoints(t, angle, dist, box, tm);
	}

void GeneralLight::BoxLight(TimeValue t, INode *inode, Box3& box, Matrix3 *tm) {
	Point3 pt;
	float d;
	if (GetTargetPoint(t, inode, pt)) {
		Point3 loc = inode->GetObjectTM(t).GetTrans();
		d = FLength(loc - pt) / FLength(inode->GetObjectTM(t).GetRow(2));
		box += tm? (*tm)*Point3(0.0f, 0.0f, -d): Point3(0.0f, 0.0f, -d);
		}
	else {
		d = GetTDist(t);
		if (coneDisplay) 
			box += tm? (*tm)*Point3(0.0f, 0.0f, -d): Point3(0.0f, 0.0f, -d);
		}
	if( coneDisplay || (extDispFlags & EXT_DISP_ONLY_SELECTED)) {
		float rad = MaxF(GetHotspot(t), GetFallsize(t));
		if (IsDir()) 
			BoxCircle(t,rad,0.0f,box,1,tm);
		BoxCircle(t,rad,d,box,1,tm);
		}
	BOOL dispAtten, dispAttenNear, dispDecay;
	if (useAtten && (extDispFlags & EXT_DISP_ONLY_SELECTED))  
		dispAtten = dispAttenNear = TRUE;
	else {
		dispAtten = attenDisplay;
		dispAttenNear = attenNearDisplay;
		}
	dispDecay = (GetDecayType()&&(extDispFlags & EXT_DISP_ONLY_SELECTED))?TRUE:decayDisplay;
	if( dispAtten||dispAttenNear||dispDecay) {
		if (type==OMNI_LIGHT||(IsSpot()&&overshoot)) { 
			Point3 q[3*NUM_CIRC_PTS];
			float rad = 0;
			if (dispAtten) rad = MaxF(GetAtten(t, ATTEN_START), GetAtten(t, ATTEN_END));
			if (dispAttenNear) { 
				rad = MaxF(GetAtten(t, ATTEN1_START), rad);
				rad = MaxF(GetAtten(t, ATTEN1_END), rad);
				}
			if (dispDecay) rad = MaxF(rad,GetDecayRadius(t));
			GetAttenPoints(t, rad, q);
			box.IncludePoints(q,3*NUM_CIRC_PTS,tm);
			}
		else  {
			if (dispAtten) {
				BoxPoints(t, GetFallsize(t), GetAtten(t,ATTEN_END), box, tm);
				BoxPoints(t, GetFallsize(t), GetAtten(t,ATTEN_START), box, tm);
				}
			if (dispAttenNear) {
				BoxPoints(t, GetFallsize(t), GetAtten(t,ATTEN1_END), box, tm);
				BoxPoints(t, GetFallsize(t), GetAtten(t,ATTEN1_START), box, tm);
				}
			if (dispDecay) {
				BoxPoints(t, GetFallsize(t), GetDecayRadius(t), box, tm);
				}
			}
		}
	}

void GeneralLight::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
	Point3 loc = inode->GetObjectTM(t).GetTrans();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(loc) / 360.0f;
	box = mesh->getBoundingBox();
	box.Scale(scaleFactor);
	BoxLight(t, inode, box, NULL);
	}

void GeneralLight::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	int nv;
	Matrix3 tm;
	GetMat(t, inode,vpt,tm);
	Point3 loc = tm.GetTrans();
	nv = mesh->getNumVerts();
	box.Init();
	if(!(extDispFlags & EXT_DISP_ZOOM_EXT)) 
		box.IncludePoints(mesh->verts,nv,&tm);
	else
		box += loc;
	tm = inode->GetObjectTM(t);
	BoxLight(t, inode, box, &tm);
	}


// From BaseObject
int GeneralLight::HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) 
{
	HitRegion hitRegion;
	DWORD savedLimits;
	int res;
	Matrix3 m;
	if (!enable) 
		return 0;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits( ((savedLimits = gw->getRndLimits()) | GW_PICK) & ~(GW_ILLUM|GW_BACKCULL));
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	// if we get a hit on the mesh, we're done
	res = mesh->select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
	// if not, check the target line, and set the pair flag if it's hit
	if( !res )	{
		// this special case only works with point selection of targeted lights
		if((type != HITTYPE_POINT) || !inode->GetTarget())
			return 0;
		// don't let line be active if only looking at selected stuff and target isn't selected
		if((flags & HIT_SELONLY) && !inode->GetTarget()->Selected() )
			return 0;
		gw->clearHitCode();
		if(res = DrawConeAndLine(t, inode, gw, -1))
			inode->SetTargetNodePair(1);
	}
	gw->setRndLimits(savedLimits);
	return res;
}

void GeneralLight::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
{
	GenericSnap(t,inode,snap,p,vpt);
}

void GeneralLight::SetExtendedDisplay(int flags)
{
	extDispFlags = flags;
}

int GeneralLight::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{
	Matrix3 m;
	if (!enable) 
		return 0;
	GraphicsWindow *gw = vpt->getGW();
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL|(gw->getRndMode() & GW_Z_BUFFER));
	if (inode->Selected())
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())	{
		if(useLight)
			gw->setColor( LINE_COLOR, GetUIColor(COLOR_LIGHT_OBJ));
		// I un-commented this line DS 6/11/99
		else
			gw->setColor( LINE_COLOR, 0.0f, 0.0f, 0.0f);
	}
	mesh->render( gw, gw->getMaterial(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL);	
	DrawConeAndLine(t, inode, gw, 1);
	DrawAtten(t, inode, gw);
	gw->setRndLimits(rlim);
	return 0 ;
}


RefResult GeneralLight::EvalLightState(TimeValue t, Interval& valid, LightState* ls) 
{
	if(useLight)
		ls->color = GetRGBColor(t,valid);
	else
		ls->color = Point3(0,0,0);
	ls->on = useLight;
	ls->intens = GetIntensity(t, valid);
	ls->hotsize = GetHotspot(t, valid);
	ls->fallsize = GetFallsize(t, valid);
#if 0
	if(ls->useAtten = GetUseAtten()) {
		ls->attenStart = GetAtten(t, ATTEN_START, valid);
		ls->attenEnd = GetAtten(t, ATTEN_END, valid);
	}
	else
		ls->attenStart = ls->attenEnd = 0.0f;
#endif
	
	ls->useNearAtten = GetUseAttenNear();
	ls->nearAttenStart = GetAtten(t, ATTEN1_START, valid);
	ls->nearAttenEnd = GetAtten(t, ATTEN1_END, valid);
	ls->useAtten = GetUseAtten();
	ls->attenStart = GetAtten(t, ATTEN_START, valid);
	ls->attenEnd = GetAtten(t, ATTEN_END, valid);
	ls->shape = GetSpotShape();
	ls->aspect = GetAspect(t, valid);
	ls->overshoot = GetOvershoot();
	ls->shadow = GetShadow();
	ls->ambientOnly = ambientOnly;
	ls->affectDiffuse = affectDiffuse;
	ls->affectSpecular = affectSpecular;

	if(type == OMNI_LIGHT)
		ls->type = OMNI_LGT;
	else if(type == DIR_LIGHT||type==TDIR_LIGHT)
		ls->type = DIRECT_LGT;
	else
		ls->type = SPOT_LGT;

	return REF_SUCCEED;
}

//
// Reference Managment:
//
					
RefResult GeneralLight::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message ) 
{
	switch (message) {
	case REFMSG_NODE_NAMECHANGE:
	case REFMSG_CHANGE:
		if(iObjParams)
			UpdateUI(iObjParams->GetTime());
		break;

	case REFMSG_WANT_SHOWPARAMLEVEL: {
		BOOL	*pb = ( BOOL * )partID;
		if ( hTarget == ( RefTargetHandle )emitter )
			*pb = TRUE;
		else
			*pb = FALSE;

		return REF_STOP;
		}

	case REFMSG_GET_PARAM_DIM: {
		GetParamDim *gpd = (GetParamDim*)partID;
		if ( hTarget == ( RefTargetHandle )pblock )
		{
			if (type == OMNI_LIGHT) {
				switch (gpd->index) {
					case PB_OMNISHADCOLOR:
					case PB_COLOR:
						gpd->dim = stdColor255Dim;
						break;
					case PB_INTENSITY:
					case PB_CONTRAST:
					case PB_DIFFSOFT:
	//				case PB_OMNIMAP_SIZE:
	//				case PB_OMNIMAP_RANGE:
						gpd->dim = defaultDim;
						break;					
					case PB_OMNIATSTART1:
					case PB_OMNIATEND1:
					case PB_OMNIATSTART:
					case PB_OMNIATEND:
					case PB_OMNIDECAY:
						gpd->dim = stdWorldDim;
						gpd->dim = GetAbsMapBias()? stdWorldDim: defaultDim;
						break;					
					case PB_OMNIATMOS_COLAMT:
					case PB_OMNIATMOS_OPACITY:
						gpd->dim = stdPercentDim;
						break;
					}
				}
			else {
				switch (gpd->index) {
					case PB_SHADCOLOR:
					case PB_COLOR:
						gpd->dim = stdColor255Dim;
						break;
					case PB_INTENSITY:
					case PB_CONTRAST:
					case PB_DIFFSOFT:
					case PB_ASPECT:
						gpd->dim = defaultDim;
						break;					
					case PB_HOTSIZE:
					case PB_FALLSIZE:
						gpd->dim = IsDir()?stdWorldDim:defaultDim;
						break;					
					case PB_TDIST:
					case PB_ATTENSTART1:
					case PB_ATTENEND1:
					case PB_ATTENSTART:
					case PB_ATTENEND:
					case PB_DECAY:
						gpd->dim = stdWorldDim;
						break;					
					case PB_ATMOS_COLAMT:
					case PB_ATMOS_OPACITY:
						gpd->dim = stdPercentDim;
						break;
					}
				}
			return REF_STOP; 
		}
		else
		if ( hTarget == ( RefTargetHandle )emitter )
		{
			switch (gpd->index) {
				case PB_EMITTER_ENABLE:
				case PB_EMITTER_ENERGY:
//				case PB_EMITTER_DECAY_TYPE:
				case PB_EMITTER_CA_PHOTONS:
				case PB_EMITTER_GI_PHOTONS:
					gpd->dim = defaultDim;
					break;		
			}
		}
		return REF_STOP;
	}

	case REFMSG_GET_PARAM_NAME: {
		GetParamName *gpn = (GetParamName*)partID;
		if ( hTarget == ( RefTargetHandle )pblock )
		{
			if (type == OMNI_LIGHT) {
				switch (gpn->index) {
					case PB_COLOR: gpn->name = TSTR(GetString(IDS_DB_COLOR)); break;
					case PB_INTENSITY:  gpn->name = TSTR(GetString(IDS_DB_MULTIPLIER)); break;
					case PB_CONTRAST:  gpn->name = TSTR(GetString(IDS_DS_CONTRAST)); break;
					case PB_DIFFSOFT:  gpn->name = TSTR(GetString(IDS_DS_DIFFSOFT)); break;
					case PB_OMNIATSTART1: gpn->name = TSTR(GetString(IDS_DS_ATTENSTARTNEAR)); break;
					case PB_OMNIATEND1: gpn->name = TSTR(GetString(IDS_DS_ATTENENDNEAR)); break;
					case PB_OMNIATSTART: gpn->name = TSTR(GetString(IDS_DB_ATTENSTART)); break;
					case PB_OMNIATEND: gpn->name = TSTR(GetString(IDS_DB_ATTENEND)); break;
					case PB_OMNIDECAY: gpn->name = TSTR(GetString(IDS_DECAY_RADIUS)); break;
					case PB_OMNISHADCOLOR: gpn->name = TSTR(GetString(IDS_DS_SHADCOL)); break;
					case PB_OMNIATMOS_OPACITY: gpn->name = TSTR(GetString(IDS_ATMOS_OPACITY)); break;
					case PB_OMNIATMOS_COLAMT: gpn->name = TSTR(GetString(IDS_ATMOS_COLAMT)); break;
					case PB_OMNISHADMULT: gpn->name = TSTR(GetString(IDS_SHAD_DENSITY)); break;  
					}
				}
			else {			
				switch (gpn->index) {
					case PB_COLOR: gpn->name =  TSTR(GetString(IDS_DB_COLOR)); break;
					case PB_INTENSITY: gpn->name = TSTR(GetString(IDS_DB_MULTIPLIER)); break;
					case PB_CONTRAST:  gpn->name = TSTR(GetString(IDS_DS_CONTRAST)); break;
					case PB_DIFFSOFT:  gpn->name = TSTR(GetString(IDS_DS_DIFFSOFT)); break;
					case PB_HOTSIZE:  gpn->name = TSTR(GetString(IDS_DB_HOTSIZE));	break;
					case PB_FALLSIZE: gpn->name = TSTR(GetString(IDS_DB_FALLSIZE));	break;
					case PB_ASPECT:	gpn->name = TSTR(GetString(IDS_DB_ASPECT_RATIO));	break;
					case PB_ATTENSTART1: gpn->name = TSTR(GetString(IDS_DS_ATTENSTARTNEAR)); break;
					case PB_ATTENEND1:	gpn->name = TSTR(GetString(IDS_DS_ATTENENDNEAR));	break;
					case PB_ATTENSTART:	gpn->name = TSTR(GetString(IDS_DB_ATTENSTART));	break;
					case PB_ATTENEND: gpn->name = TSTR(GetString(IDS_DB_ATTENEND));	break;
					case PB_DECAY: gpn->name = TSTR(GetString(IDS_DECAY_RADIUS)); break;
					case PB_TDIST:	gpn->name = TSTR(GetString(IDS_DB_TDIST));		break;
					case PB_SHADCOLOR: gpn->name = TSTR(GetString(IDS_DS_SHADCOL)); break;
					case PB_ATMOS_OPACITY: gpn->name = TSTR(GetString(IDS_ATMOS_OPACITY)); break;
					case PB_ATMOS_COLAMT: gpn->name = TSTR(GetString(IDS_ATMOS_COLAMT)); break;
					case PB_SHADMULT: gpn->name = TSTR(GetString(IDS_SHAD_DENSITY)); break;  
					}
				}
		}
		else
		if ( hTarget == ( RefTargetHandle )emitter )
		{
			switch (gpn->index) {
				case PB_EMITTER_ENABLE: gpn->name =  TSTR(GetString(IDS_EMITTER_ENABLE)); break;
				case PB_EMITTER_ENERGY: gpn->name =  TSTR(GetString(IDS_EMITTER_ENERGY)); break;
		//		case PB_EMITTER_DECAY_TYPE: gpn->name =  TSTR(GetString(IDS_EMITTER_DECAY_TYPE)); break;
				case PB_EMITTER_CA_PHOTONS: gpn->name =  TSTR(GetString(IDS_EMITTER_CA_PHOTONS)); break;
				case PB_EMITTER_GI_PHOTONS: gpn->name =  TSTR(GetString(IDS_EMITTER_GI_PHOTONS)); break;
			}
		}
		return REF_STOP; 
		}
	}
	return(REF_SUCCEED);
}

ObjectState GeneralLight::Eval(TimeValue time)
{
	UpdateUI(time);
	return ObjectState(this);
}

Interval GeneralLight::ObjectValidity(TimeValue time) 
	{
	Interval valid;
	valid.SetInfinite();
	if (!waitPostLoad) {
		GetRGBColor(time, valid);
		GetIntensity(time, valid);
		GetContrast(time, valid);
		GetDiffuseSoft(time, valid);
		if(IsSpot()) {
			GetHotspot(time, valid);
			GetFallsize(time, valid);
			GetTDist(time, valid);
			GetAspect(time, valid);
			}
		GetAtten(time, ATTEN_START, valid);
		GetAtten(time, ATTEN_END, valid);
		GetAtten(time, ATTEN1_START, valid);
		GetAtten(time, ATTEN1_END, valid);
		GetDecayRadius(time, valid);
		GetMapSize(time,valid);
		GetMapRange(time,valid);
		GetRayBias(time,valid);
		GetAtmosOpacity(time,valid);
		GetAtmosColAmt(time,valid);
		GetShadColor(time,valid);
		GetShadMult(time,valid);
		GetEmitterEnable	( time, valid );
		GetEmitterEnergy	( time, valid );
		GetEmitterDecayType ( time, valid );
		GetEmitterCausticPhotons	( time, valid );
		GetEmitterGlobalIllumPhotons	( time, valid );
		UpdateUI(time);
		}
	return valid;
	}

RefTargetHandle GeneralLight::Clone(RemapDir& remap) 
	{
	GeneralLight* newob = new GeneralLight(type);
	newob->enable = enable;
	newob->coneDisplay = coneDisplay;
	newob->useLight = useLight;
	newob->attenDisplay = attenDisplay;
	newob->useAtten = useAtten;
	newob->useAttenNear = useAttenNear;
	newob->attenNearDisplay = attenNearDisplay;
	newob->decayDisplay = decayDisplay;
	newob->shape = shape;
	newob->shadow = shadow;
	newob->shadowType = shadowType;
	newob->overshoot = overshoot;
	newob->projector = projector;
	newob->absMapBias = absMapBias;
	newob->exclList = exclList;
	newob->softenDiffuse = softenDiffuse;
	newob->affectDiffuse = affectDiffuse;
	newob->affectSpecular = affectSpecular;
	newob->ambientOnly = ambientOnly;
	newob->decayType = decayType;
	newob->atmosShadows = atmosShadows;
	newob->atmosOpacity = atmosOpacity;
	newob->atmosColAmt = atmosColAmt;
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (projMap) 
		newob->ReplaceReference(1,projMap->Clone(remap));
	newob->ReplaceReference(EMITTER_REF ,emitter->Clone(remap));
	return(newob);
	}


#define COLOR_CHUNK 0x2550		// obsolete
#define HOTSIZE_CHUNK 0x2552	// obsolete
#define CONE_DISPLAY_CHUNK	0x2560
#define RANGE_DISPLAY_CHUNK	0x2561
#define USE_ATTEN_CHUNK 0x2562
#define CROSSOVER_CHUNK 0x2563
#define SHADOW_CHUNK 0x2570
#define SHADOW_TYPE_CHUNK 0x2571
#define GLOBALSHADOW_CHUNK 0x2572
#define SPOTSHAPE_CHUNK 0x2573
#define ABS_MAP_BIAS_CHUNK 0x2574
#define OVERSHOOT_CHUNK 0x2575
#define EXCL_LIST_CHUNK 0x2576
#define PROJECTOR_CHUNK 0x2577
#define MAP_RANGE_CHUNK 0x2578
#define MAP_BIAS_CHUNK 0x2579
#define MAP_SIZE_CHUNK 0x257A
#define RAY_BIAS_CHUNK 0x257B
#define ON_OFF_CHUNK 0x2580
#define NEAR_RANGE_DISPLAY_CHUNK 0x2590
#define NEAR_USE_ATTEN_CHUNK     0x25A0
#define DONT_AFFECT_DIFF_CHUNK     0x25B0
#define DONT_AFFECT_SPEC_CHUNK     0x25B1
#define SOFTEN_DIFF_CHUNK     0x25C0
#define DECAY_TYPE_CHUNK     0x25D0
#define LT_EFFECT_SHAD_CHUNK 0x25E0
#define AMBIENT_ONLY_CHUNK 0x2600
#define DECAY_DISPLAY_CHUNK 0x2700

// IO
IOResult GeneralLight::Save(ISave *isave) 
{
	ULONG nb;
	
	isave->BeginChunk(ON_OFF_CHUNK);
	isave->Write(&useLight, sizeof(useLight), &nb);
	isave->EndChunk();
	isave->BeginChunk(CONE_DISPLAY_CHUNK);
	isave->Write(&coneDisplay, sizeof(coneDisplay), &nb);
	isave->EndChunk();
	isave->BeginChunk(RANGE_DISPLAY_CHUNK);
	isave->Write(&attenDisplay, sizeof(attenDisplay), &nb);
	isave->EndChunk();
	isave->BeginChunk(USE_ATTEN_CHUNK);
	isave->Write(&useAtten, sizeof(useAtten), &nb);
	isave->EndChunk();
	isave->BeginChunk(NEAR_RANGE_DISPLAY_CHUNK);
	isave->Write(&attenNearDisplay, sizeof(attenNearDisplay), &nb);
	isave->EndChunk();
	isave->BeginChunk(NEAR_USE_ATTEN_CHUNK);
	isave->Write(&useAttenNear, sizeof(useAttenNear), &nb);
	isave->EndChunk();
	isave->BeginChunk(DECAY_DISPLAY_CHUNK);
	isave->Write(&decayDisplay, sizeof(decayDisplay), &nb);
	isave->EndChunk();

	isave->BeginChunk(SHADOW_CHUNK);
	isave->Write(&shadow, sizeof(shadow), &nb);
	isave->EndChunk();
	isave->BeginChunk(SHADOW_TYPE_CHUNK);
	isave->Write(&shadowType, sizeof(shadowType), &nb);
	isave->EndChunk();
	isave->BeginChunk(GLOBALSHADOW_CHUNK);
	isave->Write(&useGlobalShadowParams, sizeof(useGlobalShadowParams), &nb);
	isave->EndChunk();

	if (IsSpot()) {
		isave->BeginChunk(SPOTSHAPE_CHUNK);
		isave->Write(&shape, sizeof(shape), &nb);
		isave->EndChunk();
		if (overshoot) {
			isave->BeginChunk(OVERSHOOT_CHUNK);
			isave->EndChunk();
			}
		}

	if (projector) {
		isave->BeginChunk(PROJECTOR_CHUNK);
		isave->EndChunk();
		}
	if (!affectDiffuse) {
		isave->BeginChunk(DONT_AFFECT_DIFF_CHUNK);
		isave->EndChunk();
		}
	if (!affectSpecular) {
		isave->BeginChunk(DONT_AFFECT_SPEC_CHUNK);
		isave->EndChunk();
		}
	if (softenDiffuse) {
		isave->BeginChunk(SOFTEN_DIFF_CHUNK);
		isave->EndChunk();
		}
	if (decayType) {
		isave->BeginChunk(DECAY_TYPE_CHUNK);
		isave->Write(&decayType, sizeof(decayType), &nb);
		isave->EndChunk();
		}

	if (ltAffectsShadow) {
		isave->BeginChunk(LT_EFFECT_SHAD_CHUNK);
		isave->EndChunk();
		}

	if (ambientOnly) {
		isave->BeginChunk(AMBIENT_ONLY_CHUNK);
		isave->EndChunk();
		}
	if (exclList.Count()>0) {
		isave->BeginChunk(EXCL_LIST_CHUNK);
		exclList.Save(isave);
		isave->EndChunk();
		}


	return IO_OK;
	}

void GeneralLight::FixOldVersions(ILoad *iload) {
	Point3 rgb;
	if (pblock->GetVersion() != LIGHT_VERSION) {
		int oldvers = pblock->GetVersion();
		if (oldvers>LIGHT_VERSION) 
			return;
		iload->SetObsolete();
		if (oldvers<12) {
			// loading a pre-pluggable shadow generators file
			// Split the parameters in two; the light part and the 
			// shadow generator part
			IParamBlock* oldPB = pblock;
			IParamBlock* newParamBlk = UpdateParameterBlock(GetDesc(oldvers,type), GetDim(oldvers,type), oldPB,
		                  GetDesc(LIGHT_VERSION,type), GetDim(LIGHT_VERSION,type), LIGHT_VERSION);
			if (shadowType) {
				ReplaceReference(SHADTYPE_REF,NewDefaultRayShadowType());
				}
			shadType->ConvertParamBlk( GetDesc(oldvers,type), GetDim(oldvers,type), oldPB);
			ReplaceReference( PBLOCK_REF, newParamBlk );	
			if (shadowType) {
				Renderer *rend = GetCOREInterface()->GetCurrentRenderer();
				if (rend->ClassID()==Class_ID(SREND_CLASS_ID,0)) {
					IScanRenderer *sr = (IScanRenderer*)rend;
					shadType->SetMaxDepth(TimeValue(0), sr->GetMaxRayDepth());
					}
				}
			shadType->SetAbsMapBias(TimeValue(0),absMapBias);
			if (oldvers<12) {
				SetShadMult( TimeValue(0), dlgShadMult );
				if (oldvers<11) {
					SetAtmosOpacity( TimeValue(0), dlgAtmosOpacity);
					SetAtmosColAmt( TimeValue(0), dlgAtmosColamt);
					SetAtmosShadows( TimeValue(0), dlgAtmosShadows);
					if (oldvers<10) {
						Control* c = pblock->GetController(type==OMNI_LIGHT?PB_OMNIATEND1:PB_ATTENEND1);
						if (c) {
							c = (Control *)CloneRefHierarchy(c);
							pblock->SetController(type==OMNI_LIGHT?PB_OMNIDECAY:PB_DECAY,c);
					   		}
						else 
							SetDecayRadius(0,GetAtten(0,ATTEN1_END));
						if (oldvers<8) {
							if (softenDiffuse) SetDiffuseSoft(0,1.0f);
							}
						}
					}
				}
			}

		else 
			ReplaceReference(PBLOCK_REF,
				UpdateParameterBlock(
					GetDesc(oldvers,type), GetDim(oldvers,type), pblock,
					GetDesc(LIGHT_VERSION,type), GetDim(LIGHT_VERSION,type), LIGHT_VERSION));
		}
	BuildSpotMesh(max(GetHotspot(0), GetFallsize(0)));
	}

class LightPostLoad : public PostLoadCallback {
public:
	GeneralLight *gl;
	Interval valid;
	LightPostLoad(GeneralLight *l) { gl = l;}
	void proc(ILoad *iload) {
		gl->FixOldVersions(iload);
		waitPostLoad--;
		delete this;
		}
	};

IOResult  GeneralLight::Load(ILoad *iload) 
{
	ULONG nb;
	IOResult res;
	enable = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case ON_OFF_CHUNK:
			res = iload->Read(&useLight,sizeof(useLight), &nb);
			break;
		case CONE_DISPLAY_CHUNK:
			res = iload->Read(&coneDisplay,sizeof(coneDisplay), &nb);
			break;
		case RANGE_DISPLAY_CHUNK:
			res = iload->Read(&attenDisplay,sizeof(attenDisplay), &nb);
			break;
		case DECAY_DISPLAY_CHUNK:
			res = iload->Read(&decayDisplay,sizeof(decayDisplay), &nb);
			break;
		case NEAR_USE_ATTEN_CHUNK:
			res = iload->Read(&useAttenNear,sizeof(useAttenNear), &nb);
			break;
		case NEAR_RANGE_DISPLAY_CHUNK:
			res = iload->Read(&attenNearDisplay,sizeof(attenNearDisplay), &nb);
			break;
		case USE_ATTEN_CHUNK:
			res = iload->Read(&useAtten,sizeof(useAtten), &nb);
			break;
		case SHADOW_CHUNK:
			res = iload->Read(&shadow,sizeof(shadow), &nb);
			break;
		case SHADOW_TYPE_CHUNK:// for reading old files
			res = iload->Read(&shadowType,sizeof(shadowType), &nb);
			break;
		case GLOBALSHADOW_CHUNK:
			res = iload->Read(&useGlobalShadowParams,sizeof(useGlobalShadowParams), &nb);
			break;
		case SPOTSHAPE_CHUNK:
			res = iload->Read(&shape,sizeof(shape), &nb);
			break;
		case ABS_MAP_BIAS_CHUNK: // for reading old files
			res = iload->Read(&absMapBias,sizeof(absMapBias), &nb);
			break;
		case OVERSHOOT_CHUNK:
			overshoot = TRUE;
			break;
		case PROJECTOR_CHUNK:
			projector = TRUE;
			break;
		case DONT_AFFECT_DIFF_CHUNK:
			affectDiffuse = FALSE;
			break;
		case DONT_AFFECT_SPEC_CHUNK:
			affectSpecular = FALSE;
			break;
		case SOFTEN_DIFF_CHUNK:
			softenDiffuse = TRUE;
			break;
		case EXCL_LIST_CHUNK:
			res = exclList.Load(iload);	
			break;
		case DECAY_TYPE_CHUNK:
			res = iload->Read(&decayType,sizeof(decayType), &nb);
			break;
		case LT_EFFECT_SHAD_CHUNK:
			ltAffectsShadow = TRUE;
			break;
		case AMBIENT_ONLY_CHUNK:
			ambientOnly = TRUE;
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	waitPostLoad++;
	iload->RegisterPostLoadCallback(new LightPostLoad(this));
//	waitPostLoad++;
	iload->RegisterPostLoadCallback(new ParamBlockPLCB( emitterVersions, numEmitterVersions, &curEmitterVersion, this, EMITTER_REF ));
	return IO_OK;
}


// target spot light creation stuff...

class TSpotCreationManager : public MouseCallBack, ReferenceMaker 
{
private:
	CreateMouseCallBack *createCB;	
	INode *lgtNode,*targNode;
	GeneralLight *lgtObject;
	TargetObject *targObject;
	int attachedToNode;
	IObjCreate *createInterface;
	ClassDesc *cDesc;
	Matrix3 mat;  // the nodes TM relative to the CP
	IPoint2 pt0;
	int ignoreSelectionChange;
	int lastPutCount;

	void CreateNewObject();	

	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i) { return (RefTargetHandle)lgtNode; } 
	void SetReference(int i, RefTargetHandle rtarg) { lgtNode = (INode *)rtarg; }

	// StdNotifyRefChanged calls this, which can change the partID to new value 
	// If it doesnt depend on the particular message& partID, it should return
	// REF_DONTCARE
    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

public:
	void Begin( IObjCreate *ioc, ClassDesc *desc );
	void End();
		
	TSpotCreationManager()	{ ignoreSelectionChange = FALSE; }
	int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
};


#define CID_TSPOTCREATE	CID_USER + 3

class TSpotCreateMode : public CommandMode {
	TSpotCreationManager proc;
public:
	void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
	void End() { proc.End(); }

	int Class() { return CREATE_COMMAND; }
	int ID() { return CID_TSPOTCREATE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints = 1000000; return &proc; }
	ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
	BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
	void EnterMode() {
		}
	void ExitMode() {
		}
	BOOL IsSticky() { return FALSE; }
};

static TSpotCreateMode theTSpotCreateMode;

void TSpotCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	lgtNode         = NULL;
	targNode        = NULL;
	lgtObject       = NULL;
	targObject      = NULL;
	CreateNewObject();
}

void TSpotCreationManager::End()
{
	if ( lgtObject ) {
		lgtObject->EndEditParams( (IObjParam*)createInterface, END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) {
			// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			//delete lgtObject;
			lgtObject->DeleteThis();  // JBW 11.1.99, this allows scripted plugin lights to delete cleanly
			lgtObject = NULL;
			theHold.Resume();
			// RB 7/28/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
			macroRec->Cancel();  // JBW 4/23/99
		} 
		else if ( lgtNode ) {
			 // Get rid of the reference.
			DeleteReference(0);  // sets lgtNode = NULL
		}
	}	
}

RefResult TSpotCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
{
	switch (message) {
		
	case REFMSG_PRENOTIFY_PASTE:
	case REFMSG_TARGET_SELECTIONCHANGE:
	 	if ( ignoreSelectionChange ) {
			break;
		}
	 	if (lgtObject && lgtNode==hTarget) {
			// this will set camNode== NULL;
			DeleteReference(0);
			goto endEdit;
		}
		// fall through

	case REFMSG_TARGET_DELETED:		
		if ( lgtObject && lgtNode==hTarget ) {
			endEdit:
			lgtObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
			lgtObject  = NULL;				
			lgtNode    = NULL;
			CreateNewObject();	
			attachedToNode = FALSE;
		}
		else if (targNode==hTarget) {
			targNode = NULL;
			targObject = NULL;
		}
		break;		
	}
	return REF_SUCCEED;
}


void TSpotCreationManager::CreateNewObject()
{
	lgtObject = (GeneralLight *)cDesc->Create();
	lastPutCount = theHold.GetGlobalPutCount();

    macroRec->BeginCreate(cDesc);  // JBW 4/23/99
	
	// Start the edit params process
	if ( lgtObject ) {
		lgtObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
	}	
}

static void whoa(){};

static BOOL needToss;
			
int TSpotCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
{	
	int res;
	TSTR targName;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
	case MOUSE_POINT:
		switch ( point ) {
		case 0:
			pt0 = m;
			assert( lgtObject );					
			if ( createInterface->SetActiveViewport(hwnd) ) {
				return FALSE;
			}

			if (createInterface->IsCPEdgeOnInView()) { 
				res = FALSE;
				goto done;
			}

			// if lights were hidden by category, re-display them
			GetCOREInterface()->SetHideByCategoryFlags(
					GetCOREInterface()->GetHideByCategoryFlags() & ~HIDE_LIGHTS);

			if ( attachedToNode ) {
		   		// send this one on its way
		   		lgtObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				macroRec->EmitScript();  // JBW 4/23/99
					
				// Get rid of the reference.
				if (lgtNode)
					DeleteReference(0);

				// new object
				CreateNewObject();   // creates lgtObject
			}

			needToss = theHold.GetGlobalPutCount()!=lastPutCount;

		   	theHold.Begin();	 // begin hold for undo
			mat.IdentityMatrix();

			// link it up
			lgtNode = createInterface->CreateObjectNode( lgtObject);
			attachedToNode = TRUE;
			assert( lgtNode );					
			createCB = lgtObject->GetCreateMouseCallBack();					
			createInterface->SelectNode( lgtNode );
					
			// Create target object and node
			targObject = new TargetObject;
			assert(targObject);
			targNode = createInterface->CreateObjectNode( targObject);
			assert(targNode);
			targName = lgtNode->GetName();
			targName += GetString(IDS_DB_DOT_TARGET);
			targNode->SetName(targName);
				
			// hook up camera to target using lookat controller.
			createInterface->BindToTarget(lgtNode,targNode);

			// Reference the new node so we'll get notifications.
			MakeRefByID( FOREVER, 0, lgtNode);
			
			// Position camera and target at first point then drag.
			mat.IdentityMatrix();
			//mat[3] = vpx->GetPointOnCP(m);
			#ifdef _3D_CREATE
				mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
			#else
				mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
			#endif
			createInterface->SetNodeTMRelConstPlane(lgtNode, mat);
			createInterface->SetNodeTMRelConstPlane(targNode, mat);
			lgtObject->Enable(1);

		   	ignoreSelectionChange = TRUE;
		   	createInterface->SelectNode( targNode,0);
		   	ignoreSelectionChange = FALSE;
			res = TRUE;
			break;
					
		case 1:
			if (Length(m-pt0)<2)
				goto abort;
			//mat[3] = vpx->GetPointOnCP(m);
			#ifdef _3D_CREATE
				mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
			#else
				mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
			#endif
			macroRec->Disable();   // JBW 4/23/99
			createInterface->SetNodeTMRelConstPlane(targNode, mat);
			macroRec->Enable();

			ignoreSelectionChange = TRUE;
		   	createInterface->SelectNode( lgtNode);
		   	ignoreSelectionChange = FALSE;
					
		    theHold.Accept(IDS_DS_CREATE);	 

			createInterface->AddLightToScene(lgtNode); 
			createInterface->RedrawViews(createInterface->GetTime());  

			res = FALSE;	// We're done
			break;
		}			
		break;

	case MOUSE_MOVE:
		//mat[3] = vpx->GetPointOnCP(m);
		#ifdef _3D_CREATE
			mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
		#else
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
		#endif
		macroRec->Disable();   // JBW 4/23/99
		createInterface->SetNodeTMRelConstPlane(targNode, mat);
		macroRec->Enable();
		createInterface->RedrawViews(createInterface->GetTime());

		macroRec->SetProperty(lgtObject, _T("target"),   // JBW 4/23/99
			mr_create, Class_ID(TARGET_CLASS_ID, 0), GEOMOBJECT_CLASS_ID, 1, _T("transform"), mr_matrix3, &mat);

		res = TRUE;
		break;

	case MOUSE_FREEMOVE:
		SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		#ifdef _OSNAP
			//Snap Preview
			#ifdef _3D_CREATE
				vpx->SnapPreview(m,m,NULL, SNAP_IN_3D);
			#else
				vpx->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
			#endif
		#endif

		break;

    case MOUSE_PROPCLICK:
		// right click while between creations
		createInterface->RemoveMode(NULL);
		break;
		
	case MOUSE_ABORT:
		abort:
		assert( lgtObject );
		lgtObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		// Toss the undo stack if param changes have been made
		macroRec->Cancel();  // JBW 4/23/99
		theHold.Cancel();	 // deletes both the camera and target.
		if (needToss) 
			GetSystemSetting(SYSSET_CLEAR_UNDO);
		lgtNode = NULL;			
		targNode = NULL;	 	
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;						
	}
	
done:
	createInterface->ReleaseViewport(vpx); 
	return res;
}

//----------------------------------------------------------------------

//#include "..\..\include\imaxscrpt.h"  //gdf 11,09.1999 see below.
//gdf 11.09.1999 SDK sample code imaxscrpt.h isn't part of the maxsdk (move to maxapi.h for R4)
#define I_EXEC_GET_DELEGATING_CLASSDESC	0x11002

int TSpotLightClassDesc::BeginCreate(Interface *i)
{
	IObjCreate *iob = i->GetIObjCreate();
	
	//iob->SetMouseProc( new LACamCreationManager(iob,this), 1000000 );

	ClassDesc* delegatingCD;			// JBW 11.1.99, allows fully functional extending scripted lights
										// by causing the custom command mode to create the delegating class
	i->Execute(I_EXEC_GET_DELEGATING_CLASSDESC, (ULONG)&delegatingCD);
	theTSpotCreateMode.Begin( iob, (delegatingCD ? delegatingCD : this) );

	iob->PushCommandMode( &theTSpotCreateMode );
	
	return TRUE;
}


int TSpotLightClassDesc::EndCreate(Interface *i)
{
	theTSpotCreateMode.End();
	i->RemoveMode( &theTSpotCreateMode );
	macroRec->EmitScript();  // JBW 4/23/99

	return TRUE;
}

//----------------------------------------------------------------------


int TDirLightClassDesc::BeginCreate(Interface *i)
	{
	IObjCreate *iob = i->GetIObjCreate();
	
	//iob->SetMouseProc( new LACamCreationManager(iob,this), 1000000 );

	ClassDesc* delegatingCD;			// JBW 11.1.99, allows fully functional extending scripted lights
										// by causing the custom command mode to create the delegating class
	i->Execute(I_EXEC_GET_DELEGATING_CLASSDESC, (ULONG)&delegatingCD);
	theTSpotCreateMode.Begin( iob, (delegatingCD ? delegatingCD : this) );
	iob->PushCommandMode( &theTSpotCreateMode );
	
	return TRUE;
	}

int TDirLightClassDesc::EndCreate(Interface *i)
	{
	theTSpotCreateMode.End();
	i->RemoveMode( &theTSpotCreateMode );

	return TRUE;
	}



//----------------------------------------------------------------------
//  Light descriptors for rendering
//----------------------------------------------------------------------

#define COS_45 0.7071067f
#define COS_45_2X 1.4142136f

static float stepFactor[] = {50.0f,80.0f,140.0f};
#define MAXSTEPS 1000

class AttenRanges {
	public:
		float aStart, aEnd;	// Attenuation start and end and hot spot scaling for volume shading		
		float aNearStart, aNearEnd;	// Near Attenuation start and end and hot spot scaling for volume shading		
		float decayRadius;
	};

class BaseObjLight : public ObjLightDesc {
	public:		
		NameTab exclList;
		Color intensCol;   	// intens*color	
		// RB: put these into a different structure and pass them to
		// AttenIllum to avoid threading problems.
		//float aStart, aEnd;	// Attenuation start and end and hot spot scaling for volume shading		
		//float aNearStart, aNearEnd;	// Near Attenuation start and end and hot spot scaling for volume shading		
		Color shadColor;
		float shadMult;
		float contrast,kA,kB,diffSoft;
		int decayType;
		Texmap *shadProjMap;
		BOOL ltAfctShad;
		BOOL diffSoften;
		BOOL dontNeedShadBuf;
		int atmosShadows;
		float atmosOpacity;
		float atmosColAmt;
		BOOL doingShadColor;
		BOOL ambOnly;
		BOOL isDefaultShadowMap;
		float decayRadius;
		GeneralLight* gl;
		BaseObjLight(INode *n);
		void DeleteThis() {delete this;}
		NameTab* GetExclList() { return &exclList; }  
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext * rgc, BOOL shadows, BOOL shadowGeomChanged);
		void UpdateGlobalLightLevel(Color globLightLevel) {
			intensCol = ls.intens*ls.color*globLightLevel;
			}
		void ApplyAtmosShadows(ShadeContext &sc, Point3 lpos, Color  &color); 
		inline void ApplyShadowColor(Color &color, const float &shadAtten, const Color &scol);
		void TraverseVolume(ShadeContext& sc,const Ray &ray,int samples,float tStop,float attenStart,float attenEnd,DWORD flags,LightRayTraversal *proc);
		virtual BOOL IntersectRay(Ray &ray, float &t0, float &t1, AttenRanges &ranges) {return FALSE;}
		virtual int  IntersectRayMultiple(Ray &ray, float t0, float t1, float *t);
		virtual Color AttenuateIllum(ShadeContext& sc,Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges) {return Color(0,0,0);}		
		virtual BOOL UseAtten()=0;
		virtual BOOL IsFacingLight(Point3 &dir) {return FALSE;}
		virtual int LightType()=0;

		inline float ContrastFunc(float nl) {
			if (diffSoft!=0.0f) {
				float p = nl*nl*(2.0f-nl);	// based on Hermite interpolant 
				nl = diffSoft*p + (1.0f-diffSoft)*nl;
				}
			return (contrast==0.0f)? nl: 
				nl/(kA*nl+kB);  //  the "Bias" function described in Graphics Gems IV, pp. 401ff
			}
		inline float Decay(float att,float dist, float r0) {
			float s;
			if (decayType==DECAY_NONE || dist==0.0f) return att;
			if ((s=r0/dist)>=1.0f) return att;
			return  (decayType==DECAY_INVSQ)?  s*s*att: s*att;
			}
	};



BaseObjLight::BaseObjLight(INode *n) : ObjLightDesc(n) {
	ObjectState os = n->EvalWorldState(TimeValue(0));
	assert(os.obj->SuperClassID()==LIGHT_CLASS_ID);
	gl = (os.obj->GetInterface(I_MAXSCRIPTPLUGIN) != NULL) ? (GeneralLight*)os.obj->GetReference(0) : (GeneralLight*)os.obj;  // JBW 4/7/99
	exclList = *(gl->GetExclList());
	isDefaultShadowMap = gl->ActiveShadowType()->SupportStdMapInterface();
	}	

static Color blackCol(0,0,0);

int BaseObjLight::Update(TimeValue t, const RendContext& rc, RenderGlobalContext * rgc, BOOL shadows, BOOL shadowGeomChanged) {
	ObjLightDesc::Update(t,rc,rgc,shadows,shadowGeomChanged);
	intensCol = ls.intens*ls.color*rc.GlobalLightLevel();
	ObjectState os = inode->EvalWorldState(t);
    GeneralLight* lob = (GeneralLight *)os.obj;		
	contrast = lob->GetContrast(t);
	diffSoft = lob->GetDiffuseSoft(t)/100.0f;
	decayType = lob->GetDecayType();
	//shadColor= lob->GetShadColor(t)*lob->GetShadMult(t);
	shadColor= lob->GetShadColor(t);
	shadMult = lob->GetShadMult(t);
	ambOnly = lob->GetAmbientOnly();
	decayRadius = lob->GetDecayRadius(t);
	doingShadColor = (shadColor == Color(0,0,0))?0:1;
	shadProjMap = lob->GetUseShadowColorMap(t)?lob->GetShadowProjMap():NULL;
	ltAfctShad = lob->GetLightAffectsShadow();
	ambOnly = lob->GetAmbientOnly();
	float a = contrast/204.0f + 0.5f; // so "a" varies from .5 to .99
	kA = (2.0f-1.0f/a);
	kB = 1.0f-kA;
	diffSoften = lob->GetSoftenDiffuse();
	//dontNeedShadBuf = (intensCol==Color(0,0,0))?1:0;   		

	// if light is black and don't have a shadowProjMap or a non-black shadow color,
	// then don't need a shadow buffer
	dontNeedShadBuf =  ((intensCol==blackCol)&&(!(shadProjMap||(!(shadColor==blackCol)))))?1:0;
			 	

	atmosShadows = /*lob->GetShadow()&&*/shadows&&lob->GetAtmosShadows(t);
	atmosOpacity = lob->GetAtmosOpacity(t);
	atmosColAmt = lob->GetAtmosColAmt(t);

	return 1;
	}

void BaseObjLight::ApplyAtmosShadows(ShadeContext &sc, Point3 lpos, Color  &color) { 
	if (sc.globContext&&sc.globContext->atmos) {
		Color col, trans;
		trans = Color(1.f, 1.f, 1.f);
		col = Color(1.f,1.f,1.f);
		int oldmode = sc.mode;
		sc.mode = SCMODE_SHADOW;
		sc.SetAtmosSkipLight(this);
		sc.globContext->atmos->Shade(sc, lightPos, sc.P(), col, trans);
		sc.SetAtmosSkipLight(NULL);
		sc.mode = oldmode;
		trans = 1.0f - (atmosOpacity * (1.0f - trans));
		col = 1.0f - (atmosColAmt * (1.0f - col));
		color *= trans;
		color *= col;
		}
	}

void BaseObjLight::ApplyShadowColor(Color &color, const float &shadAtten, const Color &scol) {
	float k =  (1.0f-shadAtten)*shadMult;
	if (k>=0.0f) {
		if (k<=1.0f) 
			// 0 < k < 1 
			color = ltAfctShad? color*(1.0f-k+k*scol):	(1.0f-k)*color + k*scol;
		else  	
			// k>1			
			color = ltAfctShad? color*(k*scol): k*scol;
		}
	else {	// k<0
		color = ltAfctShad? color*(1.0f+k*scol): color + k*scol;
		}
	}

int BaseObjLight::IntersectRayMultiple(Ray &ray, float t0, float t1, float *t) { 
	t[0] = t0;
	t[1] = t1;
	return 2;
	}

void BaseObjLight::TraverseVolume(
		ShadeContext& sc,
		const Ray &ray,int samples,float tStop,
		float attenStart, float attenEnd,
		DWORD flags,
		LightRayTraversal *proc)
	{
	Point3 dp, p;
	float ot, t, dt, ldp, t0, t1, dtLight, distAtten;
	Color illum, colStep;	
	Ray lr;
	int filt = 0;
	if (sc.GetAtmosSkipLight()==this)
		return;
	AttenRanges ranges;

	if (flags&TRAVERSE_LOWFILTSHADOWS) filt=1;
	if (flags&TRAVERSE_HIFILTSHADOWS) filt=2;
	if (flags&TRAVERSE_USESAMPLESIZE) filt=3;

	lr.p   = worldToLight * ray.p;
	lr.dir = VectorTransform(worldToLight,ray.dir);
	
	if (LightType()==DIR_LIGHT&&ls.useNearAtten&&ls.useAtten) {
		float mid = (ls.nearAttenEnd+ls.attenStart)/2.0f;
		ranges.aStart    = (ls.attenStart-mid)*attenStart + mid;
		ranges.aEnd      = (ls.attenEnd-mid)*attenEnd + mid;
		ranges.aNearStart= (ls.nearAttenStart-mid)*attenStart + mid;
		ranges.aNearEnd  = (ls.nearAttenEnd-mid)*attenEnd + mid;

		// DS 8/14/98  added decay radius, have to scale it like nearAttenEnd because that
		// is what we formely used for the decay radius.
		ranges.decayRadius = (decayRadius-mid)*attenEnd + mid;
		}
	else {
		ranges.aStart    = ls.attenStart * attenStart;
		ranges.aEnd      = ls.attenEnd * attenEnd;
		ranges.aNearStart= ls.nearAttenStart * attenStart;
		ranges.aNearEnd  = ls.nearAttenEnd * attenEnd;
		ranges.decayRadius  = decayRadius * attenEnd;
		}
		
	// See where we hit the light volume
	if (!IntersectRay(lr,t0,t1,ranges)) {
		// We missed.
		proc->Step(0.0f,tStop,Color(0,0,0),1.0f);
		return;
		}

	if (t1<0.0f || t0>tStop) {
		// We missed.
		proc->Step(0.0f,tStop,Color(0,0,0),1.0f);
		return;
		}
	if (t0<0.0f) t0 = 0.0f;
	if (t1>tStop) t1 = tStop;
	if (LightType()!=OMNI_LIGHT) {
		if (UseAtten() && (t1-t0) > (2.0f*ranges.aEnd)) {
			// We can only do this if we're not looking into a spot light.
			if (!IsFacingLight(lr.dir)) {
				t1 = 2.0f*ranges.aEnd + t0;
				}
			}
		}

	// The first (large) step
	if (t0!=0.0f) {
		if (!proc->Step(0.0f,t0,Color(0,0,0),1.0f)) {
			return;
			}
		}
	float tm[10];
	int n;	
	n = IntersectRayMultiple(lr,t0,t1,tm);

	dtLight = (t1-t0)/float(samples);
	
	for (int i=0; i<n-1; i++) {
		// Set everything up
		//dtLight = LightStepSize(sc,lr,t0,t1,minStep,filt);
		dt      = dtLight;
		if (dt<0.0001f) dt = 0.0001f;
		ot      = tm[i];
		t       = tm[i] + dt;	
		dp      = lr.dir * dt;
		ldp     = FLength(dp);
		colStep = intensCol * ldp;
		p       = lr.p + lr.dir*ot;

		// Traverse the ray inside of the light volume
		//for ( ; t<t1; t+=dt,p+=dp) {
		for (int sp=0; sp<samples && t<=tm[i+1]; sp++,t+=dt,p+=dp) {
			distAtten = 1.0f;
			illum = AttenuateIllum(sc,p,colStep,dp,filt,ldp,distAtten,ranges);

			// Call the callback.
			if (!proc->Step(ot,t,illum,distAtten)) {
				return;
				}
			ot = t;
			}

		// Do the remainder
		p      -= dp;
		ot      = t-dt;
		dt      = tm[i+1]-ot;
		dp      = lr.dir * dt;
		p      += dp;

		ldp     = FLength(dp);
		colStep = intensCol * ldp;

		// Attenuate the light at this point
		distAtten = 1.0f;
		illum = AttenuateIllum(sc,p,colStep,dp,filt,ldp,distAtten,ranges);

		// Call the callback.
		if (!proc->Step(ot,tm[i+1],illum,distAtten)) {
			return;
			}
		}

	// The last (large) step
	if (t1<tStop) {
		proc->Step(t1,tStop,Color(0,0,0),1.0f);
		}	
	}

//--- Omni Light ------------------------------------------------

class OmniLight : public BaseObjLight {		
//	ShadowBuffer *shadBuf[6];
//	ShadowQuadTree *rayBuf[6];
	ShadowGenerator *shadGen[6];
	Matrix3 tmCamToLight[6]; 
	BOOL shadow, doShadows, shadowRay, projector;
	Texmap *projMap;
	int shadsize;
	BOOL needMultiple;
	BOOL genCanDoOmni;
	float zfac, xscale, yscale, fov, sz2,size,sizeClip,sampSize,sampSize2;
	public:		
		OmniLight(INode *inode);
		~OmniLight();
		void FreeShadGenBuffers();
		void FreeShadGens();
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);
		int UpdateViewDepParams(const Matrix3& worldToCam);
		AColor SampleProjMap(ShadeContext &sc,  Point3 plt, Point3 dp, float x, float y, Texmap *map);
		BOOL Illuminate(ShadeContext &sc, Point3& normal, Color& color, Point3 &dir, float& dot_nl, float &diffuseCoef);
		BOOL IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges);
		BOOL NeedMultiple() { return needMultiple; }
		int  IntersectRayMultiple(Ray &ray, float t0, float t1, float *t);
		Color AttenuateIllum(ShadeContext& sc,Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges);		
		BOOL UseAtten() {return TRUE;}
		int LightType() { return OMNI_LIGHT; }
	};

OmniLight::OmniLight(INode *inode) : BaseObjLight(inode){
#ifndef DESIGN_VER
	shadow = FALSE;
#else
	shadow = TRUE;
#endif
	projector = doShadows =  shadowRay =  FALSE; 
	projMap = NULL;
	needMultiple = FALSE;
	genCanDoOmni = gl->ActiveShadowType()->CanDoOmni();
	for (int i=0; i<6; i++) 
		shadGen[i] = NULL;
	if(gl->GetShadow()) {
		if (genCanDoOmni)
			shadGen[0] = gl->ActiveShadowType()->CreateShadowGenerator(gl, this, SHAD_OMNI); 
		else {
			for (int i=0; i<6; i++) {
				shadGen[i] = gl->ActiveShadowType()->CreateShadowGenerator(gl, this, 0); 
				}
			}
		}
	}

OmniLight::~OmniLight() {
	FreeShadGens();
	}

void OmniLight::FreeShadGens() {
	for (int i=0; i<6; i++) {
		if (shadGen[i]) {
			shadGen[i]->DeleteThis();
			shadGen[i] = NULL;
			}
		}
	}

void OmniLight::FreeShadGenBuffers() {
	for (int i=0; i<6; i++) {
		if (shadGen[i]) {
			shadGen[i]->FreeBuffer();
			}
		}
	}


int OmniLight::UpdateViewDepParams(const Matrix3& worldToCam) {
	BaseObjLight::UpdateViewDepParams(worldToCam);
	for (int i=0; i<6; i++) 
		if (shadGen[i])
			shadGen[i]->UpdateViewDepParams(worldToCam);
	return 1;
	}

static Point3 MapToDir(Point3 p, int k) {
	switch(k) {
		case 0: return Point3(  p.z, p.y, -p.x); // +X
		case 1: return Point3( -p.z, p.y,  p.x); // -X
		case 2: return Point3(  p.x, p.z, -p.y); // +Y 
		case 3:	return Point3(  p.x,-p.z,  p.y); // -Y
		case 4: return Point3( -p.x, p.y, -p.z); // +Z
		case 5: return p;                        // -Z
		}
 	return p;
	}

static void GetMatrixForDir(Matrix3 &origm, Matrix3 &tm, int k ) {
	tm = origm;
	switch(k) {
		case 0:	tm.PreRotateY(-HALFPI); break;	// Map 0: +X axis	
		case 1: tm.PreRotateY( HALFPI); break;	// Map 1: -X axis	
		case 2:	tm.PreRotateX( HALFPI); break;	// Map 2: +Y axis	
		case 3:	tm.PreRotateX(-HALFPI); break; 	// Map 3: -Y axis	
		case 4:	tm.PreRotateY(   PI  );	break; 	// Map 4: +Z axis	
		case 5: 						break; 	// Map 5: -Z axis	
		}
	}

static int WhichDir(Point3 &p) {
	int j = MaxComponent(p);  // the component with the maximum abs value
	return  (p[j]<0.0f) ? 2*j+1 : 2*j;
	}

int OmniLight::Update(TimeValue t, const RendContext & rc,
		RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged) {

	BaseObjLight::Update(t,rc,rgc,shadows,shadowGeomChanged);	

	ObjectState os = inode->EvalWorldState(t);
	LightObject* lob = (LightObject *)os.obj;		
	assert(os.obj->SuperClassID()==LIGHT_CLASS_ID);
	GeneralLight* gl = (lob->GetInterface(I_MAXSCRIPTPLUGIN) != NULL) ? (GeneralLight*)lob->GetReference(0) : (GeneralLight*)lob;  // JBW 4/7/99

	shadsize = gl->ActiveShadowType()->MapSize(t);
	if (shadsize<=0) shadsize = 10;
	size = (float)shadsize;
	sizeClip = size-.0001f;
	sz2 = .5f*(float)shadsize;
	fov = HALFPI; // 90 degree fov
	zfac = -float(0.5*(double)shadsize /tan(fov*0.5));
	xscale = zfac;								
	yscale = -zfac;
	shadow = gl->GetShadow()&shadows;	
	if (ambOnly) shadow = FALSE;
	shadowRay = gl->GetShadowType();
	sampSize = gl->GetMapRange(t);
	sampSize2 = sampSize/2.0f;

	int res;
//	ULONG flags = gl->GetAbsMapBias()?SHAD_BIAS_ABSOLUTE:0;
	projector =  gl->GetProjector();
	if (projector) {
		projMap = gl->GetProjMap();
		}
	if (shadow) {	
		if (dontNeedShadBuf) {
			FreeShadGenBuffers();
			}
		else {
			float clipDist = ls.useAtten? ls.attenEnd : DONT_CLIP;

			if (shadowGeomChanged) {
				//NEWSHAD
				if (genCanDoOmni) {
					res = shadGen[0]->Update(t,rc,rgc,lightToWorld,1.0f,fov,clipDist);
					}
				else {
					for (int i=0; i<6; i++) {
						Matrix3 tm;
						GetMatrixForDir(lightToWorld,tm,i);
						res = shadGen[i]->Update(t,rc,rgc,tm,1.0f,fov,clipDist);
						}
					}
				}
			}
		}
	shadow = shadow&&shadGen[0];	
	if (ambOnly)  shadow = FALSE;  // Shouldn't this come before create shadow gens?
	if (dontNeedShadBuf) shadow = FALSE;
	needMultiple = shadow||projMap;
	return 1;
	}

//--- Omni Light Shade Context, for projector lights------------------------
class SCOmni: public ShadeContext {
	public:
		ShadeContext *origsc;
		TimeValue curtime;
		Point3 ltPos; // position of point in light space
		Point3 view;  // unit vector from light to point, in light space
		Point2 uv,duv;
		IPoint2 scrpos;
		float curve;
		int projType;

		BOOL 	  InMtlEditor() { return origsc->InMtlEditor(); }
		LightDesc* Light(int n) { return NULL; }
		TimeValue CurTime() { return curtime; }
		int NodeID() { return -1; }
		int FaceNumber() { return 0; }
		int ProjType() { return projType; }
		Point3 Normal() { return Point3(0,0,0); }
		Point3 GNormal() { return Point3(0,0,0); }
		Point3 ReflectVector(){ return Point3(0,0,0); }
		Point3 RefractVector(float ior){ return Point3(0,0,0); }
		Point3 CamPos() { return Point3(0,0,0); }
		Point3 V() { return view; }
		void SetView(Point3 p) { view = p; }
		Point3 P() { return ltPos; }	
		Point3 DP() { return Point3(0,0,0); }
		Point3 PObj() { return ltPos; }
		Point3 DPObj(){ return Point3(0,0,0); } 
		Box3 ObjectBox() { return Box3(Point3(-1,-1,-1),Point3(1,1,1));}   	  	
		Point3 PObjRelBox() { return view; }
		Point3 DPObjRelBox() { return Point3(0,0,0); }
		void ScreenUV(Point2& UV, Point2 &Duv) { UV = uv; Duv = duv; }
		IPoint2 ScreenCoord() { return scrpos;} 
		Point3 UVW(int chan) { return Point3(uv.x, uv.y, 0.0f); }
		Point3 DUVW(int chan) { return Point3(duv.x, duv.y, 0.0f);  }
		void DPdUVW(Point3 dP[3],int chan) {}  // dont need bump vectors
		void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE) {}   // returns Background color, bg transparency
		
		float Curve() { return curve; }

		// Transform to and from internal space
		Point3 PointTo(const Point3& p, RefFrame ito) { return p; } 
		Point3 PointFrom(const Point3& p, RefFrame ifrom) { return p; } 
		Point3 VectorTo(const Point3& p, RefFrame ito) { return p; } 
		Point3 VectorFrom(const Point3& p, RefFrame ifrom) { return p; } 
		SCOmni(){ doMaps = TRUE; 	curve = 0.0f;		}
	};


AColor OmniLight::SampleProjMap(ShadeContext &sc,  Point3 plt, Point3 dp, float x, float y, Texmap *map) {
	SCOmni scomni;
	float ifs = 1.0f/(float)shadsize;
	scomni.projType = 0; // perspective
	scomni.curtime = sc.CurTime();
	scomni.view = FNormalize(plt);
	scomni.curve = (float)fabs(1.0f/xscale); 
	scomni.ltPos = plt;
	scomni.view = FNormalize(plt);
	scomni.uv.x = x*ifs;			
	scomni.uv.y = 1.0f-y*ifs;			
	scomni.scrpos.x = 0;
	scomni.scrpos.y = 0;
	scomni.filterMaps = sc.filterMaps;
	scomni.globContext = sc.globContext;
	scomni.mtlNum  = sc.mtlNum;
	scomni.origsc = &sc;
	float d = MaxAbs(dp.x,dp.y,dp.z);
	scomni.duv.x = scomni.duv.y = float(fabs(xscale*d*ifs/plt.z));
	d = 0.5*scomni.duv.x;

	if (scomni.uv.x<d) scomni.duv.x = scomni.uv.x*2.0f;
	else if (1.0f-scomni.uv.x<d) scomni.duv.x = (1.0f-scomni.uv.x)*2.0f;

	if (scomni.uv.y<d) scomni.duv.y = scomni.uv.y*2.0f;
	else if (1.0f-scomni.uv.y<d) scomni.duv.y = (1.0f-scomni.uv.y)*2.0f;

	// antialiasing for 3D textures: TBD
	return map->EvalColor(scomni);
	}

static inline float Square(float v) { return v*v; }

//----------------------------------------
// Adjacent buffers:
//------------------------0	1 2	3 4	5 ----
static int  ADJPOSX[6] = {4,5,0,0,1,0};
static int  ADJNEGX[6] = {5,4,1,1,0,1};
static int  ADJPOSY[6] = {3,3,5,4,3,3};
static int  ADJNEGY[6] = {2,2,4,5,2,2};
//-----------------------------------------


//#define METHOD1

BOOL OmniLight::Illuminate(ShadeContext &sc, Point3& normal, Color& color, Point3 &dir, float& dot_nl, float &diffuseCoef) {
	float dist;
	Point3 p = sc.P();
	Point3 L = lightPos-p;  // vector from light to p in camera space
	Point3 plt;
	// quick test for light behind surface

	if (ambOnly) {
		if ((dist = FLength(L))==0.0f) return 0;
		L /= dist;
		dir = L;
		plt = camToLight * p; 
		dist = FLength(plt);
		diffuseCoef = dot_nl = 1.0f;
		}

	else {
		if (DotProd(normal,L)<=0.0f)	
			return 0;

		if ((dist = FLength(L))==0.0f) return 0;
		L /= dist;
		dir = L;
		plt = camToLight * p; 
		dist = FLength(plt);
		if (uniformScale)  {
			dot_nl = DotProd(normal,L);	
			}
		else {
			Point3	N = FNormalize(VectorTransform(camToLight,normal));
			dot_nl = -DotProd(N,plt/dist);
			if (dot_nl<=0.0f) return 0;
			}
		diffuseCoef = ContrastFunc(dot_nl);
		}

	float atten=1.0f;
	float shadAtten=1.0f;

	if(ls.useNearAtten) {
	   	if(dist<ls.nearAttenStart)		// Beyond range 
	   		return 0;
		if(dist<ls.nearAttenEnd)	{
			// in attenuated range
			float u = (dist - ls.nearAttenStart)/(ls.nearAttenEnd-ls.nearAttenStart);
			atten = u*u*(3-2*u);  // smooth cubic curve 
			}
		}

	if(ls.useAtten) {
	   	if(dist>ls.attenEnd)		// Beyond range 
	   		return 0;
		if(dist>ls.attenStart)	{
			// in attenuation range
			float u = (ls.attenEnd - dist)/(ls.attenEnd-ls.attenStart);
			atten *= u*u*(3-2*u);  // smooth cubic curve 
			}
		}

//	atten = Decay(atten,dist,ls.nearAttenEnd);
	atten = Decay(atten,dist,decayRadius);

	color = intensCol;
	float x,y;

	if (sc.shadow&&shadow) { 
		// determine which of 6 buffers contains the point.
		int j = WhichDir(plt);  
		if (!isDefaultShadowMap) {
			if (genCanDoOmni) 
				shadAtten = shadGen[0]->Sample(sc,normal,color);
			else 
				shadAtten = shadGen[j]->Sample(sc,normal,color);
			if (projMap) {
				Point3 q = MapToDir(plt,j);	 // map plt into the buffer's space 
				x = sz2 + xscale*q.x/q.z;
				y = sz2 + yscale*q.y/q.z;
				color *= SampleProjMap(sc,q,sc.DP(),x,y,projMap);
				}
			}
		else 	{
			Point3 q = MapToDir(plt,j);	 // map plt into the buffer's space 
			x = sz2 + xscale*q.x/q.z;
			y = sz2 + yscale*q.y/q.z;
			Point3 n = VectorTransform(camToLight,normal);
			Point3 n1 = MapToDir(n,j);
			float k0 = 1.0f/(zfac*DotProd(n1,q));
			float k = q.z*q.z*k0;
			float a = shadGen[j]->Sample(sc, x, y, q.z, -n1.x*k, n1.y*k);

			// Check for sample rectangles that overlap into the next buffer:
			if (x-sampSize2<0.0f) {
				int j2 = ADJNEGX[j];
				Point3 q2 = MapToDir(plt,j2);	
				float x2 = sz2 + xscale*q2.x/q2.z;
				float y2 = sz2 + yscale*q2.y/q2.z;
				Point3 n2 = MapToDir(n,j2);
				k = q2.z*q2.z*k0;
				float a2 = shadGen[j2]->Sample(sc, x2, y2, q2.z, -n2.x*k, n2.y*k);
				if (a2>=0)
					a = (a*(x+sampSize2) + a2*(sampSize2-x))/sampSize;
				}
			else if (x+sampSize2>size) {
				int j2 = ADJPOSX[j];
				Point3 q2 = MapToDir(plt,j2);
				float x2 = sz2 + xscale*q2.x/q2.z;
				float y2 = sz2 + yscale*q2.y/q2.z;
				Point3 n2 = MapToDir(n,j2);
				k = q2.z*q2.z*k0;
				float a2 = shadGen[j2]->Sample(sc, x2, y2, q2.z, -n2.x*k, n2.y*k);
				if (a2>=0)
					a = (a*(size-x+sampSize2) + a2*(x+sampSize2-size))/sampSize;
				}
			if (y-sampSize2<0.0f) {
				int j2 = ADJNEGY[j];
				Point3 q2 = MapToDir(plt,j2);
				float x2 = sz2 + xscale*q2.x/q2.z;
				float y2 = sz2 + yscale*q2.y/q2.z;
				Point3 n2 = MapToDir(n,j2);
				k = q2.z*q2.z*k0;
				float a2 = shadGen[j2]->Sample(sc, x2, y2, q2.z, -n2.x*k, n2.y*k);
				if (a2>=0)
					a = (a*(y+sampSize2) + a2*(sampSize2-y))/sampSize;
				}
			else if (y+sampSize2>size) {
				int j2 = ADJPOSY[j];
				Point3 q2 = MapToDir(plt,j2);
				float x2 = sz2 + xscale*q2.x/q2.z;
				float y2 = sz2 + yscale*q2.y/q2.z;
				Point3 n2 = MapToDir(n,j2);
				k = q2.z*q2.z*k0;
				float a2 = shadGen[j2]->Sample(sc, x2, y2, q2.z, -n2.x*k, n2.y*k);
				if (a2>=0)
					a = (a*(size-y+sampSize2) + a2*(y+sampSize2-size))/sampSize;
				}
			shadAtten = a;
			//atten *= a;  // DS 6-5-98  keep shadow atten separate for doing shadow color

			if (projMap) 
				color *= SampleProjMap(sc,q,sc.DP(),x,y,projMap);
			}
		if (shadAtten!=1.0f) {
			Color scol = shadColor;
			if (shadProjMap) {
				Point3 q = MapToDir(plt,j);	 // map plt into the buffer's space 
				float x =  sz2 + xscale*q.x/q.z;
				float y =  sz2 + yscale*q.y/q.z;
				scol = SampleProjMap(sc,q,sc.DP(),x,y,shadProjMap);
				}
			ApplyShadowColor(color, shadAtten,scol);
			}
		}
	else {
		// No shadows:
		if (projMap) {
			int j = WhichDir(plt);  
			Point3 q = MapToDir(plt,j);	 // map plt into the buffer's space 
			x = sz2 + xscale*q.x/q.z;
			y = sz2 + yscale*q.y/q.z;
			color *= SampleProjMap(sc,q,sc.DP(),x,y,projMap);
			}
		}

	// ATMOSPHERIC SHADOWS
	if (atmosShadows)
		ApplyAtmosShadows(sc,lightPos,color);
	if (atten!=1.0f)
		color *= atten;
	return 1;
	}

static int __cdecl cmp( const void *e1, const void *e2 ) {
	float &f1 = *((float *)e1);
	float &f2 = *((float *)e2);
	return f1<f2?-1:1;
	}

#define OkIntersect(tt,axis)  if (tt>=t0 && tt<=t1) { p = ray.p + tt*ray.dir;	if ( MaxComponent(p)!=axis) s[n++]=tt; }


int OmniLight::IntersectRayMultiple(Ray &ray, float t0, float t1, float *tm) {
	if (!needMultiple) { 
		tm[0] = t0;
		tm[1] = t1;
		return 2;
		}

	// intersect ray with the 6 sub-sectors;
	float t;
	float s[6];
	Point3 p;
	int n = 0;

	//---------------------------------------------------------
	//  plane:  n.P=0     ray:  P = p+t*dir
	//   =>  t = -n.p/n.dir
	//---------------------------------------------------------
	//  compute intersections with the 6 bounding planes.	
	t = -(ray.p.x+ray.p.y)/(ray.dir.x+ray.dir.y);  // x+y=0
	OkIntersect(t,2);
	t = -(ray.p.x-ray.p.y)/(ray.dir.x-ray.dir.y);  // x-y=0
	OkIntersect(t,2);
	t = -(ray.p.y+ray.p.z)/(ray.dir.y+ray.dir.z);  // y+z=0
	OkIntersect(t,0);
	t = -(ray.p.y-ray.p.z)/(ray.dir.y-ray.dir.z);  // y-z=0
	OkIntersect(t,0);
	t = -(ray.p.z+ray.p.x)/(ray.dir.z+ray.dir.x);  // z+x=0
	OkIntersect(t,1);
	t = -(ray.p.z-ray.p.x)/(ray.dir.z-ray.dir.x);  // z-x=0
	OkIntersect(t,1);

	tm[0] = t0;
	if (n==0) { tm[1] = t1;	return 2;	}
	if (n==1) { tm[1] = s[0];	tm[2] = t1;	return 3;	}
	if (n==2) {
		tm[3] = t1;
		if (s[0]>s[1]) { tm[1] = s[1];	tm[2] = s[0];	}
		else {	tm[1] = s[0];	tm[2] = s[1];	}
		return 4;
		}

#define ORDER3(n1,n2,n3) { tm[1] = s[n1];  tm[2] = s[n2];  tm[3] = s[n3]; }

	if (n==3) {
		tm[4] = t1;
		if (s[0]<s[1]) { 
			if (s[1]<s[2]) ORDER3(0,1,2)
			else {
				if (s[0]<s[2]) ORDER3(0,2,1)
				else ORDER3(2,0,1)
				}
			}
		else {	// s[1]<s[0]
			if (s[0]<s[2]) ORDER3(1,0,2)
			else {
				if (s[2]<s[1]) ORDER3(2,1,0)
				else ORDER3(1,2,0)
				}
			}
		return 5;
		}
	// I don't think this case can ever happen, but here's code for it.
	qsort(s,n,sizeof(float),cmp);
	for (int i=0; i<n; i++)
		tm[i+1] = s[i];
	tm[n+1] = t1;
	return n+2;
	}


BOOL OmniLight::IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges)
	{
	float r = ranges.aEnd;
	float a, b, c, ac4, b2;
	float root;	

	a = DotProd(ray.dir,ray.dir);
	b = DotProd(ray.dir,ray.p) * 2.0f;
	c = DotProd(ray.p,ray.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return FALSE;
	
	root = float(sqrt(b2-ac4));
	t0 = (-b + root) / (2.0f * a);
	t1 = (-b - root) / (2.0f * a);
	if (t0 > t1) {float temp=t0;t0=t1;t1=temp;}

	return TRUE;
	}

#define SIZECLIP(x) if (x>=sizeClip) x = sizeClip;	else if (x<0.0f) x = 0.0f;

Color OmniLight::AttenuateIllum(
		ShadeContext& sc,
		Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges)
	{
	// If we're not using attenuation, this is going to be a pretty boring volume!
	float dist = FLength(p);				 
	float atten = 1.0f;

	if (!isDefaultShadowMap) 
   		return Color(0.0f,0.0f,0.0f);

	distAtten = 1.0f;

	// Handle light distance attenuation 
	if(ls.useNearAtten) {
	   	if(dist<ranges.aNearStart) { // beyond range
			distAtten = 0.0f;
	   		return Color(0.0f,0.0f,0.0f);
			}
		if(dist<ranges.aNearEnd)	{
			// in attenuated range
			float u = (dist - ranges.aNearStart)/(ranges.aNearEnd-ranges.aNearStart);
			atten = distAtten = u*u*(3-2*u);  // smooth cubic curve 
			}
		}
	if (ls.useAtten) {		
	   	if(dist>ranges.aEnd)	{	// Beyond range 
			distAtten = 0.0f;
	   		return Color(0.0f,0.0f,0.0f);
			} 
		else 
		if(dist>ranges.aStart) {
			// in attenuated range
			float u = (ranges.aEnd-dist)/(ranges.aEnd-ranges.aStart);	
			atten = distAtten *= u*u*(3-2*u);
			}
		}	

//	atten = Decay(atten,dist,ranges.aNearEnd);
	atten = Decay(atten, dist, ranges.decayRadius);

//	if (sc.shadow && shadow && shadBuf[0]) { 
	if (sc.shadow && shadow && isDefaultShadowMap) { 
		// determine which of 6 buffers contains the point.
		Point3 pm = p+0.5f*dp;
		int j = WhichDir(pm);  // use midpoint to make sure we get correct buffer
		Point3 q = MapToDir(p,j);	 // map p into the buffer's space 
		float x,y;
		x = sz2 + xscale*q.x/q.z;
		y = sz2 + yscale*q.y/q.z;
		SIZECLIP(x);
		SIZECLIP(y);

		if (filt) {
			if (filt==1) { // Medium
				atten *= shadGen[j]->FiltSample(int(x), int(y), q.z, filt);
				}
			else 
			if (filt==2) {	// High
				Point3 q2 = MapToDir(p+dp,j);
				if (q2.z<0.0f) {
					float x2 = sz2 + xscale*q2.x/q2.z;
					float y2 = sz2 + yscale*q2.y/q2.z;
					SIZECLIP(x2);
					SIZECLIP(y2);
					float a = shadGen[j]->LineSample(int(x), int(y), q.z, int(x2), int(y2), q2.z);
					atten *= a;
					}
				}
			else
			if (filt==3) { // Use sample range
				atten *= shadGen[j]->Sample(sc,x,y,q.z,0.0f,0.0f);
				}
			if (atten==0.0f) return Color(0.0f,0.0f,0.0f);
			} 
		else {	//Low	
			if (!shadGen[j]->QuickSample(int(x), int(y), q.z)) {
				return Color(0.0f,0.0f,0.0f);
				}
			}		
		}
	if (projMap) {
		int j = WhichDir(p);  
		Point3 q = MapToDir(p,j);	 // map plt into the buffer's space 
		float x = sz2 + xscale*q.x/q.z;
		float y = sz2 + yscale*q.y/q.z;
		AColor pc = SampleProjMap(sc, q, dp,x,y,projMap);
		return atten*colStep*Color(pc.r,pc.g,pc.b);
		}
	
	return atten*colStep;
	}


//--- Spot Light Shade Context, for projector lights------------------------

class SCLight: public ShadeContext {
	public:
		ShadeContext *origsc;
		TimeValue curtime;
		Point3 ltPos; // position of point in light space
		Point3 view;  // unit vector from light to point, in light space
		Point2 uv,duv;
		IPoint2 scrpos;
		float curve;
		int projType;

		BOOL 	  InMtlEditor() { return origsc->InMtlEditor(); }
		LightDesc* Light(int n) { return NULL; }
		TimeValue CurTime() { return curtime; }
		int NodeID() { return -1; }
		int FaceNumber() { return 0; }
		int ProjType() { return projType; }
		Point3 Normal() { return Point3(0,0,0); }
		Point3 GNormal() { return Point3(0,0,0); }
		Point3 ReflectVector(){ return Point3(0,0,0); }
		Point3 RefractVector(float ior){ return Point3(0,0,0); }
		Point3 CamPos() { return Point3(0,0,0); }
		Point3 V() { return view; }
		void SetView(Point3 v) { view = v; }
		Point3 P() { return ltPos; }	
		Point3 DP() { return Point3(0,0,0); }
		Point3 PObj() { return ltPos; }
		Point3 DPObj(){ return Point3(0,0,0); } 
		Box3 ObjectBox() { return Box3(Point3(-1,-1,-1),Point3(1,1,1));}   	  	
		Point3 PObjRelBox() { return view; }
		Point3 DPObjRelBox() { return Point3(0,0,0); }
		void ScreenUV(Point2& UV, Point2 &Duv) { UV = uv; Duv = duv; }
		IPoint2 ScreenCoord() { return scrpos;} 
		Point3 UVW(int chan) { return Point3(uv.x, uv.y, 0.0f); }
		Point3 DUVW(int chan) { return Point3(duv.x, duv.y, 0.0f);  }
		void DPdUVW(Point3 dP[3], int chan) {}  // dont need bump vectors
		void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE) {}   // returns Background color, bg transparency
		
		float Curve() { return curve; }

		// Transform to and from internal space
		Point3 PointTo(const Point3& p, RefFrame ito) { return p; } 
		Point3 PointFrom(const Point3& p, RefFrame ifrom) { return p; } 
		Point3 VectorTo(const Point3& p, RefFrame ito) { return p; } 
		Point3 VectorFrom(const Point3& p, RefFrame ifrom) { return p; } 
		SCLight(){ doMaps = TRUE; 	curve = 0.0f;		}
	};



//--- Directional Light ------------------------------------------------

class DirLight : public BaseObjLight {
	Point3 lightDir;  // light direction in render space	
	ShadowGenerator *shadGen;
	BOOL rect;
	BOOL overshoot,projector;
	BOOL shadow, doShadows, shadowRay;
	int shadsize;
	float hotsz, fallsz, fallsq;	
	float xscale, yscale, sz2, curve;
	float out_range,in_range, range_span;
	float hotpct,ihotpct;
	float aspect;
	float sw2, sh2;
	Texmap* projMap;
	public:
		DirLight(INode *inode);
		~DirLight() {
			FreeShadGens();
			}
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);
		int UpdateViewDepParams(const Matrix3& worldToCam);
		void FreeShadGens() {	if (shadGen) { shadGen->DeleteThis();	shadGen = NULL;   }		}
		void FreeShadGenBuffers() {	if (shadGen)  shadGen->FreeBuffer();  		}
		BOOL Illuminate(ShadeContext &sc, Point3& normal, Color& color, Point3 &dir, float& dot_nl, float &diffuseCoef);
		Color AttenuateIllum( ShadeContext& sc,	Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges);		
		BOOL IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges);
		float SampleMap(ShadeContext& sc, Point3 pin, Point3 norm, Point3 plt, Color& lcol, float &shadCol);
		AColor SampleProjMap(ShadeContext &sc, Point3 plt, Point3 dp, float x, float y, Texmap *map);
		float RectAtten(float px, float py);
		float CircAtten(float px, float py);
		BOOL UseAtten() {return FALSE;}
		int LightType() { return DIR_LIGHT; }
	};

DirLight::DirLight(INode *inode) : BaseObjLight(inode) {
#ifndef DESIGN_VER
	shadow = FALSE;
#else
	shadow = TRUE;
#endif
	rect = overshoot = shadowRay =  FALSE; 
	projMap = NULL;
	shadGen = NULL;
	if(gl->GetShadow()) 
		shadGen = gl->ActiveShadowType()->CreateShadowGenerator(gl, this, SHAD_PARALLEL); 
	}

int DirLight::Update(TimeValue t, const RendContext &rc, 
		RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged) {
	int res = 1;
	BaseObjLight::Update(t,rc,rgc,shadows,shadowGeomChanged);
	hotsz = ls.hotsize;
	fallsz = ls.fallsize;
	fallsq = fallsz*fallsz;
	hotpct = ls.hotsize/ls.fallsize;
	ihotpct = 1.0f - hotpct;

	ObjectState os = inode->EvalWorldState(t);
	LightObject* lob = (LightObject *)os.obj;		
	assert(os.obj->SuperClassID()==LIGHT_CLASS_ID);
	GeneralLight* gl = (lob->GetInterface(I_MAXSCRIPTPLUGIN) != NULL) ? (GeneralLight*)lob->GetReference(0) : (GeneralLight*)lob;  // JBW 4/7/99

	//bank = ls.bank;
	rect = gl->GetSpotShape()==RECT_LIGHT?1:0;
	overshoot = gl->GetOvershoot();
	shadow = gl->GetShadow()&&shadows;	
	if (ambOnly) shadow = FALSE;
	shadowRay = gl->GetShadowType();
	projector =  gl->GetProjector();

	aspect = rect?gl->GetAspect(t):1.0f;
//	shadsize = gl->GetMapSize(t);
	shadsize = gl->ActiveShadowType()->MapSize(t);
	if (shadsize<=0) shadsize = 10;
	sz2 = .5f*(float)shadsize;
	xscale =  sz2/fallsz;
	curve =(float)fabs(1.0f/xscale); 
	yscale = -xscale*aspect;
	sw2  = fallsz;
	sh2  = sw2/aspect;

	if (projector) {
		projMap = gl->GetProjMap();
		}
	if (shadow) {
		if (dontNeedShadBuf) {
			FreeShadGenBuffers();
			}
		else {
			if (shadowGeomChanged) {
				float clipDist = ls.useAtten? ls.attenEnd : DONT_CLIP;

				//NEWSHAD
				shadGen->Update(t,rc,rgc,lightToWorld, aspect,fallsz,clipDist);
				}

			}
		}
	if (dontNeedShadBuf) shadow = FALSE;
//	doShadows = shadow&&(shadBuf||rayBuf);	
	doShadows = shadow&&shadGen;	
	return res;
	};

int DirLight::UpdateViewDepParams(const Matrix3& worldToCam) {
	BaseObjLight::UpdateViewDepParams(worldToCam);
	// The light by convention shines down the negative Z axis, so
	// the lightDir is the positive Z axis
	lightDir = FNormalize(lightToCam.GetRow(2));

	// NEWSHAD
	if (shadGen) 
		shadGen->UpdateViewDepParams(worldToCam);
	return 1;
	}

#define Dx (ray.dir.x)
#define Dy (ray.dir.y)
#define Dz (ray.dir.z)
#define Px (ray.p.x)
#define Py (ray.p.y)
#define Pz (ray.p.z)

#define DIR(i) ray.dir[i]
#define POS(i)   ray.p[i]
#define BIGFLOAT 1.0e15f
 
BOOL IntersectBox(Ray &ray,float &t0,float &t1, Box3& b) {
	float q0 = -BIGFLOAT;
	float q1 =  BIGFLOAT;
	for (int i=0; i<3; i++) {
		if (DIR(i)==0.0f) {	// parallel to this pair of planes
			if ( POS(i)<b.pmin[i] || POS(i)>b.pmax[i] ) return FALSE;
			}
		else {
			float r0 = (b.pmin[i]-POS(i))/DIR(i);
			float r1 = (b.pmax[i]-POS(i))/DIR(i);
			if (r0 > r1) {float temp=r0; r0=r1; r1=temp;}
			if (r0 > q0) q0 = r0;					
			if (r1 < q1) q1 = r1;					
			if (q0>q1) return FALSE;   // missed box
			if (q1<0.0f) return FALSE; // Box is behind ray origin.
			}
		}
	t0 = q0;
	t1 = q1;
	return TRUE;
	}

BOOL IntersectCyl(Ray &ray,float &t0,float &t1, float Rsq) {
	float A,B,C;
	A = (Dx*Dx + Dy*Dy);
	B = 2.0f*(Dx*Px + Dy*Py);
	C = Px*Px + Py*Py - Rsq;
	if (fabs(A)<float(1.0e-30))
		return FALSE;
	float d = B*B-4.0f*A*C;
	if (d<0.0f) 
		return FALSE;
	float s = (float)sqrt(d);
	t0 = (-B + s)/(2.0f*A);
	t1 = (-B - s)/(2.0f*A);
	if (t0 > t1) {float temp=t0; t0=t1; t1=temp;}

	int behind = 0;
	if (Pz + t0*Dz > 0.0f) behind = 1;
	if (Pz + t1*Dz > 0.0f) behind +=2;
	switch (behind) { 
		case 0: break;
		case 1: t0 = -Pz/Dz; 	break;  // intersect with plane z==0
		case 2: t1 = -Pz/Dz; 	break;	// intersect with plane z==0
		case 3: return FALSE;
		}
	return TRUE;
	}

BOOL DirLight::IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges) {
//	if (overshoot) return FALSE;
	if (rect) {
		Box3 b;
		float sx = fallsz;
		float sy = fallsz/aspect;
		b.pmin = Point3( -sx, -sy, -BIGFLOAT);
		b.pmax = Point3(  sx,  sy, 0.0f);
		return IntersectBox(ray,t0,t1,b);
		}
	else return IntersectCyl(ray,t0,t1,fallsq);
	}

float DirLight::RectAtten(float px, float py) {
	float u;
	float ux = (float)fabs(px)/sw2;
	float uy = (float)fabs(py)/sh2;
	if (ux>1.0f||uy>1.0f) 
		return 0.0f;
	int inflag = 0;
	if(ux>hotpct) { inflag  = 1; ux = (ux-hotpct)/ihotpct; }
	if(uy>hotpct) {	inflag |= 2; uy = (uy-hotpct)/ihotpct; }
	switch(inflag) {
		case 1:	u = 1.0f-ux;			break;
		case 2:	u = 1.0f-uy;			break;
		case 3:	u = (1.0f-ux)*(1.0f-uy); break;
		case 0: return 1.0f;
		}
	return  u*u*(3.0f-2.0f*u);  
	}


float DirLight::CircAtten(float px, float py) {
	float dsq = px*px + py*py;
	if (dsq > fallsq) 
		return 0.0f;
	float d = (float) sqrt(dsq);
	if ( d > hotsz ) {
		float u = (fallsz - d)/(fallsz-hotsz);
		return u*u*(3.0f-2.0f*u); 
		}
	else return 1.0f;
	}

Color DirLight::AttenuateIllum(
		ShadeContext& sc,
		Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges)
	{		
	float atten = 1.0f;

	/* Handle light distance attenuation */
	distAtten = 1.0f;
	float dist = -p.z;

	if(ls.useNearAtten) {
	   	if(dist<ranges.aNearStart) { // beyond range
			distAtten = 0.0f;
	   		return Color(0.0f,0.0f,0.0f);
			}
		if(dist<ranges.aNearEnd)	{
			// in attenuated range
			float u = (dist - ranges.aNearStart)/(ranges.aNearEnd-ranges.aNearStart);
			atten = distAtten = u*u*(3-2*u);  // smooth cubic curve 
			}
		}
	if (ls.useAtten) {
	   	if(dist>ranges.aEnd) {		// Beyond range 
			distAtten = 0.0f;
	   		return Color(0.0f,0.0f,0.0f);
			}
		else if(dist>ranges.aStart){
			// in attenuated range
			float u = (ranges.aEnd-dist)/(ranges.aEnd-ranges.aStart);
			atten = distAtten *= u*u*(3-2*u);  /* smooth cubic curve */
			}
		}

//	atten = Decay(atten,dist,ranges.aNearEnd);
	atten = Decay(atten,dist, ranges.decayRadius);

	if (overshoot) {
		if (!(doShadows||projMap)) 
			return colStep;
		}
	else {
		if (p.z > 0.0f) 
			return Color(0,0,0); // behind light
		atten *= rect ?  RectAtten(p.x,p.y) : CircAtten(p.x,p.y);
		}

	float x,y;	

	x = sz2 + xscale*p.x;
	y = sz2 + yscale*p.y;				
	
	if (sc.shadow && shadow && shadGen) {
		if (filt==1) {						
			atten *= shadGen->FiltSample(int(x), int(y), p.z, filt);
			if (atten==0.0f) return Color(0.0f,0.0f,0.0f);
		} else if (filt==2) {
			Point3 p2 = p+dp;			
			int x2 = int(sz2 + xscale*p2.x);
			int y2 = int(sz2 + yscale*p2.y);
			atten *= shadGen->LineSample(
				int(x), int(y), p.z, x2, y2, p2.z);
							
			if (atten==0.0f) return Color(0.0f,0.0f,0.0f);
		} else if (filt==3) {
			// Use sample range
			atten *= shadGen->Sample(sc,x,y,p.z,0.0f,0.0f);
		} else {		
			if (!shadGen->QuickSample(int(x), int(y), p.z))
				return Color(0,0,0);
			}
		}

	if (projMap) {
		AColor pc = SampleProjMap(sc,p, dp, x,y,projMap);
		return atten*colStep*Color(pc.r,pc.g,pc.b);
		}
	
	return colStep * atten;
	}

static Color whitecol(1.0f,1.0f,1.0f);

BOOL DirLight::Illuminate(ShadeContext &sc, Point3& normal, Color& color, Point3 &dir, float& dot_nl, float &diffuseCoef) {
	float dot, atten;

	if (ambOnly) {
		dot = 1.0f;
		}
	else {
		dot = DotProd(normal,lightDir);
		if (dot<0.0f) 
			return 0;
		}

	color = intensCol;
	// find distance from the light axis:
	Point3 p = sc.P();
	Point3 q = camToLight*p; 

	atten = 1.0f;
	float dist = -q.z;

	// Handle light distance attenuation 
	if(ls.useNearAtten) {
	   	if(dist<ls.nearAttenStart)		// Beyond range 
	   		return 0;
		if(dist<ls.nearAttenEnd)	{
			// in attenuated range
			float u = (dist - ls.nearAttenStart)/(ls.nearAttenEnd-ls.nearAttenStart);
			atten = u*u*(3-2*u);  /* smooth cubic curve */
			}
		}
	if (ls.useAtten) {
	   	if(dist>ls.attenEnd)		/* Beyond range */
	   		return 0;
		if(dist>ls.attenStart)	{
			/* Outside full-intensity range */
			float u = (ls.attenEnd-dist)/(ls.attenEnd-ls.attenStart);
			atten *= u*u*(3-2*u);  /* smooth cubic curve */
			}
		}

//	atten = Decay(atten,dist,ls.nearAttenEnd);
	atten = Decay(atten,dist, decayRadius);

	if (overshoot) {
		if (!(doShadows||projMap)) {
			diffuseCoef = ContrastFunc(dot_nl = dot);
			dir = lightDir;
			if (atten!=1.0f) 
				color *= atten;
			return 1;
			}
		}
	else {
		if (q.z>=0.0f) return 0;
		atten*= rect? RectAtten(q.x, q.y) : CircAtten(q.x,q.y);
		if (atten==0.0f) return 0;
		}

	IPoint2 sp = sc.ScreenCoord();

	float shadAtten=1.0f;
	if (doShadows||projMap) {
		atten *= SampleMap(sc, p, normal,q, color,shadAtten);
		}
	if (atten==0.0f) return 0;


	// ATMOSPHERIC SHADOWS
	if (atmosShadows)
		ApplyAtmosShadows(sc,lightPos,color);

	dir = lightDir;
	diffuseCoef = ContrastFunc(dot_nl = dot);
	if (shadAtten!=1.0f) {
		Color scol = shadColor;
		if (shadProjMap) {
			float x =  xscale*q.x + sz2;
			float y =  yscale*q.y + sz2;
			scol = SampleProjMap(sc,p,sc.DP(),x,y,shadProjMap);
			}
		ApplyShadowColor(color, shadAtten,scol);
		}
	if (atten!=1.0f) 
		color *= atten;
	return 1;
	}


AColor DirLight::SampleProjMap(ShadeContext &sc,  Point3 plt, Point3 dp, float x, float y, Texmap* map) {
	SCLight sclight;
	float ifs = 1.0f/(float)shadsize;
	sclight.origsc = &sc;
	sclight.projType = 1; // parallel
	sclight.curtime = sc.CurTime();;
	sclight.curve = curve; 
	sclight.ltPos = plt;
	sclight.view = FNormalize(Point3(plt.x, plt.y, 0.0f));
	sclight.uv.x = x*ifs;			
	sclight.uv.y = 1.0f-y*ifs;			
	sclight.uv.x = x*ifs;			
	sclight.uv.y = 1.0f-y*ifs;			
	sclight.scrpos.x = (int)(x+0.5);
	sclight.scrpos.y = (int)(y+0.5);
	sclight.filterMaps = sc.filterMaps;
	sclight.mtlNum  = sc.mtlNum;
	sclight.globContext = sc.globContext;

	// antialiasing for 2D textures:
	// how big is the pixel in terms of 3D space:
	float d = MaxAbs(dp.x,dp.y,dp.z);
	sclight.duv.x = sclight.duv.y = d*ifs*xscale;

	// antialiasing forg for 3D textures: TBD

	return map->EvalColor(sclight);
	}

float DirLight::SampleMap(ShadeContext& sc, Point3 pin, Point3 norm, Point3 plt, Color& lcol, float &shadAtten) {
	float mx,my,x,y,atten;
	Point3 n;

	atten = 1.0f;
	mx =  xscale*plt.x;
	my =  yscale*plt.y;

	// If it falls outside the rectangle, bail out 
	if ((float)fabs(mx)>sz2 || (float)fabs(my)>sz2)	{
		if (overshoot) return(1.0f);	// No attenuation 
		else return(0.0f);
		}

	x = sz2 + mx;
	y = sz2 + my;

	if (doShadows&&sc.shadow) {
		if (isDefaultShadowMap) {
			Point3 n = VectorTransform(camToLight,norm);
			if (n.z!=0.0f) {
				shadAtten = shadGen->Sample(sc, x, y, plt.z, -n.x/(n.z*xscale), -n.y/(n.z*yscale));
				if (shadAtten==0.0f&&!doingShadColor) return atten;
				}
			}
		else {
			shadAtten = shadGen->Sample(sc,norm,lcol);
			if (shadAtten==0.0f&&!doingShadColor) return atten;
			}
		}
	if (projMap) 
		lcol *= SampleProjMap(sc,plt,sc.DP(),x,y,projMap);
	return(atten);
	}


//--- Spot Light -------------------------------------------------------
class SpotLight: public BaseObjLight {	
	friend class SCLight;
	Point3 lightDir;  // light direction in render space
	ShadowGenerator *shadGen;
	BOOL rect;
	BOOL overshoot,projector, shadowRay;
	BOOL shadow;
	int shadsize;
	float hot_cos, fall_cos, fall_tan, fall_sin;
	float hotpct, ihotpct;	
	float zfac, xscale,yscale, fov, sz2, curve;
	float out_range,in_range, range_span;
	Point2 rectv0, rectv1;
	Texmap* projMap;
	public:
		SpotLight(INode *inode);
		~SpotLight() {	FreeShadGens();		}
		void FreeShadGens() {	if (shadGen) { shadGen->DeleteThis();	shadGen = NULL;   }		}
		void FreeShadGenBuffers() {		if (shadGen)  shadGen->FreeBuffer(); 	}
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);
		int UpdateViewDepParams(const Matrix3& worldToCam);
		BOOL Illuminate(ShadeContext &sc, Point3& normal, Color& color, Point3 &dir, float& dot_nl, float &diffuseCoef);
		float SampleMap(ShadeContext& sc, Point3 pin, Point3 norm, Point3 plt, Color& lcol, float &shadAtten);
		BOOL IntersectCone(Ray &ray,float tanAng,float &t0,float &t1);
		BOOL IntersectRectCone(Ray &ray,float &t0,float &t1);
		BOOL IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges);
		Color AttenuateIllum(ShadeContext& sc, Point3 p, Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges);		
		AColor SampleProjMap(ShadeContext& sc, Point3 plt, Point3 dp, float x, float y, Texmap *map);
		BOOL UseAtten() {return ls.useAtten;}
		BOOL IsFacingLight(Point3 &dir);
		int LightType() { return FSPOT_LIGHT; }
	};

SpotLight::SpotLight(INode *inode):BaseObjLight(inode) {
#ifndef DESIGN_VER
	shadow = FALSE;
#else
	shadow = TRUE;
#endif
	rect = overshoot =  shadowRay = FALSE; 
	shadGen = NULL;
	if(gl->GetShadow()) 
		shadGen = gl->ActiveShadowType()->CreateShadowGenerator(gl, this, 0); 
	projMap = NULL;
	}


BOOL SpotLight::IntersectCone(
		Ray &ray,float tanAng,float &t0,float &t1)
	{
#define FLOAT double
	FLOAT A, Dx2, Dy2, Dz2, den, k, root, z0, z1;

	Dx2 = Dx*Dx;
	Dy2 = Dy*Dy;
	Dz2 = Dz*Dz;
	A   = tanAng*tanAng;	

	den = 2.0f*(Dx2+Dy2-A*Dz2);
	if (den==0.0f) return FALSE;

	k = -2.0f*Dx*Px - 2.0f*Dy*Py + 2.0f*A*Dz*Pz;
	root = k*k - 2.0f*den*(Px*Px+Py*Py-A*Pz*Pz);
	if (root<0.0f) return FALSE;
	root = (float)sqrt(root);

	t0 = (float)((k-root)/den);
	t1 = (float)((k+root)/den);
	if (t0 > t1) {float temp=t0;t0=t1;t1=temp;}

	// t0 and t1 may be the iintersection with the reflected cone in the
	// positive Z direction.
	z0 = ray.p.z + ray.dir.z*t0;
	z1 = ray.p.z + ray.dir.z*t1;
	BOOL out0 = z0 > 0.0f ? TRUE : FALSE;
	BOOL out1 = z1 > 0.0f ? TRUE : FALSE;
	if (out0 && out1) {
		return FALSE;	
		}

	if (out0) {			  
		// Must be in the reflected cone, shooting out and hitting the real cone.
		
		// Do an extra check to make sure we really are inside the
		// cone and it's not just round-off.
		if (t0>0) {
			FLOAT l = (Px*Px + Py*Py)/A;
			if (Pz*Pz < l) return FALSE;
			}

		t0 = t1;
		t1 = float(1.0E30);
		}

	if (out1) {
		// Must be inside the cone, shooting out and hitting the reflected cone.
		t1 = t0;
		t0 = 0.0f;
		}
		
	return TRUE;
	}


static BOOL IntersectConeSide(
		Ray &ray,int X, int Y,
		float cs, float sn, float tn,		
		float &t)
	{
	Point2 p(ray.p[X],ray.p.z), v(cs,sn), c(ray.dir[X],ray.dir.z);
	float cv = -c.DotProd(v);
	if (cv!=0.0f) {
		float pv = p.DotProd(v);
		t = pv/cv;
		if (t>0.0f) {
			Point3 pt = ray.p + ray.dir*t;
			if (pt.z<0.0f) {
				if ((float)fabs(pt[Y]/pt.z) <= tn) {
					return TRUE;
					}
				}
			}
		}
	return FALSE;
	}

BOOL SpotLight::IntersectRectCone(
		Ray &ray,float &t0,float &t1)
	{	
	float sn0 = rectv0.y;
	float sn1 = rectv1.y;
	float cs0 = rectv0.x;
	float cs1 = rectv1.x;
	float tn0 = (float)fabs(sn0/cs0);
	float tn1 = (float)fabs(sn1/cs1);
	int hit = 0;
	float t;
	BOOL in = FALSE;
	
	if (IntersectConeSide(ray, 0, 1, cs0, sn0, tn1, t)) {		
		t0 = t1 = t;
		hit++;
		}

	if (IntersectConeSide(ray, 1, 0, cs1, sn1, tn0, t)) {
		if (hit) {
			if (t<t0) t0 = t;
			if (t>t1) t1 = t;
		} else {
			t0 = t1 = t;
			}
		hit++;
		}

	if (IntersectConeSide(ray, 0, 1, -cs0, sn0, tn1, t)) {
		if (hit) {
			if (t<t0) t0 = t;
			if (t>t1) t1 = t;
		} else {
			t0 = t1 = t;
			}
		hit++;
		}

	if (IntersectConeSide(ray, 1, 0, cs1, -sn1, tn0, t)) {
		if (hit) {
			if (t<t0) t0 = t;
			if (t>t1) t1 = t;
		} else {
			t0 = t1 = t;
			}
		hit++;
		}
	
	float xz = float(fabs(ray.p.x)/fabs(ray.p.z));
	float yz = float(fabs(ray.p.y)/fabs(ray.p.z));
	if (ray.p.z < 0.0f && xz<tn0 && yz<tn1) {
		in = TRUE;
		}

	if (hit == 0) {
		if (in) {
			t0 = 0.0f;
			t1 = float(1.0E30);
			return TRUE;
		} else {
			return FALSE;
			}
		}

	if (hit == 1) {
		if (in) t0 = 0.0f;			
		else t1 = float(1.0E30);			
		}
	
	return TRUE;
	}

#undef Dx
#undef Dy
#undef Dz
#undef Px
#undef Py
#undef Pz

BOOL SpotLight::IntersectRay(Ray &ray,float &t0,float &t1, AttenRanges &ranges)
	{
	if (rect) return IntersectRectCone(ray,t0,t1);
	else return IntersectCone(ray,fall_tan,t0,t1);	
	}

BOOL SpotLight::IsFacingLight(Point3 &dir)
	{
	return dir.z>0.0f;
	}

Color SpotLight::AttenuateIllum(
		ShadeContext& sc,
		Point3 p,Color &colStep,Point3 &dp,int filt, float ldp, float &distAtten, AttenRanges &ranges)
	{		
	float mx,my,x,y;	
	float atten = 1.0f, cosang;
	float lv = FLength(p);
	if (lv==0.0f) 
		return colStep;	

	// Handle light distance attenuation 
	distAtten = 1.0f;
	if(ls.useNearAtten) {
	   	if(lv<ranges.aNearStart) { // beyond range
			distAtten = 0.0f;
	   		return Color(0.0f,0.0f,0.0f);
			}
		if(lv<ranges.aNearEnd)	{
			// in attenuated range
			float u = (lv - ranges.aNearStart)/(ranges.aNearEnd-ranges.aNearStart);
			atten = distAtten = u*u*(3-2*u);  // smooth cubic curve 
			}
		}
	if(ls.useAtten) {		
		if(lv>ranges.aEnd) {		// Beyond range
			distAtten = 0.0f;
			return Color(0,0,0);
			}
		if(lv>ranges.aStart)	{
			// in attenuated range
			float u = (ranges.aEnd-lv)/(ranges.aEnd-ranges.aStart);
			atten = distAtten *= u*u*(3-2*u); /* smooth cubic curve */			  
			}
		}

//	atten = Decay(atten, lv, ranges.aNearEnd);
	atten = Decay(atten, lv, ranges.decayRadius);
	
	cosang = (float)fabs(p.z/lv);
	if ((!rect)&&(!overshoot) && (cosang<hot_cos) && (hot_cos!=fall_cos)) {
		if (cosang<fall_cos) {
			// RB: point is outside of falloff cone
			return Color(0.0f,0.0f,0.0f);
			}
		float u = (cosang-fall_cos)/(hot_cos-fall_cos);
		atten *= u*u*(3.0f-2.0f*u);  /* smooth cubic curve */
		}
	
	// ---DS -- 4/8/96 added ||projMap

	if ((p.z<0.0f && (sc.shadow && shadow)) || rect || projMap) { 
		mx =  xscale*p.x/p.z;
		my =  yscale*p.y/p.z;
		x = sz2 + mx;
		y = sz2 + my;				
				
		if (sc.shadow && shadow) {
			if (filt) {
				if (filt==1) {
					atten *= shadGen->FiltSample(int(x), int(y), p.z, filt);
					} 
				else if (filt==2) {
					Point3 p2 = p+dp;
					if (p2.z<0.0f) {
						int x2 = int(sz2 + xscale*p2.x/p2.z);
						int y2 = int(sz2 + yscale*p2.y/p2.z);
						atten *= shadGen->LineSample(
							int(x), int(y), p.z, x2, y2,p2.z);
						}
					}
				else if (filt==3) {
					// Use sample range
					atten *= shadGen->Sample(sc,x,y,p.z,0.0f,0.0f);
					}
				if (atten==0.0f) return Color(0.0f,0.0f,0.0f);
			} else {		
				if (!shadGen->QuickSample(int(x), int(y), p.z)) {
					return Color(0.0f,0.0f,0.0f);
					}
				}
			}		
		if (projMap) {
			AColor pc = SampleProjMap(sc,p,dp,x,y, projMap);
			return atten*colStep*Color(pc.r,pc.g,pc.b);
			}


		if (rect && !(overshoot)) {
			float u;
			float ux = (float)fabs(mx)/sz2;
			float uy = (float)fabs(my)/sz2;
			if (ux>1.0f || uy>1.0f) {
				atten = 0.0f;
				goto skipAtten;
				}
			int inflag = 0;
			if(ux>hotpct) {
				inflag = 1;	
				ux=(ux-hotpct)/ihotpct;		
				}
			if(uy>hotpct) {	
				inflag |= 2;
				uy=(uy-hotpct)/ihotpct;
				}
			switch(inflag) {
				case 1:	u = 1.0f-ux;			break;
				case 2:	u = 1.0f-uy;			break;
				case 3:	u = (1.0f-ux)*(1.0f-uy); break;
				case 0:	goto skipAtten;
				}
			atten *= u*u*(3.0f-2.0f*u);  /* smooth cubic curve */
			}
		
		}
	

skipAtten:
	return colStep * atten;
	}

#define MAX(a,b) (((a)>(b))?(a):(b))

int SpotLight::Update(TimeValue t, const RendContext &rc,
		RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged) {

	int res = 1;
	BaseObjLight::Update(t,rc,rgc,shadows, shadowGeomChanged);

	float hs = DegToRad(ls.hotsize);
	float fs = DegToRad(ls.fallsize);
	fall_tan = (float)tan(fs/2.0f);
	hot_cos = (float)cos(hs/2.0f);
	fall_cos =(float)cos(fs/2.0f);
	fall_sin = (float)sin(fs/2.0f);
	hotpct = ls.hotsize/ls.fallsize;
	ihotpct = 1.0f - hotpct;		

	ObjectState os = inode->EvalWorldState(t);
	LightObject* lob = (LightObject *)os.obj;		
	assert(os.obj->SuperClassID()==LIGHT_CLASS_ID);
	GeneralLight* gl = (lob->GetInterface(I_MAXSCRIPTPLUGIN) != NULL) ? (GeneralLight*)lob->GetReference(0) : (GeneralLight*)lob;  // JBW 4/7/99

	//bank = ls.bank;
	rect = gl->GetSpotShape()==RECT_LIGHT?1:0;
	overshoot = gl->GetOvershoot();
	shadow = gl->GetShadow()&shadows;	
	if (ambOnly) shadow = FALSE;
	shadowRay = gl->GetShadowType();
	projector =  gl->GetProjector();
	fov = MAX(fs,hs);

	float aspect = rect?gl->GetAspect(t):1.0f;
//	shadsize = gl->GetMapSize(t);
	shadsize = gl->ActiveShadowType()->MapSize(t);
	if (shadsize<=0) shadsize = 10;
	sz2 = .5f*(float)shadsize;
	 
	fov = 2.0f* (float)atan(tan(fov*0.5f)*sqrt(aspect));
	zfac = -sz2 /(float)tan(0.5*(double)fov);
	xscale = zfac;								
	yscale = -zfac*aspect;
	curve =(float)fabs(1.0f/xscale); 

	//rectv0.y = float(tan(fs*0.5) * sqrt(aspect));
	//rectv1.y = rectv0.y/aspect;
	rectv0.y = fall_sin * (float)sqrt(aspect);
	rectv1.y = fall_sin / (float)sqrt(aspect);

	rectv0.x = rectv1.x = fall_cos;
	rectv0 = Normalize(rectv0);
	rectv1 = Normalize(rectv1);

//	ULONG flags = gl->GetAbsMapBias()?SHAD_BIAS_ABSOLUTE:0;
	if (projector) {
		projMap = gl->GetProjMap();
		}
	if (shadow) {	
		if (dontNeedShadBuf) {
			FreeShadGenBuffers();
			}
		else {
			if (shadowGeomChanged) {
				float clipDist = ls.useAtten? ls.attenEnd : DONT_CLIP;
				shadGen->Update(t,rc,rgc,lightToWorld,aspect,fov,clipDist);
				}
			}
		}
	shadow = shadow&&shadGen;	
	if (dontNeedShadBuf) shadow = FALSE;
	return res;
	}

int  SpotLight::UpdateViewDepParams(const Matrix3& worldToCam) {
	BaseObjLight::UpdateViewDepParams(worldToCam);
	// get light direction in cam space
	lightDir = -FNormalize(lightToCam.GetRow(2));
	if (shadGen)
		shadGen->UpdateViewDepParams(worldToCam);
	return 1;
	}

static Color gray(.5f,.5f,.5f);

BOOL SpotLight::Illuminate(ShadeContext &sc, Point3& normal, Color& color, 
		Point3 &dir, float& dot_nl, float &diffuseCoef) {
	/* SPOTlight : compute light value */
	float atten,angle,conelimit,dist;
	Point3 p = sc.P();
	Point3 L = lightPos-p;  // vector from light to p in camera space
	Point3 plt,LL;

	if (!ambOnly) {
		// quick test for light behind surface
		if (DotProd(normal,L)<=0.0f)	
			return 0;
		}
	plt = camToLight * p;
	dist = FLength(plt);
	if (dist==0.0f) return 0;
	LL = -plt/dist;  
	atten = 1.0f;

	// Handle light distance attenuation 
	if(ls.useNearAtten) {
	   	if(dist<ls.nearAttenStart)		// Beyond range 
	   		return 0;
		if(dist<ls.nearAttenEnd)	{
			// in attenuated range
			float u = (dist - ls.nearAttenStart)/(ls.nearAttenEnd-ls.nearAttenStart);
			atten = u*u*(3-2*u);  /* smooth cubic curve */
			}
		}

	if(ls.useAtten) {
	   	if(dist>ls.attenEnd)		// Beyond range 
	   		return 0;
		if(dist>ls.attenStart)	{
			/* Outside full-intensity range */
			float u = (ls.attenEnd-dist)/(ls.attenEnd-ls.attenStart);
			atten *= u*u*(3-2*u);  // smooth cubic curve 
			}
		}

//	atten = Decay(atten,dist,ls.nearAttenEnd);
	atten = Decay(atten, dist, decayRadius);

	conelimit = rect ? (fall_cos/COS_45_2X) : fall_cos;
	color = intensCol;

	L = FNormalize(L);

	if (ambOnly) {
		dot_nl = diffuseCoef = 1.0f;
		}
	else {
		if (uniformScale) {
			dot_nl = DotProd(normal,L);	
			}
		else {
			Point3	N = FNormalize(VectorTransform(camToLight,normal));
			// Is light is in front of surface? 
			if ((dot_nl= DotProd(N,LL))<=0.0f) 
				return 0;
			}
		diffuseCoef = ContrastFunc(dot_nl);
		}
	float shadAtten = 1.0f;

	// Is point in light cone? 
	if ((angle = LL.z) < conelimit) {
		if (!overshoot)	
			return 0; 
		goto overshoot_bypass;
		}

	if (shadow||rect||projMap) {
		atten *= SampleMap(sc,p,normal,plt,color,shadAtten);
		}
	if((!rect)&&(!overshoot) && (angle < hot_cos)) {
		float u = (angle-fall_cos)/(hot_cos-fall_cos);
		atten *= u*u*(3.0f-2.0f*u);  // smooth cubic curve 
		}								
	overshoot_bypass:
	if (atten==0.0f) 
		return 0;
	dir = L;  // direction in camera space

	// ATMOSPHERIC SHADOWS
	if (atmosShadows)
		ApplyAtmosShadows(sc,lightPos,color);

	if (shadAtten!=1.0f) {
		Color scol = shadColor;
		if (shadProjMap) {
			float x =  xscale*plt.x/plt.z + sz2;
			float y =  yscale*plt.y/plt.z + sz2;
			scol = SampleProjMap(sc,plt,sc.DP(),x,y,shadProjMap);
			}
		ApplyShadowColor(color, shadAtten,scol);
		}
	if (atten!=1.0f) color *= atten;
	return 1;
	}

AColor SpotLight::SampleProjMap(ShadeContext &sc,  Point3 plt, Point3 dp, 
		float x, float y, Texmap *map) {
	SCLight scspot;
	float ifs = 1.0f/(float)shadsize;
	scspot.origsc = &sc;
	scspot.projType = 0; // perspective
	scspot.curtime = sc.CurTime();
	scspot.curve =(float)fabs(1.0f/xscale); 
	scspot.ltPos = plt;
	scspot.view = FNormalize(plt);
	scspot.uv.x = x*ifs;			
	scspot.uv.y = 1.0f-y*ifs;			

	scspot.scrpos.x = (int)(x+0.5);
	scspot.scrpos.y = (int)(y+0.5);
	scspot.filterMaps = sc.filterMaps;
	scspot.mtlNum  = sc.mtlNum;

	// antialiasing for 2D textures:
	float d = MaxAbs(dp.x,dp.y,dp.z);
	if (plt.z==0.0f) plt.z = .00001f;
	scspot.duv.x = scspot.duv.y = xscale*d*ifs/plt.z;

	// antialiasing for 3D textures: TBD
	return map->EvalColor(scspot);
	}

float SpotLight::SampleMap(ShadeContext& sc, Point3 pin, 
		Point3 norm, Point3 plt, Color& lcol, float &shadAtten) {
	float mx,my,x,y,atten;
	Point3 pout,n;
	Color col;
	atten = 1.0f;
	if (plt.z<0.0f) {
		mx =  xscale*plt.x/plt.z;
		my =  yscale*plt.y/plt.z;
		x = sz2 + mx;
		y = sz2 + my;

		/* If it falls outside the rectangle, bail out */
		if ((float)fabs(mx)>sz2 || (float)fabs(my)>sz2)	{
			if(overshoot) return(1.0f);	/* No attenuation */
			else return(0.0f);
			}

		if (sc.shadow&&shadow) {
			if (isDefaultShadowMap) {
				Point3 n = VectorTransform(camToLight,norm);
				float k = plt.z*plt.z/(zfac*DotProd(n,plt));
				shadAtten = shadGen->Sample(sc, x,y, plt.z, -n.x*k, n.y*k);
				if (shadAtten==0.0f) return atten;
				}
			else {
				shadAtten = shadGen->Sample(sc,pin,lcol);
				if (shadAtten==0.0f) return atten;
				}
			}
		
		// Calculate rectangular dropoff if outside the hotspot area 
		if (rect && !(overshoot)) {
			float u;
			float ux = (float)fabs(mx)/sz2;
			float uy = (float)fabs(my)/sz2;
			int inflag = 0;
			if(ux>hotpct) {
				inflag = 1;	
				ux=(ux-hotpct)/ihotpct;		
				}
			if(uy>hotpct) {	
				inflag |= 2;
				uy=(uy-hotpct)/ihotpct;
				}
			switch(inflag) {
				case 1:	u = 1.0f-ux;			break;
				case 2:	u = 1.0f-uy;			break;
				case 3:	u = (1.0f-ux)*(1.0f-uy); break;
				case 0:	goto noAtten;
				}
			atten *= u*u*(3.0f-2.0f*u);  /* smooth cubic curve */

			}
	noAtten:		  
		if(projMap) 
			lcol *= SampleProjMap(sc,plt,sc.DP(),x,y,projMap);
		}
	return(atten);
	}


ObjLightDesc *GeneralLight::CreateLightDesc(INode *n)
	{
	switch (type) {
		case OMNI_LIGHT: 	return new OmniLight(n);
		case DIR_LIGHT:		
		case TDIR_LIGHT:   	return new DirLight(n);
		case FSPOT_LIGHT:	
		case TSPOT_LIGHT:	return new SpotLight(n);
		default:			return NULL;
		}	
	}

#define PLUG_SHADOW_TYPE_CHUNK 5000

//---------------------------------------------------------------------------
// Class IO: The spotlight does the saving and loading of the shadow parameters
// for all the light classes.
IOResult TSpotLightClassDesc::Save(ISave *isave){
//	ULONG nb;
	isave->BeginChunk(PLUG_SHADOW_TYPE_CHUNK);
	isave->EndChunk();
//	isave->BeginChunk(SHADOW_TYPE_CHUNK);
//	isave->Write(&GeneralLight::globShadowType, sizeof(GeneralLight::globShadowType), &nb);
//	isave->EndChunk();
//	isave->BeginChunk(ABS_MAP_BIAS_CHUNK);
//	isave->Write(&GeneralLight::globAbsMapBias, sizeof(GeneralLight::globAbsMapBias), &nb);
//	isave->EndChunk();
//	isave->BeginChunk(MAP_BIAS_CHUNK);
//	isave->Write(&GeneralLight::globMapBias, sizeof(GeneralLight::globMapBias), &nb);
//	isave->EndChunk();
//	isave->BeginChunk(MAP_RANGE_CHUNK);
//	isave->Write(&GeneralLight::globMapRange, sizeof(GeneralLight::globMapRange), &nb);
//	isave->EndChunk();
//	isave->BeginChunk(MAP_SIZE_CHUNK);
//	isave->Write(&GeneralLight::globMapSize, sizeof(GeneralLight::globMapSize), &nb);
//	isave->EndChunk();
//	isave->BeginChunk(RAY_BIAS_CHUNK);
//	isave->Write(&GeneralLight::globRayBias, sizeof(GeneralLight::globRayBias), &nb);
//	isave->EndChunk();
	return IO_OK;
	}

IOResult TSpotLightClassDesc::Load(ILoad *iload){
	ULONG nb;
	IOResult res;
	int hasPlugShadows = 0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PLUG_SHADOW_TYPE_CHUNK:
				hasPlugShadows = TRUE;
				break;
			case SHADOW_TYPE_CHUNK:
				res = iload->Read(&GeneralLight::globShadowType, sizeof(GeneralLight::globShadowType), &nb);
				break;
			case ABS_MAP_BIAS_CHUNK:
				res = iload->Read(&GeneralLight::globAbsMapBias, sizeof(GeneralLight::globAbsMapBias), &nb);
				break;
			case MAP_BIAS_CHUNK:
				res = iload->Read(&GeneralLight::globMapBias, sizeof(GeneralLight::globMapBias), &nb);
				break;
			case MAP_RANGE_CHUNK:
				res = iload->Read(&GeneralLight::globMapRange, sizeof(GeneralLight::globMapRange), &nb);
				break;
			case MAP_SIZE_CHUNK:
				res = iload->Read(&GeneralLight::globMapSize, sizeof(GeneralLight::globMapSize), &nb);
				break;
			case RAY_BIAS_CHUNK:
				res = iload->Read(&GeneralLight::globRayBias, sizeof(GeneralLight::globRayBias), &nb);
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	if (!hasPlugShadows) {
		// Convert global parameters to the new style
		ShadowType *st = (GeneralLight::globShadowType)?
			NewDefaultRayShadowType():NewDefaultShadowMapType();
		st->SetMapRange(TimeValue(0),GeneralLight::globMapRange);
		st->SetMapSize(TimeValue(0),GeneralLight::globMapSize);
		st->SetMapBias(TimeValue(0),GeneralLight::globMapBias);
		st->SetAbsMapBias(TimeValue(0),GeneralLight::globAbsMapBias);
		st->SetRayBias(TimeValue(0),GeneralLight::globRayBias);
		GetCOREInterface()->SetGlobalShadowGenerator(st);
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\gridobj.cpp ===
/**********************************************************************
 *<
	FILE: gridobj.cpp

	DESCRIPTION:  A simple grid object implementation

	CREATED BY: Peter Watje

	HISTORY: Oct 31, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm2.h"
#include "Simpobj.h"
#include "surf_api.h"

#define A_RENDER			A_PLUGIN1
#define PBLOCK_REF_NO	 0


#define GRIDID 0x81f1dfc, 0x77566f65

class GridObject : public SimpleObject2{
	public:
		// Class vars
		static IObjParam *ip;
		int createMeth;
		Point3 crtPos;		
		static float crtWidth, crtHeight, crtLength;
		static BOOL typeinCreate;
		float RenderWidth,RenderLength;

		GridObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_PW_GRID); }

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock


		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID( GRIDID); }  
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		void BuildGridPatch(TimeValue t, PatchMesh &patch);

#ifndef NO_NURBS
		Object *BuildNURBSPlane(TimeValue t);
#endif

		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		BOOL HasUVW() ;
		void SetGenUVW(BOOL sw);

		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

	};				


float GridObject::crtWidth        = 25.0f; 
float GridObject::crtLength       = 25.0f;
BOOL GridObject::typeinCreate       = FALSE;


#define BOTTOMPIV


//--- ClassDescriptor and class vars ---------------------------------

class GridObjClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new GridObject;}
	const TCHAR *	ClassName() { return GetString(IDS_PW_GRID); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(GRIDID); }
	const TCHAR* 	Category() { return GetString(IDS_PW_PRIMITIVES);}	
//	void			ResetClassParams(BOOL fileReset);

	const TCHAR*	InternalName() { return _T("meshGrid"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

	};

static GridObjClassDesc gridObjDesc;

ClassDesc* GetGridobjDesc() { return &gridObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IObjParam *GridObject::ip         = NULL;


//
//
//	Creation method grid_creation_type,


enum {  grid_creation_type,grid_type_in, grid_params };
// grid_creation_type param IDs
enum { grid_create_meth };
// grid_type_in param IDs
enum { grid_ti_pos, grid_ti_length, grid_ti_width};
// grid_param param IDs
enum { grid_length,
	   grid_width,
	   grid_wsegs,
	   grid_lsegs,
	   grid_rsegs,
	   grid_rscale,
	   grid_genuvs,
	   grid_leftover,
	   grid_leftover1,
	 };

// JBW: here are the two static block descriptors.  This form of 
//      descriptor declaration uses a static NParamBlockDesc instance whose constructor
//      uses a varargs technique to walk through all the param definitions.
//      It has the advantage of supporting optional and variable type definitions, 
//      but may generate a tad more code than a simple struct template.  I'd
//      be interested in opinions about this.

//      I'll briefly describe the first definition so you can figure the others.  Note
//      that in certain places where strings are expected, you supply a string resource ID rather than
//      a string at it does the lookup for you as needed.
//
//		line 1: block ID, internal name, local (subanim) name, flags
//																 AUTO_UI here means the rollout will
//																 be automatically created (see BeginEditParams for details)
//      line 2: since AUTO_UI was set, this line gives: 
//				dialog resource ID, rollout title, flag test, appendRollout flags
//		line 3: required info for a parameter:
//				ID, internal name, type, flags, local (subanim) name
//		lines 4-6: optional parameter declaration info.  each line starts with a tag saying what
//              kind of spec it is, in this case default value, value range, and UI info as would
//              normally be in a ParamUIDesc less range & dimension
//	    the param lines are repeated as needed for the number of parameters defined.

// class creation type block
static ParamBlockDesc2 grid_crtype_blk ( grid_creation_type, _T("GridCreationType"), 0, &gridObjDesc, P_CLASS_PARAMS + P_AUTO_UI, 
	//rollout
	IDD_GRIDPARAM1, IDS_PW_CREATIONMETHOD, BEGIN_EDIT_CREATE, 0, NULL,
	// params
	grid_create_meth,  _T("typeinCreationMethod"), 		TYPE_INT, 		0, IDS_PW_CREATIONMETHOD, 	 
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2, IDC_CREATECUBE, IDC_CREATEBOX, 
		end, 
	end
	);

// class type-in block
static ParamBlockDesc2 grid_typein_blk ( grid_type_in, _T("GridTypeIn"),  0, &gridObjDesc, P_CLASS_PARAMS + P_AUTO_UI, 
	//rollout
	IDD_GRIDPARAM3, IDS_PW_KEYBOARDENTRY, BEGIN_EDIT_CREATE, APPENDROLL_CLOSED, NULL,
	// params
	grid_ti_pos, 		_T("typeInPos"), 		TYPE_POINT3, 		0, 	IDS_PW_POS,
		p_default, 		Point3(0.0f,0.0f,0.0f), 
		p_range, 		-99999999.0, 99999999.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_TI_POSX, IDC_TI_POSXSPIN, IDC_TI_POSY, IDC_TI_POSYSPIN, IDC_TI_POSZ, IDC_TI_POSZSPIN, SPIN_AUTOSCALE, 
		end, 
	grid_ti_length, 	_T("typeInLength"), 	TYPE_FLOAT, 		0, 	IDS_PW_LENGTH, 
		p_default, 		25.0, 
		p_range, 		0.0f, 999999999.9f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_LENGTHEDIT, IDC_LENSPINNER, SPIN_AUTOSCALE, 
		end, 
	grid_ti_width, 		_T("typeInWidth"), 		TYPE_FLOAT, 		0, 	IDS_PW_WIDTH, 
		p_default, 		25.0, 
		p_range, 		0.0f, 999999999.9f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_WIDTHEDIT, IDC_WIDTHSPINNER, SPIN_AUTOSCALE, 
		end, 
	end
	);

// JBW: this descriptor defines the main per-instance parameter block.  It is flagged as AUTO_CONSTRUCT which
//      means that the CreateInstance() will automatically create one of these blocks and set it to the reference
//      number given (0 in this case, as seen at the end of the line).

// per instance gridsphere block
static ParamBlockDesc2 grid_param_blk ( grid_params, _T("GridParameters"),  0, &gridObjDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF_NO, 
	//rollout
	IDD_GRIDPARAM2, IDS_PW_PARAMETERS, 0, 0, NULL,
	// params
	grid_length,  _T("length"), 			TYPE_FLOAT, 	P_ANIMATABLE + P_RESET_DEFAULT, 	IDS_PW_LENGTH, 
		p_default, 		0.0,	
		p_ms_default,	25.0,
		p_range, 		0.0f, 999999999.9f, 
		p_dim,			stdWorldDim,
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_LENGTHEDIT, IDC_LENSPINNER, SPIN_AUTOSCALE, 
		end, 
	grid_width,  _T("width"), 			TYPE_FLOAT, 	P_ANIMATABLE + P_RESET_DEFAULT, 	IDS_PW_WIDTH, 
		p_default, 		0.0,	
		p_ms_default,	25.0,
		p_range, 		0.0f, 999999999.9f, 
		p_dim,			stdWorldDim,
		p_ui, 			TYPE_SPINNER, EDITTYPE_UNIVERSE, IDC_WIDTHEDIT, IDC_WIDTHSPINNER, SPIN_AUTOSCALE, 
		end, 
	grid_lsegs, 	_T("lengthsegs"), 			TYPE_INT, 		P_ANIMATABLE, 	IDS_PW_LSEGS, 
		p_default, 		4, 
		p_range, 		1, 1000, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_LSEGS, IDC_LSEGSPIN, SPIN_AUTOSCALE, 
		end, 
	grid_wsegs, 	_T("widthsegs"), 			TYPE_INT, 		P_ANIMATABLE, 	IDS_PW_WSEGS, 
		p_default, 		4, 
		p_range, 		1, 1000, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_WSEGS, IDC_WSEGSPIN, SPIN_AUTOSCALE, 
		end, 

	grid_rsegs, 	_T("density"), 			TYPE_FLOAT, 		P_ANIMATABLE, 	IDS_PW_RSEG, 
		p_default, 		1.0f, 
		p_range, 		1.0f, 9999999.9f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_RENDERSEGEDIT, IDC_RENDERSEGSPINNER, SPIN_AUTOSCALE, 
		end, 

	grid_rscale, 	_T("renderScale"), 			TYPE_FLOAT, 		P_ANIMATABLE, 	IDS_PW_SCALE, 
		p_default, 		1.0f, 
		p_range, 		1.0f, 9999999.9f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SCALEEDIT, IDC_SCALESPINNER, SPIN_AUTOSCALE, 
		end, 

	grid_genuvs, 	_T("mapCoords"), 	TYPE_BOOL, 		0,				IDS_PW_MAPPING,
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_GENTEXTURE, 
		end, 

/*	grid_leftover, 	_T("oldVersionParam"),		TYPE_FLOAT, 0, 	IDS_PW_LEFTOVER, 
		end, 
	grid_leftover1, 	_T("oldVersionParam"),		TYPE_FLOAT, 0, 	IDS_PW_LEFTOVER, 
		end, 
*/

	end
	);


#define PARAMDESC_LENGH 9


ParamBlockDescID griddescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, grid_length },
	{ TYPE_FLOAT, NULL, TRUE, grid_width },
	{ TYPE_FLOAT, NULL, TRUE, -1 }, 
	{ TYPE_INT, NULL, TRUE, grid_wsegs }, 
	{ TYPE_INT, NULL, TRUE, grid_lsegs }, 
	{ TYPE_INT, NULL, TRUE, -1 },
	{ TYPE_INT, NULL, FALSE, grid_genuvs } 
	};

ParamBlockDescID griddescVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, grid_length },
	{ TYPE_FLOAT, NULL, TRUE, grid_width },
	{ TYPE_FLOAT, NULL, FALSE, -1 }, 
	{ TYPE_INT, NULL, TRUE, grid_wsegs }, 
	{ TYPE_INT, NULL, TRUE, grid_lsegs }, 
	{ TYPE_INT, NULL, FALSE, -1 },
	{ TYPE_INT, NULL, FALSE, grid_genuvs }, 
	{ TYPE_INT, NULL, TRUE, grid_rsegs } 
	};

ParamBlockDescID griddescVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, grid_length },
	{ TYPE_FLOAT, NULL, TRUE, grid_width },
	{ TYPE_FLOAT, NULL, FALSE, -1 }, 
	{ TYPE_INT, NULL, TRUE,  grid_wsegs}, 
	{ TYPE_INT, NULL, TRUE, grid_lsegs }, 
	{ TYPE_INT, NULL, FALSE,  -1},
	{ TYPE_INT, NULL, FALSE, grid_genuvs }, 
	{ TYPE_FLOAT, NULL, TRUE, grid_rsegs }, 
	{ TYPE_FLOAT, NULL, TRUE, grid_rscale }, 
	};


#define PBLOCK_LENGTH	9

// Array of old versions
static ParamVersionDesc versions[] = {
 	ParamVersionDesc(griddescVer0,7,1),	
 	ParamVersionDesc(griddescVer1,8,2),	
 	ParamVersionDesc(griddescVer2,9,3),	
	};
#define NUM_OLDVERSIONS	3

//#define CURRENT_VERSION	3
//static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class GridObjTypeInDlgProc : public ParamMap2UserDlgProc {
	public:
		GridObject *ob;

		GridObjTypeInDlgProc(GridObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL GridObjTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock2->SetValue(grid_length,0,grid_typein_blk.GetFloat(grid_ti_length));
						ob->pblock2->SetValue(grid_width,0,grid_typein_blk.GetFloat(grid_ti_width));
						}
					ob->typeinCreate = TRUE;
					ob->crtWidth = grid_typein_blk.GetFloat(grid_ti_width);
					ob->crtLength = grid_typein_blk.GetFloat(grid_ti_length);

					ob->crtPos = grid_typein_blk.GetPoint3(grid_ti_pos);
					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);					
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Box methods -------------------------------


GridObject::GridObject()
	{
//	typeinCreate = FALSE;
	GetGridobjDesc()->MakeAutoParamBlocks(this);
	}



int GridObject::RenderBegin(TimeValue t, ULONG flags)
	{
	SetAFlag(A_RENDER);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;
	}

int GridObject::RenderEnd(TimeValue t)
	{
	ClearAFlag(A_RENDER);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;

	}


void GridObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleObject::BeginEditParams(ip, flags, prev);
	this->ip = ip;
	// throw up all the appropriate auto-rollouts
	gridObjDesc.BeginEditParams(ip, this, flags, prev);
	// install a callback for the type in.
	grid_typein_blk.SetUserDlgProc(new GridObjTypeInDlgProc(this));
	if (typeinCreate)
		{
		pblock2->SetValue(grid_length,0,crtLength);
		pblock2->SetValue(grid_width,0,crtWidth);
		typeinCreate = FALSE;
		}

	Interval ivalid;
	int lsegs, wsegs;
	float rseg;
	pblock2->GetValue(grid_lsegs,ip->GetTime(),lsegs,ivalid);
	pblock2->GetValue(grid_wsegs,ip->GetTime(),wsegs,ivalid);
	pblock2->GetValue(grid_rsegs,ip->GetTime(),rseg,ivalid);

	if (lsegs < 1) lsegs = 1;
	if (wsegs < 1) lsegs = 1;
	if (rseg < 1.0f) rseg = 1.0f;

	int tlsegs = (int) ((float) lsegs * rseg);
	int twsegs = (int) ((float) wsegs * rseg);

	int totalCount = tlsegs*twsegs *2;
	IParamMap2 *ipm = pblock2->GetMap();
	if (ipm)
		{
		HWND hWnd = ipm->GetHWnd();

		TSTR string;
		string.printf("%d",totalCount);
	
		SetDlgItemText(hWnd, IDC_TOTALFACES, string);
		}

	}
		
void GridObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip, flags, next);
	this->ip = NULL;
	// tear down the appropriate auto-rollouts
	gridObjDesc.EndEditParams(ip, this, flags, next);
	}
// vertices ( a b c d ) are in counter clockwise order when viewd from 
// outside the surface unless bias!=0 in which case they are clockwise
static void MakeQuad(int nverts, Face *f, int a, int b , int c , int d, int sg, int bias) {
	int sm = 1;
	assert(a<nverts);
	assert(b<nverts);
	assert(c<nverts);
	assert(d<nverts);
	if (bias) {
		f[0].setVerts( b, a, c);
		f[0].setSmGroup(sm);
		f[0].setEdgeVisFlags(1,0,1);
		f[1].setVerts( d, c, a);
		f[1].setSmGroup(sm);
		f[1].setEdgeVisFlags(1,0,1);
	} else {
		f[0].setVerts( a, b, c);
		f[0].setSmGroup(sm);
		f[0].setEdgeVisFlags(1,1,0);
		f[1].setVerts( c, d, a);
		f[1].setSmGroup(sm);
		f[1].setEdgeVisFlags(1,1,0);
		}
	}


#define POSX 0	// right
#define POSY 1	// back
#define POSZ 2	// top
#define NEGX 3	// left
#define NEGY 4	// front
#define NEGZ 5	// bottom

int griddirection(Point3 *v) {
	Point3 a = v[0]-v[2];
	Point3 b = v[1]-v[0];
	Point3 n = CrossProd(a,b);
	switch(MaxComponent(n)) {
		case 0: return (n.x<0)?NEGX:POSX;
		case 1: return (n.y<0)?NEGY:POSY;
		case 2: return (n.z<0)?NEGZ:POSZ;
		}
	return 0;
	}

// Remap the sub-object material numbers so that the top face is the first one
// The order now is:
// Top / Bottom /  Left/ Right / Front / Back
static int mapDir[6] ={ 3, 5, 0, 2, 4, 1 };

#define MAKE_QUAD(na,nb,nc,nd,sm,b) {MakeQuad(nverts,&(mesh.faces[nf]),na, nb, nc, nd, sm, b);nf+=2;}


BOOL GridObject::HasUVW() { 
     BOOL genUVs;
     Interval v;
     pblock2->GetValue(grid_genuvs, 0, genUVs, v);
     return genUVs; 
}

void GridObject::SetGenUVW(BOOL sw) {  
     if (sw==HasUVW()) return;
     pblock2->SetValue(grid_genuvs,0, sw);				
}



void GridObject::BuildMesh(TimeValue t)
	{
	int ix,iy,iz,nf,kv,mv,nlayer,topStart,midStart;
	int nverts,wsegs,lsegs,hsegs,nv,nextk,nextm,wsp1;
	int nfaces;
	Point3 va,vb,p;
	float l, w, h;
	int genUVs = 1;
	BOOL bias = 0;
	float rscale, rseg;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;	
	pblock2->GetValue(grid_lsegs,t,lsegs,ivalid);
	pblock2->GetValue(grid_wsegs,t,wsegs,ivalid);
	pblock2->GetValue(grid_genuvs,t,genUVs,ivalid);
	pblock2->GetValue(grid_rscale,t,rscale,ivalid);
	pblock2->GetValue(grid_rsegs,t,rseg,ivalid);
	pblock2->GetValue(grid_length,t,l,ivalid);
	pblock2->GetValue(grid_width,t,w,ivalid);

	if (lsegs < 1) lsegs = 1;
	if (wsegs < 1) lsegs = 1;


	bias = 1;
	if (rscale <= 1.0f) rscale = 1.0f;
	if (rseg <= 1.0f) rseg = 1.0f;
//check if rendering and if so scale accordingly	
    if (TestAFlag(A_RENDER))
		{
		lsegs = (int) ((float) lsegs * rseg);
		wsegs = (int) ((float) wsegs * rseg);
		l =  ((float)l * rscale);
		w =  ((float)w * rscale);
		}
	else
		{
		long tlsegs = (long) ((float) lsegs * rseg);
		long twsegs = (long) ((float) wsegs * rseg);

		long totalCount = tlsegs*twsegs *2;
		
		IParamMap2 *ipm = pblock2->GetMap();
		if (ipm)
			{
			HWND hWnd = ipm->GetHWnd();

			TSTR string;
			string.printf("%d",totalCount);

			SetDlgItemText(hWnd, IDC_TOTALFACES, string);
			}

		}

//	LimitValue(lsegs, MIN_SEGMENTS, MAX_SEGMENTS);
//	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
//	LimitValue(hsegs, 0, MAX_SEGMENTS);

	// Number of verts
      // bottom : (lsegs+1)*(wsegs+1)
	  // top    : (lsegs+1)*(wsegs+1)
	  // sides  : (2*lsegs+2*wsegs)*(hsegs-1)

	// Number of rectangular faces.
      // bottom : (lsegs)*(wsegs)
	  // top    : (lsegs)*(wsegs)
	  // sides  : 2*(hsegs*lsegs)+2*(wsegs*lsegs)
	hsegs = 0;
	if (hsegs == 0)
	{

	wsp1 = wsegs + 1;
	nlayer  =  2*(lsegs+wsegs);
	topStart = (lsegs+1)*(wsegs+1);
	midStart = 2*topStart;

	nverts = (lsegs+1)*(wsegs+1);
	nfaces = 2*(lsegs*wsegs + hsegs*lsegs + wsegs*hsegs);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	nv = 0;
	h = 0.0f;
	vb =  Point3(w,l,h)/float(2);   
	va = -vb;

#ifdef BOTTOMPIV
	va.z = float(0);
	vb.z = h;
#endif

	float dx = w/wsegs;
	float dy = l/lsegs;
	float dz = h/hsegs;

	// do bottom vertices.
	p.z = va.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}
	
	nf = 0;

	// do bottom faces.
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+wsegs+1, kv+wsegs+2, kv+1, 1, bias);
			kv++;
			}
		}
	assert(nf==lsegs*wsegs*2);


	if (genUVs) {
		int ls = lsegs+1;
		int ws = wsegs+1;
		int hs = hsegs+1;
		int ntverts = ls*hs + hs*ws + ws*ls ;
		mesh.setNumTVerts( ntverts ) ;
		mesh.setNumTVFaces(nfaces);	
		
		float uoff = 0.0f,voff=0.0f,umult= 1.0f,vmult=1.0f;

		if ((rscale > 1.0f) && (!TestAFlag(A_RENDER)) )

			{
			uoff= ((rscale -1.0f)/2.0f) / (float)rscale ;
			voff= ((rscale -1.0f)/2.0f) / (float)rscale ;
			umult = 1.0f/(float)rscale;
			vmult = 1.0f/(float)rscale;
			}


		int xbase = 0;
		int ybase = ls*hs;
		int zbase = ls*hs + hs*ws;
	
		float dw = 1.0f/float(wsegs);
		float dl = 1.0f/float(lsegs);
//		float dh = 1.0f/float(hsegs);
		float dh = 1.0f;

		if (w==0.0f) w = .0001f;
		if (l==0.0f) l = .0001f;
		if (h==0.0f) h = .0001f;
		float u,v;

		nv = 0;
		v = 0.0f;
		// X axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f; 
			for (iy =0; iy<ls; iy++) {
				mesh.setTVert(nv, u * umult + uoff, v * vmult + voff, 0.0f);
				nv++; u+=dl;
				}
			v += dh;
			}

		v = 0.0f; 
		//Y Axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f;
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u * umult + uoff, v * vmult + voff, 0.0f);
				nv++; u+=dw;
				}
			v += dh;
			}

		v = 0.0f; 
		for (iy =0; iy<ls; iy++) {
			u = 0.0f; 
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u * umult + uoff, v * vmult + voff, 0.0f);
				nv++; u+=dw;
				}
			v += dl;
			}

		assert(nv==ntverts);

		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = griddirection(v);
			int ntv[3];
			for (ix=0; ix<3; ix++) {
				int iu,iv;
				switch(dir) {
					case POSX: case NEGX:
						iu = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f);  
						if (dir==NEGX) iu = lsegs-iu;
						ntv[ix] = (xbase + iv*ls + iu);
						break;
					case POSY: case NEGY:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f); 
						if (dir==POSY) iu = wsegs-iu;
						ntv[ix] = (ybase + iv*ws + iu);
						break;
					case POSZ: case NEGZ:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						if (dir==NEGZ) iu = wsegs-iu;
						ntv[ix] = (zbase + iv*ws + iu);
						break;
					}
			 	}
			assert(ntv[0]<ntverts);
			assert(ntv[1]<ntverts);
			assert(ntv[2]<ntverts);
			
			mesh.tvFace[nf].setTVerts(ntv[0],ntv[1],ntv[2]);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
    else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = griddirection(v);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
 
	mesh.InvalidateGeomCache();


	}
	else
	{
	wsp1 = wsegs + 1;
	nlayer  =  2*(lsegs+wsegs);
	topStart = (lsegs+1)*(wsegs+1);
	midStart = 2*topStart;

	nverts = midStart+nlayer*(hsegs-1);
	nfaces = 4*(lsegs*wsegs + hsegs*lsegs + wsegs*hsegs);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	nv = 0;

	h = 0.0f;
	vb =  Point3(w,l,h)/float(2);   
	va = -vb;

#ifdef BOTTOMPIV
	va.z = float(0);
	vb.z = h;
#endif

	float dx = w/wsegs;
	float dy = l/lsegs;
	float dz = h/hsegs;

	// do bottom vertices.
	p.z = va.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}
	
	nf = 0;

	// do bottom faces.
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+wsegs+1, kv+wsegs+2, kv+1, 1, bias);
			kv++;
			}
		}
	assert(nf==lsegs*wsegs*2);

	// do top vertices.
	p.z = vb.z;
	p.y = va.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = va.x;
		for (ix=0; ix<=wsegs; ix++) {
			mesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}

	// do top faces (lsegs*wsegs);
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1)+topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, kv+wsegs+2,kv+wsegs+1, 2, bias);
			kv++;
			}
		}
	assert(nf==lsegs*wsegs*4);

	// do middle vertices 
	for(iz=1; iz<hsegs; iz++) {
		
		p.z = va.z + dz * iz;

		// front edge
		p.x = va.x;  p.y = va.y;
		for (ix=0; ix<wsegs; ix++) { mesh.setVert(nv++, p);  p.x += dx;	}

		// right edge
		p.x = vb.x;	  p.y = va.y;
		for (iy=0; iy<lsegs; iy++) { mesh.setVert(nv++, p);  p.y += dy;	}

		// back edge
		p.x =  vb.x;  p.y =  vb.y;
		for (ix=0; ix<wsegs; ix++) { mesh.setVert(nv++, p);	 p.x -= dx;	}

		// left edge
		p.x = va.x;  p.y =  vb.y;
		for (iy=0; iy<lsegs; iy++) { mesh.setVert(nv++, p);	 p.y -= dy;	}
		}

	if (hsegs==1) {
		// do LEFT faces -----------------------
		kv = 0;
		mv = topStart;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, mv+1, mv, 5, bias);
			kv++;
			mv++;
			}

		// do RIGHT faces.-----------------------
		kv = wsegs;  
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+wsp1, mv+wsp1, mv, 4, bias);
			kv += wsp1;
			mv += wsp1;
			}	

		// do BACK faces.-----------------------
		kv = topStart - 1;
		mv = midStart - 1;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv-1, mv-1, mv, 5, bias);
			kv --;
			mv --;
			}

		// do LEFT faces.----------------------
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = topStart + kv;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv-wsp1, mv-wsp1, mv, 6, bias);
			kv -= wsp1;
			mv -= wsp1;
			}
		}

	else {
		// do front faces.
		kv = 0;
		mv = midStart;
		for(iz=0; iz<hsegs; iz++) {
			if (iz==hsegs-1) mv = topStart;
			for (ix=0; ix<wsegs; ix++) 
				MAKE_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix, 3, bias);
			kv = mv;
			mv += nlayer;
			}

		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*2);
	 
		// do RIGHT faces.-------------------------
		// RIGHT bottom row:
		kv = wsegs; // into bottom layer. 
		mv = midStart + wsegs; // first layer of mid verts


		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+wsp1, mv+1, mv, 4, bias);
			kv += wsp1;
			mv ++;
			}

		// RIGHT middle part:
		kv = midStart + wsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				MAKE_QUAD(kv+iy, kv+iy+1, mv+iy+1, mv+iy, 4, bias);
				}
			kv += nlayer;
			}

		// RIGHT top row:
		kv = midStart + wsegs + (hsegs-2)*nlayer; 
		mv = topStart + wsegs;
		for (iy=0; iy<lsegs; iy++) {
			MAKE_QUAD(kv, kv+1, mv+wsp1, mv, 4, bias);
			mv += wsp1;
			kv++;
			}
		
		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*2 + lsegs*hsegs*2);

		// do BACK faces. ---------------------
		// BACK bottom row:
		kv = topStart - 1;
		mv = midStart + wsegs + lsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv-1, mv+1, mv, 5, bias);
			kv --;
			mv ++;
			}

		// BACK middle part:
		kv = midStart + wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (ix=0; ix<wsegs; ix++) {
				MAKE_QUAD(kv+ix, kv+ix+1, mv+ix+1, mv+ix, 5, bias);
				}
			kv += nlayer;
			}

		// BACK top row:
		kv = midStart + wsegs + lsegs + (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1)+wsegs;
		for (ix=0; ix<wsegs; ix++) {
			MAKE_QUAD(kv, kv+1, mv-1, mv, 5, bias);
			mv --;
			kv ++;
			}

		assert(nf==lsegs*wsegs*4 + wsegs*hsegs*4 + lsegs*hsegs*2);

		// do LEFT faces. -----------------
		// LEFT bottom row:
		kv = lsegs*(wsegs+1);  // index into bottom
		mv = midStart + 2*wsegs +lsegs;
		for (iy=0; iy<lsegs; iy++) {
			nextm = mv+1;
			if (iy==lsegs-1) 
				nextm -= nlayer;
			MAKE_QUAD(kv, kv-wsp1, nextm, mv, 6, bias);
			kv -=wsp1;
			mv ++;
			}

		// LEFT middle part:
		kv = midStart + 2*wsegs + lsegs; 
		for(iz=0; iz<hsegs-2; iz++) {
			mv = kv + nlayer;
			for (iy=0; iy<lsegs; iy++) {
				nextm = mv+1;
				nextk = kv+iy+1;
				if (iy==lsegs-1) { 
					nextm -= nlayer;
					nextk -= nlayer;
					}
				MAKE_QUAD(kv+iy, nextk, nextm, mv, 6, bias);
				mv++;
				}
			kv += nlayer;
			}

		// LEFT top row:
		kv = midStart + 2*wsegs + lsegs+ (hsegs-2)*nlayer; 
		mv = topStart + lsegs*(wsegs+1);
		for (iy=0; iy<lsegs; iy++) {
			nextk = kv+1;
			if (iy==lsegs-1) 
				nextk -= nlayer;
			MAKE_QUAD(kv, nextk, mv-wsp1, mv, 6, bias);
			mv -= wsp1;
			kv++;
			}
		}

	if (genUVs) {
		int ls = lsegs+1;
		int ws = wsegs+1;
		int hs = hsegs+1;
		int ntverts = ls*hs + hs*ws + ws*ls ;
		mesh.setNumTVerts( ntverts ) ;
		mesh.setNumTVFaces(nfaces);		

		int xbase = 0;
		int ybase = ls*hs;
		int zbase = ls*hs + hs*ws;
	
		float dw = 1.0f/float(wsegs);
		float dl = 1.0f/float(lsegs);
		float dh = 1.0f/float(hsegs);

		if (w==0.0f) w = .0001f;
		if (l==0.0f) l = .0001f;
		if (h==0.0f) h = .0001f;
		float u,v;

		nv = 0;
		v = 0.0f;
		// X axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f; 
			for (iy =0; iy<ls; iy++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dl;
				}
			v += dh;
			}

		v = 0.0f; 
		//Y Axis face
		for (iz =0; iz<hs; iz++) {
			u = 0.0f;
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dh;
			}

		v = 0.0f; 
		for (iy =0; iy<ls; iy++) {
			u = 0.0f; 
			for (ix =0; ix<ws; ix++) {
				mesh.setTVert(nv, u, v, 0.0f);
				nv++; u+=dw;
				}
			v += dl;
			}

		assert(nv==ntverts);

		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = griddirection(v);
			int ntv[3];
			for (ix=0; ix<3; ix++) {
				int iu,iv;
				switch(dir) {
					case POSX: case NEGX:
						iu = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f);  
						if (dir==NEGX) iu = lsegs-iu;
						ntv[ix] = (xbase + iv*ls + iu);
						break;
					case POSY: case NEGY:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)hsegs*(v[ix].z-va.z)/h)+.5f); 
						if (dir==POSY) iu = wsegs-iu;
						ntv[ix] = (ybase + iv*ws + iu);
						break;
					case POSZ: case NEGZ:
						iu = int(((float)wsegs*(v[ix].x-va.x)/w)+.5f);  
						iv = int(((float)lsegs*(v[ix].y-va.y)/l)+.5f); 
						if (dir==NEGZ) iu = wsegs-iu;
						ntv[ix] = (zbase + iv*ws + iu);
						break;
					}
			 	}
			assert(ntv[0]<ntverts);
			assert(ntv[1]<ntverts);
			assert(ntv[2]<ntverts);
			
			mesh.tvFace[nf].setTVerts(ntv[0],ntv[1],ntv[2]);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
    else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		for (nf = 0; nf<nfaces; nf++) {
			Face& f = mesh.faces[nf];
			DWORD* nv = f.getAllVerts();
			Point3 v[3];
			for (int ix =0; ix<3; ix++)
				v[ix] = mesh.getVert(nv[ix]);
			int dir = griddirection(v);
			mesh.setFaceMtlIndex(nf,mapDir[dir]);
			}
		}
 
	mesh.InvalidateGeomCache();
	}
}


#define Tang(vv,ii) ((vv)*3+(ii))
inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}
inline Point3 operator-(const PatchVert &pv1,const PatchVert &pv2)
	{
	return pv1.p-pv2.p;
	}
inline Point3 operator+(const PatchVert &pv1,const PatchVert &pv2)
	{
	return pv1.p+pv2.p;
	}

void GridObject::BuildGridPatch(TimeValue t,
		PatchMesh &amesh
		)
	{
	int ix,iy,np,kv;
	int wsegs,lsegs,nv;
	Point3 v,p;
	float l, w;
	int tex;
	
	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
/*
	pblock->GetValue( PB_LENGTH, t, l, ivalid );
	pblock->GetValue( PB_WIDTH, t, w, ivalid );
	pblock->GetValue( PB_LSEGS, t, lsegs, ivalid );
	pblock->GetValue( PB_WSEGS, t, wsegs, ivalid );
	pblock->GetValue( PB_TEXTURE, t, tex, ivalid );
*/
	pblock2->GetValue(grid_lsegs,t,lsegs,ivalid);
	pblock2->GetValue(grid_wsegs,t,wsegs,ivalid);
	pblock2->GetValue(grid_genuvs,t,tex,ivalid);
	pblock2->GetValue(grid_length,t,l,ivalid);
	pblock2->GetValue(grid_width,t,w,ivalid);


	int lv = lsegs + 1;
	int wv = wsegs + 1;

	int nverts = lv * wv;
	int npatches = lsegs * wsegs;
	int nexteriors = npatches * 4 + lsegs * 2 + wsegs * 2;
	int ninteriors = npatches * 4;
	int nvecs = ninteriors + nexteriors;

	amesh.setNumVerts(nverts);
	amesh.setNumTVerts(tex ? nverts : 0);
	amesh.setNumVecs(nvecs);
	amesh.setNumPatches(npatches);
	amesh.setNumTVPatches(tex ? npatches : 0);

	v =  Point3(-w, -l, 0.0f) / 2.0f;   

	float dx = w/wsegs;
	float dy = l/lsegs;
	float fws = (float)wsegs;
	float fls = (float)lsegs;

	// Create the vertices.
	nv = 0;
	p.z = v.z;
	p.y = v.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = v.x;
		for (ix=0; ix<=wsegs; ix++) {
			if(tex)
				amesh.setTVert(nv, UVVert((float)ix / fws, (float)iy / fls, 0.0f));
			amesh.verts[nv].flags = PVERT_COPLANAR;
			amesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}

	// Create patches.
	np = 0;
	int interior = nexteriors;
	int vecRowInc = lsegs * 2;
	int vecColInc = wsegs * 2;
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		int rv = iy * vecColInc;	// Row vector start
		int cv = vecColInc * lv + iy * 2;	// column vector start
		for (ix=0; ix<wsegs; ix++,++np) {
			Patch &p = amesh.patches[np];
			int a = kv, b = kv+1, c = kv+wsegs+2, d = kv + wsegs + 1;
			int ab = rv, ba = rv+1;
			int bc = cv+vecRowInc, cb = cv + vecRowInc + 1;
			int cd = rv+vecColInc+1, dc = rv+vecColInc;
			int da = cv + 1, ad = cv;
			amesh.MakeQuadPatch(np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad, interior, interior+1, interior+2, interior+3, 1);
			if(tex)
				amesh.getTVPatch(np).setTVerts(a,b,c,d);
			// Create the default vectors
			Point3 pa = amesh.getVert(a).p;
			Point3 pb = amesh.getVert(b).p;
			Point3 pc = amesh.getVert(c).p;
			Point3 pd = amesh.getVert(d).p;
			amesh.setVec(ab, pa + (pb - pa) / 3.0f);
			amesh.setVec(ba, pb - (pb - pa) / 3.0f);
			amesh.setVec(bc, pb + (pc - pb) / 3.0f);
			amesh.setVec(cb, pc - (pc - pb) / 3.0f);
			amesh.setVec(cd, pc + (pd - pc) / 3.0f);
			amesh.setVec(dc, pd - (pd - pc) / 3.0f);
			amesh.setVec(da, pd + (pa - pd) / 3.0f);
			amesh.setVec(ad, pa - (pa - pd) / 3.0f);
			kv++;
			cv += vecRowInc;
			rv += 2;
			interior += 4;
			}
		}
	// Verify that we have the right number of parts!
	assert(np==npatches);
	assert(nv==nverts);
	// Finish up patch internal linkages (and bail out if it fails!)
	assert(amesh.buildLinkages());
	// Calculate the interior bezier points on the PatchMesh's patches
	amesh.computeInteriors();
	amesh.InvalidateGeomCache();

/*
	int nverts = 8;
	int nvecs = 48;
	int npatches = 6;
	patch.setNumVerts(nverts);	
	patch.setNumTVerts(textured ? 4 : 0);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);
//	patch.setNumTVPatches(textured ? npatches : 0);

	float w2 = width/2.0f, w3 = width/3.0f;
	float l2 = length/2.0f, l3 = length/3.0f;
	float h2 = height/2.0f, h3 = height/3.0f;
	int i;
	Point3 v;
	DWORD a, b, c, d;

	patch.setVert(0, -w2, -l2, 0.0f);
	patch.setVert(1,  w2, -l2, 0.0f);
	patch.setVert(2,  w2,  l2, 0.0f);
	patch.setVert(3, -w2,  l2, 0.0f);
	patch.setVert(4, -w2, -l2, height);
	patch.setVert(5,  w2, -l2, height);
	patch.setVert(6,  w2,  l2, height);
	patch.setVert(7, -w2,  l2, height);
	
	if(textured) {
		patch.setTVert(0, UVVert(1,0,0));
		patch.setTVert(1, UVVert(1,1,0));
		patch.setTVert(2, UVVert(0,1,0));
		patch.setTVert(3, UVVert(0,0,0));
		}

	int ix=0;
	for (i=0; i<4; i++) {
		v = (patch.verts[(i+1)%4] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		v = (patch.verts[i+4] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		v = (patch.verts[i==0?3:i-1] - patch.verts[i])/3.0f;
		patch.setVec(ix++,patch.verts[i] + v);
		}
	for (i=0; i<4; i++) {
		v = (patch.verts[(i+1)%4+4] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		v = (patch.verts[i] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		v = (patch.verts[i==0?7:i+3] - patch.verts[i+4])/3.0f;
		patch.setVec(ix++,patch.verts[i+4] + v);
		}
	
	int px = 0;
	for (i=0; i<4; i++) {
		Patch &p = patch.patches[px];
		a = i+4;
		b = i;
		c = (i+1)%4;
		d = (i+1)%4+4;
		p.SetType(PATCH_QUAD);
		p.setVerts(a, b, c, d);
		p.setVecs(
			Tang(a,1),Tang(b,1),Tang(b,0),Tang(c,2),
			Tang(c,1),Tang(d,1),Tang(d,2),Tang(a,0));
		p.setInteriors(ix, ix+1, ix+2, ix+3);
		p.smGroup = 1<<px;
		if(textured) {
//			TVPatch &tp = patch.tvPatches[px];
//			tp.setTVerts(2,3,0,1);
			}
		ix+=4;
		px++;
		}
	
	a = 0;
	b = 3;
	c = 2;
	d = 1;
	patch.patches[px].SetType(PATCH_QUAD);
	patch.patches[px].setVerts(a, b, c, d);
	patch.patches[px].setVecs(
		Tang(a,2),Tang(b,0),Tang(b,2),Tang(c,0),
		Tang(c,2),Tang(d,0),Tang(d,2),Tang(a,0));
	patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
	patch.patches[px].smGroup = 1<<px;
	if(textured) {
//		TVPatch &tp = patch.tvPatches[px];
//		tp.setTVerts(0,1,2,3);
		}
	ix+=4;
	px++;

	a = 7;
	b = 4;
	c = 5;
	d = 6;
	patch.patches[px].SetType(PATCH_QUAD);
	patch.patches[px].setVerts(a, b, c, d);
	patch.patches[px].setVecs(
		Tang(a,0),Tang(b,2),Tang(b,0),Tang(c,2),
		Tang(c,0),Tang(d,2),Tang(d,0),Tang(a,2));
	patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
	patch.patches[px].smGroup = 1<<px;
	if(textured) {
//		TVPatch &tp = patch.tvPatches[px];
//		tp.setTVerts(2,3,0,1);
		}
	ix+=4;
	px++;

	assert(patch.buildLinkages());
	patch.computeInteriors();
	patch.InvalidateGeomCache();
*/
	}

#ifndef NO_NURBS

Object * GridObject::BuildNURBSPlane(TimeValue t)
{

	int wsegs,lsegs;
	float l, w;
	int tex;
	NURBSSet nset;
	
	// Start the validity interval at forever and widdle it down.
	Interval ivalid = FOREVER;
	pblock2->GetValue(grid_lsegs,t,lsegs,ivalid);
	pblock2->GetValue(grid_wsegs,t,wsegs,ivalid);
	pblock2->GetValue(grid_genuvs,t,tex,ivalid);
	pblock2->GetValue(grid_length,t,l,ivalid);
	pblock2->GetValue(grid_width,t,w,ivalid);
	lsegs = 4;
	wsegs = 4;

	NURBSCVSurface *s = new NURBSCVSurface();
	nset.AppendObject(s);
	s->SetNumCVs(lsegs, wsegs);

	s->SetUOrder(4);
	s->SetVOrder(4);
	s->SetNumUKnots(8);
	s->SetNumVKnots(8);
	for (int k = 0; k < 4; k++) {
		s->SetUKnot(k, 0.0);
		s->SetVKnot(k, 0.0);
		s->SetUKnot(k+4, 1.0);
		s->SetVKnot(k+4, 1.0);
	}

	NURBSControlVertex cv;

	Point3 v,p;
	v =  Point3(-w, -l, 0.0f) / 2.0f;   

	float dx = w/(wsegs-1.0f);
	float dy = l/(lsegs-1.0f);
	float fws = (float)wsegs;
	float fls = (float)lsegs;

	// Create the vertices.
	int nv = 0;
	p.z = v.z;
	p.y = v.y;
	for(int iy=0; iy<lsegs; iy++) {
		p.x = v.x;
		for (int ix=0; ix<wsegs; ix++) {
//			if(tex)
//				amesh.setTVert(nv, UVVert((float)ix / fws, (float)iy / fls, 0.0f));
//			amesh.verts[nv].flags = PVERT_COPLANAR;
//			amesh.setVert(nv++, p);

			cv.SetPosition(0,  p);
			char name[20];
			sprintf(name, "%s[%d,%d]", GetString(IDS_PW_CV), ix, iy);
			cv.SetName(name);
			s->SetCV(ix, iy, cv);

			p.x += dx;
			}
		p.y += dy;
		}
/*
	for (int u = 0; u < 4; u++) {
		float up = 100.0f * ((float)u/3.0f);
		for (int v = 0; v < 4; v++) {
			float vp = 100.0f * ((float)v/3.0f);
//			cv.SetPosition(0,  Point3(-150.0f + up, -100.0f + vp, 0.0f));
			cv.SetPosition(0,  Point3(up, vp, 0.0f));
			char name[20];
//			sprintf(name, "%s[%d,%d]", GetString(IDS_CV), u, v);
			cv.SetName(name);
			s->SetCV(u, v, cv);
		}
	}
*/
	if (tex)
		{
		s->SetTextureUVs(0, 0, Point2(1.0f, 0.0f));
		s->SetTextureUVs(0, 1, Point2(0.0f, 0.0f));
		s->SetTextureUVs(0, 2, Point2(1.0f, 1.0f));
		s->SetTextureUVs(0, 3, Point2(0.0f, 1.0f));
		}
	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;


/*
	NURBSSet nset;

	Point3 center(0, 0, 0);
	Point3 northAxis(0, 0, 1);
	Point3 refAxis(0, -1, 0);

	float startAngleU = -PI;
	float endAngleU = PI;
	float startAngleV;
	if (hemi)
		startAngleV = 0.0f;
	else
		startAngleV = -HALFPI;
	float endAngleV = HALFPI;
	if (recenter) {
		if (hemi)
			center = Point3(0.0f, 0.0f, 0.0f);
		else
			center = Point3(0.0f, 0.0f, radius);
	}

	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	if (hemi) {
		surf->SetTextureUVs(0, 0, Point2(0.0f, 0.5f));
		surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
		surf->SetTextureUVs(0, 2, Point2(1.0f, 0.5f));
		surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));
	} else {
		surf->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
		surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
		surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
		surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));
	}

	surf->FlipNormals(TRUE);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_GEOSPHERE));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);
	GenNURBSSphereSurface(radius, center, northAxis, refAxis, 
					startAngleU, endAngleU, startAngleV, endAngleV,
					FALSE, *surf);

	if (hemi) {
		// now create caps on the ends
		NURBSCapSurface *cap0 = new NURBSCapSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0);
		cap0->SetEdge(0);
		cap0->FlipNormals(TRUE);
		cap0->Renderable(TRUE);
		char sname[80];
		sprintf(sname, "%s%s%", bname, GetString(IDS_CT_CAP));
		cap0->SetName(sname);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
*/
}

#endif

Object* GridObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float length, width, height;
		int genUVs;
		pblock2->GetValue(grid_length,t,length,valid);
		pblock2->GetValue(grid_width,t,width,valid);
		height = 0.0f;
		pblock2->GetValue(grid_genuvs,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildGridPatch(t,ob->patch);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
    }

#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		Object *ob = BuildNURBSPlane(t);
		ob->SetChannelValidity(TOPO_CHAN_NUM, valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM, valid);
		ob->UnlockObject();
		return ob;

	} 
#endif

    return SimpleObject::ConvertToType(t,obtype);
	}

int GridObject::CanConvertToType(Class_ID obtype)
    {
	if (obtype == patchObjectClassID)
		return 1;
    
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID)
		return 1;
#endif
    return SimpleObject::CanConvertToType(obtype);
	}


void GridObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}


class GridObjCreateCallBack: public CreateMouseCallBack {
	GridObject *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1;
	BOOL square;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(GridObject *obj) { ob = obj; }
	};

int GridObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;
	if (msg == MOUSE_FREEMOVE)
		{
		vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		}
	else if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:

				GetCOREInterface()->SetHideByCategoryFlags(GetCOREInterface()->GetHideByCategoryFlags() & ~HIDE_OBJECTS);

				sp0 = m;
				
				ob->createMeth = grid_crtype_blk.GetInt(grid_create_meth);

				ob->pblock2->SetValue(grid_length,0,0.0f);
				ob->pblock2->SetValue(grid_width,0,0.0f);
				ob->suspendSnap = TRUE;								
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
#ifdef BOTTOMPIV
				{
				Point3 xyz = mat.GetTrans();
				xyz.z = p0.z;
				mat.SetTrans(xyz);
				}
#endif
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				p1.z = p0.z +(float).01; 
				if (ob->createMeth || (flags&MOUSE_CTRL)) {
					mat.SetTrans(p0);
				} else {
 					mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV 					
					Point3 xyz = mat.GetTrans();
					xyz.z = p0.z;
					mat.SetTrans(xyz);					
					}
#endif
				d = p1-p0;
				
				square = FALSE;
				if (ob->createMeth) {
					// Constrain to cube
					d.x = d.y = d.z = Length(d)*2.0f;
				} else 
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					square = TRUE;
					}

				ob->pblock2->SetValue(grid_width,0,float(fabs(d.x)));
				ob->pblock2->SetValue(grid_length,0,float(fabs(d.y)));
//				ob->pmapParam->Invalidate();										

				if (msg==MOUSE_POINT && ob->createMeth) {
					ob->suspendSnap = FALSE;
					return (Length(sp1-sp0)<3)?CREATE_ABORT:CREATE_STOP;					
				} else if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) {
					return CREATE_ABORT;
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;					
					return CREATE_STOP;
					}

			

				break;
			}

		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static GridObjCreateCallBack gridCreateCB;

CreateMouseCallBack* GridObject::GetCreateMouseCallBack() {
	gridCreateCB.SetObj(this);
	return(&gridCreateCB);
	}


BOOL GridObject::OKtoDisplay(TimeValue t) 
	{
	return TRUE;
	}



void GridObject::InvalidateUI() 
	{
	grid_param_blk.InvalidateUI();
	}


RefTargetHandle GridObject::Clone(RemapDir& remap) 
	{
	GridObject* newob = new GridObject();
	newob->ReplaceReference(0,pblock2->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}



IOResult
GridObject::Load(ILoad *iload) 
{	
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &grid_param_blk, this, PBLOCK_REF_NO);
	iload->RegisterPostLoadCallback(plcb);
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\mkhedra.cpp ===
/**********************************************************************************
 *
 *	MKHEDRA.C	 	Creates Regular Polyhedra.
 *				Adapted from Dan Silva's HEDRA.C
 *
 *	Revision History
 *	----------------
 *	03-14-94  RWB  Created this file.
 *  10-14-95  RWB  Adapted to MAX
 *
 **********************************************************************************/
#include "prim.h"


typedef struct {
	int sclass;			
	float fp;				
	float fq;				
	float radius;			
	int axis;				
	char pmtl[17];
	char qmtl[17];
	char rmtl[17];
	int verts;			 
	float scale_axis[3];	
} State;

static State state;


static int MakeHedron(int np, int dp, int nq, int dq, double cp, double cq);
static void TesselatePolys(void);

typedef struct { double x,y,z; } DPoint;

#define CP(i,j)  (a[i]*b[j]-a[j]*b[i])

#define R_OP 0
#define P_OP 1
#define Q_OP 2

typedef struct {
	DPoint p[3];	
	DPoint v;
	} STri;

typedef struct {
	int num;
	DPoint n[30];
	STri t[30]; /* starter face */
	} AxisList;

#define MAXVERTS 380
#define MAXFACES 720
static AxisList axis[3]={0};
static DPoint verts[MAXVERTS];
static short imtl[3]={0,1,2};
static int nverts = 0;
static int nfaces = 0;
typedef struct {
	short nax[3];
	} TriReg;

#define MAXREGTRIS 120
static TriReg regtris[MAXREGTRIS];
static int nregtris = 0;
static int nsides[3];

/*----------------------------------------------------*/

typedef struct
{
unsigned short a,b,c;	/* Vertex numbers for triangular face */
unsigned long sm_group;	/* Smoothing group bits (32) */
unsigned char flags;	/* See below for meanings */
unsigned char material;	/* 0-255 */
} FData;

#define FC_ABLINE 1
#define FC_BCLINE 2
#define FC_CALINE 4

static FData fdata[MAXFACES];

/* Classes */

#define  CL_TETRA 0
#define  CL_CUBOCT 1
#define  CL_ICOSDODEC 2
#define  CL_ICOSDODEC2 3
#define  CL_DDODEC2 4

static short pnum[5] = {3,3,3,3,5};
static short pden[5] = {1,1,1,1,1};
static short qnum[5] = {3,4,5,5,5};
static short qden[5] = {1,1,1,2,2};



/*----------------------------------------------------*/

static void DCrossProd(double *p, double *a, double *b) {
	p[0] = CP(1,2); 	
	p[1] = CP(2,0);
	p[2] = CP(0,1);
	}

static double DDotProd(double *a, double *b) {
	return( a[0]*b[0]+a[1]*b[1]+a[2]*b[2]);
	}

static void NormVect(double *n) {
	double s,d;
	s = sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]);
	if (s>0.0) {
		d = 1/s;
		n[0] *= d;	n[1] *= d; n[2] *= d;
		}
	else { n[0] = 1.0; n[1] = 0.0; n[2] = 0.0; }
	}

static int same_pt(DPoint *a, DPoint *b) {
	if (fabs(a->x-b->x)>.01) return(0);
	if (fabs(a->y-b->y)>.01) return(0);
	if (fabs(a->z-b->z)>.01) return(0);
	return(1);
	}

static void ReflVect(double *pnew, double *p, double *n) {
	double d = DDotProd(p,n);
	pnew[0] = p[0]-2.0*d*n[0];
	pnew[1] = p[1]-2.0*d*n[1];
	pnew[2] = p[2]-2.0*d*n[2];
	}

static int reg_vert(DPoint *p) {
	int i;
	for (i=0; i<nverts; i++) {
		if (same_pt(p,&verts[i])) return(i);
		}
	i = nverts;
	nverts++;
#ifdef DBG
	printf("reg_vert: p = (%.5f,%.5f,%.5f)  nverts = %d\n", p->x,p->y,p->z,nverts);
#endif
	verts[i]=*p;
	return(i);
	}

#ifdef DBG
static void prx(STri *t,char *s) {
	printf("%s: (%.3f,%.3f,%.3f)(%.3f,%.3f,%.3f)(%.3f,%.3f,%.3f)\n",s,
		t->p[0].x,	t->p[0].y,	t->p[0].z,
		t->p[1].x,	t->p[1].y,	t->p[1].z,
		t->p[2].x,	t->p[2].y,	t->p[2].z);
	}
#endif

static int reg_axis(int n, DPoint *p, STri *s) {
	int i; 
	AxisList *al = &axis[n];
	for (i=0; i<al->num; i++) {
		if (same_pt(p,&al->n[i])) 
			return(i);
		}
	i = al->num;
	al->num++;
	al->n[i] = *p;
	al->t[i] = *s;
	return(i);
	}

static reg_stri(STri *t) {
	int nax[3],i;
	for (i=0; i<3; i++) {
		nax[i] = reg_axis(i,&t->p[i],t);
		}
	for (i=0; i<nregtris; i++) {
		if (nax[0]==regtris[i].nax[0] && nax[1]==regtris[i].nax[1]
			&&nax[2]==regtris[i].nax[2]) return(0);
		}
	if(nregtris>=MAXREGTRIS) {
		printf(" REG TRI OVERFLOW \n");
		return 0;
		}
	i = nregtris;
	regtris[i].nax[0] = nax[0];
	regtris[i].nax[1] = nax[1];
	regtris[i].nax[2] = nax[2];
	nregtris++;
	return(1);
	}

static void R_refl(STri *t, STri *tnew) {
	DPoint n;
	/* reflect vert 0 in line connecting vert 1 and 2 */
	tnew->p[1] = t->p[1];
	tnew->p[2] = t->p[2];
	DCrossProd(&n.x, &t->p[1].x, &t->p[2].x);
	NormVect(&n.x);	
	ReflVect(&tnew->p[0].x,&t->p[0].x,&n.x);
	ReflVect(&tnew->v.x,&t->v.x,&n.x);
	reg_vert(&tnew->v);
	}
	
static void P_refl(STri *t, STri *tnew) {
	DPoint n;
	/* reflect vert 1 in line connecting vert 0 and 2 */
	tnew->p[0] = t->p[0];
	tnew->p[2] = t->p[2];
	DCrossProd(&n.x, &t->p[0].x, &t->p[2].x);
	NormVect(&n.x);	
	ReflVect(&tnew->p[1].x,&t->p[1].x,&n.x);
	ReflVect(&tnew->v.x,&t->v.x,&n.x);
	reg_vert(&tnew->v);
	}

static void Q_refl(STri *t, STri *tnew) {
	DPoint n;
	/* reflect vert 2 in line connecting vert 0 and 1 */
	tnew->p[0] = t->p[0];
	tnew->p[1] = t->p[1];
	DCrossProd(&n.x, &t->p[0].x, &t->p[1].x);
	NormVect(&n.x);	
	ReflVect(&tnew->p[2].x,&t->p[2].x,&n.x);
	ReflVect(&tnew->v.x,&t->v.x,&n.x);
	reg_vert(&tnew->v);
	}

int level = 0;

#if 0
static void traverse(STri *t, int op) {
	STri tnew;
#if 0
	dbgprintf(" traverse, op = %d, level = %d, &tnew = %X\n",op,level,&tnew);
	prx(t," ----"); 
#endif
	if (!reg_stri(t)) return;
	level++;
	if (op!=R_OP) { R_refl(t,&tnew);	traverse(&tnew,R_OP);	}
	if (op!=P_OP) { P_refl(t,&tnew);	traverse(&tnew,P_OP);	}
	if (op!=Q_OP) { Q_refl(t,&tnew);	traverse(&tnew,Q_OP);	}
	level--;
	}

#else

//  implements Stack
#define MAXQ 300
typedef struct {
	STri t;
	int  op;
	} QEntry;

static QEntry theq[MAXQ];
static int qnext;

static void qinit() {  qnext  = 0; }
static int qany() { return(qnext!=0); }

static void qput(STri *t, int op) {
	theq[qnext].t  = *t;	
	theq[qnext].op  = op;
	qnext++;
	}

static int qget(STri *t ) {
	int  op;
	qnext--;
	op  = theq[qnext].op;
	*t  = theq[qnext].t;
	return(op);		
	}


static void traverse(STri *t, int op) {
	STri tnew,tr;
	qinit();
	qput(t,op);
	while(qany()) {
		op = qget(&tr);
		if (!reg_stri(&tr)) continue;
		if (op!=Q_OP) { Q_refl(&tr,&tnew);  qput(&tnew,Q_OP);	}
		if (op!=P_OP) { P_refl(&tr,&tnew);  qput(&tnew,P_OP);	}
		if (op!=R_OP) { R_refl(&tr,&tnew);  qput(&tnew,R_OP);	}
		}
	}

#endif

static int curax = 0;
static short do_axis[3];
static short star_axis[3];

#ifdef DBG2
static double dist(int a, int b) {
	DPoint *pa = &verts[a];
	DPoint *pb = &verts[b];
	DPoint d;
	d.x = pa->x-pb->x;
	d.y = pa->y-pb->y;
	d.z = pa->z-pb->z;
	return(sqrt(d.x*d.x+d.y*d.y+d.z*d.z));
	}
#endif

static void outface(int a, int b, int c, int vab, int vbc, int vca) {
	unsigned char flags;
	
#ifdef DBG
	printf("outface[%d] (%d,%d,%d) \n",nfaces,a,b,c);
#endif

	fdata[nfaces].a = a;
	fdata[nfaces].b = b;
	fdata[nfaces].c = c;
	flags = 0;
	if (vab) flags|=FC_ABLINE;
	if (vbc) flags|=FC_BCLINE;
	if (vca) flags|=FC_CALINE;
	fdata[nfaces].flags = flags;
	fdata[nfaces].material = (unsigned char)imtl[curax];
	nfaces++;
	}

static int pol[20];
static int npoly=0;
static short center_verts, subdiv_sides;

static void init_poly() { npoly=0; }

static void outv(DPoint *p) {
	int i;
	int nv = reg_vert(p);

	/* make sure same vert doesnt occur twice in poly */
	for (i=0; i<npoly; i++) {
		if (nv==pol[i])
			return;
		}

#ifdef DBG
	printf("   outp ( %.5f, %.5f, %.5f )   nv = %d \n", 
		p->x,p->y,p->z,nv);
#endif
	pol[npoly++] = nv;
	}

static void check_facing() {
	DPoint *p[3], d01,d12,n; 
	int i,tmp;
	p[0] = &verts[pol[0]];
	p[1] = &verts[pol[1]];
	p[2] = &verts[pol[2]];
	d01.x = p[1]->x-p[0]->x;
	d01.y = p[1]->y-p[0]->y;
	d01.z = p[1]->z-p[0]->z;
	d12.x = p[2]->x-p[1]->x;
	d12.y = p[2]->y-p[1]->y;
	d12.z = p[2]->z-p[1]->z;
	DCrossProd(&n.x,&d01.x,&d12.x);
	if (DDotProd(&n.x,&p[1]->x)<0.0) {
#ifdef DBG
		printf("  Reverse Poly facing\n");
#endif
		for (i=0; i<npoly/2; i++) {
			tmp = pol[i];
			pol[i] = pol[npoly-i-1];
			pol[npoly-i-1] = tmp;
			}
		}
	}	

static void MidPoint(DPoint *mp, DPoint *a, DPoint *b) {
	mp->x = (a->x+b->x)*.5;
	mp->y = (a->y+b->y)*.5;
	mp->z = (a->z+b->z)*.5;
	}

static void ScaleVect(DPoint *v, double s) {
	v->x *= s;
	v->y *= s;
	v->z *= s;
	}

static void outpoly() {
	int i;
	int vab,vca;
#ifdef DBG
	printf("  outpoly, npoly = %d \n", npoly);
#endif
	/* check to make sure poly faces away from origin: if not, flip it */
	check_facing();	

	if (subdiv_sides) {
		DPoint midp;
		int nxti = 0;
		for (i=npoly-1; i>=0; i--) {
			pol[2*i] = pol[i];
			MidPoint(&midp,&verts[pol[i]],&verts[pol[nxti]]);
			pol[2*i+1] = reg_vert(&midp);
			nxti = 2*i;
			}
		npoly *= 2;
		}

	if (center_verts||star_axis[curax]||state.scale_axis[curax]!=1.0) {
		DPoint sum;
		int nc,nxt;
		sum.x = sum.y = sum.z = 0.0;
		for (i=0; i<npoly; i++) {
			sum.x += verts[pol[i]].x;
			sum.y += verts[pol[i]].y;
			sum.z += verts[pol[i]].z;
			}
		sum.x /= (float)npoly;
		sum.y /= (float)npoly;
		sum.z /= (float)npoly;

		if (state.scale_axis[curax]!=1.0) {
			ScaleVect(&sum,state.scale_axis[curax]);
			nc = reg_vert(&sum);
			for (i=0; i<npoly; i++) {
				nxt = (i==npoly-1)?0:i+1;
				outface(nc,pol[i],pol[nxt],1,1,1);
				}
			}
		else {
			nc = reg_vert(&sum);
			for (i=0; i<npoly; i++) {
				nxt = (i==npoly-1)?0:i+1;
				outface(nc,pol[i],pol[nxt],0,1,0);
				}
			}
		}
	else  {
		for (i=1; i<npoly-1; i++) {
			vab = vca = 0;
			if (i==1) vab = 1;
			if	(i==npoly-2) vca = 1;
#ifdef DBG2
			printf("         face (%d,%d,%d) vis = (%d %d %d) \n",
				pol[0],pol[i],pol[i+1],vab,1,vca);
#endif
			outface(pol[0],pol[i],pol[i+1],vab,1,vca);
#ifdef DBG2
			{
			double l = dist(pol[i],pol[i+1]);
			printf(" side length = %.6f \n",l);
			}
#endif

		
			}
		}
	}


static void DoRPolys() {
	STri t;
	int i;
#ifdef DBG
	printf("\nDoRPolys---------num = %d\n",axis[0].num);
#endif
	for (i=0; i<axis[0].num; i++) {
		init_poly();
#ifdef DBG
		printf("---------\n");
#endif
		t = axis[0].t[i];
		outv(&t.v);
		P_refl(&t,&t);	 outv(&t.v);
		Q_refl(&t,&t);	 outv(&t.v);
		P_refl(&t,&t);	 outv(&t.v);
		outpoly();
		}
	}

static void DoPPolys() {
	int i,j;
	STri t;
#ifdef DBG
	printf("\nDoPPolys---------num = %d, npsides = %d\n",axis[1].num,nsides[1]);
#endif	
	for (i=0; i<axis[1].num; i++) {
#ifdef DBG
		printf("---------\n");
#endif
		init_poly();
		t = axis[1].t[i];
		for (j=0; j<nsides[1]; j++) {
			Q_refl(&t,&t);	
			outv(&t.v); 
			R_refl(&t,&t);	
			outv(&t.v);
			}
		outpoly();
		}
	}

static void DoQPolys() {
	int i,j;
	STri t;
#ifdef DBG
	printf("\nDoQPolys---------num = %d, nqsides = %d\n",axis[2].num,nsides[2]);
#endif
	for (i=0; i<axis[2].num; i++) {
#ifdef DBG
		printf("---------\n");
#endif
		t = axis[2].t[i];
		init_poly();
		for (j=0; j<nsides[2]; j++) {
			P_refl(&t,&t);	
			outv(&t.v); 
			R_refl(&t,&t);	
			outv(&t.v);
			}
		outpoly();
		}
	}


static void TesselatePolys(void) {
	int i;

	for (i=0; i<3; i++) {
		if (do_axis[i]) {
			curax = i;
			switch(i) {
				case 0: DoRPolys(); break;
				case 1: DoPPolys(); break;
				case 2: DoQPolys(); break;
				}
			}
		}
#ifdef DBG
	printf(" ------------------ Tesselate done -----------------\n");
#endif
	}

static void RotY(DPoint *p, double s, double c) {
	DPoint t;
	t.x =  c*p->x + s*p->z;
	t.z =  -s*p->x + c*p->z;
	t.y =  p->y;
	*p = t;
	}

static void RotX(DPoint *p, double s, double c) {
	DPoint t;
	t.y =  c*p->y + s*p->z;
	t.z =  -s*p->y + c*p->z;
	t.x =  p->x;
	*p = t;
	}

static int MakeHedron(int np, int dp, int nq, int dq, double cp, double cq) {
	STri t0;
	double pang,qang,cosp,cosq,sinp,sinq;

#ifdef DBG
	printf("MakeHedron: p = %d/%d  q = %d/%d  cp = %.4f  cq = %.4f\n",np,dp,nq,dq,cp,cq);
#endif

	nregtris = nfaces = nverts = 0;
	center_verts = state.verts>0?1:0;
	subdiv_sides = state.verts==2?1:0;
	nsides[0] = 4;
	nsides[1] = np;
	nsides[2] = nq;

	/* these are two of the angles of a right spherical triangle */
	pang = PI*(double)dp/(double)np;
	qang = PI*(double)dq/(double)nq;

	/* compute the (sin,cos) of sides of the spherical triangle */
	cosp = cos(pang)/sin(qang);
	cosq = cos(qang)/sin(pang);
	sinp = sqrt(1.0-cosp*cosp);
	sinq = sqrt(1.0-cosq*cosq);

	t0.p[0].x = 0.0;  t0.p[0].y = 0.0;  t0.p[0].z = 1.0;
	t0.p[1].x = sinq; t0.p[1].y = 0.0;  t0.p[1].z = cosq;
	t0.p[2].x = 0.0;  t0.p[2].y = sinp; t0.p[2].z = cosp;

	t0.v.x = cq*sinq; 
	t0.v.y = cp*sinp;
	t0.v.z = 1.0 + cq*(cosq-1.0) + cp*(cosp-1.0);
 	NormVect(&t0.v.x); 

#ifdef DBG
	printf(" pang = %.5f, qang = %.5f \n", RadToDeg(pang), RadToDeg(qang));
	printf(" cpa = %.5f, cqa = %.5f\n", RadToDeg(acos(cosp)),RadToDeg(acos(cosq)));
	printf(" t = (%.4f,%.4f,%.4f) \n",t0.v.x,t0.v.y,t0.v.z);
#endif
	switch(state.axis) {
		case 1:  /* want P aligned with Z -- rotate into pos*/
			RotY(&t0.p[0],-sinq,cosq);									
			RotY(&t0.p[1],-sinq,cosq);									
			RotY(&t0.p[2],-sinq,cosq);									
			RotY(&t0.v,-sinq,cosq);									
			break;
		case 2:  /* Q aligned with Z -- */
			RotX(&t0.p[0],sinp,cosp);									
			RotX(&t0.p[1],sinp,cosp);									
			RotX(&t0.p[2],sinp,cosp);									
			RotX(&t0.v,sinp,cosp);									
			break;
		}

#ifdef DBG
	printf(" p0 = %.4f, %.4f, %.4f \n",t0.p[0].x,t0.p[0].y,t0.p[0].z); 
	printf(" p1 = %.4f, %.4f, %.4f \n",t0.p[1].x,t0.p[1].y,t0.p[1].z); 
	printf(" p2 = %.4f, %.4f, %.4f \n",t0.p[2].x,t0.p[2].y,t0.p[2].z); 
	printf(" v  = %.4f, %.4f, %.4f \n",t0.v.x,t0.v.y,t0.v.z); 
#endif

	memset(axis,0,3*sizeof(AxisList));
	reg_vert(&t0.v);
	level = 0;
	traverse(&t0, -1);

	do_axis[0] = do_axis[1] = do_axis[2] = 1;
	star_axis[0] = star_axis[1] = star_axis[2] = 0;
	if (dp>1) star_axis[1] = 1;	
	if (dq>1) star_axis[2] = 1;	

	if (cp==0||cq==0) do_axis[0] = 0;
	if (cp==0.0 && cq==1.0) do_axis[1] = 0;
	if (cp==1.0 && cq==0.0) do_axis[2] = 0;


#ifdef DBG
	printf(" nsides = %d,%d,%d \n",nsides[0],nsides[1],nsides[2]);
	printf(" do_axis= %d,%d,%d \n",do_axis[0],do_axis[1],do_axis[2]);
	printf(" numaxis = %d,%d,%d \n",axis[0].num,axis[1].num,axis[2].num);
	printf(" nverts = %d \n",nverts);
	printf(" ------------------ MakeHedron done -----------------\n");
#endif
	

	return(1);
	}

/*------------------------------------------------------------------------------------*/


void CreateHedron(
		Mesh &mesh, 
		int family, float fp, float fq, float radius,
		int axis, int vts, float *scale_axis)
	{
	int i;	
	
	state.sclass        = family;
	state.fp            = fp;
	state.fq            = fq;
	state.radius        = radius;
	state.axis          = axis;
	state.verts         = vts;	
	state.scale_axis[0] = scale_axis[0];
	state.scale_axis[1] = scale_axis[1];
	state.scale_axis[2] = scale_axis[2];
	
	MakeHedron( pnum[state.sclass], pden[state.sclass], qnum[state.sclass],
			    qden[state.sclass], state.fp, state.fq );
	TesselatePolys();
	
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	for (i=0; i<nverts; i++) {
		mesh.verts[i].x = float(state.radius * verts[i].x);
		mesh.verts[i].y = float(state.radius * verts[i].y);
		mesh.verts[i].z = float(state.radius * verts[i].z);
		}
	
	for (i=0; i<nfaces; i++) {
		mesh.faces[i].v[0]    = fdata[i].a;
		mesh.faces[i].v[1]    = fdata[i].b;
		mesh.faces[i].v[2]    = fdata[i].c;
		mesh.faces[i].flags   = fdata[i].flags;
		mesh.faces[i].smGroup = fdata[i].sm_group;
		mesh.setFaceMtlIndex(i,fdata[i].material);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\light.h ===
/**********************************************************************
 *<
	FILE: light.h

	DESCRIPTION:  Defines lights

	CREATED BY: Dan Silva

	HISTORY: created 2 January 1995
			 added directional and spot lights, Feb 95

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __LIGHT__H__ 

#define __LIGHT__H__

// reference #s
#define PBLOCK_REF 0
#define PROJMAP_REF 1
#define SHADPROJMAP_REF 2
#define SHADTYPE_REF 3
#define EMITTER_REF 4

class GeneralLight;


class ProjMapDADMgr: public DADMgr {
	GeneralLight *gl;
	public:
		ProjMapDADMgr(GeneralLight *l=NULL) { gl = l;}
		void Init(GeneralLight *d) { gl = d; }
		// called on the draggee to see what if anything can be dragged from this x,y
		SClass_ID GetDragType(HWND hwnd, POINT p);
		// called on potential dropee to see if can drop type at this x,y
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew);
		int SlotOwner() { return OWNER_SCENE; }  
		ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type);
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type);
		BOOL AutoTooltip() { return TRUE; }
	};

class GeneralLightCreateCallBack;
class TSpotLightClassDesc;
class SetTypeRest;

class GeneralLight: public GenLight {			   
	friend class GeneralLightCreateCallBack;
	friend class LightPostLoad;
	friend class TSpotLightClassDesc;
	friend class ProjMapDADMgr;
	friend class SetTypeRest;
	friend class BaseObjLight;
	friend class OmniLight;
	friend class DirLight;
	friend class SpotLight;
	friend BOOL CALLBACK GeneralLightParamDialogProc( HWND hDlg, UINT message,
		 WPARAM wParam, LPARAM lParam );
	friend void resetLightParams();

	// Class vars
	static BOOL inCreate;
	static Mesh staticMesh[2];
	static short meshBuilt;
	static HWND hGeneralLight;
	static HWND hAttenLight;
	static HWND hSpotLight;
	static HWND hOmni;
	static HWND hShadow;
	static HWND hEmitter;
	static IObjParam* iObjParams;
	static int dlgRed;
	static int dlgGreen;
	static int dlgBlue;
	static int dlgH;
	static int dlgS;
	static int dlgV;
	static float dlgIntensity;
	static float dlgContrast;
	static float dlgDiffsoft;
	static float dlgHotsize;
	static float dlgFallsize;
	static float dlgTDist;
	static short dlgShowCone;
	static short dlgCrossover;
	static short dlgUseAtten;
	static float dlgAttenStart;
	static float dlgAttenEnd;
	static float dlgAtten1Start;
	static float dlgAtten1End;
	static short dlgShowAtten;
	static short dlgShowAttenNear;
	static short dlgShowDecay;
	static short dlgShape;
	static float dlgAspect;
//	static int dlgMapSize;
//	static float dlgMapBias;
//	static float dlgMapRange;
//	static float dlgRayBias;
	static float dlgDecayRadius;
	static short dlgAtmosShadows;
	static float dlgAtmosOpacity;
	static float dlgAtmosColamt;
	static short dlgLightAffectShadColor;
	static short dlgUseShadowColorMap;
	static Color24 dlgShadColor;
	static float dlgShadMult;
	static Class_ID dlgShadType;
	static short dlgUseGlobalShadowParams;

	static short dlgEmitterEnable;
	static float dlgEmitterEnergy;
	static short dlgEmitterDecayType;
	static int	 dlgEmitterCAPhotons;
	static int	 dlgEmitterGIPhotons;

	static short globShadowType; 
	static short globAbsMapBias;
	static float globMapRange;
	static float globMapBias;
	static int   globMapSize;
	static float globRayBias;
	static short globAtmosShadows;
	static float globAtmosOpacity;
	static float globAtmosColamt;

	static ISpinnerControl *redSpin;
	static ISpinnerControl *greenSpin;
	static ISpinnerControl *blueSpin;
	static ISpinnerControl *hSpin;
	static ISpinnerControl *sSpin;
	static ISpinnerControl *vSpin;
	static ISpinnerControl *intensitySpin;
	static ISpinnerControl *contrastSpin;
	static ISpinnerControl *diffsoftSpin;
	static ISpinnerControl *hotsizeSpin;
	static ISpinnerControl *fallsizeSpin;
	static ISpinnerControl *tDistSpin;
	static ISpinnerControl *attenStartSpin;
	static ISpinnerControl *attenEndSpin;
	static ISpinnerControl *attenStart1Spin;
	static ISpinnerControl *attenEnd1Spin;
	static ISpinnerControl *aspectSpin;
	static ISpinnerControl *decaySpin;
	static ISpinnerControl *atmosOpacitySpin;
	static ISpinnerControl *atmosColAmtSpin;
	static ISpinnerControl *shadMultSpin;
	static ISpinnerControl *emitterEnergySpin;
	static ISpinnerControl *emitterCAPhotonsSpin;
	static ISpinnerControl *emitterGIPhotonsSpin;
	static IColorSwatch *colorSwatch;
	static IColorSwatch *shadColorSwatch;
	static ICustButton *projMapName;
	static ICustButton *shadProjMapName;
	static ProjMapDADMgr projDADMgr;
	static ShadowParamDlg *shadParamDlg;
	
	// Object parameters
	IParamBlock *pblock;
	Texmap *projMap;   // a reference
	Texmap *shadProjMap;   // a reference
	ShadowType *shadType;    // a reference
	IParamBlock *temppb;
	IParamBlock *emitter; // a reference
	short updateHSVSpin;
	short type;
	short enable;
	short useLight;		// on/off toggle
	short useAtten;
	short attenDisplay;
	short decayDisplay;
	short useAttenNear;
	short attenNearDisplay;
	short coneDisplay;
	short shape;
	short shadow;
	short useGlobalShadowParams;
	short shadowType;  // 0: ShadowMap   1: RayTrace
	short absMapBias;
	short overshoot;
	short projector;
	short softenDiffuse;
	short affectDiffuse;
	short affectSpecular;
	short decayType;
	short ltAffectsShadow;
	short ambientOnly;
	int extDispFlags;
	float targDist; 
	short atmosShadows;
	float atmosOpacity;
	float atmosColAmt;
	short emitterEnable;
	float emitterEnergy;
	short emitterDecayType;
	int   emitterCAPhotons;
	int   emitterGIPhotons;
	Mesh spotMesh;
	Mesh *mesh;
	NameTab exclList;
	void BuildStaticMeshes();
	void BuildSpotMesh(float coneSize);
	void UpdateUI(TimeValue t);

	//  inherited virtual methods for Reference-management
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );

	void GetMat(TimeValue t, INode* inode, ViewExp *vpt, Matrix3& mat);
	BOOL IsCompatibleRenderer ( void );
	
public:
	GeneralLight(int type);
	~GeneralLight();

	//  inherited virtual methods:

	// From GenLight
	GenLight *NewLight(int type) { return new GeneralLight(type); }

	// From BaseObject
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	void SetExtendedDisplay(int flags);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack();
	void UpdtShadowTypeList(HWND hwndDlg);
	void UpdtShadowTypeSel();
	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	TCHAR *GetObjectName();

	void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp* vpt, Box3& box );
	void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp* vpt,  Box3& box );
	void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s);
	Interval ObjectValidity(TimeValue t);
	BOOL UsesWireColor()	{ return 1; }
	int DoOwnSelectHilite() { return 1; }		

	// From Light
	RefResult EvalLightState(TimeValue t, Interval& valid, LightState* cs);
	int Type() { return type; }  // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
	void SetType(int t);             // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
#ifdef SIMPLEDIR
	BOOL IsSpot()	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT; }
#else
	BOOL IsSpot()	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT || type == DIR_LIGHT || type==TDIR_LIGHT; }
#endif
	BOOL IsDir()	{ return type == DIR_LIGHT|| type == TDIR_LIGHT; }
	void SetUseLight(int onOff);
	BOOL GetUseLight(void)		{ return useLight; }
	void SetSpotShape(int s);
	int GetSpotShape(void)	{ return shape; }
	void SetHotspot(TimeValue time, float f);
	float GetHotspot(TimeValue t, Interval& valid = Interval(0,0));
	void SetFallsize(TimeValue time, float f);
	float GetFallsize(TimeValue t, Interval& valid = Interval(0,0));
	void SetAtten(TimeValue time, int which, float f);
	float GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0));
	void SetTDist(TimeValue time, float f);
	float GetTDist(TimeValue t, Interval& valid = Interval(0,0));
	void SetDecayRadius(TimeValue time, float f);
	float GetDecayRadius(TimeValue t, Interval& valid = Interval(0,0));
	int GetShadowMethod() {return shadow?(shadowType==0?LIGHTSHADOW_MAPPED:LIGHTSHADOW_RAYTRACED):LIGHTSHADOW_NONE;}
	void ReloadShadCtrls(HWND hDlg, TimeValue t);	

	ObjLightDesc *CreateLightDesc(INode *n);
	
	// GenLight routines
	void SetRGBColor(TimeValue t, Point3& rgb);
	Point3 GetRGBColor(TimeValue t, Interval &valid = Interval(0,0));
	void SetHSVColor(TimeValue t, Point3& hsv);
	Point3 GetHSVColor(TimeValue t, Interval &valid = Interval(0,0));
	void SetShadColor(TimeValue t, Point3& rgb);
	Point3 GetShadColor(TimeValue t, Interval &valid = Interval(0,0));
	void SetShadMult(TimeValue t, float m);
    float GetShadMult(TimeValue t, Interval &valid = Interval(0,0));
	BOOL GetLightAffectsShadow() { return ltAffectsShadow; }
	void SetLightAffectsShadow(BOOL b) { ltAffectsShadow = b; }
	void SetUpdateHSVSpin(int b)	{ updateHSVSpin = b; }
	void SetIntensity(TimeValue time, float f);
	float GetIntensity(TimeValue t, Interval& valid = Interval(0,0));
	void SetContrast(TimeValue time, float f);
	float GetContrast(TimeValue t, Interval& valid = Interval(0,0));
	void SetDiffuseSoft(TimeValue time, float f);
	float GetDiffuseSoft(TimeValue t, Interval& valid = Interval(0,0));
	void SetAspect(TimeValue t, float f);
	float GetAspect(TimeValue t, Interval& valid = Interval(0,0));
	void SetConeDisplay(int s, int notify=TRUE);
	BOOL GetConeDisplay(void)		{ return coneDisplay; }
	void DrawX(TimeValue t, float asp, int npts, float dist, GraphicsWindow *gw, int indx);
	void DrawSphereArcs(TimeValue t, GraphicsWindow *gw, float r, Point3 *q);
    int GetCirXPoints(TimeValue t, float angle, float dist, Point3 *q);
	void BoxDirPoints(TimeValue t, float angle, float dist, Box3 &box, Matrix3 *tm);
	void BoxPoints(TimeValue t, float angle, float dist, Box3 &box, Matrix3 *tm);
	int GetRectXPoints(TimeValue t, float angle, float dist, Point3 *q);
	void DrawCircleX(TimeValue t, GraphicsWindow *gw, float angle, float dist, Point3 *q);
	void DrawWarpRect(TimeValue t, GraphicsWindow *gw, float angle, float dist, Point3 *q);
	void DrawAttenCirOrRect(TimeValue t, GraphicsWindow *gw, float dist, BOOL froze, int uicol);
	void GetConePoints(TimeValue t, float aspect, float angle, float dist, Point3 *q);
	void DrawCone(TimeValue t, GraphicsWindow *gw, float dist);
	int DrawConeAndLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing );
	void SetUseAtten(int s);
	BOOL GetUseAtten(void)			{ return useAtten; }
	void SetUseAttenNear(int s);	   	
	BOOL GetUseAttenNear(void)	   	{ return useAttenNear; }
	void SetAttenDisplay(int s);
	BOOL GetAttenDisplay(void)		{ return attenDisplay; }
	void SetAttenNearDisplay(int s);
	BOOL GetDecayDisplay(void)		{ return decayDisplay; }
	void SetDecayDisplay(int s);
	BOOL GetAttenNearDisplay(void)		{ return attenNearDisplay; }
	void GetAttenPoints(TimeValue t, float rad, Point3 *q);
	int DrawAtten(TimeValue t, INode *inode, GraphicsWindow *gw);
	void Enable(int enab) { enable = enab; }

	void BuildMeshes(BOOL isnew = TRUE);
	void FixHotFallConstraint();
	int GetUseGlobal() { return useGlobalShadowParams; }
	void SetUseGlobal(int a);
	int GetShadow() { return shadow; }
	void SetShadow(int a) { shadow = a; }
	int GetShadowType();
	void SetShadowType(int a);

	// Plug-in shadow generator
	void SetShadowGenerator(ShadowType *s);
	ShadowType * GetShadowGenerator() { return shadType; }
	ShadowType * ActiveShadowType();

	void SetMapBias(TimeValue t, float f);
	float GetMapBias(TimeValue t, Interval& valid = Interval(0,0));
	void SetMapRange(TimeValue t, float f);
	float GetMapRange(TimeValue t, Interval& valid = Interval(0,0));
	void SetMapSize(TimeValue t, int f);
	int GetMapSize(TimeValue t, Interval& valid = Interval(0,0));
	void SetRayBias(TimeValue t, float f);
	float GetRayBias(TimeValue t, Interval& valid = Interval(0,0));
	int GetAbsMapBias() { return useGlobalShadowParams ? globAbsMapBias : absMapBias; }
	void SetAbsMapBias(int a) {
		if (useGlobalShadowParams) 	globAbsMapBias = a; 
		else absMapBias = a; 
		}

	void SetAtmosShadows(TimeValue t, int onOff);
	int GetAtmosShadows(TimeValue t);
	void SetAtmosOpacity(TimeValue t, float f);
	float GetAtmosOpacity(TimeValue t, Interval& valid=FOREVER);
	void SetAtmosColAmt(TimeValue t, float f);
	float GetAtmosColAmt(TimeValue t, Interval& valid=FOREVER);
	void SetUseShadowColorMap(TimeValue t, int onOff);
	int GetUseShadowColorMap(TimeValue t);
	
	int GetOvershoot() { return overshoot; }
	void SetOvershoot(int a);
	int GetProjector() { return projector; }
	void SetProjector(int a) { projector = a; }
	void DoBitmapFit(HWND hwnd, TimeValue t);
	NameTab* GetExclList() {return &exclList; }
	BOOL Include() {return exclList.TestFlag(NT_INCLUDE); }
	Texmap* GetProjMap() { return projMap;  }
	void SetProjMap(Texmap* pmap);
	Texmap* GetShadowProjMap() { return shadProjMap;  }
	void SetShadowProjMap(Texmap* pmap);
	void UpdateTargDistance(TimeValue t, INode* inode);
	void AssignProjectorMap(Texmap *m, BOOL newmat);
	void AssignShadProjMap(Texmap *m, BOOL newmat);
	void BrowseProjectorMap(HWND hWnd);	
	void BrowseShadProjMap(HWND hWnd);

	NameTab& GetExclusionList() {return exclList;}
	void SetExclusionList(NameTab &list) {exclList = list;}

	BOOL SetHotSpotControl(Control *c);
	BOOL SetFalloffControl(Control *c);
	BOOL SetColorControl(Control *c);
	Control* GetHotSpotControl();
	Control* GetFalloffControl();
	Control* GetColorControl();
	void SetAffectDiffuse(BOOL onOff) { affectDiffuse = onOff; }
	BOOL GetAffectDiffuse() {return affectDiffuse; }
	void SetAffectSpecular(BOOL onOff) { affectSpecular = onOff; }
	BOOL GetAffectSpecular() {return affectSpecular; }
	void SetSoftenDiffuse(BOOL onOff) { softenDiffuse = onOff; }
	BOOL GetSoftenDiffuse() {return softenDiffuse; }
	void SetDecayType(BOOL onOff) { decayType = onOff; }
	BOOL GetDecayType() {return decayType; }
	void SetAmbientOnly(BOOL onOff) { ambientOnly = onOff; }
	BOOL GetAmbientOnly() {return ambientOnly; }

	void SetEmitterEnable(TimeValue t, BOOL onOff);
	BOOL GetEmitterEnable(TimeValue t, Interval& valid=FOREVER);
	void SetEmitterEnergy(TimeValue t, float energy);
	float GetEmitterEnergy(TimeValue t, Interval& valid=FOREVER);
	void SetEmitterDecayType(TimeValue t, int decay);
	int  GetEmitterDecayType(TimeValue t, Interval& valid=FOREVER);
	void SetEmitterCausticPhotons(TimeValue t, int photons);
	int  GetEmitterCausticPhotons(TimeValue t, Interval& valid=FOREVER);
	void SetEmitterGlobalIllumPhotons(TimeValue t, int photons);
	int  GetEmitterGlobalIllumPhotons(TimeValue t, Interval& valid=FOREVER);


	// internal routines
	void BoxCircle(TimeValue t, float r, float d, Box3& box, int extraPt=0, Matrix3 *tm=NULL);
	void BoxLight(TimeValue t, INode *inode, Box3& box, Matrix3 *tm=NULL);
	ISpinnerControl* AttenSpinner(int atype);
	void ChangeAtten(int atype);
	void UpdateColBrackets(TimeValue t);
	void SetSpinnerBracket(ISpinnerControl *spin, int pbid);
	void UpdateForAmbOnly();
	void PreSaveOld(); 
	void PostSaveOld(); 

	// Animatable methods
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return  Class_ID(OMNI_LIGHT_CLASS_ID+type,0); }  
	void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_LIGHT_CLASS)); }

	void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags); 
	
	int NumSubs() { 
		if ( IsCompatibleRenderer ()) 
			return 5;
		else
			return 4;
		}  
	Animatable* SubAnim(int i) {
		switch(i) {
			case PBLOCK_REF: return (Animatable*)pblock;
			case PROJMAP_REF: return (Animatable*)projMap;
			case SHADPROJMAP_REF: return (Animatable*)shadProjMap;
			case SHADTYPE_REF: return (Animatable*)shadType;
			case EMITTER_REF: 
				if ( IsCompatibleRenderer ())
					return (Animatable*)emitter;
				else
					return NULL;
			default: return NULL;
			}
		 }
	TSTR SubAnimName(int i) { 
		switch(i) {
			case PBLOCK_REF: return TSTR(GetString(IDS_RB_PARAMETERS));
			case PROJMAP_REF: return TSTR(GetString(IDS_DS_PROJMAP));
			case SHADPROJMAP_REF: return TSTR(GetString(IDS_DS_SHADPROJMAP));
			case SHADTYPE_REF: return TSTR(GetString(IDS_DS_SHAD_GEN));
			case EMITTER_REF: 
				if ( IsCompatibleRenderer ())
					return TSTR(GetString(IDS_EMITTER));
				else
					return _T("");
			default: return _T("");
			}
		}

	// From ref
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	int NumRefs() { 
		if ( GetSavingVersion() == 2000 )
			return 2;
		else
			return 5;
		}
	RefTargetHandle GetReference(int i) {
		switch(i) {
			case PBLOCK_REF: return (RefTargetHandle)(temppb?temppb:pblock);
			case PROJMAP_REF: return (RefTargetHandle)projMap;
			case SHADPROJMAP_REF: return (RefTargetHandle)shadProjMap;
			case SHADTYPE_REF: return (RefTargetHandle)shadType;
			case EMITTER_REF: return (RefTargetHandle)emitter;
			}
		return NULL;
		}

	void SetReference(int i, RefTargetHandle rtarg) {
		switch(i) {
			case PBLOCK_REF:
				pblock=(IParamBlock*)rtarg; 
				break;
			case PROJMAP_REF:
				projMap = (Texmap *)rtarg;
				if (projMapName) 
					projMapName->SetText(projMap?projMap->GetFullName().data():GetString(IDS_DB_NONE));
				break;
			case SHADPROJMAP_REF:
				shadProjMap = (Texmap *)rtarg;
				if (shadProjMapName) 
					shadProjMapName->SetText(shadProjMap?shadProjMap->GetFullName().data():GetString(IDS_DB_NONE));
				break;
			case SHADTYPE_REF:
				shadType = (ShadowType *)rtarg;
				break;
			case EMITTER_REF:
				emitter = (IParamBlock*)rtarg; 
				break;

			}
		}

	// IO
	void FixOldVersions(ILoad *iload);
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
            WPARAM wParam,   LPARAM lParam ){return(0);}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\morphobj.cpp ===
/**********************************************************************
 *<
	FILE: morphobj.cpp

	DESCRIPTION:  Morph object

	CREATED BY: Rolf Berteig

	HISTORY: created 21 August 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"

Control *newDefaultMorphControl();

class MorphObject;

#define TARG_COPY		0
#define TARG_REF		1
#define TARG_INSTANCE	2
#define TARG_MOVE		3


class PickTarget;

class MorphObject: public GeomObject {			   
		
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
				
	public:
		MorphControl *morphCont;
		int sel;

		static IObjParam *ip;
		static HWND hParams1;
		static HWND hParams2;
		static PickTarget pickCB;
		static int addTargMethod;
		static MorphObject *editOb;
		static BOOL creating;

		MorphObject(BOOL loading=FALSE);
		~MorphObject();
		void SetupTargetList();
		int AddTargMethod();
		void SetTargMethod(int m);
		void AddNewTarget(INode *node,TimeValue t,int m);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();		
		TCHAR *GetObjectName() { return GetString(IDS_RB_MORPH); }

		// From Object		
		void InitNodeName(TSTR& s) {s = GetString(IDS_RB_MORPH);}
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
        BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts);
		ObjectState Eval(TimeValue time);
		int NumPipeBranches();
		Object *GetPipeBranch(int i);
		BOOL HasUVW() {return morphCont->HasUVW();}
		void SetGenUVW(BOOL sw) {morphCont->SetGenUVW(sw);}

		// From GeomObject		
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation
		int IntersectRay(TimeValue t, Ray& r, float& at) {return 0;}

		// Animatable methods
		Class_ID ClassID() {return Class_ID(MORPHOBJ_CLASS_ID,0);}  
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_MORPHOBJECT_CLASS);}
		void DeleteThis() {delete this;}				
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		BOOL AssignController(Animatable *control,int subAnim);

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		// From ref
		RefTargetHandle Clone(RemapDir& remap);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return morphCont;}
		void SetReference(int i, RefTargetHandle rtarg) {morphCont = (MorphControl*)rtarg;}
	};				

class PickTarget : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		MorphObject *mo;				

		PickTarget() {mo=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
		BOOL AllowMultiSelect() {return TRUE;}
	};


IObjParam *MorphObject::ip                 = NULL;
HWND MorphObject::hParams1                 = NULL;
HWND MorphObject::hParams2                 = NULL;
int MorphObject::addTargMethod             = TARG_INSTANCE;
MorphObject *MorphObject::editOb           = NULL;
BOOL MorphObject::creating                 = FALSE;
PickTarget MorphObject::pickCB;

class MorphObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new MorphObject(loading);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_MORPH_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(MORPHOBJ_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_COMPOUNDOBJECTS);}
	BOOL			OkToCreate(Interface *i);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	};

void MorphObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	MorphObject::addTargMethod = TARG_INSTANCE;
	}

BOOL MorphObjClassDesc::OkToCreate(Interface *i)
	{
	if (i->GetSelNodeCount()!=1) return FALSE;	
	ObjectState os = i->GetSelNode(0)->GetObjectRef()->Eval(i->GetTime());	
	if (os.obj->IsParticleSystem()) return FALSE;
	return os.obj->IsDeformable() || os.obj->CanConvertToType(defObjectClassID);
	}

static MorphObjClassDesc morphObjDesc;

ClassDesc* GetMorphObjDesc() { return &morphObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

//----------------------------------------------------------------------

#define CID_CREATEMORPHMODE		0x8F525AB2

class CreateMorphProc : public MouseCallBack {
	public:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		int proc( 
			HWND hWnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

int CreateMorphProc::proc( 
		HWND hWnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m ) 
	{
	switch (msg) {
		case MOUSE_POINT:
			ip->SetActiveViewport(hWnd);
			break;
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
// mjm - 3.1.99
		case MOUSE_PROPCLICK:
			// right click while between creations
			ip->RemoveMode(NULL);
			break;
// mjm - end
		}	
	return TRUE;
	}

class CreateMorphMode : public CommandMode, ReferenceMaker {		
	public:		
		CreateMorphProc proc;
		INode *node, *svNode;
		IObjParam *ip;
		MorphObject *obj;

		void Begin(INode *n,IObjParam *i);
		void End(IObjParam *i);		
		void JumpStart(IObjParam *i,MorphObject *o);

		int Class() { return CREATE_COMMAND; }
		int ID() { return CID_CREATEMORPHMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 1; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG(CommandMode *oldMode) {return TRUE;}
		void EnterMode() {}
		void ExitMode() {}
		
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return node;}
		void SetReference(int i, RefTargetHandle rtarg) {node = (INode*)rtarg;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);		
	};
static CreateMorphMode theCreateMorphMode;

RefResult CreateMorphMode::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,
		RefMessage message)
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:		
		case REFMSG_TARGET_DELETED:			
			if (ip) ip->StopCreating();
			break;

		}
	return REF_SUCCEED;
	}

class CreateMorphRestore : public RestoreObj {
	public:   		
		void Restore(int isUndo) {
			if (theCreateMorphMode.ip) {
				// Jump out of boolean create mode.
				theCreateMorphMode.ip->SetStdCommandMode(CID_OBJMOVE);
				}
			}	
		void Redo() {}
		TSTR Description() {return TSTR(_T("Create Morph"));}
	};

// Sending the REFMSG_NOTIFY_PASTE message notifies the modify
// panel that the Node's object reference has changed when
// undoing or redoing.
class CreateMorphNotify : public RestoreObj {
	public:   		
		MorphObject *obj;
		BOOL which;
		CreateMorphNotify(MorphObject *o, BOOL w) {
			obj = o; which = w;
			}
		void Restore(int isUndo) {
			if (which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}	
		void Redo() {
			if (!which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}
		TSTR Description() {return TSTR(_T("Create Morph Notify"));}
	};

void CreateMorphMode::Begin(INode *n,IObjParam *i) 
	{
	MakeRefByID(FOREVER,0,n);
	svNode = node;
	assert(node);
	ip = i;
	proc.Init(ip);

	theHold.Begin();
	theHold.Put(new CreateMorphRestore);

	obj = new MorphObject;
	
	theHold.Put(new CreateMorphNotify(obj,1));

	TSTR name = TSTR(_T("M_")) + node->GetName();
	SetMorphTargetPacket pckt(node->GetObjectRef(),name);
	obj->morphCont->SetValue(0,&pckt);
	
	node->SetObjectRef(obj);
	
	theHold.Put(new CreateMorphNotify(obj,0));

	theHold.Accept(IDS_DS_CREATE);

	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

void CreateMorphMode::End(IObjParam *i)
	{
	svNode = node;
	if (obj) obj->EndEditParams(i,END_EDIT_REMOVEUI,NULL);
	DeleteAllRefsFromMe();
	ip  = NULL;
	obj = NULL;
	}

void CreateMorphMode::JumpStart(IObjParam *i,MorphObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int MorphObjClassDesc::BeginCreate(Interface *i)
	{	
	assert(i->GetSelNodeCount()==1);

	theCreateMorphMode.Begin(i->GetSelNode(0),(IObjParam*)i);
	i->PushCommandMode(&theCreateMorphMode);
	return TRUE;
	}

int MorphObjClassDesc::EndCreate(Interface *i)
	{
	theCreateMorphMode.End((IObjParam*)i);
	i->RemoveMode(&theCreateMorphMode);
	return TRUE;
	}

//----------------------------------------------------------------------

BOOL PickTarget::Filter(INode *node)
	{
	if (node) {
		if (mo->morphCont->ValidTarget(
				mo->ip->GetTime(),
				node->GetObjectRef())) {			
			return TRUE;
			}
		}

	return FALSE;
	}

BOOL PickTarget::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) {
		if (mo->morphCont->ValidTarget(
				mo->ip->GetTime(),
				node->GetObjectRef())) {			
			return TRUE;
			}
		}

	return FALSE;
	}

BOOL PickTarget::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	if (mo->morphCont->
			ValidTarget(
				mo->ip->GetTime(),
				node->GetObjectRef())) {
		mo->AddNewTarget(node,mo->ip->GetTime(),mo->AddTargMethod());
		mo->SetupTargetList();
		ip->RedrawViews(ip->GetTime());
		}
	return FALSE;
	}

void PickTarget::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(mo->hParams1,IDC_PICK_MORPHTARG));
	iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void PickTarget::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(mo->hParams1,IDC_PICK_MORPHTARG));
	iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}



//----------------------------------------------------------------------

MorphObject::MorphObject(BOOL loading)
	{
	sel = -1;
	morphCont = NULL;
	if (!loading) 
		MakeRefByID(FOREVER,0,newDefaultMorphControl());	
	}

MorphObject::~MorphObject()
	{
	DeleteAllRefsFromMe();
	}
		

class MorphObjCreateCallBack: public CreateMouseCallBack {	
	MorphObject *ob;	
	public:
		int proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(MorphObject *obj) {ob = obj;}
	};

int MorphObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 pt;

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				pt = vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				break;
			case 1:								
				pt = vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				if (msg==MOUSE_POINT) 
					return CREATE_STOP;
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	return TRUE;
	}

static MorphObjCreateCallBack morphCreateCB;

CreateMouseCallBack* MorphObject::GetCreateMouseCallBack()
	{
	morphCreateCB.SetObj(this);
	return &morphCreateCB;
	}

Interval MorphObject::ObjectValidity(TimeValue t)
	{	
	return Interval(t,t);
	}

int MorphObject::CanConvertToType(Class_ID obtype)
	{
	ObjectState os = Eval(0);
	return os.obj->CanConvertToType(obtype);
	}

Object* MorphObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	ObjectState os = Eval(t);
	Object *obj = os.obj->ConvertToType(t,obtype);
	if (!obj) return NULL;
	return (Object*)obj->Clone();
	}

BOOL MorphObject::PolygonCount(TimeValue t, int& faceCount, int& vertCount)
	{
	ObjectState os = Eval(t);
	Object *obj = os.obj;
	if (!obj) return FALSE;
	return obj->PolygonCount(t, faceCount, vertCount);
	}

ObjectState MorphObject::Eval(TimeValue time)
	{
	ObjectState os;
	Interval valid;
	morphCont->GetValue(time,&os,valid);
	return os;
	}

void MorphObject::AddNewTarget(INode *node,TimeValue t,int m)
	{
	Object *obj = NULL;
	BOOL delnode = FALSE;

	switch (m) {
		case TARG_REF:
			obj = MakeObjectDerivedObject(node->GetObjectRef());
			break;
		
		case TARG_INSTANCE:
			obj = node->GetObjectRef();
			break;

		case TARG_COPY:
			obj = (Object*)node->GetObjectRef()->Clone();
			break;

		case TARG_MOVE:
			obj = node->GetObjectRef();
			delnode = TRUE;
			break;

		default:
			return;
		}

	theHold.Begin();

	TSTR name = TSTR(_T("M_")) + node->GetName();
	Matrix3 tm = node->GetObjectTM(t)*Inverse(node->GetNodeTM(t));
	SetMorphTargetPacket pckt(obj,name,tm);
	morphCont->SetValue(t,&pckt);

	if (delnode && ip) {
		ip->DeleteNode(node);
		}

	theHold.Accept(GetString(IDS_RB_PICKMORPHTARGET));
	}

void MorphObject::SetupTargetList()
	{
	if (!morphCont) return;
	SendMessage(GetDlgItem(hParams2,IDC_MORPHTARG_LIST),LB_RESETCONTENT,0,0);
	for (int i=0; i<morphCont->NumMorphTargs(); i++) {
		SendMessage(GetDlgItem(hParams2,IDC_MORPHTARG_LIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)SubAnimName(i));
		}
	if (sel>=0) {
		SendMessage(GetDlgItem(hParams2,IDC_MORPHTARG_LIST),
			LB_SETCURSEL,sel,0);
		EnableWindow(GetDlgItem(hParams2,IDC_CREATE_MORPHKEY),TRUE);
		EnableWindow(GetDlgItem(hParams2,IDC_DELETE_MORPHTARG),TRUE);

		ICustEdit *edit = GetICustEdit(GetDlgItem(hParams2,IDC_MORPHTARG_NAME));
		edit->Enable();
		edit->SetText(SubAnimName(sel));
		ReleaseICustEdit(edit);
	} else {
		EnableWindow(GetDlgItem(hParams2,IDC_CREATE_MORPHKEY),FALSE);
		EnableWindow(GetDlgItem(hParams2,IDC_DELETE_MORPHTARG),FALSE);
		
		ICustEdit *edit = GetICustEdit(GetDlgItem(hParams2,IDC_MORPHTARG_NAME));
		edit->Disable();
		edit->SetText(_T(""));
		ReleaseICustEdit(edit);
		}
	}

int MorphObject::AddTargMethod()
	{
	if (IsDlgButtonChecked(hParams1,IDC_TARG_REFERENCE)) {
		return TARG_REF;
		}
	if (IsDlgButtonChecked(hParams1,IDC_TARG_COPY)) {
		return TARG_COPY;
		}
	if (IsDlgButtonChecked(hParams1,IDC_TARG_INSTANCE)) {
		return TARG_INSTANCE;
		}
	if (IsDlgButtonChecked(hParams1,IDC_TARG_MOVE)) {
		return TARG_MOVE;
		}
	return TARG_INSTANCE;	
	}

void MorphObject::SetTargMethod(int m)
	{
	CheckDlgButton(hParams1,IDC_TARG_REFERENCE,FALSE);
	CheckDlgButton(hParams1,IDC_TARG_COPY,FALSE);
	CheckDlgButton(hParams1,IDC_TARG_INSTANCE,FALSE);
	CheckDlgButton(hParams1,IDC_TARG_MOVE,FALSE);
	switch (m) {
		case TARG_REF:
			CheckDlgButton(hParams1,IDC_TARG_REFERENCE,TRUE);
			break;
		case TARG_COPY:
			CheckDlgButton(hParams1,IDC_TARG_COPY,TRUE);
			break;
		case TARG_INSTANCE:
			CheckDlgButton(hParams1,IDC_TARG_INSTANCE,TRUE);
			break;
		case TARG_MOVE:
			CheckDlgButton(hParams1,IDC_TARG_MOVE,TRUE);
			break;
		}
	}

static BOOL CALLBACK MorphParamDlgProc1( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	MorphObject *mo = (MorphObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mo && message!=WM_INITDIALOG) return FALSE;

	switch (message) {
		case WM_INITDIALOG: {
			mo = (MorphObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mo->hParams1 = hWnd;			
			
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_PICK_MORPHTARG));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			
			mo->SetTargMethod(mo->addTargMethod);
			break;
			}

		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_PICK_MORPHTARG:
					if (mo->ip->GetCommandMode()->ID() == CID_STDPICK) {
						if (mo->creating) {
							theCreateMorphMode.JumpStart(mo->ip,mo);
							mo->ip->SetCommandMode(&theCreateMorphMode);
						} else {
							mo->ip->SetStdCommandMode(CID_OBJMOVE);
							}
					} else {
						mo->pickCB.mo = mo;
						mo->ip->SetPickMode(&mo->pickCB);						
						}
					break;				
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			mo->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK MorphParamDlgProc2( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	MorphObject *mo = (MorphObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!mo && message!=WM_INITDIALOG) return FALSE;

	switch (message) {
		case WM_INITDIALOG: {
			mo = (MorphObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mo->hParams2 = hWnd;
			mo->SetupTargetList();			
			break;
			}

		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_CREATE_MORPHKEY: {
					TSTR name;
					Matrix3 tm = mo->morphCont->GetMorphTargTM(mo->sel);
					SetMorphTargetPacket pckt(
						mo->morphCont->GetMorphTarg(mo->sel),name,
						tm,TRUE);
					theHold.Begin();
					mo->morphCont->SetValue(mo->ip->GetTime(),&pckt);
					theHold.Accept(GetString(IDS_RB_CREATEMORPHKEY));
					mo->ip->RedrawViews(mo->ip->GetTime());
					break;
					}

				case IDC_MORPHTARG_LIST:
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						mo->sel = SendMessage(
							GetDlgItem(mo->hParams2,IDC_MORPHTARG_LIST),
							LB_GETCURSEL,0,0);						
						if (mo->sel < 0) {
							EnableWindow(GetDlgItem(hWnd,IDC_CREATE_MORPHKEY),FALSE);
							EnableWindow(GetDlgItem(hWnd,IDC_DELETE_MORPHTARG),FALSE);
							ICustEdit *edit = GetICustEdit(GetDlgItem(hWnd,IDC_MORPHTARG_NAME));
							edit->Disable();
							edit->SetText(_T(""));
							ReleaseICustEdit(edit);
						} else {
							EnableWindow(GetDlgItem(hWnd,IDC_CREATE_MORPHKEY),TRUE);
							EnableWindow(GetDlgItem(hWnd,IDC_DELETE_MORPHTARG),TRUE);
							ICustEdit *edit = GetICustEdit(GetDlgItem(hWnd,IDC_MORPHTARG_NAME));
							edit->Enable();
							edit->SetText(mo->SubAnimName(mo->sel));
							ReleaseICustEdit(edit);
							}
						mo->NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
						}
					break;

				case IDC_DELETE_MORPHTARG:
					if (mo->sel>=0) {
						theHold.Begin();
						mo->morphCont->DeleteMorphTarg(mo->sel);
						theHold.Accept(GetString(IDS_RB_DELETEMORPHTARG));
						mo->sel = -1;
						mo->SetupTargetList();
						mo->ip->RedrawViews(mo->ip->GetTime());
						//GetSystemSetting(SYSSET_CLEAR_UNDO);
						}
					break;					
				}
			break;

		case WM_CUSTEDIT_ENTER:
			if (LOWORD(wParam)==IDC_MORPHTARG_NAME && mo->sel >= 0) {
				ICustEdit *edit = GetICustEdit(GetDlgItem(hWnd,IDC_MORPHTARG_NAME));
				TCHAR buf[256];
				edit->GetText(buf,256);
				mo->morphCont->SetMorphTargName(mo->sel,TSTR(buf));
				mo->SetupTargetList();
				mo->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				ReleaseICustEdit(edit);				
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			mo->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void MorphObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	this->ip = ip;
	editOb   = this;
	//pickMode = new PickTargCommandMode(this,ip);	
	
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else {
		creating = FALSE;
		}
	if (!hParams1) {
		hParams1 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_MORPHPARAM1),
				MorphParamDlgProc1, 
				GetString(IDS_RB_PICKTARGETS), 
				(LPARAM)this);		
		ip->RegisterDlgWnd(hParams1);
		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_MORPHPARAM2),
				MorphParamDlgProc2, 
				GetString(IDS_RB_CURRENTTARGETS), 
				(LPARAM)this);		
		ip->RegisterDlgWnd(hParams1);
	} else {
		SetWindowLong(hParams1,GWL_USERDATA,(LONG)this);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
		SetupTargetList();
		SetTargMethod(addTargMethod);
		}
	}

void MorphObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	//ip->DeleteMode(pickMode);
	//delete pickMode;
	//pickMode = NULL;
	ip->ClearPickMode();
	editOb   = NULL;
	creating = FALSE;

	addTargMethod = AddTargMethod();

	if (flags&END_EDIT_REMOVEUI) {
		ip->UnRegisterDlgWnd(hParams1);
		ip->DeleteRollupPage(hParams1);
		hParams1 = NULL;
		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;
	} else {
		SetWindowLong(hParams1,GWL_USERDATA,(LONG)NULL);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
		}	
	ip = NULL;
	}

int MorphObject::NumPipeBranches() 
	{
	if (sel>=0) return 1;
	else return 0;
	}

Object *MorphObject::GetPipeBranch(int i) 
	{
	assert(sel>=0&&sel<morphCont->NumMorphTargs());
	return morphCont->GetMorphTarg(sel);
	}

int MorphObject::NumSubs()
	{
	return morphCont->NumMorphTargs()+1;
	}

Animatable* MorphObject::SubAnim(int i)
	{
	if (i==morphCont->NumMorphTargs()) {
		return morphCont;
	} else {
		return morphCont->GetMorphTarg(i);
		}
	}

TSTR MorphObject::SubAnimName(int i)
	{	
	if (i>=morphCont->NumMorphTargs()) {
		return GetString(IDS_RB_MORPH);
	} else {		
		TSTR name;
		morphCont->GetMorphTargName(i,name);		
		return name;
		}
	}

BOOL MorphObject::AssignController(Animatable *control,int subAnim)
	{
	if (subAnim==morphCont->NumMorphTargs()) {
		ReplaceReference(0,(ReferenceTarget*)control);
		NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		if (editOb==this) SetupTargetList();
		return TRUE;
		}
	return FALSE;
	}

RefTargetHandle MorphObject::Clone(RemapDir& remap)
	{
	MorphObject *obj = new MorphObject(TRUE);
	obj->ReplaceReference(0,morphCont->Clone(remap));
	obj->sel = sel;
	return obj;
	}

RefResult MorphObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message) 
	{
	switch (message) {
		case REFMSG_SELECT_BRANCH: {
			sel = morphCont->GetFlaggedTarget();
			break;
			}

		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			if (editOb==this) SetupTargetList();
			break;
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\patchgrd.cpp ===
/**********************************************************************
 *<
	FILE: patchgrd.cpp

	DESCRIPTION:  A Quad Patch Grid object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 22 June 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "iparamm.h"
#include "surf_api.h"
#include "tessint.h"
#include "MeshDelta.h"

// Parameter block indices
#define PB_LENGTH	0
#define PB_WIDTH	1
#define PB_WSEGS	2
#define PB_LSEGS	3
#define PB_TEXTURE	4

// Non-parameter block indices
#define PB_TI_POS			0
#define PB_TI_LENGTH		1
#define PB_TI_WIDTH			2

class QuadPatchCreateCallBack;

#define BMIN_LENGTH		float(0)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)

#define BDEF_DIM		float(0)
#define BDEF_SEGS		1
#define BMIN_SEGS		1
#define BMAX_SEGS		100

class QuadPatchObject : public GeomObject, public IParamArray {			   
	friend class QuadPatchCreateCallBack;
	friend BOOL CALLBACK QuadPatchParamDialogProc( HWND hDlg, UINT message, 
		WPARAM wParam, LPARAM lParam );
	
	public:
		// Object parameters		
		IParamBlock *pblock;
		Interval ivalid;
		int creating;

		// Class vars
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgLSegs;
		static int dlgWSegs;
		static BOOL dlgTexture;
		static Point3 crtPos;		
		static float crtWidth, crtLength;
		static QuadPatchObject *editOb;

		// Caches
		PatchMesh patch;

		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
		void BuildPatch(TimeValue t,PatchMesh& amesh);
		void GetBBox(TimeValue t, Matrix3 &tm, Box3& box);

		QuadPatchObject();
		~QuadPatchObject();

		void InvalidateUI();
		void PatchMeshInvalid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:		

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		void PrepareMesh(TimeValue t);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags, Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next );
		TCHAR *GetObjectName() { return GetString(IDS_TH_QUADPATCH); }

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_QUADPATCH); }		
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		
		// From GeomObject
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vxt, Box3& box );
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );

		PatchMesh& GetPatchMesh(TimeValue t);
		void UpdatePatchMesh(TimeValue t);

		// Animatable methods
		void DeleteThis() { delete this; }
		void FreeCaches(); 
		Class_ID ClassID() { return Class_ID( PATCHGRID_CLASS_ID, 0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_QUADPATCHOBJECT_CLASS)); }		
		
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_TH_PARAMETERS));}		
		int IsKeyable() { return 1;}
		BOOL BypassTreeView() { return FALSE; }

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

		// IO
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// Automatic texture support
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
	};				

//------------------------------------------------------

class QuadPatchClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new QuadPatchObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_QUAD_PATCH_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(PATCHGRID_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_PATCH_GRIDS);  }
	void			ResetClassParams(BOOL fileReset);
	};

static QuadPatchClassDesc quadPatchDesc;

ClassDesc* GetQuadPatchDesc() { return &quadPatchDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IParamMap *QuadPatchObject::pmapParam  = NULL;
IParamMap *QuadPatchObject::pmapTypeIn = NULL;
IObjParam *QuadPatchObject::ip;
int QuadPatchObject::dlgLSegs = BDEF_SEGS;
int QuadPatchObject::dlgWSegs = BDEF_SEGS;
BOOL QuadPatchObject::dlgTexture = FALSE;
Point3 QuadPatchObject::crtPos         = Point3(0,0,0);		
float QuadPatchObject::crtWidth        = 0.0f; 
float QuadPatchObject::crtLength       = 0.0f;
QuadPatchObject *QuadPatchObject::editOb = NULL;

void QuadPatchClassDesc::ResetClassParams(BOOL fileReset)
	{
	QuadPatchObject::dlgLSegs = BDEF_SEGS;
	QuadPatchObject::dlgWSegs = BDEF_SEGS;
	QuadPatchObject::dlgTexture = FALSE;
	QuadPatchObject::crtWidth   = 0.0f; 
	QuadPatchObject::crtLength  = 0.0f;
	QuadPatchObject::crtPos     = Point3(0,0,0);
	}

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	

	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),
			
	};
#define TYPEINDESC_LENGTH 3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	
	
	// Length Segments
	ParamUIDesc(
		PB_LSEGS,
		EDITTYPE_INT,
		IDC_LSEGS,IDC_LSEGSPIN,
		(float)BMIN_SEGS,(float)BMAX_SEGS,
		0.1f),
	
	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_WSEGS,IDC_WSEGSPIN,
		(float)BMIN_SEGS,(float)BMAX_SEGS,
		0.1f),
	
	// Gen UVs
	ParamUIDesc(PB_TEXTURE,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 5


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
 };
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
 };
#define PBLOCK_LENGTH	5

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0)			
	};
#define NUM_OLDVERSIONS	1	

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class QuadPatchTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		QuadPatchObject *ob;

		QuadPatchTypeInDlgProc(QuadPatchObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL QuadPatchTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {					
					if (ob->crtLength==0.0) return TRUE;
					if (ob->crtWidth==0.0) return TRUE;

					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));

					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_LENGTH,0,ob->crtLength);
						ob->pblock->SetValue(PB_WIDTH,0,ob->crtWidth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);					
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void QuadPatchObject::BeginEditParams( IObjParam *ip, ULONG flags, Animatable *prev )
	{
	editOb = this;
	this->ip = ip;
	
	if (pmapTypeIn && pmapParam) {
		
		// Left over from last shape ceated
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PATCHGRIDPARAM2),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_PATCHGRIDPARAM),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new QuadPatchTypeInDlgProc(this));
		}
	}
		
void QuadPatchObject::EndEditParams( IObjParam *ip, ULONG flags, Animatable *next )
	{
	editOb = NULL;
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_LSEGS,ip->GetTime(),dlgLSegs,FOREVER);
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);	
	pblock->GetValue(PB_TEXTURE,ip->GetTime(),dlgTexture,FOREVER);	
	}

PatchMesh &QuadPatchObject::GetPatchMesh(TimeValue t) {
	UpdatePatchMesh(t);
	return patch;
	}

void QuadPatchObject::UpdatePatchMesh(TimeValue t) {
	if ( ivalid.InInterval(t) )
		return;
	BuildPatch(t,patch);
	}

void QuadPatchObject::FreeCaches() {
	ivalid.SetEmpty();
	patch.FreeAll();
	}

// Quad patch layout
//
//   A---> ad ----- da <---D
//   |                     |
//   |                     |
//   v                     v
//   ab    i1       i4     dc
//
//   |                     |
//   |                     |
// 
//   ba    i2       i3     cd
//   ^					   ^
//   |                     |
//   |                     |
//   B---> bc ----- cb <---C
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

void QuadPatchObject::BuildPatch(TimeValue t,PatchMesh& amesh)
	{
	int ix,iy,np,kv;
	int wsegs,lsegs,nv;
	Point3 v,p;
	float l, w;
	int tex;
	
	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	pblock->GetValue( PB_LENGTH, t, l, ivalid );
	pblock->GetValue( PB_WIDTH, t, w, ivalid );
	pblock->GetValue( PB_LSEGS, t, lsegs, ivalid );
	pblock->GetValue( PB_WSEGS, t, wsegs, ivalid );
	pblock->GetValue( PB_TEXTURE, t, tex, ivalid );

	LimitValue(lsegs, BMIN_SEGS, BMAX_SEGS);
	LimitValue(wsegs, BMIN_SEGS, BMAX_SEGS);

	int lv = lsegs + 1;
	int wv = wsegs + 1;

	int nverts = lv * wv;
	int npatches = lsegs * wsegs;
	int nexteriors = npatches * 4 + lsegs * 2 + wsegs * 2;
	int ninteriors = npatches * 4;
	int nvecs = ninteriors + nexteriors;

	amesh.setNumVerts(nverts);
	amesh.setNumTVerts(tex ? nverts : 0);
	amesh.setNumVecs(nvecs);
	amesh.setNumPatches(npatches);
	amesh.setNumTVPatches(tex ? npatches : 0);

	v =  Point3(-w, -l, 0.0f) / 2.0f;   

	float dx = w/wsegs;
	float dy = l/lsegs;
	float fws = (float)wsegs;
	float fls = (float)lsegs;

	// Create the vertices.
	nv = 0;
	p.z = v.z;
	p.y = v.y;
	for(iy=0; iy<=lsegs; iy++) {
		p.x = v.x;
		for (ix=0; ix<=wsegs; ix++) {
			if(tex)
				amesh.setTVert(nv, UVVert((float)ix / fws, (float)iy / fls, 0.0f));
			amesh.verts[nv].flags = PVERT_COPLANAR;
			amesh.setVert(nv++, p);
			p.x += dx;
			}
		p.y += dy;
		}

	// Create patches.
	np = 0;
	int interior = nexteriors;
	int vecRowInc = lsegs * 2;
	int vecColInc = wsegs * 2;
	for(iy=0; iy<lsegs; iy++) {
		kv = iy*(wsegs+1);
		int rv = iy * vecColInc;	// Row vector start
		int cv = vecColInc * lv + iy * 2;	// column vector start
		for (ix=0; ix<wsegs; ix++,++np) {
			Patch &p = amesh.patches[np];
			int a = kv, b = kv+1, c = kv+wsegs+2, d = kv + wsegs + 1;
			int ab = rv, ba = rv+1;
			int bc = cv+vecRowInc, cb = cv + vecRowInc + 1;
			int cd = rv+vecColInc+1, dc = rv+vecColInc;
			int da = cv + 1, ad = cv;
			amesh.MakeQuadPatch(np, a, ab, ba, b, bc, cb, c, cd, dc, d, da, ad, interior, interior+1, interior+2, interior+3, 1);
			if(tex)
				amesh.getTVPatch(np).setTVerts(a,b,c,d);
			// Create the default vectors
			Point3 pa = amesh.getVert(a).p;
			Point3 pb = amesh.getVert(b).p;
			Point3 pc = amesh.getVert(c).p;
			Point3 pd = amesh.getVert(d).p;
			amesh.setVec(ab, pa + (pb - pa) / 3.0f);
			amesh.setVec(ba, pb - (pb - pa) / 3.0f);
			amesh.setVec(bc, pb + (pc - pb) / 3.0f);
			amesh.setVec(cb, pc - (pc - pb) / 3.0f);
			amesh.setVec(cd, pc + (pd - pc) / 3.0f);
			amesh.setVec(dc, pd - (pd - pc) / 3.0f);
			amesh.setVec(da, pd + (pa - pd) / 3.0f);
			amesh.setVec(ad, pa - (pa - pd) / 3.0f);
			kv++;
			cv += vecRowInc;
			rv += 2;
			interior += 4;
			}
		}
	// Verify that we have the right number of parts!
	assert(np==npatches);
	assert(nv==nverts);
	// Finish up patch internal linkages (and bail out if it fails!)
	assert(amesh.buildLinkages());
	// Calculate the interior bezier points on the PatchMesh's patches
	amesh.computeInteriors();
	amesh.InvalidateGeomCache();
	// Tell the PatchMesh it just got changed
	amesh.InvalidateMesh();
	}

QuadPatchObject::QuadPatchObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_LSEGS,0,dlgLSegs);
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);
	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);
	pblock->SetValue(PB_TEXTURE,0,dlgTexture);

	ivalid.SetEmpty();
	creating = 0;	
	}

QuadPatchObject::~QuadPatchObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}

class QuadPatchCreateCallBack: public CreateMouseCallBack {
	QuadPatchObject *ob;
	Point3 p0,p1;
	IPoint2 sp0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(QuadPatchObject *obj) { ob = obj; }
	};

int QuadPatchCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->creating = 1;	// tell object we're building it so we can disable snapping to itself
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				p1 = p0 + Point3(0.01f,0.01f,0.0f);
				mat.SetTrans(float(.5)*(p0+p1));				
				ob->pblock->SetValue(PB_WIDTH,0,0.0f);
				ob->pblock->SetValue(PB_LENGTH,0,0.0f);
				ob->pmapParam->Invalidate();
				break;
			case 1:
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(float(.5)*(p0+p1));
				d = p1-p0;
				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pmapParam->Invalidate();										
				if (msg==MOUSE_POINT) {
					ob->creating = 0;
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f) ? CREATE_ABORT: CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		ob->creating = 0;
		return CREATE_ABORT;
		}

	return TRUE;
	}

static QuadPatchCreateCallBack patchCreateCB;

CreateMouseCallBack* QuadPatchObject::GetCreateMouseCallBack() {
	patchCreateCB.SetObj(this);
	return(&patchCreateCB);
	}

// From BaseObject
int QuadPatchObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {	
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
   	
	UpdatePatchMesh(t);
	gw->setTransform(inode->GetObjectTM(t));

	MakeHitRegion(hitRegion, type, crossing, 4, p);
	return patch.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT );
	}

void QuadPatchObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	if(creating)	// If creating this one, don't try to snap to it!
		return;

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	
   	
	UpdatePatchMesh(t);
	gw->setTransform(tm);

	patch.snap( gw, snap, p, tm );
	}

int QuadPatchObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 tm;
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(inode->GetObjectTM(t));
	UpdatePatchMesh(t);
	if(!(gw->getRndMode() & GW_BOX_MODE)) {
		PrepareMesh(t);
		Mesh& mesh = patch.GetMesh();
		if(mesh.getNumVerts()) {
			mesh.render( gw, inode->Mtls(),
				(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
				COMP_ALL | (inode->Selected()?COMP_OBJSELECTED:0), inode->NumMtls());	
			}
		}
	patch.render( gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
		COMP_ALL | (inode->Selected()?COMP_OBJSELECTED:0), inode->NumMtls());	
	return(0);
	}

//////////////////////////////////  MESH WELDER ////////////////////
static void
WeldMesh(Mesh *mesh, float thresh)
{
	if (thresh == 0.0f)
		thresh = (float)1e-30; // find only the coincident ones	BitArray vset, eset;
	BitArray vset;
	vset.SetSize(mesh->numVerts);
	vset.SetAll();
	MeshDelta md;
	md.WeldByThreshold(*mesh, vset, thresh);
	md.Apply(*mesh);
}


typedef int (* GTess)(void *obj, SurfaceType type, Matrix3 *otm, Mesh *mesh,
							TessApprox *tess, TessApprox *disp, View *view,
							Mtl* mtl, BOOL dumpMiFile, BOOL splitMesh);
static GTess psGTessFunc = NULL;

// This function get the function to do GAP Tessellation from
// tessint.dll.  This is required because of the link order between
// core.dll and tessint.dll and gmi.dll.  -- Charlie Thaeler
static void
GetGTessFunction()
{
    if (psGTessFunc)
        return;
    // Get the library handle for tessint.dll
    HINSTANCE hInst = NULL;
	hInst = LoadLibraryEx(_T("tessint.dll"), NULL, 0);
    assert(hInst);

    psGTessFunc = (GTess)GetProcAddress(hInst, _T("GapTessellate"));
	assert(psGTessFunc);
}

Mesh* QuadPatchObject::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete) {
	UpdatePatchMesh(t);
	TessApprox tess = patch.GetProdTess();
	if (tess.type == TESS_SET) {
		needDelete = FALSE;
		patch.InvalidateMesh(); // force this...
		// temporarlily set the view tess to prod tess
		TessApprox tempTess = patch.GetViewTess();
		patch.SetViewTess(tess);
		PrepareMesh(t);
		patch.SetViewTess(tempTess);
		return &patch.mesh;
	} else {
		Mesh *nmesh = new Mesh/*(mesh)*/;
		Matrix3 otm = inode->GetObjectTM(t);

		Box3 bbox;
		GetDeformBBox(t, bbox);
		tess.merge *= Length(bbox.Width())/1000.0f;
		TessApprox disp = patch.GetDispTess();
		disp.merge *= Length(bbox.Width())/1000.0f;

		GetGTessFunction();
		(*psGTessFunc)(&patch, BEZIER_PATCH, &otm, nmesh, &tess, &disp, &view, inode->GetMtl(), FALSE, FALSE);
		if (tess.merge > 0.0f && patch.GetProdTessWeld())
			WeldMesh(nmesh, tess.merge);
		needDelete = TRUE;
		return nmesh;
	}
}

void QuadPatchObject::PrepareMesh(TimeValue t) {
	UpdatePatchMesh(t);
	patch.PrepareMesh();
	}

// From GeomObject
int QuadPatchObject::IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) {
	PrepareMesh(t);	// Turn it into a mesh
	return patch.IntersectRay(r, at, norm);
	}

ObjectHandle QuadPatchObject::CreateTriObjRep(TimeValue t) {
	TriObject *tri = CreateNewTriObject();
	PrepareMesh(t);	// Turn it into a mesh
	tri->GetMesh() = patch.GetMesh();	// Place it into the TriObject
	return(ObjectHandle(tri));
	}

void QuadPatchObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	UpdatePatchMesh(t);
	patch.GetDeformBBox(box, tm, useSel);
	}

void QuadPatchObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) {
	GetDeformBBox(t,box);
	}

void QuadPatchObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Box3	patchBox;

	Matrix3 mat = inode->GetObjectTM(t);
	
	GetLocalBoundBox(t,inode,vpt,patchBox);
	box.Init();
	for(int i = 0; i < 8; i++)
		box += mat * patchBox[i];
	}

//
// Reference Managment:
//

ParamDimension *QuadPatchObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:return stdWorldDim;
		case PB_WIDTH: return stdWorldDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_LSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR QuadPatchObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH: return TSTR(GetString(IDS_RB_LENGTH));
		case PB_WIDTH:  return TSTR(GetString(IDS_RB_WIDTH));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_LSEGS:  return TSTR(GetString(IDS_RB_LSEGS));
		default: return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL QuadPatchObject::SetValue(int i, TimeValue t, int v) 
	{
	return TRUE;
	}

BOOL QuadPatchObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH:  crtWidth = v; break;
		}	
	return TRUE;
	}

BOOL QuadPatchObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL QuadPatchObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	return TRUE;
	}

BOOL QuadPatchObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {				
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH:  v = crtWidth; break;
		}
	return TRUE;
	}

BOOL QuadPatchObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}

void QuadPatchObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

RefResult QuadPatchObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			PatchMeshInvalid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ObjectState QuadPatchObject::Eval(TimeValue time){
	return ObjectState(this);
	}

Interval QuadPatchObject::ObjectValidity(TimeValue t) {
	UpdatePatchMesh(t);
	return ivalid;	
	}

int QuadPatchObject::CanConvertToType(Class_ID obtype) {
	if (obtype==patchObjectClassID || obtype==defObjectClassID ||
		obtype==mapObjectClassID || obtype==triObjectClassID) {
		return 1;
    }
#ifndef NO_NURBS
	if ( obtype == EDITABLE_SURF_CLASS_ID ) {
		return 1;
    }
#endif
	return 0;
	}

Object* QuadPatchObject::ConvertToType(TimeValue t, Class_ID obtype) {
	if(obtype == patchObjectClassID || obtype == defObjectClassID ||
			obtype == mapObjectClassID) {
		PatchObject *ob;
		UpdatePatchMesh(t);
		ob = new PatchObject();	
		ob->patch = patch;
		ob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return ob;
		}

	if(obtype == triObjectClassID) {
		TriObject *ob = CreateNewTriObject();
		PrepareMesh(t);
		ob->GetMesh() = patch.GetMesh();
		ob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return ob;
		}
#ifndef NO_NURBS
	if (obtype==EDITABLE_SURF_CLASS_ID) {
		PatchObject *pob;
		UpdatePatchMesh(t);
		pob = new PatchObject();	
		pob->patch = patch;
		Object *ob = BuildEMObjectFromPatchObject(pob);
		delete pob;
		ob->SetChannelValidity(TOPO_CHAN_NUM, ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM, ObjectValidity(t));
		return ob;
		}
#endif
	return NULL;
	}

RefTargetHandle QuadPatchObject::Clone(RemapDir& remap) {
	QuadPatchObject* newob = new QuadPatchObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}

#define GRID_MAPPING_CHUNK 0x1000	// Obsolete chunk (MAX r1.x)

class QuadPatchPostLoadCallback : public PostLoadCallback {
	public:
		BOOL tex;
		ParamBlockPLCB *cb;
		QuadPatchPostLoadCallback(ParamBlockPLCB *c) {cb=c; tex=FALSE;}
		void proc(ILoad *iload) {
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (tex) {				
				((QuadPatchObject*)targ)->pblock->SetValue(PB_TEXTURE,0,1);
				}
			delete this;
			}
	};

// IO
IOResult  QuadPatchObject::Load(ILoad *iload) {
	QuadPatchPostLoadCallback *plcb = new QuadPatchPostLoadCallback(new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	iload->RegisterPostLoadCallback(plcb);
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case GRID_MAPPING_CHUNK:
				plcb->tex = TRUE;	// Deal with this old switch after loading
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

BOOL QuadPatchObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_TEXTURE, 0, genUVs, v);
	return genUVs; 
	}

void QuadPatchObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_TEXTURE,0, sw);				
	InvalidateUI();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\morphcnt.cpp ===
/**********************************************************************
 *<
	FILE: morphcnt.cpp

	DESCRIPTION:  Morph controllers

	CREATED BY: Rolf Berteig

	HISTORY: created 21 August 1995

 *>     Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "tcbgraph.h"


//---------------------------------------------------------------

class MorphKeyWindow {
	public:
		HWND hWnd;
		HWND hParent;
		Control *cont;
		MorphKeyWindow() {assert(0);}
		MorphKeyWindow(HWND hWnd,HWND hParent,Control *cont)
			{this->hWnd=hWnd; this->hParent=hParent; this->cont=cont;}
	};
static Tab<MorphKeyWindow> morphKeyWindows;

static void RegisterMorphKeyWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	MorphKeyWindow rec(hWnd,hParent,cont);
	morphKeyWindows.Append(1,&rec);
	}

static void UnRegisterMorphKeyWindow(HWND hWnd)
	{	
	for (int i=0; i<morphKeyWindows.Count(); i++) {
		if (hWnd==morphKeyWindows[i].hWnd) {
			morphKeyWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenMorphKeyWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<morphKeyWindows.Count(); i++) {
		if (hParent == morphKeyWindows[i].hParent &&
			cont    == morphKeyWindows[i].cont) {
			return morphKeyWindows[i].hWnd;
			}
		}
	return NULL;
	}

//---------------------------------------------------------------


class MorphTarget {
	public:
		Object *obj;
		TSTR *name;
		Matrix3 tm;
		int refCount;
		MorphTarget(Object *o,TSTR &n,Matrix3 &m) {obj=0;name=new TSTR(n);refCount=1;tm = m;}
		MorphTarget() {obj=NULL;refCount=0;name=NULL;tm=Matrix3(1);}
	};

class MorphTargList : public Tab<MorphTarget> {
	public:
		int AddTarg(Object *obj,TSTR &name,Matrix3 &tm,ReferenceMaker *maker,int offset);
		BOOL DeleteTarg(int i,ReferenceMaker *maker);
		void ForceDeleteTarg(int i,int offset,ReferenceMaker *maker);
		void SetSize(int size);
		~MorphTargList();
	};

class AddMorphTargRestore : public RestoreObj {
	public:         
		ReferenceTarget *mcont;
		MorphTargList *list;
		int index;
		BOOL inc;
		MorphTarget targ;               

		AddMorphTargRestore(ReferenceTarget *mc,MorphTargList *l,int i,BOOL inc) {
			mcont = mc;
			list  = l;
			index = i;
			this->inc = inc;
			if (!inc) {
				targ.obj      = (*list)[index].obj;
				targ.name     = new TSTR(*(*list)[index].name);
				targ.tm       = (*list)[index].tm;
				targ.refCount = (*list)[index].refCount;
				}
			}
		~AddMorphTargRestore() {
			delete targ.name;
			}

		void Restore(int isUndo) {
			if (inc) {
				(*list)[index].refCount--;
			} else {
				delete (*list)[index].name;
				list->Delete(index,1);
				}
			mcont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			mcont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			}
		void Redo() {
			if (inc) {
				(*list)[index].refCount++;
			} else {                                
				list->Insert(index,1,&targ);
				(*list)[index].name = new TSTR(*(*list)[index].name);
				}
			mcont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			mcont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			}               
		TSTR Description() { return TSTR(_T("Morp Targ")); }
	};


class DeleteMorphTargRestore : public RestoreObj {
	public:         
		ReferenceTarget *mcont;
		MorphTargList *list;
		int index;		
		MorphTarget targ;               

		DeleteMorphTargRestore(ReferenceTarget *mc,MorphTargList *l,int i) {
			mcont = mc;
			list  = l;
			index = i;			
			targ.obj      = (*list)[index].obj;
			targ.name     = new TSTR(*(*list)[index].name);
			targ.tm       = (*list)[index].tm;
			targ.refCount = (*list)[index].refCount;			
			}
		DeleteMorphTargRestore() {
			delete targ.name;
			}

		void Restore(int isUndo) {
			
			list->Insert(index,1,&targ);
			(*list)[index].name = new TSTR(*(*list)[index].name);			
			
			mcont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			mcont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			}
		void Redo() {
			
			delete (*list)[index].name;
			list->Delete(index,1);
			
			mcont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			mcont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			}               
		TSTR Description() { return TSTR(_T("Morp Targ")); }
	};


MorphTargList::~MorphTargList()
	{
	for (int i=0; i<Count(); i++) {
		delete (*this)[i].name;
		}
	}

int MorphTargList::AddTarg(
		Object *obj,TSTR &name,Matrix3 &tm,
		ReferenceMaker *maker,int offset)
	{
	for (int i=0; i<Count(); i++) {
		if (obj==(*this)[i].obj) {
			(*this)[i].refCount++;
			if (theHold.Holding()) {
				theHold.Put(new AddMorphTargRestore((ReferenceTarget*)maker,this,i,TRUE));
				}
			return i;
			}
		}
	MorphTarget targ(obj,name,tm);
	Append(1,&targ);
	if (theHold.Holding()) {
		theHold.Put(new AddMorphTargRestore((ReferenceTarget*)maker,this,i,FALSE));
		}
	maker->MakeRefByID(FOREVER,i+offset,obj);       
	return i;
	}

BOOL MorphTargList::DeleteTarg(int i,ReferenceMaker *maker)
	{
#if 0
	(*this)[i].refCount--;
	if ((*this)[i].refCount<=0) {
		maker->DeleteReference(i);
		delete (*this)[i].name;
		Delete(i,1);
		return TRUE;
	} else {
		return FALSE;
		}                               
#endif
	return FALSE;
	}

void MorphTargList::ForceDeleteTarg(int i,int offset,ReferenceMaker *maker)
	{	
	DeleteMorphTargRestore *rest = NULL;
	if (theHold.Holding()) {
		rest = 
			new DeleteMorphTargRestore((ReferenceTarget*)maker,this,i);
		}
	maker->DeleteReference(i+offset);
	delete (*this)[i].name;
	Delete(i,1);
	if (theHold.Holding()) {
		theHold.Put(rest);
		}
	}

void MorphTargList::SetSize(int size)
	{
	Resize(size);   
	if (Count() < size) {
		for (int i=Count(); i<size; i++) {
			MorphTarget targ;
			Append(1,&targ);
			}
		}
	}


// Key flags
#define KEY_SELECTED    (1<<0) 
#define KEY_FLAGGED     (1<<1)
#define MULTS_VALID     (1<<2)

// Track flags
#define TRACK_INVALID   (1<<0)
#define RANGE_UNLOCKED  (1<<1)


class MorphKey {
	public:         
		DWORD flags;
		TimeValue time; 

		void SetFlag(DWORD mask) {flags|=(mask);}
		void ClearFlag(DWORD mask) {flags &= ~(mask);}
		BOOL TestFlag(DWORD mask) {return(flags&(mask)?1:0);}
	};

static int __cdecl CompareMorphKeys(const MorphKey *k1, const MorphKey *k2)
	{
	if (k1->time<k2->time) return -1;
	if (k1->time>k2->time) return 1;
	return 0;
	}

/////////////////////////////////////////////////////////////////////
//
// A simple morph controller...

template <class KT>
class GenMorphCont : public MorphControl {
	public:
		MorphTargList targs;
		KT keys;
		ObjectState ob;
		Interval obValid;
		int version, flaggedTarg;
		BOOL lockCache;

		GenMorphCont();
		~GenMorphCont();
		virtual void Update(TimeValue t,TimeValue realT)=0;
		virtual void HoldTrack()=0;
		void FreeCache();
		int FindKey(TimeValue t);
		void GetInterpVal(TimeValue t,int &n0, int &n1, float &u);
		void Invalidate();
		TimeValue ProcessORT(TimeValue t);
		
		// Animatable methods
		SClass_ID SuperClassID() {return CTRL_MORPH_CLASS_ID;}
		int NumKeys() {return keys.Count();}
		TimeValue GetKeyTime(int index) {return keys[index].time;}
		int GetTrackVSpace( int lineHeight ) {return 1;}
		BOOL IsAnimated() {return keys.Count()>=1;}

		void MapKeys(TimeMap *map,DWORD flags );
		void DeleteKeys( DWORD flags );
		void CloneSelectedKeys(BOOL offset);
		void DeleteTime( Interval iv, DWORD flags );
		void ReverseTime( Interval iv, DWORD flags );
		void ScaleTime( Interval iv, float s);
		void InsertTime( TimeValue ins, TimeValue amount );
		void AddNewKey(TimeValue t,DWORD flags);
		int GetSelKeyCoords(TimeValue &t, float &val,DWORD flags);
		void SetSelKeyCoords(TimeValue t, float val,DWORD flags);               
		BOOL CanCopyTrack(Interval iv,DWORD flags) {return 0;} // {return 1;}
		BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags) {return FALSE;} //{return (cobj && (cobj->ClassID()==ClassID()));}
		TrackClipObject *CopyTrack(Interval iv,DWORD flags);
		void PasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags);
		Interval GetTimeRange(DWORD flags);
		void EditTimeRange(Interval range,DWORD flags);
		int HitTestTrack(TrackHitTab& hits,Rect& rcHit,Rect& rcTrack,float zoom,int scroll,DWORD flags );
		int PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags );
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void SelectKeys(TrackHitTab& sel, DWORD flags);
		void SelectKeyByIndex(int i,BOOL sel);
		BOOL IsKeySelected(int i);
		int NumSelKeys();
		void FlagKey(TrackHitRecord hit);
		int GetFlagKeyIndex();          
		int TrackParamsType() {return TRACKPARAMS_KEY;}
		BOOL SupportTimeOperations() {return TRUE;} // RB 3/26/99: This wasn't implemented (def. returned FALSE)

		// Control methods
		void Copy(Control *from) {}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		BOOL IsLeaf() {return TRUE;}            
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		void MouseCycleCompleted(TimeValue t);
		int GetFlaggedTarget() {return flaggedTarg;}

		// Morph control methods
		int NumMorphTargs() {return targs.Count();}
		Object *GetMorphTarg(int i) {return targs[i].obj;}
		void GetMorphTargName(int i,TSTR &name) {name = *targs[i].name;}
		void SetMorphTargName(int i,TSTR name) {*targs[i].name = name;NotifyDependents(FOREVER,0,REFMSG_NODE_NAMECHANGE);}
		Matrix3 GetMorphTargTM(int i) {return targs[i].tm;}
		BOOL ValidTarget(TimeValue t,Object *obj);
		void DeleteMorphTarg(int i);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		void DeleteThis() {delete this;}

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		
		// Ref methods
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	};

template <class KT>
class Ver0PostLoad : public PostLoadCallback {
	public:
		GenMorphCont<KT> *cont;
		Ver0PostLoad(GenMorphCont<KT> *c) {cont=c;}
		void proc(ILoad *iload);
	};


// Current version
#define MORPHCONT_VERSION       1


//------------------------------------------------------------------------
//
//  Cubic Spline Morph Controller
//

#define CUBICMORPHCONT_CLASS_ID 0x09923023


class CubicMorphKey : public MorphKey {
	public:         
		int targ;
		float tens, cont, bias;
		float k, l, m, n;
		CubicMorphKey(TimeValue t,int targ) {
			time  = t;
			flags = 0;
			this->targ = targ;
			tens = cont = 0.0f;
			bias = k = l = m = n = 0.0f;
			}
		CubicMorphKey() {
			flags = 0;
			time  = 0;
			targ  = 0;
			tens = cont = 0.0f;
			bias = k = l = m = n = 0.0f;
			}
		
		void Invalidate();
		void ComputeMults();
	};

class CubicMorphKeyTab : public Tab<CubicMorphKey> {
	public:
		DWORD flags;
		Interval range;

		CubicMorphKeyTab() {
			flags = 0;
			}

		void SetFlag(DWORD mask) {flags|=(mask);}
		void ClearFlag(DWORD mask) {flags &= ~(mask);}
		BOOL TestFlag(DWORD mask) {return(flags&(mask)?1:0);}

		void AddNewKey(TimeValue t,int targ,BOOL sel=FALSE) {
			CubicMorphKey key(t,targ);
			if (sel) key.SetFlag(KEY_SELECTED);
			Append(1,&key,5);
			Invalidate();
			}
		
		void Clone(int i) {
			CubicMorphKey key = (*this)[i];
			Append(1,&key,5);
			}
		
		void Invalidate() {
			SetFlag(TRACK_INVALID);
			}

		void CheckForDups() {
			// Check for keys that landed on top of each other
			for (int i=0; i<Count()-1; i++) {
				if ((*this)[i].time==(*this)[i+1].time) {
					if ((*this)[i].TestFlag(KEY_SELECTED)) {
						Delete(i+1,1);
					} else {
						Delete(i,1);						
						}
					i--;
					}
				}                       
			}

		void Update();
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};


class CubicMorphCont : public GenMorphCont<CubicMorphKeyTab> {
	public:                         
		void Update(TimeValue t,TimeValue realT);
		void HoldTrack();
		void CalcFirstCoef(float *v,float *c);
		void CalcLastCoef(float *v,float *c);
		void CalcMiddleCoef(float *v,int *knum,float *c);

		// Animatable methods
		Class_ID ClassID() {return Class_ID(CUBICMORPHCONT_CLASS_ID,0);}  
		void GetClassName(TSTR& s) {s =GetString(IDS_RB_CUBICMORPHCONTROL_CLASS);}
		void EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags);

		// Control methods
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		void DeleteMorphTarg(int i);

		RefTargetHandle Clone(RemapDir& remap);
		void Copy(Control *from);
	};

class CubicMorphContClassDesc:public ClassDesc {
	public:
	int                     IsPublic() {return 1;}
	void *                  Create(BOOL loading = FALSE) {return new CubicMorphCont;}
	const TCHAR *   ClassName() { return GetString(IDS_RB_CUBICMORPHCONTROL); }
	SClass_ID               SuperClassID() { return CTRL_MORPH_CLASS_ID; }
	Class_ID                ClassID() { return Class_ID(CUBICMORPHCONT_CLASS_ID,0); }
	const TCHAR*    Category() { return _T("Morph");  }
	};

static CubicMorphContClassDesc cubicMorphContDesc;

ClassDesc* GetCubicMorphContDesc() { return &cubicMorphContDesc; }


class CubicMorphRest : public RestoreObj {
	public:
		CubicMorphKeyTab undo, redo;
		CubicMorphCont *cont;

		CubicMorphRest(CubicMorphCont *c) { 
			cont = c;
			undo = c->keys;
			}
		~CubicMorphRest() {}
		void Restore(int isUndo) {
			if (isUndo) {
				if (redo.Count()!=cont->keys.Count()) {
					redo = cont->keys;
					}
				}
			cont->keys = undo;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo() {
			cont->keys = redo;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Morph Restore")); }
	};



//------------------------------------------------------------------------
//
//  Barycentric Morph Controller
//

#define BARYMORPHCONT_CLASS_ID 0x09923022

class TargetWeight {
	public:
		int targ;
		float percent;
		TargetWeight() {targ=0;percent=0.0f;}
		TargetWeight(int t,float p) {targ=t;percent=p;}
	};

class BaryMorphKey : public MorphKey {
	public:         		
		float tens, cont, bias;
		float k, l, m, n;
		Tab<TargetWeight> *wts;

		BaryMorphKey(TimeValue t,int targ) {
			time  = t;
			flags = 0;			
			tens = cont = 0.0f;			
			bias = k = l = m = n = 0.0f;
			wts = new Tab<TargetWeight>;
			TargetWeight wt(targ,1.0f);
			WTS().Append(1,&wt);
			}
		BaryMorphKey() {
			flags = 0;
			time  = 0;			
			tens = cont = 0.0f;
			bias = k = l = m = n = 0.0f;
			wts = new Tab<TargetWeight>;
			}
		
		BaryMorphKey& operator=(BaryMorphKey &src) {
			MorphKey::operator=(src);
			tens = src.tens; cont = src.cont; bias = src.bias;
			k = src.k; l = src.l; m = src.m; n = src.n;
			wts = new Tab<TargetWeight>;
			*wts = *src.wts;
			return *this;
			}
			
		Tab<TargetWeight> &WTS() {return *wts;}
		void Invalidate();
		void ComputeMults();
		void TargetDeleted(int t);
		float GetWeight(int t);
		void SetWeight(int t,float w);
	};

class BaryMorphKeyTab : public Tab<BaryMorphKey> {
	public:
		DWORD flags;
		Interval range;

		BaryMorphKeyTab() {
			flags = 0;
			}

		void SetFlag(DWORD mask) {flags|=(mask);}
		void ClearFlag(DWORD mask) {flags &= ~(mask);}
		BOOL TestFlag(DWORD mask) {return(flags&(mask)?1:0);}

		void AddNewKey(TimeValue t,int targ,BOOL sel=FALSE) {
			BaryMorphKey key(t,targ);
			if (sel) key.SetFlag(KEY_SELECTED);
			Append(1,&key,5);
			Invalidate();
			}
		
		void Clone(int i) {
			BaryMorphKey key;
			key = (*this)[i];
			Append(1,&key,5);
			}
		
		void Invalidate() {
			SetFlag(TRACK_INVALID);
			}

		void CheckForDups() {
			// Check for keys that landed on top of each other
			for (int i=0; i<Count()-1; i++) {
				if ((*this)[i].time==(*this)[i+1].time) {
					if ((*this)[i].TestFlag(KEY_SELECTED)) {
						delete (*this)[i+1].wts;
						Delete(i+1,1);
					} else {
						delete (*this)[i].wts;
						Delete(i,1);						
						}
					i--;
					}
				}                       
			}

		void Update();
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		BaryMorphKeyTab& operator=(BaryMorphKeyTab &src) {
			Tab<BaryMorphKey>::operator=(src);
			for (int i=0; i<Count(); i++) {
				(*this)[i].wts = new Tab<TargetWeight>(*(*this)[i].wts);
				}
			range = src.range;
			flags = src.flags;
			return *this;
			}
	};


class BaryMorphCont : public GenMorphCont<BaryMorphKeyTab> {
	public:                         
		void Update(TimeValue t,TimeValue realT);
		void HoldTrack();
		void CalcFirstCoef(float *v,float *c);
		void CalcLastCoef(float *v,float *c);
		void CalcMiddleCoef(float *v,int *knum,float *c);

		// Animatable methods
		Class_ID ClassID() {return Class_ID(BARYMORPHCONT_CLASS_ID,0);}  
		void GetClassName(TSTR& s) {s =GetString(IDS_RB_BARYMORPHCONTROL_CLASS);}
		void EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags);
		void AddNewKey(TimeValue t,DWORD flags);

		// Control methods
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		void DeleteMorphTarg(int i);

		RefTargetHandle Clone(RemapDir& remap);
		void Copy(Control *from);
		
	};

class BaryMorphContClassDesc:public ClassDesc {
	public:
	int             IsPublic() {return 1;}
	void *          Create(BOOL loading = FALSE) {return new BaryMorphCont;}
	const TCHAR *   ClassName() {return GetString(IDS_RB_BARYMORPHCONTROL);}
	SClass_ID       SuperClassID() {return CTRL_MORPH_CLASS_ID;}
	Class_ID        ClassID() {return Class_ID(BARYMORPHCONT_CLASS_ID,0);}
	const TCHAR*    Category() {return _T("Morph");}
	void			ResetClassParams(BOOL fileReset=FALSE);
	};

static BaryMorphContClassDesc baryMorphContDesc;
ClassDesc* GetBaryMorphContDesc() { return &baryMorphContDesc; }

class BaryMorphRest : public RestoreObj {
	public:
		BaryMorphKeyTab undo, redo;
		BaryMorphCont *cont;

		BaryMorphRest(BaryMorphCont *c) { 
			cont = c;
			undo = c->keys;
			}
		~BaryMorphRest() {}
		void Restore(int isUndo) {
			if (isUndo) {
				if (redo.Count()!=cont->keys.Count()) {
					redo = cont->keys;
					}
				}
			cont->keys = undo;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo() {
			cont->keys = redo;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Morph Restore")); }
	};


//-----------------------------------------------------------------------

Control *newDefaultMorphControl() 
	{
	if (GetDefaultController(CTRL_MORPH_CLASS_ID)==GetCubicMorphContDesc()) {
		return new CubicMorphCont;		
	} else {
		return new BaryMorphCont;
		}
	}

template <class KT>
GenMorphCont<KT>::GenMorphCont()
	{
	lockCache = FALSE;
	obValid.SetEmpty();     
	version = MORPHCONT_VERSION;
	flaggedTarg = -1;
	}

template <class KT>
GenMorphCont<KT>::~GenMorphCont()
	{
	DeleteAllRefsFromMe();
	}

template <class KT>
BOOL GenMorphCont<KT>::HasUVW()
	{	
	for (int i=0; i<targs.Count(); i++) {
		if (!targs[i].obj->HasUVW()) return FALSE;
		}
	return TRUE;
	}

template <class KT>
void GenMorphCont<KT>::SetGenUVW(BOOL sw)
	{
	for (int i=0; i<targs.Count(); i++) {
		targs[i].obj->SetGenUVW(sw);
		}
	}

template <class KT>
void GenMorphCont<KT>::SetValue(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{       
	int index;      
	SetMorphTargetPacket *pckt = (SetMorphTargetPacket*)val;

	index = targs.AddTarg(
		pckt->obj,pckt->name,pckt->tm,this,Control::NumRefs()); 
	if (t!=0 || index!=0 || keys.Count() || pckt->forceCreate) {
		HoldTrack();
		int n = keys.Count();
		for (int i = 0; i < n; i++ ) {
			keys[i].ClearFlag(KEY_SELECTED);
			}
		if (!keys.Count() && t!=0) {
			// Make a key at frame 0
			keys.AddNewKey(0,0);
			}
		keys.AddNewKey(t,index,TRUE);
		keys.CheckForDups();
		}
	obValid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

template <class KT>
void GenMorphCont<KT>::MouseCycleCompleted(TimeValue t)
	{
	keys.CheckForDups();
	}

template <class KT>
BOOL GenMorphCont<KT>::ValidTarget(TimeValue t,Object *obj)
	{
	// Make sure it doesn't depend on us
	obj->BeginDependencyTest();
	NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (obj->EndDependencyTest()) return FALSE;

	Update(t,t);
	ObjectState os = obj->Eval(t);
	if (os.obj->IsParticleSystem()) {
		return FALSE;
	} else if (os.obj->IsDeformable()) {
		if (ob.obj && ob.obj->NumPoints()==os.obj->NumPoints()) return TRUE;
		else if (!targs.Count()) return TRUE;
	} else {
		if (os.obj->CanConvertToType(defObjectClassID)) {
			if (!targs.Count()) return TRUE;
			Object *obj = os.obj->ConvertToType(t,defObjectClassID);
			assert(obj);
			BOOL res = ob.obj->NumPoints()==obj->NumPoints();
			if (obj!=os.obj) obj->DeleteThis();
			return res;
			}
		}
	return FALSE;
	}

template <class KT>
void GenMorphCont<KT>::DeleteMorphTarg(int i)
	{	
	targs.ForceDeleteTarg(i,Control::NumRefs(),this);
	obValid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

template <class KT>
void GenMorphCont<KT>::FreeCache()
	{
	if (ob.obj && !lockCache) {
		ob.obj->UnlockChannels(GEOM_CHANNEL);
		ob.obj->UnlockObject(); 
		ob.DeleteObj();
		}
	}

template <class KT>
int GenMorphCont<KT>::FindKey(TimeValue t)
	{
	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time >= t) {
			if (keys[i].time==t && i==0) {
				return i;
			} else {
				return i-1;
				}
			}
		}
	return keys.Count()-1;
	}

template <class KT>
void GenMorphCont<KT>::GetInterpVal(TimeValue t,int &n0, int &n1, float &u)
	{
	int i = FindKey(t);
	if (i<0) {
		n0 = n1 = -1;
		u  = 0.0f;
		return;
		}
	if (i==keys.Count()-1) {
		n0 = n1 = i;
		u  = 0.0f;
		return;
		}
	n0 = i;
	n1 = i+1;
	u = float(t-keys[i].time) / float(keys[i+1].time - keys[i].time);
	}


template <class KT>
RefResult GenMorphCont<KT>::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message) 
	{
	switch (message) {
		case REFMSG_SELECT_BRANCH: {
			for (int i=0; i<targs.Count(); i++) {
				if (targs[i].obj==hTarget) {
					flaggedTarg = i;
					break;
					}
				}
			break;
			}

		case REFMSG_OBJECT_CACHE_DUMPED:
		case REFMSG_CHANGE:
			obValid.SetEmpty();
			FreeCache();
			break;
		}
	return REF_SUCCEED;
	}

template <class KT>
void GenMorphCont<KT>::Invalidate()
	{
	obValid.SetEmpty();
	}


template <class KT>
int GenMorphCont<KT>::NumSubs() 
	{
	return Control::NumSubs();
	}

template <class KT>
Animatable* GenMorphCont<KT>::SubAnim(int i) 
	{
	return Control::SubAnim(i);
	}

template <class KT>
TSTR GenMorphCont<KT>::SubAnimName(int i) 
	{
	return Control::SubAnimName(i);
	}


template <class KT>
int GenMorphCont<KT>::NumRefs() 
	{
	if (version) {
		return Control::NumRefs() + targs.Count();
	} else {
		return targs.Count();
		}
	}


template <class KT>
RefTargetHandle GenMorphCont<KT>::GetReference(int i) 
	{
	if (version) {
		if (i<Control::NumRefs()) {
			return Control::GetReference(i);
		} else {
			i -= Control::NumRefs();
			if (i<targs.Count()) {
				return targs[i].obj;
			} else {
				return NULL;
				}       
			}
	} else {
		if (i<targs.Count()) {
			return targs[i].obj;
		} else {
			return NULL;
			}       
		} 
	}

template <class KT>
void GenMorphCont<KT>::SetReference(int i, RefTargetHandle rtarg) 
	{
	if (version) {
		if (i<Control::NumRefs()) {
			Control::SetReference(i,rtarg);
		} else {                        
			targs[i-Control::NumRefs()].obj = (Object*)rtarg;
			}
	} else {                
		targs[i].obj = (Object*)rtarg;                  
		}
	}

template <class KT>
void Ver0PostLoad<KT>::proc(ILoad *iload)
	{
	cont->version = MORPHCONT_VERSION;
	delete this;
	}

#define TARGCOUNT_CHUNK                 0x01001
#define MORPHKEYS_CHUNK                 0x01002
#define MORPH_INORT_CHUNK               0x01003
#define MORPH_OUTORT_CHUNK              0x01004
#define MORPH_TARGNAME_CHUNK    0x01005
#define MORPH_VERSION_CHUNK             0x01006
#define MORPH_TARGTM_CHUNK              0x01007

template <class KT>
IOResult GenMorphCont<KT>::Save(ISave *isave)
	{
	ULONG nb;
	int ort;
	int ct = targs.Count();
	int ver = MORPHCONT_VERSION;

	isave->BeginChunk(MORPH_VERSION_CHUNK);
	isave->Write(&ver,sizeof(ver),&nb);
	isave->EndChunk();

	isave->BeginChunk(TARGCOUNT_CHUNK);
	isave->Write(&ct,sizeof(ct),&nb);
	isave->EndChunk();

	for (int i=0; i<targs.Count(); i++) {
		isave->BeginChunk(MORPH_TARGNAME_CHUNK);
		isave->WriteWString((TCHAR*)(*targs[i].name));
		isave->EndChunk();

		isave->BeginChunk(MORPH_TARGTM_CHUNK);
		targs[i].tm.Save(isave);
		isave->EndChunk();
		}

	ort = GetORT(ORT_BEFORE);
	isave->BeginChunk(MORPH_INORT_CHUNK);
	isave->Write(&ort,sizeof(ort),&nb);                     
	isave->EndChunk();

	ort = GetORT(ORT_AFTER);
	isave->BeginChunk(MORPH_OUTORT_CHUNK);
	isave->Write(&ort,sizeof(ort),&nb);                     
	isave->EndChunk();

	isave->BeginChunk(MORPHKEYS_CHUNK);
	keys.Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

template <class KT>
IOResult GenMorphCont<KT>::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res;
	int ort, ct, ni=0, ti=0;        

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case MORPH_VERSION_CHUNK:
				res=iload->Read(&version,sizeof(version),&nb);
				break;

			case TARGCOUNT_CHUNK:
				res=iload->Read(&ct,sizeof(ct),&nb);
				targs.SetSize(ct);
				break;

			case MORPH_TARGNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				targs[ni++].name = new TSTR(buf);
				break;
				}
			
			case MORPH_TARGTM_CHUNK:
				res=targs[ti++].tm.Load(iload);
				break;                          

			case MORPH_INORT_CHUNK:
				res=iload->Read(&ort,sizeof(ort),&nb);
				SetORT(ort,ORT_BEFORE);
				break;

			case MORPH_OUTORT_CHUNK:
				res=iload->Read(&ort,sizeof(ort),&nb);
				SetORT(ort,ORT_AFTER);
				break;

			case MORPHKEYS_CHUNK:
				res=keys.Load(iload);
				break;
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	keys.Invalidate();
	Invalidate();
	
	// Fix up old versions
	switch (version) {
		case 0:
			iload->RegisterPostLoadCallback(new Ver0PostLoad<KT>(this));
			iload->SetObsolete();
			break;
		}

	return IO_OK;
	}

//
// Track view key stuff
//

template <class KT>
void GenMorphCont<KT>::MapKeys(TimeMap *map,DWORD flags )
	{
	int n = keys.Count();
	BOOL changed = FALSE;
	if (!n) return;
	HoldTrack();

	if (flags&TRACK_DOALL) {
		for (int i=0; i<n; i++) {
			keys[i].time = map->map(keys[i].time);
			changed = TRUE;
			}
	} else 
	if (flags&TRACK_DOSEL) {
		BOOL slide = flags&TRACK_SLIDEUNSEL;
		TimeValue delta = 0, prev;
		int start, end, inc;
		if (flags&TRACK_RIGHTTOLEFT) {
			start = n-1;
			end = -1;
			inc = -1;
		} else {
			start = 0;
			end = n;
			inc = 1;
			} 
		for (int i = start; i!=end; i+=inc) {
			if (keys[i].TestFlag(KEY_SELECTED)) {                   
				prev = keys[i].time;
				keys[i].time = map->map(keys[i].time);
				delta = keys[i].time - prev;
				changed = TRUE;
			} else if (slide) {
				keys[i].time += delta;
				}
			}
		}
	if (flags&TRACK_MAPRANGE && keys.TestFlag(RANGE_UNLOCKED)) {
		TimeValue t0 = map->map(keys.range.Start());
		TimeValue t1 = map->map(keys.range.End());
		keys.range.Set(t0,t1);
		}

	if (changed) {
		keys.Invalidate();
		Invalidate();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

template <class KT>
void GenMorphCont<KT>::DeleteKeys(DWORD flags)
	{
	int n = keys.Count();           
	HoldTrack();
	
	for ( int i = n-1; i >= 0; i-- ) {
		if (flags&TRACK_DOALL || keys[i].TestFlag(KEY_SELECTED)) {
			keys.Delete(i,1);                       
			}
		}
	keys.Invalidate();
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
void GenMorphCont<KT>::CloneSelectedKeys(BOOL offset)
	{
	int n = keys.Count();                   
	HoldTrack();
	BOOL changed = FALSE;

	for (int i = 0; i < n; i++) {
		if (keys[i].TestFlag(KEY_SELECTED)) {                   
			keys.Clone(i);
			keys[i].ClearFlag(KEY_SELECTED);
			changed = TRUE;
			}
		}
	if (changed) {          
		keys.Invalidate();
		}
	}

template <class KT>
void GenMorphCont<KT>::DeleteTime( Interval iv, DWORD flags )
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();   
	int d = iv.Duration()-1;
	if (d<0) d = 0;
	HoldTrack();

	for (int i = n-1; i >= 0; i--) {
		if (test.InInterval(keys[i].time) ) {
			keys.Delete(i,1);                       
		} else 
		if (!(flags&TIME_NOSLIDE)) {
			if (keys[i].time > test.End()) {
				keys[i].time -= d;
				}
			}
		}                   
	keys.Invalidate();
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
void GenMorphCont<KT>::ReverseTime( Interval iv, DWORD flags )
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();
	HoldTrack();

	for (int i = 0; i < n; i++) {
		if (test.InInterval(keys[i].time)) {
			TimeValue delta = keys[i].time - iv.Start();
			keys[i].time = iv.End()-delta;                  
			}
		}
	
	keys.Invalidate();
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
void GenMorphCont<KT>::ScaleTime( Interval iv, float s)
	{
	int n = keys.Count();
	TimeValue delta = int(s*float(iv.End()-iv.Start())) + iv.Start()-iv.End();
	HoldTrack();

	for (int i = 0; i < n; i++) {
		if (iv.InInterval(keys[i].time)) {
			keys[i].time = 
				int(s*float(keys[i].time - iv.Start())) + iv.Start();
		} else 
		if (keys[i].time > iv.End()) {
			keys[i].time += delta;
			}
		}
	
	keys.Invalidate();
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
void GenMorphCont<KT>::InsertTime( TimeValue ins, TimeValue amount )
	{
	int n = keys.Count();           
	HoldTrack();

	for (int i = 0; i < n; i++) {
		if ( keys[i].time >= ins ) {
			keys[i].time += amount;
			}               
		}
	
	keys.Invalidate();
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
void GenMorphCont<KT>::AddNewKey(TimeValue t,DWORD flags)
	{

	}


template <class KT>
int GenMorphCont<KT>::GetSelKeyCoords(TimeValue &t, float &val,DWORD flags)
	{
	TimeValue atime;
	int n = keys.Count();
	BOOL tfound = FALSE;
	for (int i=0; i<n; i++) {
		if (keys[i].TestFlag(KEY_SELECTED)) {
			if (tfound) {
				if (keys[i].time!=atime) {
					return KEYS_MULTISELECTED;
					}
			} else {
				tfound = TRUE;
				atime = keys[i].time;
				}
			}
		}	
	if (tfound) {
		t = atime;
		return KEYS_COMMONTIME;
	} else {
		return KEYS_NONESELECTED;
		}
	}

template <class KT>
void GenMorphCont<KT>::SetSelKeyCoords(TimeValue t, float val,DWORD flags)
	{
	BOOL changed = FALSE;
	if (flags&KEYCOORDS_VALUEONLY) return;
	int n = keys.Count();
	for (int i=0; i<n; i++) {
		if (keys[i].TestFlag(KEY_SELECTED)) {
			keys[i].time = t;
			changed = TRUE;
			}
		}
	if (changed) {
		keys.Invalidate();
		Invalidate();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

template <class KT>
TrackClipObject *GenMorphCont<KT>::CopyTrack(Interval iv,DWORD flags)
	{
	return NULL;
	}

template <class KT>
void GenMorphCont<KT>::PasteTrack(
		TrackClipObject *cobj,Interval iv,DWORD flags)
	{

	}

template <class KT>
Interval GenMorphCont<KT>::GetTimeRange(DWORD flags)
	{
	keys.Update();
	return keys.range;
	}

template <class KT>
void GenMorphCont<KT>::EditTimeRange(Interval range,DWORD flags)
	{
	HoldTrack();
	if (flags&EDITRANGE_LINKTOKEYS) {
		keys.ClearFlag(RANGE_UNLOCKED);         
	} else {
		keys.range = range;
		keys.SetFlag(RANGE_UNLOCKED);
		}       
	Invalidate();
	keys.Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

#define HSIZE 4
#define VSIZE 5
inline void PaintKey(HDC hdc, int x, int y) {
	Ellipse(hdc,x-HSIZE,y-VSIZE,x+HSIZE,y+VSIZE);
	}

template <class KT>
int GenMorphCont<KT>::HitTestTrack(
		TrackHitTab& hits,Rect& rcHit,Rect& rcTrack,
		float zoom,int scroll,DWORD flags )
	{
	int left  = ScreenToTime(rcTrack.left,zoom,scroll) - HSIZE;
	int right = ScreenToTime(rcTrack.right,zoom,scroll) + HSIZE;
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2; 
		
	for ( int i = 0; i < n; i++ ) {
		if (flags&HITTRACK_SELONLY && 
			!keys[i].TestFlag(KEY_SELECTED)) continue;
		if (flags&HITTRACK_UNSELONLY && 
			keys[i].TestFlag(KEY_SELECTED)) continue;

		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {
			int x = TimeToScreen(keys[i].time,zoom,scroll);
			if (rcHit.Contains(IPoint2(x,y))) {
				TrackHitRecord rec(i,0);
				hits.Append(1,&rec);
				if (flags&HITTRACK_ABORTONHIT) return TRACK_DONE;
				}
			}               
		}
	return TRACK_DONE;
	}

template <class KT>
int GenMorphCont<KT>::PaintTrack(
		ParamDimensionBase *dim,
		HDC hdc,Rect& rcTrack,Rect& rcPaint,
		float zoom,int scroll,DWORD flags )
	{
	int left  = ScreenToTime(rcPaint.left-2*HSIZE,zoom,scroll);
	int right = ScreenToTime(rcPaint.right+2*HSIZE,zoom,scroll);
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2;
	HBRUSH selBrush = CreateSolidBrush(RGB(255,255,255));
	HBRUSH unselBrush = (HBRUSH)GetStockObject(GRAY_BRUSH); 

	SelectObject(hdc,GetStockObject(BLACK_PEN));    

	for ( int i = 0; i < n; i++ ) {
		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {
			int x = TimeToScreen(keys[i].time,zoom,scroll);
			if ( (flags&PAINTTRACK_SHOWSEL) &&
			     keys[i].TestFlag(KEY_SELECTED)) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}
			PaintKey(hdc,x,y);
			}               
		}
	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	DeleteObject(selBrush);
	
	return TRACK_DONE;
	}

template <class KT>
void GenMorphCont<KT>::SelectKeyByIndex(int i,BOOL sel)
	{
	HoldTrack();
	if (sel) keys[i].SetFlag(KEY_SELECTED);
	else     keys[i].ClearFlag(KEY_SELECTED);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
BOOL GenMorphCont<KT>::IsKeySelected(int i)
	{
	return keys[i].TestFlag(KEY_SELECTED);
	}

template <class KT>
BOOL GenMorphCont<KT>::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	if (!keys.Count()) return FALSE;
	if (flags&NEXTKEY_RIGHT) {		
		for (int i=0; i<keys.Count(); i++) {
			if (keys[i].time > t ) {
				nt = keys[i].time;
				return TRUE;
				}
			}
		nt = keys[0].time;
		return TRUE;
	} else {
		for (int i=keys.Count()-1; i>=0; i--) {
			if (keys[i].time < t ) {
				nt = keys[i].time;
				return TRUE;
				}
			}
		nt = keys[keys.Count()-1].time;
		return TRUE;
		}
	}

template <class KT>
void GenMorphCont<KT>::SelectKeys(TrackHitTab& sel, DWORD flags)
	{
	HoldTrack();    

	if (flags&SELKEYS_CLEARKEYS) {
		int n = keys.Count();
		for (int i = 0; i < n; i++ ) {
			keys[i].ClearFlag(KEY_SELECTED);
			}
		}
	
	if (flags&SELKEYS_DESELECT) {
		for (int i = 0; i < sel.Count(); i++) {
			keys[sel[i].hit].ClearFlag(KEY_SELECTED);
			}               
		}       
	if (flags&SELKEYS_SELECT) {                     
		for (int i = 0; i < sel.Count(); i++ ) {
			keys[sel[i].hit].SetFlag(KEY_SELECTED);
			}
		}       
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

template <class KT>
int GenMorphCont<KT>::NumSelKeys()
	{
	int n = keys.Count();
	int c = 0;
	for ( int i = 0; i < n; i++ ) {
		if (keys[i].TestFlag(KEY_SELECTED)) {
			c++;
			}
		}
	return c;
	}

template <class KT>
void GenMorphCont<KT>::FlagKey(TrackHitRecord hit)
	{
	int n = keys.Count();
	for ( int i = 0; i < n; i++ ) {
		keys[i].ClearFlag(KEY_FLAGGED);
		}
	assert(hit.hit>=0&&hit.hit<(DWORD)n);
	keys[hit.hit].SetFlag(KEY_FLAGGED);
	}

template <class KT>
int GenMorphCont<KT>::GetFlagKeyIndex()
	{
	int n = keys.Count();
	for ( int i = 0; i < n; i++ ) {
		if (keys[i].TestFlag(KEY_FLAGGED)) {
			return i;
			}
		}
	return -1;
	}

template <class KT>
TimeValue GenMorphCont<KT>::ProcessORT(TimeValue t)
	{
	int ort;
	
	if (t <= keys.range.Start()) {
		ort = GetORT(ORT_BEFORE);
	} else {
		ort = GetORT(ORT_AFTER);
		}
	
	if (ort==ORT_CONSTANT || keys.range.Empty() || keys.range.InInterval(t)) {      
		return t;
	} else {                
		switch (ort) {
			case ORT_IDENTITY:
			case ORT_LINEAR:
			case ORT_CONSTANT:                      
				if (t<keys.range.Start()) {
					return keys.range.Start();                                      
				} else {
					return keys.range.End();
					}
				break;

			case ORT_RELATIVE_REPEAT:
			case ORT_LOOP:
			case ORT_CYCLE:                                         
				return CycleTime(keys.range,t);                         

			case ORT_OSCILLATE: {
				int cycles = NumCycles(keys.range,t);
				TimeValue tp = CycleTime(keys.range,t);                         
				if (cycles&1) {
					tp = keys.range.End()-(tp-keys.range.Start());
					} 
				return tp;                              
				}                       
			}
		}
	
	return t;
	}

//------------------------------------------------------------------

static void ComputeHermiteBasis(float u, float *v) 
	{
	float u2,u3,a;
	
	u2 = u*u;
	u3 = u2*u;
	a  = 2.0f*u3 - 3.0f*u2;
	v[0] = 1.0f + a;
	v[1] = -a;
	v[2] = u - 2.0f*u2 + u3;
	v[3] = -u2 + u3;
	}

void CubicMorphCont::CalcFirstCoef(float *v,float *c)
	{
	float G, H, J;

	H = .5f*(1.0f-keys[0].tens)*v[2];
	J = 3.0f*H;
	G = v[3] - H;
	c[0] = v[0] - J - G * keys[1].k;
	c[1] = v[1] + J + G*(keys[1].k-keys[1].l);
	c[2] = G*keys[1].l;
	}

void CubicMorphCont::CalcLastCoef(float *v,float *c)
	{
	int nkeys = keys.Count();
	float G, H, J;

	H = .5f*(1.0f-keys[nkeys-1].tens)*v[3];
	J = 3.0f*H;
	G = v[2]-H;
	c[0] = -G*keys[nkeys-2].m;
	c[1] = v[0] - J + G*(keys[nkeys-2].m-keys[nkeys-2].n);
	c[2] = v[1] + J + G*keys[nkeys-2].n;
	}

void CubicMorphCont::CalcMiddleCoef(float *v,int *knum,float *c)
	{
	c[0] = -v[2]*keys[knum[1]].m;
	c[1] = v[0] + v[2]*(keys[knum[1]].m-keys[knum[1]].n) - v[3]*keys[knum[2]].k;
	c[2] = v[1] + v[2]*keys[knum[1]].n + v[3]*(keys[knum[2]].k-keys[knum[2]].l);
	c[3] = v[3]*keys[knum[2]].l;
	}

void CubicMorphCont::HoldTrack()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new CubicMorphRest(this));
		}
	}

void CubicMorphCont::Update(TimeValue t,TimeValue realT)
	{
	if (obValid.InInterval(t)) return;      
	obValid.SetInstant(t);
	
	// Whenever we dump the cache we need to make sure anyone
	// downstream knows about it.
	FreeCache();    
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);       

	if (!targs.Count()) {

		// Build a standin object.              
		ob = ObjectState(CreateNewTriObject());
		ob.obj->LockChannels(ALL_CHANNELS);
		ob.obj->LockObject();
		obValid = FOREVER;
		return;         
		}

	lockCache = TRUE;

	Object *obj[4] = {NULL,NULL,NULL,NULL};
	Matrix3 tms[4] = {Matrix3(1),Matrix3(1),Matrix3(1),Matrix3(1)};
	float v[4] = {0.0f,0.0f,0.0f,0.0f}, c[4] = {0.0f,0.0f,0.0f,0.0f};
	int n0, n1, knum[4], nKeys = keys.Count(), nobs;
	float u;
	
	keys.Update();  
	GetInterpVal(t,n0,n1,u);
	
	ob = targs[0].obj->Eval(t);

	if (nKeys==1 || n0<0 || n1<0) {
		//ob = targs[0].obj->Eval(t);
		nobs = 1;
		c[0]   = 1.0f;
		obj[0] = ob.obj;
		tms[0] = targs[0].tm;
	} else  
	if (n0==n1 || u==0.0f) {
		ObjectState os = targs[keys[n0].targ].obj->Eval(t);
		//ob = targs[keys[n0].targ].obj->Eval(t);
		nobs = 1;
		//obj[0] = ob.obj;
		c[0]   = 1.0f;
		obj[0] = os.obj;
		tms[0] = targs[keys[n0].targ].tm;
	} else 
	if (nKeys==2) {
		//ob = targs[keys[n0].targ].obj->Eval(t);
		ObjectState os1 = targs[keys[n0].targ].obj->Eval(t);
		ObjectState os2 = targs[keys[n1].targ].obj->Eval(t);
		//obj[0] = ob.obj;
		obj[0] = os1.obj;
		obj[1] = os2.obj;
		c[0]   = 1.0f-u;
		c[1]   = u;
		nobs   = 2;
		tms[0] = targs[keys[n0].targ].tm;
		tms[1] = targs[keys[n1].targ].tm;
	} else {
		//ob = targs[keys[n0].targ].obj->Eval(t);

		ComputeHermiteBasis(u,v);

		if (FALSE/*cycle*/) {
			
		} else {
			if (n0==0) {                            
				ObjectState os0 = targs[keys[n0].targ].obj->Eval(t);
				ObjectState os1 = targs[keys[n1].targ].obj->Eval(t);            
				ObjectState os2 = targs[keys[n1+1].targ].obj->Eval(t);
				//obj[0] = ob.obj;
				obj[0] = os0.obj;
				obj[1] = os1.obj;
				obj[2] = os2.obj;
				CalcFirstCoef(v,c);
				tms[0] = targs[keys[n0].targ].tm;
				tms[1] = targs[keys[n1].targ].tm;
				tms[2] = targs[keys[n1+1].targ].tm;
				nobs = 3;
			} else
			if (n1==nKeys-1) {                                                              
				ObjectState os0 = targs[keys[n0-1].targ].obj->Eval(t);          
				ObjectState os1 = targs[keys[n0].targ].obj->Eval(t);
				ObjectState os2 = targs[keys[n1].targ].obj->Eval(t);
				obj[0] = os0.obj;
				//obj[1] = ob.obj;
				obj[1] = os1.obj;
				obj[2] = os2.obj;
				CalcLastCoef(v,c);
				tms[0] = targs[keys[n0-1].targ].tm;
				tms[1] = targs[keys[n0].targ].tm;
				tms[2] = targs[keys[n1].targ].tm;
				nobs = 3;
			} else {                                
				ObjectState os0 = targs[keys[n0-1].targ].obj->Eval(t);
				ObjectState os1 = targs[keys[n0].targ].obj->Eval(t);
				ObjectState os2 = targs[keys[n1].targ].obj->Eval(t);                                            
				ObjectState os3 = targs[keys[n1+1].targ].obj->Eval(t);
				obj[0]  = os0.obj;
				//obj[1]  = ob.obj;
				obj[1]  = os1.obj;
				obj[2]  = os2.obj;
				obj[3]  = os3.obj;
				knum[0] = n0-1;
				knum[1] = n0;
				knum[2] = n1;
				knum[3] = n1+1;
				CalcMiddleCoef(v,knum,c);
				tms[0] = targs[keys[n0-1].targ].tm;
				tms[1] = targs[keys[n0].targ].tm;
				tms[2] = targs[keys[n1].targ].tm;
				tms[3] = targs[keys[n1+1].targ].tm;
				nobs = 4;
				}
			}
		}
			
	// Make sure all objects are deformable
	BOOL del[4] = {FALSE,FALSE,FALSE,FALSE};        
	for (int i=0; i<nobs; i++) {            
		if (!obj[i]->IsDeformable()) {
			Object *o = obj[i]->ConvertToType(t,defObjectClassID);
			assert(o);           
			
			// RB:6/20/96: If ConvertToType() actually returned something
			// new then it should be unlocked.
			if (o!=obj[i]) {
				
				// RB 11/21/96: This looked wrong!
				//ob.obj->UnlockObject();
				o->UnlockObject();
				}

			if (obj[i]==ob.obj) {
				// This is the one we're gonna hang on to, don't delete it.
				ob.obj = o;
				obj[i] = o;
			} else {
				if (o!=obj[i]) {
					// ConvertToType() created a new object. Make sure we delete it.
					del[i] = TRUE;
					obj[i] = o;
					}
				}
			}
		}

	// Make sure the main object is deformable
	if (!ob.obj->IsDeformable()) {
		Object *oldObj = ob.obj;
		ob.obj = ob.obj->ConvertToType(t,defObjectClassID);
		assert(ob.obj);
		
		// RB:6/20/96: If ConvertToType() actually returned something
		// new then it should be unlocked.
		if (oldObj!=ob.obj) {
			ob.obj->UnlockObject();
			}
		}

	// Prepare the geom channel to be modified
	if (ob.obj->IsObjectLocked()) {
		ob.obj = ob.obj->MakeShallowCopy(OBJ_CHANNELS);
		
		// RB 6/20/96 These next two lines didn't used to be inside this
		// if statement, however we only want to lock the object channels
		// if we made a shallow copy.
		ob.obj->LockChannels(OBJ_CHANNELS);
		ob.obj->UnlockObject();
		}	
	ob.obj->ReadyChannelsForMod(GEOM_CHANNEL);              
	
	// Blend the objects
	if (nobs>0) {
		// Find the object with the least number of points.
		int pts = ob.obj->NumPoints();
		for (int i=0; i<nobs; i++) {
			if (obj[i]->NumPoints()<pts) pts = obj[i]->NumPoints();
			}
		for (i=0; i<pts; i++) {
			Point3 p = (obj[0]->GetPoint(i)*tms[0]) * c[0];
			for (int j=1; j<nobs; j++) {
				p += (obj[j]->GetPoint(i)*tms[j]) * c[j];
				}
			ob.obj->SetPoint(i,p);
			if (ob.obj->HasWeights()) {
				double w = obj[0]->GetWeight(i) * c[0];
				for (int j=1; j<nobs; j++) {
					w += (obj[j]->GetWeight(i)) * c[j];
					}
				ob.obj->SetWeight(i, w);
				}
			}
		ob.obj->PointsWereChanged();
	} else {
		// Just transform the object
		for (int i=0; i<ob.obj->NumPoints(); i++) {
			ob.obj->SetPoint(i,ob.obj->GetPoint(i)*tms[0]);
			}
		}
	
	// Delete any objects that were created from ConvertToType()    
	for (i=0; i<nobs; i++) {
		if (del[i]) obj[i]->DeleteThis();
		}

	// Lock it since I'm going to hold on to it and return it.
	ob.obj->LockChannels(GEOM_CHANNEL);
	ob.obj->UpdateValidity(GEOM_CHAN_NUM,Interval(realT,realT));
	ob.obj->LockObject();
	lockCache = FALSE;
	}

void CubicMorphCont::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	TimeValue rt = t;
	Interval evalid;
	t = ApplyEase(t,evalid);
	t = ProcessORT(t);
	Update(t,rt);
	ObjectState *os = (ObjectState*)val;
	*os = ob;               
	}

void CubicMorphCont::DeleteMorphTarg(int i)
	{
	HoldTrack();
	for (int j=keys.Count()-1; j>=0; j--) {
		if (keys[j].targ==i) {
			keys.Delete(j,1);
		} else
		if (keys[j].targ>i) {
			keys[j].targ--;
			}
		}
	FreeCache();    
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GenMorphCont<CubicMorphKeyTab>::DeleteMorphTarg(i);
	}


//------------------------------------------------------------------

#define MORPHKEY_TABLE_CHUNK    0x02001
#define MORPHKEY_FLAGS_CHUNK    0x02002
#define MORPHKEY_RANGE_CHUNK    0x02003

	
void CubicMorphKey::Invalidate()
	{
	ClearFlag(MULTS_VALID); 
	}

void CubicMorphKey::ComputeMults()
	{
	if (!TestFlag(MULTS_VALID)) {
		float tm,cm,cp,bm,bp,tmcm,tmcp;
		tm = 0.5f*(1.0f - tens);
		cm = 1.0f - cont;       
		cp = 2.0f - cm;
		bm = 1.0f - bias;
		bp = 2.0f - bm;      
		tmcm = tm*cm;   tmcp = tm*cp;   
		k = tmcm*bp;    l = tmcp*bm;
		m = tmcp*bp;    n = tmcm*bm;
		SetFlag(MULTS_VALID);
		}
	}

void CubicMorphKeyTab::Update() 
	{
	if (TestFlag(TRACK_INVALID)) {
		ClearFlag(TRACK_INVALID);
		
		// Sort the array by time and shrink
		Sort((CompareFnc)CompareMorphKeys);
		CheckForDups(); 
		Shrink();
		
		// Update the range
		if (!TestFlag(RANGE_UNLOCKED)) {
			if (Count()) {
				range.Set((*this)[0].time,(*this)[Count()-1].time);
			} else {
				range.SetEmpty();
				}
			}
		
		// Compute the multipliers
		for (int i=0; i<Count(); i++) {
			(*this)[i].ComputeMults();
			}
		}
	}

IOResult CubicMorphKeyTab::Save(ISave *isave)
	{
	ULONG nb;

	if (Count()>0) {
		isave->BeginChunk(MORPHKEY_TABLE_CHUNK);
		isave->Write(Addr(0), sizeof(CubicMorphKey)*Count(), &nb);
		isave->EndChunk();
		}
	
	isave->BeginChunk(MORPHKEY_FLAGS_CHUNK);
	isave->Write(&flags, sizeof(flags), &nb);
	isave->EndChunk();

	isave->BeginChunk(MORPHKEY_RANGE_CHUNK);
	isave->Write(&range, sizeof(range), &nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult CubicMorphKeyTab::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;

	Resize(0);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case MORPHKEY_TABLE_CHUNK: {
				int nkeys = (iload->CurChunkLength())/sizeof(CubicMorphKey);
				SetCount(nkeys);
				if (nkeys>0) 
					res = iload->Read(Addr(0),nkeys*sizeof(CubicMorphKey),&nb);
				break;
				}

			case MORPHKEY_FLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;

			case MORPHKEY_RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	Invalidate();
	return IO_OK;
	}

//---------------------------------------------------------------------------
//
// UI stuff --- keyinfo
//
//

static HIMAGELIST hKeyInfoImages = NULL;
static BOOL tcbRegistered=FALSE;

static void LoadResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;  
	HBITMAP hBitmap, hMask;	
	
	hKeyInfoImages = ImageList_Create(16, 15, TRUE, 6, 0);
	hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_HYBRIDKEYBUTTONS));
	hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MASK_HYBRIDKEYBUTTONS));
	ImageList_Add(hKeyInfoImages,hBitmap,hMask);
	DeleteObject(hBitmap);  
	DeleteObject(hMask);            
	}

class DeleteMorphKeyInfoResources {
	public:
		~DeleteMorphKeyInfoResources() {
			ImageList_Destroy(hKeyInfoImages);
			}
	};
static DeleteMorphKeyInfoResources      theDelete;

static BOOL CALLBACK CubicMorphKeyInfoWndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define CUBICMORPH_DLG_CLASSID	0xf980e27a

class CubicMorphKeyInfo : public ReferenceMaker {
	public:
		CubicMorphCont *cont;
		IObjParam *ip;
		HWND hWnd, hName;
		ISpinnerControl *iTime, *iT, *iC, *iB;
		ICustButton *iPrevKey, *iNextKey;
		ICustStatus *iKeyNum;
		BOOL valid;

		CubicMorphKeyInfo(CubicMorphCont *c,IObjParam *i,HWND hParent);
		~CubicMorphKeyInfo();
		void Init(HWND hWnd);
		void Invalidate();
		void InvalidateGraph();
		void Update();          

		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}
		Class_ID ClassID() {return Class_ID(CUBICMORPH_DLG_CLASSID,0);}
		void MaybeCloseWindow();

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		 PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(CubicMorphCont*)rtarg;}

		void SelectPrevKey();
		void SelectNextKey();
		void ApplyTimeChange();
		void ApplyTensChange();
		void ApplyContChange();
		void ApplyBiasChange();

		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerStart(int id);
		void SpinnerChange(int id);
		void SpinnerEnd(int id,BOOL cancel);
	};

CubicMorphKeyInfo::CubicMorphKeyInfo(
		CubicMorphCont *c,IObjParam *i,HWND hParent)
	{	
	if (!tcbRegistered) {
		InitTCBGraph(hInstance);
		tcbRegistered = TRUE;
		}

	cont = NULL;
	ip = i;
	MakeRefByID(FOREVER,0,c);

	LoadResources();
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_CUBICMORPH_KEYINFO),
		hParent,
		CubicMorphKeyInfoWndProc,
		(LPARAM)this);  
	RegisterMorphKeyWindow(hWnd,hParent,c);
	}

CubicMorphKeyInfo::~CubicMorphKeyInfo()
	{
	UnRegisterMorphKeyWindow(hWnd);
	ReleaseISpinner(iTime);
	ReleaseISpinner(iT);
	ReleaseISpinner(iC);
	ReleaseISpinner(iB);
	ReleaseICustButton(iPrevKey);
	ReleaseICustButton(iNextKey);
	ReleaseICustStatus(iKeyNum);
	DeleteAllRefsFromMe();
	}

class CheckForNonCubicMorphDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonCubicMorphDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(CUBICMORPH_DLG_CLASSID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void CubicMorphKeyInfo::MaybeCloseWindow()
	{
	CheckForNonCubicMorphDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}

RefResult CubicMorphKeyInfo::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,  
		RefMessage message)
	{
	switch (message) {
		case REFMSG_NODE_NAMECHANGE:
		case REFMSG_CHANGE:
			Invalidate();
			break;

		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}

void CubicMorphKeyInfo::SelectPrevKey()
	{
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			int j = ((i-1)+cont->keys.Count())%cont->keys.Count();
			cont->keys[i].ClearFlag(KEY_SELECTED);
			cont->keys[j].SetFlag(KEY_SELECTED);                    
			break;
			}
		}
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void CubicMorphKeyInfo::SelectNextKey()
	{
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			int j = (i+1)%cont->keys.Count();
			cont->keys[i].ClearFlag(KEY_SELECTED);
			cont->keys[j].SetFlag(KEY_SELECTED);                    
			break;
			}
		}
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void CubicMorphKeyInfo::ApplyTimeChange()
	{
	int t = iTime->GetIVal();
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].time = t;
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	UpdateWindow(GetParent(hWnd));
	}

void CubicMorphKeyInfo::ApplyTensChange()
	{
	float t = iT->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].tens = t;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void CubicMorphKeyInfo::ApplyContChange()
	{
	float c = iC->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].cont = c;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void CubicMorphKeyInfo::ApplyBiasChange()
	{
	float b = iB->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].bias = b;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void CubicMorphKeyInfo::Init(HWND hWnd)
	{
	this->hWnd = hWnd;
	
	iT = GetISpinner(GetDlgItem(hWnd,IDC_TCB_TSPIN));
	iT->SetLimits(0.0f,50.0f,FALSE);
	iT->SetScale(0.1f);
	iT->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_T),EDITTYPE_FLOAT);

	iC = GetISpinner(GetDlgItem(hWnd,IDC_TCB_CSPIN));
	iC->SetLimits(0.0f,50.0f,FALSE);
	iC->SetScale(0.1f);
	iC->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_C),EDITTYPE_FLOAT);

	iB = GetISpinner(GetDlgItem(hWnd,IDC_TCB_BSPIN));
	iB->SetLimits(0.0f,50.0f,FALSE);
	iB->SetScale(0.1f);
	iB->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_B),EDITTYPE_FLOAT);

	iTime = GetISpinner(GetDlgItem(hWnd,IDC_KEYTIMESPIN));
	iTime->SetLimits(TIME_NegInfinity,TIME_PosInfinity,FALSE);
	iTime->SetScale(10.0f);
	iTime->LinkToEdit(GetDlgItem(hWnd,IDC_KEYTIME),EDITTYPE_TIME);

	iPrevKey = GetICustButton(GetDlgItem(hWnd,IDC_PREVKEY));
	iNextKey = GetICustButton(GetDlgItem(hWnd,IDC_NEXTKEY));
	iPrevKey->SetImage(hKeyInfoImages,3,3,8,8,16,15);
	iNextKey->SetImage(hKeyInfoImages,4,4,9,9,16,15);
	iKeyNum  = GetICustStatus(GetDlgItem(hWnd,IDC_KEYNUM));

	hName = GetDlgItem(hWnd,IDC_TARGNAME);

	Update();
	}

void CubicMorphKeyInfo::Invalidate()
	{
	valid = FALSE;	
	InvalidateRect(hWnd,NULL,FALSE);
	InvalidateGraph();
	}

void CubicMorphKeyInfo::InvalidateGraph()
	{
	HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
	InvalidateRect(hGraph,NULL,FALSE);
	}

void CubicMorphKeyInfo::Update()
	{
	valid = TRUE;

	TimeValue time;
	float T, C, B;
	BOOL timeInit=FALSE,timeValid=FALSE;
	BOOL tValid, tInit, bValid, bInit, cValid, cInit;
	int numSel = 0, sel = -1;
	tValid = tInit = bValid = bInit = cValid = cInit = FALSE;

	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			sel = i;
			numSel++;

			if (timeInit) {
				if (time != cont->keys[i].time) {
					timeValid = FALSE;
					}
			} else {
				timeInit  = TRUE;
				timeValid = TRUE;
				time      = cont->keys[i].time;
				}

			if (tInit) {
				if (T != cont->keys[i].tens) {
					tValid = FALSE;
					}
			} else {
				tInit  = TRUE;
				tValid = TRUE;
				T      = cont->keys[i].tens;
				}
			
			if (cInit) {
				if (C != cont->keys[i].cont) {
					cValid = FALSE;
					}
			} else {
				cInit  = TRUE;
				cValid = TRUE;
				C      = cont->keys[i].cont;
				}

			if (bInit) {
				if (B != cont->keys[i].bias) {
					bValid = FALSE;
					}
			} else {
				bInit  = TRUE;
				bValid = TRUE;
				B      = cont->keys[i].bias;
				}
			}
		}
	
	if (timeValid) {
		iTime->SetValue(time,FALSE);
		iTime->Enable();
		iTime->SetIndeterminate(FALSE);
	} else {
		iTime->SetIndeterminate();
		iTime->Disable();
		}

	if (tValid) {
		iT->SetValue((T+1.0f)*25.0f,FALSE);             
		iT->SetIndeterminate(FALSE);
	} else {
		iT->SetIndeterminate();         
		}
	if (cValid) {
		iC->SetValue((C+1.0f)*25.0f,FALSE);             
		iC->SetIndeterminate(FALSE);
	} else {
		iC->SetIndeterminate();         
		}
	if (bValid) {
		iB->SetValue((B+1.0f)*25.0f,FALSE);             
		iB->SetIndeterminate(FALSE);
	} else {
		iB->SetIndeterminate();         
		}

	if (tValid && cValid && bValid) {
		TCBGraphParams gp;
		gp.tens     = T;
		gp.cont     = C;
		gp.bias     = B;
		gp.easeFrom = 0.0f;
		gp.easeTo   = 0.0f;
		HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
		EnableWindow(hGraph,TRUE);
		SendMessage(hGraph,WM_SETTCBGRAPHPARAMS,0,(LPARAM)&gp);
		UpdateWindow(hGraph);
	} else {
		HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
		EnableWindow(hGraph,FALSE);
		}

	if (numSel==1) {
		TSTR buf;
		buf.printf(_T("%d"),sel+1);
		iKeyNum->SetText(buf);
		iPrevKey->Enable();
		iNextKey->Enable();
		//buf.printf(GetString(IDS_RB_TARGETNUMBER),cont->keys[sel].targ);           
		SetWindowText(hName,*cont->targs[cont->keys[sel].targ].name);
	} else {
		iKeyNum->SetText(_T(""));
		iPrevKey->Disable();
		iNextKey->Disable();
		SetWindowText(hName,NULL);              
		}
	}

void CubicMorphKeyInfo::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_PREVKEY:
			SelectPrevKey();
			break;
		case IDC_NEXTKEY:
			SelectNextKey();
			break;
		
		case IDCANCEL:                  
		case IDOK:
			DestroyWindow(hWnd);
			break;
		}
	}

void CubicMorphKeyInfo::SpinnerStart(int id)
	{
	theHold.Begin();
	cont->HoldTrack();
	}

void CubicMorphKeyInfo::SpinnerChange(int id)
	{
	switch (id) {
		case IDC_KEYTIMESPIN:
			ApplyTimeChange(); break;

		case IDC_TCB_TSPIN:
			ApplyTensChange(); break;
		case IDC_TCB_CSPIN:
			ApplyContChange(); break;
		case IDC_TCB_BSPIN:
			ApplyBiasChange(); break;
		}
	}

void CubicMorphKeyInfo::SpinnerEnd(int id,BOOL cancel)
	{
	if (cancel) {
		theHold.Cancel();
	} else {
		theHold.Accept(GetString(IDS_RB_EDITKEYINFO));
		}
	}



static BOOL CALLBACK CubicMorphKeyInfoWndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	CubicMorphKeyInfo *k = (CubicMorphKeyInfo*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			k = (CubicMorphKeyInfo*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			k->Init(hWnd);
			return FALSE;   // DB 2/27

		case WM_PAINT:
			if (!k->valid) {
				k->Update();
				}
			return 0;
		
		case CC_SPINNER_BUTTONDOWN:
			k->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			k->SpinnerChange(LOWORD(wParam));
			break;

		case CC_SPINNER_BUTTONUP:
			k->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			k->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);                                               
			break;
		
		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			delete k;
			break;

		default:
			return 0;
		}
	return 1;
	}

void CubicMorphCont::EditTrackParams(
		TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,
		IObjParam *ip,DWORD flags)
	{
	HWND hCur = FindOpenMorphKeyWindow(hParent,this);
	if (hCur) {
		SetForegroundWindow(hCur);
		return;
		}
	new CubicMorphKeyInfo(this,ip,hParent);
	}

RefTargetHandle CubicMorphCont::Clone(RemapDir& remap)
	{
	CubicMorphCont *cont = new CubicMorphCont;
	cont->keys = keys;
	cont->obValid.SetEmpty();
	cont->version = version;
	for (int i=0; i<targs.Count(); i++) {
		cont->targs.AddTarg(
			targs[i].obj,
			*(targs[i].name),
			targs[i].tm,
			cont,
			cont->Control::NumRefs());              
		}
	return cont;
	}

void CubicMorphCont::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		CubicMorphCont *cont = (CubicMorphCont*)from;
		keys = cont->keys;
		obValid.SetEmpty();
		version = cont->version;
		for (int i=0; i<cont->targs.Count(); i++) {
			targs.AddTarg(
				cont->targs[i].obj,
				*(cont->targs[i].name),
				cont->targs[i].tm,
				this,
				Control::NumRefs());              
			}
	} else if (from->ClassID()==Class_ID(BARYMORPHCONT_CLASS_ID,0)) {
		BaryMorphCont *cont = (BaryMorphCont*)from;
		for (int i=0; i<cont->targs.Count(); i++) {
			targs.AddTarg(
				cont->targs[i].obj,
				*(cont->targs[i].name),
				cont->targs[i].tm,
				this,
				Control::NumRefs());              
			}
		for (i=0; i<cont->keys.Count(); i++) {
			if (cont->keys[i].WTS().Count()) {
				int best    = cont->keys[i].WTS()[0].targ;
				float fbest = cont->keys[i].WTS()[0].percent;
				for (int j=0; j<cont->keys[i].WTS().Count(); j++) {
					if (fabs(cont->keys[i].WTS()[j].percent)>fabs(fbest)) {
						best  = cont->keys[i].WTS()[j].targ;
						fbest = cont->keys[i].WTS()[j].percent;
						}
					}
				keys.AddNewKey(cont->keys[i].time,best);
				}
			}
		}
	}




//-----------------------------------------------------------------------

	
void BaryMorphKey::Invalidate()
	{
	ClearFlag(MULTS_VALID); 
	}

void BaryMorphKey::ComputeMults()
	{
	if (!TestFlag(MULTS_VALID)) {
		float tm,cm,cp,bm,bp,tmcm,tmcp;
		tm = 0.5f*(1.0f - tens);
		cm = 1.0f - cont;       
		cp = 2.0f - cm;
		bm = 1.0f - bias;
		bp = 2.0f - bm;      
		tmcm = tm*cm;   tmcp = tm*cp;   
		k = tmcm*bp;    l = tmcp*bm;
		m = tmcp*bp;    n = tmcm*bm;
		SetFlag(MULTS_VALID);
		}
	}

void BaryMorphKey::TargetDeleted(int t)
	{
	for (int i=wts->Count()-1; i>=0; i--) {
		if (WTS()[i].targ>t) WTS()[i].targ--;
		else
		if (WTS()[i].targ==t) WTS().Delete(i,1);
		}
	}

float BaryMorphKey::GetWeight(int t)
	{
	for (int i=0; i<wts->Count(); i++) {
		if (WTS()[i].targ==t) return WTS()[i].percent;
		}
	return 0.0f;
	}

void BaryMorphKey::SetWeight(int t,float w)
	{
	for (int i=0; i<wts->Count(); i++) {
		if (WTS()[i].targ==t) {
			if (w==0.0f) WTS().Delete(i,1);
			else WTS()[i].percent = w;
			return;
			}
		}
	TargetWeight wt(t,w);
	WTS().Append(1,&wt);
	}

void BaryMorphKeyTab::Update() 
	{
	if (TestFlag(TRACK_INVALID)) {
		ClearFlag(TRACK_INVALID);
		
		// Sort the array by time and shrink
		Sort((CompareFnc)CompareMorphKeys);
		//CheckForDups();	// RB 4/21/99: Only do this on mouse cycle completed.
		Shrink();
		
		// Update the range
		if (!TestFlag(RANGE_UNLOCKED)) {
			if (Count()) {
				range.Set((*this)[0].time,(*this)[Count()-1].time);
			} else {
				range.SetEmpty();
				}
			}
		
		// Compute the multipliers
		for (int i=0; i<Count(); i++) {
			(*this)[i].ComputeMults();
			}
		}
	}

#define BARYKEYTABLE_COUNT		0x0300
#define BARYKEYTABLE_KEYDATA	0x0310
#define BARYKEYTABLE_TARG		0x0320

IOResult BaryMorphKeyTab::Save(ISave *isave)
	{
	ULONG nb;	
	
	isave->BeginChunk(MORPHKEY_FLAGS_CHUNK);
	isave->Write(&flags, sizeof(flags), &nb);
	isave->EndChunk();

	isave->BeginChunk(MORPHKEY_RANGE_CHUNK);
	isave->Write(&range, sizeof(range), &nb);
	isave->EndChunk();
	
	int ct = Count();
	isave->BeginChunk(BARYKEYTABLE_COUNT);
	isave->Write(&ct, sizeof(ct), &nb);
	isave->EndChunk();

	for (int i=0; i<ct; i++) {
		isave->BeginChunk(BARYKEYTABLE_KEYDATA);
		isave->Write(&(*this)[i],sizeof(BaryMorphKey),&nb);
		isave->EndChunk();
		
		for (int j=0; j<(*this)[i].wts->Count(); j++) {
			isave->BeginChunk(BARYKEYTABLE_TARG);
			isave->Write(&(*this)[i].WTS()[j],sizeof(TargetWeight),&nb);
			isave->EndChunk();
			}		
		}

	return IO_OK;
	}

IOResult BaryMorphKeyTab::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	int ct, ix=-1;

	Resize(0);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case BARYKEYTABLE_COUNT:
				res=iload->Read(&ct,sizeof(ct),&nb);
				SetCount(ct);
				break;

			case BARYKEYTABLE_KEYDATA:
				ix++;
				res=iload->Read(&(*this)[ix],sizeof(BaryMorphKey),&nb);
				(*this)[ix].wts = new Tab<TargetWeight>;
				break;

			case BARYKEYTABLE_TARG: {
				TargetWeight wt;
				res=iload->Read(&wt,sizeof(wt),&nb);
				(*this)[ix].wts->Append(1,&wt);
				break;
				}

			case MORPHKEY_FLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;

			case MORPHKEY_RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	Invalidate();
	return IO_OK;
	}

//-------------------------------------------------------------------

void BaryMorphCont::CalcFirstCoef(float *v,float *c)
	{
	float G, H, J;

	H = .5f*(1.0f-keys[0].tens)*v[2];
	J = 3.0f*H;
	G = v[3] - H;
	c[0] = v[0] - J - G * keys[1].k;
	c[1] = v[1] + J + G*(keys[1].k-keys[1].l);
	c[2] = G*keys[1].l;
	}

void BaryMorphCont::CalcLastCoef(float *v,float *c)
	{
	int nkeys = keys.Count();
	float G, H, J;

	H = .5f*(1.0f-keys[nkeys-1].tens)*v[3];
	J = 3.0f*H;
	G = v[2]-H;
	c[0] = -G*keys[nkeys-2].m;
	c[1] = v[0] - J + G*(keys[nkeys-2].m-keys[nkeys-2].n);
	c[2] = v[1] + J + G*keys[nkeys-2].n;
	}

void BaryMorphCont::CalcMiddleCoef(float *v,int *knum,float *c)
	{
	c[0] = -v[2]*keys[knum[1]].m;
	c[1] = v[0] + v[2]*(keys[knum[1]].m-keys[knum[1]].n) - v[3]*keys[knum[2]].k;
	c[2] = v[1] + v[2]*keys[knum[1]].n + v[3]*(keys[knum[2]].k-keys[knum[2]].l);
	c[3] = v[3]*keys[knum[2]].l;
	}

void BaryMorphCont::HoldTrack()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new BaryMorphRest(this));
		}
	}

void BaryMorphCont::Update(TimeValue t,TimeValue realT)
	{
	if (obValid.InInterval(t)) return;      
	obValid.SetInstant(t);
	
	// Whenever we dump the cache we need to make sure anyone
	// downstream knows about it.
	FreeCache();    
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);       

	if (!targs.Count()) {
		// Build a standin object.              
		ob = ObjectState(CreateNewTriObject());
		ob.obj->LockChannels(ALL_CHANNELS);
		ob.obj->LockObject();
		obValid = FOREVER;
		return;         
		}

	lockCache = TRUE;
	
	float v[4] = {0.0f,0.0f,0.0f,0.0f}, c[4] = {0.0f,0.0f,0.0f,0.0f};
	int n0, n1, nKeys = keys.Count();
	float u;
	int knum[4], keyct=0;
	
	keys.Update();  
	GetInterpVal(t,n0,n1,u);	

	// Compute coeffeceints	
	if (nKeys==0) keyct=0;
	else
	if (nKeys==1 || n0<0 || n1<0) {
		keyct   = 1;
		knum[0] = 0;
		c[0]    = 1.0f;
	} else 
	if (n0==n1 || u==0.0f) {
		keyct   = 1;
		knum[0] = n0;
		c[0]    = 1.0f;
	} else 
	if (nKeys==2) {
		keyct   = 2;
		knum[0] = n0;
		knum[1] = n1;
		c[0]    = 1.0f-u;
		c[1]    = u;		
	} else {
		ComputeHermiteBasis(u,v);
		if (n0==0) {
			keyct = 3;
			knum[0] = n0;
			knum[1] = n1;
			knum[2] = n1+1;
			CalcFirstCoef(v,c);
		} else
		if (n1==nKeys-1) {
			keyct = 3;
			knum[0] = n0-1;
			knum[1] = n0;
			knum[2] = n1;
			CalcLastCoef(v,c);
		} else {			
			keyct = 4;
			knum[0] = n0-1;
			knum[1] = n0;
			knum[2] = n1;
			knum[3] = n1+1;
			CalcMiddleCoef(v,knum,c);
			}
		}
	
	// Interpolate weights
	Tab<float> wts;
	wts.SetCount(targs.Count());
	for (int i=0; i<wts.Count(); i++) {
		wts[i] = 0.0f;
		for (int j=0; j<keyct; j++) {
			wts[i] += keys[knum[j]].GetWeight(i) * c[j];
			}
		}
	// Special case... if there are no keys, set the first weight to 1
	if (!nKeys) wts[0] = 1.0f;

	// Evaluate objects with non-zero weights
	// Always evaluate the 0th object because that's the object we are going to deform
	Tab<Object*> objs;
	objs.SetCount(targs.Count());
	Tab<BOOL> del;
	del.SetCount(targs.Count());
	for (i=0; i<targs.Count(); i++) {
		objs[i] = NULL;
		del[i]  = FALSE;
		if (wts[i]!=0.0f || !i) {
			// Eval the obejct			
			ObjectState os = targs[i].obj->Eval(t);
			objs[i] = os.obj;
			if (i==0) ob = os;

			// Make sure all objects are deformable
			if (!objs[i]->IsDeformable()) {
				// Convert to deformable
				Object *o = objs[i]->ConvertToType(t,defObjectClassID);
				
				// Unlock if it's a new object				
				if (o!=objs[i]) {
					o->UnlockObject();
					objs[i] = o;
					// Mark it as needing deletion (if it's not the first object)
					if (i) del[i] = TRUE;
					}
				}			
			}
		}
	ob.obj = objs[0]; // Make sure they're in synch	

	// Prepare the geom channel to be modified
	if (ob.obj->IsObjectLocked()) {
		ob.obj = ob.obj->MakeShallowCopy(OBJ_CHANNELS);		
		ob.obj->LockChannels(OBJ_CHANNELS);
		ob.obj->UnlockObject();
		}	
	ob.obj->ReadyChannelsForMod(GEOM_CHANNEL);              
	
	// Blend between all the targets
	int pts = ob.obj->NumPoints();
	for (i=0; i<pts; i++) {
		Point3 pt(0,0,0);
		for (int j=0; j<targs.Count(); j++) {
			if (objs[j] && i<objs[j]->NumPoints()) {
				pt += (objs[j]->GetPoint(i)*targs[j].tm) * wts[j];
				}
			}
		ob.obj->SetPoint(i,pt);
		if (ob.obj->HasWeights()) {
			double w = 0.0;
			for (int j=0; j<targs.Count(); j++) {
				if (objs[j] && i<objs[j]->NumPoints()) {
					w += objs[j]->GetWeight(i) * wts[j];
					}
				}
			ob.obj->SetWeight(i, w);
			}
		}
	ob.obj->PointsWereChanged();
		
	// Delete any objects that were created from ConvertToType()    
	for (i=0; i<targs.Count(); i++) {
		if (del[i]) objs[i]->DeleteThis();
		}

	// Lock it since I'm going to hold on to it and return it.
	ob.obj->LockChannels(GEOM_CHANNEL);
	ob.obj->UpdateValidity(GEOM_CHAN_NUM,Interval(realT,realT));
	ob.obj->LockObject();
	lockCache = FALSE;
	}

void BaryMorphCont::AddNewKey(TimeValue t,DWORD flags)
	{	
	int n0, n1, nKeys = keys.Count();
	float u;
	int knum[4], keyct=0;
	float c[4], v[4];
	
	if (!targs.Count()) return;
	GetInterpVal(t,n0,n1,u);

	// Compute coeffeceints	
	if (nKeys==0) keyct=0;
	else
	if (nKeys==1 || n0<0 || n1<0) {
		keyct   = 1;
		knum[0] = 0;
		c[0]    = 1.0f;
	} else 
	if (n0==n1 || u==0.0f) {
		keyct   = 1;
		knum[0] = n0;
		c[0]    = 1.0f;
	} else 
	if (nKeys==2) {
		keyct   = 2;
		knum[0] = n0;
		knum[1] = n1;
		c[0]    = 1.0f-u;
		c[1]    = u;		
	} else {
		ComputeHermiteBasis(u,v);
		if (n0==0) {
			keyct = 3;
			knum[0] = n0;
			knum[1] = n1;
			knum[2] = n1+1;
			CalcFirstCoef(v,c);
		} else
		if (n1==nKeys-1) {
			keyct = 3;
			knum[0] = n0-1;
			knum[1] = n0;
			knum[2] = n1;
			CalcLastCoef(v,c);
		} else {			
			keyct = 4;
			knum[0] = n0-1;
			knum[1] = n0;
			knum[2] = n1;
			knum[3] = n1+1;
			CalcMiddleCoef(v,knum,c);
			}
		}

	// Interpolate weights
	Tab<float> wts;
	wts.SetCount(targs.Count());
	for (int i=0; i<wts.Count(); i++) {
		wts[i] = 0.0f;
		for (int j=0; j<keyct; j++) {
			wts[i] += keys[knum[j]].GetWeight(i) * c[j];
			}
		}
	if (keyct==0) wts[0] = 1.0f;

	// Deselect all keys
	for (i=0; i<keys.Count(); i++) keys[i].ClearFlag(KEY_SELECTED);

	// Add the key
	HoldTrack();
	BaryMorphKey key;
	key.time = t;	
	key.SetFlag(KEY_SELECTED);
	for (i=0; i<wts.Count(); i++) {
		key.SetWeight(i,wts[i]);
		}
	key.Invalidate();
	keys.Append(1,&key,5);
	keys.Invalidate();	
	Invalidate();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void BaryMorphCont::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{       
	TimeValue rt = t;
	Interval evalid;
	t = ApplyEase(t,evalid);
	t = ProcessORT(t);
	Update(t,rt);
	ObjectState *os = (ObjectState*)val;
	*os = ob;               
	}

void BaryMorphCont::DeleteMorphTarg(int i)
	{
	HoldTrack();
	for (int j=keys.Count()-1; j>=0; j--) {
		keys[j].TargetDeleted(i);
		}
	FreeCache();    
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GenMorphCont<BaryMorphKeyTab>::DeleteMorphTarg(i);
	}

RefTargetHandle BaryMorphCont::Clone(RemapDir& remap)
	{
	BaryMorphCont *cont = new BaryMorphCont;
	cont->keys = keys;
	cont->obValid.SetEmpty();
	cont->version = version;
	for (int i=0; i<targs.Count(); i++) {
		cont->targs.AddTarg(
			targs[i].obj,
			*(targs[i].name),
			targs[i].tm,
			cont,
			cont->Control::NumRefs());              
		}
	return cont;
	}

void BaryMorphCont::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		BaryMorphCont *cont = (BaryMorphCont*)from;
		keys = cont->keys;
		obValid.SetEmpty();
		version = cont->version;
		for (int i=0; i<cont->targs.Count(); i++) {
			targs.AddTarg(
				cont->targs[i].obj,
				*(cont->targs[i].name),
				cont->targs[i].tm,
				this,
				Control::NumRefs());              
			}
	} else if (from->ClassID()==Class_ID(CUBICMORPHCONT_CLASS_ID,0)) {
		CubicMorphCont *cont = (CubicMorphCont*)from;
		for (int i=0; i<cont->targs.Count(); i++) {
			targs.AddTarg(
				cont->targs[i].obj,
				*(cont->targs[i].name),
				cont->targs[i].tm,
				this,
				Control::NumRefs());              
			}
		for (i=0; i<cont->keys.Count(); i++) {
			keys.AddNewKey(cont->keys[i].time,cont->keys[i].targ);
			}
		}
	}



//---------------------------------------------------------------------------
//
// UI stuff --- keyinfo for Barycentric controller
//
//

static BOOL CALLBACK BaryMorphKeyInfoWndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static BOOL constrain100 = TRUE;

void BaryMorphContClassDesc::ResetClassParams(BOOL fileReset)
	{
	constrain100 = TRUE;
	}

#define BARYMORPH_DLG_CLASSID	0x918c74ba

class BaryMorphKeyInfo : public ReferenceMaker {
	public:
		BaryMorphCont *cont;
		IObjParam *ip;
		HWND hWnd, hList;
		ISpinnerControl *iTime, *iT, *iC, *iB, *iPerc;
		ICustButton *iPrevKey, *iNextKey;
		ICustStatus *iKeyNum;
		BOOL valid;
		int lastSel;

		BaryMorphKeyInfo(BaryMorphCont *c,IObjParam *i,HWND hParent);
		~BaryMorphKeyInfo();
		void Init(HWND hWnd);
		void Invalidate();
		void InvalidateGraph();
		void Update();          

		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}
		Class_ID ClassID() {return Class_ID(BARYMORPH_DLG_CLASSID,0);}
		void MaybeCloseWindow();

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		 PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(BaryMorphCont*)rtarg;}

		void SelectPrevKey();
		void SelectNextKey();
		void ApplyTimeChange();
		void ApplyTensChange();
		void ApplyContChange();
		void ApplyBiasChange();
		void SetupPercentSpin();
		void SetPercent100();
		void ApplyPercentChange();

		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerStart(int id);
		void SpinnerChange(int id);
		void SpinnerEnd(int id,BOOL cancel);
	};

BaryMorphKeyInfo::BaryMorphKeyInfo(
		BaryMorphCont *c,IObjParam *i,HWND hParent)
	{	
	if (!tcbRegistered) {
		InitTCBGraph(hInstance);
		tcbRegistered = TRUE;
		}

	cont = NULL;
	ip = i;
	MakeRefByID(FOREVER,0,c);
	lastSel = -1;

	LoadResources();
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_BARYMORPH_KEYINFO),
		hParent,
		BaryMorphKeyInfoWndProc,
		(LPARAM)this);  
	RegisterMorphKeyWindow(hWnd,hParent,c);
	}

BaryMorphKeyInfo::~BaryMorphKeyInfo()
	{
	UnRegisterMorphKeyWindow(hWnd);
	ReleaseISpinner(iTime);
	ReleaseISpinner(iT);
	ReleaseISpinner(iC);
	ReleaseISpinner(iB);
	ReleaseISpinner(iPerc);
	ReleaseICustButton(iPrevKey);
	ReleaseICustButton(iNextKey);
	ReleaseICustStatus(iKeyNum);
	DeleteAllRefsFromMe();
	}

class CheckForNonBaryMorphDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonBaryMorphDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(BARYMORPH_DLG_CLASSID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void BaryMorphKeyInfo::MaybeCloseWindow()
	{
	CheckForNonBaryMorphDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}

RefResult BaryMorphKeyInfo::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,  
		RefMessage message)
	{
	switch (message) {
		case REFMSG_NODE_NAMECHANGE:
		case REFMSG_CHANGE:
			Invalidate();
			break;

		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}

void BaryMorphKeyInfo::SelectPrevKey()
	{
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			int j = ((i-1)+cont->keys.Count())%cont->keys.Count();
			cont->keys[i].ClearFlag(KEY_SELECTED);
			cont->keys[j].SetFlag(KEY_SELECTED);                    
			break;
			}
		}
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaryMorphKeyInfo::SelectNextKey()
	{
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			int j = (i+1)%cont->keys.Count();
			cont->keys[i].ClearFlag(KEY_SELECTED);
			cont->keys[j].SetFlag(KEY_SELECTED);                    
			break;
			}
		}
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaryMorphKeyInfo::ApplyTimeChange()
	{
	int t = iTime->GetIVal();
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].time = t;
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	UpdateWindow(GetParent(hWnd));
	}

void BaryMorphKeyInfo::ApplyTensChange()
	{
	float t = iT->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].tens = t;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaryMorphKeyInfo::ApplyContChange()
	{
	float c = iC->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].cont = c;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaryMorphKeyInfo::ApplyBiasChange()
	{
	float b = iB->GetFVal()/25.0f - 1.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].bias = b;
			cont->keys[i].Invalidate();
			}
		}
	cont->Invalidate();
	cont->keys.Invalidate();
	InvalidateGraph();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaryMorphKeyInfo::SetPercent100()
	{
	float total = 0.0f, selVal = 0.0f;
	int sel=-1;
	int listSel = SendMessage(hList,LB_GETCURSEL,0,0);

	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			sel = i;
			break;
			}
		}
	if (sel<0 || !cont->targs.Count()) return;
		
	for (i=0; i<cont->targs.Count(); i++) {
		if (i==listSel) {
			selVal = cont->keys[sel].GetWeight(i);
		} else {
			total += cont->keys[sel].GetWeight(i);
			}
		}

	if (total==0.0f) {				
		float ct = float(cont->targs.Count());
		if (listSel>=0) ct -= 1.0f;
		if (ct>=0) {
			ct = (1.0f-selVal)/ct;
			for (i=0; i<cont->targs.Count(); i++) {
				if (i!=listSel) {
					cont->keys[sel].SetWeight(i,ct);
					}
				}
			}
	} else {
		float f = (1.0f-selVal)/total;
		for (i=0; i<cont->targs.Count(); i++) {
			if (i!=listSel) {
				cont->keys[sel].SetWeight(i,
					cont->keys[sel].GetWeight(i)*f);
				}
			}
		}	
	}

void BaryMorphKeyInfo::ApplyPercentChange()
	{
	float pct = iPerc->GetFVal()/100.0f;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			cont->keys[i].SetWeight(lastSel,pct);
			}
		}
	if (constrain100) SetPercent100();
	cont->Invalidate();
	cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	UpdateWindow(hWnd);
	}

void BaryMorphKeyInfo::Init(HWND hWnd)
	{
	this->hWnd = hWnd;	

	iT = GetISpinner(GetDlgItem(hWnd,IDC_TCB_TSPIN));
	iT->SetLimits(0.0f,50.0f,FALSE);
	iT->SetScale(0.1f);
	iT->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_T),EDITTYPE_FLOAT);

	iC = GetISpinner(GetDlgItem(hWnd,IDC_TCB_CSPIN));
	iC->SetLimits(0.0f,50.0f,FALSE);
	iC->SetScale(0.1f);
	iC->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_C),EDITTYPE_FLOAT);

	iB = GetISpinner(GetDlgItem(hWnd,IDC_TCB_BSPIN));
	iB->SetLimits(0.0f,50.0f,FALSE);
	iB->SetScale(0.1f);
	iB->LinkToEdit(GetDlgItem(hWnd,IDC_TCB_B),EDITTYPE_FLOAT);

	iTime = GetISpinner(GetDlgItem(hWnd,IDC_KEYTIMESPIN));
	iTime->SetLimits(TIME_NegInfinity,TIME_PosInfinity,FALSE);
	iTime->SetScale(10.0f);
	iTime->LinkToEdit(GetDlgItem(hWnd,IDC_KEYTIME),EDITTYPE_TIME);

	iPerc = GetISpinner(GetDlgItem(hWnd,IDC_BARYMORPH_PERCENTSPIN));
	iPerc->SetLimits(-999999999.0f,999999999.0f,FALSE);
	iPerc->SetScale(0.5f);
	iPerc->LinkToEdit(GetDlgItem(hWnd,IDC_BARYMORPH_PERCENT),EDITTYPE_FLOAT);

	iPrevKey = GetICustButton(GetDlgItem(hWnd,IDC_PREVKEY));
	iNextKey = GetICustButton(GetDlgItem(hWnd,IDC_NEXTKEY));
	iPrevKey->SetImage(hKeyInfoImages,3,3,8,8,16,15);
	iNextKey->SetImage(hKeyInfoImages,4,4,9,9,16,15);
	iKeyNum  = GetICustStatus(GetDlgItem(hWnd,IDC_KEYNUM));

	hList = GetDlgItem(hWnd,IDC_BARYMORPH_TARGLIST);

	Update();
	}

void BaryMorphKeyInfo::Invalidate()
	{
	valid = FALSE;	
	InvalidateRect(hWnd,NULL,FALSE);
	InvalidateGraph();
	}

void BaryMorphKeyInfo::InvalidateGraph()
	{
	HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
	InvalidateRect(hGraph,NULL,FALSE);
	}

void BaryMorphKeyInfo::Update()
	{
	valid = TRUE;

	TimeValue time;
	float T, C, B;
	BOOL timeInit=FALSE,timeValid=FALSE;
	BOOL tValid, tInit, bValid, bInit, cValid, cInit;
	int numSel = 0, sel = -1;
	tValid = tInit = bValid = bInit = cValid = cInit = FALSE;

	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			sel = i;
			numSel++;

			if (timeInit) {
				if (time != cont->keys[i].time) {
					timeValid = FALSE;
					}
			} else {
				timeInit  = TRUE;
				timeValid = TRUE;
				time      = cont->keys[i].time;
				}

			if (tInit) {
				if (T != cont->keys[i].tens) {
					tValid = FALSE;
					}
			} else {
				tInit  = TRUE;
				tValid = TRUE;
				T      = cont->keys[i].tens;
				}
			
			if (cInit) {
				if (C != cont->keys[i].cont) {
					cValid = FALSE;
					}
			} else {
				cInit  = TRUE;
				cValid = TRUE;
				C      = cont->keys[i].cont;
				}

			if (bInit) {
				if (B != cont->keys[i].bias) {
					bValid = FALSE;
					}
			} else {
				bInit  = TRUE;
				bValid = TRUE;
				B      = cont->keys[i].bias;
				}
			}
		}
	
	if (timeValid) {
		iTime->SetValue(time,FALSE);
		iTime->Enable();
		iTime->SetIndeterminate(FALSE);
	} else {
		iTime->SetIndeterminate();
		iTime->Disable();
		}

	if (tValid) {
		iT->SetValue((T+1.0f)*25.0f,FALSE);             
		iT->SetIndeterminate(FALSE);
	} else {
		iT->SetIndeterminate();         
		}
	if (cValid) {
		iC->SetValue((C+1.0f)*25.0f,FALSE);             
		iC->SetIndeterminate(FALSE);
	} else {
		iC->SetIndeterminate();         
		}
	if (bValid) {
		iB->SetValue((B+1.0f)*25.0f,FALSE);             
		iB->SetIndeterminate(FALSE);
	} else {
		iB->SetIndeterminate();         
		}

	if (tValid && cValid && bValid) {
		TCBGraphParams gp;
		gp.tens     = T;
		gp.cont     = C;
		gp.bias     = B;
		gp.easeFrom = 0.0f;
		gp.easeTo   = 0.0f;
		HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
		EnableWindow(hGraph,TRUE);
		SendMessage(hGraph,WM_SETTCBGRAPHPARAMS,0,(LPARAM)&gp);
		UpdateWindow(hGraph);
	} else {
		HWND hGraph = GetDlgItem(hWnd,IDC_TCB_GRAPH);
		EnableWindow(hGraph,FALSE);
		}

	if (numSel==1) {
		TSTR buf;
		buf.printf(_T("%d"),sel+1);
		iKeyNum->SetText(buf);
		iPrevKey->Enable();
		iNextKey->Enable();
		
		SendMessage(hList,LB_RESETCONTENT,0,0);
		EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_TARGETLEBEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_PERCENTLABEL),TRUE);
		
		if (cont->targs.Count())
			 EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_100TOTAL),TRUE);
		else EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_100TOTAL),FALSE);

		float total = 0.0f;
		for (int i=0; i<cont->targs.Count(); i++) {
			float pct = cont->keys[sel].GetWeight(i)*100.0f;
			total += pct;
			TSTR name;
			name.printf(_T("%.1f%%\t%s"),pct,*cont->targs[i].name);
			SendMessage(hList,LB_ADDSTRING,0,(LONG)(TCHAR*)name);
			}

		TSTR tot;
		tot.printf(_T("%.1f%%"),total);
		SetDlgItemText(hWnd,IDC_BARYMORPH_TOTAL,tot);

		SetupPercentSpin();
	} else {
		iKeyNum->SetText(_T(""));
		iPrevKey->Disable();
		iNextKey->Disable();
		
		SendMessage(hList,LB_RESETCONTENT,0,0);
		EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_TARGETLEBEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_PERCENTLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_BARYMORPH_100TOTAL),FALSE);
		SetDlgItemText(hWnd,IDC_BARYMORPH_TOTAL,_T(""));
		iPerc->SetValue(0.0f,FALSE);
		iPerc->Disable();
		}

	CheckDlgButton(hWnd,IDC_BARYMORPH_100TOTAL,constrain100);
	}

void BaryMorphKeyInfo::SetupPercentSpin()
	{
	int sel=-1;
	for (int i=0; i<cont->keys.Count(); i++) {
		if (cont->keys[i].TestFlag(KEY_SELECTED)) {
			if (sel>=0) {
				sel = -1;
				break;
				}
			sel = i;			
			}
		}

	if (lastSel>=0 && sel>=0) {
		float pct = cont->keys[sel].GetWeight(lastSel)*100.0f;
		iPerc->SetValue(pct,FALSE);
		iPerc->Enable();
		SendMessage(hList,LB_SETCURSEL,lastSel,0);
	} else {
		iPerc->SetValue(0.0f,FALSE);
		iPerc->Disable();
		}
	}

void BaryMorphKeyInfo::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_BARYMORPH_TARGLIST:
			if (notify==LBN_SELCHANGE) {
				lastSel = SendMessage(hList,LB_GETCURSEL,0,0);
				SetupPercentSpin();
				}
			break;

		case IDC_BARYMORPH_100TOTAL:
			constrain100 = IsDlgButtonChecked(hWnd,IDC_BARYMORPH_100TOTAL);
			if (constrain100) {
				theHold.Begin();
				cont->HoldTrack();
				SetPercent100();
				theHold.Accept(GetString(IDS_RB_EDITKEYINFO));
				cont->Invalidate();
				cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				ip->RedrawViews(ip->GetTime());
				}
			break;

		case IDC_PREVKEY:
			SelectPrevKey();
			break;
		case IDC_NEXTKEY:
			SelectNextKey();
			break;
		
		case IDCANCEL:                  
		case IDOK:
			DestroyWindow(hWnd);
			break;
		}
	}

void BaryMorphKeyInfo::SpinnerStart(int id)
	{
	theHold.Begin();
	cont->HoldTrack();
	}

void BaryMorphKeyInfo::SpinnerChange(int id)
	{
	switch (id) {
		case IDC_KEYTIMESPIN:
			ApplyTimeChange(); break;

		case IDC_TCB_TSPIN:
			ApplyTensChange(); break;
		case IDC_TCB_CSPIN:
			ApplyContChange(); break;
		case IDC_TCB_BSPIN:
			ApplyBiasChange(); break;

		case IDC_BARYMORPH_PERCENTSPIN:
			ApplyPercentChange(); break;
		}
	ip->RedrawViews(ip->GetTime());
	UpdateWindow(hWnd);
	}

void BaryMorphKeyInfo::SpinnerEnd(int id,BOOL cancel)
	{
	if (cancel) {
		theHold.Cancel();
	} else {
		if (id==IDC_KEYTIMESPIN) {
			// RB 4/21/99: Do this on mouse up.
			cont->keys.CheckForDups();
			}
		theHold.Accept(GetString(IDS_RB_EDITKEYINFO));
		}
	ip->RedrawViews(ip->GetTime());
	}



static BOOL CALLBACK BaryMorphKeyInfoWndProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	BaryMorphKeyInfo *k = (BaryMorphKeyInfo*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			k = (BaryMorphKeyInfo*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			k->Init(hWnd);
			return FALSE;   // DB 2/27

		case WM_PAINT:
			if (!k->valid) {
				k->Update();
				}
			return 0;
		
		case CC_SPINNER_BUTTONDOWN:
			k->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			k->SpinnerChange(LOWORD(wParam));
			break;

		case CC_SPINNER_BUTTONUP:
			k->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			k->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);                                               
			break;
		
		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			delete k;
			break;

		default:
			return 0;
		}
	return 1;
	}


void BaryMorphCont::EditTrackParams(
		TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,
		IObjParam *ip,DWORD flags)
	{
	HWND hCur = FindOpenMorphKeyWindow(hParent,this);
	if (hCur) {
		SetForegroundWindow(hCur);
		return;
		}
	new BaryMorphKeyInfo(this,ip,hParent);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\prim.h ===
/**********************************************************************
 *<
	FILE: prim.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __PRIM__H
#define __PRIM__H

#include "Max.h"
#include "resource.h"

#ifdef DESIGN_VER //for conversion to amodeler solids
#include "igeomimp.h"
#include "plugapi.h"
#endif

TCHAR *GetString(int id);

extern ClassDesc* GetBoxobjDesc();
extern ClassDesc* GetSphereDesc();
extern ClassDesc* GetCylinderDesc();
extern ClassDesc* GetSimpleCamDesc();
extern ClassDesc* GetOmniLightDesc();
extern ClassDesc* GetDirLightDesc();
extern ClassDesc *GetTDirLightDesc();
extern ClassDesc* GetFSpotLightDesc();
extern ClassDesc* GetTSpotLightDesc();
extern ClassDesc* GetLookatCamDesc();
extern ClassDesc* GetSplineDesc();
#ifdef DESIGN_VER
extern ClassDesc* GetOrthoSplineDesc();
#endif
extern ClassDesc* GetNGonDesc();
extern ClassDesc* GetDonutDesc();
extern ClassDesc* GetTargetObjDesc();
extern ClassDesc* GetBonesDesc();
extern ClassDesc* GetRingMasterDesc();
extern ClassDesc* GetSlaveControlDesc();
extern ClassDesc* GetQuadPatchDesc();
extern ClassDesc* GetTriPatchDesc();
extern ClassDesc* GetTorusDesc();
extern ClassDesc* GetMorphObjDesc();
extern ClassDesc* GetCubicMorphContDesc();
extern ClassDesc* GetRectangleDesc();
extern ClassDesc* GetBoolObjDesc();
extern ClassDesc* GetTapeHelpDesc();
extern ClassDesc* GetProtHelpDesc();
extern ClassDesc* GetTubeDesc();
extern ClassDesc* GetConeDesc();
extern ClassDesc* GetHedraDesc();
extern ClassDesc* GetCircleDesc();
extern ClassDesc* GetEllipseDesc();
extern ClassDesc* GetArcDesc();
extern ClassDesc* GetStarDesc();
extern ClassDesc* GetHelixDesc();
extern ClassDesc* GetRainDesc();
extern ClassDesc* GetSnowDesc();
extern ClassDesc* GetTextDesc();
extern ClassDesc* GetTeapotDesc();
extern ClassDesc* GetBaryMorphContDesc();
#ifdef DESIGN_VER
extern ClassDesc* GetOrthoSplineDesc();
extern ClassDesc* GetParallelCamDesc();
#endif
extern ClassDesc* GetGridobjDesc();

extern HINSTANCE hInstance;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\ngon.cpp ===
/**********************************************************************
 *<
	FILE: ngon.cpp

	DESCRIPTION:  An N-sided spline object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995
			 Fillets added 1/12/97 - Audrey Peterson

 *>	Copyright (c) 1995,1996,1997 All Rights Reserved.
 **********************************************************************/

#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"

#define MIN_SIDES		3
#define MAX_SIDES		100

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)

#define MIN_CIRCULAR	0
#define MAX_CIRCULAR	1

#define DEF_SIDES		6//24

#define DEF_RADIUS		float(0.0)

#define CIRCUMSCRIBED	0
#define INSCRIBED		1
#define DEF_SCRIBE		INSCRIBED

#define CIRCULAR_ON		1
#define CIRCULAR_OFF	0

#define DEF_CIRCULAR CIRCULAR_OFF
const float HalfPI=1.570796327f;
#define CIRCLE_VECTOR_LENGTH 0.5517861843f


class NGonObjCreateCallBack;

class NGonObject: public SimpleSpline, public IParamArray {			   
		friend class NGonObjCreateCallBack;

	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgSides;
		static int dlgCreateMeth;
		static int dlgCircular;
		static int dlgScribe;
		static Point3 crtPos;		
		static float crtRadius;
		static int crtScribe;
		static float crtFillet;
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		NGonObject();
		~NGonObject();

		//  inherited virtual methods:

	    IOResult NGonObject::Load(ILoad *iload);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_NGON); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_NGON); }		
		Class_ID ClassID() { return Class_ID(NGON_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_NGON_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class NGonObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new NGonObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_NGON_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(NGON_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static NGonObjClassDesc ngonObjDesc;

ClassDesc* GetNGonDesc() { return &ngonObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for ngon class.
IParamMap *NGonObject::pmapCreate = NULL;
IParamMap *NGonObject::pmapParam  = NULL;
IParamMap *NGonObject::pmapTypeIn = NULL;
IObjParam *NGonObject::ip         = NULL;
int NGonObject::dlgSides          = DEF_SIDES;
int NGonObject::dlgCreateMeth     = 1; // create_radius
int NGonObject::dlgCircular       = DEF_CIRCULAR;
int NGonObject::dlgScribe         = DEF_SCRIBE;
Point3 NGonObject::crtPos         = Point3(0,0,0);
float NGonObject::crtRadius       = 0.0f;
float NGonObject::crtFillet       = 0.0f;

void NGonObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	NGonObject::dlgSides          = DEF_SIDES;
	NGonObject::dlgCreateMeth     = 1; // create_radius
	NGonObject::dlgCircular       = DEF_CIRCULAR;
	NGonObject::dlgScribe         = DEF_SCRIBE;
	NGonObject::crtPos            = Point3(0,0,0);
	NGonObject::crtRadius         = 0.0f;
	NGonObject::crtFillet         = 0.0f;
	}

// Parameter map indices
#define PB_RADIUS		0
#define PB_SIDES		1
#define PB_CIRCULAR		2
#define PB_FILLET		3
#define PB_SCRIBE		4

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_FILLET		3

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
		
	// Fillet
	ParamUIDesc(
		PB_TI_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_FILLET,IDC_FILLETSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)
	};

#define TYPEINDESC_LENGTH 3

//
//
// Parameters

static int scribeIDs[] = {IDC_CIRCUMSCRIBED,IDC_INSCRIBED};

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	ParamUIDesc(PB_SCRIBE,TYPE_RADIO,scribeIDs,2),

	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_SIDES,(float)MAX_SIDES,
		(float)1),
	
	// Circular
	ParamUIDesc(PB_CIRCULAR,TYPE_SINGLECHEKBOX,IDC_OBCIRCULAR),

	// Fillet
	ParamUIDesc(
		PB_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_FILLET,IDC_FILLETSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)
	};

#define PARAMDESC_LENGTH 5


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
 };
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
 };
static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
 };
#define PBLOCK_LENGTH	5

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),			
	ParamVersionDesc(descVer1,4,1),			
	};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);

class NGonPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		NGonPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((NGonObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer==0) {				
				((NGonObject*)targ)->pblock->SetValue(PB_FILLET,0,0.0f);
				((NGonObject*)targ)->pblock->SetValue(PB_SCRIBE,0,INSCRIBED);
				}
			delete this;
			}
	};
IOResult NGonObject::Load(ILoad *iload)
	{  	iload->RegisterPostLoadCallback(
			new NGonPostLoadCallback(
				new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	return SimpleSpline::Load(iload);
	}

//--- TypeInDlgProc --------------------------------

class NGonTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		NGonObject *no;

		NGonTypeInDlgProc(NGonObject *n) {no=n;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL NGonTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (no->crtRadius==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (no->TestAFlag(A_OBJ_CREATING)) {
						no->pblock->SetValue(PB_RADIUS,0,no->crtRadius);
						no->pblock->SetValue(PB_FILLET,0,no->crtFillet);
						}

					Matrix3 tm(1);
					tm.SetTrans(no->crtPos);
					no->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


/* Find the vector length for a circle segment	*/
/* Returns a unit value (radius=1.0)		*/
/* Angle expressed in radians			*/

static float
veccalc(float angstep) {
	static float lastin = -9999.0f,lastout;
	if(lastin == angstep)
		return lastout;

	float lo,hi,totdist;
	float sinfac=(float)sin(angstep),cosfac=(float)cos(angstep),test;
	int ix,count;
	Spline3D work;
	Point3 k1((float)cos(0.0f),(float)sin(0.0f),0.0f);
	Point3 k2(cosfac,sinfac,0.0f);

	hi=1.5f;
	lo=0.0f;
	count=200;

	/* Loop thru test vectors */

	loop:
	work.NewSpline();
	test=(hi+lo)/2.0f;
	Point3 out = k1 + Point3(0.0f, test, 0.0f);
	Point3 in = k2 + Point3(sinfac * test, -cosfac * test, 0.0f);

 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k1,k1,out));
 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k2,in,k2));

	totdist=0.0f;
	for(ix=0; ix<10; ++ix) {
		Point3 terp = work.InterpBezier3D(0,(float)ix/10.0f);
		totdist += (float)sqrt(terp.x * terp.x + terp.y * terp.y);
		}
	
	totdist /= 10.0f;
	count--;
	if(totdist==1.0f || count<=0)
		goto done;
	if(totdist>1.0f) {
		hi=test;
		goto loop;
		}
	lo=test;
	goto loop;

	done:
	lastin = angstep;
	lastout = test;
	return test;
	}


void NGonObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last ngon ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_NGONPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_NGONPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_NGONPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new NGonTypeInDlgProc(this));
		}
	}
		
void NGonObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
	pblock->GetValue(PB_CIRCULAR,ip->GetTime(),dlgCircular,FOREVER);	
	pblock->GetValue(PB_SCRIBE,ip->GetTime(),dlgScribe,FOREVER);	
	}

void NGonObject::BuildShape(TimeValue t, BezierShape& ashape) {

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float radius,fillet;
	int sides,circular,scribe;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_SIDES, t, sides, ivalid);
	pblock->GetValue(PB_CIRCULAR, t, circular, ivalid);
	pblock->GetValue(PB_FILLET, t, fillet, ivalid);
	pblock->GetValue(PB_SCRIBE, t, scribe, ivalid);

	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	LimitValue( sides, MIN_SIDES, MAX_SIDES );
	LimitValue( circular, MIN_CIRCULAR, MAX_CIRCULAR );
	LimitValue( fillet, MIN_RADIUS, MAX_RADIUS );
	LimitValue( scribe, CIRCUMSCRIBED, INSCRIBED );
	float vector;

	// If circumscribed, modify the radius
	if(scribe == CIRCUMSCRIBED)
		radius = radius / (float)cos(TWOPI / ((float)sides * 2.0f));

	// Delete the existing shape and create a new spline in it
	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	Spline3D *spline = ashape.NewSpline();

	// Determine the vector length if circular
	if(circular)
		vector = veccalc(6.2831853f / (float)sides) * radius;
	else
		vector = 0.0f;

	// Now add all the necessary points
	if ((fillet==0)||(circular))
	{ for(int ix=0; ix<sides; ++ix) 
	  {	float angle = 6.2831853f * (float)ix / (float)sides;
		float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
		Point3 p(cosfac * radius, sinfac * radius, 0.0f);
		Point3 rotvec = Point3(sinfac * vector, -cosfac * vector, 0.0f);
		spline->AddKnot(SplineKnot(circular ? KTYPE_BEZIER : KTYPE_CORNER,LTYPE_CURVE,p,p + rotvec,p - rotvec));
	  }
	  spline->SetClosed();
	  spline->ComputeBezPoints();
	// If it's a linear shape, turn the knots back into beziers -- We used the spline package to compute vectors
	  if(!circular) 
	  {	for(int i = 0; i < sides; ++i)
			spline->SetKnotType(i, KTYPE_BEZIER_CORNER);
	  }
	}
	else
	{ for(int ix=0; ix<sides; ++ix) 
	  {	float angle = 6.2831853f * (float)ix / (float)sides;
	    float theta2= (PI*(sides-2)/sides)/2.0f,fang=angle+theta2,fang2=angle-theta2;
		float f=fillet*(float)tan(HalfPI-theta2);
		float sinfac = (float)sin(angle), cosfac = (float)cos(angle);
		Point3 p(cosfac * radius, sinfac * radius, 0.0f),p1,p2;
		Point3 fvec1=Point3((float)-cos(fang),(float)-sin(fang),0.0f)*f;
		Point3 fvec2=Point3((float)-cos(fang2),(float)-sin(fang2),0.0f)*f;
		p1=p+fvec1;p2=p+fvec2;
		Point3 p1vec=fvec1*CIRCLE_VECTOR_LENGTH,p2vec=fvec2*CIRCLE_VECTOR_LENGTH;
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p1,p1 + p1vec,p1 - p1vec));
		spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p2,p2 - p2vec,p2 + p2vec));
	  }
	  spline->SetClosed();
	  spline->ComputeBezPoints();
	}
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

NGonObject::NGonObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_FILLET,0,crtFillet);
	pblock->SetValue(PB_SIDES,0,dlgSides);	
	pblock->SetValue(PB_CIRCULAR,0,dlgCircular);
	pblock->SetValue(PB_SCRIBE,0,dlgScribe);
 	}

NGonObject::~NGonObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class NGonObjCreateCallBack: public CreateMouseCallBack {
	NGonObject *ob;
	Point3 p[2];
	IPoint2 sp0,sp1;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(NGonObject *obj) { ob = obj; }
	};

int NGonObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif


	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				sp0 = m;
				createType = ob->dlgCreateMeth;
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1: 
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if ( createType ) {	// radius	
					r = Length(p[1]-p[0]);
					}
				else {// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{ ob->suspendSnap = FALSE;
				  if (Length(m-sp0)<3 || Length(p[1]-p[0])<0.1f)
				   return CREATE_ABORT;
				  else	return CREATE_STOP;
				}
				break;
/*			case 2:
				{ float f = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
				  ob->pblock->SetValue(PB_FILLET,0,f);
				  ob->pmapParam->Invalidate();
				  if (msg==MOUSE_POINT) 
				  {	ob->suspendSnap = FALSE;
					return CREATE_STOP;
				  }
				}
				break;*/
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static NGonObjCreateCallBack ngonCreateCB;

CreateMouseCallBack* NGonObject::GetCreateMouseCallBack() {
	ngonCreateCB.SetObj(this);
	return(&ngonCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle NGonObject::Clone(RemapDir& remap) {
	NGonObject* newob = new NGonObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL NGonObject::ValidForDisplay(TimeValue t) {
	float radius;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	return (radius == 0.0f) ? FALSE : TRUE;
	}

ParamDimension *NGonObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		case PB_FILLET:
			return stdWorldDim;			
		case PB_SIDES:
			return stdSegmentsDim;			
		case PB_CIRCULAR:
		case PB_SCRIBE:
			return stdNormalizedDim;			
		default:
			return defaultDim;
		}
	}

TSTR NGonObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return TSTR(GetString(IDS_TH_RADIUS));			
		case PB_FILLET:
			return TSTR(GetString(IDS_AP_FILLET));			
		case PB_SIDES:
			return TSTR(GetString(IDS_TH_SIDES));			
		case PB_CIRCULAR:
			return TSTR(GetString(IDS_TH_CIRCULAR));			
		case PB_SCRIBE:
			return TSTR(GetString(IDS_TH_SCRIBE));			
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL NGonObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL NGonObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_FILLET: crtFillet = v; break;
		}	
	return TRUE;
	}

BOOL NGonObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL NGonObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL NGonObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_FILLET: v = crtFillet; break;
		}
	return TRUE;
	}

BOOL NGonObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\prothelp.h ===
/**********************************************************************
 *<
	FILE: prothelp.h

	DESCRIPTION:  Defines an Angle-Measuring Helper Class

	CREATED BY: Don Brittain

	HISTORY: created 12 June 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __PROTHELP__H__ 

#define __PROTHELP__H__

class ProtHelpObject: public HelperObject 
{
	friend class ProtHelpObjCreateCallBack;
	friend BOOL CALLBACK ProtHelpParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend void resetProtParams();
public:

	// Class vars
	static Mesh mesh;
	static short meshBuilt;
	static HWND hProtHelpParams;
	static IObjParam *iObjParams;
	BOOL created;

	// Snap suspension flag (TRUE during creation only)
	BOOL suspendSnap;

	// Object parameters		
	short editting;
	double lastAngle;
	INode *refNode[2];

	Interval ivalid;

	//  inherited virtual methods for Reference-management
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message );
	void BuildMesh();
	void UpdateUI(TimeValue t);
	void GetMat(TimeValue t, INode* inod, ViewExp *vpt, Matrix3& mat);
	BOOL GetTargetPoint(int which, TimeValue t, Point3* q);
	int DrawLines(TimeValue t, INode *inode, GraphicsWindow *gw, int drawing );

	ProtHelpObject();
	~ProtHelpObject();

	//  inherited virtual methods:

	// From BaseObject
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack();
	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	TCHAR *GetObjectName() { return GetString(IDS_DB_PROTRACTOR); }

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s) { s = GetString(IDS_DB_PROTRACTOR); }
	Interval ObjectValidity(TimeValue time);
	void Invalidate();
	int DoOwnSelectHilite() { return 1; }

	// From GeomObject
	int IntersectRay(TimeValue t, Ray& r, float& at);
	void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

	// Animatable methods
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return Class_ID(PROTHELP_CLASS_ID,0); }  
	void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_PROTHELPER_CLASS)); }

	TSTR SubAnimName(int i) { return TSTR(GetString(IDS_RB_PARAMETERS));}

	// From ref
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	int NumRefs();
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
};				


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\prothelp.cpp ===
/**********************************************************************
 *<
	FILE: prothelp.cpp

	DESCRIPTION:  Angle measuring helper implementation

	CREATED BY: Don Brittain

	HISTORY: created 12 June 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "prothelp.h"

//------------------------------------------------------

static BOOL creating = FALSE;

class ProtHelpClassDesc : public ClassDesc 
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ProtHelpObject; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_PROT_CLASS); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID 		ClassID() { return Class_ID(PROTHELP_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	int 			BeginCreate(Interface *i)	{ 
						creating = TRUE;
						return ClassDesc::BeginCreate(i); }
	int 			EndCreate(Interface *i)	{ 
						creating = FALSE; 
						return ClassDesc::EndCreate(i); }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetProtParams(); }
};

static ProtHelpClassDesc ProtHelpDesc;

ClassDesc* GetProtHelpDesc() { return &ProtHelpDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for measuring tape class.
Mesh ProtHelpObject::mesh;
short ProtHelpObject::meshBuilt=0;
HWND ProtHelpObject::hProtHelpParams = NULL;
IObjParam *ProtHelpObject::iObjParams;

void resetProtParams() 
{
}

// Handles the work of actually picking the target.
class PickProtTarget : public PickModeCallback, PickNodeCallback 
{
public:
	int which;		// 0 or 1
	ProtHelpObject *ph;
	int doingPick;
	CommandMode *cm;
	HWND hDlg;
	PickProtTarget () {}

	BOOL HitTest (IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m, int flags);
	BOOL Pick (IObjParam *ip, ViewExp *vpt);
	void EnterMode(IObjParam *ip);
	void ExitMode(IObjParam *ip);

	// Allow right-clicking out of mode.
	BOOL RightClick (IObjParam *ip,ViewExp *vpt) { return TRUE; }
	
	// Is supposed to return a PickNodeCallback-derived class: we qualify!
	PickNodeCallback *GetFilter() {return this;}
	
	// PickNodeCallback methods:
	BOOL Filter(INode *node);
};

BOOL PickProtTarget::Filter(INode *node) 
{
	return node==NULL ? FALSE : TRUE;
}

BOOL PickProtTarget::HitTest (IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m, int flags) 
{	
	INode *node = ip->PickNode(hWnd, m, this);
	return Filter (node);
}

BOOL PickProtTarget::Pick (IObjParam *ip, ViewExp *vpt) 
{
	INode *node = vpt->GetClosestHit();
	assert(node);
	int res = TRUE;

	if(node->MakeReference(FOREVER,ph) != REF_SUCCEED)
		ph->refNode[which] = NULL;
	else
		ph->refNode[which] = node;
	ph->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	ph->Invalidate();
	SetDlgItemText(hDlg, which ? IDC_PROT_TARGET2_NAME : IDC_PROT_TARGET1_NAME, 
			ph->refNode[which] ? node->GetName() : _T(""));

	if(creating) {
		ph->BeginEditParams(ip, BEGIN_EDIT_CREATE, NULL);
		ip->SetCommandMode(cm);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	}
	return TRUE;
}

void PickProtTarget::EnterMode(IObjParam *ip) 
{
	ICustButton *iBut = GetICustButton(GetDlgItem(hDlg, which ? 
					IDC_PROT_PICK_TARGET2 : IDC_PROT_PICK_TARGET1));
	if (iBut) {
		iBut->SetCheck(TRUE);
		ReleaseICustButton(iBut);
	}
	doingPick = 1;
}

void PickProtTarget::ExitMode(IObjParam *ip) 
{
	ICustButton *iBut = GetICustButton(GetDlgItem(hDlg, which ? 
					IDC_PROT_PICK_TARGET2 : IDC_PROT_PICK_TARGET1));
	if (iBut) {
		iBut->SetCheck(FALSE);
		ReleaseICustButton(iBut);
	}
	doingPick = 0;
}

static PickProtTarget pickCB;

BOOL CALLBACK ProtHelpParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	ICustButton *iBut;
	ProtHelpObject *ph = (ProtHelpObject *)GetWindowLong( hDlg, GWL_USERDATA );	
	if ( !ph && message != WM_INITDIALOG ) return FALSE;

	switch ( message ) {
		case WM_INITDIALOG:
			ph = (ProtHelpObject *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)ph );
			SetDlgFont( hDlg, ph->iObjParams->GetAppHFont() );
			if( iBut = GetICustButton(GetDlgItem(hDlg, IDC_PROT_PICK_TARGET1))) {
				iBut->SetType (CBT_CHECK);
				iBut->SetHighlightColor (GREEN_WASH);
				ReleaseICustButton(iBut);
			}
			if( iBut = GetICustButton(GetDlgItem(hDlg, IDC_PROT_PICK_TARGET2))) {
				iBut->SetType (CBT_CHECK);
				iBut->SetHighlightColor (GREEN_WASH);
				ReleaseICustButton(iBut);
			}
			return FALSE;			

		case WM_DESTROY:
			return FALSE;

		case WM_MOUSEACTIVATE:
			ph->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			ph->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:			
			switch( LOWORD(wParam) ) {
			case IDC_PROT_PICK_TARGET1:
			case IDC_PROT_PICK_TARGET2:
				if(ph->created == FALSE) {
					if(iBut = GetICustButton(GetDlgItem(hDlg, IDC_PROT_PICK_TARGET1))) {
						iBut->SetCheck(FALSE);
						ReleaseICustButton(iBut);
					}
					if(iBut = GetICustButton(GetDlgItem(hDlg, IDC_PROT_PICK_TARGET2))) {
						iBut->SetCheck(FALSE);
						ReleaseICustButton(iBut);
					}
					break;
				}
				pickCB.ph = ph;
				pickCB.hDlg = hDlg;
				if(pickCB.doingPick) 
					ph->iObjParams->SetCommandMode(pickCB.cm);
				else
					pickCB.cm = ph->iObjParams->GetCommandMode();
				pickCB.which = ((LOWORD(wParam) - IDC_PROT_PICK_TARGET1) > 0);
				ph->iObjParams->SetPickMode (&pickCB);
				ph->UpdateUI(ph->iObjParams->GetTime());
				ph->iObjParams->RedrawViews (ph->iObjParams->GetTime());
				break;
			}
			return FALSE;

		default:
			return FALSE;
	}
}



void ProtHelpObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	iObjParams = ip;
	editting = TRUE;
	
	if ( !hProtHelpParams ) {
		hProtHelpParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_PROTHELPER),
				ProtHelpParamDialogProc, 
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this );	
		ip->RegisterDlgWnd(hProtHelpParams);
	} 
	else {
		SetWindowLong( hProtHelpParams, GWL_USERDATA, (LONG)this );
	}
	UpdateUI(ip->GetTime());
}
		
void ProtHelpObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
	editting = FALSE;

	if ( flags&END_EDIT_REMOVEUI ) {		
		ip->UnRegisterDlgWnd(hProtHelpParams);
		ip->DeleteRollupPage(hProtHelpParams);
		hProtHelpParams = NULL;				
	} 
	else {
		SetWindowLong( hProtHelpParams, GWL_USERDATA, 0 );
	}
	iObjParams = NULL;
}


void ProtHelpObject::BuildMesh()
{
	if(meshBuilt)
		return;
	int nverts = 7;
	int nfaces = 8;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	float d = 5.0f;
	float ds = 0.866f * d;
	float h = 2.0f * 0.866f * 5.0f;

	mesh.setVert(0, Point3(0.0f, 0.0f, 0.0f ));
	mesh.setVert(1, Point3(  -d,  -ds, -h ));
	mesh.setVert(2, Point3(   d,  -ds, -h ));
	mesh.setVert(3, Point3(0.0f,   ds, -h ));
	mesh.setVert(4, Point3(  -d,  -ds,  h ));
	mesh.setVert(5, Point3(   d,  -ds,  h ));
	mesh.setVert(6, Point3(0.0f,   ds,  h ));
	mesh.faces[0].setVerts(0, 1, 2);
	mesh.faces[0].setEdgeVisFlags(1,1,1);
	mesh.faces[1].setVerts(0, 2, 3);
	mesh.faces[1].setEdgeVisFlags(1,1,1);
	mesh.faces[2].setVerts(0, 3, 1);
	mesh.faces[2].setEdgeVisFlags(1,1,1);
	mesh.faces[3].setVerts(3, 2, 1);
	mesh.faces[3].setEdgeVisFlags(1,1,1);
	mesh.faces[4].setVerts(0, 5, 4);
	mesh.faces[4].setEdgeVisFlags(1,1,1);
	mesh.faces[5].setVerts(0, 6, 5);
	mesh.faces[5].setEdgeVisFlags(1,1,1);
	mesh.faces[6].setVerts(0, 4, 6);
	mesh.faces[6].setEdgeVisFlags(1,1,1);
	mesh.faces[7].setVerts(4, 5, 6);
	mesh.faces[7].setEdgeVisFlags(1,1,1);
#if 1
	// whoops- rotate 90 about x to get it facing the right way
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.RotateX(DegToRad(90.0));
	for (int i=0; i<nverts; i++)
		mesh.getVert(i) = mat*mesh.getVert(i);
#endif
//	mesh.buildNormals();
	meshBuilt = 1;
}

void ProtHelpObject::UpdateUI(TimeValue t)
{
	if ( hProtHelpParams &&	GetWindowLong(hProtHelpParams,GWL_USERDATA)==(LONG)this ) {
		TCHAR buf[256];

		if(refNode[0]) {
			GetDlgItemText(hProtHelpParams, IDC_PROT_TARGET1_NAME, buf, sizeof(buf));
			if(_tcscmp(buf, refNode[0]->GetName()))
				SetDlgItemText(hProtHelpParams, IDC_PROT_TARGET1_NAME, refNode[0]->GetName());
		}
		else
			SetDlgItemText(hProtHelpParams, IDC_PROT_TARGET1_NAME, _T(""));

		if(refNode[1]) {
			GetDlgItemText(hProtHelpParams, IDC_PROT_TARGET2_NAME, buf, sizeof(buf));
			if(_tcscmp(buf, refNode[1]->GetName()))
				SetDlgItemText(hProtHelpParams, IDC_PROT_TARGET2_NAME, refNode[1]->GetName());
		}
		else
			SetDlgItemText(hProtHelpParams, IDC_PROT_TARGET2_NAME, _T(""));

		if(refNode[0] && refNode[1])
			_stprintf(buf, _T("%g"), lastAngle);
		else
			buf[0] = _T('\0');
		SetDlgItemText(hProtHelpParams, IDC_PROT_ANGLE, buf);
	}
}


ProtHelpObject::ProtHelpObject() : HelperObject() 
{
	editting = 0;
	created = 0;
	refNode[0] = refNode[1] = NULL;
	suspendSnap = FALSE;
	ivalid.SetEmpty();
	BuildMesh();
}

ProtHelpObject::~ProtHelpObject()
{
	DeleteAllRefsFromMe();
}


int ProtHelpObject::NumRefs()
{
	return 2;
}

RefTargetHandle ProtHelpObject::GetReference(int i)
{
	return refNode[i];
}

void ProtHelpObject::SetReference(int i, RefTargetHandle rtarg)
{
	refNode[i] = (INode *)rtarg;
}

class ProtHelpObjCreateCallBack: public CreateMouseCallBack 
{
	ProtHelpObject *ph;
public:
	int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
	void SetObj(ProtHelpObject *obj) { ph = obj; }
};

int ProtHelpObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:
			ph->suspendSnap = TRUE;
			mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
			break;
		case 1:
			mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
			if (msg==MOUSE_POINT) {
				ph->suspendSnap = FALSE;
				return 0;
			}
			break;			
		}
	} else if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
	}
	return 1;
}

static ProtHelpObjCreateCallBack protHelpCreateCB;

CreateMouseCallBack* ProtHelpObject::GetCreateMouseCallBack() 
{
	protHelpCreateCB.SetObj(this);
	return &protHelpCreateCB;
}

void ProtHelpObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm) 
{
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
}

BOOL ProtHelpObject::GetTargetPoint(int which, TimeValue t, Point3 *pt)
{
	if(refNode[which]) {
		Matrix3 tm = refNode[which]->GetObjectTM(t);
		*pt = tm.GetTrans();
		return TRUE;
	}
	return FALSE;
}

void ProtHelpObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
{
	box = mesh.getBoundingBox(tm);
}

void ProtHelpObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) 
{
	Matrix3 m = inode->GetObjectTM(t);
	Point3 pt;
	Point3 q[4];
	float scaleFactor = vpt->GetVPWorldWidth(m.GetTrans())/360.0f;
	box = mesh.getBoundingBox();
	box.Scale(scaleFactor);

	if (GetTargetPoint(0, t, &pt))
		box += Inverse(m) * pt;
	if (GetTargetPoint(1, t, &pt))
		box += Inverse(m) * pt;
}

void ProtHelpObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
	int i, nv;
	Matrix3 tm;
	Point3 pt;
	GetMat(t,inode,vpt,tm);
	nv = mesh.getNumVerts();
	box.Init();
	for (i=0; i<nv; i++) 
		box += tm*mesh.getVert(i);

	if (GetTargetPoint(0, t, &pt))
		box += pt;
	if (GetTargetPoint(1, t, &pt))
		box += pt;
}

int ProtHelpObject::DrawLines(TimeValue t, INode *inode, GraphicsWindow *gw, int drawing )
{
	Point3 pt[3];
	Matrix3 tm(TRUE);
	gw->setTransform(tm);

	tm = inode->GetObjectTM(t);
	pt[0] = tm.GetTrans();
	if(refNode[1]) {
		pt[1] = refNode[1]->GetObjectTM(t).GetTrans();
		gw->polyline(2, pt, NULL, NULL, FALSE, NULL);
	}
	if(refNode[0]) {
		pt[1] = refNode[0]->GetObjectTM(t).GetTrans();
		gw->setColor(LINE_COLOR, GetUIColor(COLOR_TARGET_LINE));
		gw->polyline(2, pt, NULL, NULL, FALSE, NULL);
	}
	if(gw->checkHitCode())
		pt[0].x = 1.0f;
	return gw->checkHitCode();
}

// From BaseObject

int ProtHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) 
{
	HitRegion hitRegion;
	DWORD	savedLimits;
	int res;
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	// if we get a hit on the mesh, we're done
	gw->clearHitCode();
	if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
		return TRUE;
	// if not, check the target line, and set the pair flag if it's hit
	gw->clearHitCode();
	res = DrawLines(t, inode, gw, 1);
	gw->setRndLimits(savedLimits);
	return res;
}

void ProtHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
{
	if(suspendSnap)
		return;

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	
	gw->setTransform(tm);

	Matrix3 invPlane = Inverse(snap->plane);

	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Point2 fp = Point2((float)p->x, (float)p->y);
		Point2 screen2;
		IPoint3 pt3;

		Point3 thePoint(0,0,0);
		// If constrained to the plane, make sure this point is in it!
		if(snap->snapType == SNAP_2D || snap->flags & SNAP_IN_PLANE) {
			Point3 test = thePoint * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
		}
		gw->wTransPoint(&thePoint,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
			}
			else if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
			}
		}
	}
}

int ProtHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = gw->getMaterial();

	created = TRUE;
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_TAPE_OBJ));
	mesh.render( gw, mtl, NULL, COMP_ALL);
	
	// calc angle
	lastAngle = 0.0;
	#define RadToDegDbl	(180.0 / 3.141592653589793)
	if(refNode[0] && refNode[1]) {
		Point3 origin = m.GetTrans();
		Point3 vec1 = refNode[0]->GetObjectTM(t).GetTrans() - origin;
		Point3 vec2 = refNode[1]->GetObjectTM(t).GetTrans() - origin;
		float len1 = Length(vec1);
		float len2 = Length(vec2);
		if(len1 > 0.00001f && len2 > 0.00001f) {
			double cosAng = (double)DotProd(vec1, vec2) / (double)(len1 * len2);
			if(fabs(cosAng) <= 0.999999)	// beyond float accuracy!
				lastAngle = acos(cosAng) * RadToDegDbl;
			else
				lastAngle = 180.0;
		}
	}
#if 0
	Point3 pt(0,0,0);
	TCHAR buf[32];
	_stprintf(buf, "%g", lastAngle);
	gw->setColor(TEXT_COLOR, GetUIColor(COLOR_TAPE_OBJ));
	gw->text(&pt, buf);
#endif
	DrawLines(t, inode, gw, 1);
	UpdateUI(t);
	return(0);
}


// From GeomObject
int ProtHelpObject::IntersectRay(TimeValue t, Ray& r, float& at) { return(0); }

//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult ProtHelpObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
{
	switch (message) {
	case REFMSG_CHANGE:
		if (iObjParams)
			UpdateUI(iObjParams->GetTime());
		ivalid.SetEmpty();
		break;
	case REFMSG_TARGET_DELETED:
		if (hTarget == refNode[0])
			refNode[0] = NULL;
		else if (hTarget == refNode[1])
			refNode[1] = NULL;
		if (iObjParams)
			UpdateUI(iObjParams->GetTime());
		break;
	}
	return REF_SUCCEED;
}

ObjectState ProtHelpObject::Eval(TimeValue time)
{
	return ObjectState(this);
}

void ProtHelpObject::Invalidate()
{
	ivalid.SetEmpty();
}

Interval ProtHelpObject::ObjectValidity(TimeValue t) 
{
	if (ivalid.Empty())
		ivalid = Interval(t,t);
	else {
		ivalid.SetInfinite();
		if(refNode[0])
			refNode[0]->GetNodeTM(t, &ivalid);
		if(refNode[1])
			refNode[1]->GetNodeTM(t, &ivalid);
		UpdateUI(t);
	}
	return ivalid;	
}

RefTargetHandle ProtHelpObject::Clone(RemapDir& remap) 
{
	ProtHelpObject* newob = new ProtHelpObject();
	newob->refNode[0] = refNode[0];
	newob->refNode[1] = refNode[1];
	return(newob);
}



// IO
IOResult ProtHelpObject::Save(ISave *isave) 
{
	return IO_OK;
}

IOResult ProtHelpObject::Load(ILoad *iload) 
{
#if 0
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
#endif
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\prim.cpp ===
/**********************************************************************
 *<
	FILE: prim.cpp

	DESCRIPTION:   DLL implementation of primitives

	CREATED BY: Dan Silva

	HISTORY: created 12 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "3dsurfer.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;
SurferPatchDataReaderCallback patchReader;
SurferSplineDataReaderCallback splineReader;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	static call=0;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	if (call==0) {
		RegisterObjectAppDataReader(&patchReader);
		RegisterObjectAppDataReader(&splineReader);
		call++;
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,_T("PRIM.DLL: DllMain)",_T("Prim"),MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RB_PRIMLIB); }

#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 40;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBoxobjDesc();
		case 1: return GetSphereDesc();
		case 2: return GetCylinderDesc();
		case 3: return GetLookatCamDesc();
		case 4: return GetSimpleCamDesc();
		case 5: return GetTargetObjDesc();

		case 6: return GetTSpotLightDesc();
		case 7: return GetFSpotLightDesc();
		case 8: return GetTDirLightDesc();
		case 9: return GetDirLightDesc();
		case 10: return GetOmniLightDesc();

		case 11: return GetSplineDesc();
		case 12: return GetNGonDesc();
		case 13: return GetDonutDesc();
		case 14: return GetBonesDesc();
		case 15: return GetRingMasterDesc();
		case 16: return GetSlaveControlDesc();
		case 17: return GetQuadPatchDesc();
		case 18: return GetTriPatchDesc();
		case 19: return GetTorusDesc();
		case 20: return GetMorphObjDesc();
		case 21: return GetCubicMorphContDesc();
		case 22: return GetRectangleDesc();
		case 23: return GetBoolObjDesc();
		case 24: return GetTapeHelpDesc();
		case 25: return GetTubeDesc();
		case 26: return GetConeDesc();
		case 27: return GetHedraDesc();
		case 28: return GetCircleDesc();
		case 29: return GetEllipseDesc();
		case 30: return GetArcDesc();
		case 31: return GetStarDesc();
		case 32: return GetHelixDesc();
		case 33: return GetRainDesc();
		case 34: return GetSnowDesc();
		case 35: return GetTextDesc();
		case 36: return GetTeapotDesc();
		case 37: return GetBaryMorphContDesc();
		case 38: return GetProtHelpDesc();
		case 39: return GetGridobjDesc();
		default: return 0;
		}

	}

#else

//
// DESIGN VERSION EXCLUDES SOME PLUG_INS
//

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 32;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetBoxobjDesc();
		case 1: return GetSphereDesc();
		case 2: return GetCylinderDesc();
		case 3: return GetLookatCamDesc();
		case 4: return GetSimpleCamDesc();
		case 5: return GetTargetObjDesc();

		case 6: return GetTSpotLightDesc();
		case 7: return GetFSpotLightDesc();
		case 8: return GetTDirLightDesc();
		case 9: return GetDirLightDesc();
		case 10: return GetOmniLightDesc();

		case 11: return GetSplineDesc();
		case 12: return GetNGonDesc();
		case 13: return GetDonutDesc();
		//case 14: return GetBonesDesc();
		//case 15: return GetRingMasterDesc();
		//case 16: return GetSlaveControlDesc();
		case 14: return GetQuadPatchDesc();
		case 15: return GetTriPatchDesc();
		case 16: return GetTorusDesc();
		//case 20: return GetMorphObjDesc();
		//case 21: return GetCubicMorphContDesc();
		case 17: return GetRectangleDesc();
		case 18: return GetBoolObjDesc();
		case 19: return GetTapeHelpDesc();
		case 20: return GetTubeDesc();
		case 21: return GetConeDesc();
		case 22: return GetHedraDesc();
		case 23: return GetCircleDesc();
		case 24: return GetEllipseDesc();
		case 25: return GetArcDesc();
		case 26: return GetStarDesc();
		case 27: return GetHelixDesc();
		//case 33: return GetRainDesc();
		//case 34: return GetSnowDesc();
		case 28: return GetTextDesc();
		//case 36: return GetTeapotDesc();
		case 29: return GetBaryMorphContDesc();
		case 30: return GetProtHelpDesc();
		case 31: return GetGridobjDesc();

		default: return 0;
		}

	}

#endif



// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\rain.cpp ===
/**********************************************************************
 *<
	FILE: RAIN.CPP

	DESCRIPTION: Rain and snow particle systems 

	CREATED BY: Rolf Berteig	

	HISTORY: created 29 October 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "texutil.h"

void CacheData(ParticleSys *p0,ParticleSys *p1);

class GenParticle : public SimpleParticle {
	public:
		static IParamMap *pmapParam;		
		int stepSize;

		GenParticle(BOOL rain);
		void BirthParticle(INode *node,TimeValue bt,int index);
		void ComputeParticleStart(TimeValue t0,INode *node);
		int CountLive();
		Mesh *GetFacingRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		int	GetParticleCount();				
		TimeValue ParticleLife(TimeValue t, int i);
		void RescaleWorldUnits(float f);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
			
		// Animatable methods		
		void DeleteThis() {delete this;}
		IOResult Load(ILoad *iload);
		void MapKeys(TimeMap *map,DWORD flags);
		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);
		
		// From SimpleParticle
		void UpdateParticles(TimeValue t,INode *node);
		void BuildEmitter(TimeValue t, Mesh& amesh);
		Interval GetValidity(TimeValue t);		
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL EmitterVisible();		
		Point3 ParticlePosition(TimeValue t,int i);
		Point3 ParticleVelocity(TimeValue t,int i);		

		virtual int DialogID()=0;
		virtual ParamUIDesc *ParamDesc()=0;
		virtual int DescCount()=0;
	};

class RainParticle;

class RainParticleDraw : public CustomParticleDisplay {
	public:
		TimeValue life;
		BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i);
	};

class RainParticle : public GenParticle {
	public:
		RainParticleDraw theRainDraw;

		RainParticle() : GenParticle(TRUE) {}

		// From BaseObject
		TCHAR *GetObjectName() {return GetString(IDS_RB_SPRAY);}
		
		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		int IsInstanceDependent() {return 1;}

		// Animatable methods				
		Class_ID ClassID() {return Class_ID(RAIN_CLASS_ID,0);} 

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From SimpleParticle
		MarkerType GetMarkerType();		
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);

		int DialogID() {return IDD_RAINPARAM;}
		ParamUIDesc *ParamDesc();
		int DescCount();
	};

class SnowParticle;

class SnowParticleDraw : public CustomParticleDisplay {
	public:
		float scale, tumble;
		TimeValue life;
		SnowParticle *obj;

		SnowParticleDraw() {obj=NULL;}
		BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i);
	};

class SnowParticle : public GenParticle {
	public:
		SnowParticleDraw theSnowDraw;

		SnowParticle();

		// From BaseObject
		TCHAR *GetObjectName() {return GetString(IDS_RB_SNOW);}
		
		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		int IsInstanceDependent() {return 1;}

		// Animatable methods				
		Class_ID ClassID() {return Class_ID(SNOW_CLASS_ID,0);} 

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From SimpleParticle
		MarkerType GetMarkerType();		
		void UpdateParticles(TimeValue t,INode *node);
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);

		int DialogID() {return IDD_SNOWPARAM;}
		ParamUIDesc *ParamDesc();
		int DescCount();

		Matrix3 TumbleMat(int index,float amount, float scale);
	};


//--- ClassDescriptor and class vars ---------------------------------

class RainClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new RainParticle;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_SPRAY_CLASS);}
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(RAIN_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(IDS_RB_PARTICLESYSTEMS);}
	};

static RainClassDesc rainDesc;
ClassDesc* GetRainDesc() {return &rainDesc;}

class SnowClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new SnowParticle;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_SNOW_CLASS);}
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(SNOW_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(IDS_RB_PARTICLESYSTEMS);}
	};

static SnowClassDesc snowDesc;
ClassDesc* GetSnowDesc() {return &snowDesc;}

IParamMap *GenParticle::pmapParam;


//--- Parameter map/block descriptors -------------------------------

#define RAINSIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)
#define PARTICLE_SEED	0x8d6a65bc


#define PB_VPTPARTICLES		0
#define PB_RNDPARTICLES		1
#define PB_DROPSIZE			2
#define PB_SPEED			3
#define PB_VARIATION		4
#define PB_DISPTYPE			5
#define PB_STARTTIME		6
#define PB_LIFETIME			7
#define PB_EMITTERWIDTH		8
#define PB_EMITTERHEIGHT	9
#define PB_HIDEEMITTER		10
#define PB_BIRTHRATE		11
#define PB_CONSTANT			12
#define PB_RENDER			13
#define PB_TUMBLE			14
#define PB_SCALE			15


// render types
#define RENDTYPE1	0
#define RENDTYPE2	1
#define RENDTYPE3	2

#define A_RENDER			A_PLUGIN1

class BirthRateDimension : public ParamDimension {
	public:
		DimType DimensionType() {return DIM_CUSTOM;}
		float Convert(float value) {return value*(float)GetTicksPerFrame();}
		float UnConvert(float value) {return value/(float)GetTicksPerFrame();}
	};
static BirthRateDimension theBirthRateDim;

#define MAX_PARTICLE_COUNT	500000

//
//
// Parameters

static int typeIDs[] = {IDC_PARTICLE_CUST,IDC_PARTICLE_DOTS,IDC_PARTICLE_TICKS};
static int rendIDs[] = {IDC_PARTICLE_REND1,IDC_PARTICLE_REND2,IDC_PARTICLE_REND3};

static ParamUIDesc descParamRain[] = {
	// Viewport particles
	ParamUIDesc(
		PB_VPTPARTICLES,
		EDITTYPE_INT,
		IDC_VPT_PARTICLES,IDC_VPT_PARTICLESSPIN,
		1.0f,(float)MAX_PARTICLE_COUNT,
		1.0f),

	// Render particles
	ParamUIDesc(
		PB_RNDPARTICLES,
		EDITTYPE_INT,
		IDC_RND_PARTICLES,IDC_RND_PARTICLESSPIN,
		1.0f,(float)MAX_PARTICLE_COUNT,
		1.0f),

	// Particle size
	ParamUIDesc(
		PB_DROPSIZE,
		EDITTYPE_UNIVERSE,
		IDC_PARTICLE_SIZE,IDC_PARTICLE_SIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Particle speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_SPEED,IDC_PARTICLE_SPEEDSPIN,
		-999999999.0f,999999999.0f,
		0.005f),

	// Particle Variation
	ParamUIDesc(
		PB_VARIATION,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_VARIATION,IDC_PARTICLE_VARIATIONSPIN,
		0.0f,999999999.0f,
		0.005f),

	// Display type
	ParamUIDesc(PB_DISPTYPE,TYPE_RADIO,typeIDs,3),

	// Start time
	ParamUIDesc(
		PB_STARTTIME,
		EDITTYPE_TIME,
		IDC_PARTICLE_START,IDC_PARTICLE_STARTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Life time
	ParamUIDesc(
		PB_LIFETIME,
		EDITTYPE_TIME,
		IDC_PARTICLE_LIFE,IDC_PARTICLE_LIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Birth Rate
	ParamUIDesc(
		PB_BIRTHRATE,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_BIRTHRATE,IDC_PARTICLE_BIRTHRATESPIN,
		0.0f,999999999.0f,
		0.1f,
		&theBirthRateDim),

	// Constant birth rate
	ParamUIDesc(PB_CONSTANT,TYPE_SINGLECHEKBOX,IDC_PARTICLE_CONSTANTRATE),

	// Emitter width
	ParamUIDesc(
		PB_EMITTERWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_EMITTER_WIDTH,IDC_EMITTER_WIDTHSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Emitter height
	ParamUIDesc(
		PB_EMITTERHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_EMITTER_HEIGHT,IDC_EMITTER_HEIGHTSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_HIDEEMITTER,TYPE_SINGLECHEKBOX,IDC_HIDE_EMITTER),
	
	// Render
	ParamUIDesc(PB_RENDER,TYPE_RADIO,rendIDs,3),
	};
#define RAINPARAMDESC_LENGH 14

static ParamUIDesc descParamSnow[] = {
	// Viewport particles
	ParamUIDesc(
		PB_VPTPARTICLES,
		EDITTYPE_INT,
		IDC_VPT_PARTICLES,IDC_VPT_PARTICLESSPIN,
		1.0f,(float)MAX_PARTICLE_COUNT,
		1.0f),

	// Render particles
	ParamUIDesc(
		PB_RNDPARTICLES,
		EDITTYPE_INT,
		IDC_REND_PARTICLES,IDC_REND_PARTICLESSPIN,
		1.0f,(float)MAX_PARTICLE_COUNT,
		1.0f),

	// Particle size
	ParamUIDesc(
		PB_DROPSIZE,
		EDITTYPE_UNIVERSE,
		IDC_PARTICLE_SIZE,IDC_PARTICLE_SIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Particle speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_SPEED,IDC_PARTICLE_SPEEDSPIN,
		-999999999.0f,999999999.0f,
		0.005f),

	// Particle Variation
	ParamUIDesc(
		PB_VARIATION,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_VARIATION,IDC_PARTICLE_VARIATIONSPIN,
		0.0f,999999999.0f,
		0.005f),

	// Particle Tumble
	ParamUIDesc(
		PB_TUMBLE,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_TUMBLE,IDC_PARTICLE_TUMBLESPIN,
		0.0f,1.0f,
		0.005f),

	// Tumble scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_SCALE,IDC_PARTICLE_SCALESPIN,
		0.0f,999999999.0f,
		0.01f),

	// Display type
	ParamUIDesc(PB_DISPTYPE,TYPE_RADIO,typeIDs,3),

	// Start time
	ParamUIDesc(
		PB_STARTTIME,
		EDITTYPE_TIME,
		IDC_PARTICLE_START,IDC_PARTICLE_STARTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Life time
	ParamUIDesc(
		PB_LIFETIME,
		EDITTYPE_TIME,
		IDC_PARTICLE_LIFE,IDC_PARTICLE_LIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Birth Rate
	ParamUIDesc(
		PB_BIRTHRATE,
		EDITTYPE_FLOAT,
		IDC_PARTICLE_BIRTHRATE,IDC_PARTICLE_BIRTHRATESPIN,
		0.0f,999999999.0f,
		0.1f,
		&theBirthRateDim),

	// Constant birth rate
	ParamUIDesc(PB_CONSTANT,TYPE_SINGLECHEKBOX,IDC_PARTICLE_CONSTANTRATE),

	// Emitter width
	ParamUIDesc(
		PB_EMITTERWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_EMITTER_WIDTH,IDC_EMITTER_WIDTHSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Emitter height
	ParamUIDesc(
		PB_EMITTERHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_EMITTER_HEIGHT,IDC_EMITTER_HEIGHTSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_HIDEEMITTER,TYPE_SINGLECHEKBOX,IDC_HIDE_EMITTER),
	
	// Render
	ParamUIDesc(PB_RENDER,TYPE_RADIO,rendIDs,3),
	};
#define SNOWPARAMDESC_LENGH 16


static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 }};

static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // birth rate
	{ TYPE_INT, NULL, FALSE, 11 }	// constant
	};

static ParamBlockDescID descVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// count
	{ TYPE_FLOAT, NULL, TRUE, 1 },	// size
	{ TYPE_FLOAT, NULL, TRUE, 2 },	// speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	// variation
	{ TYPE_FLOAT, NULL, TRUE, 12 },	// tumble
	{ TYPE_FLOAT, NULL, TRUE, 13 },	// tumble scale
	{ TYPE_INT, NULL, FALSE, 4 },	// viewport type	
	{ TYPE_INT, NULL, FALSE, 5 },	// start
	{ TYPE_INT, NULL, FALSE, 6 },	// life
	{ TYPE_FLOAT, NULL, TRUE, 7 },	// width
	{ TYPE_FLOAT, NULL, TRUE, 8 },	// height
	{ TYPE_INT, NULL, FALSE, 9 },	// hide emitter
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // birth rate
	{ TYPE_INT, NULL, FALSE, 11 },	// constant
	{ TYPE_INT, NULL, FALSE, 14 },	// render type
	};

static ParamBlockDescID descVer3[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// vpt count
	{ TYPE_INT, NULL, FALSE, 15 },	// rnd count	
	{ TYPE_FLOAT, NULL, TRUE, 1 },	// size
	{ TYPE_FLOAT, NULL, TRUE, 2 },	// speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	// variation	
	{ TYPE_INT, NULL, FALSE, 4 },	// viewport type	
	{ TYPE_INT, NULL, FALSE, 5 },	// start
	{ TYPE_INT, NULL, FALSE, 6 },	// life
	{ TYPE_FLOAT, NULL, TRUE, 7 },	// width
	{ TYPE_FLOAT, NULL, TRUE, 8 },	// height
	{ TYPE_INT, NULL, FALSE, 9 },	// hide emitter
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // birth rate
	{ TYPE_INT, NULL, FALSE, 11 },	// constant
	{ TYPE_INT, NULL, FALSE, 14 },	// render type
	{ TYPE_FLOAT, NULL, TRUE, 12 },	// tumble
	{ TYPE_FLOAT, NULL, TRUE, 13 },	// tumble scale
	};


// Note that tumble and scale are only used by snow
#define PBLOCK_LENGTH_RAIN 14
#define PBLOCK_LENGTH_SNOW 16


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,10,0),
	ParamVersionDesc(descVer1,12,1),
	ParamVersionDesc(descVer2,15,2)	
	};
#define NUM_OLDVERSIONS	3

// Current version
#define CURRENT_VERSION	3
static ParamVersionDesc curVersionRain(descVer3,PBLOCK_LENGTH_RAIN,CURRENT_VERSION);
static ParamVersionDesc curVersionSnow(descVer3,PBLOCK_LENGTH_SNOW,CURRENT_VERSION);


//-- ParticleDlgProc ------------------------------------------------

class ParticleDlgProc : public ParamMapUserDlgProc {
	public:
		GenParticle *po;

		ParticleDlgProc(GenParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
		void SetupMaxRate(HWND hWnd,IParamBlock *pblock,TimeValue t);
		void SetupConstant(HWND hWnd);
	};

void ParticleDlgProc::SetupMaxRate(HWND hWnd,IParamBlock *pblock,TimeValue t)
	{
	int count, life;
	pblock->GetValue(PB_RNDPARTICLES,t,count,FOREVER);
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	if (life <= 0) life = 1;
	TSTR buf;
	buf.printf(_T("%.1f"),(float)GetTicksPerFrame()*float(count)/float(life));
	SetWindowText(GetDlgItem(hWnd,IDC_PARTICLE_MAXRATE),buf);
	}

void ParticleDlgProc::SetupConstant(HWND hWnd)
	{
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_PARTICLE_BIRTHRATESPIN));
	if (IsDlgButtonChecked(hWnd,IDC_PARTICLE_CONSTANTRATE)) {
		spin->Disable();
	} else {
		spin->Enable();
		}
	ReleaseISpinner(spin);
	}


#define MAX_EVAL_TIME_DELTA		TIME_TICKSPERSEC*1000

BOOL ParticleDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			SetupMaxRate(hWnd,(IParamBlock*)map->GetParamBlock(),t);
			SetupConstant(hWnd);
			break;			
			
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_PARTICLE_STARTSPIN: {
					ISpinnerControl *spin = (ISpinnerControl*)lParam;
					TimeValue st = spin->GetIVal();
					TimeValue ct = GetCOREInterface()->GetTime();
					if (st+MAX_EVAL_TIME_DELTA < ct) {
						st = ct - MAX_EVAL_TIME_DELTA;
						map->GetParamBlock()->SetValue(PB_STARTTIME,ct, st);
						}
					break;
					}

				case IDC_VPT_PARTICLESSPIN:
				case IDC_PARTICLE_LIFESPIN: 
					SetupMaxRate(hWnd,(IParamBlock*)map->GetParamBlock(),t);
					break;					
				}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_PARTICLE_CONSTANTRATE:
					SetupConstant(hWnd);
					break;					
				}
			break;	
		}
	return FALSE;
	}


static float CompParticleSize(
		TimeValue age, TimeValue life, float size)
	{
	float u = float(age)/float(life);
	if (u>0.75f) {
		return (1.0f-smoothstep(0.75f,1.0f,u)) * size;
	} else {
		return size;
		}
	}

//--- GenParticle Methods--------------------------------------------

static int Parity(Matrix3 tm)
	{
	Point3 v = tm.GetRow(0) ^ tm.GetRow(1);
	if (DotProd(v,tm.GetRow(2)) < 0.0f) return 1;
	return 0;
	}

static void FlipAllMeshFaces(Mesh *mesh)
	{
	for (int i=0; i<mesh->getNumFaces(); i++) 
		mesh->FlipNormal(i);
	}


GenParticle::GenParticle(BOOL rain)
	{
	int length = rain ? PBLOCK_LENGTH_RAIN: PBLOCK_LENGTH_SNOW;
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer3, length, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_VPTPARTICLES,0,100);
	pblock->SetValue(PB_RNDPARTICLES,0,100);
	pblock->SetValue(PB_DROPSIZE,0,2.0f);
	pblock->SetValue(PB_SPEED,0,10.0f);
	pblock->SetValue(PB_DISPTYPE,0,0);
	pblock->SetValue(PB_STARTTIME,0,0);
	pblock->SetValue(PB_LIFETIME,0,TIME_TICKSPERSEC);
	pblock->SetValue(PB_CONSTANT,0,1);
	if (!rain) pblock->SetValue(PB_SCALE,0,1.0f);
	stepSize = 0;
	}

// RB 3/3/99: Implemented this to also scale speed and variation
void GenParticle::RescaleWorldUnits(float f)
	{
	if (TestAFlag(A_WORK1))
		return;
	
	// Call the base class's rescale (this sets the A_WORK1 flag)
	SimpleParticle::RescaleWorldUnits(f);

	pblock->RescaleParam(PB_SPEED, f);
	pblock->RescaleParam(PB_VARIATION, f);	
	}

class ParticlePostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		ParticlePostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((GenParticle*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer==0) {				
				((GenParticle*)targ)->pblock->SetValue(PB_CONSTANT,0,1);
				}
			if (oldVer<3) {
				// Set render particles to vpt particles.
				int vc;				
				((GenParticle*)targ)->pblock->GetValue(PB_VPTPARTICLES,0,vc,FOREVER);
				((GenParticle*)targ)->pblock->SetValue(PB_RNDPARTICLES,0,vc);
				}
			delete this;
			}
	};

IOResult GenParticle::Load(ILoad *iload)
	{
	if (ClassID()==Class_ID(RAIN_CLASS_ID,0)) {
		iload->RegisterPostLoadCallback(
			new ParticlePostLoadCallback(
				new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersionRain,this,0)));
	} else {
		iload->RegisterPostLoadCallback(
			new ParticlePostLoadCallback(
				new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersionSnow,this,0)));
		}
	return IO_OK;
	}

TimeValue GenParticle::ParticleLife(TimeValue t, int i)
	{
	TimeValue life;	
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	return life;
	}

Point3 GenParticle::ParticlePosition(TimeValue t,int i)
	{
	return parts.points[i];
	}

Point3 GenParticle::ParticleVelocity(TimeValue t,int i)
	{
	return parts.vels[i];
	}


// RB 3-38-96
// Changed render begin and end to always invalidate the particles.
// This ensures that the particles will always update completely
// once before a rendering session and allows the integration
// step size to change to the size of a field instead of a frame.

int GenParticle::RenderBegin(TimeValue t, ULONG flags)
	{
	SetAFlag(A_RENDER);
	ParticleInvalid();		
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;

#if 0
	int vc, rc;
	pblock->GetValue(PB_VPTPARTICLES,0,vc,FOREVER);
	pblock->GetValue(PB_RNDPARTICLES,0,rc,FOREVER);
	SetAFlag(A_RENDER);
	if (vc!=rc) {
		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
#endif
	}

int GenParticle::RenderEnd(TimeValue t)
	{
	ClearAFlag(A_RENDER);
	ParticleInvalid();		
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;

#if 0
	int vc, rc;
	pblock->GetValue(PB_VPTPARTICLES,0,vc,FOREVER);
	pblock->GetValue(PB_RNDPARTICLES,0,rc,FOREVER);
	ClearAFlag(A_RENDER);
	if (vc!=rc) {
		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
#endif
	}

int	GenParticle::GetParticleCount()
	{
	int c;
	if (TestAFlag(A_RENDER)) pblock->GetValue(PB_RNDPARTICLES,0,c,FOREVER);
	else pblock->GetValue(PB_VPTPARTICLES,0,c,FOREVER);
	if (c > MAX_PARTICLE_COUNT) c = MAX_PARTICLE_COUNT;
	return c;
	}

void GenParticle::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleParticle::BeginEditParams(ip,flags,prev);
	if (pmapParam) {
		pmapParam->SetParamBlock(pblock);
	} else {		
		
		pmapParam = CreateCPParamMap(
			ParamDesc(),DescCount(),
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(DialogID()),
			GetString(IDS_RB_PARAMETERS),
			0);		
		}
	pmapParam->SetUserDlgProc(new ParticleDlgProc(this));
	}

void GenParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleParticle::EndEditParams(ip,flags,next);

	if (flags&END_EDIT_REMOVEUI) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		}
	}

void GenParticle::MapKeys(TimeMap *map,DWORD flags)
	{
	Animatable::MapKeys(map,flags);

	TimeValue start, life;
	pblock->GetValue(PB_STARTTIME,0,start,FOREVER);
	pblock->GetValue(PB_LIFETIME,0,life,FOREVER);

	start = map->map(start);
	life  = map->map(life);

	pblock->SetValue(PB_STARTTIME,0,start);
	pblock->SetValue(PB_LIFETIME,0,life);
	}

Interval GenParticle::GetValidity(TimeValue t)
	{
	// For now...
	return Interval(t,t);
	}

void GenParticle::BuildEmitter(TimeValue t, Mesh& amesh)
	{
	float width, height;
	mvalid = FOREVER;
	pblock->GetValue(PB_EMITTERWIDTH,t,width,mvalid);
	pblock->GetValue(PB_EMITTERHEIGHT,t,height,mvalid);
	width  *= 0.5f;
	height *= 0.5f;

	mesh.setNumVerts(7);
	mesh.setNumFaces(6);
	mesh.setVert(0, Point3(-width,-height, 0.0f));
	mesh.setVert(1, Point3( width,-height, 0.0f));
	mesh.setVert(2, Point3( width, height, 0.0f));
	mesh.setVert(3, Point3(-width, height, 0.0f));
	mesh.setVert(4, Point3(  0.0f,   0.0f, 0.0f));
	mesh.setVert(5, Point3(  0.0f,   0.0f, -(width+height)/2.0f));
	mesh.setVert(6, Point3(  0.0f,   0.0f, 0.0f));

	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(1);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(1);
	mesh.faces[1].setVerts(1,2,3);

	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(1);
	mesh.faces[2].setVerts(4,5,6);

	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(1);
	mesh.faces[3].setVerts(0,3,1);

	mesh.faces[4].setEdgeVisFlags(0,1,1);
	mesh.faces[4].setSmGroup(1);
	mesh.faces[4].setVerts(1,3,2);

	mesh.faces[5].setEdgeVisFlags(1,0,0);
	mesh.faces[5].setSmGroup(1);
	mesh.faces[5].setVerts(5,4,6);

	mesh.InvalidateGeomCache();
	}

int GenParticle::CountLive()
	{
	int c=0;
	for (int i=0; i<parts.Count(); i++) {
		if (parts.Alive(i)) c++;
		}
	return c;
	}

void GenParticle::ComputeParticleStart(TimeValue t0,INode *node)
	{
	int c = GetParticleCount();	
	parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES);
	for (int i=0; i<parts.Count(); i++) {
		parts.ages[i] = -1;
		}
	tvalid = t0;
	valid  = TRUE;
	}


#define VEL_SCALE	(-0.01f*1200.0f/float(TIME_TICKSPERSEC))
#define VAR_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))

void GenParticle::BirthParticle(INode *node,TimeValue bt,int index)
	{
	float initVel, var;
	float width, height;
	Point3 pos, vel;
	Matrix3 tm = node->GetObjTMBeforeWSM(bt);

	pblock->GetValue(PB_EMITTERWIDTH,bt,width,FOREVER);
	pblock->GetValue(PB_EMITTERHEIGHT,bt,height,FOREVER);
	pblock->GetValue(PB_SPEED,bt,initVel,FOREVER);
	pblock->GetValue(PB_VARIATION,bt,var,FOREVER);
	initVel *= VEL_SCALE; // UI Scaling

	vel = Point3(0.0f, 0.0f, initVel);
	if (var!=0.0f) {
		var *= VAR_SCALE;
		vel.x = -var + float(rand())/float(RAND_MAX) * 2.0f*var;
		vel.y = -var + float(rand())/float(RAND_MAX) * 2.0f*var;
		vel.z = initVel - var + float(rand())/float(RAND_MAX) * 2.0f*var;
		}

	parts.ages[index] = 0;
	parts.vels[index] = VectorTransform(tm,vel);
			
	pos.x = -width/2.0f + float(rand())/float(RAND_MAX) * width;
	pos.y = -height/2.0f + float(rand())/float(RAND_MAX) * height;
	pos.z = 0.0f;
	
	parts[index] = pos * tm;
	}



void GenParticle::UpdateParticles(TimeValue t,INode *node)
	{
	TimeValue t0, life, dt,oneframe;
	int i, j, constant = TRUE, total, birth=0;
	float brate, brateFactor = 1.0f;
	Point3 force;		
	
	// The size of steps we take to integrate will be 
	// frame size steps. Unless we're rendering in which
	// case we'll take field size steps to ensure that
	// particle are synchronized on multiple machines
	// rendering fields
	if (stepSize!=(oneframe=GetTicksPerFrame())) {
			stepSize = GetTicksPerFrame();
			valid = FALSE;
			}
	pblock->GetValue(PB_STARTTIME,t,t0,FOREVER);
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	pblock->GetValue(PB_DROPSIZE,t,parts.size,FOREVER);	
	pblock->GetValue(PB_CONSTANT,t,constant,FOREVER);	
	total = GetParticleCount();

	if (life <= 0) life = 1;
	if (constant) {
		brate = float(total)/float(life);		
	} else if (!TestAFlag(A_RENDER)) {
		int vc, rc;
		pblock->GetValue(PB_RNDPARTICLES,0,rc,FOREVER);
		pblock->GetValue(PB_VPTPARTICLES,0,vc,FOREVER);
		if (rc > MAX_PARTICLE_COUNT) rc = MAX_PARTICLE_COUNT;
		if (vc > MAX_PARTICLE_COUNT) vc = MAX_PARTICLE_COUNT;
		brateFactor = float(vc)/float(rc);
		}

	if (t < t0) {
		// Before the start time, nothing is happening
		parts.FreeAll();
		tvalid = t;
		valid  = TRUE;
		return;
		}

	if (!valid || t<tvalid || tvalid<t0) {
		// Set the particle system to the initial condition
		ComputeParticleStart(t0,node);
		}
	valid = TRUE;
	
	BOOL fullframe;
	if (!TestAFlag(A_RENDER))
	{ int offby=t%oneframe;
	  if (offby>0) t-=offby;
	}
	while (tvalid < t) {
		int born = 0;		

		// Compute our step size
		if (tvalid%stepSize !=0) {
			dt = stepSize - tvalid%stepSize;
		} else {
			dt = stepSize;
			}
		if (tvalid + dt > t) {
			dt = t-tvalid;
			}

		// Increment time
		tvalid += dt;

		
		// Compute the number of particles that should be born
		fullframe=(tvalid%oneframe==0);
		if (fullframe)
		{if (!constant) {pblock->GetValue(PB_BIRTHRATE,tvalid,brate,FOREVER);}
		birth = int((tvalid-t0)*brate*brateFactor) 
			- int((tvalid-t0-dt)*brate*brateFactor);
		}		

		// First increment age and kill off old particles
		for (j=0; j<parts.Count(); j++) {
			if (!parts.Alive(j)) continue;
			parts.ages[j] += dt;
			if (parts.ages[j] >= life) {
				parts.ages[j] = -1;
				}
			}

		
		// We want to seed the random number generator for all particles
		// born at this time. Construct the seed based on this time by
		// pulling out each of the 4 bytes, Perm() each one, and put
		// them back in the opposite byte order.
		int seed1 = (tvalid*1200)/TIME_TICKSPERSEC;
		int seed2 = seed1 >> 8;
		int seed3 = seed2 >> 8;
		int seed4 = seed2 >> 8;
		seed1 &= 0xFF;
		seed2 &= 0xFF;
		seed3 &= 0xFF;
		seed4 &= 0xFF;
		srand(
			(Perm(seed1)<<24) + 
			(Perm(seed2)<<16) +
			(Perm(seed3)<<8)  +
			Perm(seed4) +
			int(PARTICLE_SEED));
		
		// Next, birth particles at the birth rate
		for (j=0; j<parts.Count(); j++) {
			if (born>=birth) break;
			if (!parts.Alive(j)) {
				BirthParticle(node,tvalid,j);
				born++;
				}
			}

		// Apply forces to modify velocity
		if (fullframe)
		for (i=0; i<fields.Count(); i++) {		
			for (j=0; j<parts.Count(); j++) {
				if (!parts.Alive(j)) continue;
				force = fields[i]->Force(tvalid,parts[j],parts.vels[j],j);
				parts.vels[j] += force * float(dt);
				}
			}
		
		// Increment the positions
		for (j=0; j<parts.Count(); j++) {
			if (!parts.Alive(j)) continue;
			
			// Check for collisions
			BOOL collide = FALSE;
			for (int i=0; i<cobjs.Count(); i++) {
				if (cobjs[i]->CheckCollision(
						tvalid,parts[j],parts.vels[j], float(dt), j)) {
					collide = TRUE;
					break;
					}
				}
			
			// If we didn't collide, then increment.
			if (!collide) parts[j] += parts.vels[j] * float(dt);			
			}
		}
	
	assert(tvalid==t);
	}

class EmitterCreateCallback : public CreateMouseCallBack {
	public:
		GenParticle *rain;
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int EmitterCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point)  {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				rain->pblock->SetValue(PB_EMITTERWIDTH,0,0.01f);
				rain->pblock->SetValue(PB_EMITTERHEIGHT,0,0.01f);
				rain->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				rain->pblock->SetValue(PB_EMITTERWIDTH,0,
					(float)fabs(p1.x-p0.x));
				rain->pblock->SetValue(PB_EMITTERHEIGHT,0,
					(float)fabs(p1.y-p0.y));
				rain->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 || Length(p1-p0)<0.1f) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static EmitterCreateCallback emitterCallback;

CreateMouseCallBack* GenParticle::GetCreateMouseCallBack() 
	{
	emitterCallback.rain = this;
	return &emitterCallback;
	}

void GenParticle::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}

BOOL GenParticle::EmitterVisible()
	{
	int hide;
	pblock->GetValue(PB_HIDEEMITTER,0,hide,FOREVER);
	return !hide;
	}

ParamDimension *GenParticle::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_EMITTERWIDTH:
		case PB_EMITTERHEIGHT:
		case PB_DROPSIZE:		return stdWorldDim;

		case PB_STARTTIME:
		case PB_LIFETIME:		return stdTimeDim;
		
		case PB_BIRTHRATE:		return &theBirthRateDim;
		default: return defaultDim;
		}
	}

TSTR GenParticle::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_VPTPARTICLES:	return GetString(IDS_RB_VIEWPARTICLES);		
		case PB_SPEED:			return GetString(IDS_RB_SPEED);
		case PB_VARIATION:		return GetString(IDS_RB_VARIATION);
		case PB_STARTTIME:		return GetString(IDS_RB_STARTTIME);
		case PB_LIFETIME:		return GetString(IDS_RB_LIFETIME);
		case PB_EMITTERWIDTH:	return GetString(IDS_RB_WIDTH);
		case PB_EMITTERHEIGHT:	return GetString(IDS_RB_LENGTH);
		case PB_BIRTHRATE:		return GetString(IDS_RB_BIRTHRATE);
		case PB_TUMBLE:			return GetString(IDS_RB_TUMBLE);
		case PB_SCALE:			return GetString(IDS_RB_TUMBLERATE);
		case PB_DROPSIZE:		
			if (ClassID()==Class_ID(RAIN_CLASS_ID,0)) {
				return GetString(IDS_RB_DROPSIZE);
			} else {
				return GetString(IDS_RB_FLAKESIZE);
				}
			break;

		default: 				return TSTR(_T(""));
		}
	}


Mesh *GenParticle::GetFacingRenderMesh(
		TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{
	Mesh *pm = new Mesh;	
	int ix=0, nx=0, count;
	float size, sz;
	Matrix3 tm = Inverse(inode->GetObjTMAfterWSM(t));
	Matrix3 cam = Inverse(view.worldToView);
	Point3 v, v0,v1, camV = cam.GetRow(3);	
	TimeValue life;

	pblock->GetValue(PB_DROPSIZE,t,size,FOREVER);
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	if (life<=0) life = 1;
	
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	if (midframe) 
	{ Update(t-offtime,inode);
	  CacheData(&parts,&lastparts);
	  Update(t,inode);
	}
	else Update(t,inode);
	count = CountLive();

	pm->setNumFaces(count*2);
	pm->setNumVerts(count*4);
	pm->setNumTVerts(count*4);
	pm->setNumTVFaces(count*2);

	for (int i=0; i<parts.Count(); i++) {
		if (!parts.Alive(i)) continue;

		// Compute this particle's size
		sz = CompParticleSize(parts.ages[i],life,size);

		// Compute a vector from the particle to the camera
		v  = Normalize(camV-parts[i]);		
		v0 = Normalize(Point3(0,0,1)^v) * sz;
		v1 = Normalize(v0^v) * sz;
		
		pm->verts[ix  ] = (parts[i]+v0+v1) * tm;
		pm->verts[ix+1] = (parts[i]-v0+v1) * tm;
		pm->verts[ix+2] = (parts[i]-v0-v1) * tm;
		pm->verts[ix+3] = (parts[i]+v0-v1) * tm;

		pm->faces[nx  ].setSmGroup(1);		
		pm->faces[nx  ].setVerts(ix+1,ix ,ix+2);
		pm->faces[nx  ].setMatID((MtlID)i);
		pm->faces[nx  ].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
		pm->faces[nx+1].setSmGroup(1);		
		pm->faces[nx+1].setVerts(ix+3,ix+2,ix  );
		pm->faces[nx+1].setMatID((MtlID)i);
		pm->faces[nx+1].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible

		pm->setTVert(ix  ,1.0f,1.0f,0.0f);
		pm->setTVert(ix+1,0.0f,1.0f,0.0f);
		pm->setTVert(ix+2,0.0f,0.0f,0.0f);
		pm->setTVert(ix+3,1.0f,0.0f,0.0f);

		pm->tvFace[nx  ].setTVerts(ix+1,ix  ,ix+2);
		pm->tvFace[nx+1].setTVerts(ix+3,ix+2,ix  );
		
		ix += 4;
		nx += 2;
		}
	
	if (midframe) { 
		CacheData(&lastparts,&parts);
		tvalid=t-offtime;
		}
	if (Parity(tm)) FlipAllMeshFaces(pm);

	mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;
	}


void GenParticle::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{
	int type, life;
	pblock->GetValue(PB_DISPTYPE,0,type,FOREVER);
	pblock->GetValue(PB_LIFETIME,0,life,FOREVER);
	BOOL rain = ClassID()==Class_ID(RAIN_CLASS_ID,0);
	
	if (type==0) {
		Box3 pbox;
		Matrix3 mat = inode->GetObjTMBeforeWSM(t);	
		UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {
				continue;
				}
			float sz = 
				CompParticleSize(parts.ages[i],life,parts.size);			
			
			Point3 pt = parts.points[i];
			pbox += pt;
			if (rain) {				
				pbox += pt - parts.vels[i] * RAINSIZEFACTOR * sz;
			} else {
				pbox += pt + Point3( sz, 0.0f, 0.0f);
				pbox += pt + Point3(-sz, 0.0f, 0.0f);
				pbox += pt + Point3( 0.0f, sz, 0.0f);
				pbox += pt + Point3( 0.0f,-sz, 0.0f);
				pbox += pt + Point3( 0.0f, 0.0f, sz);
				pbox += pt + Point3( 0.0f, 0.0f,-sz);
				}
			}
		if (!pbox.IsEmpty()) box += pbox;
	} else {
		SimpleParticle::GetWorldBoundBox(t,inode,vpt,box);
		}
	}


//--- Rain particle -----------------------------------------------


ParamUIDesc *RainParticle::ParamDesc()
	{
	return descParamRain;
	}

int RainParticle::DescCount()
	{
	return RAINPARAMDESC_LENGH;
	}

RefTargetHandle RainParticle::Clone(RemapDir& remap) 
	{
	RainParticle* newob = new RainParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	return newob;
	}

BOOL RainParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
	{
	Point3 pt[3];
	float sz = CompParticleSize(parts.ages[i],life,parts.size);
	pt[0] = parts[i];
	pt[1] = parts[i] - parts.vels[i] * RAINSIZEFACTOR * sz;
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);
	if (GetAsyncKeyState (VK_ESCAPE)) return TRUE;
	return 0;
	}

MarkerType RainParticle::GetMarkerType() 
	{
	int type;
	
	pblock->GetValue(PB_DISPTYPE,0,type,FOREVER);	

	switch (type) {
		case 0:
			parts.SetCustomDraw(&theRainDraw);
			pblock->GetValue(PB_LIFETIME,0,theRainDraw.life,FOREVER);
			if (theRainDraw.life<=0) theRainDraw.life = 1;
			return POINT_MRKR;
		case 1:
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;			
		case 2:
			parts.SetCustomDraw(NULL);
			return PLUS_SIGN_MRKR;
		default:
			return PLUS_SIGN_MRKR;
		}
	}

// The ratio of the base of the tetrahedron to its height
#define BASEFACTOR	0.05f
#define THIRD 		(1.0f/3.0f)
#define SIXTH 		(1.0f/6.0f)
#define TWOTHIRD 	(2.0f/3.0f)
#define FIVESIXTHS 	(5.0f/6.0f)

void CacheData(ParticleSys *p0,ParticleSys *p1)
{ p1->points.SetCount(p0->points.Count());
  if (p0->points.Count()>0)
  {	for (int pc=0;pc<p0->points.Count();pc++)
		p1->points[pc]=p0->points[pc];
    p1->ages.SetCount(p0->ages.Count());
	for (pc=0;pc<p0->ages.Count();pc++)
		p1->ages[pc]=p0->ages[pc];
    p1->radius.SetCount(p0->radius.Count());
	for (pc=0;pc<p0->radius.Count();pc++)
		p1->radius[pc]=p0->radius[pc];
    p1->tension.SetCount(p0->tension.Count());
	for (pc=0;pc<p0->tension.Count();pc++)
		p1->tension[pc]=p0->tension[pc];
  }
}

float RainParticle::ParticleSize(TimeValue t,int i)
	{
	int type;
	TimeValue life;
	pblock->GetValue(PB_RENDER,t,type,FOREVER);	
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	float sz = CompParticleSize(parts.ages[i],life,parts.size);
	if (type==RENDTYPE2) return sz;
	else return Length(parts.vels[i]) * RAINSIZEFACTOR * sz;
	}

int RainParticle::ParticleCenter(TimeValue t,int i)
	{
	int type;
	pblock->GetValue(PB_RENDER,t,type,FOREVER);	
	if (type==RENDTYPE2) return PARTCENTER_CENTER;
	else return PARTCENTER_HEAD;
	}

Mesh* RainParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{
	Point3 v, v0, v1;
	int ix=0, nx=0, count, type;
	Matrix3 tm = Inverse(inode->GetObjTMAfterWSM(t));
	TimeValue life;
	float sz;

	pblock->GetValue(PB_RENDER,t,type,FOREVER);	
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	if (life<=0) life = 1;
	if (type==RENDTYPE2) return GetFacingRenderMesh(t,inode,view,needDelete);

	Mesh *pm = new Mesh;
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	if (midframe) 
	{ Update(t-offtime,inode);
	  CacheData(&parts,&lastparts);
	  Update(t,inode);
	}
	else Update(t,inode);
	count = CountLive();

	pm->setNumFaces(count*4);
	pm->setNumVerts(count*4);
	pm->setNumTVerts(count*9);
	pm->setNumTVFaces(count*4);

	for (int i=0; i<parts.Count(); i++) {
		if (!parts.Alive(i)) continue;

		// Compute this particle's size
		sz = CompParticleSize(parts.ages[i],life,parts.size);

		// v0 and v1 will former a basis for the plane the tetrahedron is in
		float len;
		v  = parts.vels[i] * RAINSIZEFACTOR * sz;
		len = Length(v) * BASEFACTOR;
		if (v!=Point3(0,1,0)) {
			v0 = Normalize(v^Point3(0,1,0))*len;
		} else {
			v0 = Point3(0.0f,0.0f,len);
			}
		v1 = Normalize(v^v0)*len;
		
		pm->verts[ix  ] = (parts[i]-v) * tm;
		pm->verts[ix+1] = (parts[i]+v0) * tm;
		pm->verts[ix+2] = (parts[i]+v1-v0) * tm;
		pm->verts[ix+3] = (parts[i]-v1-v0) * tm;

		pm->faces[ix  ].setSmGroup(1);		
		pm->faces[ix  ].setVerts(ix+2,ix+1,ix);
		pm->faces[ix  ].setMatID((MtlID)i);
		pm->faces[ix  ].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
		pm->faces[ix+1].setSmGroup(1);		
		pm->faces[ix+1].setVerts(ix+3,ix+2,ix);
		pm->faces[ix+1].setMatID((MtlID)i);
		pm->faces[ix+1].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
		pm->faces[ix+2].setSmGroup(1);		
		pm->faces[ix+2].setVerts(ix+1,ix+3,ix);
		pm->faces[ix+2].setMatID((MtlID)i);
		pm->faces[ix+2].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
		pm->faces[ix+3].setSmGroup(1);		
		pm->faces[ix+3].setVerts(ix+3,ix+1,ix+2);
		pm->faces[ix+3].setMatID((MtlID)i);
		pm->faces[ix+3].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
		
		pm->setTVert(nx  ,0.0f ,0.0f,0.0f);
		pm->setTVert(nx+1,THIRD,0.0f,0.0f);
		pm->setTVert(nx+2,SIXTH,1.0f,0.0f);
		pm->setTVert(nx+3,THIRD   ,0.0f,0.0f);
		pm->setTVert(nx+4,TWOTHIRD,0.0f,0.0f);
		pm->setTVert(nx+5,0.5f    ,1.0f,0.0f);
		pm->setTVert(nx+6,TWOTHIRD  ,0.0f,0.0f);
		pm->setTVert(nx+7,1.0f      ,0.0f,0.0f);
		pm->setTVert(nx+8,FIVESIXTHS,1.0f,0.0f);
		
		pm->tvFace[ix  ].setTVerts(nx  ,nx+1, nx+2);
		pm->tvFace[ix+1].setTVerts(nx+3,nx+4, nx+5);
		pm->tvFace[ix+2].setTVerts(nx+6,nx+7, nx+8);
		pm->tvFace[ix+3].setTVerts(nx  ,nx+1, nx+2);
		
		ix += 4;
		nx += 9;
		}

	if (midframe) { 
		CacheData(&lastparts,&parts);
		tvalid=t-offtime;
		}
	if (Parity(tm)) FlipAllMeshFaces(pm);
	mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;
	}


//--- Snow particle -----------------------------------------------

SnowParticle::SnowParticle() : GenParticle(FALSE)
	{
	pblock->SetValue(PB_VARIATION,0,2.0f);
	}

ParamUIDesc *SnowParticle::ParamDesc()
	{
	return descParamSnow;
	}

int SnowParticle::DescCount()
	{
	return SNOWPARAMDESC_LENGH;
	}

float SnowParticle::ParticleSize(TimeValue t,int i)
	{	
	TimeValue life;	
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	return CompParticleSize(parts.ages[i],life,parts.size);	
	}

int SnowParticle::ParticleCenter(TimeValue t,int i)
	{
	return PARTCENTER_CENTER;	
	}

void SnowParticle::UpdateParticles(TimeValue t,INode *node)
	{
	// Make sure the snow draw callback is up to date.
	pblock->GetValue(PB_TUMBLE,t,theSnowDraw.tumble,FOREVER);
	pblock->GetValue(PB_SCALE,t,theSnowDraw.scale,FOREVER);	
	theSnowDraw.scale /= 50.0f;
	GenParticle::UpdateParticles(t,node);
	}

RefTargetHandle SnowParticle::Clone(RemapDir& remap) 
	{
	SnowParticle* newob = new SnowParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	return newob;
	}

BOOL SnowParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
	{
	Point3 pt[3];	
	float size = CompParticleSize(parts.ages[i],life,parts.size);
	Matrix3 mat = obj->TumbleMat(i,tumble,scale);
	Point3 vx, vy, vz;

	vx = mat.GetRow(0) * size;
	vy = mat.GetRow(1) * size;
	vz = mat.GetRow(2) * size;

	pt[0] = parts[i] - vx;
	pt[1] = parts[i] + vx;
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);

	pt[0] = parts[i] - vy;
	pt[1] = parts[i] + vy;
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);

	pt[0] = parts[i] - vz;
	pt[1] = parts[i] + vz;
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);

	vx *= 0.5f;
	vy *= 0.5f;
	vz *= 0.5f;
	
	pt[0] = parts[i] - vx - vy - vz;
	pt[1] = parts[i] + vx + vy + vz;	
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);
	
	pt[0] = parts[i] + vx - vy - vz;
	pt[1] = parts[i] - vx + vy + vz;	
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);
	
	pt[0] = parts[i] - vx + vy - vz;
	pt[1] = parts[i] + vx - vy + vz;
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);

	pt[0] = parts[i] - vx - vy + vz;
	pt[1] = parts[i] + vx + vy - vz;	
	gw->polyline(2,pt,NULL,NULL,FALSE,NULL);	
	if (GetAsyncKeyState (VK_ESCAPE)) return TRUE;
	return 0;
	}

MarkerType SnowParticle::GetMarkerType() 
	{
	int type;
	pblock->GetValue(PB_DISPTYPE,0,type,FOREVER);	

	switch (type) {
		case 0: {			
			theSnowDraw.obj = this;
			pblock->GetValue(PB_LIFETIME,0,theSnowDraw.life,FOREVER);
			if (theSnowDraw.life<=0) theSnowDraw.life = 1;
			parts.SetCustomDraw(&theSnowDraw);			
			return POINT_MRKR;
			}

		case 1:
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;			
		case 2:
			parts.SetCustomDraw(NULL);
			return PLUS_SIGN_MRKR;
		default:
			return PLUS_SIGN_MRKR;
		}
	}

Matrix3 SnowParticle::TumbleMat(int index,float amount, float scale)
	{
	Matrix3 mat;
	Quat q;
	float ang[3];

	srand(int(PARTICLE_SEED) * Perm(index) + int(PARTICLE_SEED));
	
	for (int i=0; i<3; i++) {
		ang[i] = (float(2*rand())/float(RAND_MAX) - 1.0f);
		if (amount>0.0f) {
			float off = 8725.0f*i;
			ang[i] += noise3((parts[index]+Point3(off,off,off))*scale)*amount;
			}
		ang[i] *= TWOPI;
		}
	
	EulerToQuat(ang,q);
	q.MakeMatrix(mat);
	return mat;
	}

Mesh* SnowParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{
	BOOL single = FALSE;	
	float size, tumble, scale, sz;
	int type, count;
	TimeValue life;	

	pblock->GetValue(PB_DROPSIZE,t,size,FOREVER);
	pblock->GetValue(PB_TUMBLE,t,tumble,FOREVER);
	pblock->GetValue(PB_SCALE,t,scale,FOREVER);
	pblock->GetValue(PB_RENDER,t,type,FOREVER);
	pblock->GetValue(PB_LIFETIME,t,life,FOREVER);
	if (life<=0) life = 1;
	scale /= 50.0f;
	single = type==RENDTYPE2;
	if (type==RENDTYPE3) return GetFacingRenderMesh(t,inode,view,needDelete);

	Matrix3 tm = Inverse(inode->GetObjTMAfterWSM(t));
	int ix=0, nx=0, numV = single ? 3 : 6, numF = single ? 1 : 2;

	Mesh *pm = new Mesh;		
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	if (midframe) 
	{ Update(t-offtime,inode);
	  CacheData(&parts,&lastparts);
	  Update(t,inode);
	}
	else Update(t,inode);
	count = CountLive();

	if (!single) {
		pm->setNumFaces(count*2);
		pm->setNumVerts(count*6);
		pm->setNumTVerts(count*6);
		pm->setNumTVFaces(count*2);
	} else {
		pm->setNumFaces(count);
		pm->setNumVerts(count*3);
		pm->setNumTVerts(count*3);
		pm->setNumTVFaces(count);
		}

	for (int i=0; i<parts.Count(); i++) {
		if (!parts.Alive(i)) continue;
		
		// Compute this particle's size
		sz = CompParticleSize(parts.ages[i],life,size);

		for (int j=0; j<numV; j++) {
			pm->tVerts[ix+j].x = pm->verts[ix+j].x = 
				(float)cos(TWOPI*float(j)/float(numV));
			pm->tVerts[ix+j].z = pm->verts[ix+j].y = 0.0f;
			pm->tVerts[ix+j].y = pm->verts[ix+j].z = 
				(float)sin(TWOPI*float(j)/float(numV));
			pm->verts[ix+j]  = (pm->verts[ix+j]*TumbleMat(i,tumble,scale)) * sz;
			pm->verts[ix+j]  += parts[i];
			pm->tVerts[ix+j] *= 0.5f;
			pm->tVerts[ix+j] += Point3(0.5f,0.5f,0.0f);
			
			// Particles are in world space so we transform them back
			// into object space because that's what the renderer expects.
			pm->verts[ix+j] = tm * pm->verts[ix+j];
			}
		
		if (single) {
			pm->faces[nx].setSmGroup(0);
			pm->faces[nx].setVerts(ix,ix+1,ix+2);
			pm->faces[nx].setMatID((MtlID)i);
			pm->faces[nx  ].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
			pm->tvFace[nx].setTVerts(ix,ix+1,ix+2);
		} else {
			pm->faces[nx  ].setSmGroup(0);
			pm->faces[nx  ].setVerts(ix  ,ix+2,ix+4);
			pm->faces[nx  ].setMatID((MtlID)i);
			pm->faces[nx  ].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
			pm->faces[nx+1].setSmGroup(0);
			pm->faces[nx+1].setVerts(ix+1,ix+3,ix+5);
			pm->faces[nx+1].setMatID((MtlID)i);
			pm->faces[nx+1].setEdgeVisFlags(1,1,1); // RB 3/4/99: added this so snapshots would be visible
			pm->tvFace[nx  ].setTVerts(ix  ,ix+2,ix+4);
			pm->tvFace[nx+1].setTVerts(ix+1,ix+3,ix+5);
			}
		
		ix += numV;
		nx += numF;
		}
	
	if (midframe) { 
		CacheData(&lastparts,&parts);
		tvalid=t-offtime;
		}
	if (Parity(tm)) FlipAllMeshFaces(pm);
	mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prim.rc
//
#define IDS_PW_GRID                     1
#define IDD_SPHEREPARAM                 101
#define IDD_SPHEREPARAM2                101
#define IDB_SPINNER                     102
#define IDD_CYLINDERPARAM               102
#define IDD_CYLINDERPARAM2              102
#define IDC_SPINNERCUR                  103
#define IDD_BOXPARAM                    103
#define IDD_BOXPARAM2                   103
#define IDD_WAVEPARAM                   104
#define IDD_SCAMERA                     105
#define IDD_SCAMERAPARAM                105
#define IDD_LIGHT_PARAM                 106
#define IDD_CYLINDERPARAM1              107
#define IDD_DIRLIGHTPARAM               108
#define IDD_DUMMY1                      109
#define IDD_DUMMY2                      110
#define IDD_DUMMY3                      111
#define IDD_DUMMY4                      112
#define IDD_SPHEREPARAM1                113
#define IDD_DUMMY5                      114
#define IDD_DUMMY6                      115
#define IDD_FSPOTLIGHTPARAM             116
#define IDD_SPOTLIGHT                   116
#define IDD_SPLINEPARAM                 117
#define IDD_SPLINEPARAM1                117
#define IDD_NGONPARAM2                  118
#define IDD_NGONPARAM1                  119
#define IDD_DONUTPARAM2                 120
#define IDD_DONUTPARAM1                 121
#define IDD_SAMPLEPARAM                 122
#define IDD_FCAMERAPARAM                123
#define IDD_PATCHGRIDPARAM              124
#define IDD_TRIPATCHPARAM               125
#define IDD_PSPHEREPARAM1               126
#define IDD_PSPHEREPARAM2               127
#define IDD_TORUSPARAM1                 128
#define IDB_HYBRIDKEYBUTTONS            128
#define IDD_TORUSPARAM2                 129
#define IDB_MASK_HYBRIDKEYBUTTONS       129
#define IDD_MORPHPARAM                  130
#define IDD_MORPHPARAM2                 130
#define IDD_MORPHPARAM1                 131
#define IDD_FREE_SPOTLIGHT              132
#define IDD_LIGHT_SHADOW                134
#define IDD_LIGHT_SHADOW3               134
#define IDD_RECTANGLEPARAM              135
#define IDD_BOOLPARAM1                  136
#define IDD_BOOLPARAM2                  137
#define IDD_TAPEHELPER                  138
#define IDD_SPHEREPARAM3                139
#define IDD_CYLINDERPARAM3              140
#define IDD_TORUSPARAM3                 141
#define IDD_TUBEPARAM1                  142
#define IDD_TUBEPARAM2                  143
#define IDD_TUBEPARAM3                  144
#define IDD_BOXPARAM1                   145
#define IDD_BOXPARAM3                   146
#define IDD_CONEPARAM1                  147
#define IDD_CONEPARAM2                  148
#define IDD_CONEPARAM3                  149
#define IDD_HEDRAPARAM                  150
#define IDD_HELIXPARAM1                 151
#define IDD_HELIXPARAM2                 152
#define IDB_TEXT_BUTTONS                152
#define IDD_DONUTPARAM3                 153
#define IDB_TEXT_MASKBUTTONS            153
#define IDD_NGONPARAM3                  154
#define IDB_FOV                         154
#define IDD_HELIXPARAM3                 156
#define IDC_CROSS_HAIR                  156
#define IDD_RECTANGLEPARAM3             157
#define IDD_RECTANGLEPARAM2             158
#define IDB_FOVMASK                     158
#define IDD_RECTANGLEPARAM1             159
#define IDB_CI_TORUS32_MASK             159
#define IDD_CIRCLEPARAM2                160
#define IDB_CI_SPHERE16_MASK            160
#define IDD_CIRCLEPARAM1                161
#define IDB_CI_SPHERE32                 161
#define IDD_ELLIPSEPARAM3               162
#define IDB_CI_SPHERE32_MASK            162
#define IDD_ELLIPSEPARAM2               163
#define IDB_CI_TEAPOT16                 163
#define IDD_ELLIPSEPARAM1               164
#define IDB_CI_TEAPOT16_MASK            164
#define IDD_CIRCLEPARAM3                165
#define IDB_CI_TEAPOT32                 165
#define IDD_ARCPARAM3                   166
#define IDB_CI_TEAPOT32_MASK            166
#define IDD_ARCPARAM2                   167
#define IDB_CI_TORUS16                  167
#define IDD_ARCPARAM1                   168
#define IDB_CI_TORUS16_MASK             168
#define IDD_RAINPARAM                   169
#define IDB_CI_TORUS32                  169
#define IDD_STARPARAM2                  170
#define IDB_CI_SPHERE16                 170
#define IDD_STARPARAM1                  171
#define IDD_SNOWPARAM                   172
#define IDD_TEXTPARAM                   173
#define IDD_INTERPPARAMS                174
#define IDD_SPLINEPARAM2                175
#define IDD_TEAPOTPARAM1                176
#define IDD_TEAPOTPARAM2                177
#define IDD_TEAPOTPARAM3                178
#define IDD_CUBICMORPH_KEYINFO          179
#define IDD_BARYMORPH_KEYINFO           180
#define IDD_OMNI                        181
#define IDD_BONEPARAMS                  182
#define IDD_PATCHGRIDPARAM2             183
#define IDD_TRIPATCHPARAM2              184
#define IDD_PROTHELPER                  185
#define IDD_LIGHT_ATTEN                 186
#define IDD_PCAM_CUSTOM                 188
#define IDD_PCAM_STANDARD               190
#define IDD_LIGHT_SHADOW1               191
#define IDB_PUSHPIN                     192
#define IDD_GRIDPARAM3                  192
#define IDB_LOCK_ADJACENT               193
#define IDD_GRIDPARAM2                  193
#define IDD_GRIDPARAM1                  194
#define IDB_LOCK_SEPERATED              195
#define IDD_LIGHT_SHADOW2               195
#define IDD_LIGHT_EMITTER               196
#define IDD_CAMERA_DOF                  197
#define IDC_RADIUS                      1000
#define IDC_SEGMENTS                    1001
#define IDC_AMPLITUDE                   1001
#define IDC_PARAM_P                     1001
#define IDC_TI_ARCFROM                  1001
#define IDC_BOOL_BNAME                  1001
#define IDC_CREATEDIAMETER              1002
#define IDC_CYCLES                      1002
#define IDC_HEMISPHERE                  1002
#define IDC_CAPSEGMENTS                 1002
#define IDC_PARAM_Q                     1002
#define IDC_TI_ARCTO                    1002
#define IDC_CREATERADIUS                1003
#define IDC_PHASE                       1003
#define IDC_SCALE_P                     1003
#define IDC_SEGSPINNER                  1004
#define IDC_NUMNODES                    1004
#define IDC_SCALE_Q                     1004
#define IDC_RADSPINNER                  1005
#define IDC_CAPSEGSPINNER               1005
#define IDC_OBSMOOTH                    1006
#define IDC_AMPSPINNER                  1006
#define IDC_PARAM_PSPIN                 1006
#define IDC_TI_ARCFROMSPINNER           1006
#define IDC_LENGTH                      1007
#define IDC_CYCSPINNER                  1007
#define IDC_HEMISPHERESPINNER           1007
#define IDC_PARAM_QSPIN                 1007
#define IDC_TI_ARCTOSPINNER             1007
#define IDC_LENSPINNER                  1008
#define IDC_PHSSPINNER                  1008
#define IDC_SCALE_PSPIN                 1008
#define IDC_SIDES                       1009
#define IDC_NUMSPINNER                  1009
#define IDC_SCALE_QSPIN                 1009
#define IDC_POINTS                      1009
#define IDC_SCALESPINNER                1009
#define IDC_SIDESPINNER                 1010
#define IDC_HEIGHT                      1010
#define IDC_HEIGHTEDIT                  1010
#define IDC_SCALE_R                     1010
#define IDC_POINTSSPINNER               1010
#define IDC_WIDTHSPINNER                1011
#define IDC_PIESLICESPIN1               1011
#define IDC_SCALE_RSPIN                 1011
#define IDC_DISTORTSPINNER              1011
#define IDC_HEIGHTSPINNER               1012
#define IDC_PIESLICESPIN2               1012
#define IDC_DISTORT                     1012
#define IDC_FILLETSPINNER               1012
#define IDC_BROWSE                      1013
#define IDC_HSEGSPIN                    1013
#define IDC_RADSPINNER2                 1013
#define IDC_CAPSEGSPIN                  1013
#define IDC_AP_FILLETSPINNER            1013
#define IDC_OBJFILENAME                 1014
#define IDC_HSEGS                       1014
#define IDC_FOV                         1015
#define IDC_WSEGSPIN                    1015
#define IDC_AP_FILLETSPINNER2           1015
#define IDC_FOVSPINNER                  1016
#define IDC_WSEGS                       1016
#define IDC_LRED                        1017
#define IDC_LSEGSPIN                    1017
#define IDC_FOVSPINNER2                 1017
#define IDC_LREDSPINNER                 1018
#define IDC_LSEGS                       1018
#define IDC_FOV2                        1018
#define IDC_PROT_PICK_TARGET1           1018
#define IDC_SHOWCAMCONE                 1019
#define IDC_PROT_PICK_TARGET2           1019
#define IDC_RENDERSEGSPINNER            1019
#define IDC_CHECK1                      1020
#define IDC_SHOW_CONE                   1020
#define IDC_BOOL_OPTIMIZE               1020
#define IDC_SHOWHORZLINE                1020
#define IDC_SPEC_LEN                    1020
#define IDC_HEMI_RECENTER               1020
#define IDC_SLICEON                     1020
#define IDC_ARCPIE                      1020
#define IDC_HIDE_EMITTER                1020
#define IDC_TEXT_MANUAL_UPDATE          1020
#define IDC_BONES_ASSIGNIK              1020
#define IDC_LGREEN                      1021
#define IDC_BUTTON1                     1021
#define IDC_CREATE_MORPHKEY             1021
#define IDC_15MM                        1021
#define IDC_SCALE_RESET                 1021
#define IDC_REVERSE                     1021
#define IDC_BARYMORPH_100TOTAL          1021
#define IDC_BONES_ASSIGNIKROOT          1021
#define IDC_LGREENSPINNER               1022
#define IDC_BUTTON2                     1022
#define IDC_PROJ_IMAGE                  1022
#define IDC_20MM                        1022
#define IDC_DELETE_MORPHTARG            1022
#define IDC_BONES_CREATEENDEFFECTOR     1022
#define IDC_LBLUE                       1023
#define IDC_RADIO1                      1023
#define IDC_BUTTON3                     1023
#define IDC_TARG_REFERENCE              1023
#define IDC_RECT_LIGHT                  1023
#define IDC_24MM                        1023
#define IDC_BOOL_UNION                  1023
#define IDC_HEMI_SQUASH                 1023
#define IDC_SMOOTH_ALL                  1023
#define IDC_FAM_TETRA                   1023
#define IDC_HELIX_CW                    1023
#define IDC_PARTICLE_DOTS               1023
#define IDC_PART_BOTH                   1023
#define IDC_INSCRIBED                   1023
#define IDC_LBLUESPINNER                1024
#define IDC_RADIO2                      1024
#define IDC_BUTTON4                     1024
#define IDC_TARG_COPY                   1024
#define IDC_CIRCLE_LIGHT                1024
#define IDC_28MM                        1024
#define IDC_BOOL_INTERSECTION           1024
#define IDC_HEMI_CHOP                   1024
#define IDC_SMOOTH_SIDES                1024
#define IDC_FAM_OCTA                    1024
#define IDC_HELIX_CCW                   1024
#define IDC_PARTICLE_TICKS              1024
#define IDC_PART_BODY                   1024
#define IDC_CIRCUMSCRIBED               1024
#define IDC_RADIO3                      1025
#define IDC_BUTTON5                     1025
#define IDC_LHOTSIZESPINNER             1025
#define IDC_TARG_MOVE                   1025
#define IDC_35MM                        1025
#define IDC_MAP_RANGE                   1025
#define IDC_BOOL_DIFFERENCEA            1025
#define IDC_SMOOTH_NONE                 1025
#define IDC_FAM_DODEC                   1025
#define IDC_PART_LID                    1025
#define IDC_BOOL_DIFFERENCEAB           1025
#define IDC_RADIO4                      1026
#define IDC_BUTTON6                     1026
#define IDC_LHOTSIZE                    1026
#define IDC_TARG_INSTANCE               1026
#define IDC_50MM                        1026
#define IDC_BOOL_DISPRESULT             1026
#define IDC_FAM_STAR1                   1026
#define IDC_SMOOTH_STRIPES              1026
#define IDC_ATM_OPACITY                 1026
#define IDC_BUTTON7                     1027
#define IDC_LFALLOFFSPINNER             1027
#define IDC_85MM                        1027
#define IDC_BOOL_DIFFERENCEB            1027
#define IDC_BOOL_DIFFERENCEBA           1027
#define IDC_ATM_COLAMT                  1027
#define IDC_CHECK2                      1028
#define IDC_BUTTON8                     1028
#define IDC_LFALLOFF                    1028
#define IDC_135MM                       1028
#define IDC_TICKMARKS                   1028
#define IDC_BOOL_SHOWHIDDENOPS          1028
#define IDC_GENTEXTURE                  1028
#define IDC_PARTICLE_CONSTANTRATE       1028
#define IDC_BONE_AUTOLINK               1028
#define IDC_BUTTON9                     1029
#define IDC_LTDISTSPINNER               1029
#define IDC_200MM                       1029
#define IDC_BONE_COPYIKPARAMS           1029
#define IDC_BUTTON10                    1030
#define IDC_LASPECT_SPIN                1030
#define IDC_CREATE_VIEW                 1030
#define IDC_BONE_MATCHALIGNMENT         1030
#define IDC_BUTTON11                    1031
#define IDC_LASPECT                     1031
#define IDC_LIST1                       1032
#define IDC_MORPHTARG_LIST              1032
#define IDC_LBLUR_SPIN                  1032
#define IDC_BOOL_OPERANDS               1032
#define IDC_BARYMORPH_TARGLIST          1032
#define IDC_SCROLLBAR2                  1033
#define IDC_LBLUR                       1033
#define IDC_KEYTIME                     1033
#define IDC_KEYTIMESPIN                 1034
#define IDC_SCROLLBAR1                  1035
#define IDC_SCROLLBAR3                  1035
#define IDC_TCB_T                       1035
#define IDC_SCROLLBAR4                  1036
#define IDC_TCB_TSPIN                   1036
#define IDC_EDIT1                       1037
#define IDC_TEXTENTRY                   1037
#define IDC_TCB_C                       1037
#define IDC_TCB_CSPIN                   1038
#define IDC_USER1                       1039
#define IDC_PICK_MORPHTARG              1039
#define IDC_LIGHT_COLOR                 1039
#define IDC_TCB_B                       1039
#define IDC_ICORNER                     1040
#define IDC_TCB_BSPIN                   1040
#define IDC_SHADOW_COLOR                1040
#define IDC_ISMOOTH                     1041
#define IDC_BARYMORPH_PERCENT           1041
#define IDC_DCORNER                     1042
#define IDC_OBCIRCULAR                  1042
#define IDC_BARYMORPH_PERCENTSPIN       1042
#define IDC_DSMOOTH                     1043
#define IDC_RADIUS1                     1043
#define IDC_DBEZIER                     1044
#define IDC_RAD1SPINNER                 1044
#define IDC_RADIUS2                     1045
#define IDC_RAD2SPINNER                 1046
#define IDC_TORUS_ROT                   1047
#define IDC_TURNS                       1047
#define IDC_TORUS_ROTSPIN               1048
#define IDC_TORUS_TWIST                 1049
#define IDC_TURNSSPINNER                1049
#define IDC_SHOW_RANGES                 1050
#define IDC_TORUS_TWISTSPIN             1050
#define IDC_TURNSEDIT                   1050
#define IDC_BIASSPINNER                 1051
#define IDC_SHOW_RANGES1                1051
#define IDC_BIASEDIT                    1052
#define IDC_SHOW_DECAY                  1053
#define IDC_USE_ATTEN                   1062
#define IDC_START_RANGE_SPIN            1063
#define IDC_START_RANGE                 1064
#define IDC_END_RANGE_SPIN              1065
#define IDC_END_RANGE                   1066
#define IDC_LMULTSPINNER                1067
#define IDC_LMULT                       1068
#define IDC_LTDIST                      1069
#define IDC_SSTEPSSPINNER               1069
#define IDC_USE_ATTEN1                  1069
#define IDC_TDIST                       1070
#define IDC_SHAPESTEPS                  1070
#define IDC_AFFECT_DIFFUSE              1070
#define IDC_TDISTSPINNER                1071
#define IDC_AFFECT_SPECULAR             1071
#define IDC_HITHER_SPIN                 1072
#define IDC_LCONTRAST                   1072
#define IDC_DIFFSOFT                    1072
#define IDC_LVSPINNER                   1073
#define IDC_HITHER                      1073
#define IDC_LV                          1074
#define IDC_YON_SPIN                    1074
#define IDC_LSSPINNER                   1075
#define IDC_YON                         1075
#define IDC_LS                          1076
#define IDC_LHSPINNER                   1077
#define IDC_LH                          1078
#define IDC_LCONTRASTSPIN               1079
#define IDC_AMBIENT_ONLY                1080
#define IDC_OVERSHOOT                   1081
#define IDC_DECAY_EDIT                  1082
#define IDC_PROJECTOR                   1083
#define IDC_DECAY_SPIN                  1084
#define IDC_BITMAP_FIT                  1085
#define IDC_LIGHT_ON                    1086
#define IDC_PREVKEY                     1090
#define IDC_NEXTKEY                     1091
#define IDC_KEYNUM                      1092
#define IDC_TARGNAME                    1157
#define IDC_TCB_GRAPH                   1179
#define IDC_SOFTEN_DIFFUSE              1180
#define IDC_DIFFSOFTSPIN                1181
#define IDC_LCONTRASTSPIN2              1190
#define IDC_LCONTRAST2                  1191
#define IDC_ADAPTIVE                    1225
#define IDC_SC_SLICEON                  1238
#define IDC_SC_SLICE1                   1239
#define IDC_SC_SLICE1SPIN               1240
#define IDC_SC_SLICE2                   1241
#define IDC_SC_SLICE2SPIN               1242
#define IDC_PROT_TARGET1_NAME           1274
#define IDC_PROT_TARGET2_NAME           1275
#define IDC_OPTIMIZE                    1500
#define IDC_LENS                        3000
#define IDC_LENSSPINNER                 3001
#define IDC_MAP_BIAS                    3002
#define IDC_MAP_BIAS_SPIN               3003
#define IDC_MAP_SIZE                    3004
#define IDC_MAP_SIZE_SPIN               3005
#define IDC_RT_BIAS                     3006
#define IDC_RT_BIAS_SPIN                3007
#define IDC_LENGTHEDIT                  3009
#define IDC_WIDTHEDIT                   3010
#define IDC_PICK_BOOLOPERAND            3011
#define IDC_FILLET                      3011
#define IDC_SCALEEDIT                   3011
#define IDC_BOOL_RECALC                 3012
#define IDC_AP_FILLET2                  3012
#define IDC_RENDERSEGEDIT               3012
#define IDC_BOOL_EXTRACTOP              3013
#define IDC_BOOL_DISPOPS                3015
#define IDC_BOOL_UPDATERENDER           3016
#define IDC_BOOL_UPDATEMANUAL           3017
#define IDC_BOOL_UPDATEALWAYS           3018
#define IDC_BOOL_UPDATESELECT           3019
#define IDC_TI_POSX                     3019
#define IDC_TI_POSXSPIN                 3020
#define IDC_TI_POSY                     3021
#define IDC_TI_POSYSPIN                 3022
#define IDC_TI_CREATE                   3023
#define IDC_TI_POSZ                     3024
#define IDC_PIESLICE1                   3024
#define IDC_TEXTITALIC      