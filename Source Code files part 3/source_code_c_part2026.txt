onTimeout_Xbox1";
        public const string billing_createAccountTimeout = "billing_createAccountTimeout";
        public const string billing_createAccountTimeout_LiveService = "billing_createAccountTimeout_LiveService";
        public const string billing_createAccountTimeout_Xbox1 = "billing_createAccountTimeout_Xbox1";
        public const string billing_creditPaymentInstrumentExTimeout = "billing_creditPaymentInstrumentExTimeout";
        public const string billing_creditPaymentInstrumentTimeout = "billing_creditPaymentInstrumentTimeout";
        public const string billing_ctpAllowUrlOverride = "billing_ctpAllowUrlOverride";
        public const string billing_ctpconnectbilling = "billing_ctpconnectbilling";
        public const string billing_ctpJoinSubscriptionTimeoutSeconds = "billing_ctpJoinSubscriptionTimeoutSeconds";
        public const string billing_ctpMigrateAccountTimeoutSeconds = "billing_ctpMigrateAccountTimeoutSeconds";
        public const string billing_ctppurchase_roundboundarymonths = "billing_ctppurchase_roundboundarymonths";
        public const string billing_ctpPurchaseTransactionServiceTimeoutSeconds = "billing_ctpPurchaseTransactionServiceTimeoutSeconds";
        public const string billing_ctpPurchaseTransactionServiceUrl = "billing_ctpPurchaseTransactionServiceUrl";
        public const string billing_ctpTenantName = "billing_ctpTenantName";
        public const string billing_deprovisionServicesTimeout = "billing_deprovisionServicesTimeout";
        public const string billing_deprovisionServicesTimeout_LiveService = "billing_deprovisionServicesTimeout_LiveService";
        public const string billing_deprovisionServicesTimeout_Xbox1 = "billing_deprovisionServicesTimeout_Xbox1";
        public const string billing_familyGoldLimit = "billing_familyGoldLimit";
        public const string billing_getAccountIdFromAdminPUIDTimeout = "billing_getAccountIdFromAdminPUIDTimeout";
        public const string billing_getAccountIdFromAdminPUIDTimeout_LiveService = "billing_getAccountIdFromAdminPUIDTimeout_LiveService";
        public const string billing_getAccountIdFromAdminPUIDTimeout_Xbox1 = "billing_getAccountIdFromAdminPUIDTimeout_Xbox1";
        public const string billing_getAccountInfoTimeout = "billing_getAccountInfoTimeout";
        public const string billing_getAccountInfoTimeout_LiveService = "billing_getAccountInfoTimeout_LiveService";
        public const string billing_getAccountInfoTimeout_Xbox1 = "billing_getAccountInfoTimeout_Xbox1";
        public const string billing_getCommentsTimeout = "billing_getCommentsTimeout";
        public const string billing_getCommentsTimeout_LiveService = "billing_getCommentsTimeout_LiveService";
        public const string billing_getCommentsTimeout_Xbox1 = "billing_getCommentsTimeout_Xbox1";
        public const string billing_getEligibleOfferingsTimeout = "billing_getEligibleOfferingsTimeout";
        public const string billing_getEligibleOfferingsTimeout_LiveService = "billing_getEligibleOfferingsTimeout_LiveService";
        public const string billing_getEligibleOfferingsTimeout_Xbox1 = "billing_getEligibleOfferingsTimeout_Xbox1";
        public const string billing_getKeyTimeout = "billing_getKeyTimeout";
        public const string billing_getKeyTimeout_LiveService = "billing_getKeyTimeout_LiveService";
        public const string billing_getKeyTimeout_Xbox1 = "billing_getKeyTimeout_Xbox1";
        public const string billing_getPartnerConfigurationTimeout = "billing_getPartnerConfigurationTimeout";
        public const string billing_getPartnerConfigurationTimeout_LiveService = "billing_getPartnerConfigurationTimeout_LiveService";
        public const string billing_getPartnerConfigurationTimeout_Xbox1 = "billing_getPartnerConfigurationTimeout_Xbox1";
        public const string billing_getPaymentInstrumentsExTimeout = "billing_getPaymentInstrumentsExTimeout";
        public const string billing_getPaymentInstrumentsExTimeout_LiveService = "billing_getPaymentInstrumentsExTimeout_LiveService";
        public const string billing_getPaymentInstrumentsExTimeout_Xbox1 = "billing_getPaymentInstrumentsExTimeout_Xbox1";
        public const string billing_getPaymentInstrumentsTimeout = "billing_getPaymentInstrumentsTimeout";
        public const string billing_getPaymentInstrumentsTimeout_LiveService = "billing_getPaymentInstrumentsTimeout_LiveService";
        public const string billing_getPaymentInstrumentsTimeout_Xbox1 = "billing_getPaymentInstrumentsTimeout_Xbox1";
        public const string billing_getPermitsForObjectIdTimeout = "billing_getPermitsForObjectIdTimeout";
        public const string billing_getPermitsForObjectIdTimeout_LiveService = "billing_getPermitsForObjectIdTimeout_LiveService";
        public const string billing_getPermitsForObjectIdTimeout_Xbox1 = "billing_getPermitsForObjectIdTimeout_Xbox1";
        public const string billing_getSubscriptionStatusTimeout = "billing_getSubscriptionStatusTimeout";
        public const string billing_getSubscriptionStatusTimeout_LiveService = "billing_getSubscriptionStatusTimeout_LiveService";
        public const string billing_getSubscriptionStatusTimeout_Xbox1 = "billing_getSubscriptionStatusTimeout_Xbox1";
        public const string billing_getSubscriptionsTimeout = "billing_getSubscriptionsTimeout";
        public const string billing_getSubscriptionsTimeout_LiveService = "billing_getSubscriptionsTimeout_LiveService";
        public const string billing_getSubscriptionsTimeout_Xbox1 = "billing_getSubscriptionsTimeout_Xbox1";
        public const string billing_getTokenInfoExTimeout = "billing_getTokenInfoExTimeout";
        public const string billing_getTokenInfoExTimeout_LiveService = "billing_getTokenInfoExTimeout_LiveService";
        public const string billing_getTokenInfoExTimeout_Xbox1 = "billing_getTokenInfoExTimeout_Xbox1";
        public const string billing_initializeCTPWrapper = "billing_initializeCTPWrapper";
        public const string billing_loadTokenInstanceTimeout = "billing_loadTokenInstanceTimeout";
        public const string billing_loadTokenInstanceTimeout_LiveService = "billing_loadTokenInstanceTimeout_LiveService";
        public const string billing_loadTokenInstanceTimeout_Xbox1 = "billing_loadTokenInstanceTimeout_Xbox1";
        public const string billing_maxEditorialPurchasesAsZeroPointsPerMinute = "billing_maxEditorialPurchasesAsZeroPointsPerMinute";
        public const string billing_maxTrialCount = "billing_maxTrialCount";
        public const string billing_migrateOfferTimeout = "billing_migrateOfferTimeout";
        public const string billing_migrateOfferTimeout_LiveService = "billing_migrateOfferTimeout_LiveService";
        public const string billing_migrateOfferTimeout_Xbox1 = "billing_migrateOfferTimeout_Xbox1";
        public const string billing_migrationOfferId = "billing_migrationOfferId";
        public const string billing_newContentWindow = "billing_newContentWindow";
        public const string billing_offsetOrderCommentInfoCommentCode = "billing_offsetOrderCommentInfoCommentCode";
        public const string billing_offsetOrderFinancialReportingCode = "billing_offsetOrderFinancialReportingCode";
        public const string billing_offsetOrderTimeout = "billing_offsetOrderTimeout";
        public const string billing_offsetOrderTimeout_LiveService = "billing_offsetOrderTimeout_LiveService";
        public const string billing_offsetOrderTimeout_Xbox1 = "billing_offsetOrderTimeout_Xbox1";
        public const string billing_provisionServicesTimeout = "billing_provisionServicesTimeout";
        public const string billing_provisionServicesTimeout_LiveService = "billing_provisionServicesTimeout_LiveService";
        public const string billing_provisionServicesTimeout_Xbox1 = "billing_provisionServicesTimeout_Xbox1";
        public const string billing_proxy = "billing_proxy";
        public const string billing_pumpUserBillingInfoQueue = "billing_pumpUserBillingInfoQueue";
        public const string billing_pumpUserBillingInfoQueueInterval = "billing_pumpUserBillingInfoQueueInterval";
        public const string billing_purchaseItemTimeout = "billing_purchaseItemTimeout";
        public const string billing_purchaseItemTimeout_LiveService = "billing_purchaseItemTimeout_LiveService";
        public const string billing_purchaseItemTimeout_Xbox1 = "billing_purchaseItemTimeout_Xbox1";
        public const string billing_purchaseOfferingExTimeout = "billing_purchaseOfferingExTimeout";
        public const string billing_purchaseOfferingExTimeout_LiveService = "billing_purchaseOfferingExTimeout_LiveService";
        public const string billing_purchaseOfferingExTimeout_Xbox1 = "billing_purchaseOfferingExTimeout_Xbox1";
        public const string billing_purchaseOfferingTimeout = "billing_purchaseOfferingTimeout";
        public const string billing_purchaseOfferingTimeout_LiveService = "billing_purchaseOfferingTimeout_LiveService";
        public const string billing_purchaseOfferingTimeout_Xbox1 = "billing_purchaseOfferingTimeout_Xbox1";
        public const string billing_queueUserBillingInfo = "billing_queueUserBillingInfo";
        public const string billing_reinstateSubscriptionTimeout = "billing_reinstateSubscriptionTimeout";
        public const string billing_reinstateSubscriptionTimeout_LiveService = "billing_reinstateSubscriptionTimeout_LiveService";
        public const string billing_reinstateSubscriptionTimeout_Xbox1 = "billing_reinstateSubscriptionTimeout_Xbox1";
        public const string billing_removePaymentInstrumentTimeout = "billing_removePaymentInstrumentTimeout";
        public const string billing_removePaymentInstrumentTimeout_LiveService = "billing_removePaymentInstrumentTimeout_LiveService";
        public const string billing_removePaymentInstrumentTimeout_Xbox1 = "billing_removePaymentInstrumentTimeout_Xbox1";
        public const string billing_removeRoleAssignmentTimeout = "billing_removeRoleAssignmentTimeout";
        public const string billing_removeRoleAssignmentTimeout_LiveService = "billing_removeRoleAssignmentTimeout_LiveService";
        public const string billing_removeRoleAssignmentTimeout_Xbox1 = "billing_removeRoleAssignmentTimeout_Xbox1";
        public const string billing_removeViolationTimeout = "billing_removeViolationTimeout";
        public const string billing_removeViolationTimeout_LiveService = "billing_removeViolationTimeout_LiveService";
        public const string billing_removeViolationTimeout_Xbox1 = "billing_removeViolationTimeout_Xbox1";
        public const string billing_scsSourcePartnerId = "billing_scsSourcePartnerId";
        public const string billing_setPartnerConfigurationTimeout = "billing_setPartnerConfigurationTimeout";
        public const string billing_setPartnerConfigurationTimeout_LiveService = "billing_setPartnerConfigurationTimeout_LiveService";
        public const string billing_setPartnerConfigurationTimeout_Xbox1 = "billing_setPartnerConfigurationTimeout_Xbox1";
        public const string billing_settleBalanceTimeout = "billing_settleBalanceTimeout";
        public const string billing_settleBalanceTimeout_LiveService = "billing_settleBalanceTimeout_LiveService";
        public const string billing_settleBalanceTimeout_Xbox1 = "billing_settleBalanceTimeout_Xbox1";
        public const string billing_stopPaymentsTimeout = "billing_stopPaymentsTimeout";
        public const string billing_submitOrderTimeout = "billing_submitOrderTimeout";
        public const string billing_submitOrderTimeout_LiveService = "billing_submitOrderTimeout_LiveService";
        public const string billing_submitOrderTimeout_Xbox1 = "billing_submitOrderTimeout_Xbox1";
        public const string billing_switchPaymentInstrumentsTimeout = "billing_switchPaymentInstrumentsTimeout";
        public const string billing_switchPaymentInstrumentsTimeout_LiveService = "billing_switchPaymentInstrumentsTimeout_LiveService";
        public const string billing_switchPaymentInstrumentsTimeout_Xbox1 = "billing_switchPaymentInstrumentsTimeout_Xbox1";
        public const string billing_testConnectionTimeout = "billing_testConnectionTimeout";
        public const string billing_testConnectionTimeout_LiveService = "billing_testConnectionTimeout_LiveService";
        public const string billing_testConnectionTimeout_Xbox1 = "billing_testConnectionTimeout_Xbox1";
        public const string billing_timeout = "billing_timeout";
        public const string billing_timeoutBlockInterval = "billing_timeoutBlockInterval";
        public const string billing_transferBalanceTimeout = "billing_transferBalanceTimeout";
        public const string billing_transferBalanceTimeout_LiveService = "billing_transferBalanceTimeout_LiveService";
        public const string billing_transferBalanceTimeout_Xbox1 = "billing_transferBalanceTimeout_Xbox1";
        public const string billing_updateAccountInfoTimeout = "billing_updateAccountInfoTimeout";
        public const string billing_updateAccountInfoTimeout_LiveService = "billing_updateAccountInfoTimeout_LiveService";
        public const string billing_updateAccountInfoTimeout_Xbox1 = "billing_updateAccountInfoTimeout_Xbox1";
        public const string billing_updatePaymentInstrumentInfoTimeout = "billing_updatePaymentInstrumentInfoTimeout";
        public const string billing_updatePaymentInstrumentInfoTimeout_LiveService = "billing_updatePaymentInstrumentInfoTimeout_LiveService";
        public const string billing_updatePaymentInstrumentInfoTimeout_Xbox1 = "billing_updatePaymentInstrumentInfoTimeout_Xbox1";
        public const string billing_updateSubscriptionInfoTimeout = "billing_updateSubscriptionInfoTimeout";
        public const string billing_updateSubscriptionInfoTimeout_LiveService = "billing_updateSubscriptionInfoTimeout_LiveService";
        public const string billing_updateSubscriptionInfoTimeout_Xbox1 = "billing_updateSubscriptionInfoTimeout_Xbox1";
        public const string billing_useCatalogSubscriptionOffers = "billing_useCatalogSubscriptionOffers";
        public const string billing_validateProvisioningDataTimeout = "billing_validateProvisioningDataTimeout";
        public const string billing_validateProvisioningDataTimeout_LiveService = "billing_validateProvisioningDataTimeout_LiveService";
        public const string billing_validateProvisioningDataTimeout_Xbox1 = "billing_validateProvisioningDataTimeout_Xbox1";
        public const string casvc_genericSslIssuerName = "casvc_genericSslIssuerName";
        public const string casvc_oscarIssuerName = "casvc_oscarIssuerName";
        public const string catalog_activeFECatalogDBSearchVirtualInterface = "catalog_activeFECatalogDBSearchVirtualInterface";
        public const string catalog_activeFECatalogDBZuneVirtualInterface = "catalog_activeFECatalogDBZuneVirtualInterface";
        public const string catalog_appMediaTypes = "catalog_appMediaTypes";
        public const string catalog_consumableMediaTypes = "catalog_consumableMediaTypes";
        public const string catalog_editorial_ips0 = "catalog_editorial_ips0";
        public const string catalog_editorial_ips1 = "catalog_editorial_ips1";
        public const string catalog_editorial_ips2 = "catalog_editorial_ips2";
        public const string catalog_editorial_priv0 = "catalog_editorial_priv0";
        public const string catalog_editorial_priv1 = "catalog_editorial_priv1";
        public const string catalog_editorial_priv2 = "catalog_editorial_priv2";
        public const string catalog_editorial_time0 = "catalog_editorial_time0";
        public const string catalog_editorial_time1 = "catalog_editorial_time1";
        public const string catalog_editorial_time2 = "catalog_editorial_time2";
        public const string catalog_gameMediaTypes = "catalog_gameMediaTypes";
        public const string catalog_musicMediaTypes = "catalog_musicMediaTypes";
        public const string catalog_pointsBundleMediaTypes = "catalog_pointsBundleMediaTypes";
        public const string catalog_repurchasableMediaTypes = "catalog_repurchasableMediaTypes";
        public const string catalog_subscriptionMediaTypes = "catalog_subscriptionMediaTypes";
        public const string catalog_videoMediaTypes = "catalog_videoMediaTypes";
        public const string catalogwatcher_azure_connection_string = "catalogwatcher_azure_connection_string";
        public const string catalogwatcher_azure_connection_string_speech = "catalogwatcher_azure_connection_string_speech";
        public const string catalogwatcher_azure_feed_prefix = "catalogwatcher_azure_feed_prefix";
        public const string catalogwatcher_azure_feed_prefix_speech = "catalogwatcher_azure_feed_prefix_speech";
        public const string catalogwatcher_azure_feed_suffix = "catalogwatcher_azure_feed_suffix";
        public const string catalogwatcher_azure_feed_suffix_speech = "catalogwatcher_azure_feed_suffix_speech";
        public const string catalogwatcher_azure_storage_blob_format_date_part = "catalogwatcher_azure_storage_blob_format_date_part";
        public const string catalogwatcher_azure_storage_blob_format_delta = "catalogwatcher_azure_storage_blob_format_delta";
        public const string catalogwatcher_azure_storage_blob_format_delta_speech = "catalogwatcher_azure_storage_blob_format_delta_speech";
        public const string catalogwatcher_azure_storage_blob_format_full = "catalogwatcher_azure_storage_blob_format_full";
        public const string catalogwatcher_azure_storage_blob_format_full_speech = "catalogwatcher_azure_storage_blob_format_full_speech";
        public const string catalogwatcher_azure_storage_container = "catalogwatcher_azure_storage_container";
        public const string catalogwatcher_azure_storage_container_speech = "catalogwatcher_azure_storage_container_speech";
        public const string catalogwatcher_azure_storage_max_documents_per_batch = "catalogwatcher_azure_storage_max_documents_per_batch";
        public const string catalogwatcher_azure_storage_max_documents_per_batch_speech = "catalogwatcher_azure_storage_max_documents_per_batch_speech";
        public const string catalogwatcher_commands_timeout_in_secs = "catalogwatcher_commands_timeout_in_secs";
        public const string catalogwatcher_extractor_timeout_in_secs = "catalogwatcher_extractor_timeout_in_secs";
        public const string catalogwatcher_fast_esp_collection_name = "catalogwatcher_fast_esp_collection_name";
        public const string catalogwatcher_fast_esp_ingestion_port = "catalogwatcher_fast_esp_ingestion_port";
        public const string catalogwatcher_fast_esp_max_document_size = "catalogwatcher_fast_esp_max_document_size";
        public const string catalogwatcher_fast_esp_max_documents_per_batch = "catalogwatcher_fast_esp_max_documents_per_batch";
        public const string catalogwatcher_fast_esp_virtual_collection_name = "catalogwatcher_fast_esp_virtual_collection_name";
        public const string catalogwatcher_fast_wait_for_indexing = "catalogwatcher_fast_wait_for_indexing";
        public const string catalogwatcher_media_extractor_batch_size = "catalogwatcher_media_extractor_batch_size";
        public const string catalogwatcher_media_extractor_version = "catalogwatcher_media_extractor_version";
        public const string catalogwatcher_perform_and_log_validation_on_error = "catalogwatcher_perform_and_log_validation_on_error";
        public const string catalogwatcher_producer_consumer_media_max_queue_size = "catalogwatcher_producer_consumer_media_max_queue_size";
        public const string catalogwatcher_producer_consumer_speech_max_queue_size = "catalogwatcher_producer_consumer_speech_max_queue_size";
        public const string catalogwatcher_producer_consumer_video_max_queue_size = "catalogwatcher_producer_consumer_video_max_queue_size";
        public const string catalogwatcher_speech_extractor_batch_size = "catalogwatcher_speech_extractor_batch_size";
        public const string catalogwatcher_speech_extractor_timeout_in_secs = "catalogwatcher_speech_extractor_timeout_in_secs";
        public const string catalogwatcher_speech_extractor_version = "catalogwatcher_speech_extractor_version";
        public const string catalogwatcher_video_document_builder_firstpartyprovider = "catalogwatcher_video_document_builder_firstpartyprovider";
        public const string catalogwatcher_video_extractor_batch_size = "catalogwatcher_video_extractor_batch_size";
        public const string catalogwatcher_video_extractor_timeout_in_secs = "catalogwatcher_video_extractor_timeout_in_secs";
        public const string clean_clip_delete_window_minute = "clean_clip_delete_window_minute";
        public const string cleanser_clientDeadSec = "cleanser_clientDeadSec";
        public const string cleanser_EtxEventTarget = "cleanser_EtxEventTarget";
        public const string cleanser_fdbQueueMaxFreeEntriesCount = "cleanser_fdbQueueMaxFreeEntriesCount";
        public const string cleanser_fdbReconnectIntervalSec = "cleanser_fdbReconnectIntervalSec";
        public const string cleanser_fdbUpdateIntervalSec = "cleanser_fdbUpdateIntervalSec";
        public const string cleanser_log_target = "cleanser_log_target";
        public const string cleanser_maxQueueLength = "cleanser_maxQueueLength";
        public const string cleanser_maxTcpConnections = "cleanser_maxTcpConnections";
        public const string cleanser_watchDogTimerIntervalSec = "cleanser_watchDogTimerIntervalSec";
        public const string cleanser_workerThreadsPerProcessor = "cleanser_workerThreadsPerProcessor";
        public const string cleanser_XomFileTarget = "cleanser_XomFileTarget";
        public const string community_ownerNotifyCacheExpirySeconds = "community_ownerNotifyCacheExpirySeconds";
        public const string compPlugins_allowClientResultsSubmissions = "compPlugins_allowClientResultsSubmissions";
        public const string compPlugins_allowTimeAdjustment = "compPlugins_allowTimeAdjustment";
        public const string config_cacheRefreshInterval = "config_cacheRefreshInterval";
        public const string config_loadTitleConnectionTimeoutSeconds = "config_loadTitleConnectionTimeoutSeconds";
        public const string config_minEventInterval = "config_minEventInterval";
        public const string cron_deleteCompletedJobs = "cron_deleteCompletedJobs";
        public const string cron_jobCheckInterval = "cron_jobCheckInterval";
        public const string cron_load_job_max_sleep_time_milliseconds = "cron_load_job_max_sleep_time_milliseconds";
        public const string cron_requestThreads = "cron_requestThreads";
        public const string cron_retryInterval = "cron_retryInterval";
        public const string crux_allowTestAddPoints = "crux_allowTestAddPoints";
        public const string crux_allowTestCreateAccount = "crux_allowTestCreateAccount";
        public const string crux_MusicNetAESKeyType = "crux_MusicNetAESKeyType";
        public const string crux_MusicNetAESKeyVer = "crux_MusicNetAESKeyVer";
        public const string crux_MusicNetTokenMagicString = "crux_MusicNetTokenMagicString";
        public const string crux_MusicNetTokenSaltLen = "crux_MusicNetTokenSaltLen";
        public const string crux_passportSiteAddress = "crux_passportSiteAddress";
        public const string crux_useMusicNetForProvisioning = "crux_useMusicNetForProvisioning";
        public const string crux_VODLicenseWindowInMinutes = "crux_VODLicenseWindowInMinutes";
        public const string crypto_serviceKeyType = "crypto_serviceKeyType";
        public const string crypto_serviceKeyVersion = "crypto_serviceKeyVersion";
        public const string CTPPurchase_fastFailMaxThreshold = "CTPPurchase_fastFailMaxThreshold";
        public const string CTPPurchase_fastFailMinThreshold = "CTPPurchase_fastFailMinThreshold";
        public const string CTPPurchase_fastFailThrottling = "CTPPurchase_fastFailThrottling";
        public const string CTPPurchase_fastFailWindow = "CTPPurchase_fastFailWindow";
        public const string dmp_addPromotionalBalanceMaxAttempts = "dmp_addPromotionalBalanceMaxAttempts";
        public const string dmp_addPromotionalBalanceTimeoutSeconds = "dmp_addPromotionalBalanceTimeoutSeconds";
        public const string dmp_allowUrlOverride = "dmp_allowUrlOverride";
        public const string dmp_auditEnabled = "dmp_auditEnabled";
        public const string dmp_autoRegisterUsers = "dmp_autoRegisterUsers";
        public const string dmp_blacklistBlockIntervalSeconds = "dmp_blacklistBlockIntervalSeconds";
        public const string dmp_blacklistTimeoutThresholdCount = "dmp_blacklistTimeoutThresholdCount";
        public const string dmp_blacklistTimeoutTimespanSeconds = "dmp_blacklistTimeoutTimespanSeconds";
        public const string dmp_cancelPurchaseItemMaxAttempts = "dmp_cancelPurchaseItemMaxAttempts";
        public const string dmp_cancelPurchaseItemTimeoutSeconds = "dmp_cancelPurchaseItemTimeoutSeconds";
        public const string dmp_clientCertSubject = "dmp_clientCertSubject";
        public const string Dmp_fastFailMaxThreshold = "Dmp_fastFailMaxThreshold";
        public const string Dmp_fastFailMinThreshold = "Dmp_fastFailMinThreshold";
        public const string Dmp_fastFailWindow = "Dmp_fastFailWindow";
        public const string dmp_getBalanceDetailsMaxAttempts = "dmp_getBalanceDetailsMaxAttempts";
        public const string dmp_getBalanceDetailsTimeoutSeconds = "dmp_getBalanceDetailsTimeoutSeconds";
        public const string dmp_getBalanceMaxAttempts = "dmp_getBalanceMaxAttempts";
        public const string dmp_getBalanceTimeoutSeconds = "dmp_getBalanceTimeoutSeconds";
        public const string dmp_maxAcquisitionTitleLength = "dmp_maxAcquisitionTitleLength";
        public const string dmp_maxItemCategoryLength = "dmp_maxItemCategoryLength";
        public const string dmp_maxItemTitleLength = "dmp_maxItemTitleLength";
        public const string dmp_maxPointsBalance = "dmp_maxPointsBalance";
        public const string dmp_pumpPurchasesQueue = "dmp_pumpPurchasesQueue";
        public const string dmp_pumpRewardsQueue = "dmp_pumpRewardsQueue";
        public const string dmp_purchaseItemMaxAttempts = "dmp_purchaseItemMaxAttempts";
        public const string dmp_purchaseItemTimeoutSeconds = "dmp_purchaseItemTimeoutSeconds";
        public const string dmp_purchaseTransactionConsiderFailedSeconds = "dmp_purchaseTransactionConsiderFailedSeconds";
        public const string dmp_purchaseTransactionExpiredSeconds = "dmp_purchaseTransactionExpiredSeconds";
        public const string dmp_queuePumpIntervalSeconds = "dmp_queuePumpIntervalSeconds";
        public const string dmp_registerUserMaxAttempts = "dmp_registerUserMaxAttempts";
        public const string dmp_registerUserTimeoutSeconds = "dmp_registerUserTimeoutSeconds";
        public const string dmp_rewardTransactionExpiredSeconds = "dmp_rewardTransactionExpiredSeconds";
        public const string dmp_tenantID = "dmp_tenantID";
        public const string dmp_transactionUrl = "dmp_transactionUrl";
        public const string dmp_transferBalanceMaxAttempts = "dmp_transferBalanceMaxAttempts";
        public const string dmp_transferBalanceTimeoutSeconds = "dmp_transferBalanceTimeoutSeconds";
        public const string dmp_transferPointsTimeoutSeconds = "dmp_transferPointsTimeoutSeconds";
        public const string DmpUps_fastFailMaxThreshold = "DmpUps_fastFailMaxThreshold";
        public const string DmpUps_fastFailMinThreshold = "DmpUps_fastFailMinThreshold";
        public const string DmpUps_fastFailWindow = "DmpUps_fastFailWindow";
        public const string download_contentDirectory = "download_contentDirectory";
        public const string etx_default_header_version = "etx_default_header_version";
        public const string eventsink_excludeApps = "eventsink_excludeApps";
        public const string fastEsp_allow_debug_xslt = "fastEsp_allow_debug_xslt";
        public const string fastEsp_persist_connection_in_secs = "fastEsp_persist_connection_in_secs";
        public const string fastEsp_use_result_views = "fastEsp_use_result_views";
        public const string fastfail_bucketCount = "fastfail_bucketCount";
        public const string fastfail_disableThrottling = "fastfail_disableThrottling";
        public const string feapp_completionPortThreads = "feapp_completionPortThreads";
        public const string feapp_workerThreads = "feapp_workerThreads";
        public const string feedback_coeffBias = "feedback_coeffBias";
        public const string feedback_coeffFudgeFactor = "feedback_coeffFudgeFactor";
        public const string feedback_coeffNegativeReview = "feedback_coeffNegativeReview";
        public const string feedback_coeffPositiveReview = "feedback_coeffPositiveReview";
        public const string feedback_coeffRange = "feedback_coeffRange";
        public const string feedback_coeffSlope = "feedback_coeffSlope";
        public const string feedback_maxComplaintType = "feedback_maxComplaintType";
        public const string feedback_maxFeedbackTypes = "feedback_maxFeedbackTypes";
        public const string feedback_maxReviewType = "feedback_maxReviewType";
        public const string feedback_minFeedbackServiceType = "feedback_minFeedbackServiceType";
        public const string feedback_ratingDecayFactor = "feedback_ratingDecayFactor";
        public const string feedback_ratingDecayFloor = "feedback_ratingDecayFloor";
        public const string feedback_reviewIgnoreThreshold = "feedback_reviewIgnoreThreshold";
        public const string finbus_certificateSubject = "finbus_certificateSubject";
        public const string finbus_clientPartnerId = "finbus_clientPartnerId";
        public const string finbus_closeTimeout = "finbus_closeTimeout";
        public const string finbus_endpointAddress = "finbus_endpointAddress";
        public const string finbus_fastFailMaxThreshold = "finbus_fastFailMaxThreshold";
        public const string finbus_fastFailMinThreshold = "finbus_fastFailMinThreshold";
        public const string finbus_fastFailWindow = "finbus_fastFailWindow";
        public const string finbus_getPendingItemsMaxItems = "finbus_getPendingItemsMaxItems";
        public const string finbus_ignoreSslPolicyErrors = "finbus_ignoreSslPolicyErrors";
        public const string finbus_maxActiveRequests = "finbus_maxActiveRequests";
        public const string finbus_maxBufferPoolSize = "finbus_maxBufferPoolSize";
        public const string finbus_maxBufferSize = "finbus_maxBufferSize";
        public const string finbus_maxConnections = "finbus_maxConnections";
        public const string finbus_maxReceivedMessageSize = "finbus_maxReceivedMessageSize";
        public const string finbus_openTimeout = "finbus_openTimeout";
        public const string finbus_pumpQueue = "finbus_pumpQueue";
        public const string finbus_queuePumpIntervalSeconds = "finbus_queuePumpIntervalSeconds";
        public const string finbus_receiveTimeout = "finbus_receiveTimeout";
        public const string finbus_sendTimeout = "finbus_sendTimeout";
        public const string finbus_throttleWaitMilliseconds = "finbus_throttleWaitMilliseconds";
        public const string finbus_transactionConsiderFailureSeconds = "finbus_transactionConsiderFailureSeconds";
        public const string finbus_transactionExpiredSeconds = "finbus_transactionExpiredSeconds";
        public const string fse_bookmarkDaysFloor = "fse_bookmarkDaysFloor";
        public const string fse_bookmarkDaysThreshold = "fse_bookmarkDaysThreshold";
        public const string fse_bookmarkHoursFloor = "fse_bookmarkHoursFloor";
        public const string fse_bookmarkHoursThreshold = "fse_bookmarkHoursThreshold";
        public const string fse_bookmarkMinutesFloor = "fse_bookmarkMinutesFloor";
        public const string fse_bookmarkMinutesThreshold = "fse_bookmarkMinutesThreshold";
        public const string fse_configChange = "fse_configChange";
        public const string fse_reservationSeconds = "fse_reservationSeconds";
        public const string fse_reservationWaitSeconds = "fse_reservationWaitSeconds";
        public const string fse_reservationWaitSecondsMaximum = "fse_reservationWaitSecondsMaximum";
        public const string geofencing_allowAccessOnGeoInfoExceptions = "geofencing_allowAccessOnGeoInfoExceptions";
        public const string geofencing_allowAccessOnGeoInfoNulls = "geofencing_allowAccessOnGeoInfoNulls";
        public const string geofencing_maximumDaysBetweenGeoDbUpdate = "geofencing_maximumDaysBetweenGeoDbUpdate";
        public const string geofencing_offerGeoFencingEnabled = "geofencing_offerGeoFencingEnabled";
        public const string geofencing_pathToGeoDb = "geofencing_pathToGeoDb";
        public const string geofencing_videoGeoFencingEnabled = "geofencing_videoGeoFencingEnabled";
        public const string global_buildVersion = "global_buildVersion";
        public const string global_enableTestApis = "global_enableTestApis";
        public const string global_protocolVersion = "global_protocolVersion";
        public const string healthcheck_executionPeriodInSeconds = "healthcheck_executionPeriodInSeconds";
        public const string kdcsvc_askdc_checkForDos = "kdcsvc_askdc_checkForDos";
        public const string kdcsvc_askdc_DoS_cacheTimeMillis = "kdcsvc_askdc_DoS_cacheTimeMillis";
        public const string kdcsvc_askdc_DoS_numEntries = "kdcsvc_askdc_DoS_numEntries";
        public const string kdcsvc_askdc_DoS_tooSoonTimeMillis = "kdcsvc_askdc_DoS_tooSoonTimeMillis";
        public const string kdcsvc_askdc_DoS2_blockingTime = "kdcsvc_askdc_DoS2_blockingTime";
        public const string kdcsvc_askdc_DoS2_cacheSize = "kdcsvc_askdc_DoS2_cacheSize";
        public const string kdcsvc_askdc_DoS2_enabled = "kdcsvc_askdc_DoS2_enabled";
        public const string kdcsvc_askdc_DoS2_interval = "kdcsvc_askdc_DoS2_interval";
        public const string kdcsvc_askdc_DoS2_maxRequests = "kdcsvc_askdc_DoS2_maxRequests";
        public const string kdcsvc_askdc_echo_enabled = "kdcsvc_askdc_echo_enabled";
        public const string kdcsvc_askdc_echo_lifetimeInSeconds = "kdcsvc_askdc_echo_lifetimeInSeconds";
        public const string kdcsvc_askdc_keyVersion = "kdcsvc_askdc_keyVersion";
        public const string kdcsvc_askdc_machine_allowLegacyKey = "kdcsvc_askdc_machine_allowLegacyKey";
        public const string kdcsvc_askdc_timeSkewSeconds = "kdcsvc_askdc_timeSkewSeconds";
        public const string kdcsvc_core_ATQThreads = "kdcsvc_core_ATQThreads";
        public const string kdcsvc_core_ATQThreadsPerProc = "kdcsvc_core_ATQThreadsPerProc";
        public const string kdcsvc_core_Rps_lifetimeInSeconds = "kdcsvc_core_Rps_lifetimeInSeconds";
        public const string kdcsvc_core_Rps_roamingProfileSite = "kdcsvc_core_Rps_roamingProfileSite";
        public const string kdcsvc_managed_command_timeout = "kdcsvc_managed_command_timeout";
        public const string kdcsvc_xkdc_allowUnknownVersion = "kdcsvc_xkdc_allowUnknownVersion";
        public const string kdcsvc_xkdc_cacheLifeTimeInSeconds = "kdcsvc_xkdc_cacheLifeTimeInSeconds";
        public const string kdcsvc_xkdc_cacheTableSize = "kdcsvc_xkdc_cacheTableSize";
        public const string kdcsvc_xkdc_DoS_checkForDos = "kdcsvc_xkdc_DoS_checkForDos";
        public const string kdcsvc_xkdc_DoS_numEntries = "kdcsvc_xkdc_DoS_numEntries";
        public const string kdcsvc_xkdc_DoS2_blockingTime = "kdcsvc_xkdc_DoS2_blockingTime";
        public const string kdcsvc_xkdc_DoS2_cacheSize = "kdcsvc_xkdc_DoS2_cacheSize";
        public const string kdcsvc_xkdc_DoS2_enabled = "kdcsvc_xkdc_DoS2_enabled";
        public const string kdcsvc_xkdc_DoS2_interval = "kdcsvc_xkdc_DoS2_interval";
        public const string kdcsvc_xkdc_DoS2_maxRequests = "kdcsvc_xkdc_DoS2_maxRequests";
        public const string kdcsvc_xkdc_enableUserMachineTrust = "kdcsvc_xkdc_enableUserMachineTrust";
        public const string kdcsvc_xkdc_enforceClientVersion = "kdcsvc_xkdc_enforceClientVersion";
        public const string kdcsvc_xkdc_hashTableSize = "kdcsvc_xkdc_hashTableSize";
        public const string kdcsvc_xkdc_ignoreDuplicateRequests = "kdcsvc_xkdc_ignoreDuplicateRequests";
        public const string kdcsvc_xkdc_RequestCache_enabled = "kdcsvc_xkdc_RequestCache_enabled";
        public const string kdcsvc_xkdc_RequestCache_lifetimeInSeconds = "kdcsvc_xkdc_RequestCache_lifetimeInSeconds";
        public const string kdcsvc_xkdc_timeSkewSeconds = "kdcsvc_xkdc_timeSkewSeconds";
        public const string kdcsvc_xkdc_userAuthorizationBackwardsCompatibility = "kdcsvc_xkdc_userAuthorizationBackwardsCompatibility";
        public const string kdcsvc_xmacs_acceptDevKits = "kdcsvc_xmacs_acceptDevKits";
        public const string kdcsvc_xmacs_consoleExceptionList = "kdcsvc_xmacs_consoleExceptionList";
        public const string kdcsvc_xmacs_consoleTypeMask = "kdcsvc_xmacs_consoleTypeMask";
        public const string kdcsvc_xmacs_disableDOS = "kdcsvc_xmacs_disableDOS";
        public const string kdcsvc_xmacs_DoS2_blockingTime = "kdcsvc_xmacs_DoS2_blockingTime";
        public const string kdcsvc_xmacs_DoS2_cacheSize = "kdcsvc_xmacs_DoS2_cacheSize";
        public const string kdcsvc_xmacs_DoS2_enabled = "kdcsvc_xmacs_DoS2_enabled";
        public const string kdcsvc_xmacs_DoS2_interval = "kdcsvc_xmacs_DoS2_interval";
        public const string kdcsvc_xmacs_DoS2_maxRequests = "kdcsvc_xmacs_DoS2_maxRequests";
        public const string kdcsvc_xmacs_DOSStage1CacheTimeout = "kdcsvc_xmacs_DOSStage1CacheTimeout";
        public const string kdcsvc_xmacs_DOSStage2CacheTimeout = "kdcsvc_xmacs_DOSStage2CacheTimeout";
        public const string kdcsvc_xmacs_hashListPercentageWarning = "kdcsvc_xmacs_hashListPercentageWarning";
        public const string kdcsvc_xmacs_keyEncryptionKeyVersion = "kdcsvc_xmacs_keyEncryptionKeyVersion";
        public const string kdcsvc_xmacs_LimitedPcTokens = "kdcsvc_xmacs_LimitedPcTokens";
        public const string kdcsvc_xmacs_maxAllowancePerHour = "kdcsvc_xmacs_maxAllowancePerHour";
        public const string kdcsvc_xmacs_nCipherInitTimeoutInSecs = "kdcsvc_xmacs_nCipherInitTimeoutInSecs";
        public const string kdcsvc_xmacs_PUIDBlockSize = "kdcsvc_xmacs_PUIDBlockSize";
        public const string kdcsvc_xmacs_Rps_site = "kdcsvc_xmacs_Rps_site";
        public const string kdcsvc_xmacs_timeSkewSeconds = "kdcsvc_xmacs_timeSkewSeconds";
        public const string kdcsvc_xmacs_use_xcrypto = "kdcsvc_xmacs_use_xcrypto";
        public const string kdcsvc_xmacs_useNCipher = "kdcsvc_xmacs_useNCipher";
        public const string kdcsvc_xmacs_UseTestMasterSigningKey = "kdcsvc_xmacs_UseTestMasterSigningKey";
        public const string kdcsvc_xmacs_UseTestXmacsKey = "kdcsvc_xmacs_UseTestXmacsKey";
        public const string lbsvr_BufferManagerPageSize = "lbsvr_BufferManagerPageSize";
        public const string lbsvr_DatabaseWriteThreads = "lbsvr_DatabaseWriteThreads";
        public const string lbsvr_DbLoadingThreadCount = "lbsvr_DbLoadingThreadCount";
        public const string lbsvr_DbLoadIntervalSeconds = "lbsvr_DbLoadIntervalSeconds";
        public const string lbsvr_DbLoadRetryCount = "lbsvr_DbLoadRetryCount";
        public const string lbsvr_FullNamePagingFile = "lbsvr_FullNamePagingFile";
        public const string lbsvr_IOThreadCount = "lbsvr_IOThreadCount";
        public const string lbsvr_JobResetHour = "lbsvr_JobResetHour";
        public const string lbsvr_MaxCSndBuffer = "lbsvr_MaxCSndBuffer";
        public const string lbsvr_NetHelloTimeout = "lbsvr_NetHelloTimeout";
        public const string lbsvr_NetMaxConnections = "lbsvr_NetMaxConnections";
        public const string lbsvr_PagingFileInitialSize = "lbsvr_PagingFileInitialSize";
        public const string lbsvr_PersisterRetryInterval = "lbsvr_PersisterRetryInterval";
        public const string lbsvr_ReservedPhysicalMemory = "lbsvr_ReservedPhysicalMemory";
        public const string lbsvr_SizeRcvBuffer = "lbsvr_SizeRcvBuffer";
        public const string lbsvr_SizeSndBuffer = "lbsvr_SizeSndBuffer";
        public const string lbsvr_VirtualAllocSize = "lbsvr_VirtualAllocSize";
        public const string leet_webcommunity_db_Enabled = "leet_webcommunity_db_Enabled";
        public const string Lists_ConfigChange = "Lists_ConfigChange";
        public const string Lists_ValidateXmlMode = "Lists_ValidateXmlMode";
        public const string livecache_defaultConnectionLimit = "livecache_defaultConnectionLimit";
        public const string livecache_errorResultTTL = "livecache_errorResultTTL";
        public const string livecache_forwardRetryInterval = "livecache_forwardRetryInterval";
        public const string livecache_lastModified = "livecache_lastModified";
        public const string livecache_maxHeaderCollectionCount = "livecache_maxHeaderCollectionCount";
        public const string livecache_MaxRequestRatePerUser = "livecache_MaxRequestRatePerUser";
        public const string livecache_serviceEnabled = "livecache_serviceEnabled";
        public const string livecache_UserLimitInMinutes = "livecache_UserLimitInMinutes";
        public const string livecache_UserLimitRandMinutes = "livecache_UserLimitRandMinutes";
        public const string livecontent_sites = "livecontent_sites";
        public const string liveinfo_clientconfiglimit = "liveinfo_clientconfiglimit";
        public const string liveoffer_ContentCheckMode = "liveoffer_ContentCheckMode";
        public const string livepxy_forwardHeaders = "livepxy_forwardHeaders";
        public const string livepxy_MasterKeyVersion = "livepxy_MasterKeyVersion";
        public const string livepxy_maxGamerTagLookupsPerRequest = "livepxy_maxGamerTagLookupsPerRequest";
        public const string livepxy_maxPUIDLookupsPerRequest = "livepxy_maxPUIDLookupsPerRequest";
        public const string livepxy_SiteKeyType = "livepxy_SiteKeyType";
        public const string livetitle_allowBaseVersionZero = "livetitle_allowBaseVersionZero";
        public const string locale_AE = "locale_AE";
        public const string locale_AT = "locale_AT";
        public const string locale_AU = "locale_AU";
        public const string locale_BE = "locale_BE";
        public const string locale_BR = "locale_BR";
        public const string locale_CA = "locale_CA";
        public const string locale_CH = "locale_CH";
        public const string locale_CL = "locale_CL";
        public const string locale_CO = "locale_CO";
        public const string locale_CZ = "locale_CZ";
        public const string locale_DE = "locale_DE";
        public const string locale_DK = "locale_DK";
        public const string locale_ES = "locale_ES";
        public const string locale_FI = "locale_FI";
        public const string locale_FR = "locale_FR";
        public const string locale_GB = "locale_GB";
        public const string locale_GR = "locale_GR";
        public const string locale_HK = "locale_HK";
        public const string locale_HU = "locale_HU";
        public const string locale_IE = "locale_IE";
        public const string locale_IT = "locale_IT";
        public const string locale_JP = "locale_JP";
        public const string locale_KR = "locale_KR";
        public const string locale_language1 = "locale_language1";
        public const string locale_language10 = "locale_language10";
        public const string locale_language11 = "locale_language11";
        public const string locale_language12 = "locale_language12";
        public const string locale_language13 = "locale_language13";
        public const string locale_language14 = "locale_language14";
        public const string locale_language15 = "locale_language15";
        public const string locale_language16 = "locale_language16";
        public const string locale_language17 = "locale_language17";
        public const string locale_language18 = "locale_language18";
        public const string locale_language19 = "locale_language19";
        public const string locale_language2 = "locale_language2";
        public const string locale_language20 = "locale_language20";
        public const string locale_language3 = "locale_language3";
        public const string locale_language4 = "locale_language4";
        public const string locale_language5 = "locale_language5";
        public const string locale_language6 = "locale_language6";
        public const string locale_language7 = "locale_language7";
        public const string locale_language8 = "locale_language8";
        public const string locale_language9 = "locale_language9";
        public const string locale_MX = "locale_MX";
        public const string locale_NL = "locale_NL";
        public const string locale_NO = "locale_NO";
        public const string locale_NZ = "locale_NZ";
        public const string locale_PL = "locale_PL";
        public const string locale_PT = "locale_PT";
        public const string locale_RU = "locale_RU";
        public const string locale_SE = "locale_SE";
        public const string locale_SG = "locale_SG";
        public const string locale_TW = "locale_TW";
        public const string locale_US = "locale_US";
        public const string locale_validLocales = "locale_validLocales";
        public const string locale_ZA = "locale_ZA";
        public const string logCollectorModule_badDigestResponseCode = "logCollectorModule_badDigestResponseCode";
        public const string logCollectorModule_returnFixedResponseCodeForAllCalls = "logCollectorModule_returnFixedResponseCodeForAllCalls";
        public const string lspfd_databaseCachingEnabled = "lspfd_databaseCachingEnabled";
        public const string lspfd_fastFailBlockIntervalSeconds = "lspfd_fastFailBlockIntervalSeconds";
        public const string lspfd_fastFailTimeoutThresholdCount = "lspfd_fastFailTimeoutThresholdCount";
        public const string lspfd_fastFailTimeoutTimespanSeconds = "lspfd_fastFailTimeoutTimespanSeconds";
        public const string MasterKey_currentEncryptKeyVersion = "MasterKey_currentEncryptKeyVersion";
        public const string mix_default_LeaderBoardServer = "mix_default_LeaderBoardServer";
        public const string mix_default_MatchServer = "mix_default_MatchServer";
        public const string mix_productMgmt_imageCleanup = "mix_productMgmt_imageCleanup";
        public const string mix_titleMgmt_kdcReloadTimeout = "mix_titleMgmt_kdcReloadTimeout";
        public const string mix_titlemgmt_liveconnectdbhost = "mix_titlemgmt_liveconnectdbhost";
        public const string mix_wcfMaxReceivedMsgSize = "mix_wcfMaxReceivedMsgSize";
        public const string mixsettingsmanagement_etx_vortex_mgmt_timeout_ms = "mixsettingsmanagement_etx_vortex_mgmt_timeout_ms";
        public const string msnrr_allowUrlOverride = "msnrr_allowUrlOverride";
        public const string msnrr_failFastBlockIntervalSeconds = "msnrr_failFastBlockIntervalSeconds";
        public const string msnrr_failFastThresholdCount = "msnrr_failFastThresholdCount";
        public const string msnrr_failFastThresholdIntervalSeconds = "msnrr_failFastThresholdIntervalSeconds";
        public const string msnrr_getRatingAveragesTimeoutSeconds = "msnrr_getRatingAveragesTimeoutSeconds";
        public const string msnrr_getRatingByUserWithAverageTimeoutSeconds = "msnrr_getRatingByUserWithAverageTimeoutSeconds";
        public const string msnrr_ignorefdrequests = "msnrr_ignorefdrequests";
        public const string msnrr_saveRatingTimeoutSeconds = "msnrr_saveRatingTimeoutSeconds";
        public const string msnrr_serviceAggregatorUrl = "msnrr_serviceAggregatorUrl";
        public const string msnrr_serviceSingleRatingUrl = "msnrr_serviceSingleRatingUrl";
        public const string msnrr_testContentType = "msnrr_testContentType";
        public const string msnrr_testUserPuid = "msnrr_testUserPuid";
        public const string musicnet_addSubscriptionOfferTimeoutSeconds = "musicnet_addSubscriptionOfferTimeoutSeconds";
        public const string musicnet_addTrialSubscriptionOfferTimeoutSeconds = "musicnet_addTrialSubscriptionOfferTimeoutSeconds";
        public const string musicnet_allowUrlOverride = "musicnet_allowUrlOverride";
        public const string musicnet_apiMaxRetryAttempts = "musicnet_apiMaxRetryAttempts";
        public const string musicnet_auditEnabled = "musicnet_auditEnabled";
        public const string musicnet_cancelSubscriptionOfferTimeoutSeconds = "musicnet_cancelSubscriptionOfferTimeoutSeconds";
        public const string musicnet_closeAccountTimeoutSeconds = "musicnet_closeAccountTimeoutSeconds";
        public const string musicnet_createAccountTimeoutSeconds = "musicnet_createAccountTimeoutSeconds";
        public const string musicnet_dmpPurchaseGlobalMusicCampaignID = "musicnet_dmpPurchaseGlobalMusicCampaignID";
        public const string musicnet_dmpPurchaseGlobalMusicSKU = "musicnet_dmpPurchaseGlobalMusicSKU";
        public const string musicnet_dmpPurchaseMusicAlbumCategory = "musicnet_dmpPurchaseMusicAlbumCategory";
        public const string musicnet_dmpPurchaseMusicTrackCategory = "musicnet_dmpPurchaseMusicTrackCategory";
        public const string musicnet_dmpPurchaseTitleArtistFormatString = "musicnet_dmpPurchaseTitleArtistFormatString";
        public const string musicnet_downgradeSubscriptionOfferTimeoutSeconds = "musicnet_downgradeSubscriptionOfferTimeoutSeconds";
        public const string musicnet_endTrialSubscriptionOfferTimeoutSeconds = "musicnet_endTrialSubscriptionOfferTimeoutSeconds";
        public const string musicnet_failFastBlockIntervalSeconds = "musicnet_failFastBlockIntervalSeconds";
        public const string musicnet_failFastThresholdCount = "musicnet_failFastThresholdCount";
        public const string musicnet_failFastThresholdIntervalSeconds = "musicnet_failFastThresholdIntervalSeconds";
        public const string musicnet_getServiceConfigurationTimeoutSeconds = "musicnet_getServiceConfigurationTimeoutSeconds";
        public const string musicnet_getServiceConfigurationUrl = "musicnet_getServiceConfigurationUrl";
        public const string musicnet_offerIdMusicNetSkuOverrides = "musicnet_offerIdMusicNetSkuOverrides";
        public const string musicnet_pumpPurchasesQueue = "musicnet_pumpPurchasesQueue";
        public const string musicnet_purchaseAssetsTimeoutSeconds = "musicnet_purchaseAssetsTimeoutSeconds";
        public const string musicnet_purchaseTransactionConsiderFailedSeconds = "musicnet_purchaseTransactionConsiderFailedSeconds";
        public const string musicnet_purchaseTransactionExpiredSeconds = "musicnet_purchaseTransactionExpiredSeconds";
        public const string musicnet_queuePumpIntervalSeconds = "musicnet_queuePumpIntervalSeconds";
        public const string musicnet_resumeAccountTimeoutSeconds = "musicnet_resumeAccountTimeoutSeconds";
        public const string musicnet_retailerID = "musicnet_retailerID";
        public const string musicnet_subscriptionSku = "musicnet_subscriptionSku";
        public const string musicnet_suspendAccountTimeoutSeconds = "musicnet_suspendAccountTimeoutSeconds";
        public const string musicnet_transferPurchaseDBEntitlementsTimeoutSeconds = "musicnet_transferPurchaseDBEntitlementsTimeoutSeconds";
        public const string musicnet_trialSubscriptionSku = "musicnet_trialSubscriptionSku";
        public const string musicnet_upgradeSubscriptionOfferTimeoutSeconds = "musicnet_upgradeSubscriptionOfferTimeoutSeconds";
        public const string nameResolver_ruleExpirationHours = "nameResolver_ruleExpirationHours";
        public const string NotificationCache_fastFailBlockIntervalSeconds = "NotificationCache_fastFailBlockIntervalSeconds";
        public const string NotificationCache_fastFailTimeoutThresholdCount = "NotificationCache_fastFailTimeoutThresholdCount";
        public const string NotificationCache_fastFailTimeoutTimespanSeconds = "NotificationCache_fastFailTimeoutTimespanSeconds";
        public const string NotificationCache_replyTimeout = "NotificationCache_replyTimeout";
        public const string offer_cacheTimeSeconds = "offer_cacheTimeSeconds";
        public const string partnermgr_webCaches = "partnermgr_webCaches";
        public const string passport_blacklistBlockIntervalSeconds = "passport_blacklistBlockIntervalSeconds";
        public const string passport_blacklistTimeoutThresholdCount = "passport_blacklistTimeoutThresholdCount";
        public const string passport_blacklistTimeoutTimespanSeconds = "passport_blacklistTimeoutTimespanSeconds";
        public const string passport_clientCertName = "passport_clientCertName";
        public const string passport_fakeService = "passport_fakeService";
        public const string passport_partnerCallTimeoutSeconds = "passport_partnerCallTimeoutSeconds";
        public const string passport_partnerUrl = "passport_partnerUrl";
        public const string passport_publicKeyCert = "passport_publicKeyCert";
        public const string passport_publicKeyCertUrl = "passport_publicKeyCertUrl";
        public const string passport_siteAddress = "passport_siteAddress";
        public const string passport_siteAddressMsn = "passport_siteAddressMsn";
        public const string passport_siteId = "passport_siteId";
        public const string passport_sitePolicy = "passport_sitePolicy";
        public const string passport_sitePolicyMsn = "passport_sitePolicyMsn";
        public const string PassportCreation_fastFailMaxThreshold = "PassportCreation_fastFailMaxThreshold";
        public const string PassportCreation_fastFailMinThreshold = "PassportCreation_fastFailMinThreshold";
        public const string PassportCreation_fastFailWindow = "PassportCreation_fastFailWindow";
        public const string PassportCredentials_fastFailMaxThreshold = "PassportCredentials_fastFailMaxThreshold";
        public const string PassportCredentials_fastFailMinThreshold = "PassportCredentials_fastFailMinThreshold";
        public const string PassportCredentials_fastFailWindow = "PassportCredentials_fastFailWindow";
        public const string PassportLogin_fastFailMaxThreshold = "PassportLogin_fastFailMaxThreshold";
        public const string PassportLogin_fastFailMinThreshold = "PassportLogin_fastFailMinThreshold";
        public const string PassportLogin_fastFailWindow = "PassportLogin_fastFailWindow";
        public const string presence_AffiliatesAvoidingMeListSize = "presence_AffiliatesAvoidingMeListSize";
        public const string presence_AffiliatesCompletedGameListSize = "presence_AffiliatesCompletedGameListSize";
        public const string presence_AffiliatesEncounteredListSize = "presence_AffiliatesEncounteredListSize";
        public const string presence_AffiliatesFavoritesListSize = "presence_AffiliatesFavoritesListSize";
        public const string presence_AffiliatesNegativeFeedbackListSize = "presence_AffiliatesNegativeFeedbackListSize";
        public const string presence_AffiliatesPositiveFeedbackListSize = "presence_AffiliatesPositiveFeedbackListSize";
        public const string presence_BucketReloadDelay = "presence_BucketReloadDelay";
        public const string presence_ConcurrentSQLThreads = "presence_ConcurrentSQLThreads";
        public const string presence_ContextDurationAlertLimit = "presence_ContextDurationAlertLimit";
        public const string presence_DeadSgOnFailedQVal = "presence_DeadSgOnFailedQVal";
        public const string presence_EnableRichPresence = "presence_EnableRichPresence";
        public const string presence_ExpirationCheckInterval = "presence_ExpirationCheckInterval";
        public const string presence_HeartbeatDelay = "presence_HeartbeatDelay";
        public const string presence_IdleQValsCheck = "presence_IdleQValsCheck";
        public const string presence_MaxFriends = "presence_MaxFriends";
        public const string presence_MaxNumPoolBuffers = "presence_MaxNumPoolBuffers";
        public const string presence_MaxPresenceUsers = "presence_MaxPresenceUsers";
        public const string presence_MaxQValsPerHeartbeat = "presence_MaxQValsPerHeartbeat";
        public const string presence_MaxRichPresenceBytes = "presence_MaxRichPresenceBytes";
        public const string presence_MessageTimeout = "presence_MessageTimeout";
        public const string presence_MessageTypeExpiration = "presence_MessageTypeExpiration";
        public const string presence_MessagingDailyRecipients = "presence_MessagingDailyRecipients";
        public const string presence_MessagingDailySends = "presence_MessagingDailySends";
        public const string presence_NumSQLThreads = "presence_NumSQLThreads";
        public const string presence_PeerPort = "presence_PeerPort";
        public const string presence_PoolBufferSize = "presence_PoolBufferSize";
        public const string presence_PresUserCleanupDelay = "presence_PresUserCleanupDelay";
        public const string presence_pubsubEventTimeout = "presence_pubsubEventTimeout";
        public const string presence_pubsubEventUrl = "presence_pubsubEventUrl";
        public const string presence_pubsubNotificationEnabled = "presence_pubsubNotificationEnabled";
        public const string presence_QueryAffiliatesOkToPeerSubscribe = "presence_QueryAffiliatesOkToPeerSubscribe";
        public const string presence_QValRetryDelays = "presence_QValRetryDelays";
        public const string presence_RichPresenceDebug = "presence_RichPresenceDebug";
        public const string presence_SGIndexSize = "presence_SGIndexSize";
        public const string presence_SGQValRecvPort = "presence_SGQValRecvPort";
        public const string presence_SGQValSendPort = "presence_SGQValSendPort";
        public const string presence_StartNumPoolBuffers = "presence_StartNumPoolBuffers";
        public const string presence_StateBitsNotifyWhitelist = "presence_StateBitsNotifyWhitelist";
        public const string presence_StoreStateInVelocity = "presence_StoreStateInVelocity";
        public const string presence_UserIndexSize = "presence_UserIndexSize";
        public const string presence_ValidMessageTypes = "presence_ValidMessageTypes";
        public const string presence_WebUserTimeout = "presence_WebUserTimeout";
        public const string presence_WelcomeToNewConsoleMessage = "presence_WelcomeToNewConsoleMessage";
        public const string presence_WelcomeToXboxLiveMessage = "presence_WelcomeToXboxLiveMessage";
        public const string presence_XBoxIndexSize = "presence_XBoxIndexSize";
        public const string presence_XonWatchIPs = "presence_XonWatchIPs";
        public const string PresenceCache_fastFailBlockIntervalSeconds = "PresenceCache_fastFailBlockIntervalSeconds";
        public const string PresenceCache_fastFailTimeoutThresholdCount = "PresenceCache_fastFailTimeoutThresholdCount";
        public const string PresenceCache_fastFailTimeoutTimespanSeconds = "PresenceCache_fastFailTimeoutTimespanSeconds";
        public const string PresenceCache_replyTimeout = "PresenceCache_replyTimeout";
        public const string presenceFD_NumPoolThreads = "presenceFD_NumPoolThreads";
        public const string presenceWidget_friendsCacheExpirationSeconds = "presenceWidget_friendsCacheExpirationSeconds";
        public const string ProfileCache_fastFailBlockIntervalSeconds = "ProfileCache_fastFailBlockIntervalSeconds";
        public const string ProfileCache_fastFailTimeoutThresholdCount = "ProfileCache_fastFailTimeoutThresholdCount";
        public const string ProfileCache_fastFailTimeoutTimespanSeconds = "ProfileCache_fastFailTimeoutTimespanSeconds";
        public const string ProfileCache_replyTimeout = "ProfileCache_replyTimeout";
        public const string PubSubEvent_fastFailBlockIntervalSeconds = "PubSubEvent_fastFailBlockIntervalSeconds";
        public const string PubSubEvent_fastFailTimeoutThresholdCount = "PubSubEvent_fastFailTimeoutThresholdCount";
        public const string PubSubEvent_fastFailTimeoutTimespanSeconds = "PubSubEvent_fastFailTimeoutTimespanSeconds";
        public const string puidmgr_blockSize = "puidmgr_blockSize";
        public const string puidmgr_bucketCount = "puidmgr_bucketCount";
        public const string puidmgr_userPuidBucket = "puidmgr_userPuidBucket";
        public const string query_enableTitleLog = "query_enableTitleLog";
        public const string query_LspBackcompTitles = "query_LspBackcompTitles";
        public const string querylib_trustUpdates = "querylib_trustUpdates";
        public const string ratings_aggregate_use_ventura = "ratings_aggregate_use_ventura";
        public const string ratings_aggregate_ventura_listIdRegex = "ratings_aggregate_ventura_listIdRegex";
        public const string ratings_contenttype_mapping = "ratings_contenttype_mapping";
        public const string ratings_max_allowable_reviewcount = "ratings_max_allowable_reviewcount";
        public const string ratings_use_msnrr = "ratings_use_msnrr";
        public const string ratings_use_ventura = "ratings_use_ventura";
        public const string reporting_DeleteRoot = "reporting_DeleteRoot";
        public const string reporting_DistributionDataFileGrowth = "reporting_DistributionDataFileGrowth";
        public const string reporting_DistributionDataFileSize = "reporting_DistributionDataFileSize";
        public const string reporting_DistributionDBName = "reporting_DistributionDBName";
        public const string reporting_DistributionLogFileGrowth = "reporting_DistributionLogFileGrowth";
        public const string reporting_DistributionLogFileSize = "reporting_DistributionLogFileSize";
        public const string reporting_DistributionMaxHistoryRetention = "reporting_DistributionMaxHistoryRetention";
        public const string reporting_DistributionMaxRetention = "reporting_DistributionMaxRetention";
        public const string reporting_ReplicationShare = "reporting_ReplicationShare";
        public const string reporting_RSUtilPath = "reporting_RSUtilPath";
        public const string reporting_SSISUseReplica = "reporting_SSISUseReplica";
        public const string reporting_WMISCertSubject = "reporting_WMISCertSubject";
        public const string reporting_WMISDBDrop = "reporting_WMISDBDrop";
        public const string reporting_WMISDBUrl = "reporting_WMISDBUrl";
        public const string scs_blacklistBlockIntervalSeconds = "scs_blacklistBlockIntervalSeconds";
        public const string scs_blacklistTimeoutThresholdCount = "scs_blacklistTimeoutThresholdCount";
        public const string scs_blacklistTimeoutTimespanSeconds = "scs_blacklistTimeoutTimespanSeconds";
        public const string scs_pumpPurchaseItemQueue = "scs_pumpPurchaseItemQueue";
        public const string scs_purchaseItemTransactionConsiderFailedSeconds = "scs_purchaseItemTransactionConsiderFailedSeconds";
        public const string scs_purchaseItemTransactionExpiredSeconds = "scs_purchaseItemTransactionExpiredSeconds";
        public const string scs_queuePumpIntervalSeconds = "scs_queuePumpIntervalSeconds";
        public const string SCSCreditCard_fastFailMaxThreshold = "SCSCreditCard_fastFailMaxThreshold";
        public const string SCSCreditCard_fastFailMinThreshold = "SCSCreditCard_fastFailMinThreshold";
        public const string SCSCreditCard_fastFailWindow = "SCSCreditCard_fastFailWindow";
        public const string SCSNonCreditCard_fastFailMaxThreshold = "SCSNonCreditCard_fastFailMaxThreshold";
        public const string SCSNonCreditCard_fastFailMinThreshold = "SCSNonCreditCard_fastFailMinThreshold";
        public const string SCSNonCreditCard_fastFailWindow = "SCSNonCreditCard_fastFailWindow";
        public const string setup_approot = "setup_approot";
        public const string setup_logroot = "setup_logroot";
        public const string setup_secureUNC = "setup_secureUNC";
        public const string setup_sqldbroot = "setup_sqldbroot";
        public const string setup_sqlftroot = "setup_sqlftroot";
        public const string setup_sqllogroot = "setup_sqllogroot";
        public const string sg_AesMinClientVersionPc = "sg_AesMinClientVersionPc";
        public const string sg_AesMinClientVersionXbox360 = "sg_AesMinClientVersionXbox360";
        public const string sg_AesProtocolEnabled = "sg_AesProtocolEnabled";
        public const string sg_ArpNegativeTimeoutInSeconds = "sg_ArpNegativeTimeoutInSeconds";
        public const string sg_ArpPositiveTimeoutInSeconds = "sg_ArpPositiveTimeoutInSeconds";
        public const string sg_ArpRequestRetries = "sg_ArpRequestRetries";
        public const string sg_ArpRexmitTimeoutInSeconds = "sg_ArpRexmitTimeoutInSeconds";
        public const string sg_BlockLimit = "sg_BlockLimit";
        public const string sg_ChalHeartbeatTimeoutInSeconds = "sg_ChalHeartbeatTimeoutInSeconds";
        public const string sg_ClientHistoryLimit = "sg_ClientHistoryLimit";
        public const string sg_ClientLimit = "sg_ClientLimit";
        public const string sg_ClientPortLimit = "sg_ClientPortLimit";
        public const string sg_ConnectionServerPortLimit = "sg_ConnectionServerPortLimit";
        public const string sg_DesKeySize = "sg_DesKeySize";
        public const string sg_DhInfoCacheSize = "sg_DhInfoCacheSize";
        public const string sg_DhLimitHysteresisInMs = "sg_DhLimitHysteresisInMs";
        public const string sg_DhLimitOpsPerSec = "sg_DhLimitOpsPerSec";
        public const string sg_DnsRefreshFailureIntervalInSeconds = "sg_DnsRefreshFailureIntervalInSeconds";
        public const string sg_DnsRefreshIntervalInMinutes = "sg_DnsRefreshIntervalInMinutes";
        public const string sg_DvdChalShiftIntervalInSeconds = "sg_DvdChalShiftIntervalInSeconds";
        public const string sg_EnableChallengeResponse = "sg_EnableChallengeResponse";
        public const string sg_EnableConnectionServices = "sg_EnableConnectionServices";
        public const string sg_HashTableOverheadInPercent = "sg_HashTableOverheadInPercent";
        public const string sg_IpHdrTos = "sg_IpHdrTos";
        public const string sg_IpHdrTtl = "sg_IpHdrTtl";
        public const string sg_KerberosApReqDeltaInMinutes = "sg_KerberosApReqDeltaInMinutes";
        public const string sg_KeyExBlockIntervalInSeconds = "sg_KeyExBlockIntervalInSeconds";
        public const string sg_KeyExDontSendIcmp = "sg_KeyExDontSendIcmp";
        public const string sg_KeyExIcmpVip = "sg_KeyExIcmpVip";
        public const string sg_KeyExMinRetryInMs = "sg_KeyExMinRetryInMs";
        public const string sg_KeyExXbToSgInitMinSize = "sg_KeyExXbToSgInitMinSize";
        public const string sg_LogClientUpdates = "sg_LogClientUpdates";
        public const string sg_LuaStateTableSize = "sg_LuaStateTableSize";
        public const string sg_NatDetectionDisconnectInSeconds = "sg_NatDetectionDisconnectInSeconds";
        public const string sg_NotifyBatchIntervalInSeconds = "sg_NotifyBatchIntervalInSeconds";
        public const string sg_PacketPool = "sg_PacketPool";
        public const string sg_PacketPoolMax = "sg_PacketPoolMax";
        public const string sg_ProcessorQuantum = "sg_ProcessorQuantum";
        public const string sg_SgToXbChallengePeriodInSeconds = "sg_SgToXbChallengePeriodInSeconds";
        public const string sg_SgToXbKeyExTimeoutInSeconds = "sg_SgToXbKeyExTimeoutInSeconds";
        public const string sg_SgToXbPulseTimeoutInSeconds = "sg_SgToXbPulseTimeoutInSeconds";
        public const string sg_SgToXbScanFrequencyInSeconds = "sg_SgToXbScanFrequencyInSeconds";
        public const string sg_SgToXbTimeoutInSeconds = "sg_SgToXbTimeoutInSeconds";
        public const string sg_ShareDatacenterNicWithWindows = "sg_ShareDatacenterNicWithWindows";
        public const string sg_ShareInternetNicWithWindows = "sg_ShareInternetNicWithWindows";
        public const string sg_SpiFlow = "sg_SpiFlow";
        public const string sg_SpiFlowDataLimit = "sg_SpiFlowDataLimit";
        public const string sg_SpiWatchdogTimeoutInSeconds = "sg_SpiWatchdogTimeoutInSeconds";
        public const string sg_StatsConfidenceLimitInClients = "sg_StatsConfidenceLimitInClients";
        public const string sg_StatsDisconnectSigmaInterval = "sg_StatsDisconnectSigmaInterval";
        public const string sg_StatsHistoryInMs = "sg_StatsHistoryInMs";
        public const string sg_StatsPenaltyTimeInSeconds = "sg_StatsPenaltyTimeInSeconds";
        public const string sg_StatsRefreshFrequencyInSeconds = "sg_StatsRefreshFrequencyInSeconds";
        public const string sg_StatsReportIntervalInSeconds = "sg_StatsReportIntervalInSeconds";
        public const string sg_StatsWarningSigmaInterval = "sg_StatsWarningSigmaInterval";
        public const string sg_WiretapTimeoutInMinutes = "sg_WiretapTimeoutInMinutes";
        public const string sg_XbToSgChallengeAckInSeconds = "sg_XbToSgChallengeAckInSeconds";
        public const string sg_XbToSgChallengeTimeoutInSeconds = "sg_XbToSgChallengeTimeoutInSeconds";
        public const string sg_XbToSgPulseTimeoutInSeconds = "sg_XbToSgPulseTimeoutInSeconds";
        public const string sg_XbToSgReplayWindow = "sg_XbToSgReplayWindow";
        public const string sg_XbToSgTimeoutInSeconds = "sg_XbToSgTimeoutInSeconds";
        public const string sginfo_maxRetries = "sginfo_maxRetries";
        public const string sginfo_retrieveForFlowToken = "sginfo_retrieveForFlowToken";
        public const string sginfo_supportedHttpAuthDataVersion = "sginfo_supportedHttpAuthDataVersion";
        public const string sginfo_timeout = "sginfo_timeout";
        public const string sginfo_useOldProtocol = "sginfo_useOldProtocol";
        public const string sginfo_verifyAuth = "sginfo_verifyAuth";
        public const string sginfo_verifyTestTitleVersion = "sginfo_verifyTestTitleVersion";
        public const string signature_crlRevocationMode = "signature_crlRevocationMode";
        public const string signature_digestReloadInterval = "signature_digestReloadInterval";
        public const string signature_licenseTransferMinDaysToRestart = "signature_licenseTransferMinDaysToRestart";
        public const string signature_licenseTransferTimeoutInMinutes = "signature_licenseTransferTimeoutInMinutes";
        public const string signature_machineReloadInterval = "signature_machineReloadInterval";
        public const string signature_serviceKeyType = "signature_serviceKeyType";
        public const string signature_serviceKeyVersion = "signature_serviceKeyVersion";
        public const string signature_titleReloadInterval = "signature_titleReloadInterval";
        public const string signature_userReloadInterval = "signature_userReloadInterval";
        public const string signature_validateCertificateValidUntilMinutes = "signature_validateCertificateValidUntilMinutes";
        public const string SocialCache_BulkGetBatchMaxSize = "SocialCache_BulkGetBatchMaxSize";
        public const string SocialCache_BytesPerPooledBuffer = "SocialCache_BytesPerPooledBuffer";
        public const string SocialCache_CacheEntryExpirationTimeout = "SocialCache_CacheEntryExpirationTimeout";
        public const string SocialCache_DataThreadpoolSize = "SocialCache_DataThreadpoolSize";
        public const string SocialCache_fastFailBlockIntervalSeconds = "SocialCache_fastFailBlockIntervalSeconds";
        public const string SocialCache_fastFailTimeoutThresholdCount = "SocialCache_fastFailTimeoutThresholdCount";
        public const string SocialCache_fastFailTimeoutTimespanSeconds = "SocialCache_fastFailTimeoutTimespanSeconds";
        public const string SocialCache_MaxClientSockets = "SocialCache_MaxClientSockets";
        public const string SocialCache_MaxMessageBytes = "SocialCache_MaxMessageBytes";
        public const string SocialCache_MaxObjectsPerMessage = "SocialCache_MaxObjectsPerMessage";
        public const string SocialCache_MemCacheDllName = "SocialCache_MemCacheDllName";
        public const string SocialCache_RelationshipsLookupTableBuckets = "SocialCache_RelationshipsLookupTableBuckets";
        public const string SocialCache_replyTimeoutMS = "SocialCache_replyTimeoutMS";
        public const string SocialCache_SocketBufferSize = "SocialCache_SocketBufferSize";
        public const string SocialCache_TCPKeepAliveTimeout = "SocialCache_TCPKeepAliveTimeout";
        public const string SocialCache_UserLookupTableBuckets = "SocialCache_UserLookupTableBuckets";
        public const string stats_AllowAlternateDestination = "stats_AllowAlternateDestination";
        public const string stats_allowTitleReset = "stats_allowTitleReset";
        public const string stats_allowUnverifiedWrite = "stats_allowUnverifiedWrite";
        public const string stats_dbMaxRetry = "stats_dbMaxRetry";
        public const string stats_dbRetryInteval = "stats_dbRetryInteval";
        public const string stats_debugPuid = "stats_debugPuid";
        public const string stats_enableCertificationMode = "stats_enableCertificationMode";
        public const string stats_enableTitlePerfCounters = "stats_enableTitlePerfCounters";
        public const string stats_trackCountersPerLb = "stats_trackCountersPerLb";
        public const string storage_xbancCacheTimeOut = "storage_xbancCacheTimeOut";
        public const string storageFD_allowZeroUserPuidsFromInternet = "storageFD_allowZeroUserPuidsFromInternet";
        public const string storageFD_httpCacheHeader = "storageFD_httpCacheHeader";
        public const string storageFD_httpContentTypeHeader = "storageFD_httpContentTypeHeader";
        public const string storageFD_removeFileSqlTimeout = "storageFD_removeFileSqlTimeout";
        public const string storageFD_verifyAccessTokens = "storageFD_verifyAccessTokens";
        public const string storageFD_writeFileSqlTimeout = "storageFD_writeFileSqlTimeout";
        public const string storageModule_enableXbancCaching = "storageModule_enableXbancCaching";
        public const string storageModule_maxUrlLength = "storageModule_maxUrlLength";
        public const string storageModule_returnFixedResponseCodeForAllCalls = "storageModule_returnFixedResponseCodeForAllCalls";
        public const string storageModule_urlPathRegEx = "storageModule_urlPathRegEx";
        public const string storageModule_urlRedirectPath = "storageModule_urlRedirectPath";
        public const string storageModule_urlReplacementString = "storageModule_urlReplacementString";
        public const string storageModule_urlStringToReplace = "storageModule_urlStringToReplace";
        public const string storageWidget_fakeFrontDoorFailures = "storageWidget_fakeFrontDoorFailures";
        public const string storageWidget_fakeXCache = "storageWidget_fakeXCache";
        public const string storageWidget_fakeXSig = "storageWidget_fakeXSig";
        public const string stringsvr_flushStringsInterval = "stringsvr_flushStringsInterval";
        public const string stringsvr_loadStringsInterval = "stringsvr_loadStringsInterval";
        public const string stringsvr_reportingAggregateKeys = "stringsvr_reportingAggregateKeys";
        public const string sts_cert_subject = "sts_cert_subject";
        public const string sts_machine_token_expiration_seconds = "sts_machine_token_expiration_seconds";
        public const string sts_partner_token_expiration_seconds = "sts_partner_token_expiration_seconds";
        public const string sts_token_issuer_name = "sts_token_issuer_name";
        public const string sts_token_window_minutes = "sts_token_window_minutes";
        public const string sts_user_token_expiration_seconds = "sts_user_token_expiration_seconds";
        public const string svct_heartbeatTimeout = "svct_heartbeatTimeout";
        public const string tagrecycle_comber_job_batch_size = "tagrecycle_comber_job_batch_size";
        public const string tagrecycle_disassociated_job_batch_size = "tagrecycle_disassociated_job_batch_size";
        public const string tagrecycle_disassociater_high_value_files = "tagrecycle_disassociater_high_value_files";
        public const string tagrecycle_disassociater_reservation_console_id = "tagrecycle_disassociater_reservation_console_id";
        public const string tagrecycle_emailer_job_batch_size = "tagrecycle_emailer_job_batch_size";
        public const string tagrecycle_emailer_job_file_path = "tagrecycle_emailer_job_file_path";
        public const string tagrecycle_emailer1_file_name = "tagrecycle_emailer1_file_name";
        public const string tagrecycle_emailer2_file_name = "tagrecycle_emailer2_file_name";
        public const string TagRecycleCronJobs = "TagRecycleCronJobs";
        public const string testfd_PermissionLevel = "testfd_PermissionLevel";
        public const string titlevault_root = "titlevault_root";
        public const string tokenService_batchSize = "tokenService_batchSize";
        public const string tokenService_considerStaleSeconds = "tokenService_considerStaleSeconds";
        public const string tokenService_delayBaseNumber = "tokenService_delayBaseNumber";
        public const string tokenService_delayExponentFactor = "tokenService_delayExponentFactor";
        public const string tokenService_finalOutputDirectory = "tokenService_finalOutputDirectory";
        public const string tokenService_keyType = "tokenService_keyType";
        public const string tokenService_keyVersion = "tokenService_keyVersion";
        public const string tokenService_maxFailureThreshold = "tokenService_maxFailureThreshold";
        public const string tokenService_maxNumTokens = "tokenService_maxNumTokens";
        public const string tokenService_scsBatchSize = "tokenService_scsBatchSize";
        public const string tokenService_sqlBatchSize = "tokenService_sqlBatchSize";
        public const string tokenService_tempOutputDirectory = "tokenService_tempOutputDirectory";
        public const string tokenService_vetTokens = "tokenService_vetTokens";
        public const string toolsmgmt_filePrefix = "toolsmgmt_filePrefix";
        public const string toolsmgmt_fileshare = "toolsmgmt_fileshare";
        public const string toolsmgmt_pollingInterval = "toolsmgmt_pollingInterval";
        public const string toolsmgmt_SDClient = "toolsmgmt_SDClient";
        public const string toolsmgmt_SDPort = "toolsmgmt_SDPort";
        public const string udpadpt_numOfThreads = "udpadpt_numOfThreads";
        public const string ups_blacklistBlockIntervalSeconds = "ups_blacklistBlockIntervalSeconds";
        public const string ups_blacklistTimeoutThresholdCount = "ups_blacklistTimeoutThresholdCount";
        public const string ups_blacklistTimeoutTimespanSeconds = "ups_blacklistTimeoutTimespanSeconds";
        public const string ups_clientCertName = "ups_clientCertName";
        public const string ups_getProfileTimeoutSeconds = "ups_getProfileTimeoutSeconds";
        public const string ups_partnerId = "ups_partnerId";
        public const string ups_updateProfileTimeoutSeconds = "ups_updateProfileTimeoutSeconds";
        public const string ups_url = "ups_url";
        public const string user_forbiddenNamesReloadIntervalMinutes = "user_forbiddenNamesReloadIntervalMinutes";
        public const string user_nameReservationMinutes = "user_nameReservationMinutes";
        public const string venturarr_aggregateRatingTimeoutSeconds = "venturarr_aggregateRatingTimeoutSeconds";
        public const string venturarr_clientVersion = "venturarr_clientVersion";
        public const string venturarr_customerGroup = "venturarr_customerGroup";
        public const string venturarr_defaultConnectionLimit = "venturarr_defaultConnectionLimit";
        public const string venturarr_deviceId = "venturarr_deviceId";
        public const string venturarr_failFastEnabled = "venturarr_failFastEnabled";
        public const string venturarr_failFastMaxThreshold = "venturarr_failFastMaxThreshold";
        public const string venturarr_failFastMinThreshold = "venturarr_failFastMinThreshold";
        public const string venturarr_failFastTimeWindow = "venturarr_failFastTimeWindow";
        public const string venturarr_formatSuperVuid = "venturarr_formatSuperVuid";
        public const string venturarr_formatVuid = "venturarr_formatVuid";
        public const string venturarr_ignoreSslPolicyErrors = "venturarr_ignoreSslPolicyErrors";
        public const string venturarr_locale = "venturarr_locale";
        public const string venturarr_padCredentialExpiryMilliseconds = "venturarr_padCredentialExpiryMilliseconds";
        public const string venturarr_serviceAuthKeyArray = "venturarr_serviceAuthKeyArray";
        public const string venturarr_serviceAuthKeyIndex = "venturarr_serviceAuthKeyIndex";
        public const string venturarr_serviceDirectoryServiceUrl = "venturarr_serviceDirectoryServiceUrl";
        public const string venturarr_singleRatingTimeoutSeconds = "venturarr_singleRatingTimeoutSeconds";
        public const string venturarr_superUserVuidPart = "venturarr_superUserVuidPart";
        public const string vortex_alwaysUseWorkerThread = "vortex_alwaysUseWorkerThread";
        public const string vortex_cake_stream_recipe_template_xml = "vortex_cake_stream_recipe_template_xml";
        public const string vortex_defaultEventTypeCountWindowSeconds = "vortex_defaultEventTypeCountWindowSeconds";
        public const string vortex_defaultInputEventQueueSize = "vortex_defaultInputEventQueueSize";
        public const string vortex_logweb_v1_p3p = "vortex_logweb_v1_p3p";
        public const string vortex_logweb_v1_producer = "vortex_logweb_v1_producer";
        public const string vortex_maxIoThreads = "vortex_maxIoThreads";
        public const string vortex_maxWorkerThreadLatencyMs = "vortex_maxWorkerThreadLatencyMs";
        public const string vortex_maxWorkerThreads = "vortex_maxWorkerThreads";
        public const string vortex_maxWorkItemQueueSize = "vortex_maxWorkItemQueueSize";
        public const string vortex_minIoThreads = "vortex_minIoThreads";
        public const string vortex_minWorkerThreads = "vortex_minWorkerThreads";
        public const string vortex_numOverlappedIoOperations = "vortex_numOverlappedIoOperations";
        public const string vortex_retrieveSgInfoForUnknownEvents = "vortex_retrieveSgInfoForUnknownEvents";
        public const string vortex_udpReceiveBufferSize = "vortex_udpReceiveBufferSize";
        public const string vortex_unknownEventHeaderVersion = "vortex_unknownEventHeaderVersion";
        public const string wcgeneral_titleListValidSeconds = "wcgeneral_titleListValidSeconds";
        public const string wcsignature_createSignatureURL = "wcsignature_createSignatureURL";
        public const string wcsignature_maximumAdminIdLength = "wcsignature_maximumAdminIdLength";
        public const string wcsignature_maximumVerifySignaturesPerRequest = "wcsignature_maximumVerifySignaturesPerRequest";
        public const string wcsignature_signatureSite = "wcsignature_signatureSite";
        public const string wcsignature_verifySignatureURL = "wcsignature_verifySignatureURL";
        public const string wcstats_AboveMax = "wcstats_AboveMax";
        public const string wcstats_BelowMax = "wcstats_BelowMax";
        public const string wcstats_EnumEntriesMax = "wcstats_EnumEntriesMax";
        public const string wcstats_EnumRawEntriesMax = "wcstats_EnumRawEntriesMax";
        public const string wcstats_EnumRawStartMin = "wcstats_EnumRawStartMin";
        public const string wcstats_EnumStartMax = "wcstats_EnumStartMax";
        public const string wcstats_EnumStartMin = "wcstats_EnumStartMin";
        public const string wcstats_LeaderboardListValidSeconds = "wcstats_LeaderboardListValidSeconds";
        public const string wcstats_RemoveDups = "wcstats_RemoveDups";
        public const string wcstats_SingleAppDomain = "wcstats_SingleAppDomain";
        public const string wcstats_SortByRating = "wcstats_SortByRating";
        public const string wcstats_TagListMax = "wcstats_TagListMax";
        public const string wctoolsmgmt_actionTableXML = "wctoolsmgmt_actionTableXML";
        public const string wctoolsmgmt_autopropLBServer = "wctoolsmgmt_autopropLBServer";
        public const string wctoolsmgmt_autopropMMServer = "wctoolsmgmt_autopropMMServer";
        public const string wctoolsmgmt_concurrentJobs = "wctoolsmgmt_concurrentJobs";
        public const string wctoolsmgmt_pingInterval = "wctoolsmgmt_pingInterval";
        public const string wctoolsmgmt_uploadPathRoot = "wctoolsmgmt_uploadPathRoot";
        public const string wctoolsmgmt_workPathRoot = "wctoolsmgmt_workPathRoot";
        public const string wcusers_alertsSite = "wcusers_alertsSite";
        public const string wcusers_cacheExpirationSeconds = "wcusers_cacheExpirationSeconds";
        public const string wcusers_uacsGetUserSettingsURL = "wcusers_uacsGetUserSettingsURL";
        public const string wcusers_uacsLinkUserURL = "wcusers_uacsLinkUserURL";
        public const string wcusers_uacsSite = "wcusers_uacsSite";
        public const string webSG_capturePath = "webSG_capturePath";
        public const string webSG_certIssuerCN1 = "webSG_certIssuerCN1";
        public const string webSG_certIssuerCN2 = "webSG_certIssuerCN2";
        public const string webSG_certIssuerCN3 = "webSG_certIssuerCN3";
        public const string webSG_certIssuerCN4 = "webSG_certIssuerCN4";
        public const string webSG_maxInReqSize = "webSG_maxInReqSize";
        public const string wiredata_postLimit = "wiredata_postLimit";
        public const string wiredata_stringLimit = "wiredata_stringLimit";
        public const string wiretap_AuthDataReplyPort = "wiretap_AuthDataReplyPort";
        public const string wiretap_AuthDataWaitTimeInSecs = "wiretap_AuthDataWaitTimeInSecs";
        public const string wiretap_DumpDirectory = "wiretap_DumpDirectory";
        public const string wiretap_MaxNumOfRetrys = "wiretap_MaxNumOfRetrys";
        public const string wiretap_MaxNumOfTaps = "wiretap_MaxNumOfTaps";
        public const string wiretap_MaxSGAuthDataRetry = "wiretap_MaxSGAuthDataRetry";
        public const string wiretap_NumOfCarrierNodes = "wiretap_NumOfCarrierNodes";
        public const string wiretap_NumOfReceiverNodes = "wiretap_NumOfReceiverNodes";
        public const string wiretap_PacketBufferSize = "wiretap_PacketBufferSize";
        public const string wiretap_SGSessionTimeoutInSecs = "wiretap_SGSessionTimeoutInSecs";
        public const string wiretap_UnwantedIPs = "wiretap_UnwantedIPs";
        public const string wmis_allowUrlOverride = "wmis_allowUrlOverride";
        public const string wmis_apiMaxRetryAttempts = "wmis_apiMaxRetryAttempts";
        public const string wmis_clientCertSubject = "wmis_clientCertSubject";
        public const string wmis_dmpPurchaseGlobalVideoCampaignID = "wmis_dmpPurchaseGlobalVideoCampaignID";
        public const string wmis_dmpPurchaseGlobalVideoSKU = "wmis_dmpPurchaseGlobalVideoSKU";
        public const string wmis_dmpPurchaseVideoCategory = "wmis_dmpPurchaseVideoCategory";
        public const string wmis_failFastBlockIntervalSeconds = "wmis_failFastBlockIntervalSeconds";
        public const string wmis_failFastThresholdCount = "wmis_failFastThresholdCount";
        public const string wmis_failFastThresholdIntervalSeconds = "wmis_failFastThresholdIntervalSeconds";
        public const string wmis_getVideoPurchaseDetailsTimeoutSeconds = "wmis_getVideoPurchaseDetailsTimeoutSeconds";
        public const string wmis_serviceUrl = "wmis_serviceUrl";
        public const string xarb_AllowAlternateDestination = "xarb_AllowAlternateDestination";
        public const string xarb_BundleRetryPeriodInSeconds = "xarb_BundleRetryPeriodInSeconds";
        public const string xarb_EnableDebugResult = "xarb_EnableDebugResult";
        public const string xarb_GarbageCollectionIntervalInSeconds = "xarb_GarbageCollectionIntervalInSeconds";
        public const string xarb_InterfaceBucketInterceptThrottleInMillis = "xarb_InterfaceBucketInterceptThrottleInMillis";
        public const string xarb_MaxBundleRetrySeconds = "xarb_MaxBundleRetrySeconds";
        public const string xarb_MaxDelayedTrustUpdates = "xarb_MaxDelayedTrustUpdates";
        public const string xarb_MaxSessionSeconds = "xarb_MaxSessionSeconds";
        public const string xarb_MaxStatsBundleSize = "xarb_MaxStatsBundleSize";
        public const string xarb_MaxTournamentBundleSize = "xarb_MaxTournamentBundleSize";
        public const string xarb_MemoryUsageHighWaterMark = "xarb_MemoryUsageHighWaterMark";
        public const string xarb_MemoryUsageLowWaterMark = "xarb_MemoryUsageLowWaterMark";
        public const string xarb_MigrationWaitWindowMinutes = "xarb_MigrationWaitWindowMinutes";
        public const string xarb_NumberFlushBundleThreads = "xarb_NumberFlushBundleThreads";
        public const string xarb_NumberFlushTrustRatingThreads = "xarb_NumberFlushTrustRatingThreads";
        public const string xarb_SessionTimeoutExtensionSeconds = "xarb_SessionTimeoutExtensionSeconds";
        public const string xarb_TitleParameterReloadPeriodInSeconds = "xarb_TitleParameterReloadPeriodInSeconds";
        public const string xarb_TrailingReportRetriesWaitSeconds = "xarb_TrailingReportRetriesWaitSeconds";
        public const string xarb_TrustFlushPeriodInSeconds = "xarb_TrustFlushPeriodInSeconds";
        public const string xarb_TrustIdleSecondsBeforeFlush = "xarb_TrustIdleSecondsBeforeFlush";
        public const string xarb_TrustSummationExecutionTimeInSeconds = "xarb_TrustSummationExecutionTimeInSeconds";
        public const string xarb_TrustSummationPeriodInSeconds = "xarb_TrustSummationPeriodInSeconds";
        public const string xarb_TrustSummationRetryInSeconds = "xarb_TrustSummationRetryInSeconds";
        public const string xarb_TrustSummationTimeoutSeconds = "xarb_TrustSummationTimeoutSeconds";
        public const string xarb_VerboseLogging = "xarb_VerboseLogging";
        public const string xbanc_context_duration_alert_limit = "xbanc_context_duration_alert_limit";
        public const string xbanc_fastFailBlockIntervalSeconds = "xbanc_fastFailBlockIntervalSeconds";
        public const string xbanc_fastFailTimeoutThresholdCount = "xbanc_fastFailTimeoutThresholdCount";
        public const string xbanc_fastFailTimeoutTimespanSeconds = "xbanc_fastFailTimeoutTimespanSeconds";
        public const string xbanc_heartbeat_interval = "xbanc_heartbeat_interval";
        public const string xbanc_localCacheItemDuration = "xbanc_localCacheItemDuration";
        public const string xbanc_localCacheMaxSize = "xbanc_localCacheMaxSize";
        public const string xbanc_low_water_data_storage_bytes = "xbanc_low_water_data_storage_bytes";
        public const string xbanc_max_key_length = "xbanc_max_key_length";
        public const string xbanc_record_maintenance_period = "xbanc_record_maintenance_period";
        public const string xbanc_replyTimeout = "xbanc_replyTimeout";
        public const string xbanc_total_data_storage_bytes = "xbanc_total_data_storage_bytes";
        public const string xbos_allowMultiItemSubmitOrderTransactions = "xbos_allowMultiItemSubmitOrderTransactions";
        public const string xbos_auditEnabled = "xbos_auditEnabled";
        public const string xbos_AutoCacheFlushHour = "xbos_AutoCacheFlushHour";
        public const string xbos_blockPurchaseMediaOffersSubmitOrderTransactions = "xbos_blockPurchaseMediaOffersSubmitOrderTransactions";
        public const string xbos_CTPPurchaseTransactionConsiderFailedSeconds = "xbos_CTPPurchaseTransactionConsiderFailedSeconds";
        public const string xbos_ctpTimeConversionRatio = "xbos_ctpTimeConversionRatio";
        public const string xbos_CTPTransactionExpiredSeconds = "xbos_CTPTransactionExpiredSeconds";
        public const string xbos_EnablePaymentTypeIdSupportInZuneCatalog = "xbos_EnablePaymentTypeIdSupportInZuneCatalog";
        public const string xbos_gfwlOrderAttributeGuid = "xbos_gfwlOrderAttributeGuid";
        public const string xbos_limitedChildContentPurchaseCountryList = "xbos_limitedChildContentPurchaseCountryList";
        public const string xbos_limitedChildOfferTypePurchaseCountryList = "xbos_limitedChildOfferTypePurchaseCountryList";
        public const string xbos_MaxCacheSize_ContentEnumerate = "xbos_MaxCacheSize_ContentEnumerate";
        public const string xbos_MaxCacheSize_EnumerateTitlesByFilter = "xbos_MaxCacheSize_EnumerateTitlesByFilter";
        public const string xbos_MaxCacheSize_GetTitleDetails = "xbos_MaxCacheSize_GetTitleDetails";
        public const string xbos_newContentWindowHours = "xbos_newContentWindowHours";
        public const string xbos_populateNewPurchaseHistoryFromOldPurchase = "xbos_populateNewPurchaseHistoryFromOldPurchase";
        public const string xbos_pumpCTPPurchaseQueue = "xbos_pumpCTPPurchaseQueue";
        public const string xbos_pumpOffsetOrderQueue = "xbos_pumpOffsetOrderQueue";
        public const string xbos_pumpSubmitOrderQueue = "xbos_pumpSubmitOrderQueue";
        public const string xbos_queuePumpIntervalSeconds = "xbos_queuePumpIntervalSeconds";
        public const string xbos_submitOrderTransactionConsiderFailedSeconds = "xbos_submitOrderTransactionConsiderFailedSeconds";
        public const string xbos_submitOrderTransactionExpiredSeconds = "xbos_submitOrderTransactionExpiredSeconds";
        public const string xbos_subscriptionMaxTimeCredit = "xbos_subscriptionMaxTimeCredit";
        public const string xbos_titleActivation_disableAllTitles = "xbos_titleActivation_disableAllTitles";
        public const string xbos_useExternalVideoMarketplaceCatalog = "xbos_useExternalVideoMarketplaceCatalog";
        public const string xbos_xbox360OrderAttributeGuid = "xbos_xbox360OrderAttributeGuid";
        public const string xcache_connection_receive_timeout_milliseconds = "xcache_connection_receive_timeout_milliseconds";
        public const string xcache_connection_send_timeout_milliseconds = "xcache_connection_send_timeout_milliseconds";
        public const string xcache_connectionTimeoutSeconds = "xcache_connectionTimeoutSeconds";
        public const string xcache_db_batchSize = "xcache_db_batchSize";
        public const string xcache_db_pollingInterval = "xcache_db_pollingInterval";
        public const string xcache_db_transactionTimeout = "xcache_db_transactionTimeout";
        public const string xcache_db_usedatabaselocks = "xcache_db_usedatabaselocks";
        public const string xcache_gamertag_hash_buckets = "xcache_gamertag_hash_buckets";
        public const string XCache_MaxClientSockets = "XCache_MaxClientSockets";
        public const string XCache_MaxMessageBytes = "XCache_MaxMessageBytes";
        public const string xcache_maxPipeConnections = "xcache_maxPipeConnections";
        public const string xcache_memory_page_size = "xcache_memory_page_size";
        public const string xcache_passport_hash_buckets = "xcache_passport_hash_buckets";
        public const string XCache_SocketBufferSize = "XCache_SocketBufferSize";
        public const string xcache_test_num_users = "xcache_test_num_users";
        public const string xcache_test_random_seed = "xcache_test_random_seed";
        public const string xcache_userid_hash_buckets = "xcache_userid_hash_buckets";
        public const string xcbk_auditEnabled = "xcbk_auditEnabled";
        public const string xcbk_billingNotificationTimeout = "xcbk_billingNotificationTimeout";
        public const string xcbk_scs_heartbeatTimeout = "xcbk_scs_heartbeatTimeout";
        public const string xcbk_sslCertSubject = "xcbk_sslCertSubject";
        public const string XConnSrv_BulkGetBatchMaxSize = "XConnSrv_BulkGetBatchMaxSize";
        public const string XConnSrv_BytesPerPooledBuffer = "XConnSrv_BytesPerPooledBuffer";
        public const string XConnSrv_DataThreadpoolSize = "XConnSrv_DataThreadpoolSize";
        public const string XConnSrv_MaxClientSockets = "XConnSrv_MaxClientSockets";
        public const string XConnSrv_MaxMessageBytes = "XConnSrv_MaxMessageBytes";
        public const string XConnSrv_MaxObjectsPerMessage = "XConnSrv_MaxObjectsPerMessage";
        public const string XConnSrv_MaxSubscriptionsPerConnection = "XConnSrv_MaxSubscriptionsPerConnection";
        public const string XConnSrv_MemCacheDllName = "XConnSrv_MemCacheDllName";
        public const string XConnSrv_NumLookupTableBuckets = "XConnSrv_NumLookupTableBuckets";
        public const string XConnSrv_SocketBufferSize = "XConnSrv_SocketBufferSize";
        public const string XConnSrv_TCPKeepAliveTimeout = "XConnSrv_TCPKeepAliveTimeout";
        public const string XConnSrv_UseSGAuth = "XConnSrv_UseSGAuth";
        public const string xcrypto_DoRealPakTest = "xcrypto_DoRealPakTest";
        public const string xcrypto_useNCipher = "xcrypto_useNCipher";
        public const string xcrypto_useTestKey = "xcrypto_useTestKey";
        public const string xds_ARPRetryEventThrottle = "xds_ARPRetryEventThrottle";
        public const string xds_ARPRetryIntervalInSeconds = "xds_ARPRetryIntervalInSeconds";
        public const string xds_cacheHashTableSize = "xds_cacheHashTableSize";
        public const string xds_cacheSize = "xds_cacheSize";
        public const string xds_eventCacheThrottleLifeTimeInSeconds = "xds_eventCacheThrottleLifeTimeInSeconds";
        public const string xds_gatewayLookupIntervalInSeconds = "xds_gatewayLookupIntervalInSeconds";
        public const string xds_ICMPReplyAddr = "xds_ICMPReplyAddr";
        public const string xds_infactionLimitPerMinute = "xds_infactionLimitPerMinute";
        public const string xds_maxLogLength = "xds_maxLogLength";
        public const string xds_minICMPRequestLength = "xds_minICMPRequestLength";
        public const string xds_minLogRequestLength = "xds_minLogRequestLength";
        public const string xds_numberOfProcessingThreads = "xds_numberOfProcessingThreads";
        public const string xds_packetBufferSize = "xds_packetBufferSize";
        public const string xds_port = "xds_port";
        public const string xds_skewTimeInMilliSecs = "xds_skewTimeInMilliSecs";
        public const string xds_TOS = "xds_TOS";
        public const string xds_TTL = "xds_TTL";
        public const string xevents_buffers = "xevents_buffers";
        public const string xevents_threads = "xevents_threads";
        public const string xlfsmon_AdminFdURL = "xlfsmon_AdminFdURL";
        public const string xlfsmon_ClientCertificateName = "xlfsmon_ClientCertificateName";
        public const string xlfsmon_ClientCertificateThumbprint = "xlfsmon_ClientCertificateThumbprint";
        public const string xlfsmon_ClientFdURL = "xlfsmon_ClientFdURL";
        public const string xlfsmon_DownloaderPath = "xlfsmon_DownloaderPath";
        public const string xlfsmon_EnvironmentName = "xlfsmon_EnvironmentName";
        public const string xlfsmon_ProxyURL = "xlfsmon_ProxyURL";
        public const string xlfsmon_SaveDirectory = "xlfsmon_SaveDirectory";
        public const string xlfsmon_SubscriptionId = "xlfsmon_SubscriptionId";
        public const string xlfsmon_UseRealSTS = "xlfsmon_UseRealSTS";
        public const string xmatchfd_defaultSessionExpiration = "xmatchfd_defaultSessionExpiration";
        public const string xmatchfd_disableAffiliateQuery = "xmatchfd_disableAffiliateQuery";
        public const string xmatchfd_enableAuthCheck = "xmatchfd_enableAuthCheck";
        public const string xmatchfd_enableTitlePerfCounters = "xmatchfd_enableTitlePerfCounters";
        public const string xmatchfd_fastFailBlockIntervalSeconds = "xmatchfd_fastFailBlockIntervalSeconds";
        public const string xmatchfd_fastFailBucketIntervalSeconds = "xmatchfd_fastFailBucketIntervalSeconds";
        public const string xmatchfd_fastFailNumBuckets = "xmatchfd_fastFailNumBuckets";
        public const string xmatchfd_fastFailReservedThreadsPerDB = "xmatchfd_fastFailReservedThreadsPerDB";
        public const string xmatchfd_fastFailTimeoutThresholdCount = "xmatchfd_fastFailTimeoutThresholdCount";
        public const string xmatchfd_fastFailTimeoutTimespanSeconds = "xmatchfd_fastFailTimeoutTimespanSeconds";
        public const string xmatchfd_fastFailTimeTolerance = "xmatchfd_fastFailTimeTolerance";
        public const string xmatchfd_fastFailTotalSharedThreads = "xmatchfd_fastFailTotalSharedThreads";
        public const string xmatchfd_insertRetries = "xmatchfd_insertRetries";
        public const string xmatchfd_nolockRetries = "xmatchfd_nolockRetries";
        public const string xmatchfd_relaxXenonValidation = "xmatchfd_relaxXenonValidation";
        public const string xmatchfd_sessioncacheexpiration = "xmatchfd_sessioncacheexpiration";
        public const string xmatchfd_valueOfAvoidingMe = "xmatchfd_valueOfAvoidingMe";
        public const string xmatchfd_valueOfCompletedGame = "xmatchfd_valueOfCompletedGame";
        public const string xmatchfd_valueOfFriend = "xmatchfd_valueOfFriend";
        public const string xmatchfd_valueOfNegativeFeedback = "xmatchfd_valueOfNegativeFeedback";
        public const string xmatchfd_valueOfPositiveFeedback = "xmatchfd_valueOfPositiveFeedback";
        public const string xmgmt_area_aainfo = "xmgmt_area_aainfo";
        public const string xmgmt_area_aamodule = "xmgmt_area_aamodule";
        public const string xmgmt_area_AccelerationClient = "xmgmt_area_AccelerationClient";
        public const string xmgmt_area_AccelerationDebug = "xmgmt_area_AccelerationDebug";
        public const string xmgmt_area_AccelerationProxy = "xmgmt_area_AccelerationProxy";
        public const string xmgmt_area_ASkdc = "xmgmt_area_ASkdc";
        public const string xmgmt_area_atTrace = "xmgmt_area_atTrace";
        public const string xmgmt_area_audit = "xmgmt_area_audit";
        public const string xmgmt_area_authsglog = "xmgmt_area_authsglog";
        public const string xmgmt_area_authsgtrace = "xmgmt_area_authsgtrace";
        public const string xmgmt_area_bcfgtrace = "xmgmt_area_bcfgtrace";
        public const string xmgmt_area_blackbox = "xmgmt_area_blackbox";
        public const string xmgmt_area_blstTrace = "xmgmt_area_blstTrace";
        public const string xmgmt_area_catalog = "xmgmt_area_catalog";
        public const string xmgmt_area_catalogwatcherlog = "xmgmt_area_catalogwatcherlog";
        public const string xmgmt_area_cfgtrace = "xmgmt_area_cfgtrace";
        public const string xmgmt_area_checkready = "xmgmt_area_checkready";
        public const string xmgmt_area_cleanclips = "xmgmt_area_cleanclips";
        public const string xmgmt_area_cleansermissingdata = "xmgmt_area_cleansermissingdata";
        public const string xmgmt_area_cleansertrace = "xmgmt_area_cleansertrace";
        public const string xmgmt_area_computil = "xmgmt_area_computil";
        public const string xmgmt_area_contentutiltrace = "xmgmt_area_contentutiltrace";
        public const string xmgmt_area_crontest = "xmgmt_area_crontest";
        public const string xmgmt_area_crontrace = "xmgmt_area_crontrace";
        public const string xmgmt_area_cryptomgr = "xmgmt_area_cryptomgr";
        public const string xmgmt_area_cryptotools = "xmgmt_area_cryptotools";
        public const string xmgmt_area_ctpTransactionServiceLog = "xmgmt_area_ctpTransactionServiceLog";
        public const string xmgmt_area_ctpTransactionServiceTrace = "xmgmt_area_ctpTransactionServiceTrace";
        public const string xmgmt_area_ctxDebug = "xmgmt_area_ctxDebug";
        public const string xmgmt_area_deactivator = "xmgmt_area_deactivator";
        public const string xmgmt_area_Debug = "xmgmt_area_Debug";
        public const string xmgmt_area_DefaultNtLog = "xmgmt_area_DefaultNtLog";
        public const string xmgmt_area_DefaultTrace = "xmgmt_area_DefaultTrace";
        public const string xmgmt_area_dmplog = "xmgmt_area_dmplog";
        public const string xmgmt_area_dmptrace = "xmgmt_area_dmptrace";
        public const string xmgmt_area_domTrace = "xmgmt_area_domTrace";
        public const string xmgmt_area_DOS = "xmgmt_area_DOS";
        public const string xmgmt_area_ElimEntrants = "xmgmt_area_ElimEntrants";
        public const string xmgmt_area_ElimEvents = "xmgmt_area_ElimEvents";
        public const string xmgmt_area_Elimination = "xmgmt_area_Elimination";
        public const string xmgmt_area_elimtest = "xmgmt_area_elimtest";
        public const string xmgmt_area_enfTrace = "xmgmt_area_enfTrace";
        public const string xmgmt_area_enmrdfTrace = "xmgmt_area_enmrdfTrace";
        public const string xmgmt_area_espengine = "xmgmt_area_espengine";
        public const string xmgmt_area_EventService = "xmgmt_area_EventService";
        public const string xmgmt_area_feedbacklog = "xmgmt_area_feedbacklog";
        public const string xmgmt_area_FeedbackProxy = "xmgmt_area_FeedbackProxy";
        public const string xmgmt_area_feedbackTrace = "xmgmt_area_feedbackTrace";
        public const string xmgmt_area_finbusLog = "xmgmt_area_finbusLog";
        public const string xmgmt_area_finbusTrace = "xmgmt_area_finbusTrace";
        public const string xmgmt_area_FlokenMap = "xmgmt_area_FlokenMap";
        public const string xmgmt_area_fseLog = "xmgmt_area_fseLog";
        public const string xmgmt_area_fseTrace = "xmgmt_area_fseTrace";
        public const string xmgmt_area_geoFenceLog = "xmgmt_area_geoFenceLog";
        public const string xmgmt_area_geoFenceTrace = "xmgmt_area_geoFenceTrace";
        public const string xmgmt_area_GetPostalCode = "xmgmt_area_GetPostalCode";
        public const string xmgmt_area_glcTrace = "xmgmt_area_glcTrace";
        public const string xmgmt_area_graduateUserTrace = "xmgmt_area_graduateUserTrace";
        public const string xmgmt_area_gtqTrace = "xmgmt_area_gtqTrace";
        public const string xmgmt_area_Integration = "xmgmt_area_Integration";
        public const string xmgmt_area_KdcBase = "xmgmt_area_KdcBase";
        public const string xmgmt_area_KdcCore = "xmgmt_area_KdcCore";
        public const string xmgmt_area_kdcmanaged = "xmgmt_area_kdcmanaged";
        public const string xmgmt_area_LbsTrace = "xmgmt_area_LbsTrace";
        public const string xmgmt_area_lbsvrclient = "xmgmt_area_lbsvrclient";
        public const string xmgmt_area_listsTrace = "xmgmt_area_listsTrace";
        public const string xmgmt_area_livecachelog = "xmgmt_area_livecachelog";
        public const string xmgmt_area_livecachetrace = "xmgmt_area_livecachetrace";
        public const string xmgmt_area_livepxy = "xmgmt_area_livepxy";
        public const string xmgmt_area_livepxylog = "xmgmt_area_livepxylog";
        public const string xmgmt_area_log = "xmgmt_area_log";
        public const string xmgmt_area_LogCleanser = "xmgmt_area_LogCleanser";
        public const string xmgmt_area_LogCode = "xmgmt_area_LogCode";
        public const string xmgmt_area_LogCodeWindows = "xmgmt_area_LogCodeWindows";
        public const string xmgmt_area_LogCollectorModuleLog = "xmgmt_area_LogCollectorModuleLog";
        public const string xmgmt_area_logCollectorModuleTrace = "xmgmt_area_logCollectorModuleTrace";
        public const string xmgmt_area_LogDvd = "xmgmt_area_LogDvd";
        public const string xmgmt_area_LogTitle = "xmgmt_area_LogTitle";
        public const string xmgmt_area_LogWindows = "xmgmt_area_LogWindows";
        public const string xmgmt_area_lua = "xmgmt_area_lua";
        public const string xmgmt_area_marketplacecatalog = "xmgmt_area_marketplacecatalog";
        public const string xmgmt_area_matchdblog = "xmgmt_area_matchdblog";
        public const string xmgmt_area_matchdbtrace = "xmgmt_area_matchdbtrace";
        public const string xmgmt_area_matchprestrace = "xmgmt_area_matchprestrace";
        public const string xmgmt_area_MatchProxy = "xmgmt_area_MatchProxy";
        public const string xmgmt_area_matchtrace = "xmgmt_area_matchtrace";
        public const string xmgmt_area_MessageProxy = "xmgmt_area_MessageProxy";
        public const string xmgmt_area_messagingfd = "xmgmt_area_messagingfd";
        public const string xmgmt_area_messagingfdLog = "xmgmt_area_messagingfdLog";
        public const string xmgmt_area_MessagingLog = "xmgmt_area_MessagingLog";
        public const string xmgmt_area_metro = "xmgmt_area_metro";
        public const string xmgmt_area_mllog = "xmgmt_area_mllog";
        public const string xmgmt_area_mltrace = "xmgmt_area_mltrace";
        public const string xmgmt_area_msgmanager = "xmgmt_area_msgmanager";
        public const string xmgmt_area_msnrraggregationlog = "xmgmt_area_msnrraggregationlog";
        public const string xmgmt_area_msnrraggregationtrace = "xmgmt_area_msnrraggregationtrace";
        public const string xmgmt_area_msnrrLog = "xmgmt_area_msnrrLog";
        public const string xmgmt_area_msnrrTrace = "xmgmt_area_msnrrTrace";
        public const string xmgmt_area_musicnetLog = "xmgmt_area_musicnetLog";
        public const string xmgmt_area_musicnetTrace = "xmgmt_area_musicnetTrace";
        public const string xmgmt_area_nametrace = "xmgmt_area_nametrace";
        public const string xmgmt_area_NicMgr = "xmgmt_area_NicMgr";
        public const string xmgmt_area_NotificationDebug = "xmgmt_area_NotificationDebug";
        public const string xmgmt_area_NotificationLog = "xmgmt_area_NotificationLog";
        public const string xmgmt_area_nrTrace = "xmgmt_area_nrTrace";
        public const string xmgmt_area_offer = "xmgmt_area_offer";
        public const string xmgmt_area_oledbw = "xmgmt_area_oledbw";
        public const string xmgmt_area_passportLog = "xmgmt_area_passportLog";
        public const string xmgmt_area_passportTrace = "xmgmt_area_passportTrace";
        public const string xmgmt_area_pathTrace = "xmgmt_area_pathTrace";
        public const string xmgmt_area_PingLog = "xmgmt_area_PingLog";
        public const string xmgmt_area_PipeDbg = "xmgmt_area_PipeDbg";
        public const string xmgmt_area_plugintest = "xmgmt_area_plugintest";
        public const string xmgmt_area_Policy = "xmgmt_area_Policy";
        public const string xmgmt_area_PPALoader = "xmgmt_area_PPALoader";
        public const string xmgmt_area_PresenceDebug = "xmgmt_area_PresenceDebug";
        public const string xmgmt_area_PresenceFDDebug = "xmgmt_area_PresenceFDDebug";
        public const string xmgmt_area_PresenceFDLog = "xmgmt_area_PresenceFDLog";
        public const string xmgmt_area_PresenceLog = "xmgmt_area_PresenceLog";
        public const string xmgmt_area_PresenceProxy = "xmgmt_area_PresenceProxy";
        public const string xmgmt_area_PresenceRPDebug = "xmgmt_area_PresenceRPDebug";
        public const string xmgmt_area_profilelog = "xmgmt_area_profilelog";
        public const string xmgmt_area_progresslog = "xmgmt_area_progresslog";
        public const string xmgmt_area_prov = "xmgmt_area_prov";
        public const string xmgmt_area_provdr = "xmgmt_area_provdr";
        public const string xmgmt_area_provisioning = "xmgmt_area_provisioning";
        public const string xmgmt_area_pss = "xmgmt_area_pss";
        public const string xmgmt_area_puidmgr = "xmgmt_area_puidmgr";
        public const string xmgmt_area_QFlag = "xmgmt_area_QFlag";
        public const string xmgmt_area_QueryTest = "xmgmt_area_QueryTest";
        public const string xmgmt_area_ratingstrace = "xmgmt_area_ratingstrace";
        public const string xmgmt_area_rdfTrace = "xmgmt_area_rdfTrace";
        public const string xmgmt_area_readsitekeys = "xmgmt_area_readsitekeys";
        public const string xmgmt_area_replacePassportTrace = "xmgmt_area_replacePassportTrace";
        public const string xmgmt_area_ReportConnection = "xmgmt_area_ReportConnection";
        public const string xmgmt_area_Reporting = "xmgmt_area_Reporting";
        public const string xmgmt_area_Reporting_v2 = "xmgmt_area_Reporting_v2";
        public const string xmgmt_area_rfhTrace = "xmgmt_area_rfhTrace";
        public const string xmgmt_area_rmfTrace = "xmgmt_area_rmfTrace";
        public const string xmgmt_area_selog = "xmgmt_area_selog";
        public const string xmgmt_area_serialnumber = "xmgmt_area_serialnumber";
        public const string xmgmt_area_ServHlpDebug = "xmgmt_area_ServHlpDebug";
        public const string xmgmt_area_SgClientStats = "xmgmt_area_SgClientStats";
        public const string xmgmt_area_sginfotrace = "xmgmt_area_sginfotrace";
        public const string xmgmt_area_SGProxy = "xmgmt_area_SGProxy";
        public const string xmgmt_area_soaptrace = "xmgmt_area_soaptrace";
        public const string xmgmt_area_SocialCacheAPI = "xmgmt_area_SocialCacheAPI";
        public const string xmgmt_area_SocialCacheConnection = "xmgmt_area_SocialCacheConnection";
        public const string xmgmt_area_SocialCacheLog = "xmgmt_area_SocialCacheLog";
        public const string xmgmt_area_spslog = "xmgmt_area_spslog";
        public const string xmgmt_area_spsproxy = "xmgmt_area_spsproxy";
        public const string xmgmt_area_spsproxyLog = "xmgmt_area_spsproxyLog";
        public const string xmgmt_area_spsqueuetrace = "xmgmt_area_spsqueuetrace";
        public const string xmgmt_area_spstrace = "xmgmt_area_spstrace";
        public const string xmgmt_area_sqltrace = "xmgmt_area_sqltrace";
        public const string xmgmt_area_statslog = "xmgmt_area_statslog";
        public const string xmgmt_area_stfdTrace = "xmgmt_area_stfdTrace";
        public const string xmgmt_area_stlog = "xmgmt_area_stlog";
        public const string xmgmt_area_storageHealthTrace = "xmgmt_area_storageHealthTrace";
        public const string xmgmt_area_StorageModuleLog = "xmgmt_area_StorageModuleLog";
        public const string xmgmt_area_storageModuleTrace = "xmgmt_area_storageModuleTrace";
        public const string xmgmt_area_storageUtilsTrace = "xmgmt_area_storageUtilsTrace";
        public const string xmgmt_area_stringLog = "xmgmt_area_stringLog";
        public const string xmgmt_area_StringProxy = "xmgmt_area_StringProxy";
        public const string xmgmt_area_stringSvrHealthTrace = "xmgmt_area_stringSvrHealthTrace";
        public const string xmgmt_area_stringTrace = "xmgmt_area_stringTrace";
        public const string xmgmt_area_sts = "xmgmt_area_sts";
        public const string xmgmt_area_ststrace = "xmgmt_area_ststrace";
        public const string xmgmt_area_subcodemgr = "xmgmt_area_subcodemgr";
        public const string xmgmt_area_switchPassportTrace = "xmgmt_area_switchPassportTrace";
        public const string xmgmt_area_synccastLog = "xmgmt_area_synccastLog";
        public const string xmgmt_area_synccastTrace = "xmgmt_area_synccastTrace";
        public const string xmgmt_area_TagRecycleCronJobs = "xmgmt_area_TagRecycleCronJobs";
        public const string xmgmt_area_TALKER = "xmgmt_area_TALKER";
        public const string xmgmt_area_TCPCnt = "xmgmt_area_TCPCnt";
        public const string xmgmt_area_TCPConnection = "xmgmt_area_TCPConnection";
        public const string xmgmt_area_TeamProxy = "xmgmt_area_TeamProxy";
        public const string xmgmt_area_TeamsLog = "xmgmt_area_TeamsLog";
        public const string xmgmt_area_Test = "xmgmt_area_Test";
        public const string xmgmt_area_testfd = "xmgmt_area_testfd";
        public const string xmgmt_area_TestUtilities = "xmgmt_area_TestUtilities";
        public const string xmgmt_area_title = "xmgmt_area_title";
        public const string xmgmt_area_tmrlog = "xmgmt_area_tmrlog";
        public const string xmgmt_area_tokenTrace = "xmgmt_area_tokenTrace";
        public const string xmgmt_area_toolspslog = "xmgmt_area_toolspslog";
        public const string xmgmt_area_ToolsSrv = "xmgmt_area_ToolsSrv";
        public const string xmgmt_area_ToolsSrvLog = "xmgmt_area_ToolsSrvLog";
        public const string xmgmt_area_trace = "xmgmt_area_trace";
        public const string xmgmt_area_UDPADAPT = "xmgmt_area_UDPADAPT";
        public const string xmgmt_area_UDPADPTLog = "xmgmt_area_UDPADPTLog";
        public const string xmgmt_area_UDPMGR = "xmgmt_area_UDPMGR";
        public const string xmgmt_area_UNITTEST = "xmgmt_area_UNITTEST";
        public const string xmgmt_area_user2 = "xmgmt_area_user2";
        public const string xmgmt_area_userbillinginfo = "xmgmt_area_userbillinginfo";
        public const string xmgmt_area_Vlan = "xmgmt_area_Vlan";
        public const string xmgmt_area_VortexFlow = "xmgmt_area_VortexFlow";
        public const string xmgmt_area_VortexOutput = "xmgmt_area_VortexOutput";
        public const string xmgmt_area_VortexOutputUnknown = "xmgmt_area_VortexOutputUnknown";
        public const string xmgmt_area_VortexTrace = "xmgmt_area_VortexTrace";
        public const string xmgmt_area_voucher = "xmgmt_area_voucher";
        public const string xmgmt_area_wcAlertsLog = "xmgmt_area_wcAlertsLog";
        public const string xmgmt_area_wcgenerallog = "xmgmt_area_wcgenerallog";
        public const string xmgmt_area_wcgeneraltrace = "xmgmt_area_wcgeneraltrace";
        public const string xmgmt_area_wcMessagingLog = "xmgmt_area_wcMessagingLog";
        public const string xmgmt_area_wcMessagingTrace = "xmgmt_area_wcMessagingTrace";
        public const string xmgmt_area_wcmusiclog = "xmgmt_area_wcmusiclog";
        public const string xmgmt_area_wcpresencelog = "xmgmt_area_wcpresencelog";
        public const string xmgmt_area_wcQueryLog = "xmgmt_area_wcQueryLog";
        public const string xmgmt_area_wcsignaturelog = "xmgmt_area_wcsignaturelog";
        public const string xmgmt_area_wcstatscache = "xmgmt_area_wcstatscache";
        public const string xmgmt_area_wcstatsdomain = "xmgmt_area_wcstatsdomain";
        public const string xmgmt_area_wcstatslog = "xmgmt_area_wcstatslog";
        public const string xmgmt_area_wcstatstrace = "xmgmt_area_wcstatstrace";
        public const string xmgmt_area_wcstoragelog = "xmgmt_area_wcstoragelog";
        public const string xmgmt_area_wcteamslog = "xmgmt_area_wcteamslog";
        public const string xmgmt_area_wctoolsmgmtlog = "xmgmt_area_wctoolsmgmtlog";
        public const string xmgmt_area_wctoolsmgmttrace = "xmgmt_area_wctoolsmgmttrace";
        public const string xmgmt_area_wcuserslog = "xmgmt_area_wcuserslog";
        public const string xmgmt_area_wcutilitieslog = "xmgmt_area_wcutilitieslog";
        public const string xmgmt_area_wcutilitiestrace = "xmgmt_area_wcutilitiestrace";
        public const string xmgmt_area_websg = "xmgmt_area_websg";
        public const string xmgmt_area_WINHTTP = "xmgmt_area_WINHTTP";
        public const string xmgmt_area_WireDataBin = "xmgmt_area_WireDataBin";
        public const string xmgmt_area_WireDataTxt = "xmgmt_area_WireDataTxt";
        public const string xmgmt_area_wmisLog = "xmgmt_area_wmisLog";
        public const string xmgmt_area_wmisTrace = "xmgmt_area_wmisTrace";
        public const string xmgmt_area_wrfTrace = "xmgmt_area_wrfTrace";
        public const string xmgmt_area_wsttrace = "xmgmt_area_wsttrace";
        public const string xmgmt_area_xarblog = "xmgmt_area_xarblog";
        public const string xmgmt_area_XBancClient = "xmgmt_area_XBancClient";
        public const string xmgmt_area_XBancDebug = "xmgmt_area_XBancDebug";
        public const string xmgmt_area_XBancProxy = "xmgmt_area_XBancProxy";
        public const string xmgmt_area_xbos = "xmgmt_area_xbos";
        public const string xmgmt_area_xboxcom = "xmgmt_area_xboxcom";
        public const string xmgmt_area_XCacheClient = "xmgmt_area_XCacheClient";
        public const string xmgmt_area_XCacheData = "xmgmt_area_XCacheData";
        public const string xmgmt_area_XCacheDatabase = "xmgmt_area_XCacheDatabase";
        public const string xmgmt_area_XCacheLog = "xmgmt_area_XCacheLog";
        public const string xmgmt_area_XCacheLookup = "xmgmt_area_XCacheLookup";
        public const string xmgmt_area_XCacheProxy = "xmgmt_area_XCacheProxy";
        public const string xmgmt_area_XCacheService = "xmgmt_area_XCacheService";
        public const string xmgmt_area_xcbk = "xmgmt_area_xcbk";
        public const string xmgmt_area_XConnSrvAPI = "xmgmt_area_XConnSrvAPI";
        public const string xmgmt_area_XConnSrvCache = "xmgmt_area_XConnSrvCache";
        public const string xmgmt_area_XConnSrvConnection = "xmgmt_area_XConnSrvConnection";
        public const string xmgmt_area_XConnSrvLog = "xmgmt_area_XConnSrvLog";
        public const string xmgmt_area_XConnSrvSubscription = "xmgmt_area_XConnSrvSubscription";
        public const string xmgmt_area_XDb = "xmgmt_area_XDb";
        public const string xmgmt_area_Xds = "xmgmt_area_Xds";
        public const string xmgmt_area_Xkdc = "xmgmt_area_Xkdc";
        public const string xmgmt_area_XkdcTicketLog = "xmgmt_area_XkdcTicketLog";
        public const string xmgmt_area_xlastutil = "xmgmt_area_xlastutil";
        public const string xmgmt_area_xlisttrace = "xmgmt_area_xlisttrace";
        public const string xmgmt_area_xmachine = "xmgmt_area_xmachine";
        public const string xmgmt_area_XMACS = "xmgmt_area_XMACS";
        public const string xmgmt_area_XMGMT = "xmgmt_area_XMGMT";
        public const string xmgmt_area_XomInstrumentation = "xmgmt_area_XomInstrumentation";
        public const string xmgmt_area_xqry = "xmgmt_area_xqry";
        public const string xmgmt_area_xrltrace = "xmgmt_area_xrltrace";
        public const string xmgmt_area_xsig = "xmgmt_area_xsig";
        public const string xmgmt_area_xsiglog = "xmgmt_area_xsiglog";
        public const string xmgmt_area_xsuppapi = "xmgmt_area_xsuppapi";
        public const string xmgmt_area_xsuppapiEmailSentLog = "xmgmt_area_xsuppapiEmailSentLog";
        public const string xmgmt_area_xsuppapiLog = "xmgmt_area_xsuppapiLog";
        public const string xmgmt_area_xuacs = "xmgmt_area_xuacs";
        public const string xmgmt_area_XWireTap = "xmgmt_area_XWireTap";
        public const string xmgmt_area_XWireTapHash = "xmgmt_area_XWireTapHash";
        public const string xmgmt_area_XWireTapNicMgr = "xmgmt_area_XWireTapNicMgr";
        public const string xmgmt_area_XWireTapProdCons = "xmgmt_area_XWireTapProdCons";
        public const string xmgmt_default_target_settings = "xmgmt_default_target_settings";
        public const string xmgmt_ntevents = "xmgmt_ntevents";
        public const string xmgmt_target_ = "xmgmt_target_";
        public const string xmgmt_target_catalogwatcherlog = "xmgmt_target_catalogwatcherlog";
        public const string xmgmt_target_cleansermissingdata = "xmgmt_target_cleansermissingdata";
        public const string xmgmt_target_ctpTransactionServiceLog = "xmgmt_target_ctpTransactionServiceLog";
        public const string xmgmt_target_dmplog = "xmgmt_target_dmplog";
        public const string xmgmt_target_espengine = "xmgmt_target_espengine";
        public const string xmgmt_target_geofencelog = "xmgmt_target_geofencelog";
        public const string xmgmt_target_log = "xmgmt_target_log";
        public const string xmgmt_target_logcleanser = "xmgmt_target_logcleanser";
        public const string xmgmt_target_logcode = "xmgmt_target_logcode";
        public const string xmgmt_target_logcodewindows = "xmgmt_target_logcodewindows";
        public const string xmgmt_target_logdvd = "xmgmt_target_logdvd";
        public const string xmgmt_target_logwindows = "xmgmt_target_logwindows";
        public const string xmgmt_target_lua = "xmgmt_target_lua";
        public const string xmgmt_target_msglog = "xmgmt_target_msglog";
        public const string xmgmt_target_msnrraggregationlog = "xmgmt_target_msnrraggregationlog";
        public const string xmgmt_target_musicnetlog = "xmgmt_target_musicnetlog";
        public const string xmgmt_target_notlog = "xmgmt_target_notlog";
        public const string xmgmt_target_passportlog = "xmgmt_target_passportlog";
        public const string xmgmt_target_preslog = "xmgmt_target_preslog";
        public const string xmgmt_target_remote = "xmgmt_target_remote";
        public const string xmgmt_target_report = "xmgmt_target_report";
        public const string xmgmt_target_sgclientstats = "xmgmt_target_sgclientstats";
        public const string xmgmt_target_spslog = "xmgmt_target_spslog";
        public const string xmgmt_target_synccastlog = "xmgmt_target_synccastlog";
        public const string xmgmt_target_teamslog = "xmgmt_target_teamslog";
        public const string xmgmt_target_ticketlog = "xmgmt_target_ticketlog";
        public const string xmgmt_target_wmislog = "xmgmt_target_wmislog";
        public const string xmgmt_target_xdslog = "xmgmt_target_xdslog";
        public const string xmgmt_target_XomInstrumentationLog = "xmgmt_target_XomInstrumentationLog";
        public const string xmgmt_target_xsuppapiemaillog = "xmgmt_target_xsuppapiemaillog";
        public const string xmgmt_target_xsuppapilog = "xmgmt_target_xsuppapilog";
        public const string xmgmt_targets = "xmgmt_targets";
        public const string xmstv_accessInfoUri = "xmstv_accessInfoUri";
        public const string xmstv_crldp = "xmstv_crldp";
        public const string xmstv_issuerCertName = "xmstv_issuerCertName";
        public const string xmstv_lastCaRevocationTicks = "xmstv_lastCaRevocationTicks";
        public const string xmstv_maximumCertificatesAllowed = "xmstv_maximumCertificatesAllowed";
        public const string xmstv_subjectNameSuffix = "xmstv_subjectNameSuffix";
        public const string xrlscan_allowHead = "xrlscan_allowHead";
        public const string xrlutil_allowAlternateUrl = "xrlutil_allowAlternateUrl";
        public const string xsts_issuer_name = "xsts_issuer_name";
        public const string xsts_signing_cert_name = "xsts_signing_cert_name";
        public const string xsuppapi_extraLicensesIncrementBy = "xsuppapi_extraLicensesIncrementBy";
        public const string xsuppapi_extraLicensesMaximum = "xsuppapi_extraLicensesMaximum";
        public const string xsuppapi_FNCFormatString = "xsuppapi_FNCFormatString";
        public const string xsuppapi_FNCRegenMaxTries = "xsuppapi_FNCRegenMaxTries";
        public const string xsuppapi_Xbox1AccountFNCFlags = "xsuppapi_Xbox1AccountFNCFlags";
        public const string xsuppapi_XboxComAccountFNCFlags = "xsuppapi_XboxComAccountFNCFlags";
        public const string xsuppapi_XenonAccountGoldFNCFlags = "xsuppapi_XenonAccountGoldFNCFlags";
        public const string xsuppapi_XenonAccountSilverFNCFlags = "xsuppapi_XenonAccountSilverFNCFlags";
        public const string xsuppapi_ZuneAccountFNCFlags = "xsuppapi_ZuneAccountFNCFlags";
        public const string xtou_cacheDurationSeconds = "xtou_cacheDurationSeconds";
        public const string xuacs_allowClearSubscriptions = "xuacs_allowClearSubscriptions";
        public const string xuacs_allowDisableSubscription = "xuacs_allowDisableSubscription";
        public const string xuacs_allowGetNoAgeOut = "xuacs_allowGetNoAgeOut";
        public const string xuacs_allowSetUserAccountStatus = "xuacs_allowSetUserAccountStatus";
        public const string xuacs_allowSetUserSettings2 = "xuacs_allowSetUserSettings2";
        public const string xuacs_allowUncheckedRecovery = "xuacs_allowUncheckedRecovery";
        public const string xuacs_auditEnabled = "xuacs_auditEnabled";
        public const string xuacs_autoGenCC = "xuacs_autoGenCC";
        public const string xuacs_billingdecline_notificationcount = "xuacs_billingdecline_notificationcount";
        public const string xuacs_defaultGamercardReputation = "xuacs_defaultGamercardReputation";
        public const string xuacs_domain = "xuacs_domain";
        public const string xuacs_familyGoldAssignmentCoolDownWaitIntervalDays = "xuacs_familyGoldAssignmentCoolDownWaitIntervalDays";
        public const string xuacs_familyGoldAssignmentDistinctUsers = "xuacs_familyGoldAssignmentDistinctUsers";
        public const string xuacs_familyGoldAssignmentThrottlingWindowDays = "xuacs_familyGoldAssignmentThrottlingWindowDays";
        public const string xuacs_familyGoldChangeWaitIntervalHours = "xuacs_familyGoldChangeWaitIntervalHours";
        public const string xuacs_FamilyGoldConvertionRatio = "xuacs_FamilyGoldConvertionRatio";
        public const string xuacs_gamertagChangeWaitIntervalHours = "xuacs_gamertagChangeWaitIntervalHours";
        public const string xuacs_generateGamertagMinsToReserve = "xuacs_generateGamertagMinsToReserve";
        public const string xuacs_graduateUserPumpQueue = "xuacs_graduateUserPumpQueue";
        public const string xuacs_graduateUserQueuePumpIntervalSeconds = "xuacs_graduateUserQueuePumpIntervalSeconds";
        public const string xuacs_graduateUserQueuePumpRetryLimit = "xuacs_graduateUserQueuePumpRetryLimit";
        public const string xuacs_hijackingIntervalHours = "xuacs_hijackingIntervalHours";
        public const string xuacs_link_failureWindowMinutes = "xuacs_link_failureWindowMinutes";
        public const string xuacs_link_maxFailedAttempts = "xuacs_link_maxFailedAttempts";
        public const string xuacs_machineGamertagIntervalDays = "xuacs_machineGamertagIntervalDays";
        public const string xuacs_machineGamertagThreshold = "xuacs_machineGamertagThreshold";
        public const string xuacs_machinePassportIntervalDays = "xuacs_machinePassportIntervalDays";
        public const string xuacs_machinePassportThreshold = "xuacs_machinePassportThreshold";
        public const string xuacs_machineRecoveryIntervalDays = "xuacs_machineRecoveryIntervalDays";
        public const string xuacs_machineRecoveryThreshold = "xuacs_machineRecoveryThreshold";
        public const string xuacs_max_family_dependents = "xuacs_max_family_dependents";
        public const string xuacs_passport_generateddomain = "xuacs_passport_generateddomain";
        public const string xuacs_passport_generatedprefix = "xuacs_passport_generatedprefix";
        public const string xuacs_passportChangeWaitIntervalHours = "xuacs_passportChangeWaitIntervalHours";
        public const string xuacs_PassportCreateGeneratedRetries = "xuacs_PassportCreateGeneratedRetries";
        public const string xuacs_replaceUserPassportDaysBetween = "xuacs_replaceUserPassportDaysBetween";
        public const string xuacs_replaceUserPassportPumpQueue = "xuacs_replaceUserPassportPumpQueue";
        public const string xuacs_replaceUserPassportQueuePumpIntervalSeconds = "xuacs_replaceUserPassportQueuePumpIntervalSeconds";
        public const string xuacs_replaceUserPassportQueuePumpRetryLimit = "xuacs_replaceUserPassportQueuePumpRetryLimit";
        public const string xuacs_restore_failureWindowMinutes = "xuacs_restore_failureWindowMinutes";
        public const string xuacs_restore_maxFailedAttempts = "xuacs_restore_maxFailedAttempts";
        public const string xuacs_seedbasedGamertagDefault = "xuacs_seedbasedGamertagDefault";
        public const string xuacs_setNoAgeOutQueueIntervalSeconds = "xuacs_setNoAgeOutQueueIntervalSeconds";
        public const string xuacs_setNoAgeOutQueueRetryLimit = "xuacs_setNoAgeOutQueueRetryLimit";
        public const string xuacs_setNoAgeOutQueueStart = "xuacs_setNoAgeOutQueueStart";
        public const string xuacs_subscriptionNotificationWindowDays = "xuacs_subscriptionNotificationWindowDays";
        public const string xuacs_subscriptionTenureGracePeriodDays = "xuacs_subscriptionTenureGracePeriodDays";
        public const string xuacs_switchUserCountryAllowMultipleSubscriptions = "xuacs_switchUserCountryAllowMultipleSubscriptions";
        public const string xuacs_switchUserCountryConsiderExpiredSeconds = "xuacs_switchUserCountryConsiderExpiredSeconds";
        public const string xuacs_switchUserCountryDaysBetween = "xuacs_switchUserCountryDaysBetween";
        public const string xuacs_switchUserCountryMigrateAccountOfferId = "xuacs_switchUserCountryMigrateAccountOfferId";
        public const string xuacs_switchUserCountryPumpQueue = "xuacs_switchUserCountryPumpQueue";
        public const string xuacs_switchUserCountryQueuePumpIntervalSeconds = "xuacs_switchUserCountryQueuePumpIntervalSeconds";
        public const string xuacs_switchUserCountryRetryTimeoutsImmediately = "xuacs_switchUserCountryRetryTimeoutsImmediately";
        public const string xuacs_switchUserPassportDaysBetween = "xuacs_switchUserPassportDaysBetween";
        public const string xuacs_switchUserPassportPumpQueue = "xuacs_switchUserPassportPumpQueue";
        public const string xuacs_switchUserPassportQueuePumpIntervalSeconds = "xuacs_switchUserPassportQueuePumpIntervalSeconds";
        public const string xuacs_switchUserPassportQueuePumpRetryLimit = "xuacs_switchUserPassportQueuePumpRetryLimit";
        public const string xuacs_trialSubscriptionNotificationWindowDays = "xuacs_trialSubscriptionNotificationWindowDays";
        public const string xuacs_userDateWindowForThrottling = "xuacs_userDateWindowForThrottling";
        public const string xuacs_userGamertagIntervalDays = "xuacs_userGamertagIntervalDays";
        public const string xuacs_userGamertagThreshold = "xuacs_userGamertagThreshold";
        public const string xuacs_userNumberOfAccountsPerMachineId = "xuacs_userNumberOfAccountsPerMachineId";
        public const string xuacs_userPassportIntervalDays = "xuacs_userPassportIntervalDays";
        public const string xuacs_userPassportThreshold = "xuacs_userPassportThreshold";
        public const string xuacs_userRecoveryIntervalDays = "xuacs_userRecoveryIntervalDays";
        public const string xuacs_userRecoveryThreshold = "xuacs_userRecoveryThreshold";
        public const string xuacs_WelcomeToXboxLiveMessageForGeneratedAccount = "xuacs_WelcomeToXboxLiveMessageForGeneratedAccount";
        public const string xuacs_xonwatch_creditCard = "xuacs_xonwatch_creditCard";
        public const string xuacs_xonwatch_ips = "xuacs_xonwatch_ips";
        public const string xuacs_xonwatch_voucher = "xuacs_xonwatch_voucher";

        // An array used by the SettingChangeFilter defined by the config library. Items not in this array will not have changes
        // to the settings data in NPDB propigated into the Config class' caches and will not be offered to the Config client code.
        // Add a dynamic="true" attribute to a setting element in the configItems.xml file to have that setting automatically included in this array.
          
        public static string[] DynamicSettings = new string[]
        {
  
               "aainfo_xbancExpirationInSeconds",
               "aamodule_antidosBanTimeInSeconds",
               "aamodule_antidosBlockingThreshold",
               "aamodule_antidosMaxRecordsToTrack",
               "aamodule_antidosThrottlingThreshold",
               "aamodule_antidosTrackingThreshold",
               "aamodule_ignoreHost",
               "aamodule_Rps_site",
               "aamodule_sts_deviceId_cert_subject_prefix",
               "aamodule_useLoadBalancerSslHeaders",
               "abch_fastFailBlockIntervalSeconds",
               "abch_fastFailTimeoutThresholdCount",
               "abch_fastFailTimeoutTimespanSeconds",
               "acceleration_context_duration_alert_limit",
               "acceleration_fastFailBlockIntervalSeconds",
               "acceleration_fastFailTimeoutThresholdCount",
               "acceleration_fastFailTimeoutTimespanSeconds",
               "acceleration_heartbeat_interval",
               "acceleration_localCacheItemDuration",
               "acceleration_localCacheMaxSize",
               "acceleration_low_water_data_storage_bytes",
               "acceleration_notificationPollInterval",
               "acceleration_record_maintenance_period",
               "acceleration_replyTimeout",
               "acceleration_total_data_storage_bytes",
               "authsg_allowlistheadersincoming",
               "authsg_allowlistheadersoutgoing",
               "authsg_sslCertSubject",
               "authsg_timeoutInSeconds",
               "authsg_whitelistheaders",
               "bdk_auditEnabled",
               "bif_AllowBehaviorInjections",
               "billing_activateTokenTimeout",
               "billing_activateTokenTimeout_LiveService",
               "billing_activateTokenTimeout_Xbox1",
               "billing_addCommentTimeout",
               "billing_addCommentTimeout_LiveService",
               "billing_addCommentTimeout_Xbox1",
               "billing_addPaymentInstrumentTimeout",
               "billing_addPaymentInstrumentTimeout_LiveService",
               "billing_addPaymentInstrumentTimeout_Xbox1",
               "billing_addRoleAssignmentTimeout",
               "billing_addRoleAssignmentTimeout_LiveService",
               "billing_addRoleAssignmentTimeout_Xbox1",
               "billing_addViolationTimeout",
               "billing_addViolationTimeout_LiveService",
               "billing_addViolationTimeout_Xbox1",
               "billing_allowEditorialPurchasesAsZeroPoints",
               "billing_allowFakeActivationCode",
               "billing_allowInjectedScsErrorInRequest",
               "billing_allowUrlOverrideInRequest",
               "billing_bdkUrl",
               "billing_calculateTaxTimeout",
               "billing_calculateTaxTimeout_LiveService",
               "billing_calculateTaxTimeout_Xbox1",
               "billing_cancelSubscriptionTimeout",
               "billing_cancelSubscriptionTimeout_LiveService",
               "billing_cancelSubscriptionTimeout_Xbox1",
               "billing_checkProvisioningStatusTimeout",
               "billing_checkProvisioningStatusTimeout_LiveService",
               "billing_checkProvisioningStatusTimeout_Xbox1",
               "billing_closeBalanceTimeout",
               "billing_connectionLimit",
               "billing_connectToBilling",
               "billing_convertSubscriptionExTimeout",
               "billing_convertSubscriptionExTimeout_LiveService",
               "billing_convertSubscriptionExTimeout_Xbox1",
               "billing_convertSubscriptionTimeout",
               "billing_convertSubscriptionTimeout_LiveService",
               "billing_convertSubscriptionTimeout_Xbox1",
               "billing_createAccountTimeout",
               "billing_createAccountTimeout_LiveService",
               "billing_createAccountTimeout_Xbox1",
               "billing_creditPaymentInstrumentExTimeout",
               "billing_creditPaymentInstrumentTimeout",
               "billing_ctpAllowUrlOverride",
               "billing_ctpconnectbilling",
               "billing_ctpJoinSubscriptionTimeoutSeconds",
               "billing_ctpMigrateAccountTimeoutSeconds",
               "billing_ctppurchase_roundboundarymonths",
               "billing_ctpPurchaseTransactionServiceTimeoutSeconds",
               "billing_ctpPurchaseTransactionServiceUrl",
               "billing_ctpTenantName",
               "billing_deprovisionServicesTimeout",
               "billing_deprovisionServicesTimeout_LiveService",
               "billing_deprovisionServicesTimeout_Xbox1",
               "billing_familyGoldLimit",
               "billing_getAccountIdFromAdminPUIDTimeout",
               "billing_getAccountIdFromAdminPUIDTimeout_LiveService",
               "billing_getAccountIdFromAdminPUIDTimeout_Xbox1",
               "billing_getAccountInfoTimeout",
               "billing_getAccountInfoTimeout_LiveService",
               "billing_getAccountInfoTimeout_Xbox1",
               "billing_getCommentsTimeout",
               "billing_getCommentsTimeout_LiveService",
               "billing_getCommentsTimeout_Xbox1",
               "billing_getEligibleOfferingsTimeout",
               "billing_getEligibleOfferingsTimeout_LiveService",
               "billing_getEligibleOfferingsTimeout_Xbox1",
               "billing_getKeyTimeout",
               "billing_getKeyTimeout_LiveService",
               "billing_getKeyTimeout_Xbox1",
               "billing_getPartnerConfigurationTimeout",
               "billing_getPartnerConfigurationTimeout_LiveService",
               "billing_getPartnerConfigurationTimeout_Xbox1",
               "billing_getPaymentInstrumentsExTimeout",
               "billing_getPaymentInstrumentsExTimeout_LiveService",
               "billing_getPaymentInstrumentsExTimeout_Xbox1",
               "billing_getPaymentInstrumentsTimeout",
               "billing_getPaymentInstrumentsTimeout_LiveService",
               "billing_getPaymentInstrumentsTimeout_Xbox1",
               "billing_getPermitsForObjectIdTimeout",
               "billing_getPermitsForObjectIdTimeout_LiveService",
               "billing_getPermitsForObjectIdTimeout_Xbox1",
               "billing_getSubscriptionStatusTimeout",
               "billing_getSubscriptionStatusTimeout_LiveService",
               "billing_getSubscriptionStatusTimeout_Xbox1",
               "billing_getSubscriptionsTimeout",
               "billing_getSubscriptionsTimeout_LiveService",
               "billing_getSubscriptionsTimeout_Xbox1",
               "billing_getTokenInfoExTimeout",
               "billing_getTokenInfoExTimeout_LiveService",
               "billing_getTokenInfoExTimeout_Xbox1",
               "billing_initializeCTPWrapper",
               "billing_loadTokenInstanceTimeout",
               "billing_loadTokenInstanceTimeout_LiveService",
               "billing_loadTokenInstanceTimeout_Xbox1",
               "billing_maxEditorialPurchasesAsZeroPointsPerMinute",
               "billing_maxTrialCount",
               "billing_migrateOfferTimeout",
               "billing_migrateOfferTimeout_LiveService",
               "billing_migrateOfferTimeout_Xbox1",
               "billing_migrationOfferId",
               "billing_newContentWindow",
               "billing_offsetOrderCommentInfoCommentCode",
               "billing_offsetOrderFinancialReportingCode",
               "billing_offsetOrderTimeout",
               "billing_offsetOrderTimeout_LiveService",
               "billing_offsetOrderTimeout_Xbox1",
               "billing_provisionServicesTimeout",
               "billing_provisionServicesTimeout_LiveService",
               "billing_provisionServicesTimeout_Xbox1",
               "billing_pumpUserBillingInfoQueue",
               "billing_pumpUserBillingInfoQueueInterval",
               "billing_purchaseItemTimeout",
               "billing_purchaseItemTimeout_LiveService",
               "billing_purchaseItemTimeout_Xbox1",
               "billing_purchaseOfferingExTimeout",
               "billing_purchaseOfferingExTimeout_LiveService",
               "billing_purchaseOfferingExTimeout_Xbox1",
               "billing_purchaseOfferingTimeout",
               "billing_purchaseOfferingTimeout_LiveService",
               "billing_purchaseOfferingTimeout_Xbox1",
               "billing_queueUserBillingInfo",
               "billing_reinstateSubscriptionTimeout",
               "billing_reinstateSubscriptionTimeout_LiveService",
               "billing_reinstateSubscriptionTimeout_Xbox1",
               "billing_removePaymentInstrumentTimeout",
               "billing_removePaymentInstrumentTimeout_LiveService",
               "billing_removePaymentInstrumentTimeout_Xbox1",
               "billing_removeRoleAssignmentTimeout",
               "billing_removeRoleAssignmentTimeout_LiveService",
               "billing_removeRoleAssignmentTimeout_Xbox1",
               "billing_removeViolationTimeout",
               "billing_removeViolationTimeout_LiveService",
               "billing_removeViolationTimeout_Xbox1",
               "billing_scsSourcePartnerId",
               "billing_setPartnerConfigurationTimeout",
               "billing_setPartnerConfigurationTimeout_LiveService",
               "billing_setPartnerConfigurationTimeout_Xbox1",
               "billing_settleBalanceTimeout",
               "billing_settleBalanceTimeout_LiveService",
               "billing_settleBalanceTimeout_Xbox1",
               "billing_stopPaymentsTimeout",
               "billing_submitOrderTimeout",
               "billing_submitOrderTimeout_LiveService",
               "billing_submitOrderTimeout_Xbox1",
               "billing_switchPaymentInstrumentsTimeout",
               "billing_switchPaymentInstrumentsTimeout_LiveService",
               "billing_switchPaymentInstrumentsTimeout_Xbox1",
               "billing_testConnectionTimeout",
               "billing_testConnectionTimeout_LiveService",
               "billing_testConnectionTimeout_Xbox1",
               "billing_timeout",
               "billing_timeoutBlockInterval",
               "billing_transferBalanceTimeout",
               "billing_transferBalanceTimeout_LiveService",
               "billing_transferBalanceTimeout_Xbox1",
               "billing_updateAccountInfoTimeout",
               "billing_updateAccountInfoTimeout_LiveService",
               "billing_updateAccountInfoTimeout_Xbox1",
               "billing_updatePaymentInstrumentInfoTimeout",
               "billing_updatePaymentInstrumentInfoTimeout_LiveService",
               "billing_updatePaymentInstrumentInfoTimeout_Xbox1",
               "billing_updateSubscriptionInfoTimeout",
               "billing_updateSubscriptionInfoTimeout_LiveService",
               "billing_updateSubscriptionInfoTimeout_Xbox1",
               "billing_useCatalogSubscriptionOffers",
               "billing_validateProvisioningDataTimeout",
               "billing_validateProvisioningDataTimeout_LiveService",
               "billing_validateProvisioningDataTimeout_Xbox1",
               "casvc_genericSslIssuerName",
               "casvc_oscarIssuerName",
               "catalog_activeFECatalogDBSearchVirtualInterface",
               "catalog_activeFECatalogDBZuneVirtualInterface",
               "catalog_appMediaTypes",
               "catalog_consumableMediaTypes",
               "catalog_editorial_ips0",
               "catalog_editorial_ips1",
               "catalog_editorial_ips2",
               "catalog_editorial_priv0",
               "catalog_editorial_priv1",
               "catalog_editorial_priv2",
               "catalog_editorial_time0",
               "catalog_editorial_time1",
               "catalog_editorial_time2",
               "catalog_gameMediaTypes",
               "catalog_musicMediaTypes",
               "catalog_pointsBundleMediaTypes",
               "catalog_repurchasableMediaTypes",
               "catalog_subscriptionMediaTypes",
               "catalog_videoMediaTypes",
               "catalogwatcher_azure_connection_string",
               "catalogwatcher_azure_connection_string_speech",
               "catalogwatcher_azure_feed_prefix",
               "catalogwatcher_azure_feed_prefix_speech",
               "catalogwatcher_azure_feed_suffix",
               "catalogwatcher_azure_feed_suffix_speech",
               "catalogwatcher_azure_storage_blob_format_date_part",
               "catalogwatcher_azure_storage_blob_format_delta",
               "catalogwatcher_azure_storage_blob_format_delta_speech",
               "catalogwatcher_azure_storage_blob_format_full",
               "catalogwatcher_azure_storage_blob_format_full_speech",
               "catalogwatcher_azure_storage_container",
               "catalogwatcher_azure_storage_container_speech",
               "catalogwatcher_azure_storage_max_documents_per_batch",
               "catalogwatcher_azure_storage_max_documents_per_batch_speech",
               "catalogwatcher_commands_timeout_in_secs",
               "catalogwatcher_extractor_timeout_in_secs",
               "catalogwatcher_fast_esp_collection_name",
               "catalogwatcher_fast_esp_ingestion_port",
               "catalogwatcher_fast_esp_max_document_size",
               "catalogwatcher_fast_esp_max_documents_per_batch",
               "catalogwatcher_fast_esp_virtual_collection_name",
               "catalogwatcher_fast_wait_for_indexing",
               "catalogwatcher_media_extractor_batch_size",
               "catalogwatcher_media_extractor_version",
               "catalogwatcher_perform_and_log_validation_on_error",
               "catalogwatcher_producer_consumer_media_max_queue_size",
               "catalogwatcher_producer_consumer_speech_max_queue_size",
               "catalogwatcher_producer_consumer_video_max_queue_size",
               "catalogwatcher_speech_extractor_batch_size",
               "catalogwatcher_speech_extractor_timeout_in_secs",
               "catalogwatcher_speech_extractor_version",
               "catalogwatcher_video_document_builder_firstpartyprovider",
               "catalogwatcher_video_extractor_batch_size",
               "catalogwatcher_video_extractor_timeout_in_secs",
               "clean_clip_delete_window_minute",
               "cleanser_clientDeadSec",
               "cleanser_EtxEventTarget",
               "cleanser_fdbReconnectIntervalSec",
               "cleanser_watchDogTimerIntervalSec",
               "cleanser_XomFileTarget",
               "community_ownerNotifyCacheExpirySeconds",
               "compPlugins_allowClientResultsSubmissions",
               "compPlugins_allowTimeAdjustment",
               "cron_deleteCompletedJobs",
               "cron_jobCheckInterval",
               "cron_load_job_max_sleep_time_milliseconds",
               "cron_requestThreads",
               "cron_retryInterval",
               "crux_allowTestAddPoints",
               "crux_allowTestCreateAccount",
               "crux_MusicNetAESKeyType",
               "crux_MusicNetAESKeyVer",
               "crux_MusicNetTokenMagicString",
               "crux_MusicNetTokenSaltLen",
               "crux_passportSiteAddress",
               "crux_useMusicNetForProvisioning",
               "crux_VODLicenseWindowInMinutes",
               "CTPPurchase_fastFailMaxThreshold",
               "CTPPurchase_fastFailMinThreshold",
               "CTPPurchase_fastFailThrottling",
               "CTPPurchase_fastFailWindow",
               "dmp_addPromotionalBalanceMaxAttempts",
               "dmp_addPromotionalBalanceTimeoutSeconds",
               "dmp_allowUrlOverride",
               "dmp_auditEnabled",
               "dmp_autoRegisterUsers",
               "dmp_blacklistBlockIntervalSeconds",
               "dmp_blacklistTimeoutThresholdCount",
               "dmp_blacklistTimeoutTimespanSeconds",
               "dmp_cancelPurchaseItemMaxAttempts",
               "dmp_cancelPurchaseItemTimeoutSeconds",
               "dmp_clientCertSubject",
               "Dmp_fastFailMaxThreshold",
               "Dmp_fastFailMinThreshold",
               "Dmp_fastFailWindow",
               "dmp_getBalanceDetailsMaxAttempts",
               "dmp_getBalanceDetailsTimeoutSeconds",
               "dmp_getBalanceMaxAttempts",
               "dmp_getBalanceTimeoutSeconds",
               "dmp_maxAcquisitionTitleLength",
               "dmp_maxItemCategoryLength",
               "dmp_maxItemTitleLength",
               "dmp_maxPointsBalance",
               "dmp_pumpPurchasesQueue",
               "dmp_pumpRewardsQueue",
               "dmp_purchaseItemMaxAttempts",
               "dmp_purchaseItemTimeoutSeconds",
               "dmp_purchaseTransactionConsiderFailedSeconds",
               "dmp_purchaseTransactionExpiredSeconds",
               "dmp_queuePumpIntervalSeconds",
               "dmp_registerUserMaxAttempts",
               "dmp_registerUserTimeoutSeconds",
               "dmp_rewardTransactionExpiredSeconds",
               "dmp_tenantID",
               "dmp_transactionUrl",
               "dmp_transferBalanceMaxAttempts",
               "dmp_transferBalanceTimeoutSeconds",
               "dmp_transferPointsTimeoutSeconds",
               "DmpUps_fastFailMaxThreshold",
               "DmpUps_fastFailMinThreshold",
               "DmpUps_fastFailWindow",
               "etx_default_header_version",
               "fastEsp_allow_debug_xslt",
               "fastEsp_persist_connection_in_secs",
               "fastEsp_use_result_views",
               "fastfail_bucketCount",
               "fastfail_disableThrottling",
               "feedback_coeffBias",
               "feedback_coeffFudgeFactor",
               "feedback_coeffNegativeReview",
               "feedback_coeffPositiveReview",
               "feedback_coeffRange",
               "feedback_coeffSlope",
               "feedback_maxComplaintType",
               "feedback_maxFeedbackTypes",
               "feedback_maxReviewType",
               "feedback_minFeedbackServiceType",
               "feedback_ratingDecayFactor",
               "feedback_ratingDecayFloor",
               "feedback_reviewIgnoreThreshold",
               "finbus_certificateSubject",
               "finbus_clientPartnerId",
               "finbus_closeTimeout",
               "finbus_endpointAddress",
               "finbus_fastFailMaxThreshold",
               "finbus_fastFailMinThreshold",
               "finbus_fastFailWindow",
               "finbus_getPendingItemsMaxItems",
               "finbus_ignoreSslPolicyErrors",
               "finbus_maxActiveRequests",
               "finbus_maxBufferPoolSize",
               "finbus_maxBufferSize",
               "finbus_maxConnections",
               "finbus_maxReceivedMessageSize",
               "finbus_openTimeout",
               "finbus_pumpQueue",
               "finbus_queuePumpIntervalSeconds",
               "finbus_receiveTimeout",
               "finbus_sendTimeout",
               "finbus_throttleWaitMilliseconds",
               "finbus_transactionConsiderFailureSeconds",
               "finbus_transactionExpiredSeconds",
               "fse_bookmarkDaysFloor",
               "fse_bookmarkDaysThreshold",
               "fse_bookmarkHoursFloor",
               "fse_bookmarkHoursThreshold",
               "fse_bookmarkMinutesFloor",
               "fse_bookmarkMinutesThreshold",
               "fse_configChange",
               "fse_reservationSeconds",
               "fse_reservationWaitSeconds",
               "fse_reservationWaitSecondsMaximum",
               "geofencing_allowAccessOnGeoInfoExceptions",
               "geofencing_allowAccessOnGeoInfoNulls",
               "geofencing_maximumDaysBetweenGeoDbUpdate",
               "geofencing_offerGeoFencingEnabled",
               "geofencing_pathToGeoDb",
               "geofencing_videoGeoFencingEnabled",
               "global_protocolVersion",
               "healthcheck_executionPeriodInSeconds",
               "kdcsvc_askdc_DoS_cacheTimeMillis",
               "kdcsvc_askdc_DoS_tooSoonTimeMillis",
               "kdcsvc_askdc_DoS2_blockingTime",
               "kdcsvc_askdc_DoS2_enabled",
               "kdcsvc_askdc_DoS2_interval",
               "kdcsvc_askdc_DoS2_maxRequests",
               "kdcsvc_askdc_echo_enabled",
               "kdcsvc_askdc_echo_lifetimeInSeconds",
               "kdcsvc_askdc_keyVersion",
               "kdcsvc_askdc_machine_allowLegacyKey",
               "kdcsvc_askdc_timeSkewSeconds",
               "kdcsvc_core_ATQThreads",
               "kdcsvc_core_ATQThreadsPerProc",
               "kdcsvc_core_Rps_lifetimeInSeconds",
               "kdcsvc_core_Rps_roamingProfileSite",
               "kdcsvc_managed_command_timeout",
               "kdcsvc_xkdc_allowUnknownVersion",
               "kdcsvc_xkdc_cacheLifeTimeInSeconds",
               "kdcsvc_xkdc_DoS2_blockingTime",
               "kdcsvc_xkdc_DoS2_enabled",
               "kdcsvc_xkdc_DoS2_interval",
               "kdcsvc_xkdc_DoS2_maxRequests",
               "kdcsvc_xkdc_enableUserMachineTrust",
               "kdcsvc_xkdc_enforceClientVersion",
               "kdcsvc_xkdc_ignoreDuplicateRequests",
               "kdcsvc_xkdc_RequestCache_enabled",
               "kdcsvc_xkdc_RequestCache_lifetimeInSeconds",
               "kdcsvc_xkdc_timeSkewSeconds",
               "kdcsvc_xkdc_userAuthorizationBackwardsCompatibility",
               "kdcsvc_xmacs_acceptDevKits",
               "kdcsvc_xmacs_consoleExceptionList",
               "kdcsvc_xmacs_consoleTypeMask",
               "kdcsvc_xmacs_DoS2_blockingTime",
               "kdcsvc_xmacs_DoS2_enabled",
               "kdcsvc_xmacs_DoS2_interval",
               "kdcsvc_xmacs_DoS2_maxRequests",
               "kdcsvc_xmacs_DOSStage1CacheTimeout",
               "kdcsvc_xmacs_DOSStage2CacheTimeout",
               "kdcsvc_xmacs_hashListPercentageWarning",
               "kdcsvc_xmacs_keyEncryptionKeyVersion",
               "kdcsvc_xmacs_LimitedPcTokens",
               "kdcsvc_xmacs_maxAllowancePerHour",
               "kdcsvc_xmacs_PUIDBlockSize",
               "kdcsvc_xmacs_Rps_site",
               "kdcsvc_xmacs_timeSkewSeconds",
               "kdcsvc_xmacs_use_xcrypto",
               "Lists_ConfigChange",
               "Lists_ValidateXmlMode",
               "livecache_errorResultTTL",
               "livecache_forwardRetryInterval",
               "livecache_lastModified",
               "livecache_maxHeaderCollectionCount",
               "livecache_MaxRequestRatePerUser",
               "livecache_serviceEnabled",
               "livecache_UserLimitInMinutes",
               "livecache_UserLimitRandMinutes",
               "livecontent_sites",
               "liveinfo_clientconfiglimit",
               "liveoffer_ContentCheckMode",
               "logCollectorModule_badDigestResponseCode",
               "logCollectorModule_returnFixedResponseCodeForAllCalls",
               "lspfd_databaseCachingEnabled",
               "lspfd_fastFailBlockIntervalSeconds",
               "lspfd_fastFailTimeoutThresholdCount",
               "lspfd_fastFailTimeoutTimespanSeconds",
               "MasterKey_currentEncryptKeyVersion",
               "mix_default_LeaderBoardServer",
               "mix_default_MatchServer",
               "mix_productMgmt_imageCleanup",
               "mix_titleMgmt_kdcReloadTimeout",
               "mix_titlemgmt_liveconnectdbhost",
               "mix_wcfMaxReceivedMsgSize",
               "mixsettingsmanagement_etx_vortex_mgmt_timeout_ms",
               "msnrr_allowUrlOverride",
               "msnrr_failFastBlockIntervalSeconds",
               "msnrr_failFastThresholdCount",
               "msnrr_failFastThresholdIntervalSeconds",
               "msnrr_getRatingAveragesTimeoutSeconds",
               "msnrr_getRatingByUserWithAverageTimeoutSeconds",
               "msnrr_ignorefdrequests",
               "msnrr_saveRatingTimeoutSeconds",
               "msnrr_serviceAggregatorUrl",
               "msnrr_serviceSingleRatingUrl",
               "msnrr_testContentType",
               "msnrr_testUserPuid",
               "musicnet_addSubscriptionOfferTimeoutSeconds",
               "musicnet_addTrialSubscriptionOfferTimeoutSeconds",
               "musicnet_allowUrlOverride",
               "musicnet_apiMaxRetryAttempts",
               "musicnet_auditEnabled",
               "musicnet_cancelSubscriptionOfferTimeoutSeconds",
               "musicnet_closeAccountTimeoutSeconds",
               "musicnet_createAccountTimeoutSeconds",
               "musicnet_dmpPurchaseGlobalMusicCampaignID",
               "musicnet_dmpPurchaseGlobalMusicSKU",
               "musicnet_dmpPurchaseMusicAlbumCategory",
               "musicnet_dmpPurchaseMusicTrackCategory",
               "musicnet_dmpPurchaseTitleArtistFormatString",
               "musicnet_downgradeSubscriptionOfferTimeoutSeconds",
               "musicnet_endTrialSubscriptionOfferTimeoutSeconds",
               "musicnet_failFastBlockIntervalSeconds",
               "musicnet_failFastThresholdCount",
               "musicnet_failFastThresholdIntervalSeconds",
               "musicnet_getServiceConfigurationTimeoutSeconds",
               "musicnet_getServiceConfigurationUrl",
               "musicnet_offerIdMusicNetSkuOverrides",
               "musicnet_pumpPurchasesQueue",
               "musicnet_purchaseAssetsTimeoutSeconds",
               "musicnet_purchaseTransactionConsiderFailedSeconds",
               "musicnet_purchaseTransactionExpiredSeconds",
               "musicnet_queuePumpIntervalSeconds",
               "musicnet_resumeAccountTimeoutSeconds",
               "musicnet_retailerID",
               "musicnet_subscriptionSku",
               "musicnet_suspendAccountTimeoutSeconds",
               "musicnet_transferPurchaseDBEntitlementsTimeoutSeconds",
               "musicnet_trialSubscriptionSku",
               "musicnet_upgradeSubscriptionOfferTimeoutSeconds",
               "nameResolver_ruleExpirationHours",
               "NotificationCache_fastFailBlockIntervalSeconds",
               "NotificationCache_fastFailTimeoutThresholdCount",
               "NotificationCache_fastFailTimeoutTimespanSeconds",
               "NotificationCache_replyTimeout",
               "passport_blacklistBlockIntervalSeconds",
               "passport_blacklistTimeoutThresholdCount",
               "passport_blacklistTimeoutTimespanSeconds",
               "passport_partnerCallTimeoutSeconds",
               "passport_publicKeyCert",
               "PassportCreation_fastFailMaxThreshold",
               "PassportCreation_fastFailMinThreshold",
               "PassportCreation_fastFailWindow",
               "PassportCredentials_fastFailMaxThreshold",
               "PassportCredentials_fastFailMinThreshold",
               "PassportCredentials_fastFailWindow",
               "PassportLogin_fastFailMaxThreshold",
               "PassportLogin_fastFailMinThreshold",
               "PassportLogin_fastFailWindow",
               "presence_AffiliatesAvoidingMeListSize",
               "presence_AffiliatesCompletedGameListSize",
               "presence_AffiliatesEncounteredListSize",
               "presence_AffiliatesFavoritesListSize",
               "presence_AffiliatesNegativeFeedbackListSize",
               "presence_AffiliatesPositiveFeedbackListSize",
               "presence_BucketReloadDelay",
               "presence_ConcurrentSQLThreads",
               "presence_ContextDurationAlertLimit",
               "presence_DeadSgOnFailedQVal",
               "presence_EnableRichPresence",
               "presence_ExpirationCheckInterval",
               "presence_HeartbeatDelay",
               "presence_IdleQValsCheck",
               "presence_MaxFriends",
               "presence_MaxNumPoolBuffers",
               "presence_MaxPresenceUsers",
               "presence_MaxQValsPerHeartbeat",
               "presence_MaxRichPresenceBytes",
               "presence_MessageTimeout",
               "presence_MessageTypeExpiration",
               "presence_MessagingDailyRecipients",
               "presence_MessagingDailySends",
               "presence_NumSQLThreads",
               "presence_PoolBufferSize",
               "presence_PresUserCleanupDelay",
               "presence_pubsubEventTimeout",
               "presence_pubsubEventUrl",
               "presence_pubsubNotificationEnabled",
               "presence_QueryAffiliatesOkToPeerSubscribe",
               "presence_QValRetryDelays",
               "presence_RichPresenceDebug",
               "presence_SGIndexSize",
               "presence_StartNumPoolBuffers",
               "presence_StateBitsNotifyWhitelist",
               "presence_StoreStateInVelocity",
               "presence_UserIndexSize",
               "presence_ValidMessageTypes",
               "presence_WebUserTimeout",
               "presence_WelcomeToNewConsoleMessage",
               "presence_WelcomeToXboxLiveMessage",
               "presence_XBoxIndexSize",
               "presence_XonWatchIPs",
               "PresenceCache_fastFailBlockIntervalSeconds",
               "PresenceCache_fastFailTimeoutThresholdCount",
               "PresenceCache_fastFailTimeoutTimespanSeconds",
               "PresenceCache_replyTimeout",
               "ProfileCache_fastFailBlockIntervalSeconds",
               "ProfileCache_fastFailTimeoutThresholdCount",
               "ProfileCache_fastFailTimeoutTimespanSeconds",
               "ProfileCache_replyTimeout",
               "PubSubEvent_fastFailBlockIntervalSeconds",
               "PubSubEvent_fastFailTimeoutThresholdCount",
               "PubSubEvent_fastFailTimeoutTimespanSeconds",
               "query_enableTitleLog",
               "query_LspBackcompTitles",
               "ratings_aggregate_use_ventura",
               "ratings_aggregate_ventura_listIdRegex",
               "ratings_use_msnrr",
               "ratings_use_ventura",
               "scs_blacklistBlockIntervalSeconds",
               "scs_blacklistTimeoutThresholdCount",
               "scs_blacklistTimeoutTimespanSeconds",
               "scs_pumpPurchaseItemQueue",
               "scs_purchaseItemTransactionConsiderFailedSeconds",
               "scs_purchaseItemTransactionExpiredSeconds",
               "scs_queuePumpIntervalSeconds",
               "SCSCreditCard_fastFailMaxThreshold",
               "SCSCreditCard_fastFailMinThreshold",
               "SCSCreditCard_fastFailWindow",
               "SCSNonCreditCard_fastFailMaxThreshold",
               "SCSNonCreditCard_fastFailMinThreshold",
               "SCSNonCreditCard_fastFailWindow",
               "sg_AesMinClientVersionPc",
               "sg_AesMinClientVersionXbox360",
               "sg_AesProtocolEnabled",
               "sg_ArpNegativeTimeoutInSeconds",
               "sg_ArpPositiveTimeoutInSeconds",
               "sg_ArpRequestRetries",
               "sg_ArpRexmitTimeoutInSeconds",
               "sg_ChalHeartbeatTimeoutInSeconds",
               "sg_DesKeySize",
               "sg_DnsRefreshFailureIntervalInSeconds",
               "sg_DnsRefreshIntervalInMinutes",
               "sg_DvdChalShiftIntervalInSeconds",
               "sg_EnableChallengeResponse",
               "sg_HashTableOverheadInPercent",
               "sg_IpHdrTos",
               "sg_IpHdrTtl",
               "sg_KerberosApReqDeltaInMinutes",
               "sg_KeyExBlockIntervalInSeconds",
               "sg_KeyExDontSendIcmp",
               "sg_KeyExIcmpVip",
               "sg_KeyExMinRetryInMs",
               "sg_KeyExXbToSgInitMinSize",
               "sg_LogClientUpdates",
               "sg_LuaStateTableSize",
               "sg_NatDetectionDisconnectInSeconds",
               "sg_NotifyBatchIntervalInSeconds",
               "sg_SgToXbChallengePeriodInSeconds",
               "sg_SgToXbKeyExTimeoutInSeconds",
               "sg_SgToXbPulseTimeoutInSeconds",
               "sg_SgToXbScanFrequencyInSeconds",
               "sg_SgToXbTimeoutInSeconds",
               "sg_SpiFlow",
               "sg_SpiFlowDataLimit",
               "sg_SpiWatchdogTimeoutInSeconds",
               "sg_StatsConfidenceLimitInClients",
               "sg_StatsDisconnectSigmaInterval",
               "sg_StatsHistoryInMs",
               "sg_StatsPenaltyTimeInSeconds",
               "sg_StatsRefreshFrequencyInSeconds",
               "sg_StatsReportIntervalInSeconds",
               "sg_StatsWarningSigmaInterval",
               "sg_WiretapTimeoutInMinutes",
               "sg_XbToSgChallengeAckInSeconds",
               "sg_XbToSgChallengeTimeoutInSeconds",
               "sg_XbToSgPulseTimeoutInSeconds",
               "sg_XbToSgReplayWindow",
               "sg_XbToSgTimeoutInSeconds",
               "sginfo_maxRetries",
               "sginfo_retrieveForFlowToken",
               "sginfo_supportedHttpAuthDataVersion",
               "sginfo_timeout",
               "sginfo_useOldProtocol",
               "sginfo_verifyAuth",
               "sginfo_verifyTestTitleVersion",
               "signature_crlRevocationMode",
               "signature_digestReloadInterval",
               "signature_licenseTransferMinDaysToRestart",
               "signature_licenseTransferTimeoutInMinutes",
               "signature_machineReloadInterval",
               "signature_serviceKeyType",
               "signature_serviceKeyVersion",
               "signature_titleReloadInterval",
               "signature_userReloadInterval",
               "signature_validateCertificateValidUntilMinutes",
               "SocialCache_BulkGetBatchMaxSize",
               "SocialCache_CacheEntryExpirationTimeout",
               "SocialCache_fastFailBlockIntervalSeconds",
               "SocialCache_fastFailTimeoutThresholdCount",
               "SocialCache_fastFailTimeoutTimespanSeconds",
               "SocialCache_MaxMessageBytes",
               "SocialCache_MaxObjectsPerMessage",
               "SocialCache_replyTimeoutMS",
               "SocialCache_SocketBufferSize",
               "stats_AllowAlternateDestination",
               "stats_allowTitleReset",
               "stats_allowUnverifiedWrite",
               "stats_dbMaxRetry",
               "stats_dbRetryInteval",
               "stats_debugPuid",
               "stats_enableCertificationMode",
               "stats_enableTitlePerfCounters",
               "stats_trackCountersPerLb",
               "storage_xbancCacheTimeOut",
               "storageFD_allowZeroUserPuidsFromInternet",
               "storageFD_httpCacheHeader",
               "storageFD_httpContentTypeHeader",
               "storageFD_removeFileSqlTimeout",
               "storageFD_verifyAccessTokens",
               "storageFD_writeFileSqlTimeout",
               "storageModule_enableXbancCaching",
               "storageModule_maxUrlLength",
               "storageModule_returnFixedResponseCodeForAllCalls",
               "storageModule_urlPathRegEx",
               "storageModule_urlRedirectPath",
               "storageModule_urlReplacementString",
               "storageModule_urlStringToReplace",
               "stringsvr_flushStringsInterval",
               "stringsvr_loadStringsInterval",
               "stringsvr_reportingAggregateKeys",
               "sts_cert_subject",
               "sts_machine_token_expiration_seconds",
               "sts_partner_token_expiration_seconds",
               "sts_token_issuer_name",
               "sts_token_window_minutes",
               "sts_user_token_expiration_seconds",
               "tagrecycle_comber_job_batch_size",
               "tagrecycle_disassociated_job_batch_size",
               "tagrecycle_disassociater_high_value_files",
               "tagrecycle_disassociater_reservation_console_id",
               "tagrecycle_emailer_job_batch_size",
               "tagrecycle_emailer_job_file_path",
               "tagrecycle_emailer1_file_name",
               "tagrecycle_emailer2_file_name",
               "testfd_PermissionLevel",
               "tokenService_batchSize",
               "tokenService_considerStaleSeconds",
               "tokenService_delayBaseNumber",
               "tokenService_delayExponentFactor",
               "tokenService_finalOutputDirectory",
               "tokenService_keyType",
               "tokenService_keyVersion",
               "tokenService_maxFailureThreshold",
               "tokenService_maxNumTokens",
               "tokenService_scsBatchSize",
               "tokenService_sqlBatchSize",
               "tokenService_tempOutputDirectory",
               "tokenService_vetTokens",
               "ups_blacklistBlockIntervalSeconds",
               "ups_blacklistTimeoutThresholdCount",
               "ups_blacklistTimeoutTimespanSeconds",
               "user_forbiddenNamesReloadIntervalMinutes",
               "venturarr_aggregateRatingTimeoutSeconds",
               "venturarr_clientVersion",
               "venturarr_customerGroup",
               "venturarr_defaultConnectionLimit",
               "venturarr_deviceId",
               "venturarr_failFastEnabled",
               "venturarr_failFastMaxThreshold",
               "venturarr_failFastMinThreshold",
               "venturarr_failFastTimeWindow",
               "venturarr_formatSuperVuid",
               "venturarr_formatVuid",
               "venturarr_ignoreSslPolicyErrors",
               "venturarr_locale",
               "venturarr_padCredentialExpiryMilliseconds",
               "venturarr_serviceAuthKeyArray",
               "venturarr_serviceAuthKeyIndex",
               "venturarr_serviceDirectoryServiceUrl",
               "venturarr_singleRatingTimeoutSeconds",
               "venturarr_superUserVuidPart",
               "vortex_alwaysUseWorkerThread",
               "vortex_cake_stream_recipe_template_xml",
               "vortex_defaultEventTypeCountWindowSeconds",
               "vortex_defaultInputEventQueueSize",
               "vortex_logweb_v1_p3p",
               "vortex_logweb_v1_producer",
               "vortex_maxIoThreads",
               "vortex_maxWorkerThreadLatencyMs",
               "vortex_maxWorkerThreads",
               "vortex_maxWorkItemQueueSize",
               "vortex_minIoThreads",
               "vortex_minWorkerThreads",
               "vortex_numOverlappedIoOperations",
               "vortex_retrieveSgInfoForUnknownEvents",
               "vortex_udpReceiveBufferSize",
               "vortex_unknownEventHeaderVersion",
               "wcstats_AboveMax",
               "wcstats_BelowMax",
               "wcstats_EnumEntriesMax",
               "wcstats_EnumRawEntriesMax",
               "wcstats_EnumRawStartMin",
               "wcstats_EnumStartMax",
               "wcstats_EnumStartMin",
               "wcstats_LeaderboardListValidSeconds",
               "wcstats_RemoveDups",
               "wcstats_SingleAppDomain",
               "wcstats_SortByRating",
               "wcstats_TagListMax",
               "wctoolsmgmt_actionTableXML",
               "wctoolsmgmt_autopropLBServer",
               "wctoolsmgmt_autopropMMServer",
               "wctoolsmgmt_concurrentJobs",
               "wctoolsmgmt_pingInterval",
               "wctoolsmgmt_uploadPathRoot",
               "wctoolsmgmt_workPathRoot",
               "webSG_capturePath",
               "wmis_allowUrlOverride",
               "wmis_apiMaxRetryAttempts",
               "wmis_clientCertSubject",
               "wmis_dmpPurchaseGlobalVideoCampaignID",
               "wmis_dmpPurchaseGlobalVideoSKU",
               "wmis_dmpPurchaseVideoCategory",
               "wmis_failFastBlockIntervalSeconds",
               "wmis_failFastThresholdCount",
               "wmis_failFastThresholdIntervalSeconds",
               "wmis_getVideoPurchaseDetailsTimeoutSeconds",
               "wmis_serviceUrl",
               "xarb_AllowAlternateDestination",
               "xarb_BundleRetryPeriodInSeconds",
               "xarb_EnableDebugResult",
               "xarb_GarbageCollectionIntervalInSeconds",
               "xarb_InterfaceBucketInterceptThrottleInMillis",
               "xarb_MaxBundleRetrySeconds",
               "xarb_MaxDelayedTrustUpdates",
               "xarb_MaxSessionSeconds",
               "xarb_MaxStatsBundleSize",
               "xarb_MaxTournamentBundleSize",
               "xarb_MemoryUsageHighWaterMark",
               "xarb_MemoryUsageLowWaterMark",
               "xarb_MigrationWaitWindowMinutes",
               "xarb_SessionTimeoutExtensionSeconds",
               "xarb_TitleParameterReloadPeriodInSeconds",
               "xarb_TrailingReportRetriesWaitSeconds",
               "xarb_TrustFlushPeriodInSeconds",
               "xarb_TrustIdleSecondsBeforeFlush",
               "xarb_TrustSummationExecutionTimeInSeconds",
               "xarb_TrustSummationPeriodInSeconds",
               "xarb_TrustSummationRetryInSeconds",
               "xarb_TrustSummationTimeoutSeconds",
               "xarb_VerboseLogging",
               "xbanc_context_duration_alert_limit",
               "xbanc_fastFailBlockIntervalSeconds",
               "xbanc_fastFailTimeoutThresholdCount",
               "xbanc_fastFailTimeoutTimespanSeconds",
               "xbanc_heartbeat_interval",
               "xbanc_localCacheItemDuration",
               "xbanc_localCacheMaxSize",
               "xbanc_low_water_data_storage_bytes",
               "xbanc_max_key_length",
               "xbanc_record_maintenance_period",
               "xbanc_replyTimeout",
               "xbanc_total_data_storage_bytes",
               "xbos_allowMultiItemSubmitOrderTransactions",
               "xbos_auditEnabled",
               "xbos_AutoCacheFlushHour",
               "xbos_blockPurchaseMediaOffersSubmitOrderTransactions",
               "xbos_CTPPurchaseTransactionConsiderFailedSeconds",
               "xbos_ctpTimeConversionRatio",
               "xbos_CTPTransactionExpiredSeconds",
               "xbos_EnablePaymentTypeIdSupportInZuneCatalog",
               "xbos_gfwlOrderAttributeGuid",
               "xbos_limitedChildContentPurchaseCountryList",
               "xbos_limitedChildOfferTypePurchaseCountryList",
               "xbos_MaxCacheSize_ContentEnumerate",
               "xbos_MaxCacheSize_EnumerateTitlesByFilter",
               "xbos_MaxCacheSize_GetTitleDetails",
               "xbos_newContentWindowHours",
               "xbos_populateNewPurchaseHistoryFromOldPurchase",
               "xbos_pumpCTPPurchaseQueue",
               "xbos_pumpOffsetOrderQueue",
               "xbos_pumpSubmitOrderQueue",
               "xbos_queuePumpIntervalSeconds",
               "xbos_submitOrderTransactionConsiderFailedSeconds",
               "xbos_submitOrderTransactionExpiredSeconds",
               "xbos_subscriptionMaxTimeCredit",
               "xbos_titleActivation_disableAllTitles",
               "xbos_useExternalVideoMarketplaceCatalog",
               "xbos_xbox360OrderAttributeGuid",
               "xcache_connection_receive_timeout_milliseconds",
               "xcache_connection_send_timeout_milliseconds",
               "xcache_db_batchSize",
               "xcache_db_pollingInterval",
               "xcache_db_transactionTimeout",
               "xcache_db_usedatabaselocks",
               "XCache_MaxMessageBytes",
               "XCache_SocketBufferSize",
               "xcbk_auditEnabled",
               "xcbk_sslCertSubject",
               "XConnSrv_BulkGetBatchMaxSize",
               "XConnSrv_MaxMessageBytes",
               "XConnSrv_MaxObjectsPerMessage",
               "XConnSrv_MaxSubscriptionsPerConnection",
               "XConnSrv_SocketBufferSize",
               "XConnSrv_UseSGAuth",
               "xcrypto_DoRealPakTest",
               "xds_ARPRetryEventThrottle",
               "xds_ARPRetryIntervalInSeconds",
               "xds_gatewayLookupIntervalInSeconds",
               "xds_ICMPReplyAddr",
               "xds_infactionLimitPerMinute",
               "xds_maxLogLength",
               "xds_minICMPRequestLength",
               "xds_minLogRequestLength",
               "xds_skewTimeInMilliSecs",
               "xds_TOS",
               "xds_TTL",
               "xmatchfd_defaultSessionExpiration",
               "xmatchfd_disableAffiliateQuery",
               "xmatchfd_enableAuthCheck",
               "xmatchfd_enableTitlePerfCounters",
               "xmatchfd_fastFailBlockIntervalSeconds",
               "xmatchfd_fastFailBucketIntervalSeconds",
               "xmatchfd_fastFailReservedThreadsPerDB",
               "xmatchfd_fastFailTimeoutThresholdCount",
               "xmatchfd_fastFailTimeoutTimespanSeconds",
               "xmatchfd_fastFailTotalSharedThreads",
               "xmatchfd_insertRetries",
               "xmatchfd_nolockRetries",
               "xmatchfd_relaxXenonValidation",
               "xmatchfd_sessioncacheexpiration",
               "xmatchfd_valueOfAvoidingMe",
               "xmatchfd_valueOfCompletedGame",
               "xmatchfd_valueOfFriend",
               "xmatchfd_valueOfNegativeFeedback",
               "xmatchfd_valueOfPositiveFeedback",
               "xmgmt_ntevents",
               "xmstv_accessInfoUri",
               "xmstv_crldp",
               "xmstv_issuerCertName",
               "xmstv_lastCaRevocationTicks",
               "xmstv_maximumCertificatesAllowed",
               "xmstv_subjectNameSuffix",
               "xrlscan_allowHead",
               "xsts_issuer_name",
               "xsts_signing_cert_name",
               "xsuppapi_extraLicensesIncrementBy",
               "xsuppapi_extraLicensesMaximum",
               "xsuppapi_FNCFormatString",
               "xsuppapi_FNCRegenMaxTries",
               "xsuppapi_Xbox1AccountFNCFlags",
               "xsuppapi_XboxComAccountFNCFlags",
               "xsuppapi_XenonAccountGoldFNCFlags",
               "xsuppapi_XenonAccountSilverFNCFlags",
               "xsuppapi_ZuneAccountFNCFlags",
               "xtou_cacheDurationSeconds",
               "xuacs_auditEnabled",
               "xuacs_defaultGamercardReputation",
               "xuacs_familyGoldAssignmentCoolDownWaitIntervalDays",
               "xuacs_familyGoldAssignmentDistinctUsers",
               "xuacs_familyGoldAssignmentThrottlingWindowDays",
               "xuacs_familyGoldChangeWaitIntervalHours",
               "xuacs_FamilyGoldConvertionRatio",
               "xuacs_gamertagChangeWaitIntervalHours",
               "xuacs_generateGamertagMinsToReserve",
               "xuacs_graduateUserPumpQueue",
               "xuacs_graduateUserQueuePumpIntervalSeconds",
               "xuacs_graduateUserQueuePumpRetryLimit",
               "xuacs_hijackingIntervalHours",
               "xuacs_machineGamertagIntervalDays",
               "xuacs_machineGamertagThreshold",
               "xuacs_machinePassportIntervalDays",
               "xuacs_machinePassportThreshold",
               "xuacs_machineRecoveryIntervalDays",
               "xuacs_machineRecoveryThreshold",
               "xuacs_passport_generateddomain",
               "xuacs_passport_generatedprefix",
               "xuacs_passportChangeWaitIntervalHours",
               "xuacs_PassportCreateGeneratedRetries",
               "xuacs_replaceUserPassportDaysBetween",
               "xuacs_replaceUserPassportPumpQueue",
               "xuacs_replaceUserPassportQueuePumpIntervalSeconds",
               "xuacs_replaceUserPassportQueuePumpRetryLimit",
               "xuacs_seedbasedGamertagDefault",
               "xuacs_setNoAgeOutQueueIntervalSeconds",
               "xuacs_setNoAgeOutQueueRetryLimit",
               "xuacs_setNoAgeOutQueueStart",
               "xuacs_subscriptionNotificationWindowDays",
               "xuacs_subscriptionTenureGracePeriodDays",
               "xuacs_switchUserCountryConsiderExpiredSeconds",
               "xuacs_switchUserCountryDaysBetween",
               "xuacs_switchUserCountryMigrateAccountOfferId",
               "xuacs_switchUserCountryPumpQueue",
               "xuacs_switchUserCountryQueuePumpIntervalSeconds",
               "xuacs_switchUserCountryRetryTimeoutsImmediately",
               "xuacs_switchUserPassportDaysBetween",
               "xuacs_switchUserPassportPumpQueue",
               "xuacs_switchUserPassportQueuePumpIntervalSeconds",
               "xuacs_switchUserPassportQueuePumpRetryLimit",
               "xuacs_trialSubscriptionNotificationWindowDays",
               "xuacs_userDateWindowForThrottling",
               "xuacs_userGamertagIntervalDays",
               "xuacs_userGamertagThreshold",
               "xuacs_userNumberOfAccountsPerMachineId",
               "xuacs_userPassportIntervalDays",
               "xuacs_userPassportThreshold",
               "xuacs_userRecoveryIntervalDays",
               "xuacs_userRecoveryThreshold",
               "xuacs_WelcomeToXboxLiveMessageForGeneratedAccount",
        };

        // All the remaining, non-dynamic (static), settings.

        public static string[] StaticSettings = new string[]
        {
  
               "aamodule_audienceUriMode",
               "aamodule_certificateRevocationMode",
               "aamodule_certificateValidationMode",
               "aamodule_suppress_xmgmt_connection",
               "abch_abserviceUrl",
               "abch_allowQueryAtLoginAsQueryAtSignup",
               "abch_applicationId",
               "abch_getMessengerBuddiesTimeoutSeconds",
               "abch_getSoapConnectionPoolSize",
               "abch_sharingServiceUrl",
               "acceleration_allocation_page_size",
               "acceleration_allocation_sizes",
               "acceleration_max_key_length",
               "acceleration_notificationChangelistSize",
               "acceleration_numHashtableBuckets",
               "billing_proxy",
               "cleanser_fdbQueueMaxFreeEntriesCount",
               "cleanser_fdbUpdateIntervalSec",
               "cleanser_log_target",
               "cleanser_maxQueueLength",
               "cleanser_maxTcpConnections",
               "cleanser_workerThreadsPerProcessor",
               "config_cacheRefreshInterval",
               "config_loadTitleConnectionTimeoutSeconds",
               "config_minEventInterval",
               "crypto_serviceKeyType",
               "crypto_serviceKeyVersion",
               "download_contentDirectory",
               "eventsink_excludeApps",
               "feapp_completionPortThreads",
               "feapp_workerThreads",
               "global_buildVersion",
               "global_enableTestApis",
               "kdcsvc_askdc_checkForDos",
               "kdcsvc_askdc_DoS_numEntries",
               "kdcsvc_askdc_DoS2_cacheSize",
               "kdcsvc_xkdc_cacheTableSize",
               "kdcsvc_xkdc_DoS_checkForDos",
               "kdcsvc_xkdc_DoS_numEntries",
               "kdcsvc_xkdc_DoS2_cacheSize",
               "kdcsvc_xkdc_hashTableSize",
               "kdcsvc_xmacs_disableDOS",
               "kdcsvc_xmacs_DoS2_cacheSize",
               "kdcsvc_xmacs_nCipherInitTimeoutInSecs",
               "kdcsvc_xmacs_useNCipher",
               "kdcsvc_xmacs_UseTestMasterSigningKey",
               "kdcsvc_xmacs_UseTestXmacsKey",
               "lbsvr_BufferManagerPageSize",
               "lbsvr_DatabaseWriteThreads",
               "lbsvr_DbLoadingThreadCount",
               "lbsvr_DbLoadIntervalSeconds",
               "lbsvr_DbLoadRetryCount",
               "lbsvr_FullNamePagingFile",
               "lbsvr_IOThreadCount",
               "lbsvr_JobResetHour",
               "lbsvr_MaxCSndBuffer",
               "lbsvr_NetHelloTimeout",
               "lbsvr_NetMaxConnections",
               "lbsvr_PagingFileInitialSize",
               "lbsvr_PersisterRetryInterval",
               "lbsvr_ReservedPhysicalMemory",
               "lbsvr_SizeRcvBuffer",
               "lbsvr_SizeSndBuffer",
               "lbsvr_VirtualAllocSize",
               "leet_webcommunity_db_Enabled",
               "livecache_defaultConnectionLimit",
               "livepxy_forwardHeaders",
               "livepxy_MasterKeyVersion",
               "livepxy_maxGamerTagLookupsPerRequest",
               "livepxy_maxPUIDLookupsPerRequest",
               "livepxy_SiteKeyType",
               "livetitle_allowBaseVersionZero",
               "locale_AE",
               "locale_AT",
               "locale_AU",
               "locale_BE",
               "locale_BR",
               "locale_CA",
               "locale_CH",
               "locale_CL",
               "locale_CO",
               "locale_CZ",
               "locale_DE",
               "locale_DK",
               "locale_ES",
               "locale_FI",
               "locale_FR",
               "locale_GB",
               "locale_GR",
               "locale_HK",
               "locale_HU",
               "locale_IE",
               "locale_IT",
               "locale_JP",
               "locale_KR",
               "locale_language1",
               "locale_language10",
               "locale_language11",
               "locale_language12",
               "locale_language13",
               "locale_language14",
               "locale_language15",
               "locale_language16",
               "locale_language17",
               "locale_language18",
               "locale_language19",
               "locale_language2",
               "locale_language20",
               "locale_language3",
               "locale_language4",
               "locale_language5",
               "locale_language6",
               "locale_language7",
               "locale_language8",
               "locale_language9",
               "locale_MX",
               "locale_NL",
               "locale_NO",
               "locale_NZ",
               "locale_PL",
               "locale_PT",
               "locale_RU",
               "locale_SE",
               "locale_SG",
               "locale_TW",
               "locale_US",
               "locale_validLocales",
               "locale_ZA",
               "offer_cacheTimeSeconds",
               "partnermgr_webCaches",
               "passport_clientCertName",
               "passport_fakeService",
               "passport_partnerUrl",
               "passport_publicKeyCertUrl",
               "passport_siteAddress",
               "passport_siteAddressMsn",
               "passport_siteId",
               "passport_sitePolicy",
               "passport_sitePolicyMsn",
               "presence_PeerPort",
               "presence_SGQValRecvPort",
               "presence_SGQValSendPort",
               "presenceFD_NumPoolThreads",
               "presenceWidget_friendsCacheExpirationSeconds",
               "puidmgr_blockSize",
               "puidmgr_bucketCount",
               "puidmgr_userPuidBucket",
               "querylib_trustUpdates",
               "ratings_contenttype_mapping",
               "ratings_max_allowable_reviewcount",
               "reporting_DeleteRoot",
               "reporting_DistributionDataFileGrowth",
               "reporting_DistributionDataFileSize",
               "reporting_DistributionDBName",
               "reporting_DistributionLogFileGrowth",
               "reporting_DistributionLogFileSize",
               "reporting_DistributionMaxHistoryRetention",
               "reporting_DistributionMaxRetention",
               "reporting_ReplicationShare",
               "reporting_RSUtilPath",
               "reporting_SSISUseReplica",
               "reporting_WMISCertSubject",
               "reporting_WMISDBDrop",
               "reporting_WMISDBUrl",
               "setup_approot",
               "setup_logroot",
               "setup_secureUNC",
               "setup_sqldbroot",
               "setup_sqlftroot",
               "setup_sqllogroot",
               "sg_BlockLimit",
               "sg_ClientHistoryLimit",
               "sg_ClientLimit",
               "sg_ClientPortLimit",
               "sg_ConnectionServerPortLimit",
               "sg_DhInfoCacheSize",
               "sg_DhLimitHysteresisInMs",
               "sg_DhLimitOpsPerSec",
               "sg_EnableConnectionServices",
               "sg_PacketPool",
               "sg_PacketPoolMax",
               "sg_ProcessorQuantum",
               "sg_ShareDatacenterNicWithWindows",
               "sg_ShareInternetNicWithWindows",
               "SocialCache_BytesPerPooledBuffer",
               "SocialCache_DataThreadpoolSize",
               "SocialCache_MaxClientSockets",
               "SocialCache_MemCacheDllName",
               "SocialCache_RelationshipsLookupTableBuckets",
               "SocialCache_TCPKeepAliveTimeout",
               "SocialCache_UserLookupTableBuckets",
               "storageWidget_fakeFrontDoorFailures",
               "storageWidget_fakeXCache",
               "storageWidget_fakeXSig",
               "svct_heartbeatTimeout",
               "TagRecycleCronJobs",
               "titlevault_root",
               "toolsmgmt_filePrefix",
               "toolsmgmt_fileshare",
               "toolsmgmt_pollingInterval",
               "toolsmgmt_SDClient",
               "toolsmgmt_SDPort",
               "udpadpt_numOfThreads",
               "ups_clientCertName",
               "ups_getProfileTimeoutSeconds",
               "ups_partnerId",
               "ups_updateProfileTimeoutSeconds",
               "ups_url",
               "user_nameReservationMinutes",
               "wcgeneral_titleListValidSeconds",
               "wcsignature_createSignatureURL",
               "wcsignature_maximumAdminIdLength",
               "wcsignature_maximumVerifySignaturesPerRequest",
               "wcsignature_signatureSite",
               "wcsignature_verifySignatureURL",
               "wcusers_alertsSite",
               "wcusers_cacheExpirationSeconds",
               "wcusers_uacsGetUserSettingsURL",
               "wcusers_uacsLinkUserURL",
               "wcusers_uacsSite",
               "webSG_certIssuerCN1",
               "webSG_certIssuerCN2",
               "webSG_certIssuerCN3",
               "webSG_certIssuerCN4",
               "webSG_maxInReqSize",
               "wiredata_postLimit",
               "wiredata_stringLimit",
               "wiretap_AuthDataReplyPort",
               "wiretap_AuthDataWaitTimeInSecs",
               "wiretap_DumpDirectory",
               "wiretap_MaxNumOfRetrys",
               "wiretap_MaxNumOfTaps",
               "wiretap_MaxSGAuthDataRetry",
               "wiretap_NumOfCarrierNodes",
               "wiretap_NumOfReceiverNodes",
               "wiretap_PacketBufferSize",
               "wiretap_SGSessionTimeoutInSecs",
               "wiretap_UnwantedIPs",
               "xarb_NumberFlushBundleThreads",
               "xarb_NumberFlushTrustRatingThreads",
               "xcache_connectionTimeoutSeconds",
               "xcache_gamertag_hash_buckets",
               "XCache_MaxClientSockets",
               "xcache_maxPipeConnections",
               "xcache_memory_page_size",
               "xcache_passport_hash_buckets",
               "xcache_test_num_users",
               "xcache_test_random_seed",
               "xcache_userid_hash_buckets",
               "xcbk_billingNotificationTimeout",
               "xcbk_scs_heartbeatTimeout",
               "XConnSrv_BytesPerPooledBuffer",
               "XConnSrv_DataThreadpoolSize",
               "XConnSrv_MaxClientSockets",
               "XConnSrv_MemCacheDllName",
               "XConnSrv_NumLookupTableBuckets",
               "XConnSrv_TCPKeepAliveTimeout",
               "xcrypto_useNCipher",
               "xcrypto_useTestKey",
               "xds_cacheHashTableSize",
               "xds_cacheSize",
               "xds_eventCacheThrottleLifeTimeInSeconds",
               "xds_numberOfProcessingThreads",
               "xds_packetBufferSize",
               "xds_port",
               "xevents_buffers",
               "xevents_threads",
               "xlfsmon_AdminFdURL",
               "xlfsmon_ClientCertificateName",
               "xlfsmon_ClientCertificateThumbprint",
               "xlfsmon_ClientFdURL",
               "xlfsmon_DownloaderPath",
               "xlfsmon_EnvironmentName",
               "xlfsmon_ProxyURL",
               "xlfsmon_SaveDirectory",
               "xlfsmon_SubscriptionId",
               "xlfsmon_UseRealSTS",
               "xmatchfd_fastFailNumBuckets",
               "xmatchfd_fastFailTimeTolerance",
               "xmgmt_area_aainfo",
               "xmgmt_area_aamodule",
               "xmgmt_area_AccelerationClient",
               "xmgmt_area_AccelerationDebug",
               "xmgmt_area_AccelerationProxy",
               "xmgmt_area_ASkdc",
               "xmgmt_area_atTrace",
               "xmgmt_area_audit",
               "xmgmt_area_authsglog",
               "xmgmt_area_authsgtrace",
               "xmgmt_area_bcfgtrace",
               "xmgmt_area_blackbox",
               "xmgmt_area_blstTrace",
               "xmgmt_area_catalog",
               "xmgmt_area_catalogwatcherlog",
               "xmgmt_area_cfgtrace",
               "xmgmt_area_checkready",
               "xmgmt_area_cleanclips",
               "xmgmt_area_cleansermissingdata",
               "xmgmt_area_cleansertrace",
               "xmgmt_area_computil",
               "xmgmt_area_contentutiltrace",
               "xmgmt_area_crontest",
               "xmgmt_area_crontrace",
               "xmgmt_area_cryptomgr",
               "xmgmt_area_cryptotools",
               "xmgmt_area_ctpTransactionServiceLog",
               "xmgmt_area_ctpTransactionServiceTrace",
               "xmgmt_area_ctxDebug",
               "xmgmt_area_deactivator",
               "xmgmt_area_Debug",
               "xmgmt_area_DefaultNtLog",
               "xmgmt_area_DefaultTrace",
               "xmgmt_area_dmplog",
               "xmgmt_area_dmptrace",
               "xmgmt_area_domTrace",
               "xmgmt_area_DOS",
               "xmgmt_area_ElimEntrants",
               "xmgmt_area_ElimEvents",
               "xmgmt_area_Elimination",
               "xmgmt_area_elimtest",
               "xmgmt_area_enfTrace",
               "xmgmt_area_enmrdfTrace",
               "xmgmt_area_espengine",
               "xmgmt_area_EventService",
               "xmgmt_area_feedbacklog",
               "xmgmt_area_FeedbackProxy",
               "xmgmt_area_feedbackTrace",
               "xmgmt_area_finbusLog",
               "xmgmt_area_finbusTrace",
               "xmgmt_area_FlokenMap",
               "xmgmt_area_fseLog",
               "xmgmt_area_fseTrace",
               "xmgmt_area_geoFenceLog",
               "xmgmt_area_geoFenceTrace",
               "xmgmt_area_GetPostalCode",
               "xmgmt_area_glcTrace",
               "xmgmt_area_graduateUserTrace",
               "xmgmt_area_gtqTrace",
               "xmgmt_area_Integration",
               "xmgmt_area_KdcBase",
               "xmgmt_area_KdcCore",
               "xmgmt_area_kdcmanaged",
               "xmgmt_area_LbsTrace",
               "xmgmt_area_lbsvrclient",
               "xmgmt_area_listsTrace",
               "xmgmt_area_livecachelog",
               "xmgmt_area_livecachetrace",
               "xmgmt_area_livepxy",
               "xmgmt_area_livepxylog",
               "xmgmt_area_log",
               "xmgmt_area_LogCleanser",
               "xmgmt_area_LogCode",
               "xmgmt_area_LogCodeWindows",
               "xmgmt_area_LogCollectorModuleLog",
               "xmgmt_area_logCollectorModuleTrace",
               "xmgmt_area_LogDvd",
               "xmgmt_area_LogTitle",
               "xmgmt_area_LogWindows",
               "xmgmt_area_lua",
               "xmgmt_area_marketplacecatalog",
               "xmgmt_area_matchdblog",
               "xmgmt_area_matchdbtrace",
               "xmgmt_area_matchprestrace",
               "xmgmt_area_MatchProxy",
               "xmgmt_area_matchtrace",
               "xmgmt_area_MessageProxy",
               "xmgmt_area_messagingfd",
               "xmgmt_area_messagingfdLog",
               "xmgmt_area_MessagingLog",
               "xmgmt_area_metro",
               "xmgmt_area_mllog",
               "xmgmt_area_mltrace",
               "xmgmt_area_msgmanager",
               "xmgmt_area_msnrraggregationlog",
               "xmgmt_area_msnrraggregationtrace",
               "xmgmt_area_msnrrLog",
               "xmgmt_area_msnrrTrace",
               "xmgmt_area_musicnetLog",
               "xmgmt_area_musicnetTrace",
               "xmgmt_area_nametrace",
               "xmgmt_area_NicMgr",
               "xmgmt_area_NotificationDebug",
               "xmgmt_area_NotificationLog",
               "xmgmt_area_nrTrace",
               "xmgmt_area_offer",
               "xmgmt_area_oledbw",
               "xmgmt_area_passportLog",
               "xmgmt_area_passportTrace",
               "xmgmt_area_pathTrace",
               "xmgmt_area_PingLog",
               "xmgmt_area_PipeDbg",
               "xmgmt_area_plugintest",
               "xmgmt_area_Policy",
               "xmgmt_area_PPALoader",
               "xmgmt_area_PresenceDebug",
               "xmgmt_area_PresenceFDDebug",
               "xmgmt_area_PresenceFDLog",
               "xmgmt_area_PresenceLog",
               "xmgmt_area_PresenceProxy",
               "xmgmt_area_PresenceRPDebug",
               "xmgmt_area_profilelog",
               "xmgmt_area_progresslog",
               "xmgmt_area_prov",
               "xmgmt_area_provdr",
               "xmgmt_area_provisioning",
               "xmgmt_area_pss",
               "xmgmt_area_puidmgr",
               "xmgmt_area_QFlag",
               "xmgmt_area_QueryTest",
               "xmgmt_area_ratingstrace",
               "xmgmt_area_rdfTrace",
               "xmgmt_area_readsitekeys",
               "xmgmt_area_replacePassportTrace",
               "xmgmt_area_ReportConnection",
               "xmgmt_area_Reporting",
               "xmgmt_area_Reporting_v2",
               "xmgmt_area_rfhTrace",
               "xmgmt_area_rmfTrace",
               "xmgmt_area_selog",
               "xmgmt_area_serialnumber",
               "xmgmt_area_ServHlpDebug",
               "xmgmt_area_SgClientStats",
               "xmgmt_area_sginfotrace",
               "xmgmt_area_SGProxy",
               "xmgmt_area_soaptrace",
               "xmgmt_area_SocialCacheAPI",
               "xmgmt_area_SocialCacheConnection",
               "xmgmt_area_SocialCacheLog",
               "xmgmt_area_spslog",
               "xmgmt_area_spsproxy",
               "xmgmt_area_spsproxyLog",
               "xmgmt_area_spsqueuetrace",
               "xmgmt_area_spstrace",
               "xmgmt_area_sqltrace",
               "xmgmt_area_statslog",
               "xmgmt_area_stfdTrace",
               "xmgmt_area_stlog",
               "xmgmt_area_storageHealthTrace",
               "xmgmt_area_StorageModuleLog",
               "xmgmt_area_storageModuleTrace",
               "xmgmt_area_storageUtilsTrace",
               "xmgmt_area_stringLog",
               "xmgmt_area_StringProxy",
               "xmgmt_area_stringSvrHealthTrace",
               "xmgmt_area_stringTrace",
               "xmgmt_area_sts",
               "xmgmt_area_ststrace",
               "xmgmt_area_subcodemgr",
               "xmgmt_area_switchPassportTrace",
               "xmgmt_area_synccastLog",
               "xmgmt_area_synccastTrace",
               "xmgmt_area_TagRecycleCronJobs",
               "xmgmt_area_TALKER",
               "xmgmt_area_TCPCnt",
               "xmgmt_area_TCPConnection",
               "xmgmt_area_TeamProxy",
               "xmgmt_area_TeamsLog",
               "xmgmt_area_Test",
               "xmgmt_area_testfd",
               "xmgmt_area_TestUtilities",
               "xmgmt_area_title",
               "xmgmt_area_tmrlog",
               "xmgmt_area_tokenTrace",
               "xmgmt_area_toolspslog",
               "xmgmt_area_ToolsSrv",
               "xmgmt_area_ToolsSrvLog",
               "xmgmt_area_trace",
               "xmgmt_area_UDPADAPT",
               "xmgmt_area_UDPADPTLog",
               "xmgmt_area_UDPMGR",
               "xmgmt_area_UNITTEST",
               "xmgmt_area_user2",
               "xmgmt_area_userbillinginfo",
               "xmgmt_area_Vlan",
               "xmgmt_area_VortexFlow",
               "xmgmt_area_VortexOutput",
               "xmgmt_area_VortexOutputUnknown",
               "xmgmt_area_VortexTrace",
               "xmgmt_area_voucher",
               "xmgmt_area_wcAlertsLog",
               "xmgmt_area_wcgenerallog",
               "xmgmt_area_wcgeneraltrace",
               "xmgmt_area_wcMessagingLog",
               "xmgmt_area_wcMessagingTrace",
               "xmgmt_area_wcmusiclog",
               "xmgmt_area_wcpresencelog",
               "xmgmt_area_wcQueryLog",
               "xmgmt_area_wcsignaturelog",
               "xmgmt_area_wcstatscache",
               "xmgmt_area_wcstatsdomain",
               "xmgmt_area_wcstatslog",
               "xmgmt_area_wcstatstrace",
               "xmgmt_area_wcstoragelog",
               "xmgmt_area_wcteamslog",
               "xmgmt_area_wctoolsmgmtlog",
               "xmgmt_area_wctoolsmgmttrace",
               "xmgmt_area_wcuserslog",
               "xmgmt_area_wcutilitieslog",
               "xmgmt_area_wcutilitiestrace",
               "xmgmt_area_websg",
               "xmgmt_area_WINHTTP",
               "xmgmt_area_WireDataBin",
               "xmgmt_area_WireDataTxt",
               "xmgmt_area_wmisLog",
               "xmgmt_area_wmisTrace",
               "xmgmt_area_wrfTrace",
               "xmgmt_area_wsttrace",
               "xmgmt_area_xarblog",
               "xmgmt_area_XBancClient",
               "xmgmt_area_XBancDebug",
               "xmgmt_area_XBancProxy",
               "xmgmt_area_xbos",
               "xmgmt_area_xboxcom",
               "xmgmt_area_XCacheClient",
               "xmgmt_area_XCacheData",
               "xmgmt_area_XCacheDatabase",
               "xmgmt_area_XCacheLog",
               "xmgmt_area_XCacheLookup",
               "xmgmt_area_XCacheProxy",
               "xmgmt_area_XCacheService",
               "xmgmt_area_xcbk",
               "xmgmt_area_XConnSrvAPI",
               "xmgmt_area_XConnSrvCache",
               "xmgmt_area_XConnSrvConnection",
               "xmgmt_area_XConnSrvLog",
               "xmgmt_area_XConnSrvSubscription",
               "xmgmt_area_XDb",
               "xmgmt_area_Xds",
               "xmgmt_area_Xkdc",
               "xmgmt_area_XkdcTicketLog",
               "xmgmt_area_xlastutil",
               "xmgmt_area_xlisttrace",
               "xmgmt_area_xmachine",
               "xmgmt_area_XMACS",
               "xmgmt_area_XMGMT",
               "xmgmt_area_XomInstrumentation",
               "xmgmt_area_xqry",
               "xmgmt_area_xrltrace",
               "xmgmt_area_xsig",
               "xmgmt_area_xsiglog",
               "xmgmt_area_xsuppapi",
               "xmgmt_area_xsuppapiEmailSentLog",
               "xmgmt_area_xsuppapiLog",
               "xmgmt_area_xuacs",
               "xmgmt_area_XWireTap",
               "xmgmt_area_XWireTapHash",
               "xmgmt_area_XWireTapNicMgr",
               "xmgmt_area_XWireTapProdCons",
               "xmgmt_default_target_settings",
               "xmgmt_target_",
               "xmgmt_target_catalogwatcherlog",
               "xmgmt_target_cleansermissingdata",
               "xmgmt_target_ctpTransactionServiceLog",
               "xmgmt_target_dmplog",
               "xmgmt_target_espengine",
               "xmgmt_target_geofencelog",
               "xmgmt_target_log",
               "xmgmt_target_logcleanser",
               "xmgmt_target_logcode",
               "xmgmt_target_logcodewindows",
               "xmgmt_target_logdvd",
               "xmgmt_target_logwindows",
               "xmgmt_target_lua",
               "xmgmt_target_msglog",
               "xmgmt_target_msnrraggregationlog",
               "xmgmt_target_musicnetlog",
               "xmgmt_target_notlog",
               "xmgmt_target_passportlog",
               "xmgmt_target_preslog",
               "xmgmt_target_remote",
               "xmgmt_target_report",
               "xmgmt_target_sgclientstats",
               "xmgmt_target_spslog",
               "xmgmt_target_synccastlog",
               "xmgmt_target_teamslog",
               "xmgmt_target_ticketlog",
               "xmgmt_target_wmislog",
               "xmgmt_target_xdslog",
               "xmgmt_target_XomInstrumentationLog",
               "xmgmt_target_xsuppapiemaillog",
               "xmgmt_target_xsuppapilog",
               "xmgmt_targets",
               "xrlutil_allowAlternateUrl",
               "xuacs_allowClearSubscriptions",
               "xuacs_allowDisableSubscription",
               "xuacs_allowGetNoAgeOut",
               "xuacs_allowSetUserAccountStatus",
               "xuacs_allowSetUserSettings2",
               "xuacs_allowUncheckedRecovery",
               "xuacs_autoGenCC",
               "xuacs_billingdecline_notificationcount",
               "xuacs_domain",
               "xuacs_link_failureWindowMinutes",
               "xuacs_link_maxFailedAttempts",
               "xuacs_max_family_dependents",
               "xuacs_restore_failureWindowMinutes",
               "xuacs_restore_maxFailedAttempts",
               "xuacs_switchUserCountryAllowMultipleSubscriptions",
               "xuacs_xonwatch_creditCard",
               "xuacs_xonwatch_ips",
               "xuacs_xonwatch_voucher",
        };



    }
    
    // MultiSettings
    [ComVisible(false)]
    public class MultiSetting 
    {
  
        public const string aamodule_antidosIpOverrides = "aamodule_antidosIpOverrides";
        public const string aamodule_audienceUris = "aamodule_audienceUris";
        public const string aamodule_rpsSiteNames = "aamodule_rpsSiteNames";
        public const string aamodule_serviceCertsSubject = "aamodule_serviceCertsSubject";
        public const string aamodule_trustedIssuersSubject = "aamodule_trustedIssuersSubject";
        public const string aamodule_XblEnhancedKeyUsages = "aamodule_XblEnhancedKeyUsages";
        public const string authsg_hostNameMappings = "authsg_hostNameMappings";
        public const string billing_geoid_region = "billing_geoid_region";
        public const string billing_nonUserBillingErrors = "billing_nonUserBillingErrors";
        public const string billingNotifications_ClientCertificate = "billingNotifications_ClientCertificate";
        public const string billingNotifications_CreditCardDeclineReason = "billingNotifications_CreditCardDeclineReason";
        public const string catalog_storeCatalogDefault = "catalog_storeCatalogDefault";
        public const string catalog_storeMediaTypeCatalogOverride = "catalog_storeMediaTypeCatalogOverride";
        public const string community_cacheDataTypes = "community_cacheDataTypes";
        public const string etx_manifest_producers = "etx_manifest_producers";
        public const string fastEspFlatFieldsDateTime = "fastEspFlatFieldsDateTime";
        public const string fastEspFlatFieldsInt32 = "fastEspFlatFieldsInt32";
        public const string fastEspFlatFieldsSingle = "fastEspFlatFieldsSingle";
        public const string fastEspFlatFieldsString = "fastEspFlatFieldsString";
        public const string fastEspFlatFieldsXml = "fastEspFlatFieldsXml";
        public const string fastEspMarketplaceIngestionIps = "fastEspMarketplaceIngestionIps";
        public const string fastEspNavigatorParameters = "fastEspNavigatorParameters";
        public const string fastEspOrderByParameters = "fastEspOrderByParameters";
        public const string fastEspRemappingParameters = "fastEspRemappingParameters";
        public const string fastEspReplaceDashForParameter = "fastEspReplaceDashForParameter";
        public const string fastEspSpellCheckLanguage = "fastEspSpellCheckLanguage";
        public const string fastRatingExemptGCForTitles = "fastRatingExemptGCForTitles";
        public const string fastRatingExemptMediaTypes = "fastRatingExemptMediaTypes";
        public const string fastRatingNonExemptMediaIds = "fastRatingNonExemptMediaIds";
        public const string fastRatingNonExemptRatingSystem = "fastRatingNonExemptRatingSystem";
        public const string feapp_compressionPaths = "feapp_compressionPaths";
        public const string geofencing_territoryMapping = "geofencing_territoryMapping";
        public const string kdcsvc_xkdc_legacyPcTitles = "kdcsvc_xkdc_legacyPcTitles";
        public const string kdcsvc_xkdc_sgSite1Ips = "kdcsvc_xkdc_sgSite1Ips";
        public const string liveinfo_allowed_shared_config_names = "liveinfo_allowed_shared_config_names";
        public const string mix_offerMgmt_nonOfferType = "mix_offerMgmt_nonOfferType";
        public const string passport_secretQuestionsXml = "passport_secretQuestionsXml";
        public const string pdlc_mediatypes = "pdlc_mediatypes";
        public const string presenceFD_StringPresence_BlackList = "presenceFD_StringPresence_BlackList";
        public const string ratings_mediatypes = "ratings_mediatypes";
        public const string reporting_nonSplitComponentIds = "reporting_nonSplitComponentIds";
        public const string reporting_ReportServerAllowedIPs = "reporting_ReportServerAllowedIPs";
        public const string scs_creditCardAuthApis = "scs_creditCardAuthApis";
        public const string sg_NullMachineId = "sg_NullMachineId";
        public const string storageModule_DefaultAvatarPicBody = "storageModule_DefaultAvatarPicBody";
        public const string storageModule_DefaultAvatarPicLarge = "storageModule_DefaultAvatarPicLarge";
        public const string storageModule_DefaultAvatarPicSmall = "storageModule_DefaultAvatarPicSmall";
        public const string storageModule_urlFilePathExclusionSet = "storageModule_urlFilePathExclusionSet";
        public const string storageModule_validResponseCodesForCacheUpdate = "storageModule_validResponseCodesForCacheUpdate";
        public const string stringsvr_LogStringPrefix = "stringsvr_LogStringPrefix";
        public const string sts_audienceDenyList = "sts_audienceDenyList";
        public const string testfd_API_PermissionLevel = "testfd_API_PermissionLevel";
        public const string user_forbiddenNamesExcludedTitles = "user_forbiddenNamesExcludedTitles";
        public const string vortex_cake_log_config_xml = "vortex_cake_log_config_xml";
        public const string vortex_cake_query_config_xml = "vortex_cake_query_config_xml";
        public const string vortex_categoriesAllowedThroughIFLC = "vortex_categoriesAllowedThroughIFLC";
        public const string xbos_ContentOfferIdsForReporting = "xbos_ContentOfferIdsForReporting";
        public const string xbos_freeGamertagOffers = "xbos_freeGamertagOffers";
        public const string xbos_limitedChildContentPurchaseAllowedMediaTypes = "xbos_limitedChildContentPurchaseAllowedMediaTypes";
        public const string xbos_limitedChildPurchaseAllowedOfferTypes = "xbos_limitedChildPurchaseAllowedOfferTypes";
        public const string xbos_reducedPriceCheckStores = "xbos_reducedPriceCheckStores";
        public const string xbos_subscriptionCountryCreditMapping = "xbos_subscriptionCountryCreditMapping";
        public const string xbos_titleActivation_testTitles = "xbos_titleActivation_testTitles";
        public const string xbos_zeroTaxIncludedCountryList = "xbos_zeroTaxIncludedCountryList";
        public const string xmgmt_eventThrottles = "xmgmt_eventThrottles";
        public const string xuacs_nameToClientTypeMapping = "xuacs_nameToClientTypeMapping";
        public const string xuacs_platformToClientTypeMapping = "xuacs_platformToClientTypeMapping";
  
        public static string[] Settings = new string[]
        {
  
               "aamodule_antidosIpOverrides",
               "aamodule_audienceUris",
               "aamodule_rpsSiteNames",
               "aamodule_serviceCertsSubject",
               "aamodule_trustedIssuersSubject",
               "aamodule_XblEnhancedKeyUsages",
               "authsg_hostNameMappings",
               "billing_geoid_region",
               "billing_nonUserBillingErrors",
               "billingNotifications_ClientCertificate",
               "billingNotifications_CreditCardDeclineReason",
               "catalog_storeCatalogDefault",
               "catalog_storeMediaTypeCatalogOverride",
               "community_cacheDataTypes",
               "etx_manifest_producers",
               "fastEspFlatFieldsDateTime",
               "fastEspFlatFieldsInt32",
               "fastEspFlatFieldsSingle",
               "fastEspFlatFieldsString",
               "fastEspFlatFieldsXml",
               "fastEspMarketplaceIngestionIps",
               "fastEspNavigatorParameters",
               "fastEspOrderByParameters",
               "fastEspRemappingParameters",
               "fastEspReplaceDashForParameter",
               "fastEspSpellCheckLanguage",
               "fastRatingExemptGCForTitles",
               "fastRatingExemptMediaTypes",
               "fastRatingNonExemptMediaIds",
               "fastRatingNonExemptRatingSystem",
               "feapp_compressionPaths",
               "geofencing_territoryMapping",
               "kdcsvc_xkdc_legacyPcTitles",
               "kdcsvc_xkdc_sgSite1Ips",
               "liveinfo_allowed_shared_config_names",
               "mix_offerMgmt_nonOfferType",
               "passport_secretQuestionsXml",
               "pdlc_mediatypes",
               "presenceFD_StringPresence_BlackList",
               "ratings_mediatypes",
               "reporting_nonSplitComponentIds",
               "reporting_ReportServerAllowedIPs",
               "scs_creditCardAuthApis",
               "sg_NullMachineId",
               "storageModule_DefaultAvatarPicBody",
               "storageModule_DefaultAvatarPicLarge",
               "storageModule_DefaultAvatarPicSmall",
               "storageModule_urlFilePathExclusionSet",
               "storageModule_validResponseCodesForCacheUpdate",
               "stringsvr_LogStringPrefix",
               "sts_audienceDenyList",
               "testfd_API_PermissionLevel",
               "user_forbiddenNamesExcludedTitles",
               "vortex_cake_log_config_xml",
               "vortex_cake_query_config_xml",
               "vortex_categoriesAllowedThroughIFLC",
               "xbos_ContentOfferIdsForReporting",
               "xbos_freeGamertagOffers",
               "xbos_limitedChildContentPurchaseAllowedMediaTypes",
               "xbos_limitedChildPurchaseAllowedOfferTypes",
               "xbos_reducedPriceCheckStores",
               "xbos_subscriptionCountryCreditMapping",
               "xbos_titleActivation_testTitles",
               "xbos_zeroTaxIncludedCountryList",
               "xmgmt_eventThrottles",
               "xuacs_nameToClientTypeMapping",
               "xuacs_platformToClientTypeMapping",
        };
    }
    
    // ConfigBlobs
    [ComVisible(false)]
    public class ConfigBlob
    {
  
        public const string etx_schema_document = "etx_schema_document";
  
        public static string[] Settings = new string[]
        {
  
               "etx_schema_document",
        };
    }
    

  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastFailThreading.cs ===
/* FastFail using the thread throttling approach - Core Implementation
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * The idea here is to cap the number of threads a resource may tie up in your
 * process.  The cap is dynamically adjusted based on its performance by a
 * specifiable throttling adjustment function.
 *
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 *
 * NPDB Settings:
 *   [system]
 *   fastfail_disableThrottling - indicates of throttle enabled [true/false]
 *   fastfail_bucketCount - bucket count for features - [natural numbers]
 *
 *   [resource configuration]
 *   #prefix#_fastFailMaxThreshold - threshold upper bound :num[%]
 *   #prefix#_fastFailMinThreshold - threshold lower bound : num[%]
 *   #prefix#_fastFailWindow - duration of expiration window (sec) : num[.num]
 *
 * current owner: jojohn
 */

namespace STF.common.service
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Threading;

    using STF.common.mgmt;
    using STF.common.config;


    public class FastFailResourceConfig
    {
        public static FastFailResourceConfig CreateFromResource(
           FastFailResource resource,
           string prefix,
           bool optional)
        {
            FastFailResourceConfig config;

            config = new FastFailResourceConfig();

            if (!optional && null == prefix)
                throw new ArgumentNullException("prefix");
            if (optional && null == resource)
                throw new ArgumentNullException("resource");
            if (optional && null == resource.Statistics)
                throw new ArgumentException("npdb load optional but resource statistics is null", "resource.Statistics");

            if (null != resource)
            {
                lock (resource)
                {
                    config.ThrottlingSelector = resource.ThrottlingSelector;

                    if (optional)
                    {
                        config.MaximumThreshold = resource.MaximumThreshold;
                        config.MinimumThreshold = resource.MinimumThreshold;
                        config.CaptureTimeWindow = resource.Statistics.CaptureTimeWindow;
                    }
                }
            }

            if (null != prefix)
                config.ReadNpdbSettings(prefix, optional);

            return config;
        }

        public static FastFailResourceConfig CreateFromResource(
           FastFailResource resource)
        {
            return CreateFromResource(resource, null, true);
        }

        private static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig target,
           FastFailResourceConfig config,
           string prefix,
           bool optional)
        {
            if (!optional && null == prefix)
                throw new ArgumentException("npdb load required but prefix is null", "prefix");
            if (optional && null == config)
                throw new ArgumentException("npdb load optional but config is null", "resource");

            if (optional)
            {
                target.MaximumThreshold = config.MaximumThreshold;
                target.MinimumThreshold = config.MinimumThreshold;
                target.CaptureTimeWindow = config.CaptureTimeWindow;
                target.ThrottlingSelector = config.ThrottlingSelector;
            }

            if (null != prefix)
                target.ReadNpdbSettings(prefix, optional);

            return target;
        }

        public static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig config,
           string prefix,
           bool optional)
        {
            return CreateFromConfig(
               new FastFailResourceConfig(),
               config,
               prefix,
               optional);
        }

        public static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig config)
        {
            return CreateFromConfig(config, null, true);
        }

        public FastFailResourceConfig(FastFailResourceConfig config, string prefix, bool optional)
        {
            CreateFromConfig(this, config, prefix, optional);
        }

        public FastFailResourceConfig()
        {
            maximumThreshold = 20;
            minimumThreshold = 20;
            captureTimeWindow = TimeSpan.FromSeconds(30);
            throttlingSelector = new FastFailThrottleSelector();
        }

        private uint GetThreadSetting(string name)
        {
            string Setting = Config.GetSetting(name).Trim();

            if (Setting.EndsWith("%"))
            {
                int Workers, Completion;
                float Percentage;

                System.Threading.ThreadPool.GetMaxThreads(out Workers, out Completion);
                Percentage = float.Parse(Setting.Substring(0, Setting.Length - 1)) / 100.0f;

                return (uint)(Workers * Percentage);
            }
            else
                return uint.Parse(Setting);
        }

        public void ReadNpdbSettings(string prefix, bool allowMissing)
        {
            if (null == prefix)
                throw new ArgumentNullException("prefix");

            try { maximumThreshold = GetThreadSetting(prefix + FastFail.Settings.Setting_ResourceMaxThr); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }

            try { minimumThreshold = GetThreadSetting(prefix + FastFail.Settings.Setting_ResourceMinThr); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }

            try { captureTimeWindow = TimeSpan.FromSeconds((uint)Config.GetIntSetting(prefix + FastFail.Settings.Setting_ResourceWindow)); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }
        }

        #region Properties
        public uint MaximumThreshold
        {
            get { return maximumThreshold; }
            set { maximumThreshold = value; }
        }

        public uint MinimumThreshold
        {
            get { return minimumThreshold; }
            set { minimumThreshold = value; }
        }

        public TimeSpan CaptureTimeWindow
        {
            get { return captureTimeWindow; }
            set { captureTimeWindow = value; }
        }

        public FastFailThrottleSelector ThrottlingSelector
        {
            get { return throttlingSelector; }
            set { throttlingSelector = value; }
        }
        #endregion

        private uint maximumThreshold;
        private uint minimumThreshold;
        private TimeSpan captureTimeWindow;
        private FastFailThrottleSelector throttlingSelector;
    }

    public partial class FastFailResource
    {
        public FastFailResource(string name, FastFailResourceConfig configuration)
        {
            if (null == name)
                throw new ArgumentNullException("name");

            this.name = name.ToLower();
            this.currentThresholdLock = new object();
            this.threadCount = 0;

            this.globalPerformance = FastFailPerformanceCategory.GetPerformanceCategory(this.name);
            if (null != this.globalPerformance)
                this.instancedPerformance = this.globalPerformance[Config.ComponentName];

            Configure(configuration);
        }

        public FastFailResource(string name)
            : this(name, new FastFailResourceConfig()) { }

        #region Exposed Methods
        public void InvalidateThreshold()
        {
            Interlocked.Exchange(ref currentThresholdValid, 0);
        }

        public void IngestEvent(DateTime start, DateTime end, FastFailResult result)
        {
            //Update performance counters
            AdjustEventCounters(start, end, result);

            lock (Statistics.IngestionLock)
            {
                //make sure we are writing to the correct bucket
                Statistics.AdvanceWindow();

                //write to the bucket
                Statistics.AggregatedFeatures.IngestEvent(start, end, result);
            }

            InvalidateThreshold();
        }

        public bool ClaimThread()
        {
            if (Interlocked.Increment(ref threadCount) > CurrentThreshold)
            {
                Interlocked.Decrement(ref threadCount);
                IncrementDenialCounter();
                return false;
            }
            else
            {
                IncrementThreadCounter();
                return true;
            }
        }

        public void ReleaseThread()
        {
            Interlocked.Decrement(ref threadCount);
            DecrementThreadCounter();
        }

        public void Configure(FastFailResourceConfig configuration)
        {
            if (null == configuration)
                throw new ArgumentNullException("configuration");
            if (null == configuration.ThrottlingSelector)
                throw new ArgumentNullException("configuration.ThrottlingSelector");

            // synchronization notes
            lock (this)
            { //only one configuration at a time simultaneously
                lock (currentThresholdLock)
                { //cannot configure and acquire simultaneously
                    object ingestionLock = statistics == null ? null : statistics.IngestionLock;

                    if (null != ingestionLock)
                        Monitor.Enter(ingestionLock); //cannot configure and ingest simultaneously

                    try
                    {
                        maximumThreshold = Math.Max(configuration.MaximumThreshold, configuration.MinimumThreshold);
                        minimumThreshold = Math.Min(configuration.MaximumThreshold, configuration.MinimumThreshold);
                        ThrottlingSelector = configuration.ThrottlingSelector;
                        statistics = new FastFailStatistics(configuration);
                    }
                    finally
                    {
                        if (null != ingestionLock)
                            Monitor.Exit(ingestionLock);
                    }
                }
            }
        }
        #endregion

        #region Private Methods
        private uint CalculateThreshold()
        {
            if (!ThrottlingDisabled)
            {
                float Adjustment;
                int Range;

                Adjustment = ThrottlingSelector.SelectThrottle(Statistics);

                if (float.IsNaN(Adjustment))
                { // invalid operation on NaN LSG:5961
                    throw new InvalidOperationException(
                       string.Format("throttling function {0} returned NaN", ThrottlingSelector.GetType().Name));
                }

                Adjustment = Math.Min(1.0f, Adjustment);
                Adjustment = Math.Max(0.0f, Adjustment);
                Range = (int)MaximumThreshold - (int)MinimumThreshold;

                return (uint)(MinimumThreshold + Range * Adjustment);
            }
            else
                return MaximumThreshold;
        }
        #endregion

        #region Properties
        public string Name
        {
            get { return name; }
        }

        public uint MaximumThreshold
        {
            get { return maximumThreshold; }
        }

        public uint MinimumThreshold
        {
            get { return minimumThreshold; }
        }

        public virtual bool ThrottlingDisabled
        {
            get { return FastFail.Settings.ThrottlingDisabled; }
        }

        public FastFailThrottleSelector ThrottlingSelector
        {
            get { return throttlingSelector; }
            set
            {
                Interlocked.Exchange(ref throttlingSelector, value);
                InvalidateThreshold();
            }
        }

        public FastFailStatistics Statistics
        {
            get { return statistics; }

        }

        public uint ThreadCount
        {
            get { return (uint)threadCount; }
        }

        public uint CurrentThreshold
        {
            get
            {
                uint result = 0;

                lock (currentThresholdLock)
                {
                    if ((0 == Interlocked.Exchange(ref currentThresholdValid, 1)) | statistics.AdvanceWindow())
                        currentThreshold = (int)CalculateThreshold();

                    result = (uint)currentThreshold;
                }

                ChangeUtilizationDenominator(result);

                return result;
            }
        }

        public FastFailPerformanceCategory GlobalPerformance
        {
            get { return globalPerformance; }
        }

        public FastFailPerformanceCategory InstancedPerformance
        {
            get { return instancedPerformance; }
        }
        #endregion

        private string name;
        private uint maximumThreshold;
        private uint minimumThreshold;
        private FastFailThrottleSelector throttlingSelector;
        private FastFailStatistics statistics;
        private int threadCount;
        private int currentThreshold;
        private int currentThresholdValid;
        private object currentThresholdLock;
        private FastFailPerformanceCategory globalPerformance;
        private FastFailPerformanceCategory instancedPerformance;
    }

    public class CriticalFastFailResource : FastFailResource
    {
        public CriticalFastFailResource(string name, FastFailResourceConfig configuration)
            : base(name, configuration) { }

        public CriticalFastFailResource(string name)
            : base(name) { }

        public override bool ThrottlingDisabled
        {
            get { return true; }
        }
    }

    public static class FastFail
    {
        public class FastFailResourceContext
        {
            public FastFailResourceContext(FastFailResource resource)
            {
                if (null == resource)
                    throw new ArgumentNullException("resource");

                _resource = resource;
                _pendingConfigPrefix = null;
            }

            public void InvalidateConfiguration(string prefix)
            {
                Interlocked.Exchange(ref _pendingConfigPrefix, prefix);
            }

            public string GetAndClearConfigPrefix()
            {
                return Interlocked.Exchange(ref _pendingConfigPrefix, null);
            }

            public FastFailResource Resource
            {
                get { return _resource; }
            }

            private FastFailResource _resource;
            private string _pendingConfigPrefix;
        }

        public static class Settings
        {
            public const string Setting_ResourceMaxThr = "_fastFailMaxThreshold";
            public const string Setting_ResourceMinThr = "_fastFailMinThreshold";
            public const string Setting_ResourceWindow = "_fastFailWindow";

            static Settings()
            {
                Config.SettingChange += new SettingChangeEventHandler(SettingChangeEventHandler);
            }

            private static void LoadSettings()
            {
                using (FastFailTracker Npdb = new FastFailTracker(FastFail.NpdbResource))
                {
                    // takes affect immediately
                    try { throttlingDisabled = Config.GetBoolSetting(Setting.fastfail_disableThrottling); }
                    catch (ApplicationException) { }

                    // resources needs to be reconfigured in order for this to take affect
                    try { FastFailFeature.BucketCount = Config.GetUIntSetting(Setting.fastfail_bucketCount); }
                    catch (ApplicationException) { }

                    Npdb.IndicateSuccess();
                }
            }

            private static void InvalidateResourceConfiguration(string resourceName, string prefix)
            {
                if (FastFail.IsResourcePresent(resourceName))
                {
                    FastFailResourceContext context;

                    context = FastFail.GetResourceContext(resourceName);
                    context.InvalidateConfiguration(prefix);
                }
            }

            private static void RegisterSettingListener(string setting, string resourceName, string prefix)
            {
                setting = setting.ToLower();

                if (!SettingMappings.ContainsKey(setting))
                    SettingMappings.Add(setting, new List<KeyValuePair<string, string>>());

                SettingMappings[setting].Add(new KeyValuePair<string, string>(resourceName, prefix));
            }

            public static void RegisterNpdbListener(string resourceName, string prefix)
            {
                if (null == prefix)
                    throw new ArgumentNullException("prefix");
                if (null == resourceName)
                    throw new ArgumentNullException("resourceName");

                if (!ConfiguredResources.ContainsKey(resourceName.ToLower()))
                {
                    ConfiguredResources.Add(resourceName.ToLower(), null);

                    RegisterSettingListener(prefix + Setting_ResourceMaxThr, resourceName, prefix);
                    RegisterSettingListener(prefix + Setting_ResourceMinThr, resourceName, prefix);
                    RegisterSettingListener(prefix + Setting_ResourceWindow, resourceName, prefix);
                }
            }

            private static void SettingChangeEventHandler(object sender, SettingChangeEventArgs args)
            {
                if (args.Setting == Setting.fastfail_bucketCount)
                    LoadSettings();
                else if (SettingMappings.ContainsKey(args.Setting.ToLower()))
                {
                    foreach (KeyValuePair<string, string> item in SettingMappings[args.Setting.ToLower()])
                        InvalidateResourceConfiguration(item.Key, item.Value);
                }
            }

            #region Properties
            public static string ComponentName
            {
                get { return Config.ComponentName; }
            }

            public static bool ThrottlingDisabled
            {
                get
                {
                    if (!throttlingDisabled.HasValue)
                        LoadSettings();

                    return throttlingDisabled.Value;
                }
            }

            private static Dictionary<string, List<KeyValuePair<string, string>>> SettingMappings
            {
                get { return settingMappings ?? (settingMappings = new Dictionary<string, List<KeyValuePair<string, string>>>()); }
            }

            private static Dictionary<string, object> ConfiguredResources
            {
                get { return configuredResources ?? (configuredResources = new Dictionary<string, object>()); }
            }

            private static object SyncObject
            {
                get { return syncObject ?? (syncObject = new object()); }
            }
            #endregion

            private static bool? throttlingDisabled = false;
            private static Dictionary<string, List<KeyValuePair<string, string>>> settingMappings;
            private static Dictionary<string, object> configuredResources;
            private static object syncObject;
        }

        private static readonly CriticalFastFailResource NpdbResource;

        static FastFail()
        {
            // intialize the performance counters (LSG: 6088)
            XomPerformanceCounterCategory.InitPerfCtrs();

            NpdbResource = new CriticalFastFailResource("safenpdb");
        }

        public static void RegisterNpdbListener(string resourceName, string prefix)
        {
            Settings.RegisterNpdbListener(resourceName, prefix);
        }

        public static FastFailResource ConfigureResource(string resourceName, FastFailResourceConfig configuration)
        {
            FastFailResource resource;

            if (null == resourceName)
                throw new ArgumentNullException("resourceName");
            if (null == configuration)
                throw new ArgumentNullException("configuration");

            resourceName = resourceName.ToLower();

            lock (TrackingCache)
            {
                if (TrackingCache.ContainsKey(resourceName))
                {
                    resource = TrackingCache[resourceName].Resource;
                    resource.Configure(configuration);
                }
                else
                {
                    resource = new FastFailResource(resourceName, configuration);
                    TrackingCache.Add(resourceName, new FastFailResourceContext(resource));
                }
            }

            return resource;
        }

        internal static bool IsResourcePresent(string resourceName)
        {
            if (null == resourceName)
                throw new ArgumentNullException("resourceName");

            resourceName = resourceName.ToLower();

            return TrackingCache.ContainsKey(resourceName);
        }

        public static FastFailResourceContext GetResourceContext(string resourceName)
        {
            if (null == resourceName)
                throw new ArgumentNullException("resourceName");

            resourceName = resourceName.ToLower();

            if (TrackingCache.ContainsKey(resourceName))
                return TrackingCache[resourceName];
            else
            {
                Xom.NtEvent(XEvent.Id.FAST_FAIL_MISSING_RESOURCE,
                   "FastFail - " + resourceName + " - " +
                   "resource is not found, may be caused by codebase failure to configure the resource."
                );

                throw new FastFailTrackerMissingException(resourceName);
            }
        }

        public static FastFailResource GetResource(string resourceName)
        {
            FastFailResourceContext context = GetResourceContext(resourceName);

            return context.Resource;
        }

        private static Dictionary<string, FastFailResourceContext> TrackingCache
        {
            get { return trackingCache != null ? trackingCache : trackingCache = new Dictionary<string, FastFailResourceContext>(); }
        }

        private static object SyncBlock
        {
            get { return syncBlock != null ? syncBlock : syncBlock = new object(); }
        }

        private static Dictionary<string, FastFailResourceContext> trackingCache;
        private static object syncBlock;
    }

    public class FastFailTracker : IDisposable
    {
        public FastFailTracker(FastFailResource resource)
        {
            InitializeTracker(resource, null);
        }

        public FastFailTracker(string resourceName)
        {
            FastFail.FastFailResourceContext context;

            context = FastFail.GetResourceContext(resourceName);

            InitializeTracker(
               context.Resource,
               context.GetAndClearConfigPrefix());
        }

        // when a non-null prefix is specified, the resource is configured before claiming a thread
        private void InitializeTracker(FastFailResource resource, string prefix)
        {
            this.result = null;
            this.tracker = resource;

            if (null != prefix)
            {
                resource.Configure(
                   FastFailResourceConfig.CreateFromResource(resource, prefix, true));
            }

            if (!this.tracker.ClaimThread())
                throw new FastFailException(this.tracker.Name);

            this.start = FastFailClock.Clock.Now;
        }

        #region Exposed Methods
        public void IndicateFailure()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Failure;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void IndicateSuccess()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Success;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void IndicateTimeout()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Timeout;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void Dispose()
        {
            IndicateFailure();
        }
        #endregion

        #region Properties
        public FastFailResource Tracker
        {
            get { return tracker; }
        }

        public DateTime StartTime
        {
            get { return this.start; }
        }

        public string ResourceName
        {
            get { return tracker.Name; }
        }
        #endregion

        private FastFailResource tracker;
        private DateTime start;
        private FastFailResult? result;
    }

    public class FastFailThrottleSelector
    {
        public FastFailThrottleSelector(float throttle)
        {
            this.throttle = throttle;
        }

        public FastFailThrottleSelector()
            : this(1.0f) { }

        public virtual float SelectThrottle(FastFailStatistics statistics)
        {
            return throttle;
        }

        private float throttle;
    }

    public class FastFailSquareThrottleSelector : FastFailThrottleSelector
    {
        public FastFailSquareThrottleSelector() : this(0.5f) { }
        public FastFailSquareThrottleSelector(float tolerance)
        {
            Tolerance = tolerance;
        }

        public override float SelectThrottle(FastFailStatistics statistics)
        {
            if (statistics.AggregatedFeatures.TimeoutRatio > tolerance)
                return 0.0f;

            return 1.0f;
        }

        public float Tolerance
        {
            get { return tolerance; }
            set
            {
                if (tolerance > 1 || tolerance < 0)
                    throw new ArgumentOutOfRangeException("value", tolerance, "range must be in [0, 1]");
                tolerance = value;
            }
        }

        private float tolerance;
    }

    [Serializable]
    public class BaseFastFailException : Exception
    {
        public BaseFastFailException() : base("") { }
        public BaseFastFailException(string resourceName) : this(resourceName, "") { }
        public BaseFastFailException(string resourceName, string message) : this(resourceName, message, null) { }
        public BaseFastFailException(string resourceName, string message, Exception inner)
            : base(message, inner)
        {
            this.resourceName = resourceName;
        }
        protected BaseFastFailException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            resourceName = info.GetString("resourceName");
        }

        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("resourceName", resourceName);
        }

        public string ResourceName
        {
            get { return resourceName; }
        }

        protected virtual string DefaultMessage
        {
            get { return string.Format("Encountered error for resource '{0}'.", resourceName ?? "(unnamed)"); }
        }

        public override string Message
        {
            get
            {
                string BaseMessage = base.Message;

                if (string.IsNullOrEmpty(BaseMessage))
                    BaseMessage = DefaultMessage;

                return BaseMessage;
            }
        }

        private string resourceName;
    }

    [Serializable]
    public class FastFailException : BaseFastFailException
    {
        public FastFailException() : base("") { }
        public FastFailException(string resourceName) : this(resourceName, "") { }
        public FastFailException(string resourceName, string message) : this(resourceName, message, null) { }
        public FastFailException(string resourceName, string message, Exception inner) : base(resourceName, message, inner) { }

        protected FastFailException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }

        protected override string DefaultMessage
        {
            get { return string.Format("Resource '{0}' has reached its thread threshold.", ResourceName ?? "(unnamed)"); }
        }
    }

    [Serializable]
    public class FastFailTrackerMissingException : BaseFastFailException
    {
        public FastFailTrackerMissingException() : base("") { }
        public FastFailTrackerMissingException(string resourceName) : this(resourceName, "") { }
        public FastFailTrackerMissingException(string resourceName, string message) : this(resourceName, message, null) { }
        public FastFailTrackerMissingException(string resourceName, string message, Exception inner) : base(resourceName, message, inner) { }

        protected FastFailTrackerMissingException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }

        protected override string DefaultMessage
        {
            get { return string.Format("Configuration not performed for resource '{0}'.", ResourceName ?? "(unnamed)"); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastPool.cs ===
using System;
using System.Threading;

namespace STF.common.service
{    
    public class FastPool
    {
        public class PoolItem
        {
            public PoolItem()
            {
                _iLocked = 0;
                _o = null;
            }
            
            public int _iLocked;
            public Object _o;
        }

        public class WaitContext
        {
            public WaitContext()
            {
                _event = new ManualResetEvent(false);
            }
            
            public Object _o;
            public ManualResetEvent _event;
        }

        // using this constructor will create a pool that can be empty.
        // if Obtain() is called on an empty pool, an InvalidOperationException will be thrown.
        public FastPool(int size) : this(size, 0, true) {}

        // using this constructor will create a pool that can be empty.
        // if Obtain() is called on an empty pool, and fUseExceptions is false, null is returned.
        public FastPool(int size, bool fUseExceptions) : this(size, 0, fUseExceptions) {}

        // using this constructor will create a pool with an accompanying queue to store wait contexts.
        // if Obtain is called on an empty pool, the call will block until one of the pool items becomes available.
        public FastPool(int poolSize, int queueSize) : this(poolSize, queueSize, true) {}

        // using this constructor will create a pool with an accompanying queue to store wait contexts.
        // if Obtain is called on an empty pool, the call will block until one of the pool items becomes available.
        // if Obtain() is called on an empty pool, and fUseExceptions is false, null is returned.
        public FastPool(int poolSize, int queueSize, bool fUseExceptions)
        {
            _iSize = poolSize;
            _iLastInserted = 0;
            _iLastObtained = 0;
            _fUseExceptions = fUseExceptions;
            _rgItems = new PoolItem[_iSize];

            if (queueSize != 0)
            {
                _waitQueue = new FastQueue(queueSize, fUseExceptions);
            }
            else
            {
                _waitQueue = null;
            }

            for (int i = 0; i < _iSize; i++)
            {
                _rgItems[i] = new PoolItem();
            }
        }

        ~FastPool()
        {
            for (int i = 0; i < _iSize; i++)
            {
                _rgItems[i]._o = null;
                _rgItems[i] = null;
            }
        }

        public bool Insert(Object o)
        {
            if (o == null)
            {
                if (_fUseExceptions)
                {
                    throw new ArgumentException("object cannot be null.");
                }
                else
                {
                    return false;
                }
            }

            if (_waitQueue != null)
            {
                if (_fUseExceptions)
                {
                    try
                    {
                        WaitContext wc = (WaitContext)_waitQueue.Dequeue();

                        // there is a context waiting on a free object.  we have one.
                        wc._o = o;
                        wc._event.Set();

                        // this object is transferred to the wait context and does not go back into the pool at this time.
                        return true;
                    }
                    catch (InvalidOperationException)
                    {
                        // do nothing.
                    }
                }
                else
                {
                    WaitContext wc = (WaitContext)_waitQueue.Dequeue();

                    if (wc != null)
                    {
                        // there is a context waiting on a free object.  we have one.
                        wc._o = o;
                        wc._event.Set();

                        // this object is transferred to the wait context and does not go back into the pool at this time.
                        return true;
                    }
                }
            }

            // a good place to start.
            int iSlot = _iLastObtained;
            int slotsChecked = 0;
            bool fInserted = false;

            while (slotsChecked < _iSize)
            {
                // is it unlocked?
                if (0 == Interlocked.Exchange(ref _rgItems[iSlot]._iLocked, 1))
                {
                    // now we have this slot locked.
                    
                    // is it empty?
                    if (_rgItems[iSlot]._o == null)
                    {
                        // take it.
                        _rgItems[iSlot]._o = o;
                        fInserted = true;
                    }
                    
                    // unlock the slot either way
                    _rgItems[iSlot]._iLocked = 0;
                }

                // did we find a slot?
                if (fInserted)
                {
                    // do this while unlocked.  the next person to call obtain will find an unlocked slot filled with this item.
                    _iLastInserted = iSlot;

                    // we're done!
                    break;
                }

                // next slot
                iSlot = (iSlot + 1) % _iSize;
                ++slotsChecked;
            }

            if (!fInserted)
            {
                // cycled the pool and found no unlocked free slots.
                if (_fUseExceptions)
                {
                    throw new InvalidOperationException("pool full");
                }
                else
                {
                    return false;
                }
            }

            return true;
        }

        public Object Obtain()
        {
            Object o = null;
            
            // a good place to start.
            int iSlot = _iLastInserted;
            int slotsChecked = 0;

            while (slotsChecked < _iSize)
            {
                // is it unlocked?
                if (0 == Interlocked.Exchange(ref _rgItems[iSlot]._iLocked, 1))
                {
                    // now we have this slot locked.
                    
                    // is it filled?
                    if (_rgItems[iSlot]._o != null)
                    {
                        // empty it.
                        o = _rgItems[iSlot]._o;
                        _rgItems[iSlot]._o = null;
                    }
                    
                    // unlock the slot either way
                    _rgItems[iSlot]._iLocked = 0;
                }

                // did we obtain an item?
                if (o != null)
                {
                    // do this while unlocked.  the next person to call insert will find this unlocked slot that is empty.
                    _iLastObtained = iSlot;

                    // we're done!
                    break;
                }

                // next slot (traverse backwards)
                iSlot = (iSlot +_iSize - 1) % _iSize;
                ++slotsChecked;
            }

            if (o == null)
            {
                if (_waitQueue != null)
                {
                    // cycled the pool and found no unlocked free slots.
                    WaitContext wc = new WaitContext();

                    // put context on the queue and wait for an object to become free                
                    _waitQueue.Enqueue(wc);
                    wc._event.WaitOne();

                    // context now contains the free object.
                    o = wc._o;
                }
                else
                {
                    if (_fUseExceptions)
                    {
                        throw new InvalidOperationException("pool empty");
                    }
                    else
                    {
                        return null;
                    }
                }
            }

            return o;
        }

        private PoolItem[] _rgItems;
        private int _iLastInserted;
        private int _iLastObtained;
        private int _iSize;
        private bool _fUseExceptions;
        private FastQueue _waitQueue;
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastThreadPool.cs ===
// VxFastThreadPool.cs
//
// Copyright (c) 2010 Microsoft Corporation. All Rights Reserved.
//
// A fast, low-overhead thread pool for all your needs. Spins up threads faster than 
// .Net's ThreadPool class. Uses no locks. Minimizes context switches if you are willing 
// to tolerate some latency. Queue size can be capped. Your callback method is expected to 
// catch all exceptions.
// 
// Author: mattchil (original FastThreadPool)
// Author: kgoodier 7/2010 (adapted from the new XCache FastThreadPool)
//

using System;
using System.Threading;
using System.Diagnostics;
using System.Collections.Generic;

using STF.common.mgmt;

namespace STF.common.service
{

    public interface IThreadPool
    {
        bool QueueUserWorkItem(WaitCallback callback, object o);
    }

    public class DotNetThreadPool : IThreadPool
    {
        public static DotNetThreadPool Default = new DotNetThreadPool();

        public bool QueueUserWorkItem(WaitCallback callback, object o)
        {
            return ThreadPool.QueueUserWorkItem(callback, o);
        }
    }

    public class FastThreadPool : IThreadPool
    {
        public FastThreadPool(string instanceName, int poolSize, ThreadPriority priority)
            : this(instanceName, poolSize, poolSize, priority, 0, 0)
        {
        }

        public FastThreadPool(string instanceName, int poolSize, int maxPoolSize, ThreadPriority priority)
            : this (instanceName, poolSize, maxPoolSize, priority, 0, 0)
        {
        }

        public FastThreadPool(string instanceName, int poolSize, int maxPoolSize, ThreadPriority priority, int maxLatencyMs, int maxWorkItemQueueSize)
        {
            // Note: set maxLatencyMs to 0 to disable this feature, and return to "enqueue 
            // item and wake up a thread" model. set maxWorkItemQueueSize to 0 (or maxint) 
            // to allow unbounded growth.

            _counters = FastThreadPoolCounters.Total[instanceName];
            _queueWorkItems = new LockFreeQueue<WorkItem>();
            _event = new AutoResetEvent(false);
            _fAlive = true;
            _priority = priority;

            _numWaitingThreads = 0;
            _numAwakenings = 0;
            _numItemsProcessed = 0;

            // Use properties for setting these things
            MaxThreadCount = maxPoolSize;

            // This will create the threads
            _listThreads = new List<XboxLiveThread>(poolSize);
            ThreadCount = poolSize;

            // This will apply some safety checks
            MaxQueueCount = maxWorkItemQueueSize;

            // This will configure the timer as well
            MaxLatencyMs = maxLatencyMs;
        }

        // 
        // Read/write properties
        //

        public int MaxThreadCount
        {
            get { return _maxPoolSize; }
            set { _maxPoolSize = value; }
        }

        public int ThreadCount
        {
            get 
            { 
                return _listThreads.Count; 
            }
            set 
            {
                // Can't shrink, sorry.
                Grow(value - _listThreads.Count);
            }
        }

        public int MaxLatencyMs
        {
            get 
            { 
                return _maxLatencyMs; 
            }
            set 
            { 
                _maxLatencyMs = value; 
                ConfigureTimer();
            }
        }

        public int MaxQueueCount
        {
            get 
            { 
                return _maxWorkItemQueueSize; 
            }
            set 
            { 
                _maxWorkItemQueueSize = value > 0 ? value : int.MaxValue;
            }
        }

        //
        // Read-only properties
        //

        public int QueueCount
        {
            get { return _queueWorkItems.Count; }
        }

        public int ThreadsWaiting
        {
            get { return _numWaitingThreads; }
        }

        public long NumberOfAwakenings
        {
            get { return _numAwakenings; }
        }

        public long NumberOfItemsProcessed
        {
            get { return _numItemsProcessed; }
        }

        //
        // Public methods
        //

        public bool Grow(int threadCount)
        {
            for (int i = 0; i < threadCount; i++)
            {
                if (!AddThread())
                {
                    return false;
                }
            }
            return true;
        }

        public void Shutdown()
        {
            _fAlive = false;

            for (int iThread = 0; iThread < _listThreads.Count; iThread++)
            {
                _event.Set();
            }
            
            for (int iThread = 0; iThread < _listThreads.Count; iThread++)
            {
                _listThreads[iThread].Interrupt(); // not perfect, Abort() may be better (but meaner)
                _listThreads[iThread].Join();
            }
        }
        
        public bool QueueUserWorkItem(WaitCallback callback, object o)
        {
            if (_queueWorkItems.Count >= _maxWorkItemQueueSize)
            {
                return false;
            }

            WorkItem workItem = new WorkItem(callback, o);

            _queueWorkItems.Enqueue(workItem);
            _counters.QueueLength.Increment();
            if (_maxLatencyMs <= 0)
            {
                _event.Set();
            }
            
            return true;
        }

        // 
        // Private methods
        //

        private void ConfigureTimer()
        {
            if (_maxLatencyMs > 0)
            {
                // Start or change timer
                if (_freshnessTimer == null)
                {
                    _freshnessTimer = new Timer(
                        new TimerCallback(FreshnessCallback),
                        null,
                        _maxLatencyMs,
                        _maxLatencyMs);
                }
                else
                {
                    _freshnessTimer.Change(_maxLatencyMs, _maxLatencyMs);
                }
            }
            else
            {
                // Stop timer
                if (_freshnessTimer != null)
                {
                    _freshnessTimer.Dispose();
                    _freshnessTimer = null;
                }
            }
        }

        private void FreshnessCallback(object state)
        {
            try
            {
                if (_queueWorkItems.Count > 0)
                {
                    _event.Set();
                }
            }
            catch (Exception)
            {
                // Really shouldn't fail, but just in case we don't want this to go
                // unhandled.
            }
        }

        private bool AddThread()
        {
            if (_listThreads.Count >= _maxPoolSize)
            {
                return false;
            }

            XboxLiveThread thread;
            thread = new XboxLiveThread(new ThreadStart(ThreadProc));
            thread.Priority = _priority;
            thread.Start();
            _listThreads.Add(thread);
            return true;
        }


        private class WorkItem
        {
            public WorkItem(WaitCallback callback, object o)
            {
                _callback = callback;
                _o = o;
                _elapsed = new XomRequestTimeElapsed();
            }
            
            public WaitCallback _callback;
            public object _o;
            public XomRequestTimeElapsed _elapsed;
        }
        
        private void ThreadProc()
        {
            while (_fAlive)
            {
                try
                {
                    WorkItem item = null;
                    long processCount = 0;

                    _counters.ThreadsActive.Increment();
                    while (_queueWorkItems.TryDequeue(out item))
                    {
                        processCount++;

                        _counters.QueueLength.Decrement();
                        _counters.WaitTimeAvg.IncrementBy(item._elapsed.MillisecondsElapsed);
                        _counters.WaitTimeAvgBase.Increment();
                        try
                        {
                            item._callback(item._o);
                        }
                        catch (Exception)
                        {
                            // this should never happen.  the callback is expected to catch 
                            // all exceptions.  we're going to swallow it to avoid xmgmt and 
                            // events.
                        }
                        _counters.CompletionRate.Increment();
                    }

                    Interlocked.Increment(ref _numAwakenings);
                    Interlocked.Add(ref _numItemsProcessed, processCount);

                    // nothing on the queue.  go to sleep.
                    Interlocked.Increment(ref _numWaitingThreads);
                    _counters.ThreadsActive.Decrement();
                    _counters.ThreadsIdle.Increment();
                    try
                    {
                        _event.WaitOne();
                    }
                    catch (Exception e)
                    {
                        if (!(e is ThreadInterruptedException))
                        {
                            Xom.NtEvent(XEvent.Id.THREADPOOL_THREAD_EXCEPTION, e, "FastThreadPool::ThreadProc() threw an exception.");
                        }
                    }
                    finally
                    {
                        _counters.ThreadsIdle.Decrement();
                        Interlocked.Decrement(ref _numWaitingThreads);
                    }
                }
                catch (ThreadAbortException)
                {
                }
                catch (ThreadInterruptedException)
                {
                }
                // We use XboxLiveThreads, which will catch and log unhandled exceptions.  Let 
                // it go so we don't have to have an event defined here or take an xmgmt 
                // dependency.
            }
        }

        private List<XboxLiveThread> _listThreads;
        private LockFreeQueue<WorkItem> _queueWorkItems;
        private AutoResetEvent _event;
        private int _maxPoolSize;
        private int _maxLatencyMs;
        private  ThreadPriority _priority;
        private int _maxWorkItemQueueSize;
        private bool _fAlive;
        private Timer _freshnessTimer;
        private FastThreadPoolCounters _counters;

        private int _numWaitingThreads;
        private long _numAwakenings;
        private long _numItemsProcessed;
    }

    [XomPerformanceCounterCategoryAttr( "FastThreadPool", "XBox Live Thread Pool" )]
    public class FastThreadPoolCounters : XomPerformanceCounterCategory
    {
        public FastThreadPoolCounters() : base(true)
        {
        }
        
        public virtual FastThreadPoolCounters this[string instanceName]
        {
            get
            {
                return (FastThreadPoolCounters) GetInstance(instanceName);
            }
        }

        static public FastThreadPoolCounters Total = new FastThreadPoolCounters();
        
        [XomPerformanceCounterAttr(
            "Completion Rate", 
            "Total number of all contexts per second processed by the threadpool.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompletionRate;

        [XomPerformanceCounterAttr(
            "Threads Active", 
            "Total number of threads in use.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ThreadsActive;
        
        [XomPerformanceCounterAttr(
            "Threads Idle", 
            "Total number of threads idle.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ThreadsIdle;

        [XomPerformanceCounterAttr(
            "Queue Length", 
            "Total number of work items waiting to be started.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueueLength;

        [XomPerformanceCounterAttr(
            "Context Wait Time (ms)", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter WaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Wait Time Base", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTimeAvgBase;

    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigInstance.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Xml;
using System.Globalization;
using Microsoft.Win32;

namespace STF.common.config
{
    // Since it is no longer possible for the config code to reference Xom explicitly,
    // Add the code to perform XomLogging via a delegate.  All of the code that performs
    // Logging in config should now go through the event delegate, which in xonline
    // builds should point to Xom.NtEvent

    public delegate void LogEventHandler(uint eventId, string message, string componentName);

    // No explicit initialization is required by the component
    // to get configuration information. The current environment name, siteid, server name,
    // and component name are detected automatically by the class. The current
    // component name is set to the current assembly name for C# components. Non-C#
    // components or C# components that need or want to specify a different component name
    // (e.g. shared code) may use one of the GetSetting overrides.
    [ComVisible(false)]
    public partial class ConfigInstance : ConfigEventLogger
    {
        public event LogEventHandler HandleLogEvent;

        public interface IConfigurationOverride
        {
            string GetInjectedNpdbValue(string setting, string value);
        }

        /// <summary>
        /// This class encapsulates all NPDB discovery logic.  This logic was moved out of
        /// the Config class on 5/8/2008 so that very restricted locking could occur
        /// on the setting of _npdbServer and _npdbDatabase via lock(this), rather than
        /// piggy-backing on _rwLock in the Config class.
        /// </summary>
        private class NpdbInfo
        {
            private readonly ConfigInstance _configInstance;
            private string _npdbServer;
            private string _npdbDatabase;

            public NpdbInfo(ConfigInstance instance, string npdbServer, string npdbDatabase)
            {
                _configInstance = instance;
                _npdbServer = npdbServer;
                _npdbDatabase = npdbDatabase;
            }

            public string NpdbServer
            {
                get
                {
                    string capturedErrors = "";

                    if (_npdbServer != null)
                    {
                        // we've already figured out where NPDB lives, so return it
                        return _npdbServer;
                    }

                    lock (this)
                    {
                        if (_npdbServer != null)
                        {
                            // we've already figured out where NPDB lives, so return it
                            return _npdbServer;
                        }

                        // 1st precedence is to use the server specified in the XBL_CONFIG_SERVER environment variable
                        string serverEnvSetting = System.Environment.GetEnvironmentVariable(_xblConfigServerEnvVarName);
                        if (serverEnvSetting != null)
                        {
                            _npdbServer = serverEnvSetting;

                            _configInstance.LogNtEvent(
                                ConfigEvent.Id.COMMON_INFO_9,
                                "Using NPDB server specified in '" + _xblConfigServerEnvVarName + 
                                "' environment variable, value: " + _npdbServer
                            );

                            return _npdbServer;
                        }

                        // 2nd precedence is to use the server specified in the Server value in the registry key:
                        // \HKLM\Software\Microsoft\XboxLive\CommonConfig
                        RegistryKey commonConfig = Registry.LocalMachine.OpenSubKey(_CommonConfigRegKeyPath);
                        if (commonConfig != null)
                        {
                            object o = commonConfig.GetValue(_ServerRegValueName);

                            if (o != null)
                            {
                                // we should be able to cast this to a string, but we don't want to
                                // completely fail if the cast is bad
                                try
                                {
                                    string temp = (string) o;

                                    _npdbServer = temp;

                                    _configInstance.LogNtEvent(
                                        ConfigEvent.Id.COMMON_INFO_10,
                                        "Using NPDB server specified in registry at '" +
                                        _CommonConfigRegKeyPath + "', value: " + _npdbServer
                                    );

                                    return _npdbServer;
                                }
                                catch (InvalidCastException)
                                {
                                    string errorMessage = "Unable to cast '" +
                                                          _ServerRegValueName +
                                                          "' registry value at path '" + _CommonConfigRegKeyPath +
                                                          "' to a string. This registry setting will be ignored";
                                    capturedErrors += errorMessage + "\n";
                                    _configInstance.LogNtEvent(
                                        ConfigEvent.Id.COMMON_CONFIG_71,
                                        errorMessage
                                    );
                                }
                            }
                        }

                        // 3rd precedence is to use the server pointed to by DNS
                        GetHostByName delegateGetHostByName = Dns.GetHostEntry;
                        IAsyncResult iAsyncResult = delegateGetHostByName.BeginInvoke(
                            _xblConfigServerDNSName,
                            null,
                            null);

                        // wait for up to iTimeoutMilliseconds for the read operation
                        // to complete
                        bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(_xblConfigDNSTimeout, false);
                        if (!bSignal)
                        {
                            // the wait timed out, log an NT event noting this, and move along
                            string errorMessage = "Dns.GetHostByName(" + _xblConfigServerDNSName +
                                                  ") timed out. DNS will not be used to find NPDB";
                            capturedErrors += errorMessage + "\n";
                            _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_72, errorMessage);
                        }
                        else
                        {
                            try
                            {
                                IPHostEntry ipHostEntry = delegateGetHostByName.EndInvoke(iAsyncResult);
                                if (ipHostEntry == null)
                                {
                                    // apparently there was no record, log an NT event noting this, and move along
                                    string errorMessage = "Dns.GetHostByName(" + _xblConfigServerDNSName +
                                                          ") returned null. DNS will not be used to find NPDB";
                                    capturedErrors += errorMessage + "\n";
                                    _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_73, errorMessage);
                                }
                                else
                                {
                                    if (ipHostEntry.AddressList.Length < 1)
                                    {
                                        // apparently there was a record, but no addresses for it.
                                        // log an NT event noting this, and move along
                                        string errorMessage = "Dns.GetHostByName(" +
                                                              _xblConfigServerDNSName +
                                                              ") returned a zero length list of IP addresses. DNS will not be used to find NPDB";
                                        capturedErrors += errorMessage + "\n";
                                        
                                        _configInstance.LogNtEvent(
                                            ConfigEvent.Id.COMMON_CONFIG_74,
                                            errorMessage
                                        );
                                    }
                                    else
                                    {
                                        // we have at least one IP address. Use the first one in the list
                                        if (ipHostEntry.AddressList.Length > 1)
                                        {
                                            string errorMessage = "Dns.GetHostByName(" +
                                                                  _xblConfigServerDNSName +
                                                                  ") returned " + ipHostEntry.AddressList.Length +
                                                                  " IP addresses. The first address in the list will be used and the rest will be ignored";
                                            _configInstance.LogNtEvent(
                                                ConfigEvent.Id.COMMON_CONFIG_75,
                                                errorMessage
                                            );
                                        }

                                        _npdbServer = ipHostEntry.AddressList[0].ToString();

                                        _configInstance.LogNtEvent(
                                           ConfigEvent.Id.COMMON_INFO_11,
                                           "Using NPDB server specified by DNS for hostname '" +
                                           _xblConfigServerDNSName + "'value: " + _npdbServer
                                           
                                        );

                                        return _npdbServer;
                                    }
                                }
                            }
                            catch (SocketException e)
                            {
                                // Dns.GetHostByName will throw a socket exception if the host is not
                                // known. Simply log an event and move along
                                string errorMessage = "Dns.GetHostByName(" + _xblConfigServerDNSName +
                                                      ") threw a SocketException. DNS will not be used to find NPDB. Exception message: " +
                                                      e.Message;
                                capturedErrors += errorMessage + "\n";
                                _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_76, errorMessage);
                            }
                        }

                        // 4th precedence is to use the server specified in CommonConfig.xml
                        // in the directory where the calling assembly lives
                        string defaultConfigFile = Path.Combine(_configInstance.AssemblyDirectory, _defaultConfigFileName);
                        if (!File.Exists(defaultConfigFile))
                        {
                            string errorMessage = "The default xml configuration file '" +
                                                  defaultConfigFile + "' was not found.";

                            capturedErrors += errorMessage + "\n";
                            _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_77, errorMessage);
                        }
                        else
                        {
                            string temp = _configInstance.LoadServerFromXml(defaultConfigFile);

                            // if we got a server, then we're done, otherwise, fall through
                            // to the next option to figure out the server
                            if (temp != null)
                            {
                                _npdbServer = temp;

                                _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_12, 
                                   "Using NPDB server specified in '" + defaultConfigFile +
                                   "' xml configuration file, value: " + _npdbServer
                                );

                                return _npdbServer;
                            }
                        }

                        // if we get here, we didn't figure out where NPDB lives, so we log an
                        // event and throw
                        ApplicationException ae =
                            new ApplicationException("Unable to determine location of NPDB\n" + capturedErrors);
                        _configInstance.LogNtEvent(
                            ConfigEvent.Id.COMMON_CONFIG_78, 
                            ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }
                }
                set
                {
                    lock (this)
                    {
                        // flush any cached information, then remember what
                        // server the caller wants us to use from now on.
                        _configInstance.DiscardCachedValues();

                        _npdbServer = value;

                        _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_13, 
                                   "Using NPDB server specified by caller, value: " + _npdbServer );
                    }
                }
            }

            public string NpdbDatabase
            {
                get
                {
                    if (_npdbDatabase != null)
                    {
                        // we've already figured out what the name of the NPDB database is, so return it
                        return _npdbDatabase;
                    }

                    lock (this)
                    {
                        if (_npdbDatabase != null)
                        {
                            return _npdbDatabase;
                        }

                        // 1st precedence is to use the server specified in the XBL_CONFIG_DATABASE environment variable
                        string databaseEnvSetting = System.Environment.GetEnvironmentVariable(_xblConfigDatabaseEnvVarName);
                        if (databaseEnvSetting != null)
                        {
                            _npdbDatabase = databaseEnvSetting;

                            _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_14, 
                                       "Using NPDB database name specified in '" +
                                       _xblConfigDatabaseEnvVarName + "' environment variable, value: " + _npdbDatabase);
                            return _npdbDatabase;
                        }

                        // 2nd precedence is to use the database name specified in the Database value in the registry key:
                        // \HKLM\Software\Microsoft\XboxLive\CommonConfig
                        RegistryKey commonConfig = Registry.LocalMachine.OpenSubKey(_CommonConfigRegKeyPath);
                        if (commonConfig != null)
                        {
                            object o = commonConfig.GetValue(_DatabaseRegValueName);
                            // we should be able to cast this to a string, but we don't want to
                            // completely fail if the cast is bad
                            string temp = null;
                            try
                            {
                                temp = (string)o;
                            }
                            catch (InvalidCastException)
                            {
                                _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_79, 
                                           "Unable to cast '" + _DatabaseRegValueName +
                                           "' registry value at path '" + _CommonConfigRegKeyPath +
                                           "' to a string. This registry setting will be ignored"
                                           );
                            }

                            // if we got a database name, then we're done, otherwise, fall through
                            // to the next option to figure out the database name
                            if (temp != null)
                            {
                                _npdbDatabase = temp;

                                _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_15, 
                                           "Using NPDB database name specified in registry at '" +
                                           _CommonConfigRegKeyPath + "', value: " + _npdbDatabase
                                           );
                                return _npdbDatabase;
                            }
                        }

                        // 3rd precedence is to use the database name specified in CommonConfig.xml
                        // in the directory where the calling assembly lives
                        string defaultConfigFile = Path.Combine(Path.GetDirectoryName(_configInstance.AssemblyPath), _defaultConfigFileName);
                        if (File.Exists(defaultConfigFile))
                        {
                            string temp2 = _configInstance.LoadDatabaseFromXml(defaultConfigFile);

                            _npdbDatabase = temp2;

                            // if we got a server, then we're done, otherwise, fall through
                            // to the next option to figure out the server
                            if (_npdbDatabase != null)
                            {
                                _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_16,
                                           "Using NPDB database name specified in '" +
                                           defaultConfigFile +
                                           "' xml configuration file, value: " + _npdbDatabase
                                           );
                                return _npdbDatabase;
                            }
                        }

                        // if we get here, none of the locations above specified a value for the
                        // database name, so we use the default of "npdb". I don't want services
                        // to compile defaults in, because I want those defaults to be in NPDB,
                        // but since this is a bootstrap to get to npdb, I think it's ok to compile
                        // in a default.
                        _configInstance.LogNtEvent(ConfigEvent.Id.COMMON_INFO_17, 
                                   "Using default NPDB database name of '" + _defaultDatabaseName +
                                   "'");

                        _npdbDatabase = _defaultDatabaseName;

                        return _npdbDatabase;
                    }
                }
                set
                {
                    lock(this)
                    {
                        // flush any cached information, then remember what
                        // database name the caller wants us to use from now on.
                        _configInstance.DiscardCachedValues();

                        _npdbDatabase = value;

                        _configInstance.LogNtEvent(
                            ConfigEvent.Id.COMMON_INFO_18,
                            "Using NPDB database name specified by caller, value: " + _npdbDatabase
                        );
                    }
                }
            }
        }

        // This ReaderWriterLock is used in place of the lock(typeof(Config)) idiom
        // that was found to be too slow.
        private readonly ReaderWriterLock _rwLock;
        private readonly NpdbInfo _npdbInfo;
        private readonly string _connStringSuffix = null;

        // We use this timeout on all lock requests. If we ever see it timeout
        // we're very likely in a deadlock situation and should investigate.
        // The config class should not be holding write locks for 60 seconds.
        private const int _rwLockTimeout = 60000;

        private Hashtable _refreshFunction; // A hash table of ArrayList, Hashtable1 =  (function, ArrayList) and ArrayList = (table)

        public Hashtable RefreshFunction
        {
            get
            {
                if (null != _refreshFunction)
                {
                    return _refreshFunction;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (null != _refreshFunction)
                    {
                        return _refreshFunction;
                    }

                    _refreshFunction = NpdbAccess.GetAllRefreshFunctions(NpdbConnectionString);

                    return _refreshFunction;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }

            set
            {
                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    _refreshFunction = value;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public static ConfigInstance Create()
        {
            return new ConfigInstance();
        }

        public static ConfigInstance Create(string npdbServer, string npdbDatabase)
        {
            return new ConfigInstance(npdbServer, npdbDatabase);
        }

        public static ConfigInstance Create(string npdbServer, string npdbDatabase, string connectionStringSuffix)
        {
            return new ConfigInstance(npdbServer, npdbDatabase, connectionStringSuffix);
        }

        // We need the reader writer lock to be initialized before any
        // member is called, so we initialize it in a constructor.
        // We also use this opportunity to attach our global change
        // event handlers.
        private ConfigInstance()
        {
            _rwLock = new ReaderWriterLock();
            SettingChange += SettingChangeFilter.GlobalHandler;
            _npdbInfo = new NpdbInfo(this, null, null);
        }

        // We need the reader writer lock to be initialized before any
        // member is called, so we initialize it in a constructor.
        // We also use this opportunity to attach our global change
        // event handlers.
        private ConfigInstance(string npdbServer, string npdbDatabase)
        {
            _rwLock = new ReaderWriterLock();
            SettingChange += SettingChangeFilter.GlobalHandler;
            _npdbInfo = new NpdbInfo(this, npdbServer, npdbDatabase);
        }

        // We need the reader writer lock to be initialized before any
        // member is called, so we initialize it in a constructor.
        // We also use this opportunity to attach our global change
        // event handlers.
        //
        // RWLock is initialized first by calling base constructor
        private ConfigInstance(string npdbServer, string npdbDatabase, string connectionStringSuffix)
            : this(npdbServer, npdbDatabase)
        {
            _connStringSuffix = connectionStringSuffix;
            if (_connStringSuffix.Length > 0 && _connStringSuffix[0] != ';')
                _connStringSuffix = ";" + _connStringSuffix;
        }

        public const string _xblConfigServerEnvVarName = "XBL_CONFIG_SERVER";
        private const string _xblConfigDatabaseEnvVarName = "XBL_CONFIG_DATABASE";

        private const string _xblConfigServerDNSName = "npdb";
        private const int _xblConfigDNSTimeout = 60000;

        private int _npdbConnectionTimeout = 15;

        public int NpdbConnectionTimeout
        {
            get
            {
                return _npdbConnectionTimeout;
            }
            set
            {
                Interlocked.Exchange(ref _npdbConnectionTimeout, value);
            }
        }

        private const string _defaultConfigFileName = "CommonConfig.xml";
        private const string _defaultDatabaseName = "npdb";

        private const string _npdbServerXpath = "/npdb/@server";
        private const string _npdbDBNameXpath = "/npdb/@dbname";

        // this is relative to HKLM
        private const string _CommonConfigRegKeyPath = "Software\\Microsoft\\XboxLive\\CommonConfig";
        private const string _ServerRegValueName = "Server";
        private const string _DatabaseRegValueName = "Database";

        private IConfigurationOverride _configOverride;
        private Assembly _assembly;
        private string _assemblyPath;
        private string _applicationName;
        private string _componentName;
        private string _environment;
        private string _environmentType;
        private int _siteId;
        private bool _siteIdLookedUp;
        private string _server;
        private string _component = config.Component.unknown;
        private int _mainSiteId;
        private bool _mainSiteIdLookedUp;
        private Hashtable _reportMessageComponentIdMapping;

        private Random _rand;

        private int _inUpdate;

        // this Timer is what checks for updates, and the timer callback
        // needs to impersonte the windows identity of the process that
        // is using config
        private Timer _refreshTimer;
        private Int64 _latestChangeId;
        private bool _firstTimerCallback;
        private int _minEventInterval;
        private int _cacheRefreshInterval;

        public IConfigurationOverride ConfigurationOverride
        {
            get
            {
                return _configOverride;
            }
            set
            {
                _configOverride = value;
            }
        }

        public Int64 LatestChangeId
        {
            get
            {
                return _latestChangeId;
            }
        }
        private Int64 LatestChangeIdSet
        {
            set
            {
                Interlocked.Exchange(ref _latestChangeId, value);
            }
        }

        public TimeSpan MinEventInterval
        {
            get
            {
                return new TimeSpan(0, 0, 0, 0, _minEventInterval);
            }
        }
        private int MinEventIntervalSet
        {
            set
            {
                Interlocked.Exchange(ref _minEventInterval, value);
            }
        }

        public int CacheRefreshInterval
        {
            get
            {
                return _cacheRefreshInterval;
            }
        }
        private int CacheRefreshIntervalSet
        {
            set
            {
                Interlocked.Exchange(ref _cacheRefreshInterval, value);
            }
        }

        private void RefreshTimerInit()
        {
            if (_refreshTimer == null)
            {
                // get the minimum interval that must pass before we'll signal
                // an additional NT event for a particular stale cache line
                MinEventIntervalSet = GetMinEventInterval();

                // log the min event interval
                LogMinEventInterval();

                // get the iterval that we'll check for updates in npdb
                CacheRefreshIntervalSet = GetCacheRefreshInterval();

                // log the cache refresh interval
                LogCacheRefreshInterval();

                RecreateRefreshTimer();
            }
        }

        private void RecreateRefreshTimer()
        {
            // for informational purposes, log the current windows identity
            WindowsIdentity current = WindowsIdentity.GetCurrent();
            string currentName = (current == null ? "<unknown identity>" : current.Name);

            LogNtEvent(
                       ComponentName,
                       "The NPDB refresh timer is being created by a thread using the following windows identity: " +
                       currentName + "\n", ConfigEvent.Id.COMMON_INFO_4);

            // get the latest change id in the database
            LatestChangeIdSet = GetLatestChangeId();
            // no need to check return, will throw if invalid

            // setup the timer that will periodically call CheckForUpdates
            // make sure we keep a reference to the timer, or else it
            // will be disposed on us

            _firstTimerCallback = true;
            Timer timerToDispose = Interlocked.Exchange(
                ref _refreshTimer,
                new Timer(CheckForUpdatesCallback, null,
                          CacheRefreshInterval +
                          Rand.Next(0, CacheRefreshInterval),
                          CacheRefreshInterval));


            //  Dispose the old timer.
            if (timerToDispose != null)
            {
                timerToDispose.Dispose();
            }
        }

        private void CheckForUpdatesCallback(object state)
        {
            if (_firstTimerCallback)
            {
                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_firstTimerCallback)
                    {
                        WindowsIdentity current = WindowsIdentity.GetCurrent();
                        string currentName = (current == null ? "<unknown identity>" : current.Name);

                        // for informational purposes, log the current windows identity
                        // but we only do this the first time the timer calls us
                        LogNtEvent(
                            ConfigEvent.Id.COMMON_INFO_4,
                            "The NPDB refresh timer is being called by a thread using the following windows identity: " +
                            currentName + "\n"
                        );

                        _firstTimerCallback = false;
                    }
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }

            CheckForUpdates();
        }


        private bool ShouldUpdateData(NpdbRefreshTypes refreshType, Hashtable htModifiedTables)
        {
            bool fRet = false;

            ArrayList arrTablesOfInterest = (ArrayList)RefreshFunction[refreshType];

            if (null != arrTablesOfInterest)
            {
                foreach (string szTable in arrTablesOfInterest)
                {
                    if (htModifiedTables.ContainsKey(szTable))
                    {
                        fRet = true; //i am interested in this table
                        break;
                    }
                }
            }
            else
            {
                fRet = true;// if this function is not configured, then by default we would refresh by default
            }

            return fRet;
        }


        //While this could be use for other things, it is currently planned to be used for testing
        #region NPDB Refresh Type Notification

        public event RefreshTypeEventHandler _npdbRefreshNotification = null;
        protected void OnNpdbRefresh(NpdbRefreshTypes npdbRefreshType)
        {
            if (null != _npdbRefreshNotification)
            {
                _npdbRefreshNotification(npdbRefreshType);
            }
        }

        #endregion

        public void CheckForUpdates()
        {
            // track how much time is spent processing the change
            System.Diagnostics.Stopwatch timeElapsed = new System.Diagnostics.Stopwatch();
            timeElapsed.Start();

            if (Interlocked.CompareExchange(ref _inUpdate, 1, 0) == 1)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_69,
                    "A prior configuration change has not yet finished propagating\n"
                   + "through the system.  If this persists it may indicate a\n"
                   + "deadlocked state.");
                return;
            }

            try
            {
                // get the highest change id in NPDB
                Int64 currentChangeId = GetLatestChangeId();
                // no need to check return, will throw if invalid

                // if the latest change id is higher than the one
                // from our last check, something has changed in NPDB
                // and we need to refresh the cache
                if (currentChangeId > LatestChangeId)
                {
                    //LogNtEvent(ConfigEvent.Id.COMMON_INFO_6,
                    //    "A configuration change has been detected in NPDB\n"
                    //    + "NPDB will now be examined for relevant changes\n"
                    //    + "Previous Change ID: " + LatestChangeId + "\n"
                    //    + "New Change ID: " + currentChangeId + "\n");

                    // Get a list of the tables that have been modified
                    // since the last change id we were aware of
                    Hashtable modifiedTables = GetModifiedTables(LatestChangeId);

                    // Update the latest change id first, before we do anything
                    // below. We want to make sure that no matter what happens
                    // in the calls below, we won't reexamine the caches for
                    // the same change again.
                    LatestChangeIdSet = currentChangeId;

                    if (null != modifiedTables["t_config_refresh_functions"])
                    {
                        RefreshFunction = NpdbAccess.GetAllRefreshFunctions(NpdbConnectionString);
                    }

                    OnNpdbRefresh(NpdbRefreshTypes.REFRESH_STARTS);

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_SERVER_LIST, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_SERVER_LIST);
                        RefreshServerLists();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_INTERFACES, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_INTERFACES);
                        RefreshInterfaces();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_INTERFACE_BUCKETS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_INTERFACE_BUCKETS);
                        RefreshInterfaceBuckets();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_VIRTUAL_INTERFACE_LISTS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_VIRTUAL_INTERFACE_LISTS);
                        RefreshVirtualInterfaceLists();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_VIRTUAL_INTERFACES, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_VIRTUAL_INTERFACES);
                        RefreshVirtualInterfaces();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_SETTINGS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_SETTINGS);
                        RefreshSettings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_MULTI_SETTINGS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_MULTI_SETTINGS);
                        RefreshMultiSettings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_GAME_CONFIG, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_GAME_CONFIG);
                        RefreshGameConfig();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_XDELAY, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_XDELAY);
                        RefreshXDelaySettings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_XRL_MAPPINGS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_XRL_MAPPINGS);
                        RefreshXrlMappings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_HEALTH_MAPPINGS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_HEALTH_MAPPINGS);
                        RefreshHealthMappings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_LIVE_REGISTRY_SETTINGS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_LIVE_REGISTRY_SETTINGS);
                        RefreshLiveRegistrySettings();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_SERVICE_KEYS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_SERVICE_KEYS);
                        RefreshServiceKeys();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_CONFIG_BLOBS, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_CONFIG_BLOBS);
                        RefreshConfigBlobs();
                    }

                    if (ShouldUpdateData(NpdbRefreshTypes.REFRESH_ETX_MANIFEST, modifiedTables))
                    {
                        OnNpdbRefresh(NpdbRefreshTypes.REFRESH_ETX_MANIFEST);
                        RefreshEtxManifest();
                    }

                    OnNpdbRefresh(NpdbRefreshTypes.REFRESH_ENDS);

                    // Record an informational event indicating how much time was spent
                    // processing the change.
                    LogNtEvent(ConfigEvent.Id.CONFIG_CHANGE_PROCESSED,
                        "NPDB configuration change ID: " + currentChangeId + " has been processed.\n"
                        + "Time elapsed: " + timeElapsed.Elapsed.Milliseconds + " milliseconds.\n");
                }

                // the caches have been refreshed, the client code has been
                // signaled of each change, so we're done.
            }
            catch (Exception e)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_COMM_7,
                    "Failed to retrieve all configuration changes.\n"
                    + "Some cached configuration settings will be used\n"
                    + "until this issue is resolved.\n"
                    + "(time elapsed processing: " + timeElapsed.Elapsed.Milliseconds + " milliseconds)\n"
                    + "Exception Message: " + e.Message + "\n");
            }
            finally
            {
                Interlocked.Exchange(ref _inUpdate, 0);
            }
        }

        public string ProcessConfigCache(string xmgmtCommand, string [] commandArgs)
        {
            switch (xmgmtCommand)
            {
                case "assemblypath":
                    return AssemblyPath;

                case "cacherefreshinterval":
                    return CacheRefreshInterval.ToString();

                case "component":
                    return Component;

                case "componentname":
                    return ComponentName;

                case "environment":
                    return Environment;

                case "help":
                    return ProcessConfigCacheHelp();

                case "interface":
                    return ProcessConfigCacheInterface(commandArgs);

                case "interfaces":
                    return ProcessConfigCacheInterfaces();

                case "interfacebucket":
                    return ProcessConfigCacheInterfaceBucket(commandArgs);

                case "interfacebuckets":
                    return ProcessConfigCacheInterfaceBuckets(Interface.None);

                case "latestchangeid":
                    return LatestChangeId.ToString();

                case "mainsiteid":
                    return MainSiteId.ToString();

                case "mineventinterval":
                    return MinEventInterval.TotalMilliseconds.ToString();

                case "multisetting":
                    return ProcessConfigCacheMultiSetting(commandArgs);

                case "multisettings":
                    return ProcessConfigCacheMultiSettings();

                case "nativenpdbconnectionstring":
                    return NativeNpdbConnectionString;

                case "npdbconnectionstring":
                    return NpdbConnectionString;

                case "npdbdatabase":
                    return NpdbDatabase;

                case "npdbserver":
                    return NpdbServer;

                case "server":
                    return Server;

                case "serverlist":
                    return ProcessConfigCacheServerList(commandArgs);

                case "serverlists":
                    return ProcessConfigCacheServerLists();

                case "setting":
                    return ProcessConfigCacheSetting(commandArgs);

                case "settings":
                    return ProcessConfigCacheSettings();

                case "siteid":
                    return SiteId.ToString();

                case "virtualinterface":
                    return ProcessConfigCacheVirtualInterface(commandArgs);

                case "virtualinterfaces":
                    return ProcessConfigCacheVirtualInterfaces();

                case "virtualinterfacelist":
                    return ProcessConfigCacheVirtualInterfaceList(commandArgs);

                case "virtualinterfacelists":
                    return ProcessConfigCacheVirtualInterfaceLists();

                default:
                    return ProcessConfigCacheHelp();
            }
        }

        private static string ProcessConfigCacheHelp()
        {
            //.........1.........2.........3.........4.........5.........6.........7..........8
            return
                 "configcache <command> [parameters]\r\n"
                + " where <command> is one of:\r\n"
                + "  assemblypath        - show current assembly path\r\n"
                + "  cacherefreshinterval- show the amount of time (in milliseconds)\r\n"
                + "                        between checks for updates in npdb\r\n"
                + "  component           - show current default component\r\n"
                + "                        note: may be 'unknown' if component name\r\n"
                + "                        does not match any known components\r\n"
                + "  componentname       - show current component name\r\n"
                + "  environment         - show current default environment\r\n"
                + "  help                - show this message\r\n"
                + "  interface <server> <name> \r\n"
                + "                      - show interface cache entry for interface <name>\r\n"
                + "                        on server <server> that matches current default\r\n"
                + "                        environment\r\n"
                + "  interfaces          - show entire interface cache\r\n"
                + "  interfacebucket <name> \r\n"
                + "                      - show interfacebucket cache entries for interface\r\n"
                + "                        <name> for the default environment\r\n"
                + "  interfacebuckets    - show entire interfacebucket cache\r\n"
                + "  latestchangeid      - show the latest changeid known by this component\r\n"
                + "  mainsiteid          - show main site id\r\n"
                + "                        the main site id is the site that contains npdb\r\n"
                + "  mineventinterval    - show the amount of time (in milliseconds)\r\n"
                + "                        that must elapse before a duplicate stale config\r\n"
                + "                        event will be written\r\n"
                + "  multisetting <name> - show multisetting cache entry for <name>\r\n"
                + "                        that matches current default environment,\r\n"
                + "                        siteid, server, and component\r\n"
                + "  multisettings       - show entire multisetting cache\r\n"
                + "  nativenpdbconnectionstring\r\n"
                + "                      - show npdb connection string used by native code\r\n"
                + "  npdbconnectionstring- show npdb connection string\r\n"
                + "  npdbdatabase        - show npdb database name\r\n"
                + "  npdbserver          - show npdb server ip or name\r\n"
                + "  server              - show current default server name\r\n"
                + "  serverlist <name>   - show server list cache entry for interface <name>\r\n"
                + "                        that matches current default environment\r\n"
                + "  serverlists         - show entire server list cache\r\n"
                + "  setting <name>      - show setting cache entry for <name>\r\n"
                + "                        that matches current default environment,\r\n"
                + "                        siteid, server, and component\r\n"
                + "  settings            - show entire setting cache\r\n"
                + "  siteid              - show current default siteid\r\n"
                + "  virtualinterface <name> <site>\r\n"
                + "                      - show virtual interface cache line for virtual\r\n"
                + "                        interface <name> for site id <site> in the\r\n"
                + "                        default environment\r\n"
                + "  virtualinterfaces   - show entire virtual interface cache\r\n"
                + "  virtualinterfacelist <site>\r\n"
                + "                      - show virtual interface list cache line for\r\n"
                + "                        siteid <site> for the default environment\r\n"
                + "  virtualinterfacelists\r\n"
                + "                      - show entire virtual interface list cache\r\n";
        }

        private string ProcessConfigCacheInterface(string[] args)
        {
            if (args.Length != 3
                || String.IsNullOrEmpty(args[1])
                || String.IsNullOrEmpty(args[2]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string server = args[1];
            string interfaceName = args[2];

            // create the key of the cache line we're looking for:
            InterfaceKey key = new InterfaceKey();
            key._environment = Environment;
            key._server = server;
            key._iface = interfaceName;

            // see if we have a cache line for this entry
            if (InterfaceCache.ContainsKey(key))
            {
                InterfaceCacheLine cacheLine = (InterfaceCacheLine)InterfaceCache[key];

                // we have a cache line, so return it
                return "{environment,server,interface}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No interface cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheInterfaces()
        {
            // iterate through all Interface cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(InterfaceCache.Count
                + " lines are present in the interface cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,server,interface}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in InterfaceCache)
            {
                InterfaceKey key = (InterfaceKey)de.Key;
                InterfaceCacheLine cacheLine = (InterfaceCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        private string ProcessConfigCacheInterfaceBucket(string[] args)
        {
            if (args.Length != 2
                || string.IsNullOrEmpty(args[1]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string iface = args[1];

            // use ProcessConfigCacheInterfaceBuckets to output the cache lines,
            // but only those that match the interface provided
            return ProcessConfigCacheInterfaceBuckets(iface);
        }

        private string ProcessConfigCacheInterfaceBuckets(string iface)
        {
            // iterate through all InterfaceBucket cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            if (iface == Interface.None)
            {
                output.Append(InterfaceBucketCache.Count
                    + " lines are present in the interface bucket cache\r\n");
                output.Append("Format of cache lines is:\r\n");
            }
            output.Append("{environment,interface,titleid,bucket}{value,isStale,lastEventTime,newValue}\r\n");
            if (iface == Interface.None)
            {
                output.Append("\r\n");
            }

            foreach (DictionaryEntry de in InterfaceBucketCache)
            {
                InterfaceBucketKey key = (InterfaceBucketKey)de.Key;
                if (iface == Interface.None || key._iface == iface)
                {
                    InterfaceBucketCacheLine cacheLine = (InterfaceBucketCacheLine)de.Value;
                    output.Append("{" + key + "}{" + cacheLine + "}\r\n");
                }
            }

            return output.ToString();
        }

        private string ProcessConfigCacheMultiSetting(string[] args)
        {
            if (args.Length != 2
                || string.IsNullOrEmpty(args[1]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string multiSetting = args[1];

            // create the key of the cache line we're looking for:
            MultiSettingKey key = new MultiSettingKey();
            key._environment = Environment;
            key._siteId = SiteId;
            key._server = Server;
            key._component = Component;
            key._multiSetting = multiSetting;

            // see if we have a cache line for this entry
            if (MultiSettingCache.ContainsKey(key))
            {
                MultiSettingCacheLine cacheLine = (MultiSettingCacheLine)MultiSettingCache[key];

                // we have a cache line, so output it
                return "{environment,siteid,server,component,multisetting}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No multisetting cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheMultiSettings()
        {
            // iterate through all MultiSetting cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(MultiSettingCache.Count
                + " lines are present in the multisetting cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,siteid,server,component,multisetting}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in MultiSettingCache)
            {
                MultiSettingKey key = (MultiSettingKey)de.Key;
                MultiSettingCacheLine cacheLine = (MultiSettingCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        private string ProcessConfigCacheServerList(string[] args)
        {
            if (args.Length != 2
                || string.IsNullOrEmpty(args[1]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string iface = args[1];

            // create the key of the cache line we're looking for:
            ServerListKey key = new ServerListKey();
            key._environment = Environment;
            key._iface = iface;

            // see if we have a cache line for this entry
            if (ServerListCache.ContainsKey(key))
            {
                ServerListCacheLine cacheLine = (ServerListCacheLine)ServerListCache[key];

                // we have a cache line, so return it
                return "{environment,interface}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No server list cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheServerLists()
        {
            // iterate through all ServerList cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(ServerListCache.Count
                + " lines are present in the server list cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,interface}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in ServerListCache)
            {
                ServerListKey key = (ServerListKey)de.Key;
                ServerListCacheLine cacheLine = (ServerListCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        private string ProcessConfigCacheSetting(string[] args)
        {
            if (args.Length != 2
                || string.IsNullOrEmpty(args[1]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string setting = args[1];

            // create the key of the cache line we're looking for:
            SettingsKey key = new SettingsKey();
            key._environment = Environment;
            key._siteId = SiteId;
            key._server = Server;
            key._component = Component;
            key._setting = setting;

            // see if we have a cache line for this entry
            if (SettingsCache.ContainsKey(key))
            {
                SettingsCacheLine cacheLine = (SettingsCacheLine)SettingsCache[key];

                // we have a cache line, so output it
                return "{environment,siteid,server,component,setting}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No setting cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheSettings()
        {
            // iterate through all Setting cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(SettingsCache.Count
                + " lines are present in the setting cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,siteid,server,component,setting}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in SettingsCache)
            {
                SettingsKey key = (SettingsKey)de.Key;
                SettingsCacheLine cacheLine = (SettingsCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        private string ProcessConfigCacheVirtualInterface(string[] args)
        {
            if (args.Length != 3
                || args[1] == null
                || args[2] == null
                || args[1] == String.Empty
                || args[2] == String.Empty)
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string virtualInterface = args[1];
            string siteIdString = args[2];
            int siteId;

            // try to parse the siteid
            try
            {
                siteId = Int32.Parse(siteIdString);
            }
            catch (Exception)
            {
                return "Error: " + siteIdString + " is not a valid site id\r\n";
            }

            // create the key of the cache line we're looking for:
            VirtualInterfaceKey key = new VirtualInterfaceKey();
            key._environment = Environment;
            key._siteId = siteId;
            key._virtualInterface = virtualInterface;

            // see if we have a cache line for this entry
            if (VirtualInterfaceCache.ContainsKey(key))
            {
                VirtualInterfaceCacheLine cacheLine
                    = (VirtualInterfaceCacheLine)VirtualInterfaceCache[key];

                // we have a cache line, so return it
                return "{environment,siteid,virtualinterface}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No virtual interface cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheVirtualInterfaces()
        {
            // iterate through all VirtualInterface cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(VirtualInterfaceCache.Count
                + " lines are present in the virtual interface cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,siteid,virtualinterface}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in VirtualInterfaceCache)
            {
                VirtualInterfaceKey key = (VirtualInterfaceKey)de.Key;
                VirtualInterfaceCacheLine cacheLine = (VirtualInterfaceCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        private string ProcessConfigCacheVirtualInterfaceList(string[] args)
        {
            if (args.Length != 2
                || string.IsNullOrEmpty(args[1]))
            {
                return "Error: invalid command arguments\r\n\r\n"
                    + ProcessConfigCacheHelp();
            }

            string siteIdString = args[1];

            // convert the siteid to an integer
            int siteId;
            try
            {
                siteId = Int32.Parse(siteIdString);
            }
            catch (Exception)
            {
                return "Error: " + siteIdString + " is not a valid site number\r\n";
            }

            // create the key of the cache line we're looking for:
            VirtualInterfaceListKey key = new VirtualInterfaceListKey();
            key._environment = Environment;
            key._siteId = siteId;

            // see if we have a cache line for this entry
            if (VirtualInterfaceListCache.ContainsKey(key))
            {
                VirtualInterfaceListCacheLine cacheLine
                    = (VirtualInterfaceListCacheLine)VirtualInterfaceListCache[key];

                // we have a cache line, so return it
                return "{environment,siteid}{value,isStale,lastEventTime,newValue}\r\n"
                    + "{" + key + "}{" + cacheLine + "}\r\n";
            }
            return "Error: No virtual interface list cache line found matching key {" + key + "}\r\n";
        }

        private string ProcessConfigCacheVirtualInterfaceLists()
        {
            // iterate through all VirtualInterfaceList cache lines, and add each
            // one to the output string
            StringBuilder output = new StringBuilder();
            output.Append(VirtualInterfaceListCache.Count
                + " lines are present in the virtual interface list cache\r\n");
            output.Append("Format of cache lines is:\r\n");
            output.Append("{environment,siteid}{value,isStale,lastEventTime,newValue}\r\n\r\n");

            foreach (DictionaryEntry de in VirtualInterfaceListCache)
            {
                VirtualInterfaceListKey key = (VirtualInterfaceListKey)de.Key;
                VirtualInterfaceListCacheLine cacheLine = (VirtualInterfaceListCacheLine)de.Value;
                output.Append("{" + key + "}{" + cacheLine + "}\r\n");
            }

            return output.ToString();
        }

        public string ProcessConfigCacheRefresh()
        {
            Int64 startingChangeId = LatestChangeId;
            try
            {
                CheckForUpdates();
            }
            catch (Exception e)
            {
                string errMessage = "Exception calling CheckForUpdates, details below:\r\n"
                    + "Exception Message: " + e.Message + "\r\n"
                    + "Exception Stack Trace: " + e.StackTrace + "\r\n";
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_70,
                    errMessage);
                return errMessage;
            }

            Int64 endingChangeId = LatestChangeId;
            if (endingChangeId != startingChangeId)
            {
                return "Changes in NPDB detected, old changeid = "
                    + startingChangeId
                    + ", new changeid = "
                    + endingChangeId + "\r\n";
            }
            return "No changes in NPDB detected, current changeid = " + endingChangeId + "\r\n";
        }

        private delegate IPHostEntry GetHostByName(string s);

        public string NpdbServer
        {
            get
            {
                return _npdbInfo.NpdbServer;
            }
            set
            {
                _npdbInfo.NpdbServer = value;
            }
        }

        public string NpdbDatabase
        {
            get
            {
                return _npdbInfo.NpdbDatabase;
            }
            set
            {
                _npdbInfo.NpdbDatabase = value;
            }
        }

        private string LoadServerFromXml(string xmlFile)
        {
            XmlDocument configXmlDoc = new XmlDocument();
            try
            {
                configXmlDoc.Load(xmlFile);
            }
            catch (XmlException)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_80, "Error loading Xml from configuration file '" + xmlFile + "' This configuration file will be ignored.");
                return null;
            }

            XmlNode serverNode = configXmlDoc.SelectSingleNode(_npdbServerXpath);
            if (serverNode == null)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_81, "Unable to locate server information in '" + xmlFile + "' at xpath: " + _npdbServerXpath);
                return null;
            }

            return serverNode.Value;
        }

        private string LoadDatabaseFromXml(string xmlFile)
        {
            XmlDocument configXmlDoc = new XmlDocument();
            try
            {
                configXmlDoc.Load(xmlFile);
            }
            catch (XmlException)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_82, "Error loading Xml from configuration file '" + xmlFile + "' This configuration file will be ignored.");
                return null;
            }

            XmlNode databaseNode = configXmlDoc.SelectSingleNode(_npdbDBNameXpath);
            if (databaseNode == null)
            {
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_83, "Unable to locate database name information in '" + xmlFile + "' at xpath: " + _npdbDBNameXpath);
                return null;
            }

            return databaseNode.Value;
        }

        private Random Rand
        {
            get
            {
                if (_rand == null)
                {
                    _rand = new Random();
                }
                return _rand;
            }
        }

        public Assembly Assembly
        {
            [MethodImpl(MethodImplOptions.NoInlining)]
            get
            {
                if (_assembly == null)
                {
                    _assembly = System.Reflection.Assembly.GetCallingAssembly();
                }

                return _assembly;
            }

            set
            {
                _assembly = value;
            }
        }


        public string AssemblyPath
        {
            get
            {
                if (_assemblyPath == null)
                {
                    Uri assemblyUri = new Uri(Assembly.CodeBase);
                    _assemblyPath = assemblyUri.LocalPath;
                }

                return _assemblyPath;
            }
        }

        public string AssemblyDirectory
        {
            get
            {
                return Path.GetDirectoryName(AssemblyPath);
            }
        }

        internal string SqlApplicationName
        {
            get
            {
                if (String.IsNullOrEmpty(_applicationName))
                {
                    _applicationName = ComponentName;
                }

                return _applicationName;
            }

            set
            {
                _applicationName = value;
            }
        }

        public string ComponentName
        {
            get
            {
                if (_componentName == null)
                {
                    _componentName = ConfigAttribute.GetComponent();
                }

                return _componentName;
            }

            set
            {
                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (String.Equals(_componentName, value, StringComparison.OrdinalIgnoreCase))
                    {
                        // no change, *do not* throw away the ConfigCache, else lots of 
                        // settings break.
                        return;
                    }
                    
                    // We probably shouldn't allow you to change the component name more 
                    // than once, since doing so basically orphans the previous settings 
                    // -- it becomes impossible to update those values with a restart of 
                    // the service.  This should be left for the future though, to 
                    // preserve backward compatibility this late in the release.

                    //we need to flush the cache because changing the component name could 
                    //mean new overridden values. any settings loaded prior to this are 
                    //now orphaned unless the code calls GetSetting() again.
                    DiscardCachedValues();

                    string componentName = _componentName;
                    _componentName = value;

                    LogNtEvent(
                        ConfigEvent.Id.COMMON_INFO_19,  (string.IsNullOrEmpty(componentName) ?
                        "Component name is being set" : "ComponentName is being changed from "
                        + componentName) + " to " + _componentName
                    );
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public string NpdbConnectionStringWithTimeout(int timeout)
        {
            string connString = "Data Source=" + NpdbServer
                    + ";Initial Catalog=" + NpdbDatabase
                    + ";Integrated Security=SSPI"
                    + ";Connection Timeout=" + timeout
                    + ";Application Name=" + SqlApplicationName;

            if (_connStringSuffix != null)
            {
                connString = connString + _connStringSuffix;
            }

            return connString;
        }

        public string NpdbConnectionString
        {
            get
            {
                return NpdbConnectionStringWithTimeout(NpdbConnectionTimeout);
            }
        }

        public string NativeNpdbConnectionString
        {
            get
            {
                string connString = "Provider=SQLOLEDB"
                    + ";Data Source=" + NpdbServer
                    + ";Initial Catalog=" + NpdbDatabase
                    + ";Trusted_Connection=yes"
                    + ";Connection Timeout=" + NpdbConnectionTimeout
                    + ";Application Name=" + SqlApplicationName;

                if (_connStringSuffix != null)
                {
                    connString = connString + _connStringSuffix;
                }

                return connString;
            }
        }

        public string Environment
        {
            get
            {
                if (_environment != null)
                {
                    return _environment;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_environment != null)
                    {
                        return _environment;
                    }

                    GetCurrentEnvironment();

                    return _environment;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public string EnvironmentType
        {
            get
            {
                if (_environmentType != null)
                {
                    return _environmentType;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_environmentType != null)
                    {
                        return _environmentType;
                    }

                    GetCurrentEnvironment();

                    return _environmentType;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        // Some features are only allowed in test environments.  Encapsulate what
        // constitutes a test environment here
        public bool IsTestEnvironment()
        {
            return Config.EnvironmentType.Equals("development", StringComparison.OrdinalIgnoreCase);
        }


        protected void GetCurrentEnvironment()
        {
            // we dont' know what the current environment is, so let's figure it out
            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_current_environment";
                cmd.CommandType = CommandType.StoredProcedure;

                using(SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader == null || !reader.Read())
                    {
                        ApplicationException ae =
                            new ApplicationException(
                                "p_config_get_current_environment returned zero rows, cannot determine current environment.");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_84,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    string env = (string) reader["vc_environment"];

                    if (string.IsNullOrEmpty(env))
                    {
                        ApplicationException ae =
                            new ApplicationException(
                                "p_config_get_current_environment returned a null or an empty string, cannot determine current environment.");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_85,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    string envType = (string) reader["vc_environment_type"];

                    if (string.IsNullOrEmpty(envType))
                    {
                        ApplicationException ae =
                            new ApplicationException(
                                "p_config_get_current_environment returned a null or an empty string, cannot determine current environment type.");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_85,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    if (reader.Read())
                    {
                        // more than one row was returned, throw
                        ApplicationException ae =
                            new ApplicationException(
                                "p_config_get_current_environment returned more than one row, cannot determine current environment.");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_86,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    // everything is good -- set environment and environment type
                    _environment = env.Trim();
                    _environmentType = envType.Trim();

                    LogNtEvent(ConfigEvent.Id.COMMON_INFO_20, "Current environment is " + _environment + " (type: " + _environmentType + ")");
                }
            }
        }

        public int SiteId
        {
            get
            {
                if (_siteIdLookedUp)
                {
                    return _siteId;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_siteIdLookedUp)
                    {
                        return _siteId;
                    }

                    // look up both the server id and the
                    // site id while we're at it
                    int tempSiteId;
                    GetServerInfo(Server, out tempSiteId);

                    _siteId = tempSiteId;
                    _siteIdLookedUp = true;

                    return _siteId;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public int MainSiteId
        {
            get
            {
                if (_mainSiteIdLookedUp)
                {
                    return _mainSiteId;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_mainSiteIdLookedUp)
                    {
                        return _mainSiteId;
                    }
                    int tempSiteId = 1;

                    // Temporary hack to get around issue where NpdbServer can be an IP address.  Need to be able to get site information
                    // from npdb, but since there are installation dependencies that need to be worked out first.
                    // GetServerInfo(NpdbServer, out tempSiteId);
                    if (tempSiteId == 0)
                    {
                        // this shouldn't happen. NPDB must exist, and we have to know what
                        // site it's in!
                        ApplicationException ae = new ApplicationException("Could not determine site for NPDB server named '"
                            + NpdbServer
                            + "'");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_88, ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    _mainSiteId = tempSiteId;
                    _mainSiteIdLookedUp = true;

                    LogNtEvent(ConfigEvent.Id.COMMON_INFO_21, "NPDB is in siteid " + _mainSiteId);
                    return _mainSiteId;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public string Server
        {
            get
            {
                if (_server != null)
                {
                    return _server;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_server != null)
                    {
                        return _server;
                    }

                    // determine the machine name of the server we are currently running on
                    string machineName = System.Environment.MachineName;
                    if (machineName == String.Empty)
                    {
                        ApplicationException ae =
                            new ApplicationException(
                                "Cannot determine current machine name: Process.GetCurrentProcess().MachineName is null or String.Empty");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_89,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    _server = machineName;

                    // reset the site and server ids, so the next time anyone needs to know
                    // the site, it's sure to get looked up, using whatever
                    // server name we settled on
                    _siteIdLookedUp = false;
                    _siteId = 0;

                    LogNtEvent(ConfigEvent.Id.COMMON_INFO_22, "Current server is " + _server);
                    return _server;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        /// <summary>
        /// DO NOT USE!!!  SERIOUSLY!!!  WHAT ARE YOU THINKING???
        /// This is a Test Only Method.
        /// DO NOT USE!!!  SERIOUSLY!!!
        /// </summary>
        public string ServerSet_TestOnly_DoNotUse
        {
            set
            {
                _server = value;

                // reset the site and server ids, so the next time anyone needs to know
                // the site, it's sure to get looked up, using whatever
                // server name we settled on
                _siteIdLookedUp = false;
                _siteId = 0;
            }
        }

        public string Component
        {
            get
            {
                if (_component != STF.common.config.Component.unknown)
                {
                    return _component;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_component != STF.common.config.Component.unknown)
                    {
                        return _component;
                    }

                    if (ComponentExists(ComponentName))
                    {
                        _component = ComponentName;
                    }
                    else
                    {
                        // can't convert it to an enum, so the component is not known
                        LogNtEvent(ConfigEvent.Id.COMMON_INFO_23,
                                   "Unable to determine current component, using Component.unknown. " +
                                   "Component specific overrides will not be used by this component. ");
                    }

                    LogNtEvent(ConfigEvent.Id.COMMON_INFO_24, "Current component is " + _component);
                    return _component;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        /// <summary>
        /// Gets the ID used by the cleanser's ReportMessage protocol based on the current component.
        /// 0 is returned if no mapping for the current component has been defined.
        /// </summary>
        public int ReportMessageComponentId
        {
            get
            {
                int id = 0;
                object mappedInfo = ReportMessageComponentIdMapping[Component];

                if (mappedInfo != null)
                {
                    id = ((ReportMessageComponentInfo)mappedInfo).ComponentID;
                }

                return id;
            }
        }

        public string ReportMessageCleanserVirtualInterface
        {
            get
            {
                string virtInt = "cleanseriis";
                object mappedInfo = ReportMessageComponentIdMapping[Component];

                if (mappedInfo != null)
                {
                    virtInt = ((ReportMessageComponentInfo)mappedInfo).VirtualInterface;
                }

                return virtInt;
            }
        }

        private Hashtable ReportMessageComponentIdMapping
        {
            get
            {
                if (_reportMessageComponentIdMapping == null)
                {
                    int numDefaultMaps = config.Component.ReportMessageComponents.Length;
                    Hashtable defaultMaps = new Hashtable(config.Component.ReportMessageComponents.Length);


                    for (int i = 0; i < numDefaultMaps; i++)
                    {
                        defaultMaps.Add(config.Component.ReportMessageComponents[i], config.Component.ReportMessageComponentInfoList[i]);
                    }

                    _reportMessageComponentIdMapping = defaultMaps;
                }

                return _reportMessageComponentIdMapping;
            }
        }

        // Allows components to add additional mappings without having to modify the default mappings in
        // the Component class.
        public void AddReportMessageComponentIdMapping(string component, int reportMessageId)
        {
            lock (ReportMessageComponentIdMapping)
            {
                ReportMessageComponentIdMapping.Add(component, new ReportMessageComponentInfo(reportMessageId, component));
            }
        }

        public void RemoveReportMessageComponentIdMapping(string component)
        {
            lock (ReportMessageComponentIdMapping)
            {
                ReportMessageComponentIdMapping.Remove(component);
            }
        }

        // This method discards all cached configuration information,
        // forcing it to be reread from the source. Services can use this
        // in response to an xmgmt command asking them to reread configuration data.
        public void DiscardCachedValues()
        {
            _rwLock.AcquireWriterLock(_rwLockTimeout);
            try
            {
                // shut down the Timer that's calling into CheckForUpdates
                // periodically
                if (_refreshTimer != null)
                {
                    _refreshTimer.Dispose();
                }

                // CheckForUpdates will do nothing if _refreshTimer == null,
                // so if it gets called once or twice after this function
                // returns, there should be no harm done. The other option would
                // be to wait on an event that Dispose would signal when it's
                // shut everything down, but I'm not sure how long that might take
                // and I don't want to block the caller for an indefinate amount
                // of time.
                _refreshTimer = null;

                // clear the other cache related statics, plus the caches themselves
                LatestChangeIdSet = 0;

                // flush the cache used by GetServerListByInterface
                _serverListCache = null;

                // flush the cache used by GetInterface
                _interfaceCache = null;

                // flush the cache used by GetTitleBucketServer
                // and the bucket count cache
                _interfaceBucketCache = null;
                _bucketCountCache = null;

                // flush the cache used by GetVirtualInterface
                _virtualInterfaceCache = null;

                // flush the cache used by GetVirtualInterfaceList
                _virtualInterfaceListCache = null;

                // flush the cache used by GetSetting
                _settingsCache = null;

                // flush the cache used by GetMultiSetting
                _multiSettingCache = null;

                // clear the rest of the state, which will all get
                // redetermined on the next call that needs it.
                // We do not clear _componentName, so C++ clients can
                // do it once only at startup and be sure it will "stick".
                _environment = null;
                _siteId = 0;
                _siteIdLookedUp = false;
                _server = null;
                _component = config.Component.unknown;
                _mainSiteId = 0;
                _mainSiteIdLookedUp = false;
            }
            finally
            {
                _rwLock.ReleaseWriterLock();
            }
        }

        private Int64 GetLatestChangeId()
        {
            // call p_config_get_latest_change_id to retrieve the most
            // recent change id from t_config_log

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_latest_change_id";
                cmd.CommandType = CommandType.StoredProcedure;

                object o = cmd.ExecuteScalar();
                if (o == null)
                {
                    ApplicationException ae = new ApplicationException("p_config_get_latest_change_id did not return a value");
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_91, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }

                try
                {
                    // try to cast the returned object to an Int64
                    return (Int64)o;
                }
                catch (InvalidCastException e)
                {
                    ApplicationException ae = new ApplicationException("p_config_get_latest_change_id returned an object that could not be cast to Int64", e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_92, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }
        }

        private Hashtable GetModifiedTables(Int64 changeId)
        {
            // call p_config_get_modifed_tables to retrieve the list
            // of tables that have been modified since changeId
            Hashtable modifiedTables = new Hashtable();
            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_modified_tables";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@bi_change_id", SqlDbType.BigInt).Value = changeId;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            modifiedTables.Add(reader["vc_table"], true);
                        }
                    }
                }
            }

            return modifiedTables;
        }

        public void GetServerInfo(string server, out int siteId)
        {
            if (server == null)
            {
                ArgumentNullException e = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_93, e + "\n" + System.Environment.StackTrace);
                throw e;
            }

            // default to zero
            siteId = 0;

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_server_info";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null && reader.Read())
                    {
                        // i_site_id is declared not null
                        siteId = (Int32)reader["i_site_id"];

                        // sanity check - make sure only one row was received
                        if (reader.Read())
                        {
                            ApplicationException ae =
                                new ApplicationException("p_config_get_server_info returned more than one row");
                            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_94,
                                       ae + "\n" + System.Environment.StackTrace);
                            throw ae;
                        }
                    }
                }

                // We don't throw if the server was not found, since it
                // is valid to ask about a server that's not in the database.
                // Instead we just return default of 0 for siteId
            }
            return;
        }

        // Gets a list of server names that are exposing a particular interface name
        public string[] GetServerListByInterface(string iface)
        {
            return GetServerListByInterfaceFromCache(Environment, iface);
        }

        // attach ServerListChangeEventHandler delegates to this event to be notified
        // when server lists change in NPDB
        public event ServerListChangeEventHandler ServerListChange;
        protected void OnServerListChange(ServerListChangeEventArgs e)
        {
            if (ServerListChange != null)
            {
                ServerListChange(null, e);
            }
        }

        // if the ServerListChangeHandler wants to veto the change, it calls
        // VetoServerListChange, which sets the _approveServerListChange flag to false
        private bool _approveServerListChange = true;
        public void VetoServerListChange()
        {
            // ServerListChangeEventHandlers call this method if they
            // need to indicate that the server list change indicated by
            // the ServerListChangeEventArgs should not be committed
            // to the cache
            _approveServerListChange = false;
        }

        // the server list cache is implemented as a Hashtable, where the
        // keys are ServerListKey objects and the values are ServerListCacheLine
        // objects.
        private Hashtable _serverListCache;
        private class ServerListKey : IComparable
        {
            public string _environment;
            public string _iface;

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _iface.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _iface;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(ServerListKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to ServerListKey.CompareTo is not a ServerListKey");
                }

                ServerListKey key = (ServerListKey)o;

                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                return String.Compare(_iface, key._iface, false, CultureInfo.InvariantCulture);
            }
        }

        private class ServerListCacheLine
        {
            public string[] _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public string[] _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return CollectionToString(_value) + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + CollectionToString(_newValue);
            }
        }

        private Hashtable ServerListCache
        {
            get
            {
                if (_serverListCache != null)
                {
                    return _serverListCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_serverListCache != null)
                    {
                        return _serverListCache;
                    }

                    _serverListCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _serverListCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        private string[] GetServerListByInterfaceFromCache(string environment, string iface)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_95, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested setting
            ServerListKey key = new ServerListKey();
            key._environment = environment;
            key._iface = iface;

            if (ServerListCache.ContainsKey(key))
            {
                ServerListCacheLine cacheLine = (ServerListCacheLine)ServerListCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleServerListEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the server list was not found in the cache, so
            // get the info from the database and add it to the cache
            string[] value = GetServerListByInterfaceFromDB(environment, iface);

            ServerListCacheLine newCacheLine = new ServerListCacheLine();
            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock(ServerListCache)
            {
                ServerListCache[key] = newCacheLine;
            }

            return value;
        }

        private void RefreshServerLists()
        {
            // for each line in the server list cache, requery that virtual interface list from NPDB
            foreach (DictionaryEntry de in ServerListCache)
            {
                // requery for the server list from the database
                ServerListKey key = (ServerListKey)de.Key;
                string[] value = GetServerListByInterfaceFromDB(
                    key._environment,
                    key._iface);

                // has the server list changed?
                ServerListCacheLine cacheLine = (ServerListCacheLine)de.Value;
                if (!CollectionEquals(value, cacheLine._value))
                {
                    // if the server list has changed, but Config.ServerListChange
                    // is null (which means no delegates have been attached to the Event) then
                    // we can't commit this change to the cache, because we didn't get approval
                    // from the client code. So mark this cache line as dirty, log an event,
                    // and move along to the next cache line
                    if (ServerListChange == null)
                    {
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                        LogServerListChangeNoHandlerEvent(key, cacheLine._value, value);
                        continue;
                    }

                    // if we get here, ServerListChange is not null, so
                    // we signal the Event to notify the client code of the change.
                    // first we set _approveServerListChange to true, so we can
                    // see if any of the event handlers vetoed the change
                    ServerListChangeEventArgs eventArgs
                        = new ServerListChangeEventArgs(
                        key._environment,
                        key._iface,
                        cacheLine._value,
                        value);
                    _approveServerListChange = true;

                    // we want to wrap this in a try catch block, so if any
                    // registered handlers throw an exception we behave in
                    // a predictable fashion
                    try
                    {
                        OnServerListChange(eventArgs);
                    }
                    catch (Exception e)
                    {
                        // Log that the exception was thrown and then treat
                        // this as a rejected change
                        LogServerListChangeExceptionEvent(key, cacheLine._value, value, e);
                        _approveServerListChange = false;
                    }

                    // if _approveServerListChange is still true, then none of the
                    // ServerListChangeEventHandler delegates called VetoServerListChange,
                    // therefore we can commit the change to the cache
                    if (_approveServerListChange)
                    {
                        LogServerListChangeAcceptedEvent(key, cacheLine._value, value);
                        cacheLine._value = value;
                    }
                    else
                    {
                        // if _approveServerListChange is now false, one or more of the
                        // ServerListChangeEventHandler delegates called VetoServerListChange,
                        // therefore we should flag this cache line as dirty, and log
                        // an NT event
                        LogServerListChangeRejectedEvent(key, cacheLine._value, value);
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                    }
                }
                else if (cacheLine._dirty)
                {
                    //  In this case the values are equal but the cacheline is currently marked dirty
                    //  This means the value has been returned to its original value, clear the
                    //  dirty flag.
                    cacheLine._dirty = false;
                    cacheLine._lastEvent = DateTime.MinValue;
                    cacheLine._newValue = null;
                }
            }
        }

        private void LogServerListChangeAcceptedEvent(
            ServerListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_25,
                "A server list change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogServerListChangeRejectedEvent(
            ServerListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_96,
                "A server list change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogServerListChangeNoHandlerEvent(
            ServerListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_97,
                "A server list change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogServerListChangeExceptionEvent(
            ServerListKey key,
            string[] oldValue,
        string[] newValue,
        Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_98,
                "A server list change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogStaleServerListEvent(
            ServerListKey key,
            ServerListCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_99,
                    "This component is not using the latest server list information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "Interface: " + key._iface + "\n"
                    + "Stale Value: " + CollectionToString(cacheLine._value) + "\n"
                    + "New Value: " + CollectionToString(cacheLine._newValue) + "\n");

                // remember the current time...
                LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                try
                {
                    cacheLine._lastEvent = DateTime.Now;
                }
                finally
                {
                    _rwLock.DowngradeFromWriterLock(ref lc);
                }
            }
        }

        private string[] GetServerListByInterfaceFromDB(string environment, string iface)
        {
            SortedList serverList = new SortedList();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_server_list_by_interface";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = (string)environment;
                cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = (string)iface.ToString();

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            string server = ((string) reader["vc_server"]).ToUpper();

                            // sanity check - make sure it's not a duplicate,
                            // This would indicate a problem with the db schema or stored proc
                            // since the primary key on the servers table should ensure no duplicates
                            // are created
                            if (serverList.Contains(server))
                            {
                                ApplicationException ae = new ApplicationException(
                                    "Duplicate server named '"
                                    + server
                                    + "' returned by p_config_get_server_list_by_interface");
                                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_100,
                                           ae + "\n" + System.Environment.StackTrace);
                                throw ae;
                            }

                            serverList.Add(server, server);
                        }
                    }
                }
            }

            // convert the sorted list to an array
            string[] servers = new string[serverList.Count];
            serverList.Values.CopyTo(servers, 0);
            return servers;
        }

        public IInterfaceInfo GetInterface(
            string iface)
        {
            return GetInterfaceFromCache(Environment, iface, Server);
        }


        public IInterfaceInfo GetInterface(
            string server,
            string iface)
        {
            return GetInterfaceFromCache(Environment, iface, server);
        }


        public IInterfaceInfo GetInterface(
            string environment,
            string server,
        string iface)
        {
            return GetInterfaceFromCache(environment, iface, server);
        }



        // attach InterfaceChangeEventHandler delegates to this event to be notified
        // when interface info changes in NPDB
        public event InterfaceChangeEventHandler InterfaceChange;
        protected void OnInterfaceChange(InterfaceChangeEventArgs e)
        {
            if (InterfaceChange != null)
            {
                InterfaceChange(null, e);
            }
        }

        // if the InterfaceChangeHandler wants to veto the change, it calls
        // VetoInterfaceChange, which sets the _approveInterfaceChange flag to false
        private bool _approveInterfaceChange = true;
        public void VetoInterfaceChange()
        {
            // InterfaceChangeEventHandlers call this method if they
            // need to indicate that the interface change indicated by
            // the InterfaceChangeEventArgs should not be committed
            // to the cache
            _approveInterfaceChange = false;
        }

        // the virtual interface cache is implemented as a hashtable, where the
        // keys are InterfaceKey objects and the values are InterfaceCacheLine
        // objects.
        private Hashtable _interfaceCache;
        private class InterfaceKey : IComparable
        {
            public string _environment;
            public string _server;
            public string _iface;

            public InterfaceKey()
            {

            }

            public InterfaceKey(string environment, string server, string iface)
            {
                _environment = environment;
                _server = server;
                _iface = iface;
            }


            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _server.GetHashCode()
                    + _iface.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _server + ","
                    + _iface;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(InterfaceKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to InterfaceKey.CompareTo is not a InterfaceKey");
                }

                InterfaceKey key = (InterfaceKey)o;
                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                int serverCompare = String.Compare(_server, key._server, false, CultureInfo.InvariantCulture);
                if (serverCompare != 0)
                {
                    return serverCompare;
                }

                // servers are equal

                return String.Compare(_iface, key._iface, false, CultureInfo.InvariantCulture);
            }
        }

        private class InterfaceCacheLine
        {
            public IInterfaceInfo _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public IInterfaceInfo _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return _value.ToString() + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + (_newValue == null ? "<null>" : _newValue.ToString());
            }
        }

        private Hashtable InterfaceCache
        {
            get
            {
                if (_interfaceCache != null)
                {
                    return _interfaceCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_interfaceCache != null)
                    {
                        return _interfaceCache;
                    }

                    _interfaceCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _interfaceCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        // gets the interface information from the cache if present,
        // or from the database if not present, and adds that information to the
        // cache. If the cache does not exist, it is created
        private IInterfaceInfo GetInterfaceFromCache(
            string environment,
            string iface,
        string server)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_101, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_102, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested interface
            InterfaceKey key = new InterfaceKey(environment, server, iface);

            if (InterfaceCache.ContainsKey(key))
            {
                InterfaceCacheLine cacheLine = (InterfaceCacheLine)InterfaceCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleInterfaceEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the interface was not found in the cache, so
            // get the info from the database and add it to the cache
            IInterfaceInfo value = GetInterfaceFromDB(
                environment,
                server,
                iface);

            AddToInterfaceCache(key, value);

            return value;
        }


        private void AddToInterfaceCache(InterfaceKey key, IInterfaceInfo value)
        {
            if (!InterfaceCache.ContainsKey(key))
            {

                InterfaceCacheLine newCacheLine = new InterfaceCacheLine();
                newCacheLine._value = value;
                newCacheLine._dirty = false;

                // set the last event time to a valid time that's far enough in the
                // past to guarantee that if the line gets dirty, we'll log the
                // event the first time
                newCacheLine._lastEvent = DateTime.MinValue;

                lock(InterfaceCache)
                {
                    InterfaceCache[key] = newCacheLine;
                }
            }
        }


        private void RemoveFromInterfaceCache(InterfaceKey key)
        {
            if (InterfaceCache.ContainsKey(key))
            {
                lock(InterfaceCache)
                {
                    InterfaceCache.Remove(key);
                }
            }
        }

        private void RefreshInterfaces()
        {
            ArrayList interfacesToDelete = new ArrayList();

            // for each line in the interface cache, requery that interface from NPDB
            foreach (DictionaryEntry de in InterfaceCache)
            {
                // requery for the interface from the database
                InterfaceKey key = (InterfaceKey)de.Key;
                IInterfaceInfo value;

                try
                {
                    value = GetInterfaceFromDB(
                        key._environment,
                        key._server,
                        key._iface);
                }
                catch (ApplicationException)
                {
                    // for whatever reason, this key didnt refresh so well.  we'll just remove it from the cache.
                    interfacesToDelete.Add(key);
                    continue;
                }

                // has the interface changed?
                InterfaceCacheLine cacheLine = (InterfaceCacheLine)de.Value;
                if (value.ToString() != cacheLine._value.ToString())
                {
                    // if the interface has changed, but Config.InterfaceChange
                    // is null (which means no delegates have been attached to the Event) then
                    // we can't commit this change to the cache, because we didn't get approval
                    // from the client code. So mark this cache line as dirty, log an event,
                    // and move along to the next cache line
                    if (InterfaceChange == null)
                    {
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                        LogInterfaceChangeNoHandlerEvent(key, cacheLine._value, value);
                        continue;
                    }

                    // if we get here, InterfaceChange is not null, so we
                    // we signal the Event to notifiy the client code of the change.
                    // first we set _approveInterfaceChange to true, so we can
                    // see if any of the event handlers vetoed the change
                    InterfaceChangeEventArgs eventArgs
                        = new InterfaceChangeEventArgs(
                            key._environment,
                            key._server,
                            key._iface,
                            cacheLine._value,
                            value);

                    _approveInterfaceChange = true;

                    // we want to wrap this in a try catch block, so if any
                    // registered handlers throw an exception we behave in
                    // a predictable fashion
                    try
                    {
                        OnInterfaceChange(eventArgs);
                    }
                    catch (Exception e)
                    {
                        // Log that the exception was thrown and then treat
                        // this as a rejected change
                        LogInterfaceChangeExceptionEvent(key, cacheLine._value, value, e);

                        _approveInterfaceChange = false;
                    }

                    // if _approveInterfaceChange is still true, then none of the
                    // VirtualChangeEventHandler delegates called VetoInterfaceChange,
                    // therefore we can commit the change to the cache
                    if (_approveInterfaceChange)
                    {
                        LogInterfaceChangeAcceptedEvent(key, cacheLine._value, value);

                        cacheLine._value = value;
                    }
                    else
                    {
                        // if _approveInterfaceChange is now false, one or more of the
                        // InterfaceChangeEventHandler delegates called VetoInterfaceChange,
                        // therefore we should flag this cache line as dirty, and log
                        // an NT event
                        LogInterfaceChangeRejectedEvent(key, cacheLine._value, value);

                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                    }
                }
                else if (cacheLine._dirty)
                {
                    //  In this case the values are equal but the cacheline is currently marked dirty
                    //  This means the value has been returned to its original value, clear the
                    //  dirty flag.
                    LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                    try
                    {
                        cacheLine._dirty = false;
                        cacheLine._lastEvent = DateTime.MinValue;
                        cacheLine._newValue = null;
                    }
                    finally
                    {
                        _rwLock.DowngradeFromWriterLock(ref lc);
                    }
                }
            }

            // remove any keys that didnt refresh.
            lock (InterfaceCache)
            {
                foreach (InterfaceKey key in interfacesToDelete)
                {
                    InterfaceCache.Remove(key);
                }
            }
        }

        private void LogInterfaceChangeAcceptedEvent(
            InterfaceKey key,
            IInterfaceInfo oldValue,
        IInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_26,
                "An interface change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Server: " + key._server + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceChangeRejectedEvent(
            InterfaceKey key,
            IInterfaceInfo oldValue,
        IInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_103,
                "An interface change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Server: " + key._server + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceChangeNoHandlerEvent(
            InterfaceKey key,
            IInterfaceInfo oldValue,
        IInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_104,
                "An interface change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Server: " + key._server + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceChangeExceptionEvent(
            InterfaceKey key,
            IInterfaceInfo oldValue,
        IInterfaceInfo newValue,
        Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_105,
                "An interface change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Server: " + key._server + "\n"
                + "Interface: " + key._iface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogStaleInterfaceEvent(
            InterfaceKey key,
            InterfaceCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_106,
                    "This component is not using the latest interface information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "Server: " + key._server + "\n"
                    + "Interface: " + key._iface + "\n"
                    + "Stale Value: " + cacheLine._value.ToString() + "\n"
                    + "New Value: " + cacheLine._newValue.ToString() + "\n");

                // remember the current time...
                cacheLine._lastEvent = DateTime.Now;
            }
        }

        // Retrieves the information required to reach an interface on a particular server
        private IInterfaceInfo GetInterfaceFromDB(
            string environment,
            string server,
        string iface)
        {
            if (environment == null)
            {
                ArgumentNullException e = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_107, e + "\n" + System.Environment.StackTrace);
                throw e;
            }

            if (server == null)
            {
                ArgumentNullException e = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_108, e + "\n" + System.Environment.StackTrace);
                throw e;
            }

#if TEST
        if (_overrides.Contains(server + "_" + iface.ToString()))
        {
            return (IInterfaceInfo)_overrides[server + "_" + iface.ToString()];
        }

#endif

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();
                SqlDataReader reader;
                InterfaceInfo interfaceInfo;

                // This proc gets the default interface info from t_interfaces
                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_interface";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;
                cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = iface;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = ComponentName;

                using (reader = cmd.ExecuteReader())
                {
                    if (reader != null && !reader.Read())
                    {
                        ApplicationException ae = new ApplicationException("Interface '"
                                                                           + iface
                                                                           + "' not present on server '"
                                                                           + server
                                                                           + "' for environment '"
                                                                           + environment
                                                                           + "'");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_109,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    interfaceInfo = CreateInterfaceInfo(server, reader);
                }

                OverrideInterfaceInfo(server, iface, interfaceInfo, npdbConnection);

                return interfaceInfo;
            }
        }


        // Adds the information regarding an interface on a particular server
        private IInterfaceInfo AddServerInterfaceToDB(
            string environment,
            string server,
            string iface)
        {
            ValidateParameterIsNull(environment, "environment", ConfigEvent.Id.COMMON_CONFIG_107);
            ValidateParameterIsNull(server, "server", ConfigEvent.Id.COMMON_CONFIG_108);

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();
                SqlDataReader reader;
                InterfaceInfo interfaceInfo;

                // This proc gets the default interface info from t_interfaces
                using (reader = AddServerInterface(npdbConnection, environment, server, iface))
                {
                    if (!reader.Read())
                    {
                        ApplicationException ae = new ApplicationException("Unable to add Interface '"
                                                                           + iface
                                                                           + "' on server '"
                                                                           + server
                                                                           + "'");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_109,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    interfaceInfo = CreateInterfaceInfo(server, reader);
                }

                OverrideInterfaceInfo(server, iface, interfaceInfo, npdbConnection);

                return interfaceInfo;
            }
        }


        // Adds the information regarding an interface on a particular server
        private void RemoveServerInterfaceFromDB(
            string environment,
            string server,
            string iface)
        {
            ValidateParameterIsNull(environment, "environment", ConfigEvent.Id.COMMON_CONFIG_107);
            ValidateParameterIsNull(server, "server", ConfigEvent.Id.COMMON_CONFIG_108);

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                // This proc gets the default interface info from t_interfaces
                RemoveServerInterface(npdbConnection, environment, server, iface);
            }
        }


        private void OverrideInterfaceInfo(string server, string iface, InterfaceInfo interfaceInfo, SqlConnection npdbConnection)
        {
            // now, get any environment type overrides and apply them
            SqlDataReader reader = GetEnvironmentTypeInterfaceOverrides(npdbConnection, iface);
            if (reader.Read())
            {
                OverrideInterfaceInfoOnEnvironmentType(interfaceInfo, reader);
            }
            reader.Close();


            // now, get any environment overrides and apply them
            reader = GetEnvironmentInterfaceOverrides(npdbConnection, iface);
            if (reader.Read())
            {
                OverrideInterfaceInfoOnEnvironment(interfaceInfo, reader);
            }
            reader.Close();


            // now, get any server overrides and apply them
            reader = GetServerInterfaceOverrides(npdbConnection, server, iface);
            if (reader.Read())
            {
                OverrideInterfaceInfoOnServer(interfaceInfo, reader);
            }
            reader.Close();

        }


        private static void OverrideInterfaceInfoOnServer(InterfaceInfo interfaceInfo, IDataRecord reader)
        {

            // there is an override row, so apply anything that's not null
            if (reader["i_port"] != DBNull.Value)
            {
                interfaceInfo.Port = (Int32)reader["i_port"];
            }

            if (reader["i_port_end"] != DBNull.Value)
            {
                interfaceInfo.PortEnd = (Int32)reader["i_port_end"];
            }

            if (reader["vc_vdir"] != DBNull.Value)
            {
                interfaceInfo.VDir = (string)reader["vc_vdir"];
            }

            if (reader["vc_dbname"] != DBNull.Value)
            {
                interfaceInfo.DBName = (string)reader["vc_dbname"];
            }

            if (reader["vc_sharename"] != DBNull.Value)
            {
                interfaceInfo.Sharename = (string)reader["vc_sharename"];
            }

            if (reader["i_timeout"] != DBNull.Value)
            {
                interfaceInfo.Timeout = (Int32)reader["i_timeout"];
            }

            if (reader["vc_info1"] != DBNull.Value)
            {
                interfaceInfo.Info1 = (string)reader["vc_info1"];
            }

            if (reader["vc_info2"] != DBNull.Value)
            {
                interfaceInfo.Info2 = (string)reader["vc_info2"];
            }
        }

        private static void OverrideInterfaceInfoOnEnvironment(InterfaceInfo interfaceInfo, IDataRecord reader)
        {

            // there is an override row, so apply anything that's not null
            if (reader["i_port"] != DBNull.Value)
            {
                interfaceInfo.Port = (Int32)reader["i_port"];
            }

            if (reader["i_port_end"] != DBNull.Value)
            {
                interfaceInfo.PortEnd = (Int32)reader["i_port_end"];
            }

            if (reader["vc_vdir"] != DBNull.Value)
            {
                interfaceInfo.VDir = (string)reader["vc_vdir"];
            }

            if (reader["vc_dbname"] != DBNull.Value)
            {
                interfaceInfo.DBName = (string)reader["vc_dbname"];
            }

            if (reader["vc_sharename"] != DBNull.Value)
            {
                interfaceInfo.Sharename = (string)reader["vc_sharename"];
            }

            if (reader["i_timeout"] != DBNull.Value)
            {
                interfaceInfo.Timeout = (Int32)reader["i_timeout"];
            }

            if (reader["vc_info1"] != DBNull.Value)
            {
                interfaceInfo.Info1 = (string)reader["vc_info1"];
            }

            if (reader["vc_info2"] != DBNull.Value)
            {
                interfaceInfo.Info2 = (string)reader["vc_info2"];
            }
        }

        private static void OverrideInterfaceInfoOnEnvironmentType(InterfaceInfo interfaceInfo, IDataRecord reader)
        {

            // there is an override row, so apply anything that's not null
            if (reader["i_port"] != DBNull.Value)
            {
                interfaceInfo.Port = (Int32)reader["i_port"];
            }

            if (reader["i_port_end"] != DBNull.Value)
            {
                interfaceInfo.PortEnd = (Int32)reader["i_port_end"];
            }

            if (reader["vc_vdir"] != DBNull.Value)
            {
                interfaceInfo.VDir = (string)reader["vc_vdir"];
            }

            if (reader["vc_dbname"] != DBNull.Value)
            {
                interfaceInfo.DBName = (string)reader["vc_dbname"];
            }

            if (reader["vc_sharename"] != DBNull.Value)
            {
                interfaceInfo.Sharename = (string)reader["vc_sharename"];
            }

            if (reader["i_timeout"] != DBNull.Value)
            {
                interfaceInfo.Timeout = (Int32)reader["i_timeout"];
            }

            if (reader["vc_info1"] != DBNull.Value)
            {
                interfaceInfo.Info1 = (string)reader["vc_info1"];
            }

            if (reader["vc_info2"] != DBNull.Value)
            {
                interfaceInfo.Info2 = (string)reader["vc_info2"];
            }
        }

        private InterfaceInfo CreateInterfaceInfo(string server, SqlDataReader reader)
        {
            InterfaceInfo interfaceInfo = new InterfaceInfo();

            interfaceInfo.ServerName = server.ToUpper();
            interfaceInfo.Interface = (string)reader["vc_interface"];

            // vc_protocol is declared as not null
            interfaceInfo.Protocol = (string)reader["vc_protocol"];

            // vc_ip is declared as not null, but could be invalid
            try
            {
                interfaceInfo.IPAddress = IPAddress.Parse((string)reader["vc_ip"]);
            }
            catch (Exception e)
            {
                ApplicationException ae = new ApplicationException(
                    "Could not parse vc_ip as an IPAddress, value: "
                    + (string)reader["vc_ip"],
                    e);
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_111, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // vc_ip_netmask may be null or invalid
            if (reader["vc_ip_netmask"] != DBNull.Value)
            {
                try
                {
                    interfaceInfo.IPNetMask = IPAddress.Parse((string)reader["vc_ip_netmask"]);
                }
                catch (Exception e)
                {
                    ApplicationException ae = new ApplicationException(
                        "Could not parse vc_ip_netmask as an IPAddress, value: "
                        + (string)reader["vc_ip_netmask"],
                        e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_112, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }

            // vc_ip_default_gateway may be null or invalid
            if (reader["vc_ip_default_gateway"] != DBNull.Value)
            {
                try
                {
                    interfaceInfo.IPDefaultGateway = IPAddress.Parse((string)reader["vc_ip_default_gateway"]);
                }
                catch (Exception e)
                {
                    ApplicationException ae = new ApplicationException(
                        "Could not parse vc_ip_netmask as an IPAddress, value: "
                        + (string)reader["vc_ip_netmask"],
                        e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_113, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }

            // i_port may be null
            if (reader["i_port"] != DBNull.Value)
            {
                interfaceInfo.Port = (Int32)reader["i_port"];
            }

            // i_port_end may be null
            if (reader["i_port_end"] != DBNull.Value)
            {
                interfaceInfo.PortEnd = (Int32)reader["i_port_end"];
            }

            // vc_vsite may be null
            if (reader["vc_vsite"] != DBNull.Value)
            {
                interfaceInfo.VSite = (string)reader["vc_vsite"];
            }

            // i_vsite_id may be null
            if (reader["i_vsite_id"] != DBNull.Value)
            {
                interfaceInfo.VSiteId = (Int32)reader["i_vsite_id"];
            }

            // vc_vdir may be null
            if (reader["vc_vdir"] != DBNull.Value)
            {
                interfaceInfo.VDir = (string)reader["vc_vdir"];
            }

            // vc_dbname may be null
            if (reader["vc_dbname"] != DBNull.Value)
            {
                interfaceInfo.DBName = (string)reader["vc_dbname"];
            }

            // vc_sharename may be null
            if (reader["vc_sharename"] != DBNull.Value)
            {
                interfaceInfo.Sharename = (string)reader["vc_sharename"];
            }

            // i_timeout may be null
            if (reader["i_timeout"] != DBNull.Value)
            {
                interfaceInfo.Timeout = (Int32)reader["i_timeout"];
            }

            // i_service_id may be null
            if (reader["i_service_id"] != DBNull.Value)
            {
                interfaceInfo.ServiceId = (Int32)reader["i_service_id"];
            }

            // vc_service_name may be null
            if (reader["vc_service_name"] != DBNull.Value)
            {
                interfaceInfo.ServiceName = (string)reader["vc_service_name"];
            }

            // vc_mac may be null
            if (reader["vc_mac"] != DBNull.Value)
            {
                interfaceInfo.Mac = (string)reader["vc_mac"];
            }

            // vc_sg_ip_begin may be null or invalid
            if (reader["vc_sg_ip_begin"] != DBNull.Value)
            {
                try
                {
                    interfaceInfo.SgIpAddressBegin = IPAddress.Parse((string)reader["vc_sg_ip_begin"]);
                }
                catch (Exception e)
                {
                    ApplicationException ae = new ApplicationException(
                        "Could not parse vc_sg_ip_begin as an IPAddress, value: "
                        + (string)reader["vc_sg_ip_begin"],
                        e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_114, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }

            // vc_sg_ip_end may be null or invalid
            if (reader["vc_sg_ip_end"] != DBNull.Value)
            {
                try
                {
                    interfaceInfo.SgIpAddressEnd = IPAddress.Parse((string)reader["vc_sg_ip_end"]);
                }
                catch (Exception e)
                {
                    ApplicationException ae = new ApplicationException(
                        "Could not parse vc_sg_ip_end as an IPAddress, value: "
                        + (string)reader["vc_sg_ip_end"],
                        e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_115, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }

            // i_sg_port_begin may be null
            if (reader["i_sg_port_begin"] != DBNull.Value)
            {
                interfaceInfo.SgPortBegin = (Int32)reader["i_sg_port_begin"];
            }

            // i_sg_port_end may be null
            if (reader["i_sg_port_end"] != DBNull.Value)
            {
                interfaceInfo.SgPortEnd = (Int32)reader["i_sg_port_end"];
            }

            // b_need_sg_info may be null
            if (reader["b_need_sg_info"] != DBNull.Value)
            {
                interfaceInfo.NeedSGInfo = (bool)reader["b_need_sg_info"];
            }

            // vc_wiretap_ip may be null or invalid
            if (reader["vc_wiretap_ip"] != DBNull.Value)
            {
                try
                {
                    interfaceInfo.WiretapIpAddress = IPAddress.Parse((string)reader["vc_wiretap_ip"]);
                }
                catch (Exception e)
                {
                    ApplicationException ae = new ApplicationException(
                        "Could not parse vc_wiretap_ip as an IPAddress, value: "
                        + (string)reader["vc_wiretap_ip"],
                        e);
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_116, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
                }
            }

            // b_disabled may be null
            if (reader["b_disabled"] != DBNull.Value)
            {
                interfaceInfo.NicDisabled = (bool)reader["b_disabled"];
            }

            // vc_username may be null
            if (reader["vc_username"] != DBNull.Value)
            {
                interfaceInfo.Username = (string)reader["vc_username"];
                interfaceInfo.Username = interfaceInfo.Username.Replace("%COMPUTERNAME%", System.Environment.MachineName);
            }

            // vc_password may be null
            if (reader["vc_password"] != DBNull.Value)
            {
                interfaceInfo.Password = (string)reader["vc_password"];
            }

            // vc_info1 may be null
            if (reader["vc_info1"] != DBNull.Value)
            {
                interfaceInfo.Info1 = (string)reader["vc_info1"];
            }

            // vc_info2 may be null
            if (reader["vc_info2"] != DBNull.Value)
            {
                interfaceInfo.Info2 = (string)reader["vc_info2"];
            }

            // i_min_connection_pool_size may be null
            if (reader["i_min_connection_pool_size"] != DBNull.Value)
            {
                interfaceInfo.MinConnectionPoolSize = (Int32)reader["i_min_connection_pool_size"];
            }

            // i_max_connection_pool_size may be null
            if (reader["i_max_connection_pool_size"] != DBNull.Value)
            {
                interfaceInfo.MaxConnectionPoolSize = (Int32)reader["i_max_connection_pool_size"];
            }

            // i_load_balance_timeout may be null
            if (reader["i_load_balance_timeout"] != DBNull.Value)
            {
                interfaceInfo.LoadBalanceTimeout = (Int32)reader["i_load_balance_timeout"];
            }

            // i_connection_timeout may be null
            if (reader["i_connection_timeout"] != DBNull.Value)
            {
                interfaceInfo.ConnectionTimeout = (Int32)reader["i_connection_timeout"];
            }

            // Do we have another result set?
            if (reader.NextResult())
            {
                // Generic Notification Interfaces are stored here
                while (reader.Read())
                {
                    string vc_notification = (string)reader["vc_notification"];
                    string vc_url          = (string)reader["vc_url"];

                    interfaceInfo.AddNotificationUrl( vc_notification, vc_url );
                }
            }

            return interfaceInfo;
        }

        // Retrieves the information required to reach a particular interface,
        // when the caller expects only one server to expose that interface.
        // A good example of when this might be used is when querying for
        // a non-partitioned database interface. The interface is not virtual,
        // but there will still only be one instance of that interface because
        // the data is not partitioned. If more than one server exposes the
        // specified interface, then an ApplicationException will be thrown
        public IInterfaceInfo GetSingleInterface(string iface)
        {
            string[] servers = GetServerListByInterface(iface);
            if (servers.Length == 0)
            {
                ApplicationException ae = new ApplicationException("Could not find Interface '"
                    + iface
                    + "' on any Server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_117, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }
            if (servers.Length > 1)
            {
                ApplicationException ae = new ApplicationException("More than one Server was found exposing Interface '"
                    + iface
                    + "' when only one was expected");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_118, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            return GetInterface(servers[0], iface);
        }

        public IBucketServer GetBucketServer(string iface, uint bucket)
        {
            return GetTitleBucketServer(iface, 0, bucket);
        }

        public IBucketServer GetTitleBucketServer(
            string iface,
            uint titleId,
            uint bucket)
        {
            return GetInterfaceBucketFromCache(Environment, iface, titleId, bucket);
        }

        // attach InterfaceBucketChangeEventHandler delegates to this event to be notified
        // when interface bucket info changes in NPDB
        public event InterfaceBucketChangeEventHandler InterfaceBucketChange;
        protected void OnInterfaceBucketChange(InterfaceBucketChangeEventArgs e)
        {
            InterfaceBucketChange(null, e);
        }

        // if the InterfaceBucketChangeHandler wants to veto the change, it calls
        // VetoInterfaceBucketChange, which sets the _approveInterfaceBucketChange
        // flag to false
        private bool _approveInterfaceBucketChange = true;
        public void VetoInterfaceBucketChange()
        {
            // InterfaceBucketChangeEventHandlers call this method if they
            // need to indicate that the interface change indicated by
            // the InterfaceBucketChangeEventArgs should not be committed
            // to the cache
            _approveInterfaceBucketChange = false;
        }

        // the virtual interface cache is implemented as a hashtable, where the
        // keys are InterfaceBucketKey objects and the values are InterfaceBucketCacheLine
        // objects.
        private Hashtable _interfaceBucketCache;
        private class InterfaceBucketKey : IComparable
        {
            public string _environment;
            public string _iface;
            public uint _titleId;
            public uint _bucket;

            public InterfaceBucketKey()
            {

            }

            public InterfaceBucketKey(string szEnvironment, string szInterface, uint titleId, uint bucketId)
            {
                _environment = szEnvironment;
                _iface   = szInterface;
                _titleId = titleId;
                _bucket  = bucketId;
            }

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _iface.GetHashCode()
                    + _titleId.GetHashCode()
                    + _bucket.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _iface + ","
                    + _titleId + ","
                    + _bucket;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public string ToXmlBatchQueryFormat()
            {
                return String.Format(   @"<a vc_environment=""{0}"" vc_interface=""{1}"" i_title_id=""{2}"" i_bucket=""{3}""/>",
                                        _environment,
                                        _iface,
                                        (int)_titleId,  // cast to signed integer, so that we don't overflow the signed column in sql
                                        _bucket
                                     );
            }

            public int CompareTo(object o)
            {
                if (typeof(InterfaceBucketKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to InterfaceBucketKey.CompareTo is not a InterfaceBucketKey");
                }

                InterfaceBucketKey key = (InterfaceBucketKey)o;
                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                int ifaceCompare = String.Compare(_iface, key._iface, false, CultureInfo.InvariantCulture);
                if (ifaceCompare != 0)
                {
                    return ifaceCompare;
                }

                // interfaces are equal

                if (_titleId < key._titleId)
                {
                    return -1;
                }
                if (_titleId > key._titleId)
                {
                    return 1;
                }
                // titleids are equal

                if (_bucket < key._bucket)
                {
                    return -1;
                }
                if (_bucket > key._bucket)
                {
                    return 1;
                }
                // buckets are equal

                return 0;
            }

        }

        private class InterfaceBucketCacheLine
        {
            public IBucketServer _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public IBucketServer _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return _value.ToString() + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + (_newValue == null ? "<null>" : _newValue.ToString());
            }
        }

        private Hashtable InterfaceBucketCache
        {
            get
            {
                if (_interfaceBucketCache != null)
                {
                    return _interfaceBucketCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_interfaceBucketCache != null)
                    {
                        return _interfaceBucketCache;
                    }

                    _interfaceBucketCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _interfaceBucketCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        // gets the interface bucket information from the cache if present,
        // or from the database if not present, and adds that information to the
        // cache. If the cache does not exist, it is created
        private IBucketServer GetInterfaceBucketFromCache(
            string environment,
            string iface,
            uint titleId,
            uint bucket)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_119, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested interface bucket
            InterfaceBucketKey key = new InterfaceBucketKey();
            key._environment = environment;
            key._iface = iface;
            key._titleId = titleId;
            key._bucket = bucket;

            if (InterfaceBucketCache.ContainsKey(key))
            {
                InterfaceBucketCacheLine cacheLine = (InterfaceBucketCacheLine)InterfaceBucketCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleInterfaceBucketEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            //hit the database
            Hashtable htBucketValuesFromNpdb = NpdbAccess.GetBatchBucketsFromDB(NpdbConnectionString, key.ToXmlBatchQueryFormat());
            IBucketServer value = (IBucketServer) htBucketValuesFromNpdb[key];

            if (null == value)
            {
                string szMessage = String.Format("Specified interface bucket was not found.This probably indicates a configuration error.  Details below.\nInterface {0} TitleID {1} Bucket {2}", iface, titleId, bucket);

                ApplicationException ae = new ApplicationException(szMessage);

                throw ae;
            }


            InterfaceBucketCacheLine newCacheLine = new InterfaceBucketCacheLine();

            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock(InterfaceBucketCache)
            {
                InterfaceBucketCache[key] = newCacheLine;
            }

            return value;
        }

        private void RefreshInterfaceBuckets()
        {
            StringBuilder xml = new StringBuilder();

            int nBatchCount = 0;

            // First - Construct an xml
            foreach (DictionaryEntry de in InterfaceBucketCache)
            {
                try
                {
                    InterfaceBucketKey key = (InterfaceBucketKey) de.Key;

                    xml.Append(key.ToXmlBatchQueryFormat());
                    nBatchCount = nBatchCount + 1;
                }
                catch (Exception e)
                {
                    LogNtEvent(ConfigEvent.Id.COMMON_BUCKETS_BATCH_CONSTRUCTION, e.Message);
                }
            }

            Hashtable htBucketValuesFromNpdb = null;

            // Second - Perform database transaction
            if (xml.Length > 0)
            {
                try
                {
                    string szXmlQuery = xml.ToString();

                    LogNtEvent(ConfigEvent.Id.COMMON_BUCKET_COUNT,
                               String.Format("Querying {0} number of buckets at once from NPDB", nBatchCount));

                    htBucketValuesFromNpdb = NpdbAccess.GetBatchBucketsFromDB(NpdbConnectionString, szXmlQuery);
                }
                catch (Exception e)
                {
                    LogNtEvent(ConfigEvent.Id.COMMON_BUCKET_BATCH_QUERY, e.Message);
                }
            }

            // Third - Analyze Result
            if (null != htBucketValuesFromNpdb)
            {
                foreach (DictionaryEntry deResult in htBucketValuesFromNpdb)
                {
                    InterfaceBucketKey key = (InterfaceBucketKey) deResult.Key;
                    InterfaceBucketCacheLine cacheLine = (InterfaceBucketCacheLine) InterfaceBucketCache[key];

                    if (null != cacheLine)
                    {
                        IBucketServer value = (IBucketServer) deResult.Value;

                        if (value.ToString() != cacheLine._value.ToString())
                        {
                            // if the interface bucket has changed, but Config.InterfaceBucketChange
                            // is null (which means no delegates have been attached to the Event) then
                            // we can't commit this change to the cache, because we didn't get approval
                            // from the client code. So mark this cache line as dirty, log an event,
                            // and move along to the next cache line
                            if (InterfaceBucketChange == null)
                            {
                                cacheLine._dirty = true;
                                cacheLine._newValue = value;
                                LogInterfaceBucketChangeNoHandlerEvent(key, cacheLine._value, value);
                                continue;
                            }

                            // if we get here, InterfaceBucketChange is not null, so we
                            // we signal the Event to notify the client code of the change.
                            // first we set _approveInterfaceBucketChange to true, so we can
                            // see if any of the event handlers vetoed the change
                            InterfaceBucketChangeEventArgs eventArgs
                                = new InterfaceBucketChangeEventArgs(
                                    key._environment,
                                    key._titleId,
                                    key._bucket,
                                    key._iface,
                                    cacheLine._value,
                                    value);

                            _approveInterfaceBucketChange = true;

                            // we want to wrap this in a try catch block, so if any
                            // registered handlers throw an exception we behave in
                            // a predictable fashion
                            try
                            {
                                OnInterfaceBucketChange(eventArgs);
                            }
                            catch (Exception e)
                            {
                                // Log that the exception was thrown and then treat
                                // this as a rejected change
                                LogInterfaceBucketChangeExceptionEvent(key, cacheLine._value, value, e);
                                _approveInterfaceBucketChange = false;
                            }

                            // if _approveInterfaceBucketChange is still true, then none of the
                            // InterfaceBucketChangeEventHandler delegates called VetoInterfaceBucketChange,
                            // therefore we can commit the change to the cache
                            if (_approveInterfaceBucketChange)
                            {
                                LogInterfaceBucketChangeAcceptedEvent(key, cacheLine._value, value);
                                cacheLine._value = value;
                            }
                            else
                            {
                                // if _approveInterfaceBucketChange is now false, one or more of the
                                // InterfaceBucketChangeEventHandler delegates called VetoInterfaceBucketChange,
                                // therefore we should flag this cache line as dirty, and log
                                // an NT event
                                LogInterfaceBucketChangeRejectedEvent(key, cacheLine._value, value);
                                cacheLine._dirty = true;
                                cacheLine._newValue = value;
                            }
                        }
                        else if (cacheLine._dirty)
                        {
                            //  In this case the values are equal but the cacheline is currently marked dirty
                            //  This means the value has been returned to its original value, clear the
                            //  dirty flag.
                            LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                            try
                            {
                                cacheLine._dirty = false;
                                cacheLine._lastEvent = DateTime.MinValue;
                                cacheLine._newValue = null;
                            }
                            finally
                            {
                                _rwLock.DowngradeFromWriterLock(ref lc);
                            }
                        }
                    }
                }
            }
        }

        private void LogInterfaceBucketChangeAcceptedEvent(
            InterfaceBucketKey key,
            IBucketServer oldValue,
        IBucketServer newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_27,
                "An interface bucket change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "TitleId: " + key._titleId + "\n"
                + "Bucket: " + key._bucket + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceBucketChangeRejectedEvent(
            InterfaceBucketKey key,
            IBucketServer oldValue,
        IBucketServer newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_120,
                "An interface bucket change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "TitleId: " + key._titleId + "\n"
                + "Bucket: " + key._bucket + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceBucketChangeNoHandlerEvent(
            InterfaceBucketKey key,
            IBucketServer oldValue,
        IBucketServer newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_121,
                "An interface bucket change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "TitleId: " + key._titleId + "\n"
                + "Bucket: " + key._bucket + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogInterfaceBucketChangeExceptionEvent(
            InterfaceBucketKey key,
            IBucketServer oldValue,
        IBucketServer newValue,
        Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_122,
                "An interface bucket change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "Interface: " + key._iface + "\n"
                + "TitleId: " + key._titleId + "\n"
                + "Bucket: " + key._bucket + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogStaleInterfaceBucketEvent(
            InterfaceBucketKey key,
            InterfaceBucketCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_123,
                    "This component is not using the latest interface bucket information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "Interface: " + key._iface + "\n"
                    + "TitleId: " + key._titleId + "\n"
                    + "Bucket: " + key._bucket + "\n"
                    + "Stale Value: " + cacheLine._value.ToString() + "\n"
                    + "New Value: " + cacheLine._newValue.ToString() + "\n");

                // remember the current time...
                cacheLine._lastEvent = DateTime.Now;
            }
        }

        public uint GetBucketNum(string iface, ulong hashValue)
        {
            return (uint)(hashValue % GetBucketCount(iface));
        }

        public uint GetRandomBucketNum(string iface)
        {
            return (uint)(Rand.Next(0, (int)GetBucketCount(iface) - 1));
        }

        // We do not support changing the number of buckets on the fly.
        // the idea is that we choose the number of buckets to be large enough that
        // we can accomplish any load balancing we wish by moving a bucket from
        // one server to another. This way, we can add new servers on the fly, then
        // move buckets from existing servers to new servers using stateful
        // server migration. Therefore, we do not implement notifications like the
        // other caches in this class, because it should never change.
        private Hashtable _bucketCountCache;

        private Hashtable BucketCountCache
        {
            get
            {
                if (_bucketCountCache != null)
                {
                    return _bucketCountCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_bucketCountCache != null)
                    {
                        return _bucketCountCache;
                    }

                    _bucketCountCache = new Hashtable();

                    return _bucketCountCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        public uint GetBucketCount(string iface)
        {
            uint bucketCount;
            if (TryGetBucketCount(iface, out bucketCount)) return bucketCount;

            ApplicationException ae = new ApplicationException(
                "No interface buckets found for specified interface " + iface + ". " +
                "This probably indicates a configuration error.  Details below.\n\n" +
                "p_config_get_interface_partition_count(" + String.Join(",", new string[]
                { Environment, iface }) + ") did not return any results ! Check npdb.t_interface_buckets."
            );

            LogNtEvent(
                ConfigEvent.Id.COMMON_CONFIG_126, ae + "\n" + System.Environment.StackTrace
            );

            throw ae;
        }


        public bool TryGetBucketCount(string iface, out uint bucketCount)
        {
            if (!BucketCountCache.Contains(iface))
            {
                using (SqlConnection cxn = new SqlConnection(NpdbConnectionString))
                {
                    cxn.Open();
                    SqlCommand cmd = new SqlCommand("p_config_get_interface_partition_count", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add(new SqlParameter("@vc_environment", Environment));
                    cmd.Parameters.Add(new SqlParameter("@vc_interface", iface));
                    cmd.Parameters.Add(new SqlParameter("@i_num_buckets", 0));
                    cmd.Parameters[2].SqlDbType = SqlDbType.Int;
                    cmd.Parameters[2].Direction = ParameterDirection.Output;

                    cmd.ExecuteNonQuery();

                    if (cmd.Parameters[2].Value == DBNull.Value)
                    {
                        bucketCount = 0;
                        return false;
                    }

                    lock(BucketCountCache)
                    {
                        BucketCountCache[iface] = (uint)((int)cmd.Parameters[2].Value) + 1;
                    }
                }
            }

            bucketCount = (uint) BucketCountCache[iface];
            return true;
        }

        public void CompleteMigration(string iface, uint bucket)
        {
            CompleteTitleMigration(iface, 0, bucket);
        }

        // this method does not modify the interface bucket cache - we rely on the usual
        // detection and notification procedure to take care of that
        public void CompleteTitleMigration(string iface, uint titleId, uint bucket)
        {
            using (SqlConnection cxn = new SqlConnection(NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand cmd = new SqlCommand("p_config_complete_bucket_migration", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add(new SqlParameter("@vc_environment", Environment));
                cmd.Parameters.Add(new SqlParameter("@vc_interface", iface));
                cmd.Parameters.Add(new SqlParameter("@i_title_id", (int)titleId));
                cmd.Parameters.Add(new SqlParameter("@i_bucket", (int)bucket));

                cmd.ExecuteNonQuery();
            }
        }

        public string[] GetVirtualInterfaceListBySite(Site site)
        {
            ApplicationException ae;
            string[] virtualInterfaces = null;
            switch (site)
            {
                case Site.main:
                    virtualInterfaces = GetVirtualInterfaceListBySite(MainSiteId);
                    break;

                case Site.same:
                    if (SiteId == 0)
                    {
                        ae = new ApplicationException("GetVirtualInterfaceListBySite(Site.same) called when current site is unknown");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_127, ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }
                    virtualInterfaces = GetVirtualInterfaceListBySite(SiteId);
                    break;

                case Site.only:
                    ae = new ApplicationException("GetVirtualInterfaceListBySite(Site.only) is not allowed");
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_128, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
            }

            return virtualInterfaces;
        }

        public string[] GetVirtualInterfaceListBySite(int siteId)
        {
            return GetVirtualInterfaceListBySiteFromCache(Environment, siteId);
        }

        // attach VirtualInterfaceListChangeEventHandler delegates to this event to be notified
        // when virtual interface lists change in NPDB
        public event VirtualInterfaceListChangeEventHandler VirtualInterfaceListChange;
        protected void OnVirtualInterfaceListChange(VirtualInterfaceListChangeEventArgs e)
        {
            if (VirtualInterfaceListChange != null)
            {
                VirtualInterfaceListChange(null, e);
            }
        }

        // if the VirtualInterfaceListChangeHandler wants to veto the change, it calls
        // VetoVirtualInterfaceListChange, which sets the _approveVirtualInterfaceListChange flag to false
        private bool _approveVirtualInterfaceListChange = true;
        public void VetoVirtualInterfaceListChange()
        {
            // VirtualInterfaceListChangeEventHandlers call this method if they
            // need to indicate that the virtual interface list change indicated by
            // the VirtualInterfaceListChangeEventArgs should not be committed
            // to the cache
            _approveVirtualInterfaceListChange = false;
        }

        // the virtual interface list cache is implemented as a hashtable, where the
        // keys are VirtualInterfaceListKey objects and the values are VirtualInterfaceListCacheLine
        // objects.
        private Hashtable _virtualInterfaceListCache;
        private class VirtualInterfaceListKey : IComparable
        {
            public string _environment;
            public int _siteId;

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _siteId.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _siteId;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(VirtualInterfaceListKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to VirtualInterfaceListKey.CompareTo is not a VirtualInterfaceListKey");
                }

                VirtualInterfaceListKey key = (VirtualInterfaceListKey)o;
                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                if (_siteId < key._siteId)
                {
                    return -1;
                }
                if (_siteId > key._siteId)
                {
                    return 1;
                }
                // siteids are equal

                return 0;
            }

        }

        private class VirtualInterfaceListCacheLine
        {
            public string[] _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public string[] _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return CollectionToString(_value) + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + CollectionToString(_newValue);
            }
        }

        private Hashtable VirtualInterfaceListCache
        {
            get
            {
                if (_virtualInterfaceListCache != null)
                {
                    return _virtualInterfaceListCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_virtualInterfaceListCache != null)
                    {
                        return _virtualInterfaceListCache;
                    }

                    _virtualInterfaceListCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _virtualInterfaceListCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        private string[] GetVirtualInterfaceListBySiteFromCache(string environment, int siteId)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_129, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested setting
            VirtualInterfaceListKey key = new VirtualInterfaceListKey();
            key._environment = environment;
            key._siteId = siteId;

            if (VirtualInterfaceListCache.ContainsKey(key))
            {
                VirtualInterfaceListCacheLine cacheLine = (VirtualInterfaceListCacheLine)VirtualInterfaceListCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleVirtualInterfaceListEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the virtual interface list was not found in the cache, so
            // get the info from the database and add it to the cache
            string[] value = GetVirtualInterfaceListBySiteFromDB(environment, siteId);

            VirtualInterfaceListCacheLine newCacheLine = new VirtualInterfaceListCacheLine();

            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock (VirtualInterfaceListCache)
            {
                VirtualInterfaceListCache[key] = newCacheLine;
            }

            return value;
        }

        private void RefreshVirtualInterfaceLists()
        {
            // for each line in the virtual interface list cache, requery that virtual interface list from NPDB
            foreach (DictionaryEntry de in VirtualInterfaceListCache)
            {
                // requery for the virtual interface list from the database
                VirtualInterfaceListKey key = (VirtualInterfaceListKey) de.Key;
                string[] value = GetVirtualInterfaceListBySiteFromDB(
                    key._environment,
                    key._siteId);
                // GetVirtualInterfaceList will throw if the virtual interface does not exist

                // has the virtual interface list changed?
                VirtualInterfaceListCacheLine cacheLine = (VirtualInterfaceListCacheLine) de.Value;
                if (!CollectionEquals(value, cacheLine._value))
                {
                    // if the virtual interface list has changed, but Config.VirtualInterfaceListChange
                    // is null (which means no delegates have been attached to the Event) then
                    // we can't commit this change to the cache, because we didn't get approval
                    // from the client code. So mark this cache line as dirty, log an event,
                    // and move along to the next cache line
                    if (VirtualInterfaceListChange == null)
                    {
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                        LogVirtualInterfaceListChangeNoHandlerEvent(key, cacheLine._value, value);
                        continue;
                    }

                    // if we get here, VirtualInterfaceListChange is not null, so we
                    // we signal the Event to notifiy the client code of the change.
                    // first we set _approveVirtualInterfaceListChange to true, so we can
                    // see if any of the event handlers vetoed the change
                    VirtualInterfaceListChangeEventArgs eventArgs
                        = new VirtualInterfaceListChangeEventArgs(
                            key._environment,
                            key._siteId,
                            cacheLine._value,
                            value);
                    _approveVirtualInterfaceListChange = true;

                    // we want to wrap this in a try catch block, so if any
                    // registered handlers throw an exception we behave in
                    // a predictable fashion
                    try
                    {
                        OnVirtualInterfaceListChange(eventArgs);
                    }
                    catch (Exception e)
                    {
                        // Log that the exception was thrown and then treat
                        // this as a rejected change
                        LogVirtualInterfaceListChangeExceptionEvent(key, cacheLine._value, value, e);
                        _approveVirtualInterfaceListChange = false;
                    }

                    // if _approveVirtualInterfaceListChange is still true, then none of the
                    // VirtualInterfaceListChangeEventHandler delegates called VetoVirtualInterfaceListChange,
                    // therefore we can commit the change to the cache
                    if (_approveVirtualInterfaceListChange)
                    {
                        LogVirtualInterfaceListChangeAcceptedEvent(key, cacheLine._value, value);
                        cacheLine._value = value;
                    }
                    else
                    {
                        // if _approveVirtualInterfaceListChange is now false, one or more of the
                        // VirtualInterfaceListChangeEventHandler delegates called VetoVirtualInterfaceListChange,
                        // therefore we should flag this cache line as dirty, and log
                        // an NT event
                        LogVirtualInterfaceListChangeRejectedEvent(key, cacheLine._value, value);
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                    }
                }
                else if (cacheLine._dirty)
                {
                    //  In this case the values are equal but the cacheline is currently marked dirty
                    //  This means the value has been returned to its original value, clear the
                    //  dirty flag.
                    cacheLine._dirty = false;
                    cacheLine._lastEvent = DateTime.MinValue;
                    cacheLine._newValue = null;
                }
            }
        }

        private void LogVirtualInterfaceListChangeAcceptedEvent(
            VirtualInterfaceListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_28,
                "A virtual interface list change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogVirtualInterfaceListChangeRejectedEvent(
            VirtualInterfaceListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_130,
                "A virtual interface list change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogVirtualInterfaceListChangeNoHandlerEvent(
            VirtualInterfaceListKey key,
            string[] oldValue,
        string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_131,
                "A virtual interface list change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogVirtualInterfaceListChangeExceptionEvent(
            VirtualInterfaceListKey key,
            string[] oldValue,
        string[] newValue,
        Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_132,
                "A virtual interface list change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n"
                + "Exception Message:" + e.Message + "\n"
                + "Exception Stack Trace:" + e.StackTrace + "\n");
        }

        private void LogStaleVirtualInterfaceListEvent(
            VirtualInterfaceListKey key,
            VirtualInterfaceListCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_133,
                    "This component is not using the latest virtual interface list information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "SiteId: " + key._siteId + "\n"
                    + "Stale Value: " + CollectionToString(cacheLine._value) + "\n"
                    + "New Value: " + CollectionToString(cacheLine._newValue) + "\n");

                // remember the current time...
                cacheLine._lastEvent = DateTime.Now;
            }
        }

        private string[] GetVirtualInterfaceListBySiteFromDB(string environment, int siteId)
        {
            SortedList virtualInterfaceList = new SortedList();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_virtual_interface_list_by_site";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@i_site_id", SqlDbType.NVarChar).Value = siteId;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            string virtualInterface = (string) reader["vc_virtual_interface"];

                            // add it to the list
                            virtualInterfaceList.Add(virtualInterface, virtualInterface);
                        }
                    }
                }
            }

            // convert the sorted list to an array
            string[] virtualInterfaces = new string[virtualInterfaceList.Count];
            virtualInterfaceList.Values.CopyTo(virtualInterfaces, 0);
            return virtualInterfaces;
        }

        public IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(Site site)
        {
            ApplicationException ae;
            IVirtualInterfaceInfo[] virtualInterfaceInfos = null;
            switch (site)
            {
                case Site.main:
                    virtualInterfaceInfos = GetVirtualInterfaceInfoBySite(MainSiteId);
                    break;

                case Site.same:
                    if (SiteId == 0)
                    {
                        ae = new ApplicationException("GetVirtualInterfaceInfoBySite(Site.same) called when current site is unknown");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_135, ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }
                    virtualInterfaceInfos = GetVirtualInterfaceInfoBySite(SiteId);
                    break;

                case Site.only:
                    ae = new ApplicationException("GetVirtualInterfaceInfoBySite(Site.only) is not allowed");
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_136, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
            }

            return virtualInterfaceInfos;
        }

        public IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(int siteId)
        {
            string[] virtualInterfaces = GetVirtualInterfaceListBySite(siteId);

            IVirtualInterfaceInfo[] virtualInterfaceInfos
                = new IVirtualInterfaceInfo[virtualInterfaces.Length];

            for (int i = 0; i < virtualInterfaces.Length; ++i)
            {
                virtualInterfaceInfos[i] = GetVirtualInterface(virtualInterfaces[i], siteId);
            }

            return virtualInterfaceInfos;
        }

        // Retrieves the information required to reach a virtual interface.
        public bool TryGetVirtualInterface(string virtualInterface, out IVirtualInterfaceInfo virtualInterfaceInfo)
        {
            virtualInterfaceInfo = GetVirtualInterface(virtualInterface, Site.same, true);
            return virtualInterfaceInfo != null;
        }

        // Retrieves the information required to reach a virtual interface.
        public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface)
        {
            return GetVirtualInterface(virtualInterface, Site.same, false);
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, Site site)
        {
            return GetVirtualInterface(virtualInterface, site, false);
        }

        private IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, Site site, bool tryGet)
        {
            ApplicationException ae;
            IVirtualInterfaceInfo virtualInterfaceInfo = null;
            switch (site)
            {
                case Site.main:
                    virtualInterfaceInfo = GetVirtualInterface(virtualInterface, MainSiteId, tryGet);
                    break;

                case Site.same:
                    if (SiteId == 0)
                    {
                        ae = new ApplicationException("GetVirtualInterface(Site.same) called when current site is unknown");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_137, ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }
                    virtualInterfaceInfo = GetVirtualInterface(virtualInterface, SiteId, tryGet);
                    break;

                case Site.only:
                    ae = new ApplicationException("GetVirtualInterface(Site.only) not yet implemented");
                    LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_138, ae + "\n" + System.Environment.StackTrace);
                    throw ae;
            }

            return virtualInterfaceInfo;
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, int siteId)
        {
            return GetVirtualInterfaceFromCache(virtualInterface, siteId, Environment, false);
        }

        private IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, int siteId, bool tryGet)
        {
            return GetVirtualInterfaceFromCache(virtualInterface, siteId, Environment, tryGet);
        }

        // attach VirtualInterfaceChangeEventHandler delegates to this event to be notified
        // when virtual interface info changes in NPDB
        public event VirtualInterfaceChangeEventHandler VirtualInterfaceChange;
        protected void OnVirtualInterfaceChange(VirtualInterfaceChangeEventArgs e)
        {
            if (VirtualInterfaceChange != null)
            {
                VirtualInterfaceChange(null, e);
            }
        }

        // if the VirtualInterfaceChangeHandler wants to veto the change, it calls
        // VetoVirtualInterfaceChange, which sets the _approveVirtualInterfaceChange flag to false
        private bool _approveVirtualInterfaceChange = true;
        public void VetoVirtualInterfaceChange()
        {
            // VirtualInterfaceChangeEventHandlers call this method if they
            // need to indicate that the virtual interface change indicated by
            // the VirtualInterfaceChangeEventArgs should not be committed
            // to the cache
            _approveVirtualInterfaceChange = false;
        }

        // the virtual interface cache is implemented as a hashtable, where the
        // keys are VirtualInterfaceKey objects and the values are VirtualInterfaceCacheLine
        // objects.
        private Hashtable _virtualInterfaceCache;
        private class VirtualInterfaceKey : IComparable
        {
            public string _environment;
            public int _siteId;
            public string _virtualInterface;

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _siteId.GetHashCode()
                    + _virtualInterface.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _siteId + ","
                    + _virtualInterface;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(VirtualInterfaceKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to VirtualInterfaceKey.CompareTo is not a VirtualInterfaceKey");
                }

                VirtualInterfaceKey key = (VirtualInterfaceKey)o;

                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                if (_siteId < key._siteId)
                {
                    return -1;
                }
                if (_siteId > key._siteId)
                {
                    return 1;
                }
                // siteids are equal

                return String.Compare(_virtualInterface, key._virtualInterface, false, CultureInfo.InvariantCulture);
            }
        }

        private class VirtualInterfaceCacheLine
        {
            public IVirtualInterfaceInfo _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public IVirtualInterfaceInfo _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return _value.ToString() + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + (_newValue == null ? "<null>" : _newValue.ToString());
            }
        }

        private Hashtable VirtualInterfaceCache
        {
            get
            {
                if (_virtualInterfaceCache != null)
                {
                    return _virtualInterfaceCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_virtualInterfaceCache != null)
                    {
                        return _virtualInterfaceCache;
                    }

                    _virtualInterfaceCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _virtualInterfaceCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        // gets the virtual interface information from the cache if present,
        // or from the database if not present, and adds that information to the
        // cache. If the cache does not exist, it is created
        private IVirtualInterfaceInfo GetVirtualInterfaceFromCache(
            string virtualInterface,
            int siteId,
            string environment,
            bool tryGet)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_139, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested setting
            VirtualInterfaceKey key = new VirtualInterfaceKey();
            key._environment = environment;
            key._siteId = siteId;
            key._virtualInterface = virtualInterface;

            if (VirtualInterfaceCache.ContainsKey(key))
            {
                VirtualInterfaceCacheLine cacheLine = (VirtualInterfaceCacheLine)VirtualInterfaceCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleVirtualInterfaceEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the virtual interface was not found in the cache, so
            // get the info from the database and add it to the cache
            IVirtualInterfaceInfo value = GetVirtualInterfaceFromDB(
                virtualInterface,
                siteId,
                environment,
                tryGet
            );

            if (value == null) return null;
            VirtualInterfaceCacheLine newCacheLine = new VirtualInterfaceCacheLine();

            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock (VirtualInterfaceCache)
            {
                VirtualInterfaceCache[key] = newCacheLine;
            }

            return value;
        }

        private void RefreshVirtualInterfaces()
        {
            // for each line in the virtual interface cache, requery that virtual interface from NPDB
            foreach (DictionaryEntry de in VirtualInterfaceCache)
            {
                // requery for the virtual interface from the database
                VirtualInterfaceKey key = (VirtualInterfaceKey)de.Key;
                IVirtualInterfaceInfo value = GetVirtualInterfaceFromDB(
                    key._virtualInterface,
                    key._siteId,
                    key._environment,
                    false);
                // GetVirtualInterface will throw if the virtual interface does not exist

                // has the virtual interface changed?
                VirtualInterfaceCacheLine cacheLine = (VirtualInterfaceCacheLine)de.Value;
                if (value.ToString() != cacheLine._value.ToString())
                {
                    // if the virtual interface has changed, but Config.VirtualInterfaceChange
                    // is null (which means no delegates have been attached to the Event) then
                    // we can't commit this change to the cache, because we didn't get approval
                    // from the client code. So mark this cache line as dirty, log an event,
                    // and move along to the next cache line
                    if (VirtualInterfaceChange == null)
                    {
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;

                        LogVirtualInterfaceChangeNoHandlerEvent(key, cacheLine._value, value);
                        continue;
                    }

                    // if we get here, VirtualInterfaceChange is not null, so we
                    // we signal the Event to notifiy the client code of the change.
                    // first we set _approveVirtualInterfaceChange to true, so we can
                    // see if any of the event handlers vetoed the change
                    VirtualInterfaceChangeEventArgs eventArgs
                        = new VirtualInterfaceChangeEventArgs(
                            key._environment,
                            key._siteId,
                            key._virtualInterface,
                            cacheLine._value,
                            value);
                    _approveVirtualInterfaceChange = true;

                    // we want to wrap this in a try catch block, so if any
                    // registered handlers throw an exception we behave in
                    // a predictable fashion
                    try
                    {
                        OnVirtualInterfaceChange(eventArgs);
                    }
                    catch (Exception e)
                    {
                        // Log that the exception was thrown and then treat
                        // this as a rejected change
                        LogVirtualInterfaceChangeExceptionEvent(key, cacheLine._value, value, e);
                        _approveVirtualInterfaceChange = false;
                    }

                    // if _approveVirtualInterfaceChange is still true, then none of the
                    // VirtualInterfaceChangeEventHandler delegates called VetoVirtualInterfaceChange,
                    // therefore we can commit the change to the cache
                    if (_approveVirtualInterfaceChange)
                    {
                        LogVirtualInterfaceChangeAcceptedEvent(key, cacheLine._value, value);
                        cacheLine._value = value;
                    }
                    else
                    {
                        // if _approveVirtualInterfaceChange is now false, one or more of the
                        // VirtualInterfaceChangeEventHandler delegates called VetoVirtualInterfaceChange,
                        // therefore we should flag this cache line as dirty, and log
                        // an NT event
                        LogVirtualInterfaceChangeRejectedEvent(key, cacheLine._value, value);
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                    }
                }
                else if (cacheLine._dirty)
                {
                    //  In this case the values are equal but the cacheline is currently marked dirty
                    //  This means the value has been returned to its original value, clear the
                    //  dirty flag.
                    cacheLine._dirty = false;
                    cacheLine._lastEvent = DateTime.MinValue;
                    cacheLine._newValue = null;
                }
            }
        }

        private void LogVirtualInterfaceChangeAcceptedEvent(
            VirtualInterfaceKey key,
            IVirtualInterfaceInfo oldValue,
        IVirtualInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_29,
                "A virtual interface change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "VirtualInterface: " + key._virtualInterface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogVirtualInterfaceChangeRejectedEvent(VirtualInterfaceKey key, IVirtualInterfaceInfo oldValue, IVirtualInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_140,
                "A virtual interface change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "VirtualInterface: " + key._virtualInterface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogVirtualInterfaceChangeNoHandlerEvent(VirtualInterfaceKey key, IVirtualInterfaceInfo oldValue, IVirtualInterfaceInfo newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_141,
                "A virtual interface change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "VirtualInterface: " + key._virtualInterface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n");
        }

        private void LogVirtualInterfaceChangeExceptionEvent(
            VirtualInterfaceKey key,
            IVirtualInterfaceInfo oldValue,
            IVirtualInterfaceInfo newValue,
            Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_142,
                "A virtual interface change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "VirtualInterface: " + key._virtualInterface + "\n"
                + "Old Value: " + oldValue.ToString() + "\n"
                + "New Value: " + newValue.ToString() + "\n"
                + "Exception Message:" + e.Message + "\n"
                + "Exception Stack Trace:" + e.StackTrace + "\n");
        }

        private void LogStaleVirtualInterfaceEvent(VirtualInterfaceKey key, VirtualInterfaceCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_143,
                    "This component is not using the latest virtual interface information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "SiteId: " + key._siteId + "\n"
                    + "VirtualInterface: " + key._virtualInterface + "\n"
                    + "Stale Value: " + cacheLine._value.ToString() + "\n"
                    + "New Value: " + cacheLine._newValue.ToString() + "\n");

                // remember the current time...
                cacheLine._lastEvent = DateTime.Now;
            }
        }

        // Get the virtual interface information directly from the database
        private IVirtualInterfaceInfo GetVirtualInterfaceFromDB(
            string virtualInterface,
            int siteId,
            string environment,
            bool tryGet)
        {
            // default contructor inits everything to null or invalid values. These will be used
            // if no value is provided in NPDB for a particular value
            VirtualInterfaceInfo virtualInterfaceInfo = new VirtualInterfaceInfo();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_virtual_interface";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@i_site_id", SqlDbType.NVarChar).Value = siteId;
                cmd.Parameters.Add("@vc_virtual_interface", SqlDbType.NVarChar).Value = virtualInterface;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = ComponentName;

                SqlDataReader reader;
                
                using(reader = cmd.ExecuteReader())
                {
                    if(reader != null)
                    {
                        if (!reader.Read())
                        {
                            if (tryGet) return null;

                            ApplicationException ae = new ApplicationException("VirtualInterface '"
                                + virtualInterface
                                + "' not present in site id "
                                + siteId);
                            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_144, ae + "\n" + System.Environment.StackTrace);
                            throw ae;
                        }

                        // if it's returned by the stored proc, it can't be null
                        virtualInterfaceInfo.VirtualInterface = (string)reader["vc_virtual_interface"];

                        // if it's returned by the stored proc, it can't be null
                        virtualInterfaceInfo.Interface = (string)reader["vc_interface"];

                        // vc_protocol is declared as not null
                        virtualInterfaceInfo.Protocol = (string)reader["vc_protocol"];

                        // vc_ip may be null, and could be invalid
                        if (reader["vc_ip"] != DBNull.Value)
                        {
                            try
                            {
                                virtualInterfaceInfo.IPAddressString = (string)reader["vc_ip"];
                            }
                            catch (Exception e)
                            {
                                ApplicationException ae = new ApplicationException(
                                    "Could not parse vc_ip as an IPAddress, value: "
                                    + (string)reader["vc_ip"],
                                    e);
                                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_147, ae + "\n" + System.Environment.StackTrace);
                                throw ae;
                            }
                        }

                        // i_port may be null
                        if (reader["i_port"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Port = (Int32)reader["i_port"];
                        }

                        // i_port_end may be null
                        if (reader["i_port_end"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.PortEnd = (Int32)reader["i_port_end"];
                        }

                        // vc_vdir may be null
                        if (reader["vc_vdir"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.VDir = (string)reader["vc_vdir"];
                        }

                        // vc_webstore_app may be null
                        if (reader["vc_webstore_app"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.WebstoreApp = (string)reader["vc_webstore_app"];
                        }

                        // i_timeout may be null
                        if (reader["i_timeout"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Timeout = (Int32)reader["i_timeout"];
                        }

                        // i_service_id may be null
                        if (reader["i_service_id"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.ServiceId = (Int32)reader["i_service_id"];
                        }

                        // old version of this stored proc will not return this column. Until we have
                        // regular builds of testnet, I'll squash the exception that indicates the
                        // column is not returned. This will allow developers to deploy private
                        // builds that include this new config code without requiring NPDB to be updated
                        try
                        {
                            // vc_service_name may be null
                            if (reader["vc_service_name"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.ServiceName = (string)reader["vc_service_name"];
                            }
                        }
                        catch (IndexOutOfRangeException)
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        // old version of this stored proc will not return this column. Until we have
                        // regular builds of testnet, I'll squash the exception that indicates the
                        // column is not returned. This will allow developers to deploy private
                        // builds that include this new config code without requiring NPDB to be updated
                        try
                        {
                            // b_need_sg_info may be null
                            if (reader["b_need_sg_info"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.NeedSGInfo = (bool)reader["b_need_sg_info"];
                            }
                        }
                        catch (IndexOutOfRangeException)
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        // i_internet_port may be null
                        if (reader["i_internet_port"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.InternetPort = (Int32)reader["i_internet_port"];
                        }

                        // i_internet_port_end may be null
                        if (reader["i_internet_port_end"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.InternetPortEnd = (Int32)reader["i_internet_port_end"];
                        }

                        // vc_info1 may be null
                        if (reader["vc_info1"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info1 = (string)reader["vc_info1"];
                        }

                        // vc_info2 may be null
                        if (reader["vc_info2"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info2 = (string)reader["vc_info2"];
                        }
                        // i_min_connection_pool_size may be null
                        if (reader["i_min_connection_pool_size"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.MinConnectionPoolSize = (Int32)reader["i_min_connection_pool_size"];
                        }

                        // i_max_connection_pool_size may be null
                        if (reader["i_max_connection_pool_size"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.MaxConnectionPoolSize = (Int32)reader["i_max_connection_pool_size"];
                        }

                        // i_load_balance_timeout may be null
                        if (reader["i_load_balance_timeout"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.LoadBalanceTimeout = (Int32)reader["i_load_balance_timeout"];
                        }

                        // i_connection_timeout may be null
                        if (reader["i_connection_timeout"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.ConnectionTimeout = (Int32)reader["i_connection_timeout"];
                        }

                        // vc_health_xrl may be null or might not exist
                        try
                        {
                            if (reader["vc_health_xrl"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.HealthCheckUrl = (string)reader["vc_health_xrl"];
                            }
                        } 
                        catch (IndexOutOfRangeException)
                        {
                            // Ignore
                        }

                        // Do we have another result set?
                        if (reader.NextResult())
                        {
                            // Generic Notification Interfaces are stored here
                            while (reader.Read())
                            {
                                string vc_notification = (string)reader["vc_notification"];
                                string vc_url          = (string)reader["vc_url"];

                                virtualInterfaceInfo.AddNotificationUrl( vc_notification, vc_url );
                            }
                        }

                    }
                }

                // now, get any environment type overrides and apply them
                cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_environment_type_virtual_interface_overrides";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_virtual_interface", SqlDbType.NVarChar).Value = virtualInterface;
                
                using(reader = cmd.ExecuteReader())
                {
                    if (reader != null && reader.Read())
                    {
                        // there is an override row, so apply anything that's not null
                        if (reader["i_port"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Port = (Int32) reader["i_port"];
                        }

                        if (reader["i_port_end"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.PortEnd = (Int32) reader["i_port_end"];
                        }

                        if (reader["vc_vdir"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.VDir = (string) reader["vc_vdir"];
                        }

                        if (reader["vc_webstore_app"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.WebstoreApp = (string) reader["vc_webstore_app"];
                        }

                        if (reader["i_timeout"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Timeout = (Int32) reader["i_timeout"];
                        }

                        try
                        {
                            if (reader["i_internet_port"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.InternetPort = (Int32) reader["i_internet_port"];
                            }
                        }
                        catch
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        try
                        {
                            if (reader["i_internet_port_end"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.InternetPortEnd = (Int32) reader["i_internet_port_end"];
                            }
                        }
                        catch
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        if (reader["vc_info1"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info1 = (string) reader["vc_info1"];
                        }

                        if (reader["vc_info2"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info2 = (string) reader["vc_info2"];
                        }
                    }
                }

                // now, get any site overrides and apply them
                cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_site_virtual_interface_overrides";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@i_site_id", SqlDbType.NVarChar).Value = siteId;
                cmd.Parameters.Add("@vc_virtual_interface", SqlDbType.NVarChar).Value = virtualInterface;
                
                using(reader = cmd.ExecuteReader())
                {
                    if (reader != null && reader.Read())
                    {
                        // there is an override row, so apply anything that's not null
                        if (reader["i_port"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Port = (Int32) reader["i_port"];
                        }

                        if (reader["i_port_end"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.PortEnd = (Int32) reader["i_port_end"];
                        }

                        if (reader["vc_vdir"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.VDir = (string) reader["vc_vdir"];
                        }

                        if (reader["vc_webstore_app"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.WebstoreApp = (string) reader["vc_webstore_app"];
                        }

                        if (reader["i_timeout"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Timeout = (Int32) reader["i_timeout"];
                        }

                        try
                        {
                            if (reader["i_internet_port"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.InternetPort = (Int32) reader["i_internet_port"];
                            }
                        }
                        catch
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        try
                        {
                            if (reader["i_internet_port_end"] != DBNull.Value)
                            {
                                virtualInterfaceInfo.InternetPortEnd = (Int32) reader["i_internet_port_end"];
                            }
                        }
                        catch
                        {
                            // just squash the exception, which treats the column like a NULL
                        }

                        if (reader["vc_info1"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info1 = (string) reader["vc_info1"];
                        }

                        if (reader["vc_info2"] != DBNull.Value)
                        {
                            virtualInterfaceInfo.Info2 = (string) reader["vc_info2"];
                        }
                    }
                }
            }

            return virtualInterfaceInfo;
        }

        // use this API to retrieve the value for a boolean setting for the
        // current component on the current server
        public bool GetBoolSetting(string setting)
        {
            string val = GetSetting(setting);
            return Config.ConvertBoolSetting(val);
        }

        // use this API to retrieve the value for a signed integer setting for the
        // current component on the current server
        public int GetIntSetting(string setting)
        {
            string val = GetSetting(setting);
            return Int32.Parse(val);
        }

        // use this API to retrieve the value for an unsigned integer setting for the
        // current component on the current server
        public uint GetUIntSetting(string setting)
        {
            string val = GetSetting(setting);
            return UInt32.Parse(val);
        }

        // use this API to retrieve the value for an IP address as an unsigned integer setting for the
        // current component on the current server
        public uint GetUIntIpSetting(string setting)
        {
            string val = GetSetting(setting);
            return ConfigUtil.IpAddressToDword(IPAddress.Parse(val));
        }

        // use this API to retrieve the value for a signed integer setting for the
        // current component on the current server
        public long GetLongSetting(string setting)
        {
            string val = GetSetting(setting);
            return Int64.Parse(val);
        }

        // use this API to retrieve the value for an unsigned integer setting for the
        // current component on the current server
        public ulong GetULongSetting(string setting)
        {
            string val = GetSetting(setting);
            return UInt64.Parse(val);
        }

        // use this API to retrieve the value for a double precision floating point setting for the
        // current component on the current server
        public double GetDoubleSetting(string setting)
        {
            string val = GetSetting(setting);
            return Double.Parse(val);
        }

        // use this API to retrieve the value for a setting for the
        // current component on the current server
        public string GetSetting(string setting)
        {
            string value = GetSettingFromCache(
                Environment,
                SiteId,
                Server,
                Component,
                setting);

            IConfigurationOverride configOverride = this.ConfigurationOverride;
            if (configOverride != null)
                return configOverride.GetInjectedNpdbValue(setting, value);
            else
                return value;
        }

        // Gets a setting from the blob table
        public byte[] GetBlobSetting(string setting)
        {
            using (SqlConnection npdb = new SqlConnection(NpdbConnectionString))
            {
                npdb.Open();

                // Read certificate template from npdb
                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandText = "dbo.p_config_blob_get";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_config_blob_name", SqlDbType.NVarChar).Value = setting;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader == null || !reader.Read())
                    {
                        return null;
                    }

                    return reader.GetSqlBytes(0).Value;
                }
            }
        }

        // attach SettingChangeEventHandler delegates to this event to be notified
        // when settings change in NPDB
        public event SettingChangeEventHandler SettingChange;
        protected void OnSettingChange(SettingChangeEventArgs e)
        {
            if (SettingChange != null)
            {
                SettingChange(this, e);
            }
        }

        // if the SettingChangeEventHandler wants to veto the change, it calls
        // VetoSetingChange, which sets the _approveSettingsChange flag to false
        private bool _approveSettingsChange = true;
        public void VetoSettingChange()
        {
            // SettingChangeEventHandlers call this method if they
            // need to indicate that the setting change indicated by
            // the SettingChangeEventArgs should not be committed
            // to the cache
            _approveSettingsChange = false;
        }



        // the settings cache is implemented as a hashtable, where the
        // keys are SettingsKey objects and the values are SettingsCacheLine
        // objects.
        private Hashtable _settingsCache;
        private class SettingsKey : IComparable
        {
            public string _environment;
            public int _siteId;
            public string _server;
            public string _component;
            public string _setting;

            public SettingsKey()
            {

            }

            public SettingsKey(string szEnvironment, int iSiteId, string szServer, string szComponent, string szSetting)
            {
                _environment = szEnvironment;
                _siteId = iSiteId;
                _server = szServer;
                _component = szComponent;
                _setting = szSetting;
            }

            public string ToXmlBatchQueryFormat()
            {
                return String.Format(@"<a vc_setting=""{0}""/>", _setting);
            }

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                                 + _siteId.GetHashCode()
                                 + _server.GetHashCode()
                                 + _component.GetHashCode()
                                 + _setting.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                       + _siteId + ","
                       + _server + ","
                       + _component + ","
                       + _setting;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(SettingsKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to SettingsKey.CompareTo is not a SettingsKey");
                }

                SettingsKey key = (SettingsKey)o;
                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                if (_siteId < key._siteId)
                {
                    return -1;
                }
                if (_siteId > key._siteId)
                {
                    return 1;
                }
                // siteids are equal

                int serverCompare = String.Compare(_server, key._server, false, CultureInfo.InvariantCulture);
                if (serverCompare != 0)
                {
                    return serverCompare;
                }

                // servers are equal

                int componentCompare = String.Compare(_component, key._component, false, CultureInfo.InvariantCulture);
                if (componentCompare != 0)
                {
                    return componentCompare;
                }

                // components are equal

                return String.Compare(_setting, key._setting, false, CultureInfo.InvariantCulture);
            }
        }

        private class SettingsCacheLine
        {
            public string _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public string _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return _value + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + (_newValue ?? "<null>");
            }
        }

        private Hashtable SettingsCache
        {
            get
            {
                if (_settingsCache != null)
                {
                    return _settingsCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_settingsCache != null)
                    {
                        return _settingsCache;
                    }

                    _settingsCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();

                    return _settingsCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        /*
        private string SettingCacheToString()
        {
            StringBuilder sb = new StringBuilder();

            foreach (DictionaryEntry de in SettingsCache)
            {
                SettingsKey key = (SettingsKey)de.Key;
                SettingsCacheLine cacheLine = (SettingsCacheLine)de.Value;

                sb.Append(key.ToString());
                sb.Append(":");
                sb.Append(cacheLine.ToString());
                sb.Append("\n");
            }

            return sb.ToString();
        }
        */

        private string GetSettingFromCache(
            string environment,
            int siteId,
            string server,
            string component,
            string setting)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_148, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_149, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested setting
            SettingsKey key = new SettingsKey();
            key._environment = environment;
            key._siteId = siteId;
            key._server = server;
            key._component = component;
            key._setting = setting;

            if (SettingsCache.ContainsKey(key))
            {
                SettingsCacheLine cacheLine = (SettingsCacheLine)SettingsCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleSettingEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the setting was not found in the cache, so use
            // ConfigSql to get it and add it to the cache
            string value = GetSettingFromDB(
                environment,
                siteId,
                server,
                component,
                setting);

            SettingsCacheLine newCacheLine = new SettingsCacheLine();
            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock (SettingsCache)
            {
                SettingsCache[key] = newCacheLine;
            }

            return value;
        }

        internal void TryCacheSettings(
            params string[] settings)
        {
            string environment = Environment;
            int siteId = SiteId;
            string server = Server;
            string component = Component;

            StringBuilder settingsToLoad = new StringBuilder();

            foreach (string setting in settings)
            {
                SettingsKey key = new SettingsKey();
                key._environment = environment;
                key._siteId = siteId;
                key._server = server;
                key._component = component;
                key._setting = setting;

                if (!SettingsCache.ContainsKey(key))
                {
                    settingsToLoad.Append(key.ToXmlBatchQueryFormat());
                }
            }

            if (settingsToLoad.Length > 0)
            {
                Hashtable htSettingValue =
                    NpdbAccess.GetBatchSettingsFromDB(NpdbConnectionString, environment, siteId, server, component, settingsToLoad.ToString());

                foreach (SettingsKey key in htSettingValue.Keys)
                {
                    SettingsCacheLine newCacheLine = new SettingsCacheLine();
                    newCacheLine._value = (string)htSettingValue[key];
                    newCacheLine._dirty = false;

                    // set the last event time to a valid time that's far enough in the
                    // past to guarantee that if the line gets dirty, we'll log the
                    // event the first time
                    newCacheLine._lastEvent = DateTime.MinValue;

                    // save the line in the cache
                    lock (SettingsCache)
                    {
                        SettingsCache[key] = newCacheLine;
                    }
                }
            }
        }

        private void LogSettingChangeAcceptedEvent(SettingsKey key, string oldValue, string newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_30,
                "A setting change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "Setting: " + key._setting + "\n"
                + "Old Value: " + oldValue + "\n"
                + "New Value: " + newValue + "\n");
        }

        private void LogSettingChangeRejectedEvent(SettingsKey key, string oldValue, string newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_150,
                "A setting change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "Setting: " + key._setting + "\n"
                + "Old Value: " + oldValue + "\n"
                + "New Value: " + newValue + "\n");
        }

        private void LogSettingChangeNoHandlerEvent(SettingsKey key, string oldValue, string newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_151,
                "A setting change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "Setting: " + key._setting + "\n"
                + "Old Value: " + oldValue + "\n"
                + "New Value: " + newValue + "\n");
        }

        private void LogSettingChangeExceptionEvent(
            SettingsKey key,
            string oldValue,
        string newValue,
        Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_152,
                "A setting change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "Setting: " + key._setting + "\n"
                + "Old Value: " + oldValue + "\n"
                + "New Value: " + newValue + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogStaleSettingEvent(SettingsKey key, SettingsCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_153,
                    "This component is not using the latest setting information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "SiteId: " + key._siteId + "\n"
                    + "Server: " + key._server + "\n"
                    + "Component: " + key._component + "\n"
                    + "Setting: " + key._setting + "\n"
                    + "Stale Value: " + cacheLine._value + "\n"
                    + "New Value: " + cacheLine._newValue + "\n");

                cacheLine._lastEvent = DateTime.Now;
            }
        }

        private int GetMinEventInterval()
        {
            // get the minimum interval that must pass before we'll signal
            // an additional NT event for a particular stale cache line
            string minEventIntervalString = GetSettingFromDB(
                Environment,
                SiteId,
                Server,
                Component,
                Setting.config_minEventInterval);
            // GetSetting will throw if the setting is not found, we do not
            // need to check for that condition here

            // try to parse the event interval as an integer
            int minEventIntervalMilliseconds;
            try
            {
                minEventIntervalMilliseconds = Int32.Parse(minEventIntervalString);
            }
            catch (Exception e)
            {
                ApplicationException ae = new ApplicationException(
                    "Unable to parse '"
                    + minEventIntervalString
                    + "' (config_minEventInterval) as an int", e);
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_154, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            return minEventIntervalMilliseconds;
        }

        private int GetCacheRefreshInterval()
        {
            // get the interval we should check for config updates from npdb
            string cacheRefreshIntervalString = GetSettingFromDB(
                Environment,
                SiteId,
                Server,
                Component,
                Setting.config_cacheRefreshInterval);
            // GetSettingFromDB will throw if the setting is not found, we do not
            // need to check for that condition here

            // try to parse the refresh interval as an integer
            try
            {
                int cacheRefreshInterval = Int32.Parse(cacheRefreshIntervalString);
                return cacheRefreshInterval;
            }
            catch (Exception e)
            {
                ApplicationException ae = new ApplicationException(
                    "Unable to parse '"
                    + cacheRefreshIntervalString
                    + "' (config_cacheRefreshInterval) as an int", e);
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_155, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }
        }

        private void LogMinEventInterval()
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_31,
                       "The minimum interval between consecutive stale data events is set to " +
                       MinEventInterval.TotalMilliseconds + " milliseconds\n");
        }

        private void LogCacheRefreshInterval()
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_32,
                       "This component will check for updates in NPDB every " +
                       CacheRefreshInterval + " milliseconds\n");
        }

        private void RefreshSettings()
        {
            // first we should deal with any changes to the two settings
            // that this class consumes

            // we can simply refresh this one unconditionally, no muss, no fuss
            TimeSpan newMinEventInterval = new TimeSpan(0, 0, 0, 0, GetMinEventInterval());
            if (newMinEventInterval != MinEventInterval)
            {
                MinEventIntervalSet = newMinEventInterval.Milliseconds;
                LogMinEventInterval();
            }

            // get the interval we should check for config updates from npdb
            int newCacheRefreshInterval = GetCacheRefreshInterval();
            if (newCacheRefreshInterval != CacheRefreshInterval)
            {
                CacheRefreshIntervalSet = newCacheRefreshInterval;
                LogCacheRefreshInterval();
                RecreateRefreshTimer();
            }

            StringBuilder xml = new StringBuilder();

            int nSettingCount = 0;

            // First - Construct an xml that will be used for batch queries from NPDB
            foreach (DictionaryEntry de in SettingsCache)
            {
                try
                {
                    SettingsKey key = (SettingsKey) de.Key;

                    xml.AppendFormat(key.ToXmlBatchQueryFormat());
                    nSettingCount = nSettingCount + 1;
                }
                catch (Exception e)
                {
                    LogNtEvent(ConfigEvent.Id.COMMON_SETTING_BATCH_CONSTRUCTION, e.Message);
                }
            }

            Hashtable htSettingValuesInNpdb = null;

            // Second - Perform database transaction
            if (xml.Length > 0)
            {
                try
                {
                    string szXmlQuery = xml.ToString();

                    LogNtEvent(ConfigEvent.Id.COMMON_SETTING_BATCH_COUNT,
                               String.Format("Querying {0} number of setting at once from NPDB", nSettingCount));

                    htSettingValuesInNpdb = NpdbAccess.GetBatchSettingsFromDB(
                        NpdbConnectionString, 
                        Environment,
                        SiteId,
                        Server,
                        Component,
                        szXmlQuery
                        );
                }
                catch (Exception e)
                {
                    LogNtEvent(ConfigEvent.Id.COMMON_SETTING_BATCH_QUERY, e.Message);
                }
            }

            // Third - Analyze Result
            if (null != htSettingValuesInNpdb)
            {
                foreach (DictionaryEntry deResult in htSettingValuesInNpdb)
                {
                    SettingsKey key = (SettingsKey) deResult.Key;
                    SettingsCacheLine cacheLine = (SettingsCacheLine) SettingsCache[key];

                    if (null != cacheLine)
                    {
                        string value = (string) deResult.Value;

                        if (value != cacheLine._value)
                        {
                            // if the setting has changed, but Config.SettingChange is null (which means
                            // no delegates have been attached to the Event) then we can't commit
                            // this change to the cache, because we didn't get approval from the
                            // client code. So mark this cache line as dirty, log an event,
                            // and move along to the next cache line
                            if (SettingChange == null)
                            {
                                LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                                try
                                {
                                    cacheLine._dirty = true;
                                    cacheLine._newValue = value;
                                }
                                finally
                                {
                                    _rwLock.DowngradeFromWriterLock(ref lc);
                                }

                                LogSettingChangeNoHandlerEvent(key, cacheLine._value, value);
                                continue;
                            }

                            // if we get here, SettingChange is not null, so we
                            // we signal the Event to notifiy the client code of the change.
                            // first we set _approveSettingChange to true, so we can
                            // see if any of the event handlers vetoed the change
                            SettingChangeEventArgs eventArgs
                                = new SettingChangeEventArgs(
                                    key._environment,
                                    key._siteId,
                                    key._server,
                                    key._component,
                                    key._setting,
                                    cacheLine._value,
                                    value);
                            _approveSettingsChange = true;

                            // we want to wrap this in a try catch block, so if any
                            // registered handlers throw an exception we behave in
                            // a predictable fashion
                            try
                            {
                                OnSettingChange(eventArgs);
                            }
                            catch (Exception e)
                            {
                                // Log that the exception was thrown and then treat
                                // this as a rejected change
                                LogSettingChangeExceptionEvent(key, cacheLine._value, value, e);
                                _approveSettingsChange = false;
                            }

                            // if _approveSettingChange is still true, then none of the
                            // SettingChangeEventHandler delegates called VetoSettingChange,
                            // therefore we can commit the change to the cache
                            if (_approveSettingsChange)
                            {
                                LogSettingChangeAcceptedEvent(key, cacheLine._value, value);
                                cacheLine._value = value;
                            }
                            else
                            {
                                // if _approveSettingChange is now false, one or more of the
                                // SettingChangeEventHandler delegates called VetoSettingChange,
                                // therefore we should flag this cache line as dirty, and log
                                // an NT event
                                LogSettingChangeRejectedEvent(key, cacheLine._value, value);
                                cacheLine._dirty = true;
                                cacheLine._newValue = value;
                            }
                        }
                        else if (cacheLine._dirty)
                        {
                            LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                            try
                            {
                                //  In this case the values are equal but the cacheline is currently marked dirty
                                //  This means the value has been returned to its original value, clear the
                                //  dirty flag.
                                cacheLine._dirty = false;
                                cacheLine._lastEvent = DateTime.MinValue;
                                cacheLine._newValue = null;
                            }
                            finally
                            {
                                _rwLock.DowngradeFromWriterLock(ref lc);
                            }
                        }
                    }
                }
            }
        }

        private string GetSettingFromDB(
            string environment,
            int siteId,
            string server,
            string component,
            string setting)
        {
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_156,
                           ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_157,
                           ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            SettingsKey key = new SettingsKey(environment, siteId, server, component, setting);

            //this should throw exception for database issues or can't find setting
            Hashtable htSettingValue =
                NpdbAccess.GetBatchSettingsFromDB(NpdbConnectionString, environment, siteId, server, component, key.ToXmlBatchQueryFormat());

            string szValue = (string) htSettingValue[key];

            if (null == szValue)
            {
                //we did not find it - throw the same exception as we did before
                ApplicationException ae =
                    new ApplicationException("Setting '" + setting + "' not found in t_settings table in NPDB");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_158,
                           ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            return szValue;
        }

        public void RegisterDynamicSetting(string setting)
        {
            SettingChangeFilter.RegisterDynamicSetting(setting);
        }

        public void UnRegisterDynamicSetting(string setting)
        {
            SettingChangeFilter.UnRegisterDynamicSetting(setting);
        }

        // use this API to retrieve the values for a multisetting for the
        // current component on the current server
        public string[] GetMultiSetting(
            string multiSetting)
        {
            return GetMultiSettingFromCache(
                Environment,
                SiteId,
                Server,
                Component,
                multiSetting);
        }

        // this API provides a way to explicitly specify the component name
        // may be useful for shared code
        public string[] GetMultiSetting(
            string multiSetting,
            string component)
        {
            return GetMultiSettingFromCache(
                    Environment,
                    SiteId,
                    Server,
                    component,
                    multiSetting);
        }

        // this API provides a way to explicitly specify the environment, siteid, server, and component
        public string[] GetMultiSetting(
            string environment,
            int siteId,
        string server,
        string component,
        string multiSetting)
        {
            return GetMultiSettingFromCache(
                    environment,
                    siteId,
                    server,
                    component,
                    multiSetting);
        }

        // attach MultiSettingChangeEventHandler delegates to this event to be notified
        // when multi settings change in NPDB
        public event MultiSettingChangeEventHandler MultiSettingChange;
        protected void OnMultiSettingChange(MultiSettingChangeEventArgs e)
        {
            if (MultiSettingChange != null)
            {
                MultiSettingChange(null, e);
            }
        }

        // if the MultiSettingChangeEventHandler wants to veto the change, it calls
        // VetoMultiSettingChange, which sets the _approveMultiSettingChange flag to false
        private bool _approveMultiSettingChange = true;
        public void VetoMultiSettingChange()
        {
            // MultiSettingChangeEventHandlers call this method if they
            // need to indicate that the multi setting change indicated by
            // the MultiSettingChangeEventArgs should not be committed
            // to the cache
            _approveMultiSettingChange = false;
        }

        // the multisetting cache is implemented as a hashtable, where the
        // keys are MultiSettingKey objects and the values are MultiSettingCacheLine
        // objects.
        private Hashtable _multiSettingCache;
        private class MultiSettingKey : IComparable
        {
            public string _environment;
            public int _siteId;
            public string _server;
            public string _component;
            public string _multiSetting;

            public override int GetHashCode()
            {
                return unchecked(_environment.GetHashCode()
                    + _siteId.GetHashCode()
                    + _server.GetHashCode()
                    + _component.GetHashCode()
                    + _multiSetting.GetHashCode());
            }

            public override string ToString()
            {
                return _environment + ","
                    + _siteId + ","
                    + _server + ","
                    + _component + ","
                    + _multiSetting;
            }

            public override bool Equals(object o)
            {
                return (CompareTo(o) == 0);
            }

            public int CompareTo(object o)
            {
                if (typeof(MultiSettingKey) != o.GetType())
                {
                    throw new ArgumentException(
                        "Object provided to MultiSettingKey.CompareTo is not a MultiSettingKey");
                }

                MultiSettingKey key = (MultiSettingKey)o;
                int environmentCompare = String.Compare(_environment, key._environment, false, CultureInfo.InvariantCulture);
                if (environmentCompare != 0)
                {
                    return environmentCompare;
                }

                // environments are equal

                if (_siteId < key._siteId)
                {
                    return -1;
                }
                if (_siteId > key._siteId)
                {
                    return 1;
                }
                // siteids are equal

                int serverCompare = String.Compare(_server, key._server, false, CultureInfo.InvariantCulture);
                if (serverCompare != 0)
                {
                    return serverCompare;
                }

                // servers are equal

                int componentCompare = String.Compare(_component, key._component, false, CultureInfo.InvariantCulture);
                if (componentCompare != 0)
                {
                    return componentCompare;
                }

                // components are equal

                return String.Compare(_multiSetting, key._multiSetting, false, CultureInfo.InvariantCulture);
            }
        }

        private class MultiSettingCacheLine
        {
            public string[] _value;
            public bool _dirty;
            public DateTime _lastEvent;
            public string[] _newValue; // used to store the new value if the line is dirty

            public override string ToString()
            {
                return CollectionToString(_value) + ","
                    + _dirty + ","
                    + _lastEvent + ","
                    + (_newValue == null ? "<null>" : CollectionToString(_newValue));
            }
        }

        private Hashtable MultiSettingCache
        {
            get
            {
                if (_multiSettingCache != null)
                {
                    return _multiSettingCache;
                }

                _rwLock.AcquireWriterLock(_rwLockTimeout);
                try
                {
                    if (_multiSettingCache != null)
                    {
                        return _multiSettingCache;
                    }

                    _multiSettingCache = new Hashtable();

                    // make sure the timer callback has been set up
                    RefreshTimerInit();


                    return _multiSettingCache;
                }
                finally
                {
                    _rwLock.ReleaseWriterLock();
                }
            }
        }

        /*
                private string MultiSettingCacheToString()
                {
                    StringBuilder sb = new StringBuilder();

                    foreach (DictionaryEntry de in MultiSettingCache)
                    {
                        MultiSettingKey key = (MultiSettingKey)de.Key;
                        MultiSettingCacheLine cacheLine = (MultiSettingCacheLine)de.Value;

                        sb.Append(key.ToString());
                        sb.Append(":");
                        sb.Append(cacheLine.ToString());
                        sb.Append("\n");
                    }

                    return sb.ToString();
                }
        */

        private string[] GetMultiSettingFromCache(
            string environment,
            int siteId,
            string server,
            string component,
            string multiSetting)
        {
            // validate parameters
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_161, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_162, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // check the cache for the requested multi setting
            MultiSettingKey key = new MultiSettingKey();
            key._environment = environment;
            key._siteId = siteId;
            key._server = server;
            key._component = component;
            key._multiSetting = multiSetting;

            if (MultiSettingCache.ContainsKey(key))
            {
                MultiSettingCacheLine cacheLine = (MultiSettingCacheLine)MultiSettingCache[key];

                // if this cache line is dirty, we should consider logging an NT event
                if (cacheLine._dirty)
                {
                    LogStaleMultiSettingEvent(key, cacheLine);
                }

                // we've done our duty and notified ops that this process is using
                // stale config data, so return the stale data and get on with it
                return cacheLine._value;
            }

            // if we get here, the multi setting was not found in the cache,
            // so get it from the database and add it to the cache
            string[] value = GetMultiSettingFromDB(
                environment,
                siteId,
                server,
                component,
                multiSetting);

            MultiSettingCacheLine newCacheLine = new MultiSettingCacheLine();

            newCacheLine._value = value;
            newCacheLine._dirty = false;

            // set the last event time to a valid time that's far enough in the
            // past to guarantee that if the line gets dirty, we'll log the
            // event the first time
            newCacheLine._lastEvent = DateTime.MinValue;

            // save the line in the cache
            lock (MultiSettingCache)
            {
                MultiSettingCache[key] = newCacheLine;
            }

            return value;
        }

        private void RefreshMultiSettings()
        {
            // for each line in the multi settings cache,
            // requery that multi setting from NPDB
            foreach (DictionaryEntry de in MultiSettingCache)
            {
                // requery for the multi setting from the database
                MultiSettingKey key = (MultiSettingKey)de.Key;
                string[] value = GetMultiSettingFromDB(
                    key._environment,
                    key._siteId,
                    key._server,
                    key._component,
                    key._multiSetting);
                // GetMultiSetting will throw if the multisetting does not exist

                // has the multisetting changed?
                MultiSettingCacheLine cacheLine = (MultiSettingCacheLine)de.Value;
                if (!CollectionEquals(value, cacheLine._value))
                {
                    // if the multi setting has changed, but Config.MultiSettingChange is null (which means
                    // no delegates have been attached to the Event) then we can't commit
                    // this change to the cache, because we didn't get approval from the
                    // client code. So mark this cache line as dirty, log an event,
                    // and move along to the next cache line
                    if (MultiSettingChange == null)
                    {
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                        LogMultiSettingChangeNoHandlerEvent(key, cacheLine._value, value);
                        continue;
                    }

                    // if we get here, MultiSettingChange is not null, so we
                    // we signal the Event to notifiy the client code of the change.
                    // first we set _approveMultiSettingChange to true, so we can
                    // see if any of the event handlers vetoed the change
                    MultiSettingChangeEventArgs eventArgs
                        = new MultiSettingChangeEventArgs(
                            key._environment,
                            key._siteId,
                            key._server,
                            key._component,
                            key._multiSetting,
                            cacheLine._value,
                            value);
                    _approveMultiSettingChange = true;

                    // we want to wrap this in a try catch block, so if any
                    // registered handlers throw an exception we behave in
                    // a predictable fashion
                    try
                    {
                        OnMultiSettingChange(eventArgs);
                    }
                    catch (Exception e)
                    {
                        // Log that the exception was thrown and then treat
                        // this as a rejected change
                        LogMultiSettingChangeExceptionEvent(key, cacheLine._value, value, e);
                        _approveMultiSettingChange = false;
                    }

                    // if _approveMultiSettingChange is still true, then none of the
                    // MultiSettingChangeEventHandler delegates called VetoSettingChange,
                    // therefore we can commit the change to the cache
                    if (_approveMultiSettingChange)
                    {
                        LogMultiSettingChangeAcceptedEvent(key, cacheLine._value, value);
                        cacheLine._value = value;
                    }
                    else
                    {
                        // if _approveMultiSettingChange is now false, one or more of the
                        // MultiSettingChangeEventHandler delegates called VetoMultiSettingChange,
                        // therefore we should flag this cache line as dirty, and log
                        // an NT event
                        LogMultiSettingChangeRejectedEvent(key, cacheLine._value, value);
                        cacheLine._dirty = true;
                        cacheLine._newValue = value;
                    }
                }
                else if (cacheLine._dirty)
                {
                    //  In this case the values are equal but the cacheline is currently marked dirty
                    //  This means the value has been returned to its original value, clear the
                    //  dirty flag.
                    cacheLine._dirty = false;
                    cacheLine._lastEvent = DateTime.MinValue;
                    cacheLine._newValue = null;
                }
            }
        }

        private void LogMultiSettingChangeAcceptedEvent(
            MultiSettingKey key,
            string[] oldValue,
            string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_INFO_33,
                "A multisetting change has been accepted by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "MultiSetting: " + key._multiSetting + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogMultiSettingChangeRejectedEvent(
            MultiSettingKey key,
            string[] oldValue,
            string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_163,
                "A multisetting change has been rejected by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "MultiSetting: " + key._multiSetting + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogMultiSettingChangeNoHandlerEvent(
            MultiSettingKey key,
            string[] oldValue,
            string[] newValue)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_164,
                "A multisetting change event was not handled by this component (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "MultiSetting: " + key._multiSetting + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n");
        }

        private void LogMultiSettingChangeExceptionEvent(
            MultiSettingKey key,
            string[] oldValue,
            string[] newValue,
            Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_165,
                "A multisetting change handler threw an exception! (details below)\n"
                + "Environment: " + key._environment + "\n"
                + "SiteId: " + key._siteId + "\n"
                + "Server: " + key._server + "\n"
                + "Component: " + key._component + "\n"
                + "MultiSetting: " + key._multiSetting + "\n"
                + "Old Value: " + CollectionToString(oldValue) + "\n"
                + "New Value: " + CollectionToString(newValue) + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogStaleMultiSettingEvent(
            MultiSettingKey key,
            MultiSettingCacheLine cacheLine)
        {
            // check to see how long ago we logged an event about this setting
            if ((DateTime.Now - cacheLine._lastEvent) >= MinEventInterval)
            {
                // time for another event!
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_166,
                    "This component is not using the latest multisetting information from NPDB (details below)\n"
                    + "Operator action may be required. Please investigate!\n"
                    + "Note: This event will not be logged again for this particular problem until at least "
                    + MinEventInterval.TotalMilliseconds
                    + " milliseconds have elapsed\n"
                    + "Environment: " + key._environment + "\n"
                    + "SiteId: " + key._siteId + "\n"
                    + "Server: " + key._server + "\n"
                    + "Component: " + key._component + "\n"
                    + "MultiSetting: " + key._multiSetting + "\n"
                    + "Stale Value: " + CollectionToString(cacheLine._value) + "\n"
                    + "New Value: " + CollectionToString(cacheLine._newValue) + "\n");

                // remember the current time...
                LockCookie lc = _rwLock.UpgradeToWriterLock(_rwLockTimeout);
                try
                {
                    cacheLine._lastEvent = DateTime.Now;
                }
                finally
                {
                    _rwLock.DowngradeFromWriterLock(ref lc);
                }
            }
        }


        // all the other GetSetting methods call this one to do the real work
        private string[] GetMultiSettingFromDB(
            string environment,
            int siteId,
            string server,
            string component,
            string multiSetting)
        {
            // server is allowed to be null - which simply indicates that the caller is not
            // running on a server that is listed in the xml file, but we have to be
            // given an environment
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_167, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // unlike regular settings, multisettings are allowed to exist as a name but
            // have no values assigned to them. i.e. the list of values assigned to a multisetting
            // is allowed to be zero length. Therefore, we approach multisettings in the opposite
            // way we approach settings. First we look for the most specific overrides, working
            // our way back to the default values. If no values were specified at any level, then
            // we return a zero length array of strings.
            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                // Because there may be multiple rows that apply to this component, on this server
                // in this site, we need some precedence rules. vc_component is considered the
                // most significant field, since it is the most granular, followed by
                // vc_server, then i_site_id.
                //
                // The table below show the 8 possible rows returned by p_config_get_setting_overrides
                // in order from higest to lowest precedence.
                //
                // i_site_id,  vc_server,  vc_component
                // <match>,     <match>,    <match>
                // -1,          <match>,    <match>
                // <match>,     ALL,        <match>
                // -1,          ALL,        <match>
                // <match>,     <match>,    ALL
                // -1,          <match>,    ALL
                // <match>,     ALL,        ALL
                // -1,          ALL,        ALL
                //
                // The code below loops through any rows returned, and applies the precedence in
                // the chart above. The most significant result is returned.
                //
                // The stored proc is basically returning 8 possible sets of values, all mixed together.
                // To fix this, we examine each one, and decide which of the 8 sets the row is part of
                // and add it to an ArrayList for that set. Once we've processed all the rows, we
                // find the non-empty set with the highest precedence and return that, if
                // any rows were returned.
                ArrayList matchedComponentServerSite = new ArrayList();
                ArrayList matchedComponentServer = new ArrayList();
                ArrayList matchedComponentSite = new ArrayList();
                ArrayList matchedComponent = new ArrayList();
                ArrayList matchedServerSite = new ArrayList();
                ArrayList matchedServer = new ArrayList();
                ArrayList matchedSite = new ArrayList();
                ArrayList matchedNone = new ArrayList();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_multisetting_overrides";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = siteId;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server ?? "ALL";
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multiSetting;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            int siteOverride = (Int32) reader["i_site_id"];
                            string serverOverride = ((string) reader["vc_server"]).ToUpper();
                            string componentOverride = (string) reader["vc_component"];
                            string value = (string) reader["vc_value"];

                            if (componentOverride == "ALL")
                            {
                                if (serverOverride == "ALL")
                                {
                                    if (siteOverride == -1)
                                    {
                                        matchedNone.Add(value);
                                    }
                                    else
                                    {
                                        matchedSite.Add(value);
                                    }
                                }
                                else
                                {
                                    if (siteOverride == -1)
                                    {
                                        matchedServer.Add(value);
                                    }
                                    else
                                    {
                                        matchedServerSite.Add(value);
                                    }
                                }
                            }
                            else
                            {
                                if (serverOverride == "ALL")
                                {
                                    if (siteOverride == -1)
                                    {
                                        matchedComponent.Add(value);
                                    }
                                    else
                                    {
                                        matchedComponentSite.Add(value);
                                    }
                                }
                                else
                                {
                                    if (siteOverride == -1)
                                    {
                                        matchedComponentServer.Add(value);
                                    }
                                    else
                                    {
                                        matchedComponentServerSite.Add(value);
                                    }
                                }
                            }
                        }
                    }
                }

                // walk through the ArrayLists in order from highest to
                // lowest precedence. Return the first one to contain any
                // values, if any.
                ArrayList values = null;
                if (matchedComponentServerSite.Count > 0)
                {
                    values = matchedComponentServerSite;
                }
                else if (matchedComponentServer.Count > 0)
                {
                    values = matchedComponentServer;
                }
                else if (matchedComponentSite.Count > 0)
                {
                    values = matchedComponentSite;
                }
                else if (matchedComponent.Count > 0)
                {
                    values = matchedComponent;
                }
                else if (matchedServerSite.Count > 0)
                {
                    values = matchedServerSite;
                }
                else if (matchedServer.Count > 0)
                {
                    values = matchedServer;
                }
                else if (matchedSite.Count > 0)
                {
                    values = matchedSite;
                }
                else if (matchedNone.Count > 0)
                {
                    values = matchedNone;
                }

                // if values is not null, then we have a hit, so return it
                if (values != null)
                {
                    string[] valuesArray = new string[values.Count];
                    values.CopyTo(valuesArray);
                    return valuesArray;
                }

                // if we get here, then there was no applicable data in the
                // t_multisetting_overrides table, so next we check
                // t_environment_type_multisetting_overrides
                cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_environment_type_multisetting_override";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multiSetting;

                ArrayList envTypeValues = new ArrayList();
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            // we have an environment type override, so use it
                            // vc_value is declared as not null
                            envTypeValues.Add(reader["vc_value"]);
                        }
                    }
                }

                // if envTypeValues is not zero length, then we have a hit, so return it
                if (envTypeValues.Count > 0)
                {
                    string[] valuesArray = new string[envTypeValues.Count];
                    envTypeValues.CopyTo(valuesArray);
                    return valuesArray;
                }

                // finally check the t_multisettings table
                cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_multisetting";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multiSetting;

                ArrayList defaultValues = new ArrayList();
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            // we have an environment type override, so use it
                            // vc_value is declared as not null
                            defaultValues.Add(reader["vc_value"]);
                        }
                    }
                }

                // if defaultValues is not null, then we have a hit, so return it
                if (defaultValues.Count != 0)
                {
                    string[] valuesArray = new string[defaultValues.Count];
                    defaultValues.CopyTo(valuesArray);
                    return valuesArray;
                }
            }

            // if we get here, then there were no applicable multisetting rows
            // anywhere, so return a zero length array
            return new string[0];
        }

        // the following methods are intended for use by Setup and not services
        public string[] GetInstallUnitListByServer(
            string server)
        {
            return GetInstallUnitListByServer(Environment, server);
        }

        public InstallUnitInfo[] GetInstallUnitInfoByServer(
            string server)
        {
            throw new Exception("not yet implemented");
        }

        public string[] GetInstallUnitListByServer(
            string environment,
            string server)
        {
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_168, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }
            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_169, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            ArrayList installUnitList = new ArrayList();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_install_unit_list_by_server";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            string installUnitString = (string) reader["vc_install_unit"];

                            // add it to the list
                            installUnitList.Add(installUnitString);
                        }
                    }
                }
            }

            installUnitList.Sort();

            string[] installUnits = new string[installUnitList.Count];
            installUnitList.CopyTo(installUnits);
            return installUnits;
        }

        public InstallUnitInfo[] GetInstallUnitInfoByServer(
            string environment,
            string server)
        {
            throw new Exception("not yet implemented");
        }

        public IInstallUnitInfo GetInstallUnit(string installUnit)
        {
            // default constructor inits everything to null
            InstallUnitInfo installUnitInfo = new InstallUnitInfo();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_install_unit";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_install_unit", SqlDbType.NVarChar).Value = installUnit;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if(reader != null)
                    {
                        if (!reader.Read())
                        {
                            ApplicationException ae =
                                new ApplicationException("install unit " + installUnit + " not found in npdb");
                            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_171,
                                       ae + "\n" + System.Environment.StackTrace);
                            throw ae;
                        }

                        if (reader["vc_info1"] != DBNull.Value)
                        {
                            installUnitInfo.Info1 = (string)reader["vc_info1"];
                        }
                        if (reader["vc_info2"] != DBNull.Value)
                        {
                            installUnitInfo.Info2 = (string)reader["vc_info2"];
                        }
                        if (reader["vc_info3"] != DBNull.Value)
                        {
                            installUnitInfo.Info3 = (string)reader["vc_info3"];
                        }
                        if (reader["vc_info4"] != DBNull.Value)
                        {
                            installUnitInfo.Info4 = (string)reader["vc_info4"];
                        }
                    }
                }
            }

            return installUnitInfo;
        }

        public string[] GetComponentListByServer(
            string server)
        {
            return GetComponentListByServer(Environment, server);
        }

        public ComponentInfo[] GetComponentInfoByServer(
            string server)
        {
            throw new Exception("not yet implemented");
        }

        public string[] GetComponentListByServer(
            string environment,
            string server)
        {
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_172, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }
            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_173, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            SortedList componentList = new SortedList();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_component_list_by_server";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            string component = (string) reader["vc_component"];

                            // add it to the list, use the string value as the
                            // key so we get the list in alphabetical order
                            componentList.Add(component, component);
                        }
                    }
                }
            }

            // convert the sorted list to an array of Components
            string[] components = new string[componentList.Count];
            componentList.Values.CopyTo(components, 0);
            return components;
        }


        public bool CheckServerConfiguration(string environment, string server, string component)
        {
            bool hasComponent = false;

            if (String.IsNullOrEmpty(server))
            {
                throw new ArgumentException("Server parameter cannot be empty. Current value - {0} ", server);
            }

            if (String.IsNullOrEmpty(environment))
            {
                throw new ArgumentException("Environment parameter cannot be empty. Current value - {0} ", environment);
            }

            //Get the list of components for the Server, Environment
            string[] components = GetComponentListByServer(environment, server);


            //If component param is empty, we dont check the entries. We just check to make sure the Server has atleast one component.
            if ((string.IsNullOrEmpty(component)) || (String.Compare(component, ".", true) == 0))
            {
                if (components.Length > 0)
                {
                    hasComponent = true;
                }
            }
            else
            {

                for (int i = 0; i < components.Length; i++)
                {
                    //Console.WriteLine(" \t {0}, {1} , {2} ", environment, server, aComponent);
                    string aComponent = components[i];
                    if (String.Equals(aComponent, component, StringComparison.CurrentCultureIgnoreCase))
                    {
                        hasComponent = true;
                        break;
                    }
                }
            }

            return hasComponent;
        }

        public ComponentInfo[] GetComponentInfoByServer(
            string environment,
            string server)
        {
            throw new Exception("not yet implemented");
        }

        private bool ComponentExists(string component)
        {
            if (component == config.Component.unknown)
            {
                ArgumentException ae = new ArgumentException("Component.unknown cannot be passed to Config.ComponentExists", "component");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_175, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_component";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    return reader == null ? false : reader.Read();
                }
            }
        }

        public IComponentInfo GetComponent(string component)
        {
            if (component == config.Component.unknown)
            {
                ArgumentException ae =
                    new ArgumentException("Component.unknown cannot be passed to Config.GetComponent", "component");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_175, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            // default constructor inits everything to null or invalid values
            ComponentInfo componentInfo = new ComponentInfo();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_config_get_component";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader == null || !reader.Read())
                    {
                        ArgumentException ae =
                            new ArgumentException("component " + component + " not found in npdb");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_176,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    if (reader["vc_executable"] != DBNull.Value)
                    {
                        componentInfo.Executable = (string)reader["vc_executable"];
                    }
                    if (reader["vc_installer"] != DBNull.Value)
                    {
                        string installerString = (string)reader["vc_installer"];
                        try
                        {
                            componentInfo.Installer = (Installer)Enum.Parse(typeof(Installer), installerString);
                        }
                        catch (ArgumentException)
                        {
                            // this may be a new installer type that was added after this
                            // component was created, map it to "unspecified" and warn
                            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_177,
                                       "Installer of '" + installerString +
                                       "' returned by p_config_get_component " +
                                       "is not recognized by this component and will be ignored.");
                            componentInfo.Installer = Installer.unspecified;
                        }
                    }
                    if (reader["vc_username"] != DBNull.Value)
                    {
                        componentInfo.Username = (string)reader["vc_username"];
                        componentInfo.Username =
                            componentInfo.Username.Replace("%COMPUTERNAME%", System.Environment.MachineName);
                    }
                    if (reader["vc_password"] != DBNull.Value)
                    {
                        componentInfo.Password = (string)reader["vc_password"];
                    }
                    if (reader["vc_info1"] != DBNull.Value)
                    {
                        componentInfo.Info1 = (string)reader["vc_info1"];
                    }
                    if (reader["vc_info2"] != DBNull.Value)
                    {
                        componentInfo.Info2 = (string)reader["vc_info2"];
                    }
                }
            }

            return componentInfo;
        }

        public string[] GetInterfaceListByServer(
            string server)
        {
            return GetInterfaceListByServer(Environment, server);
        }

        public InterfaceInfo[] GetInterfaceInfoByServer(
            string server)
        {
            throw new Exception("not yet implemented");
        }

        public string[] GetInterfaceListByServer(
            string environment,
            string server)
        {
            if (environment == null)
            {
                ArgumentNullException ae = new ArgumentNullException("environment");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_178, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }
            if (server == null)
            {
                ArgumentNullException ae = new ArgumentNullException("server");
                LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_179, ae + "\n" + System.Environment.StackTrace);
                throw ae;
            }

            SortedList interfaceList = new SortedList();

            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_interface_list_by_server";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader != null)
                    {
                        while (reader.Read())
                        {
                            string interfaceString = (string) reader["vc_interface"];

                            // add it to the list
                            interfaceList.Add(interfaceString, interfaceString);
                        }
                    }
                }
            }

            // convert the sorted list to an array
            string[] interfaces = new string[interfaceList.Count];
            interfaceList.Values.CopyTo(interfaces, 0);
            return interfaces;
        }

        // also used by SG, in addition to setup
        public InterfaceInfo[] GetInterfaceInfoByServer(
            string environment,
            string server)
        {
            throw new Exception("not yet implemented");
        }

        // attach GameConfigChangeEventHandler delegates to this event to be notified
        // when t_game_config is modified in NPDB
        public event GameConfigChangeEventHandler GameConfigChange;
        protected void OnGameConfigChange(EventArgs e)
        {
            if (GameConfigChange != null)
            {
                GameConfigChange(null, e);
            }
        }

        private void RefreshGameConfig()
        {
            LogGameConfigChangeEvent();
            try
            {
                OnGameConfigChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogGameConfigChangeExceptionEvent(e);
            }
        }

        private void LogGameConfigChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_INFO_34,
            //    "This component has been notified of a change to t_game_config in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogGameConfigChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_181,
                "A game config change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        // attach XdelaySettingsChangeEventHandler delegates to this event to be notified
        // when t_xdelay_settings is modified in NPDB
        public event XdelaySettingsChangeEventHandler XdelaySettingsChange;
        protected void OnXdelaySettingsChange(EventArgs e)
        {
            if (XdelaySettingsChange != null)
            {
                XdelaySettingsChange(null, e);
            }
        }

        private void RefreshXDelaySettings()
        {
            LogXdelaySettingsChangeEvent();
            try
            {
                OnXdelaySettingsChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogXdelaySettingsChangeExceptionEvent(e);
            }
        }

        private void LogXdelaySettingsChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_INFO_35,
            //    "This component has been notified of a change to t_xdelay_settings in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogXdelaySettingsChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_182,
                "An xdelay settings change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        // attach XrlMappingsChangeEventHandler delegates to this event to be notified
        // when t_xdelay_settings is modified in NPDB
        public event XrlMappingsChangeEventHandler XrlMappingsChange;
        protected void OnXrlMappingsChange(EventArgs e)
        {
            if (XrlMappingsChange != null)
            {
                XrlMappingsChange(null, e);
            }
        }

        private void RefreshXrlMappings()
        {
            LogXrlMappingsChangeEvent();
            try
            {
                OnXrlMappingsChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogXrlMappingsChangeExceptionEvent(e);
            }
        }

        private void LogXrlMappingsChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_INFO_36,
            //    "This component has been notified of a change to t_xrl_virtual_interface_mappings in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogXrlMappingsChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_183,
                "An xrl mappings change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        // attach HealthMappingsChangeEventHandler delegates to this event to be notified
        // when t_health_mappings is modified in NPDB
        public event HealthMappingsChangeEventHandler HealthMappingsChange;
        protected void OnHealthMappingsChange(EventArgs e)
        {
            if (HealthMappingsChange != null)
            {
                HealthMappingsChange(null, e);
            }
        }

        private void RefreshHealthMappings()
        {
            LogHealthMappingsChangeEvent();
            try
            {
                OnHealthMappingsChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogHealthMappingsChangeExceptionEvent(e);
            }
        }

        private void LogHealthMappingsChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_HEALTH_CHANGE,
            //    "This component has been notified of a change to t_health_mappings in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogHealthMappingsChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_HEALTH_CHANGE,
                "A health mappings change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        #region Config Blob Refresh

        protected void RefreshConfigBlobs()
        {
            LogConfigBlobsChangeEvent();
            try
            {
                OnConfigBlobsChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                LogConfigBlobsChangeExceptionEvent(e);
            }
        }

        private void LogConfigBlobsChangeEvent()
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_CONFIG_BLOBS_CHANGE,
                "This component has been notified of a change to t_config_blobs in NPDB\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n");
        }

        private void LogConfigBlobsChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_CONFIG_BLOBS_CHANGE,
                "A config_blobs change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n"
                );
        }

        public virtual event ConfigBlobChangeEventHandler ConfigBlobChange;

        protected void OnConfigBlobsChange(EventArgs e)
        {
            if (ConfigBlobChange != null)
            {
                ConfigBlobChange(null, e);
            }
        }

        #endregion

        #region ETX Manifest Refresh

        protected void RefreshEtxManifest()
        {
            LogEtxManifestChangeEvent();
            try
            {
                OnEtxManifestChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                LogEtxManifestChangeExceptionEvent(e);
            }
        }

        private void LogEtxManifestChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_ETX_MANIFEST_CHANGE,
            //    "This component has been notified of a change to the etx manifest in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogEtxManifestChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_ETX_MANIFEST_CHANGE,
                "A etx manifest change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                );
        }

        public virtual event EtxManifestChangeEventHandler EtxManifestChange;

        protected void OnEtxManifestChange(EventArgs e)
        {
            if (EtxManifestChange != null)
            {
                EtxManifestChange(null, e);
            }
        }

        #endregion

        // attach LiveRegistrySettingsChangeEventHandler delegates to this event to be notified
        // when t_live_registry_settings is modified in NPDB
        public event LiveRegistrySettingsChangeEventHandler LiveRegistrySettingsChange;
        protected void OnLiveRegistrySettingsChange(EventArgs e)
        {
            if (LiveRegistrySettingsChange != null)
            {
                LiveRegistrySettingsChange(null, e);
            }
        }

        private void RefreshLiveRegistrySettings()
        {
            LogLiveRegistrySettingsChangeEvent();
            try
            {
                OnLiveRegistrySettingsChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogLiveRegistrySettingsChangeExceptionEvent(e);
            }
        }

        private void LogLiveRegistrySettingsChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_LIVE_REGISTRY_SETTINGS_CHANGE,
            //    "This component has been notified of a change to t_live_registry_settings in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogLiveRegistrySettingsChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_LIVE_REGISTRY_SETTINGS_CHANGE,
                "A live_registry_settings change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        // attach ServiceKeysChangeEventHandler delegates to this event to be notified
        // when t_service_keys is modified in NPDB
        public event ServiceKeysChangeEventHandler ServiceKeysChange;
        protected void OnServiceKeysChange(EventArgs e)
        {
            if (ServiceKeysChange != null)
            {
                ServiceKeysChange(null, e);
            }
        }

        private void RefreshServiceKeys()
        {
            LogServiceKeysChangeEvent();

            try
            {
                OnServiceKeysChange(EventArgs.Empty);
            }
            catch (Exception e)
            {
                // note the exception was thrown
                LogServiceKeysChangeExceptionEvent(e);
            }
        }

        private void LogServiceKeysChangeEvent()
        {
            //LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_INFO_SERVICE_KEYS_CHANGE,
            //    "This component has been notified of a change to t_service_keys in NPDB\n"
            //    + "Environment: " + Environment + "\n"
            //    + "SiteId: " + SiteId + "\n"
            //    + "Server: " + Server + "\n"
            //    + "Component: " + Component + "\n");
        }

        private void LogServiceKeysChangeExceptionEvent(Exception e)
        {
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_SERVICE_KEYS_CHANGE,
                "A service keys change handler threw an exception! (details below)\n"
                + "Environment: " + Environment + "\n"
                + "SiteId: " + SiteId + "\n"
                + "Server: " + Server + "\n"
                + "Component: " + Component + "\n"
                + "Exception Message: " + e.Message + "\n"
                + "Exception Stack Trace: " + e.StackTrace + "\n");
        }

        private void LogNtEvent(ConfigEvent.Id eventId, string message)
        {
            if (HandleLogEvent != null)
            {
                HandleLogEvent((uint)eventId, message, ComponentName);
            }
            else
            {
                LogNtEvent(ComponentName, message, eventId);
            }
        }

        public static string CollectionToString(ICollection items)
        {
            if (items == null)
            {
                return "<null>";
            }

            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            foreach (Object o in items)
            {
                sb.Append(o.ToString());
                sb.Append(",");
            }
            // pop the last "," off the string, but only if there
            // was at least one element in the collection
            if (items.Count > 0)
            {
                sb.Remove(sb.Length - 1, 1);
            }
            sb.Append("}");
            return sb.ToString();
        }

        // note: do not use this method with a type of collection where
        // order is not deterministic. This method considers two collections
        // equal if, when you enumerate through each collection in lockstep,
        // each element of the collection compares equal. This will work fine
        // for objects of type Array, ArrayList, SortedList, Queue, and any
        // other class that implements ICollection where the order is 
        // deterministic in some fashion. For example, you may find that the
        // results of this method are unpredictable when used on Hashtable objects
        private static bool CollectionEquals(ICollection items1, ICollection items2)
        {
            // if both are null, then they are considered equal
            if (items1 == null && items2 == null)
            {
                return true;
            }

            // if either one by itself is null, they are not considered equal
            if (items1 == null || items2 == null)
            {
                return false;
            }

            // if they are not the same size, they are not considered equal
            if (items1.Count != items2.Count)
            {
                return false;
            }

            // if each corresponding element does compare equal (according to Object.Equals)
            // note, since we've already checked the length, this loop assumes the lengths
            // are equal
            IEnumerator enum1 = items1.GetEnumerator();
            IEnumerator enum2 = items2.GetEnumerator();
            while (enum1.MoveNext())
            {
                enum2.MoveNext();
                if (!enum1.Current.Equals(enum2.Current))
                {
                    return false;
                }
            }

            // if we get here, all the elements matched, so the collections are considered equal
            return true;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="server"></param>
        /// <param name="iface"></param>
        public void AddServerInterfaceConfiguration(
            string environment,
            string server,
            string iface)
        {
            //Parameter Validation
            ValidateParameterIsNull(environment, "environment", ConfigEvent.Id.COMMON_CONFIG_107);
            ValidateParameterIsNull(server, "server", ConfigEvent.Id.COMMON_CONFIG_108);
            ValidateParameterIsNull(iface, "interface", ConfigEvent.Id.COMMON_CONFIG_108);


            if (iface != "-")
            {
                //Inputs can be ; delimited
                char[] seperator = new char[] { ';' };
                string[] servers = server.Split(seperator, StringSplitOptions.RemoveEmptyEntries);
                string[] interfaces = iface.Split(seperator, StringSplitOptions.RemoveEmptyEntries);

                foreach (string aServer in servers)
                {
                    foreach (string anInterface in interfaces)
                    {
                        AddSingleServerInterface(environment, aServer, anInterface);
                    }
                }
            }
        }

        private void AddSingleServerInterface(string environment, string server, string iface)
        {
            //Check the cache if the (environment, server, iface) combo exists already
            // Issue: GetInterfaceFromDB() will THROW exception if there is no NPDB entry for that "interface on the given server"
            try
            {
                GetInterface(environment, server, iface);
            }
            catch (ApplicationException ae)
            {
                if (ae.Message.Contains("not present on server"))
                {
                    //If NOT EXIST - Create t-server_interface cache.

                    //Add entry in t_server_interfaces
                    IInterfaceInfo interfaceInfo = AddServerInterfaceToDB(environment, server, iface);

                    //Add to InterfaceCache
                    InterfaceKey key = new InterfaceKey(environment, server, iface);
                    AddToInterfaceCache(key, interfaceInfo);
                }
                else
                {
                    //Some other error, so just bubble it up
                    throw new ApplicationException(String.Format("Unable to add configuration for interface {0} on server {1}", iface, server)
                                                    , ae);
                }
            }
            return;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="server"></param>
        /// <param name="iface"></param>
        public void RemoveServerInterfaceConfiguration(string environment,
            string server,
        string iface)
        {

            //Parameter Validation
            ValidateParameterIsNull(environment, "environment", ConfigEvent.Id.COMMON_CONFIG_107);
            ValidateParameterIsNull(server, "server", ConfigEvent.Id.COMMON_CONFIG_108);
            ValidateParameterIsNull(iface, "interface", ConfigEvent.Id.COMMON_CONFIG_108);


            if (iface == "-") return;

            //Inputs can be ; delimited
            char[] separator = new char[] { ';' };
            string[] servers = server.Split(separator, StringSplitOptions.RemoveEmptyEntries);
            string[] interfaces = iface.Split(separator, StringSplitOptions.RemoveEmptyEntries);

            foreach (string aServer in servers)
            {
                foreach (string anInterface in interfaces)
                {
                    RemoveSingleServerInterface(environment, aServer, anInterface);
                }
            }
        }


        private void RemoveSingleServerInterface(string environment, string server, string iface)
        {

            //Currently checks are done in the sproc
            //Check if Interface exists
            //Check if Server exists

            // Ignoring

            //Check the cache if the (environment, server, iface) combo exists already. If not GetInterface() throws exception
            //IInterfaceInfo interfaceInfo = GetInterface(environment, server, iface);

            //if (interfaceInfo != null)
            {
                //Remove From DB
                RemoveServerInterfaceFromDB(environment, server, iface);

                //Remove from Cache
                InterfaceKey key = new InterfaceKey(environment, server, iface);
                RemoveFromInterfaceCache(key);
            }


        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="userrole"></param>
        /// <returns></returns>
        public IUserRole GetUserRole(string userrole)
        {
            return GetUserRole(Environment, userrole);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="userrole"></param>
        /// <returns></returns>
        public IUserRole GetUserRole(string environment, string userrole)
        {
            using (SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString))
            {
                npdbConnection.Open();

                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd.CommandText = "p_config_get_user_role";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_user_role", SqlDbType.NVarChar).Value = userrole;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader == null || !reader.Read())
                    {
                        ApplicationException ae =
                            new ApplicationException("user role " + userrole + " not found in npdb");
                        LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_171,
                                   ae + "\n" + System.Environment.StackTrace);
                        throw ae;
                    }

                    UserRole role = new UserRole();

                    role.Name = (string) reader["vc_user_role"];

                    if (reader["vc_username"] != DBNull.Value)
                    {
                        String userName = (string) reader["vc_username"];
                        role.FullUsername = userName.Replace("%COMPUTERNAME%", System.Environment.MachineName);
                    }
                    if (reader["vc_password"] != DBNull.Value)
                    {
                        role.Password = (string) reader["vc_password"];
                    }

                    return role;
                }
            }
        }

        #region Parameter Validation


        private void ValidateParameterIsNull(string value, string description, ConfigEvent.Id eventId)
        {
            if (value == null)
            {
                ArgumentNullException e = new ArgumentNullException(description);
                LogNtEvent(eventId, e + "\n" + System.Environment.StackTrace);
                throw e;
            }
        }

        #endregion Parameter Validation


        #region Data Access Methods


        private SqlDataReader GetServerInterfaceOverrides(SqlConnection npdbConnection, string server, string iface)
        {
            SqlCommand cmd = npdbConnection.CreateCommand();
            cmd.CommandText = "p_config_get_server_interface_overrides";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
            cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;
            cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = iface;
            SqlDataReader reader = cmd.ExecuteReader();

            return reader;
        }

        private SqlDataReader GetEnvironmentInterfaceOverrides(SqlConnection npdbConnection, string iface)
        {
            SqlCommand cmd = npdbConnection.CreateCommand();
            cmd.CommandText = "p_config_get_environment_interface_overrides";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
            cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = iface;
            SqlDataReader reader = cmd.ExecuteReader();

            return reader;
        }

        private SqlDataReader GetEnvironmentTypeInterfaceOverrides(SqlConnection npdbConnection, string iface)
        {
            SqlCommand cmd = npdbConnection.CreateCommand();
            cmd.CommandText = "p_config_get_environment_type_interface_overrides";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Environment;
            cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = iface;
            SqlDataReader reader = cmd.ExecuteReader();

            return reader;
        }


        private static SqlDataReader AddServerInterface(SqlConnection npdbConnection, string environment, string server, string iface)
        {
            SqlCommand cmd = npdbConnection.CreateCommand();
            cmd.CommandText = "p_config_add_server_interface";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = environment;
            cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = server;
            cmd.Parameters.Add("@interface", SqlDbType.NVarChar).Value = iface;
            SqlDataReader reader = cmd.ExecuteReader();

            return reader;
        }

        private static void RemoveServerInterface(SqlConnection npdbConnection, string environment, string server, string iface)
        {
            SqlCommand cmd = npdbConnection.CreateCommand();
            cmd.CommandText = "p_config_remove_server_interface";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = environment;
            cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = server;
            cmd.Parameters.Add("@interface", SqlDbType.NVarChar).Value = iface;
            cmd.ExecuteNonQuery();
        }

        #endregion Data Access Methods


#if TEST
    private Hashtable _overrides = new Hashtable();

    public void SetSingleInterface(string iface, IInterfaceInfo info)
    {
        string[] servers = GetServerListByInterface(iface);
        if (servers.Length == 0)
        {
            ApplicationException ae = new ApplicationException("Could not find Interface '"
                + iface.ToString()
                + "' on any Server");
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_184, ae +"\n" + System.Environment.StackTrace);
            throw ae;
        }
        if (servers.Length > 1)
        {
            ApplicationException ae = new ApplicationException("More than one Server was found exposing Interface '"
                + iface.ToString()
                + "' when only one was expected");
            LogNtEvent(ConfigEvent.Id.COMMON_CONFIG_185, ae +"\n" + System.Environment.StackTrace);
            throw ae;
        }

        SetInterface(servers[0], iface, info);
    }

    public void SetInterface(string server, string iface, IInterfaceInfo info)
    {
        _overrides[server + "_" + iface.ToString()] = info;
    }
#endif

    }
} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastQueue.cs ===
using System;
using System.Threading;

namespace STF.common.service
{
    public class FastQueue
    {
        
        public FastQueue(int size) : this(size, true) {}
        public FastQueue(int size, bool fUseExceptions)
        {
            _rgItems = new Object[size];
            _iHead = 0;
            _iTail = 0;
            _cItems = 0;
            _iWriting = 0;
            _fUseExceptions = fUseExceptions;
            _rwlGrow = new ReaderWriterLock();
        }

        ~FastQueue()
        {
            for (int i = 0 ; i < _rgItems.Length; i++)
            {
                _rgItems[i] = null;
            }

            _rgItems = null;
        }

        public int Count
        {
            get
            {
                return _cItems;
            }
        }
        
        public bool Enqueue(Object o)
        {
            if (o == null)
            {
                if (_fUseExceptions)
                {
                    throw new ArgumentException("Cannot enqueue null value.");
                }
                else
                {
                    return false;
                }
            }
            
            bool fDone = false;
            
            while (!fDone)
            {
                // always get a reader lock so that we dont do anything while growing.
                _rwlGrow.AcquireReaderLock(-1);
                
                int iSlot = _iTail;
                if (iSlot == Interlocked.CompareExchange(ref _iTail, (iSlot + 1) % _rgItems.Length, iSlot))
                {
                    // we just incremented _iTail -- it should be safe to use the old slot.
                    if (null == Interlocked.CompareExchange(ref _rgItems[iSlot], o, null))
                    {
                        // we got our spot
                        fDone = true;
                    }
                    else
                    {
                        Grow();
                    }
                }
                
                _rwlGrow.ReleaseReaderLock();
            }

            // increment the count.
            Interlocked.Increment(ref _cItems);

            return true;
        }

        public Object Dequeue()
        {
            // test if there is an item available to satisfy this dequeue.
            int count = Interlocked.Decrement(ref _cItems);
            if (count < 0)
            {
                // undo the extraneous decrement.
                Interlocked.Increment(ref _cItems);

                if (_fUseExceptions)
                {
                    throw new InvalidOperationException("queue empty.");
                }
                else
                {
                    return null;
                }
            }
            
            Object o = null;
            
            while (o == null)
            {
                // always get a reader lock so that we dont do anything while growing.
                _rwlGrow.AcquireReaderLock(-1);
                
                int iSlot = _iHead;
                if (iSlot == Interlocked.CompareExchange(ref _iHead, (iSlot + 1) % _rgItems.Length, iSlot))
                {
                    // we just incremented _iHead -- iSlot should contain our item.     
                    o = Interlocked.Exchange(ref _rgItems[iSlot], null);

                    while (o == null)
                    {
                        // this happens if an enqueue has claimed this slot, but was interrupted before populating it.
                        // we know that the slot will be filled as soon as that thread resumes, so we yield to allow it.
                        Thread.Sleep(0);
                        o = Interlocked.Exchange(ref _rgItems[iSlot], null);
                    }
                }
                
                _rwlGrow.ReleaseReaderLock();
            }

            return o;
        }
        
        private void Grow()
        {
            // assumes reader lock is already held.

            // this is a fast check to determine if someone else is already doing the grow.  we dont want multiple calls to Grow to queue up and all succeed.
            if (1 == Interlocked.Increment(ref _iWriting))
            {
                // only the first increment actually writes

                // take the writer lock to prevent any Enqueues or Dequeues
                LockCookie lc = _rwlGrow.UpgradeToWriterLock(-1);

                // double the size of the array
                Object[] rgNew = new Object[_rgItems.Length * 2];

                int iNew = 0;
                _iTail = _iHead;

                // copy the old data.  we rebase _iHead at 0.            
                // there should be roughly _rgItems.Length elements in the list.
                for (; _iHead < _rgItems.Length; _iHead++)
                {
                    if (_rgItems[_iHead] != null)
                    {
                        rgNew[iNew] = _rgItems[_iHead];
                        iNew++;
                    }
                }
                for (_iHead = 0; _iHead < _iTail; _iHead++)
                {
                    if (_rgItems[_iHead] != null)
                    {
                        rgNew[iNew] = _rgItems[_iHead];
                        iNew++;
                    }
                }

                // update new members
                _rgItems = rgNew;
                _iHead = 0;
                _iTail = iNew;

                _rwlGrow.DowngradeFromWriterLock(ref lc);
            }

            Interlocked.Decrement(ref _iWriting);
        }

        private Object[] _rgItems;
        private int _iHead;
        private int _iTail;
        private int _cItems;
        private int _iWriting;
        private bool _fUseExceptions;
        private ReaderWriterLock _rwlGrow;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FeAppInitializer.cs ===
/*
 * This allows us to specify necessary initialization methods that FeApp will call
 * at the end of Application_Startup. To use this mechanism, do the following:
 * 
 * 1:   Define a static method with no parameters that returns void
 * 2:   Add a FrontEndAppInitializationAttribute to the assembly, passing in
 *      the full path of the class that contains the method, the method name,
 *      and the 'rank', which defines the order in which the methods will be called.
 * 
 * That's all you need to do. During Application_Startup, FeApp will find all of these
 * attributes and call them in (ascending) rank order. For an exmpale, look in
 * common\geoinfo\geofence.cs:
 * [assembly: FrontEndAppInitializationAttribute("STF.common.geofence.MSCOMGeoAPIWrapper", "InitControl", 1)]
 * 
 * The advantage of this is that once you do this, anyone in the future that uses your
 * component will just need to use it (probably meaning adding an XLUSE_) and will
 * automatically get the initialization method called.
 * 
 * Obvious places to improve this:
 *  Instead of a simple static void function, we could use an interface or some method of parameter-passing.
 *  Fatal vs. non-fatal errors--all errors are currently considered non-fatal.
 */

using System;
using System.Collections.Generic;
using System.Reflection;

using STF.common.config;
using STF.common.mgmt;


namespace STF.common.service
{

    // Add this attribute to the assembly to make FeApp call your init method.
    // See comment block at top of file for details.
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    public class FrontEndAppInitializationAttribute : Attribute
    {
        public Type OwningClass;
        public string MethodName;
        public uint Rank;

        public FrontEndAppInitializationAttribute(Type owningClass, string methodName, uint rank)
        {
            OwningClass = owningClass;
            MethodName = methodName;
            Rank = rank;
        }

        public FrontEndAppInitializationAttribute(Type owningClass, string methodName)
            : this(owningClass, methodName, UInt32.MaxValue) { }
    }

    public class FrontEndAppInitializer
    {
        public void Invoke()
        {
            try
            {
                _methodInfo.Invoke(null, null);
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.FEAPP_INITIALIZATION_METHOD_FAILED,  e,  "Initializer '{0}' failed.", _methodInfo.Name);
            }
        }

        public static List<FrontEndAppInitializer> GetInitializers()
        {
            List<FrontEndAppInitializer> initializers = new List<FrontEndAppInitializer>();

            Assembly assembly = Config.Assembly;
            GetInitializers(initializers, assembly);

            foreach (AssemblyName assemblyName in assembly.GetReferencedAssemblies()) {
                GetInitializers(initializers, Assembly.Load(assemblyName));
            }

            // Sort initializers so we call them in the correct order.
            initializers.Sort(Compare);
            return initializers;
        }

        private static void GetInitializers(List<FrontEndAppInitializer> initializers, Assembly assembly)
        {
            object[] attributes = assembly.GetCustomAttributes(typeof(FrontEndAppInitializationAttribute), false);

            foreach (object attributeObject in attributes)
            {
                FrontEndAppInitializationAttribute attribute = (FrontEndAppInitializationAttribute)attributeObject;
                try
                {
                    MethodInfo initMethodInfo = attribute.OwningClass.GetMethod(attribute.MethodName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
                    if (initMethodInfo == null)
                    {
                        throw new Exception();
                    }
                    initializers.Add(new FrontEndAppInitializer(initMethodInfo, attribute.Rank));
                }
                catch (Exception e)
                {
                  Xom.NtEvent(
                      XEvent.Id.FEAPP_INITIALIZATION_METHOD_NOT_FOUND, e,
                      "Could not find method '{0}' in type '{1}'",
                      attribute.MethodName, attribute.OwningClass.Name
                  );
                }
            }
        }

        private FrontEndAppInitializer(MethodInfo methodInfo, uint rank)
        {
            _methodInfo = methodInfo;
            _rank = rank;
        }

        private static int Compare(FrontEndAppInitializer lhs, FrontEndAppInitializer rhs)
        {
            return (int)lhs._rank - (int)rhs._rank;
        }

        private readonly MethodInfo _methodInfo;
        private readonly uint _rank;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\feedbackprot.cs ===
// 
// FeedbackProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Feedback Service Integration
// Xbox Online Service
// 
// Author: masonb
//

using System;
using STF.common.service;
using STF.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.FeedbackProxy)]


namespace STF.common.protocol 
{    
    //
    // Feedback definitions
    //
    public class FeedbackDefs
    {
        // Header name for redirecting presence requests for stress testing. 
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";
        
        // 
        // Enumeration of feedback types
        //  Maps to XONLINE_FEEDBACK_TYPE in STF.x
        //
        public enum FeedbackType : byte
        {
            NegNickname = 0,
            NegGameplay = 1,
            NegScreaming = 2,
            NegHarassment = 3,
            NegLewdness = 4,
            PosAttitude = 5,
            PosSession = 6,
            PosStatsAttachment = 7,
            NegStatsAttachment = 8,
            NegStatsAttachmentCheating = 9,
            NegMessageInappropriate = 10,
            NegMessageSpam = 11,
            NegTeamName = 12,
            NegTeamMotto = 13,
            NegTeamContent = 14,
            NegTeamDescription = 15,
            NegTeamURL = 16,
            NegCompetitionName = 17,
            NegCompetitionMotto = 18,
            NegCompetitionContent = 19,

            // Add new public types here
  
            NumTypes,

            MinServiceType = 254,

            // Add new private service types here and decrement MinServiceType

            ServiceDataMachine = 255,

        }

        // 
        // Enumeration of player review types
        //  Maps to ??? in STF.x
        //
        public enum PlayerReview : uint
        {
            Prefer = 0,
            AvoidTrashTalk = 1,
            AvoidLanguage = 2,
            AvoidDisruptive = 3,
            AvoidAggressive = 4,
            AvoidUnsporting = 5,
            AvoidDisconnect = 6,
            AvoidUnskilled = 7,
            AvoidTooGood = 8,
            AvoidUnfamiliar = 9,


            // Add new review types here
        }
        
        // 
        // Enumeration of player review types
        //  Maps to ??? in STF.x
        //
        public enum ComplaintType : uint
        {
            OffensiveGamertag = 0,
            OffensiveMotto = 1,
            OffensiveTextMessage = 2,
            OffensiveVoiceMail = 3,
            OffensiveVoiceChat = 4,
            OffensiveInGame = 5,
            TamperingFeedback = 6,
            TamperingSystem = 7,
            TamperingCheating = 8,
            OffensiveUserContent = 9,
            OffensiveVideoMessage = 10,
            OffensiveVideoChat = 11,
            OffensiveGamerPicture = 12,
            OffensiveInGameVideo = 13,
            OffensivePhotoMessage  = 14,
            OffensiveUrl = 15,
            ChildAbuse = 16,
            
            // Add new complaint types here
  
        }
        
    } // end definitions

    //
    // Structure Representing a Feedback request.
    //  Maps to XONFEEDBACK_SEND_REQUEST in STF.x
    //  
    public class FeedbackRequest : XRLObject2
    {
        public ulong   ulSendPUID;
        public ulong   ulTargetPUID;
        public uint    uiTitleID;
        public byte    bFeedbackType;
        public byte    bTextSize;

        [WireInfo(SizeParam="bTextSize")]
        public string  szText;

        public override string Xrl
        {
            get
            {
                return "/fbserver/fbserver.ashx";
            }
        }
    }

    //
    // Structure Representing a Player Review request.
    //  Maps to ??? in STF.x
    //  
    public class SubmitReviewRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;

        public override string Xrl
        {
            get
            {
                return "/fbserver/submitreview.ashx";
            }
        }
    }


    //
    // Structure Representing an enumeration of Player Reviews sent by a particular user.
    //  Maps to ??? in STF.x
    //  
    public class EnumerateSentReviewsRequest : XRLObject2
    {
        public ulong   senderPUID;
        public uint    page;
        public uint    resultsPerPage;

        public override string Xrl
        {
            get
            {
                return "/fbserver/enumsentreview.ashx";
            }
        }
    }

    //
    // Structure Representing an enumeration of Player Reviews received by a particular user.
    //  Maps to ??? in STF.x
    //  
    public class EnumerateRecdReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;
        public uint    page;
        public uint    resultsPerPage;

        public override string Xrl
        {
            get
            {
                return "/fbserver/enumrecdreview.ashx";
            }
        }

    }

    //
    // A single PlayerReview result
    //  
    public class PlayerReview : WireData
    {
        public ulong       senderPUID;
        public ulong       targetPUID;
        public uint        titleID;
        public uint        type;
        public ulong       context;
        public DateTime    dtSubmitted;
    }

    //
    // A reply to either a EnumerateSentReviewsRequest or EnumerateRecdReviewsRequest message
    //  
    public class EnumerateReviewsReply : XRLObject2
    {
        public HResult     hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public PlayerReview [] reviews;
    }


    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in STF.x
    //  
    public class GetAggregateReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;

        public override string Xrl
        {
            get
            {
                return "/fbserver/getaggreview.ashx";
            }
        }
    }

    //
    // A single AggregateReview result
    //  
    public class AggregateReview : WireData
    {
        public ulong       targetPUID;
        public uint        count;
        public uint        type;
    }

    //
    // A reply to a GetAggregateReviewsRequest message
    //  
    public class GetAggregateReviewsReply : XRLObject2
    {
        public HResult     hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public AggregateReview [] aggReviews;
    }

    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in STF.x
    //  
    public class SubmitComplaintRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;
	
        public override string Xrl
        {
            get
            {
                return "/fbserver/submitcomplaint.ashx";
            }
        }
    }

    //
    // Structures for the XeSchemaUnitTest component.
    //

    public class XeSchemaUnitTestComplexType : XRLObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]        
        public ushort  v3_ushort_field = '\0';
        [WireInfo(MinSchemaVersion="4.0")]        
        public int     v4_int_field = 0;
    }
    
    public class XeSchemaUnitTestRequest : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field;

        public override string Xrl
        {
            get
            {
                return "/fbserver/XeSchemaUnitTest.ashx";
            }
        }
    }

    public class XeSchemaUnitTestResponse : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field = new XeSchemaUnitTestComplexType();
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\feapp.cs ===
using System;
using System.Web;
using System.Web.Configuration;
using System.Threading;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;

using STF.common.config;
using STF.common.mgmt;

namespace STF.common.service
{
    public interface IFrontEndAppCounters
    {
        IFrontEndAppCounters this[string xrl] { get; }

        PerformanceCounter TotalRequests { get; }

        PerformanceCounter RequestsInProgress { get; }

        PerformanceCounter RequestsPerSec { get; }

        PerformanceCounter AverageExecutionTime { get; }

        PerformanceCounter AverageExecutionTimeBase { get; }

        PerformanceCounter FailuresPerSecond { get; }

        PerformanceCounter FailuresTotal { get; }

        PerformanceCounter FailuresPercentage { get; }

        PerformanceCounter FailuresPercentageBase { get; }
    }

    public class FrontEndAppInternal : HttpApplication
    {
        // key used to access performance counters to be incremented by errors
        public const string FE_APP_COUNTERS      = "FeAppCounters";
        public const string FE_APP_GET_HR        = "FeAppGetHr";
        public const string FE_APP_LOGGED        = "FeAppLogged";
        public const string FE_APP_EXCEPTION     = "FeAppException";
        public const string FE_APP_CACHE_CONTROL = "FeAppCacheControl";
        public const string FE_APP_XRL_COUNTER_NAME      = "FeAppXrlName";

        private static int _keytag;

        // Should FEAPP handle the per-api perf counters, or not?
        private bool _fPerApiCounters;

        private static IFrontEndAppCounters _apiCounters;
        public static IFrontEndAppCounters FrontEndAppCounters
        {
            get { return _apiCounters; }
            set { _apiCounters = value; }
        }

        // set on application_start to signal success/failure
        private static bool _fInitialized = false;
        private static string _strLastInitError;

        // accessors for the above initialization members.
        public static bool fInitialized
        {
            get
            {
                return _fInitialized;
            }
        }

        public static string strLastInitError
            {
            get
            {
                return _strLastInitError;
            }
        }

        // Time spent in current request so far. Useful when writing to a log file.
        public static long MillisecondsElapsed
        {
            get
            {
                XomRequestTimeElapsed requestTimeElapsed
                    = (XomRequestTimeElapsed)(HttpContext.Current.Items["FeAppElapsedTime"]);
                return requestTimeElapsed == null ? 0 : requestTimeElapsed.MillisecondsElapsed;
            }
        }

        // Ticks spent in current request so far. Useful when writing to a log file.
        public static long TimeElapsed
        {
            get
            {
                XomRequestTimeElapsed requestTimeElapsed
                    = (XomRequestTimeElapsed)(HttpContext.Current.Items["FeAppElapsedTime"]);
                return requestTimeElapsed == null ? 0 : requestTimeElapsed.TimeElapsed;
            }
        }

        static FrontEndAppInternal()
        {
            //
            // Start the cache key tag at value 1.
            //
            _keytag = 1;
        }

        public FrontEndAppInternal()
            : this(true)
        {
        }

        public FrontEndAppInternal(bool fPerApiCounters)
        {
            _fPerApiCounters = fPerApiCounters;
        }

        public static IFrontEndAppCounters XrlCounters(HttpContext ctx)
        {
            string nameXrlCounter = GetXrlCounterName( ctx.Request.Path, ctx.Request.Headers["SOAPAction"] );

            ctx.Items[FE_APP_XRL_COUNTER_NAME] = nameXrlCounter;
            
            return FrontEndAppCounters[nameXrlCounter];
        }

        public static IFrontEndAppCounters XrlCounters(string nameXrlCounter)
        {
            return FrontEndAppCounters[nameXrlCounter];
        }

        public static string GetXrlCounterName(string url, string SOAPAction)
        {
            // set up XRL-specific perf counters
            // 1. "/" are bad in instance names
            // 2. instance must be <= 127 chars
            // 3. query strings are bad in instance names
            string instanceName = url.Replace('/', '\\');
            if (null != SOAPAction)
            {
                int start = SOAPAction.LastIndexOf( "/" ) + 1;
                if ( 0 < start ) // If parsing worked then append what should be the API name (omit the closing quote(")
                    instanceName += "\\" + SOAPAction.Substring( start, SOAPAction.Length - start - 1 );
            }
            if (instanceName.Length > 127)
            {
                instanceName = instanceName.Substring(0, 127);
            }
            return instanceName;
        }

        // Application_Start is not virtual, because we want derived classes to instead override
        // OnApplicationStart (which is called by Application_Start) so that they get the benefit
        // of this class's Application_Start exception handling.
        public virtual void Application_Start(object sender, EventArgs e)
        {
            try
            {
                if (BreakOnStart)
                {
                    System.Diagnostics.Debugger.Break();
                }

                XomLoggingControl.Init();
                XomPerformanceCounterCategory.InitPerfCtrs();

                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                // prevent performance degradation when periods of slow activity alternate with periods of heavy activity
                // KB#827419 http://support.microsoft.com/default.aspx?scid=kb;en-us;827419
                int workerThreads = Config.GetIntSetting(Setting.feapp_workerThreads);;
                int completionPortThreads = Config.GetIntSetting(Setting.feapp_completionPortThreads);;
                int maxWorkerThreads, maxCompletionPortThreads = 0;

                ThreadPool. GetMaxThreads(out maxWorkerThreads, out maxCompletionPortThreads);
                workerThreads = Math.Min(maxWorkerThreads, workerThreads);
                completionPortThreads = Math.Min(maxCompletionPortThreads, completionPortThreads);

                ThreadPool.SetMinThreads(workerThreads, completionPortThreads);

                List<FrontEndAppInitializer> initializers = FrontEndAppInitializer.GetInitializers();
                initializers.ForEach(delegate(FrontEndAppInitializer initializer) { initializer.Invoke(); } );

                // we've done the base initialization -- now give derived classes an opportunity to
                // do their specific initialization, by calling OnApplicationStart.
                OnApplicationStart();

                // setting this to true means that the FEApp initialization health check will now be green.
                _fInitialized = true;

                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "\r\n" );
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "==================================");
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "New Application, started " + DateTime.Now);
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "==================================");

                Xom.NtEvent(XEvent.Id.MC_APPDOMAIN_STARTED, "App domain '{0}' has started successfully.", AppDomain.CurrentDomain.ToString());
            }
            catch (Exception ex)
            {
                _fInitialized = false;
                _strLastInitError = ex.ToString();
                Xom.NtEvent(XEvent.Id.FEAPP_INIT_FAILURE, ex, "Failed to start application domain '{0}'", AppDomain.CurrentDomain.FriendlyName);
            }
        }

        protected virtual void OnApplicationStart()
        {
            // no base implementation.  Derived classes should override this if they want any code run
            // on application_start.
        }

        public virtual void OnAudit(object sender, EventArgs eventArgs)
        {
            // no base implmentation. Derived front door classes should override this.
        }

        public virtual void Application_End(object sender, EventArgs e)
        {
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "\r\n");
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "==================================");
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Application End, " + DateTime.Now);
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "==================================");

            XomLoggingControl.Close();

          Xom.NtEvent(XEvent.Id.MC_APPDOMAIN_STARTED_1, "The app domain has ended.\r\n" + AppDomain.CurrentDomain.ToString());

            PerformanceCounter.CloseSharedResources();
        }

#if ICECAP
        int _mark = 0;
#endif

        public virtual void Application_BeginRequest(object sender, EventArgs e)
        {
            HttpContext context = HttpContext.Current;
            HttpRequest request = context.Request;

            context.Items["FeAppElapsedTime"] = new XomRequestTimeElapsed();

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "---------" + DateTime.Now.ToString() + "--------" );
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "BeginRequest(" + request.RawUrl + ")" );
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "" );

            RequestHeaderBehaviorInjectionMgr.AddBehaviorInjections(request.Headers);

            if (_fPerApiCounters)
            {
                IFrontEndAppCounters xrlCounters = XrlCounters(context);
                xrlCounters.RequestsInProgress.Increment();
            }

            FrontEndAppCounters.RequestsInProgress.Increment();

            // Reset context logging status for this thread.
            XomLogArea.ResetContextLogging();

#if ICECAP
            IceCap.StartProfile(IceCap.PROFILE_THREADLEVEL, IceCap.PROFILE_CURRENTID);
            IceCap.CommentMarkProfile(++_mark, url);
#endif
        }

        public virtual void Application_EndRequest(object sender, EventArgs e)
        {
            HttpContext context = HttpContext.Current;
            HttpRequest request = context.Request;

            // null-op for most front doors (unless the override)
            OnAudit(sender, e);

            XomRequestTimeElapsed requestTimeElapsed = null;
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "EndRequest(" + context.Request.RawUrl + ")" );
            if (context != null && context.Items["FeAppElapsedTime"] != null)
            {
                requestTimeElapsed = (XomRequestTimeElapsed)(context.Items["FeAppElapsedTime"]);
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Elapsed Time (ms): " + requestTimeElapsed != null ? requestTimeElapsed.MillisecondsElapsed.ToString() : "0");
            }
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "---------" + DateTime.Now.ToString() + "--------" );
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "" );

            long elapsed = requestTimeElapsed != null ? requestTimeElapsed.TimeElapsed : 0;
            if (_fPerApiCounters)
            {
                IFrontEndAppCounters xrlCounters = XrlCounters(context);

                xrlCounters.TotalRequests.Increment();
                xrlCounters.RequestsPerSec.Increment();
                xrlCounters.RequestsInProgress.Decrement();
                xrlCounters.FailuresPercentageBase.Increment();

                // Only add succeses into the average execution time.
                if (GetErrorFromContext(context) == null)
                {
                    xrlCounters.AverageExecutionTime.IncrementBy(elapsed * 1000);
                    xrlCounters.AverageExecutionTimeBase.Increment();
                }
            }

            RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();

            FrontEndAppCounters.TotalRequests.Increment();
            FrontEndAppCounters.RequestsPerSec.Increment();
            FrontEndAppCounters.RequestsInProgress.Decrement();
            FrontEndAppCounters.FailuresPercentageBase.Increment();

            FrontEndAppCounters.AverageExecutionTime.IncrementBy(elapsed * 1000);
            FrontEndAppCounters.AverageExecutionTimeBase.Increment();

            // if this request has logged an event, then copy the id
            // into the response header so caller  knows  we  logged

            if ((context.Items["XEvent"] != null) && (context.Response.Headers["X-Event"] == null))
            {
                context.Response.AppendHeader("X-Event", (string) context.Items["XEvent"]);
            }

            // and now for some utterly gross magic.  if this is a post
            // or get, and there was an error we reformat the  response

            ReformatResponse(context);
            CacheControl(context);
#if ICECAP
            IceCap.StopProfile(IceCap.PROFILE_THREADLEVEL, IceCap.PROFILE_CURRENTID);
#endif
        }

        public static void CacheControl(HttpContext context)
        {
            // cache-control - TODO make this configurable

            if (context.Items[FE_APP_CACHE_CONTROL] != null)
            {
                int seconds;
                HttpResponse response = context.Response;

                if (int.TryParse((string) context.Items[FE_APP_CACHE_CONTROL], out seconds))
                {
                    // we don't set cache-control. .NET overwrites it.
                    // add a header telling XRL scan to overwrite  it

                    response.Cache.SetExpires(DateTime.Now.AddSeconds(seconds));
                    response.Cache.SetNoServerCaching();

                    response.AddHeader("X-Cache-Control", string.Format("public, must-revalidate, max-age={0}", seconds));
                }
            }
        }

        public static void ReformatResponse(HttpContext context)
        {
            HttpResponse response = context.Response;
            HttpApplicationState state = context.Application;

            // we only reformat errors. and then only if it is not XON.

            if (response.StatusCode != 500 && response.StatusCode != 400) return;
            if (context.Request.ContentType.StartsWith("xon/")) return;

            // figure out what error we will write  into  the  response.
            // if there's none, then they just get the current response

            Exception e = GetErrorFromContext(context);
            if (e == null) return;

            // the xbox client is looking for the hresult in a specific
            // header (part of the XRL protocol actually). put it there

            GetHrDelegate GetHr = (GetHrDelegate) state.Get(FE_APP_GET_HR);
            if (GetHr == null) GetHr = XRLException.ToHResult;

            // the X-Err header is hex but does not have a  leading  0x
            response.AppendHeader("X-Err", GetHr(e, HResult.XONLINE_E_SERVER_ERROR).ToString());

            // we added the X-Err header for SOAP, but we do not modify
            // the actual response.  return if this is a  SOAP  request

            if (context.Request.Headers["SOAPAction"] != null) return;

            // IIS looks at the Context.Error and if it sees  one  will
            // reformat  our reformatting.  if we use it, then clear it

            if (e == context.Error) context.ClearError();

            // construct an XML  response.  there is no schema,  but it
            // is well formed so the caller can parse  the  information

            response.ClearContent();
            response.ContentType = "text/xml";
            response.Headers.Remove("Content-Encoding");

            response.Write(FormatException(
                e, false, (! context.IsCustomErrorEnabled) || Config.IsTestEnvironment(), GetHr
            ));
        }

        private static string FormatException(Exception e, bool isInner, bool IsVerbose, GetHrDelegate GetHr)
        {
            StringBuilder sb = new StringBuilder();

            if (isInner)
                sb.AppendLine("<InnerException>");
            else
            {
                sb.AppendLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
                sb.AppendLine("<Exception>");
            }

            // all that information comes from the exception.  some are
            // richer than others.  use everything  that  we  can  find

            sb.AppendFormat("<Type>{0}</Type>\r\n", e.GetType().ToString());

            if (IsVerbose) {
                sb.AppendFormat("<Message>{0}</Message>\r\n", HttpUtility.HtmlEncode(e.Message));
            }

            sb.AppendFormat("<HResult>{0}</HResult>\r\n", GetHr(e, HResult.XONLINE_E_SERVER_ERROR).ToString());

            if (e is ExceptionWithEvent) {
                sb.AppendFormat("<EventId>{0}</EventId>\r\n", ((uint) ((ExceptionWithEvent) e).EventId) & 0xFFFF);
            }

            // if custom errors are not enablged, then we recurse
            // to include all of the inner exception  information

            if (IsVerbose) {
                sb.AppendFormat("<StackTrace>{0}</StackTrace>\r\n", HttpUtility.HtmlEncode(e.StackTrace));

                if (e.InnerException != null)
                {
                    sb.AppendFormat("{0}\r\n", FormatException(e.InnerException, true, IsVerbose, GetHr));
                }
            }

            if (isInner)
                sb.AppendLine("</InnerException>");
            else {
                sb.AppendLine("</Exception>");
            }

            return sb.ToString();
        }


        public virtual void Application_OnError(object sender, EventArgs ea)
        {
            LogException(
                Context, Context == null ? null : Context.Error, true
            );
        }

        public static void LogException(Exception e)
        {
            HttpContext context = HttpContext.Current;
            LogException(context, e, false);
        }


        public static void LogException(
            HttpContext           context,
            Exception             e,
            bool                  generateXrlResponse
        )
        {
            // this should never (ever) happen, but if/when it does ...

            if (context == null)
            {
                string eventString = String.Format("No HTTP Context found\r\n\r\n{0}", Environment.StackTrace);
              Xom.NtEvent(XEvent.Id.MC_APPLICATION_ERROR, eventString);
                return;
            }

            // get and set some stuff in context cache for this request

            string errCtrsName;
            GetHrDelegate GetHr;
            PerformanceCounter[] errCtrs = null;

            // this guy here is to prevent SOAPExtensions  from  double
            // logging and double incrementing the performance counters

            context.Items[FE_APP_LOGGED] = "true";

            // and put the exception in the cache so we have  it  later
            // if we want to reformat the  exception  for  post and get

            context.Items[FE_APP_EXCEPTION] = e;

            // we have a delegate to get the HResult because  different
            // apps get the HResult and translate it in different  ways

            HttpApplicationState state = context.Application;

            if (state.Get(FE_APP_GET_HR) == null)
                GetHr = XRLException.ToHResult;
            else
            {
                GetHr = (GetHrDelegate) state.Get(FE_APP_GET_HR);
            }

            // webcache apps use a different set of  error  performance
            // counters, get the name of the counters we will increment

            if (state.Get(FE_APP_COUNTERS) != null)
                errCtrsName = (string) state.Get(FE_APP_COUNTERS);
            else
            {
                errCtrsName = XOn.ERROR_PERF_COUNTERS;
            }

            // and take that name and use it find the  actual  counters

            if (context.Items[errCtrsName] != null)
            {
                errCtrs = (PerformanceCounter[]) context.Items[errCtrsName];
            }


            // dredge through any exception they passed us for hresults
            // events ids, etc, and then send it off to the  event  log

            if (e != null)
            {
                string msg = null;
                bool fireEvent = true;
                XEvent.Id eventId = XEvent.Id.MC_APPLICATION_ERROR;


                try
                {
                    if (e is ExceptionWithoutEvent)
                    {
                        fireEvent = false;
                    }
                    else
                    {
                        // grab an event id and message
                        msg = e.Message;

                        if (e is ExceptionWithEvent)
                        {
                            eventId = ((ExceptionWithEvent)e).EventId;
                        }
                    }

                    if (generateXrlResponse)
                    {
                        uint titleId = 0;

                        try
                        {
                            titleId = SGInfo.Current.TitleId;
                        }
                        catch
                        {
                            // couldn't get title id, leave it at 0.
                        }

                        XRLUtil.SetXRLResponse(context.Response, XRLUtil.GetServiceID(context.Request), titleId, GetHr(e, HResult.XONLINE_E_SERVER_ERROR));
                    }
                }
                catch (Exception ex)
                {
                    StringBuilder eventText = new StringBuilder(fireEvent ? msg : null);

                    eventText.Append("\r\n*********\r\n");
                    eventText.Append("A new exception was thrown in the global event handler!\r\n");
                    eventText.Append(ex.ToString());

                    // Just add or set this to the event that will get fired below
                    msg = eventText.ToString();
                    fireEvent = true;
                }
                finally
                {
                    if (fireEvent)
                    {
                        Xom.NtDataDynEvent(eventId, e, null, msg);
                    }
                }
            }

            // if they provided us with a set of  error  counters  then
            // we need to increment them.  keep trucking if this  fails

            try
            {
                string xrlCounterName = (string)context.Items[FE_APP_XRL_COUNTER_NAME];
                if (!String.IsNullOrEmpty(xrlCounterName))
                {
                    IFrontEndAppCounters xrlCounters = XrlCounters(xrlCounterName);
                    xrlCounters.FailuresPerSecond.Increment();
                    xrlCounters.FailuresTotal.Increment();
                    xrlCounters.FailuresPercentage.Increment();
                }

                FrontEndAppCounters.FailuresPerSecond.Increment();
                FrontEndAppCounters.FailuresTotal.Increment();
                FrontEndAppCounters.FailuresPercentage.Increment();

                if (errCtrs != null)
                {
                    for (int i = 0; i < errCtrs.Length; i++)
                    {
                        errCtrs[i].Increment();
                    }
                }
            }
            catch(Exception ePerfCtr)
            {
                Debug.Assert(false, "Failure in incrementing error perf counters!  " + ePerfCtr.ToString());
            }


#if DEBUG
            if (!XRLUtil.IsFromBrowser())
            {
#endif
                if (generateXrlResponse)
                {
                    context.Response.End();
                }
#if DEBUG
            }
#endif
        }

        public delegate HResult GetHrDelegate(Exception e, HResult hr);

        //
        // event callback stuff
        //
        public delegate void FlushCacheEventHandler (object sender, EventArgs args);

        public static event FlushCacheEventHandler FlushCacheEvent;

        public static void OnFlushCache(EventArgs args)
        {

        }


        //
        // Control stuff
        //

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage("FrontEndApp help:\r\n" +
                            " CacheFlush -- effectively flushes the application cache of all persistant data\r\n" +
                            "               that could be changed in the underlying database, thus forcing\r\n" +
                            "               the front door to go back to the database where appropriate the\r\n" +
                            "                next time through.\r\n" +
                            " ForceGC -- forces a garbage collection by calling GC.WaitForPendingFinalizers,\r\n" +
                            "            GC.Collect(). WARNING: will stop all threads on the service while\r\n" +
                            "            executing.  Should only be used when absoutely necessary!!\r\n\r\n", args.RequestId);
                        args.Handled = true;
                        break;

                    case "forcegc":
                        XomControlConnection.SendMessage(ProcessForceGCRequest(args), args.RequestId);
                        args.Handled = true;
                        break;

                    case "cacheflush":
                        XomControlConnection.SendMessage(ProcessCacheFlush(args), args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static string ProcessForceGCRequest(ControlRequestEventArgs args)
        {
            long bytes = GC.GetTotalMemory(true);
            return "Collection complete.   Bytes currently allocated: " + bytes + " (approximate)\r\n";
        }


        public static string ProcessCacheFlush(ControlRequestEventArgs args)
        {
            Interlocked.Increment(ref _keytag);

            if (FlushCacheEvent != null)
            {
                FlushCacheEvent(null, args);
            }

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "***Management command issued to flush cache. Completed.***");

            return "Cache version flush complete. (Old entries will expire silently.)\r\n";
        }

        public static int CacheTag()
        {
            return _keytag;
        }

        private static Exception GetErrorFromContext(HttpContext context)
        {
            Exception e = (Exception) context.Items[FE_APP_EXCEPTION];
            if (e == null)
            {
                e = context.Error;
            }
            return e;
        }

        /* Want to break in the debugger as FeApp starts up? Add the following to web.config,
         * directly in the configuration section (not in the system.web section):
              <appSettings>
                <add key="BreakOnApplicationStart" value="true" />
              </appSettings>
         */
        private static bool BreakOnStart
        {
            get
            {
                string breakOnStartSetting = WebConfigurationManager.AppSettings["BreakOnApplicationStart"];
                bool breakOnStart;
                if (Boolean.TryParse(breakOnStartSetting, out breakOnStart))
                {
                    return breakOnStart;
                }
                else
                {
                    return false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Floken.cs ===
using System;
using System.IO;
using System.Globalization;

namespace STF.common.service
{
    // -----------------------------------------------------------------------------
    // Flow tokens - used to track a session throughout live. This definition should match   
    // the one in STF.x for native code.
    //
    // See http://xblwiki/default.aspx/XboxLive/FlowTokenDesignSpec.html.
    // -----------------------------------------------------------------------------
    public struct Floken : IEquatable<Floken>, IEquatable<ulong>
    {
        // If this was an internal header, it should go in XOn.cs. But it isn't, and we don't 
        // have a good central place yet, so it's going here.
        public const string XHTTPHDR_FLOWTOKEN = "X-Floken";

        public static Floken None
        {
            get 
            { 
                Floken f = new Floken();
                f._FlowToken = 0;
                return f;
            }
        }

        // Prevent recursion when SGInfo calls XomTrace and it comes back to us (for 
        // instance). No need to use interlocked functions since this is thread static.
        [ThreadStatic]
        private static int s_currentCallDepth = 0;

        public static Floken Current
        {
            get
            {
                try
                {
                    if (++s_currentCallDepth > 1)
                    {
                        return Floken.None;
                    }

                    // @@@ TODO: implement a more generic, pluggable caching / request 
                    // management system.

                    if (AAInfo.IsCached || AAInfo.IsActiveAuthAvailable)
                    {
                        AAInfo aa = AAInfo.Current;
                        if (aa != null)
                        {
                            return aa.FlowToken;
                        }
                        return Floken.None;
                    }

                    if (SGInfo.IsCached)
                    {
                        return SGInfo.Current.FlowToken;
                    }
                    else if (SGInfo.RetrieveSgInfoForFlowToken && SGInfo.IsAvailable)
                    {
                        // This will force an SGInfo lookup
                        try
                        {
                            return SGInfo.Current.FlowToken;
                        }
                        catch (Exception)
                        {
                            // @@@ Trace? Event? Kinda want to keep Xom out of this  
                            // class...
                            return Floken.None;
                        }
                    }
                    else
                    {
                        return Floken.None;
                    }
                    
                }
                catch (Exception)
                {
                    // @@@ TODO: event, trace, something.
                    return Floken.None;
                }
                finally
                {
                    --s_currentCallDepth;
                }
            }
        }

        // Please try to use the provided accessors and operators instead of this
        public ulong FlowToken
        {
            get { return _FlowToken; }
        }

        public bool IsValid
        {
            get { return _FlowToken != 0; }
        }

        // -----------------------------------------------------------------------------
        // Constructor - deserializes floken from a stream
        // -----------------------------------------------------------------------------
        public Floken(BinaryReader br)
        {
            _FlowToken = br.ReadUInt64();
        }

        // -----------------------------------------------------------------------------
        // Constructor - deserializes floken from a hexadecimal string 
        // -----------------------------------------------------------------------------
        public Floken(String s)
        {
            if (String.IsNullOrEmpty(s))
            {
                _FlowToken = 0;
                return;
            }

            if (s.StartsWith("FT", true, CultureInfo.CurrentCulture))
                s = s.Substring(2);
            else if (s.StartsWith("0x", true, CultureInfo.CurrentCulture))
                s = s.Substring(2);

            try
            {
                _FlowToken = UInt64.Parse(s, NumberStyles.HexNumber);
            }
            catch (FormatException)
            {
                // bad client! bad! we don't want to abort the request with an unhandled 
                // exception, though, so carry on.
                _FlowToken = 0;
            }
        }

        // -----------------------------------------------------------------------------
        // Constructor - from a simple ulong. Try not to use this one, k? Flowtokens are 
        // best represented as a Floken, not a ulong.
        // -----------------------------------------------------------------------------
        public Floken(ulong v)
        {
            _FlowToken = v;
        }

        // -----------------------------------------------------------------------------
        // Generates a new random flow token 
        // -----------------------------------------------------------------------------
        public static Floken NewFloken()
        {
            Floken f = new Floken();
            f._FlowToken = Crypto.GetRandomUInt64();
            return f;
        }

        // -----------------------------------------------------------------------------
        // Write - serialize floken to a stream
        // -----------------------------------------------------------------------------
        public void Write(BinaryWriter bw)
        {
            bw.Write(_FlowToken);
        }

        // -----------------------------------------------------------------------------
        // ToString - the one and only way to display a flow token
        // -----------------------------------------------------------------------------
        public override string ToString()
        {
            if (IsValid)
                return "FT" + _FlowToken.ToString("X016");
            else
                return "FT0";
        }

#region Equality overrides
        // {{{
        public override int GetHashCode()
        {
            return _FlowToken.GetHashCode();
        }

        public bool Equals(Floken other)
        {
            return _FlowToken == other._FlowToken;
        }

        public bool Equals(ulong other)
        {
            return _FlowToken == other;
        }

        public override bool Equals(Object obj)
        {
            if (obj == null) return base.Equals(obj);

            if (!(obj is Floken))
                return false;
            else
                return Equals((Floken)obj);
        }

        public static bool operator ==(Floken floken1, Floken floken2)
        {
            return floken1.Equals(floken2);
        }

        public static bool operator !=(Floken floken1, Floken floken2)
        {
            return (!floken1.Equals(floken2));
        }

        // }}}
#endregion

        private ulong _FlowToken;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FrontEndApp.cs ===
using System;
using System.Web;
using System.Reflection;
using System.Diagnostics;

using STF.common.config;
using STF.common.mgmt;

namespace STF.common.service 
{
    public class FrontEndApp : FrontEndAppInternal
    {
        public FrontEndApp() : this(true)
        {
        }

        public FrontEndApp(bool fPerApiCounters) : base(fPerApiCounters)
        {
            // Don't forget this, else FrontEndAppInternal will throw exceptions
            FrontEndAppInternal.FrontEndAppCounters = XrlPerfCounters.Counters;
        }

        public override void Application_Start(object sender, EventArgs e)
        {
            // This one line must run in assembly of the application
            // and must be  "included"  instead  of  linked  against

            Config.Assembly = Assembly.GetExecutingAssembly();
            base.Application_Start(sender, e);
	}
    }

    [XomComponentPerformanceCounterCategoryAttr( "XRL" , "Xbox Live Common Per-XRL Counters" )]
    public class XrlPerfCounters : XomPerformanceCounterCategory, IFrontEndAppCounters
    {
        public IFrontEndAppCounters this[string xrl]
        {
            get
            {
                return (XrlPerfCounters) GetInstance(xrl);
            }
        }

        static public XrlPerfCounters Counters = new XrlPerfCounters();

        [XomPerformanceCounterAttr(
             "Requests, Total",
             "Total number of requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _TotalRequests;

        public PerformanceCounter TotalRequests { get { return _TotalRequests; } }

        [XomPerformanceCounterAttr(
             "Requests, In Progress",
             "Number of requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _RequestsInProgress;
        
        public PerformanceCounter RequestsInProgress { get { return _RequestsInProgress; } }

        [XomPerformanceCounterAttr(
             "Requests, Per Sec",
             "Number of requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _RequestsPerSec;
        
        public PerformanceCounter RequestsPerSec { get { return _RequestsPerSec; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time (in ms)",
             "Average request execution time in the current AppDomain (in ms)",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter _AverageExecutionTime;

        public PerformanceCounter AverageExecutionTime { get { return _AverageExecutionTime; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time Base",
             "Base for the average request execution time in the current AppDomain",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter _AverageExecutionTimeBase;

        public PerformanceCounter AverageExecutionTimeBase { get { return _AverageExecutionTimeBase; } }

        [XomPerformanceCounterAttr(
             "Failures, Per Sec",
             "Number of failures per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _FailuresPerSecond;

        public PerformanceCounter FailuresPerSecond { get { return _FailuresPerSecond; } }

        [XomPerformanceCounterAttr(
             "Failures, Total",
             "Total number of failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _FailuresTotal;

        public PerformanceCounter FailuresTotal { get { return _FailuresTotal; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage",
             "Request failure percentage",
             PerformanceCounterType.SampleFraction)]
        public PerformanceCounter _FailuresPercentage;

        public PerformanceCounter FailuresPercentage { get { return _FailuresPercentage; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage Base",
             "Base for the prequest failure percentage",
             PerformanceCounterType.SampleBase)]
        public PerformanceCounter _FailuresPercentageBase;

        public PerformanceCounter FailuresPercentageBase { get { return _FailuresPercentageBase; } }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FrontEndCompression.cs ===
// FrontEndCompression.cs
// Copyright (c) Microsoft Corporation

using System.Collections.Generic;
using System.Collections;
using System.Web;
using System.Text.RegularExpressions;

using STF.common.config;
using STF.common.mgmt;


namespace STF.common.feapp
{

    internal class CompressionPathList
    {
        private List<string> _paths = new List<string>();

        public void Add(string path)
        {
            if (!_paths.Contains(path))
            {
                _paths.Add(path);
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Adding '" + path + "' to compression paths");
            }
        }

        public bool ShouldCompress(string requestPath)
        {
            bool retValue = false;
            foreach (string path in _paths)
            {
                if (requestPath.StartsWith(path))
                {
                    retValue = true;
                    break;
                }
            }
            return retValue;
        }
    }

    public class FrontEndCompression
    {

        private static CompressionPathList _compressionPaths;
        private static volatile bool _fInitialized = false;
        private static object _lockInit = new object();

        static FrontEndCompression()
        {
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(MultiSettingChange);
        }

        //////////////////////////////////////////////////////////
        // Initialize
        //
        // Public static methods of this class MUST call this method (Initialize) to guarantee
        // all static members are properly initialized before doing any work
        // Note: MultiSettingCHange is one exception to this rule.
        private static void Initialize()
        {
            if ( !_fInitialized )
            {
                lock ( _lockInit )
                {
                    if ( !_fInitialized )
                    {
                        string[] paths = Config.GetMultiSetting(MultiSetting.feapp_compressionPaths);
                        Load(paths);
                        
                        _fInitialized = true;
                    }
                }
            }
        }

        private static void Load(string[] paths)
        {
            CompressionPathList list = new CompressionPathList();
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Reloading compression paths");

            foreach (string path in paths) {
                list.Add(path.ToLower());                                
            }

            _compressionPaths = list;
        }


        public static void MultiSettingChange(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            if (eventArgs.MultiSetting == MultiSetting.feapp_compressionPaths)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Detected configuration change for compression paths");
                Load(eventArgs.ValueNew);
            }
        }


        public static bool Compress(HttpContext context)
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            // if they do not have context, or they do not have
            // a request or response,  then we cannot  compress

            if (context == null) return false;

            HttpRequest request = context.Request;
            if (request == null) return false;

            HttpResponse response = context.Response;
            if (response == null) return false;

            // we only compress configured paths stored in read
            // only CompressionPaths structure populated by feapp multi-setting

            if (!_compressionPaths.ShouldCompress(request.Path.ToLower()))
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Compression not configured for path '" + request.Path + "'");
                return false;
            }

            //set the response header "Vary" to "Accept-Encoding". This will determine whether a cache is permitted to use the response to reply to a subsequent request without revalidation
            //revalidation will not happen if and only if the requests consists same "Accept-Encoding" header
            
            response.AppendHeader("Vary", "Accept-Encoding");

            // check if client accepts  compression,  and if so
            // whether they have a specific preference  to  one

            AcceptEncoding acceptEncoding = new AcceptEncoding(request);

            // right now,  we only  support  gzip  and  deflate

            bool acceptsGzip = acceptEncoding.Accepts("gzip");
            bool acceptsDeflate = acceptEncoding.Accepts("deflate");

            // if they support  both,  see  which  they  prefer
            // turn off gzip if they prefer deflated  responses

            if (acceptsGzip && acceptsDeflate) {
                acceptsGzip = acceptEncoding.Preference("gzip") >= acceptEncoding.Preference("deflate");
            }

            // then test gzip first (our preferred) which  wins
            // all the ties if they have no specific preference

            if (acceptsGzip)
            {
                response.Filter = new System.IO.Compression.GZipStream(
                    response.Filter, System.IO.Compression.CompressionMode.Compress);

                response.AppendHeader("Content-Encoding", "gzip");
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Setting gzip compression for request to '" + request.Path + "'");
            }

            // was not gzip, is not deflate, so we return false

            else if (! acceptsDeflate)
                return false;

            else {
                response.Filter = new System.IO.Compression.DeflateStream(
                    response.Filter, System.IO.Compression.CompressionMode.Compress);

                response.AppendHeader("Content-Encoding", "deflate");
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Setting deflate compression for request to '" + request.Path + "'");
            }

            // if we get here then we setup compression  filter
            // and added a content-encoding header, return true

            return true;
        }
    }


    internal class AcceptEncoding
    {
        private Dictionary<string, double> _dictionary = new Dictionary<string, double>();

        internal AcceptEncoding(HttpRequest request)
        {
            // not having the header is okay, we just won't
            // be able to give them much info when they ask

            string header = GetHeader(request);
            if (header == null) return;

            foreach (string s in header.Split(',')) {
                Parse(s);
            }
        }


        private string GetHeader(HttpRequest request)
        {
            if (request == null) return null;

            string acceptEncoding = request.Headers["Accept-Encoding"];
            if (string.IsNullOrEmpty(acceptEncoding)) return null;
            return acceptEncoding.ToLower();
        }


        private void Parse(string header)
        {
            string[] t = header.Split(';');

            if (t.Length <= 2)
            {
                string encoding = t[0].Trim();
                t = (t.Length == 1 ? "q=1.0" : t[1]).Split('=');

                if ((t.Length == 2) && (t[0].Trim() == "q"))
                {
                    double value;

                    if (double.TryParse(t[1], out value))
                    {
                        if (_dictionary.ContainsKey(encoding)) _dictionary.Remove(encoding);
                        _dictionary.Add(encoding, value);
                        return;
                    }
                }
            }

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "AcceptEncoding : invalid header value '" + header + "'");
        }

        internal double Preference(string encoding)
        {
            double value;
            if (_dictionary.TryGetValue(encoding, out value)) return value;
            return 0.0;
        }

        internal bool Accepts(string encoding)
        {
            return Preference(encoding) > 0.0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FrontEndHandler.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;

using STF.common.config;
using STF.common.service;

namespace STF.common.feapp
{
    public abstract class FrontEndHandler<TRequest, TResponse> : IHttpHandler where TRequest  : XRLObject2, new()
                                                                              where TResponse : XRLObject2
    {
        #region Implementation of IHttpHandler

        /// <summary>
        /// Deserialize request and call the internal ProcessRequest method
        /// to get the returned resposne and HResult
        /// </summary>
        /// <param name="context">HttpContext from IIS</param>

        public void ProcessRequest(HttpContext context)
        {
            // make sure come in on one of the allowed interfaces

            FrontEndMapping mapping = FrontEndMapping.Get(context);
            XOService serviceId = mapping[CallSource.Check(mapping.Interfaces)];

            // if the interface has a service id,  then make sure
            // the caller has that service id in their auth  data

            if (serviceId != 0) {
                SGInfo.VerifyServiceId(serviceId);
            }

            // use the null constructor  to  instantiate  request

            TRequest  request  = new TRequest();
            TResponse response = null;

            // and then read the request buffer into  the request

            request.SchemaVersion = WireData.GetSchemaVersion(context.Request);
            request.ReadFromRequest(context.Request);

#if false
            // now authorize the request  against  the  attributes
            // defined for this request in the wiredata definition

            request.Authorize();
#endif           
            // call internal version for  the  deserialized  class.
            HResult hr = ProcessRequest(context, request, out response);

            // if we have response, set schema version and write it  out
            if (response != null) response.SchemaVersion = request.SchemaVersion;
            XRLUtil.SetXRLResponse(context.Response, serviceId, hr, response);
        }

        /// <summary>
        /// Implementation of IHttpHandler method. Pretty much every handler
        /// we have is reusable.  If  not,  concrete  classes  can  override.
        /// </summary>
        
        public virtual bool IsReusable
        {
            get { return true; }
        }

        #endregion

        #region Abstract methods

        /// <summary>
        /// Entry point where the real business logic of a process request  call
        /// is executed.   takes a request,  returns a response and  an  HResult.
        /// </summary>
        /// <param name="context">The HttpContext from the ASP.NET pipeline</param>
        /// <param name="request">The deserialized request object</param>
        /// <param name="request">The response object.  This can be returned as null.
        /// but it must have a type. If there is no response type, then use XRLObject2</param>
        /// <returns>An HResult.</returns>

        public abstract HResult ProcessRequest(HttpContext context, TRequest request, out TResponse response);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FseBookmark.cs ===
// FseBookmark.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;

using STF.common.config;
using STF.common.service;

namespace STF.common.fse
{
    public class FseBookmark
    {

        private int          _minutesFloor = 0;
        private const string _minutesFloorSetting = "MinutesFloor";

        private int          _minutesThreshold = 60;
        private const string _minutesThresholdSetting = "MinutesThreshold";

        private int          _hoursFloor = 0;
        private const string _hoursFloorSetting = "HoursFloor";

        private int          _hoursThreshold = 24;
        private const string _hoursThresholdSetting = "HoursThreshold";

        private int          _daysFloor = 0;
        private const string _daysFloorSetting = "DaysFloor";

        private int          _daysThreshold = 14;
        private const string _daysThresholdSetting = "DaysThreshold";

        // prefix for settings to allow for per service bookmark settings
        private string _prefix;

        public FseBookmark() : this("fse") {
        }

        public FseBookmark(string prefix)
        {
            _prefix = (string.IsNullOrEmpty(prefix) ? "fse" : prefix) + "_bookmark";
            Config.SettingChange += new SettingChangeEventHandler(SettingChange);
            Load();
        }

        public DateTime Adjust(DateTime bookmark)
        {
            bool daysAdjust = false;
            bool hoursAdjust = false;
            DateTime now = DateTime.UtcNow;

            try
            {
                // we always get rid of the seconds and milliseconds
                bookmark = bookmark.AddSeconds(-bookmark.Second);
                bookmark = bookmark.AddMilliseconds(-bookmark.Millisecond);

                //
                if (Math.Abs((bookmark -now).TotalMinutes) >= _minutesThreshold)
                {
                    if (Math.Abs((bookmark -now).TotalHours) >= _hoursThreshold)
                    {
                        hoursAdjust = true;
                        
                        if (Math.Abs((bookmark -now).TotalDays) >= _daysThreshold)
                        {
                            daysAdjust = true;
                        }
                    }

                    if (bookmark.Minute < _minutesFloor) bookmark = bookmark.AddHours(-1);
                    bookmark = bookmark.AddMinutes(_minutesFloor - bookmark.Minute);
                }

                if (hoursAdjust)
                {
                    if (bookmark.Hour < _hoursFloor) bookmark = bookmark.AddDays(-1);
                    bookmark = bookmark.AddHours(_hoursFloor - bookmark.Hour);
                }

                if (daysAdjust)
                {
                    if ((int)bookmark.DayOfWeek < _daysFloor) bookmark = bookmark.AddDays(-7);
                    bookmark = bookmark.AddDays(_daysFloor - (int)bookmark.DayOfWeek);
                }
            }
            catch (ArgumentOutOfRangeException aoore)
            {
                throw new ParameterException(HResult.XONLINE_E_FSE_PARAM_INVALID_VALUE, "Invalid value for parameter 'Bookmark'", aoore);
            }

            return bookmark;
        }


        public int CheckSetting(string setting, string value, int minimum, int maximum) {

            int result;

            if (int.TryParse(value, out result))
            {
                if (minimum <= result && result <= maximum) return result;

                throw new ConfigException(
                    HResult.XONLINE_E_FSE_BOOKMARK_INVALID_SETTING,
                    string.Format("Bookmark setting '{0}' is out of range [{1}-{2}]", setting, minimum, maximum)
                );
            }

            throw new ConfigException(
                HResult.XONLINE_E_FSE_BOOKMARK_INVALID_SETTING,
                string.Format("Bookmark setting '{0}' is not an integer", setting)
            );
        }

        
        public void UpdateSetting(string setting, string value)
        {
            // settings coming into here have the prefix on them
            // strip that off to normalize to the  known  values

            switch (setting.Substring(_prefix.Length))
            {
                case _minutesThresholdSetting:
                    _minutesThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _minutesFloorSetting:
                    _minutesFloor = CheckSetting(setting, value, 0, 59);
                    break;

                case _hoursThresholdSetting:
                    _hoursThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _hoursFloorSetting:
                    _hoursFloor = CheckSetting(setting, value, 0, 23);
                    break;

                case _daysThresholdSetting:
                    _daysThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _daysFloorSetting: // 0 = Sunday, ... 6 = Saturday
                    _daysFloor = CheckSetting(setting, value, 0, 6);
                    break;
            }
        }

       // event handler after changes to t_settings or t_setting_overrides
        public void SettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            if (!eventArgs.Setting.StartsWith(_prefix)) return;
            UpdateSetting(eventArgs.Setting, eventArgs.ValueNew);
        }

        private string[] _settings = {
            _minutesFloorSetting, _minutesThresholdSetting,
            _hoursFloorSetting,   _hoursThresholdSetting,
            _daysFloorSetting,    _daysThresholdSetting
        };

        private void Load()
        {
            foreach (string setting in _settings) {
                try {
                    // update and config expects settings to be prefixed.
                    UpdateSetting(_prefix + setting, Config.GetSetting(_prefix + setting));
                } catch (ApplicationException) {
                    // it's okay if there is no setting
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\giprot.cs ===
// 
// GIProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Game Instrumentation Service Integration
// Xbox Online Service
// 

using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using STF.common.service;


namespace STF.common.protocol 
{
    public class GITypes
    {
        public const uint XONLINE_STAT_DATATYPE_MASK     = 0xF0000000;
        
        public const uint XONLINE_STAT_NULL              = 0x00000000;
        public const uint XONLINE_STAT_LONG              = 0x10000000;
        public const uint XONLINE_STAT_LONGLONG          = 0x20000000;
        public const uint XONLINE_STAT_DOUBLE            = 0x30000000;
        public const uint XONLINE_STAT_LPCWSTR           = 0x40000000;
        public const uint XONLINE_STAT_FLOAT             = 0x50000000;
        public const uint XONLINE_STAT_BINARY            = 0x60000000;
        public const uint XONLINE_STAT_DATETIME          = 0x70000000;
    }

    public class GIDefs
    {
        public const uint X_CONTEXT_PRESENCE            = 0x00008001;
        public const uint X_CONTEXT_GAME_TYPE           = 0x0000800A;
        public const uint X_CONTEXT_GAME_MODE           = 0x0000800B;
    }
    
    //
    // Basic Context name value pair. The value always corresponds to a localized label for display purposes
    //
    public class GIContext : WireData
    {
        public uint           Id;
        public uint           Value;

        public GIContext() { }
        public GIContext(uint id)
        {
            Id = id;
        }    
        public GIContext(uint id, uint value)
        {
            Id = id;
            Value = value;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                Id = binaryReader.ReadUInt32();
                Value = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_8, 
                    "Reached end of stream trying to read GIContext", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Id);
            binaryWriter.Write(Value);
        }

    }


    //
    // Property data for Game Instrumentation. This is the meat of how data is represented via instrumentation
    //
    public class GIProperty: WireData
    {
        public GIProperty() { }
        public GIProperty(uint id)
        {
            Id = id;

            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = (float)0.0;
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = (DateTime)DateTime.UtcNow;
                break;
                
            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = (double)0.0;
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = (int)0;
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = (long)0;
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                strValue = "";
                break;
            }            
        }    
        
        public GIProperty(uint id, float f)
        {
            Id = id;
            fValue = f;
            
            if ( (id & GITypes.XONLINE_STAT_FLOAT) != GITypes.XONLINE_STAT_FLOAT)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, DateTime dt)
        {
            Id = id;
            dtValue = dt;
            
            if ((id & GITypes.XONLINE_STAT_DATETIME) != GITypes.XONLINE_STAT_DATETIME)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, double d)
        {
            Id = id;
            dValue = d;

            if ( (id & GITypes.XONLINE_STAT_DOUBLE) != GITypes.XONLINE_STAT_DOUBLE)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, int n)
        {
            Id = id;
            nValue = n;

            if ( (id & GITypes.XONLINE_STAT_LONG) != GITypes.XONLINE_STAT_LONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, long l)
        {
            Id = id;
            lValue = l;

            if ( (id & GITypes.XONLINE_STAT_LONGLONG) != GITypes.XONLINE_STAT_LONGLONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, string str)
        {
            Id = id;
            strValue = str;

            if ( (id & GITypes.XONLINE_STAT_LPCWSTR) != GITypes.XONLINE_STAT_LPCWSTR)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, byte[] bin)
        {
            Id = id;
            binValue = bin;

            if ( (id & GITypes.XONLINE_STAT_BINARY) != GITypes.XONLINE_STAT_BINARY)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }            
        
        
        //
        // Data exposed to SOAP for web services
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors (these aren't serialized)
        //
        [XmlIgnore]
        public float fValue
        {
            get { return (float)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public DateTime dtValue
        {
            get { return (DateTime)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public double dValue
        {
            get { return (double)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public int nValue
        {
            get { return (int)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = binaryReader.ReadSingle();
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = DateTime.FromFileTimeUtc(binaryReader.ReadInt64());
                break;

            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = binaryReader.ReadDouble();
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = binaryReader.ReadInt32();
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = binaryReader.ReadInt64();
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                len = binaryReader.ReadUInt16();
                strValue = Encoding.Unicode.GetString(binaryReader.ReadBytes(len));
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                len = binaryReader.ReadUInt16();
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.COMMON_CODE_42, 
                    "Unrecgonized datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                binaryWriter.Write(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                binaryWriter.Write(Convert.ToDateTime(dtValue).ToFileTimeUtc());
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                binaryWriter.Write(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                binaryWriter.Write(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                binaryWriter.Write(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                {
                byte[] buf;
                
                buf = Encoding.Unicode.GetBytes(strValue);
                binaryWriter.Write((ushort)buf.Length);
                binaryWriter.Write(buf);
                }
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                binaryWriter.Write((ushort)binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.COMMON_CODE_43, 
                    "Unexpected datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }
        }

        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                str.Append(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                str.Append(dtValue);
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                str.Append(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                str.Append(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                str.Append(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                str.Append(strValue);
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                str.Append(ByteConvert.ToString(binValue));                    
                break;

            default:
                str.Append("null");
                break;
            }
            
            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FrontEndMapping.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Reflection;
using System.Web;

using STF.common.config;
using STF.common.exceptions;
using STF.common.service;
using STF.common.installer;
using STF.common.sql.sqlclient;

namespace STF.common.feapp
{
    internal class FrontEndMapping : Dictionary<string, XOService>
    {
        private string _xrl;

        private FrontEndMapping(string xrl)
        {
            _xrl = xrl.ToLower();
        }

        /// <summary>
        /// Return a list of interfaces that are valid for the mapping
        /// </summary>
        internal string[] Interfaces {
            get { 
                string[] interfaces = new string[Count];
                Keys.CopyTo(interfaces, 0);
                return interfaces;
            }
        }

        #region Static Methods

        // initialize the dictionary to empty.  that way if we fail
        // to load the mappings we can run without a null reference

        private static Dictionary<string, FrontEndMapping> _mappings = new Dictionary<string, FrontEndMapping>();
        private static string[] _interfaces = null;

        static FrontEndMapping()
        {
            List<string> interfaces = new List<string>();

            // get the list of interfaces on which we are  listening  by
            // reflecting on assembly attributes for XomIisConfigurators

            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies()) {
                foreach (XomInstallerAttribute attribute in assembly.GetCustomAttributes(typeof(XomInstallerAttribute), true)) {
                    if (attribute.ConfiguratorType != typeof(XomIisConfigurator)) continue;
                    interfaces.Add(attribute.InterfaceKey);
                }
            }

            Config.XrlMappingsChange += new XrlMappingsChangeEventHandler(OnXrlMappingsChange);
            LoadMappings(_interfaces = interfaces.ToArray());
        }

        /// <summary>
        /// Get mapping for the current call by taking the raw URL
        /// from the HTTP context as a key to lookup in our mappnig table
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
                                              
        internal static FrontEndMapping Get(HttpContext context) {
            return Get(context.Request.RawUrl.Split('?')[0].ToLower());
        }

        internal static FrontEndMapping Get(string xrl) {
            if (_mappings.ContainsKey(xrl)) return _mappings[xrl];
            throw new XblException(HResult.E_FAIL, "No mapping found for '" + xrl + "'");
        }

        private static void OnXrlMappingsChange(object sender, EventArgs e) {
            LoadMappings(_interfaces);
        }

        private static void LoadMappings(string[] interfaces) 
        {
            FrontEndMapping mapping;
            Dictionary<string, FrontEndMapping> mappings = new Dictionary<string, FrontEndMapping>(StringComparer.OrdinalIgnoreCase);

            // for each interface defined by this front end

            for (int i = 0; i < interfaces.Length; i++) 
            {
                using (SqlClient client = new SqlClient(Interface.npdb))
                {
                    // get the interface to get the vdir, vsite and service id

                    IInterfaceInfo interfaceInfo = Config.GetInterface(_interfaces[i]);
                    client.ClearParameters();

                    client.StoredProc = "p_xrlscan_get_valid_xrls";
                    client.AddParameter("@vc_server", Config.Server);
                    client.AddParameter("@vc_vdir", interfaceInfo.VDir);
                    client.AddParameter("@vc_vsite", interfaceInfo.VSite);

                    // add the mapping records for each xrl. if there is
                    // is already a mapping just add the interface to it

                    using (SqlDataReader reader = client.Execute())
                    {
                        while (reader.Read())
                        {
                            string xrl = reader.GetString(reader.GetOrdinal("vc_xrl"));

                            // check if there is an existing mapping. if
                            // not then we create a new one for this xrl

                            if (!mappings.TryGetValue(xrl, out mapping)) {
                                mappings[xrl] = mapping = new FrontEndMapping(xrl);
                            }

                            // add this interface to the    xrl  mapping
                            mapping.Add(interfaceInfo.Interface, (XOService) interfaceInfo.ServiceId);
                        }
                    }
                }
            }

            // replace original mapping dictionary with new dictionary
            _mappings = mappings;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FseExceptions.cs ===
// FseExceptions.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;

using STF.common.service;

namespace STF.common.fse
{
    public class FseException : Exception, ExceptionWithHResult {
        protected FseException(HResult hr, string message)
            : base(message)
        {
            HResult = hr;
        }

        protected FseException(HResult hr, string message, Exception innerException)
            : base(message, innerException)
        {
            HResult = hr;
        }

        public new HResult HResult
        {
            get { return (HResult) (uint) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }

    public class ConfigException : FseException {
        internal ConfigException(HResult hr, string message)
            : base(hr, message)
        {
        }

        internal ConfigException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class InternalException : FseException {
        internal InternalException(HResult hr, string message)
            : base(hr, message)
        {
        }

        internal InternalException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class MethodException : FseException, ExceptionWithoutEvent {
        internal MethodException(HResult hr, string message)
            : base(hr, message)
        {
        }

        internal MethodException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class ParameterException : FseException, ExceptionWithoutEvent {
        internal ParameterException(HResult hr, string message)
            : base(hr, message)
        {
        }

        internal ParameterException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class CacheException : FseException {
        internal CacheException(HResult hr, string message)
            : base(hr, message)
        {
        }

        internal CacheException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class ApplicationException : FseException
    {
        public ApplicationException(HResult hr, string message)
            : base(hr, message)
        {
        }

        public ApplicationException(HResult hr, string message, Exception innerException)
            : base(hr, message, innerException)
        {
        }
    }

    public class DatabaseException : FseException
    {
        public DatabaseException(HResult hr, string message)
            : base(hr, message)
        {
        }

        public DatabaseException(HResult hr, string message, Exception innerException)
            : base(hr, message, ((innerException is XRLException) && (innerException.InnerException != null)) ? innerException.InnerException : innerException)
        {
        }
    }

    public class UnhandledException : ExceptionWithEventId, ExceptionWithHResult
    {
        public UnhandledException(HResult hr, XEvent.Id eventId, string message) : base(eventId, message)
        {
            HResult = hr;
        }

        public UnhandledException(HResult hr, XEvent.Id eventId, string message, Exception innerException) : base(eventId, message, innerException)
        {
            HResult = hr;
        }

        public new HResult HResult
        {
            get { return (HResult) (uint) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\HelperWrapperManaged.cs ===
/* This file was generated by:
 * 1: Build the native version of CryptoWrapper.dll
 * 2: Run that through tlbimp.exe:
 *      tlbimp CryptoWrapper.dll /namespace:STF.common.crypto /out:HELPERWRAPPERLib.dll
 * 3: Run the .net reflector on HELPERWRAPPERLib.dll
 *      reflector HELPERWRAPPERLib.dll
 *      expand STF.common.crypto
 *      expand HELPERWRAPPERLib.dll
 *      right-click STF.common.crypto, select "disasemble"
 *      On the right-hand pane, click "expand types"
 *      Replace this file's HELPERWRAPPERLib namespace with that from the reflector
 *      Also, all the interfaces and classes must be declared as *internal* rather than *public*.
 *          If you don't do this, anything that references both a dll that builds this file
 *          and this file itself will fail to build.
 *      Build
 *      Profit
 */

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace STF.common.crypto
{
    [ComImport, TypeLibType((short) 0x1040), Guid("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")]
    public interface IXoCryptoWrapper
    {
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        byte[] XOCryptGenRandomWrp([In] uint ulDataSize);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        byte[] DecryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint pulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        void GenPPAforDBWrp([In, MarshalAs(UnmanagedType.BStr)] string bstrName, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] ppsaKey, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaSPPA, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaPPA);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        byte[] EncryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint cbPublicKey, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaPublicKey, [In] uint ulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaDecData);
    }

    [ComImport, TypeLibType((short) 0x1040), Guid("86BA703A-DEDA-42DC-8A27-622F39B13D9F")]
    internal interface IXoKeyEncryptionHelperWrp
    {
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        void Init([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] saKEK);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        void Terminate();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        void GenerateNewKey([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaRawData);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        byte[] DecryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaIV, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(5)]
        void EncryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaRawData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData);
    }

    [ComImport, CoClass(typeof(XoCryptoWrapperClass)), Guid("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")]
    public interface XoCryptoWrapper : IXoCryptoWrapper
    {
    }

    [ComImport, ClassInterface((short) 0), TypeLibType((short) 2), Guid("007CDE6D-353E-4F97-98E2-B351D009BD1B")]
    public class XoCryptoWrapperClass : IXoCryptoWrapper, XoCryptoWrapper
    {
        // Methods
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        public virtual extern byte[] DecryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint pulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncData);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        public virtual extern byte[] EncryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint cbPublicKey, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaPublicKey, [In] uint ulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaDecData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        public virtual extern void GenPPAforDBWrp([In, MarshalAs(UnmanagedType.BStr)] string bstrName, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] ppsaKey, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaSPPA, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaPPA);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        public virtual extern byte[] XOCryptGenRandomWrp([In] uint ulDataSize);
    }

    [ComImport, Guid("86BA703A-DEDA-42DC-8A27-622F39B13D9F"), CoClass(typeof(XoKeyEncryptionHelperWrpClass))]
    internal interface XoKeyEncryptionHelperWrp : IXoKeyEncryptionHelperWrp
    {
    }

    [ComImport, ClassInterface((short) 0), Guid("50C34C88-45C4-483F-94A5-FEB32E6E2A71"), TypeLibType((short) 2)]
    internal class XoKeyEncryptionHelperWrpClass : IXoKeyEncryptionHelperWrp, XoKeyEncryptionHelperWrp
    {
        // Methods
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        public virtual extern byte[] DecryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaIV, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(5)]
        public virtual extern void EncryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaRawData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        public virtual extern void GenerateNewKey([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaRawData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        public virtual extern void Init([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] saKEK);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        public virtual extern void Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IComponentInfo.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(true)]
[Guid("058EE87C-C7AD-4342-A769-B99A055F1DC4")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IComponentInfo
{
    string Component
    {
        get;
    }

    string Executable
    {
        get;
    }

    Installer Installer
    {
        get;
    }

    string Username
    {
        get;
    }

    string Password
    {
        get;
    }

    string Info1
    {
        get;
    }

    string Info2
    {
        get;
    }

}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IBucketServer.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(true)]
[Guid("FFF88330-DB97-428A-B61D-B857F4FE30CB")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IBucketServer
{
    IInterfaceInfo CurrentServer { get; }
    IInterfaceInfo NextServer  { get; }
    string CurrentServerName { get; }
    string NextServerName  { get; }
    DateTime NextServerStart  { get; }
    string Info1 { get; }
    string Info2 { get; }
    string Info3 { get; }
    string Info4 { get; }

    string ToString();
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\HTTPUtils.cs ===
namespace STF.common.protocol
{



    public class HTTPHeaders
    {
        //See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html

        public const string IfModifiedSince = "If-Modified-Since";
        public const string CacheControl = "Cache-Control";
        public const string LastModified = "Last-Modified";
        public const string ContentType = "Content-Type";
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IConfig.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7100")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IServerListChangeEventArgs
{
    string Environment { get; }
    string Interface { get; }
    string[] ValueOld { get; }
    string[] ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7101")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IInterfaceChangeEventArgs
{
    string Environment { get; }
    string Server { get; }
    string Interface { get; }
    IInterfaceInfo ValueOld { get; }
    IInterfaceInfo ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7102")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IInterfaceBucketChangeEventArgs
{
    string Environment { get; }
    uint TitleId { get; }
    uint Bucket { get; }
    string Interface { get; }
    IBucketServer ValueOld { get; }
    IBucketServer ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7103")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVirtualInterfaceChangeEventArgs
{
    string Environment { get; }
    int SiteId { get; }
    string VirtualInterface { get; }
    IVirtualInterfaceInfo ValueOld { get; }
    IVirtualInterfaceInfo ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7104")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVirtualInterfaceListChangeEventArgs
{
    string Environment { get; }
    int SiteId { get; }
    string[] ValueOld { get; }
    string[] ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7105")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface ISettingChangeEventArgs
{
    string Environment { get; }
    int SiteId { get; }
    string Server { get; }
    string Component { get; }
    string Setting { get; }
    string ValueOld { get; }
    string ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7106")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IMultiSettingChangeEventArgs
{
    string Environment { get; }
    int SiteId { get; }
    string Server { get; }
    string Component { get; }
    string MultiSetting { get; }
    string[] ValueOld { get; }
    string[] ValueNew { get; }
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7107")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IConfigListener
{
    void ServerListChange(IServerListChangeEventArgs e);
    void InterfaceChange(IInterfaceChangeEventArgs e);
    void InterfaceBucketChange(IInterfaceBucketChangeEventArgs e);
    void VirtualInterfaceChange(IVirtualInterfaceChangeEventArgs e);
    void VirtualInterfaceListChange(IVirtualInterfaceListChangeEventArgs e);
    void SettingChange(ISettingChangeEventArgs e);
    void MultiSettingChange(IMultiSettingChangeEventArgs e);
    void GameConfigChange();
    void XdelaySettingsChange();
    void XrlMappingsChange();
}

[ComVisible(true)]
[Guid("EF8B1B06-3D19-4755-86E6-4F1B3B7A7108")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IConfig
{
    IConfigListener ConfigListener { set; }

    // C++ has no easy way to translate from an enum value to
    // the corresponding string the way C# does, so I'm providing
    // these utility functions in this interface so C++ code
    // can ask the C# code to do the translation. This can be
    // useful for event and log text.
    string InstallUnitToString(string installUnit);
    string ComponentToString(string component);
    string InterfaceToString(string iface);
    string VirtualInterfaceToString(string viface);
    string SettingToString(string setting);
    string MultiSettingToString(string multiSetting);

    string InstallerToString(Installer installer);
    string SiteToString(Site site);

    string Environment { get; }
    int SiteId { get; }
    string Server { get; }
    string ServerSet_TestOnly_DoNotUse { set; }
    string Component { get; }
    string ComponentName { get; set; }
    int ReportMessageComponentId { get; }
    string ReportMessageCleanserVirtualInterface { get; }

    void AddReportMessageComponentIdMapping(string component, int reportMessageId);

    void CheckForUpdates();

    void GetServerInfo(string server, out int siteId);
    string[] GetServerListByInterface(string iface);
    IInterfaceInfo GetInterface(string server, string iface);
    IInterfaceInfo GetInterface(string iface);
    IBucketServer GetBucketServer(string iface, uint bucket);
    IBucketServer GetTitleBucketServer(string iface, uint titleId, uint bucket);
    uint GetBucketNum(string iface, ulong hashValue);
    uint GetBucketCount(string iface);
    void CompleteMigration(string iface, uint bucket);
    void CompleteTitleMigration(string iface, uint titleId, uint bucket);
    IInterfaceInfo GetSingleInterface(string iface);
    string[]  GetVirtualInterfaceListBySite(Site site);
    string[]  GetVirtualInterfaceListBySite(int siteId);
    IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(Site site);
    IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(int siteId);
    IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, int siteId);
    bool GetBoolSetting(string setting);
    int GetIntSetting(string setting);
    uint GetUIntSetting(string setting);
    uint GetUIntIpSetting(string setting);
    long GetLongSetting(string setting);
    ulong GetULongSetting(string setting);
    double GetDoubleSetting(string setting);
    string GetSetting(string setting);    
    string[] GetMultiSetting(string multiSetting);
    string[] GetMultiSetting(string component, string multiSetting);
    string[] GetMultiSetting(
        string environment,
        int siteId,
        string server,
        string component,
        string multiSetting);
    string[] GetInstallUnitListByServer(string server);
    string[] GetInstallUnitListByServer(string environment, string server);
    IInstallUnitInfo[] GetInstallUnitInfoByServer(string server);
    IInstallUnitInfo[] GetInstallUnitInfoByServer(string environment, string server);
    IInstallUnitInfo GetInstallUnit(string installUnit);
    string[] GetComponentListByServer(string server);
    string[] GetComponentListByServer(string environment, string server);
    IComponentInfo[] GetComponentInfoByServer(string server);
    IComponentInfo[] GetComponentInfoByServer(string environment, string server);
    IComponentInfo GetComponent(string component);
    string[]  GetInterfaceListByServer(string server);
    string[]  GetInterfaceListByServer(string environment, string server);
    IInterfaceInfo[] GetInterfaceInfoByServer(string server);
    IInterfaceInfo[] GetInterfaceInfoByServer(string environment, string server);
    void DiscardCachedValues();
    string NpdbDatabase { get; }
    string NpdbServer { get; }
    string NpdbConnectionString { get; }

    void RegisterDynamicSetting(string setting);

    void VetoInterfaceBucketChange();
    void VetoInterfaceChange();
    void VetoMultiSettingChange();
    void VetoServerListChange();
    void VetoSettingChange();
    void VetoVirtualInterfaceChange();
    void VetoVirtualInterfaceListChange();
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\HResultAttributes.cs ===
﻿// 
// HResultAttributes.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Attributes that get applied to the HResult struct when
// used from XblCore.dll.
//

using System;
using System.Xml;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

namespace STF.common.service
{
    /// <summary>
    /// You may be asking yourself why we are doing this?  Well...
    /// The reason is that we want to be able to use the HResult class
    /// by itself without pulling in the rest of the Xbox Live world.
    /// Specifically, the WireInfoAttribute class references Config.
    /// 
    /// This was done originally for Azure Hosted Services that use
    /// XblSamlToken (and HResult by reference), but separating this
    /// out may have other applications in the future.
    /// </summary>
    [ComVisible(false)]
    [XmlSchemaProvider("HResultSchema")]
    [WireInfo(SerializeAs = typeof(uint))]
    public partial struct HResult : IEquatable<HResult>, IXmlSerializable
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\InstallUnitInfo.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(false)]
public class InstallUnitInfo : IInstallUnitInfo
{
    private string _installUnit = "";
    private string _info1 = null;
    private string _info2 = null;
    private string _info3 = null;
    private string _info4 = null;

    public string InstallUnit
    {
        get { return _installUnit; }
        set { _installUnit = value; }
    }

    public string Info1
    {
        get { return _info1; }
        set { _info1 = value; }
    }

    public string Info2
    {
        get { return _info2; }
        set { _info2 = value; }
    }

    public string Info3
    {
        get { return _info3; }
        set { _info3 = value; }
    }

    public string Info4
    {
        get { return _info4; }
        set { _info4 = value; }
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IInterfaceInfo.cs ===
using System;
using System.Net;
using System.Runtime.InteropServices;

namespace STF.common.config
{
[ComVisible(true)]
[Guid("D8FE4B71-D23C-444A-B044-CC64AE4B5337")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IInterfaceInfo
{
    string Interface
    {
        get;
    }

    string Protocol
    {
        get;
    }

    IPAddress IPAddress
    {
        get;
    }

    string IPAddressString
    {
        get;
    }

    uint IPAddressDword
    {
        get;
    }

    IPAddress IPNetMask
    {
        get;
    }

    string IPNetMaskString
    {
        get;
    }

    uint IPNetMaskDword
    {
        get;
    }

    IPAddress IPDefaultGateway
    {
        get;
    }

    string IPDefaultGatewayString
    {
        get;
    }

    uint IPDefaultGatewayDword
    {
        get;
    }

    int Port
    {
        get;
    }

    int PortEnd
    {
        get;
    }

    string VSite
    {
        get;
    }

    int VSiteId
    {
        get;
    }

    string VDir
    {
        get;
    }

    string DBName
    {
        get;
    }

    string Sharename
    {
        get;
    }

    int Timeout
    {
        get;
    }

    int ServiceId
    {
        get;
    }

    string ServiceName
    {
        get;
    }

    string Mac
    {
        get;
    }

    IPAddress SgIpAddressBegin
    {
        get;
    }

    string SgIpAddressBeginString
    {
        get;
    }

    uint SgIpAddressBeginDword
    {
        get;
    }

    IPAddress SgIpAddressEnd
    {
        get;
    }

    string SgIpAddressEndString
    {
        get;
    }

    uint SgIpAddressEndDword
    {
        get;
    }

    int SgPortBegin
    {
        get;
    }

    int SgPortEnd
    {
        get;
    }

    bool NeedSGInfo
    {
        get;
    }

    IPAddress WiretapIpAddress
    {
        get;
    }

    string WiretapIpAddressString
    {
        get;
    }

    uint WiretapIpAddressDword
    {
        get;
    }

    bool NicDisabled
    {
        get;
    }

    string Username
    {
        get;
    }

    string Password
    {
        get;
    }

    string Info1
    {
        get;
    }

    string Info2
    {
        get;
    }

    string ServerName
    {
        get;
    }

    [ComVisible(false)]
    int? MinConnectionPoolSize
    {
        get;
    }

    [ComVisible(false)]
    int? MaxConnectionPoolSize
    {
        get;
    }

    [ComVisible(false)]
    int? LoadBalanceTimeout
    {
        get;
    }

    [ComVisible(false)]
    int? ConnectionTimeout
    {
        get;
    }

    Uri Url
    {
        get;
    }

    string SqlConnectionString
    {
        get;
    }

    string GetNotificationUrl(string notification);

    string ToString();
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IInstallUnitInfo.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(true)]
[Guid("497FC85F-6415-4C02-9E13-E6AC77B80D52")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IInstallUnitInfo
{
    string InstallUnit
    {
        get;
    }

    string Info1
    {
        get;
    }

    string Info2
    {
        get;
    }

    string Info3
    {
        get;
    }

    string Info4
    {
        get;
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\HttpContextAdapter.cs ===
// 
// HttpContextAdapter.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Provides a wrapper around either an IIS HttpContext or an HttpListener 
// HttpListenerContext.
// 
// Author: kgoodier 5/2010
//

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Serialization;
using System.Net;
using System.Security.Principal;

// WCF
using System.ServiceModel;
using System.ServiceModel.Channels;


namespace STF.common.service
{

// --------------------------------------------------------------------------------------
// HttpContextAdapter
//
// Provides a common interface in front of HttpContext and HttpListenerContext objects.  
// This is the bare set of what we need at the moment; please add more as needed.
// --------------------------------------------------------------------------------------
public class HttpContextAdapter : IDisposable
{
    public IHttpRequestAdapter      Request { get; private set; }
    public IHttpResponseAdapter     Response { get; private set; }
    public IDictionary              Items { get; private set; }
    private object                  OriginalContext { get; set; }

    public HttpContextAdapter(HttpContext iisCtx)
    {
        OriginalContext = iisCtx;
        Request = new IisRequestAdapter(iisCtx);
        Response = new IisResponseAdapter(iisCtx);
        Items = iisCtx.Items;
        Current = this;
    }

    public HttpContextAdapter(HttpListenerContext hlCtx)
    {
        OriginalContext = hlCtx;
        Request = new HttpListenerRequestAdapter(hlCtx);
        Response = new HttpListenerResponseAdapter(hlCtx);
        Items = new Hashtable();
        Current = this;
    }

    public HttpContextAdapter(OperationContext opCtx)
    {
        // Note the Wcf adapters are not fully implemented, in particular the Response 
        // interface. We're mostly using it as a bridge to the http headers and remote 
        // endpoint.
        OriginalContext = opCtx;
        Request = new WcfRequestAdapter(opCtx);
        Response = new WcfResponseAdapter(opCtx);
        Items = new Hashtable();
        Current = this;
    }

    public void Dispose()
    {
        Request.Dispose();
        Response.Dispose();
        Request = null;
        Response = null;
        Items = null;
        OriginalContext = null;

        if (_Current == this)
        {
            _Current = null;
        }
    }

    [ThreadStatic]
    private static HttpContextAdapter _Current;

    /// <summary>
    /// Get the current HttpContextAdapter automatically if you are using ASP.Net or
    /// WCF. Does not work for HttpListener.
    /// </summary>
    public static HttpContextAdapter Current
    {
        get
        {
            if (HttpContext.Current != null)
            {
                if (_Current == null || HttpContext.Current != _Current.OriginalContext)
                {
                    _Current = new HttpContextAdapter(HttpContext.Current);
                }
            }
            else if (OperationContext.Current != null)
            {
                if (_Current == null || OperationContext.Current != _Current.OriginalContext)
                {
                    _Current = new HttpContextAdapter(OperationContext.Current);
                }
            }
            return _Current;
        }
        set
        {
            _Current = value;
        }
    }

    // @@@ TODO: add a Current property that is thread static, and is reset upon the start
    // and end of every request. Tricky.

    #region Interfaces

    // {{{ Interfaces 

// --------------------------------------------------------------------------------------
// IHttpRequestAdapter
//
// Provides a common interface in front of HttpRequest and HttpListenerRequest objects.  
// --------------------------------------------------------------------------------------
public interface IHttpRequestAdapter : IDisposable
{
    Uri                 Url { get; }
    string              HttpMethod { get; }
    long                ContentLength { get; }
    IPEndPoint          LocalEP { get; }
    IPEndPoint          RemoteEP { get; }
    NameValueCollection Headers { get; }
    NameValueCollection QueryString { get; }

    Stream              InputStream { get; }
}

// --------------------------------------------------------------------------------------
// IHttpResponseAdapter
//
// Provides a common interface in front of HttpResponse and HttpListenerResponse objects.  
// --------------------------------------------------------------------------------------
public interface IHttpResponseAdapter : IDisposable
{
    // Response
    int                 StatusCode { get; set; }
    string              ContentType { get; set; }
    TextWriter          Output { get; }

    void BinaryWrite(byte[] data);

}

// interfaces }}}

    #endregion

    #region IIS Request/Response Adapters
// {{{ IIS Request / Response adapters

// --------------------------------------------------------------------------------------
// IisRequestAdapter
// --------------------------------------------------------------------------------------
private class IisRequestAdapter : IHttpRequestAdapter
{
    private HttpRequest _req;

    public IisRequestAdapter(HttpContext ctx)
    {
        _req = ctx.Request;
    }

    public void Dispose()
    {
        // nothing to do
    }

    public Uri Url 
    { 
        get 
        {
            return _req.Url;
        }
    }

    public string HttpMethod 
    { 
        get
        {
            return _req.HttpMethod;
        }
    }

    public long ContentLength 
    { 
        get
        {
            return (long)_req.ContentLength;
        }
    }

    public IPEndPoint LocalEP 
    { 
        get
        {
            int localPort;

            // Helper from xrlscan
            string serverPort = _req.Headers[XHttpHdr.SERVERPORT];
            if (serverPort != null)
            {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                localPort = (int)Convert.ToUInt16(serverPort);
            }
            else
            {
                localPort = (int)(_req.Url.Port);
            }

            // kgoodier: I cannot find a way to get the local IP in IIS/ASP.NET. That's 
            // ok, since our code only ever needs the local port anyway.  
            //
            // _req.ServerVariables["SERVER_NAME"]
            // - returns "The server's host name, DNS alias, or IP address as it would 
            // appear in self-referencing URLs."
            return new IPEndPoint(IPAddress.Loopback, localPort);
        }
    }

    public IPEndPoint RemoteEP 
    { 
        get
        {
            IPAddress srcIP;
            int srcPort;
            string sgIPPort = _req.Headers[XHttpHdr.SGIPPORT];
            if (sgIPPort != null)
            {
                // Header added by xrlscan/udpadapter
                int colon = sgIPPort.IndexOf(':');
                if (colon > -1)
                {
                    srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
                    srcPort = (int)Convert.ToUInt16(sgIPPort.Substring(colon + 1));
                    return new IPEndPoint(srcIP, srcPort);
                }
            }
            srcIP = IPAddress.Parse(_req.UserHostAddress);
            srcPort = (int)Convert.ToUInt16(_req.ServerVariables.Get("REMOTE_PORT"));
            return new IPEndPoint(srcIP, srcPort);
        }
    }

    public NameValueCollection Headers 
    { 
        get
        {
            return _req.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get 
        {
            return _req.QueryString;
        }
    }

    public Stream InputStream 
    { 
        get
        {
            return _req.InputStream;
        }
    }

}

// --------------------------------------------------------------------------------------
// IisResponseAdapter
// --------------------------------------------------------------------------------------
private class IisResponseAdapter : IHttpResponseAdapter
{
    private HttpResponse _resp;

    public IisResponseAdapter(HttpContext ctx)
    {
        _resp = ctx.Response;
    }

    public void Dispose()
    {
        // nothing to do
    }

    public int StatusCode
    {
        get { return _resp.StatusCode; }
        set { _resp.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _resp.ContentType; }
        set { _resp.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return _resp.Output; }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            // We want to avoid the use of _resp.BinaryWrite since that isn't 
            // allowed by .Net for local instances of HttpContext (i.e., ones constructed 
            // by the tests). So we'll work around it by converting our bytes to UTF8 
            // characters and writing those.
            
            int count = data.Length;
            char[] charData = new char[count];
            MemoryStream ms = new MemoryStream(data, 0, count);
            StreamReader sr = new StreamReader(ms, Encoding.UTF8, true);

            // Read all characters at once. Not ideal, but our stylesheets won't ever be 
            // *that* large. Some notes from Ian:
            //
            // note that according to 
            // http://msdn.microsoft.com/en-us/library/9kstw824(VS.80).aspx there is room 
            // for a performance improvement here by:
            //  1. specifying the size of the internal buffer in the Streamreader 
            //  constructor to some desired block size
            //  2. locking the output charData array to the same size as that internal 
            //  buffer and 
            //  3. repeatedly reading slightly fewer characters than will fit into that 
            //  destination array and writing the data to the response stream in multiple 
            //  passes until all the characters have been read from the StreamReader

            // read out up to count chars (the number of chars cannot exceed count since 
            // chars are at least 1 byte each)
            int charsRead = sr.Read(charData, 0, count);

            // write the retrieved chars out to the resopnse stream, using the real number 
            // of chars found in the UTF-8 stream rather than the number of bytes passed 
            // in initially. This avoid use of the HttpResponse.OutputStream (instead uses 
            // the Writer), and thus no exception for our tests.
            _resp.Write(charData, 0, charsRead);
        }
    }


}

// IIS }}}

    #endregion

    #region HttpListener Request/Response Adapters
// {{{ HttpListener Request / Response adapters

// --------------------------------------------------------------------------------------
// HttpListenerRequestAdapter
// --------------------------------------------------------------------------------------
private class HttpListenerRequestAdapter : IHttpRequestAdapter
{
    private HttpListenerRequest _req;
    private MemoryStream        _OutputStorage;

    public HttpListenerRequestAdapter(HttpListenerContext ctx)
    {
        _req = ctx.Request;
        _OutputStorage = new MemoryStream();
    }

    public void Dispose()
    {
    }

    public Uri Url 
    { 
        get 
        {
            return _req.Url;
        }
    }

    public string HttpMethod 
    { 
        get
        {
            return _req.HttpMethod;
        }
    }

    public long ContentLength 
    { 
        get
        {
            return _req.ContentLength64;
        }
    }

    public IPEndPoint LocalEP 
    { 
        get
        {
            return _req.LocalEndPoint;
        }
    }

    public IPEndPoint RemoteEP 
    { 
        get
        {
            return _req.RemoteEndPoint;
        }
    }

    public NameValueCollection Headers 
    { 
        get
        {
            return _req.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get 
        {
            return _req.QueryString;
        }
    }

    public Stream InputStream 
    { 
        get
        {
            return _req.InputStream;
        }
    }
}

// --------------------------------------------------------------------------------------
// HttpListenerResponseAdapter
// --------------------------------------------------------------------------------------
private class HttpListenerResponseAdapter : IHttpResponseAdapter
{
    private HttpListenerResponse _resp;
    private MemoryStream         _OutputStorage;

    public HttpListenerResponseAdapter(HttpListenerContext ctx)
    {
        _resp = ctx.Response;
        _OutputStorage = new MemoryStream();
    }

    public void Dispose()
    {
        CloseOutput();
    }

    public int StatusCode
    {
        get { return _resp.StatusCode; }
        set { _resp.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _resp.ContentType; }
        set { _resp.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return new StreamWriter(_OutputStorage); }  //return new StreamWriter(_resp.OutputStream); }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            //_resp.OutputStream.Write(data, 0, data.Length);
            BinaryWriter bw = new BinaryWriter(_OutputStorage);
            bw.Write(data);
        }
    }

    // Extra method for annoying outputstream cleanup
    private void CloseOutput()
    {
        byte[] data = _OutputStorage.GetBuffer();
        long dataLength = _OutputStorage.Length;
        // data.Length is probably larger than _OutputStorage.Length, fyi. It represents 
        // the total buffer size.

        _resp.ContentLength64 = dataLength;
        _resp.OutputStream.Write(data, 0, (int)dataLength);
        _resp.OutputStream.Close();
    }

}

    // HttpListener }}}

    #endregion

    #region WCF Request/Response Adapters
// {{{ WCF Request/Response adapters

// --------------------------------------------------------------------------------------
// WcfRequestAdapter
// --------------------------------------------------------------------------------------
private class WcfRequestAdapter : IHttpRequestAdapter
{
    private OperationContext                _ctx;
    private RemoteEndpointMessageProperty   _endpointProperty;
    private HttpRequestMessageProperty      _httpRequestProperty;

    public WcfRequestAdapter(OperationContext ctx)
    {
        _ctx = ctx;
        if (ctx != null)
        {
            MessageProperties messageProperties = ctx.IncomingMessageProperties;
            _endpointProperty = (RemoteEndpointMessageProperty)messageProperties[RemoteEndpointMessageProperty.Name];
            _httpRequestProperty = (HttpRequestMessageProperty)messageProperties[HttpRequestMessageProperty.Name];
        }
    }

    public void Dispose()
    {
    }

    public Uri Url
    {
        get
        {
            return _ctx.IncomingMessageHeaders.To;
        }
    }

    public string HttpMethod
    {
        get
        {
            return _httpRequestProperty.Method;
        }
    }

    public long ContentLength
    {
        get
        {
            throw new NotImplementedException();
        }
    }

    public IPEndPoint LocalEP
    {
        get
        {
            throw new NotImplementedException();
        }
    }

    public IPEndPoint RemoteEP
    {
        get
        {
            return new IPEndPoint(IPAddress.Parse(_endpointProperty.Address), _endpointProperty.Port);
        }
    }

    public NameValueCollection Headers
    {
        get
        {
            return _httpRequestProperty.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get
        {
            return HttpUtility.ParseQueryString(_httpRequestProperty.QueryString);
        }
    }

    public Stream InputStream
    {
        get
        {
            throw new NotImplementedException();
        }
    }
}

// --------------------------------------------------------------------------------------
// WcfResponseAdapter
// --------------------------------------------------------------------------------------
private class WcfResponseAdapter : IHttpResponseAdapter
{
    private OperationContext    _ctx;

    public WcfResponseAdapter(OperationContext ctx)
    {
        _ctx = ctx;
    }

    public void Dispose()
    {
    }

    public int StatusCode
    {
        get { throw new NotImplementedException(); }
        set { throw new NotImplementedException(); }
    }

    public string ContentType
    {
        get { throw new NotImplementedException(); }
        set { throw new NotImplementedException(); }
    }

    public TextWriter Output
    {
        get { throw new NotImplementedException(); }
    }

    public void BinaryWrite(byte[] data)
    {
        throw new NotImplementedException();
    }
}

    // Wcf }}}

#endregion

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IpRangeList.cs ===
// 
// IpRangeList.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// IpRangeList class
// Xbox Online Service
//
//
// Author: kgoodier 9/2007
//

using System;
using System.Text;
using System.Collections.Generic;
using System.Net;
using System.Runtime.InteropServices;
using System.Threading;


// "a reference to a volatile field will not be treated as volatile"
#pragma warning disable 420

namespace STF.common.utilities2
{


// -----------------------------------------------------------------------------------
// IpRangeList
//
// Provides a mapping of IP addresses to some record. Also maps a range of ips to a single 
// base IP.  
// -----------------------------------------------------------------------------------
[ComVisible(false)]
public class IpRangeList<TValue> 
    where TValue : IIpRangeUserRecord, new()
{
    public IpRangeList()
    {
    }

    public IpRangeList(string[] ipOverrideSettings)
    {
        Reload(ipOverrideSettings);
    }


    // -------------------------------------------------------------------------------
    // Lookup - maps a given ip to a record, taking into consideration ip ranges. Returns 
    // true if record was found, or false if not. If false is returned, ipMapped will be 
    // set to ip.
    // -------------------------------------------------------------------------------
    internal bool Lookup(IPAddress ip, out IPAddress ipMapped, out TValue userRecord)
    {

        // Get local copy of list in case it gets swapped out on us
        List<IpRangeListRecord<TValue> > ipList = _IpList;

        IpRangeListRecord<TValue> dummyRecord = new IpRangeListRecord<TValue>(ip);
        int index = ipList.BinarySearch(dummyRecord);

        if (index < 0)
        {
            ipMapped = ip;
            userRecord = default(TValue);
            return false;
        }

        ipMapped = new IPAddress(ipList[index].IpBase);
        userRecord = ipList[index].UserRecord;
        return true;
    }


    // -------------------------------------------------------------------------------
    // Reload - given an array of ip override settings, configures the internal data 
    // structure.
    //
    // Format for each setting. "ip" is required. "ipEnd" is optional and allows an 
    // inclusive range to be defined. Any other parameters are passed directly to the 
    // IIpRangeUserRecord "SetParam" method.
    //
    //   ip=<ip address>;[ipEnd=<ip address>;][param1=value1;][param2=value2;]...
    //
    // Examples:
    //   ip=10.198.102.210;throttle=2
    //   ip=10.198.102.220;ipEnd=10.198.102.230;throttle=10
    // -------------------------------------------------------------------------------
    internal void Reload(string[] ipOverrideSettings)
    {
        // Local copy!
        List<IpRangeListRecord<TValue> > ipList = new List<IpRangeListRecord<TValue> >();

        // Add them all
        foreach (string setting in ipOverrideSettings)
        {
            IpRangeListRecord<TValue> record = new IpRangeListRecord<TValue>(setting);
            ipList.Add(record);
        }

        // Sort 'em
        ipList.Sort();

        // Validate no illegal ranges. Easy to do by walking through the now-sorted list.
        IpRangeListRecord<TValue> prevRecord = null;
        foreach (IpRangeListRecord<TValue> record in ipList)
        {
            if (prevRecord != null)
            {
                if (prevRecord.OverlapsWith(record))
                {
                    throw new ArgumentException(String.Format(
                            "Range {0} overlaps with {1}",
                            prevRecord,
                            record));
                }
            }
            prevRecord = record;
        }

        // Swap in new one. Interlocked.Exchange will ensure a memory barrier.
        Interlocked.Exchange(ref _IpList, ipList);
    }
   
    public override string ToString()
    {
        // Local copy!
        List<IpRangeListRecord<TValue> > ipList = _IpList;
        StringBuilder sb = new StringBuilder();

        foreach (IpRangeListRecord<TValue> record in ipList)
        {
            sb.Append(record + "\r\n");
        }
        return sb.ToString();
    }

    private volatile List<IpRangeListRecord<TValue> > _IpList = null;
    
}


// -----------------------------------------------------------------------------------
// IIpRangeUserRecord
//
// This is to be implemented by any consumers of the IpRangeList class. 
//
// -----------------------------------------------------------------------------------
[ComVisible(false)]
public interface IIpRangeUserRecord 
{
    void SetParam(string paramName, string paramValue);
}



// -----------------------------------------------------------------------------------
// IpRangeListRecord
//
// Internal class that gets plopped into our List.
// -----------------------------------------------------------------------------------
internal class IpRangeListRecord<TValue> : IComparable
    where TValue : IIpRangeUserRecord, new()
{

    // -------------------------------------------------------------------------------
    // Default constructor
    // -------------------------------------------------------------------------------
    internal IpRangeListRecord()
    {
        IpBase = 0;
        IpEnd  = 0;
        UserRecord = default(TValue);
    }

    // -------------------------------------------------------------------------------
    // Constructor for generic config strings
    // Sample format:
    //   ip=<ip address>;[ipEnd=<ip address>;][param1=value1;][param2=value2;]...
    // -------------------------------------------------------------------------------
    internal IpRangeListRecord(string configString)
        : this()
    {
        char[] majorSep = new char[] { ';', ',' };
        char[] minorSep = new char[] { '=' };

        UserRecord = new TValue();

        string[] majorTokens = configString.Split(majorSep);

        foreach (string nameValuePair in majorTokens)
        {
            if (String.IsNullOrEmpty(nameValuePair))
            {
                // Something like "ip=1.1.1.1;" would cause this
                continue;
            }

            string[] minorTokens = nameValuePair.Split(minorSep);
            if (minorTokens.Length != 2)
            {
                throw new ArgumentException("Token format must be <name>=<value>, \"" + nameValuePair + "\" is invalid");
            }
           
            string paramName = minorTokens[0].Trim();
            string paramValue = minorTokens[1].Trim();
           
            // Note: we store the IP in big-endian format, so that something like 1.2.3.4 
            // becomes 0x01020304. This makes our ranges work a whole lot better.

            if (String.Compare(paramName, "ip", true) == 0 ||
                String.Compare(paramName, "ipBase", true) == 0)
            {
                IpBase = ByteOrder.IpStringToUInt32(paramValue);
            }
            else if (String.Compare(paramName, "ipEnd", true) == 0)
            {
                IpEnd = ByteOrder.IpStringToUInt32(paramValue);
            }
            else
            {
                UserRecord.SetParam(paramName, paramValue);
            }
        }

        if (IpEnd == 0)
        {
            IpEnd = IpBase;
        }

        // Comparisons must use internal members
        if (_IpEnd < _IpBase)
        {
            throw new ArgumentException("Invalid ip range " + this.ToString());
        }

    }

    // -------------------------------------------------------------------------------
    // Constructor for searching
    // -------------------------------------------------------------------------------
    internal IpRangeListRecord(IPAddress ip)
        : this()
    {
        IpBase  = ByteOrder.IpAddressToUInt32(ip);
        IpEnd   = IpBase;
    }

    // -------------------------------------------------------------------------------
    // CompareTo - implements the IComparable interface. See ascii art below for how this 
    // works..
    // -------------------------------------------------------------------------------
    public int CompareTo(object o)
    {
        // Note: use the big-endian format (the internal, non-accessor format) for 
        // accurate range comparisons. 

        if (!(o is IpRangeListRecord<TValue>))
        {
            throw new ArgumentException("Comparison object is not an IpRangeListRecord");
        }

        IpRangeListRecord<TValue> r = (IpRangeListRecord<TValue>)o;
    
        //  [ASCII Art Extraordinaire]
        //      IpBase <--> IpEnd
        //
        // Us:           |===========|    
        //       |   | |   | |   | |   | |   |
        //  o:   ----- |   | |   | |   | |   |   : return +2
        //  o:         ----- |   | |   | |   |   : return +1
        //  o:               ----- |   | |   |   : return  0
        //  o:                     ----- |   |   : return -1
        //  o: |                         ----- | : return -2 
        //  o: --------------------------------- : return  0
        //

        if (_IpEnd < r._IpEnd)
        {
            // This instance is less than o, or maybe engulfing
            if (_IpBase > r._IpBase)
                return 0;
            else if (_IpEnd >= r._IpBase)
                return -1;
            else
                return -2;
        }
        else if (_IpBase > r._IpBase)
        {
            // This instance is greater than o
            if (_IpBase <= r._IpEnd)
                return 1;
            else
                return 2;
        }
        else
        {
            // Just right
            return 0;
        }

    }

    // -------------------------------------------------------------------------------
    // OverlapsWith - does this record overlap another one?
    // -------------------------------------------------------------------------------
    public bool OverlapsWith(IpRangeListRecord<TValue> r)
    {
        // -2 or +2 mean no overlap
        int c = CompareTo(r);
        return (c >= -1 && c <= 1);
    }

    public override string ToString()
    {
        return String.Format(
            "[{0} - {1}, {2}]", 
            new IPAddress(IpBase),
            new IPAddress(IpEnd),
            UserRecord);
    }


    // Handles little-endian format
    internal UInt32 IpBase
    {
        get { return ByteOrder.Revert(_IpBase); }
        set { _IpBase = ByteOrder.Revert(value); }
    }

    internal UInt32 IpEnd
    {
        get { return ByteOrder.Revert(_IpEnd); }
        set { _IpEnd = ByteOrder.Revert(value); }
    }

    internal TValue UserRecord
    {
        get { return _UserRecord; }
        set { _UserRecord = value; }
    }


    // Stored in big-endian format for accurate range comparisons. We want "2.1.1.1" to be 
    // 0x02010101 and "1.1.1.2" to be 0x01010102, not the other way around.

    private UInt32     _IpBase;
    private UInt32     _IpEnd;
    private TValue     _UserRecord;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\InterfaceInfo.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(false)]
public class InterfaceInfo : ConfigEventLogger, IInterfaceInfo
{
    private string _interface = STF.common.config.Interface.None;
    private string _protocol = null;
    private IPAddress _ipAddress = null;
    private IPAddress _ipNetMask = null;
    private IPAddress _ipDefaultGateway = null;
    private int _port = 0;
    private int _portEnd = 0;
    private string _vsite = null;
    private int _vsiteid = 0;
    private string _vdir = null;
    private string _dbname = null;
    private string _sharename = null;
    private int _timeout = 0;
    private int _serviceId = 0;
    private string _serviceName = null;
    private string _mac = null;
    private IPAddress _sgIpAddressBegin = null;
    private IPAddress _sgIpAddressEnd = null;
    private int _sgPortBegin = 0;
    private int _sgPortEnd = 0;
    private bool _needSGInfo = false;
    private IPAddress _wiretapIpAddress = null;
    private bool _nicDisabled = false;
    private string _username = null;
    private string _password = null;
    private string _info1 = null;
    private string _info2 = null;
    private string _serverName = null;
    private int? _minConnectionPoolSize = null;
    private int? _maxConnectionPoolSize = null;
    private int? _loadBalanceTimeout = null;
    private int? _connectionTimeout = null;
    private Dictionary<string,string> _notificationUrls = null;
    private object _notificationLock = new object();

    public override string ToString()
    {
        return "{{"
            +_interface.ToString()+","
            +(_protocol == null ? "<null>" : _protocol)+","
            +(_ipAddress== null ? "<null>" : _ipAddress.ToString())+","
            +(_ipNetMask== null ? "<null>" : _ipNetMask.ToString())+","
            +(_ipDefaultGateway== null ? "<null>" : _ipDefaultGateway.ToString())+","
            +_port.ToString()+","
            +_portEnd.ToString()+","
            +(_vsite== null ? "<null>" : _vsite)+","
            +_vsiteid.ToString()+","
            +(_vdir== null ? "<null>" : _vdir)+","
            +(_dbname== null ? "<null>" : _dbname)+","
            +(_sharename== null ? "<null>" : _sharename)+","
            +_timeout.ToString()+","
            +_serviceId.ToString()+","
            +(_serviceName== null ? "<null>" : _serviceName)+","
            +(_mac== null ? "<null>" : _mac)+","
            +(_sgIpAddressBegin== null ? "<null>" : _sgIpAddressBegin.ToString())+","
            +(_sgIpAddressEnd== null ? "<null>" : _sgIpAddressEnd.ToString())+","
            +_sgPortBegin.ToString()+","
            +_sgPortEnd.ToString()+","
            +_needSGInfo.ToString()+","
            +(_wiretapIpAddress== null ? "<null>" : _wiretapIpAddress.ToString())+","
            +_nicDisabled.ToString()+","
            +(_username== null ? "<null>" : _username)+","
            +(_password== null ? "<null>" : _password)+","
            +(_info1== null ? "<null>" : _info1)+","
            +(_info2== null ? "<null>" : _info2)+","
            +(_serverName== null ? "<null>" : _serverName)+","
            +(_minConnectionPoolSize==null ? "<null>" : _minConnectionPoolSize.ToString())+","
            +(_maxConnectionPoolSize==null ? "<null>" : _maxConnectionPoolSize.ToString())+","
            +(_loadBalanceTimeout==null ? "<null>" : _loadBalanceTimeout.ToString())+","
            +(_connectionTimeout==null ? "<null>" : _connectionTimeout.ToString())+","
            +(_notificationUrls==null ? "<null>" : 
              "[" + string.Join(";", _notificationUrls.Select( u => u.Key + ":" + u.Value ).ToArray() ) +"]")
            +"}}";
    }

    public string Interface
    {
        get { return _interface; }
        set { _interface = value; }
    }

    public string Protocol
    {
        get { return _protocol; }
        set { _protocol = value; }
    }

    public IPAddress IPAddress
    {
        get { return _ipAddress; }
        set { _ipAddress = value; }
    }

    public string IPAddressString
    {
        get { return _ipAddress == null ? null : _ipAddress.ToString(); }
    }

    public uint IPAddressDword
    {
        get { return _ipAddress == null ? 0 : ConfigUtil.IpAddressToDword( _ipAddress ); }
    }

    public IPAddress IPNetMask
    {
        get { return _ipNetMask; }
        set { _ipNetMask = value; }
    }

    public string IPNetMaskString
    {
        get { return _ipNetMask == null ? null : _ipNetMask.ToString(); }
    }

    public uint IPNetMaskDword
    {
        get { return _ipNetMask == null ? 0 : ConfigUtil.IpAddressToDword( _ipNetMask ); }
    }

    public IPAddress IPDefaultGateway
    {
        get { return _ipDefaultGateway; }
        set { _ipDefaultGateway = value; }
    }

    public string IPDefaultGatewayString
    {
        get { return _ipDefaultGateway == null ? null : _ipDefaultGateway.ToString(); }
    }

    public uint IPDefaultGatewayDword
    {
        get { return _ipDefaultGateway == null ? 0 : ConfigUtil.IpAddressToDword( _ipDefaultGateway ); }
    }

    public int Port
    {
        get { return _port; }
        set { _port = value; }
    }

    public int PortEnd
    {
        get { return _portEnd; }
        set { _portEnd = value; }
    }

    public string VSite
    {
        get { return _vsite; }
        set { _vsite = value; }
    }

    public int VSiteId
    {
        get { return _vsiteid; }
        set { _vsiteid = value; }
    }

    public string VDir
    {
        get { return _vdir; }
        set { _vdir = value; }
    }

    public string DBName
    {
        get { return _dbname; }
        set { _dbname = value; }
    }

    public string Sharename
    {
        get { return _sharename; }
        set { _sharename= value; }
    }

    public int Timeout
    {
        get { return (_connectionTimeout ?? _timeout); }
        set { _timeout = value; }
    }

    public int ServiceId
    {
        get { return _serviceId; }
        set { _serviceId = value; }
    }

    public string ServiceName
    {
        get { return _serviceName; }
        set { _serviceName = value; }
    }

    public string Mac
    {
        get { return _mac; }
        set { _mac = value; }
    }

    public IPAddress SgIpAddressBegin
    {
        get { return _sgIpAddressBegin; }
        set { _sgIpAddressBegin = value ; }
    }

    public string SgIpAddressBeginString
    {
        get { return _sgIpAddressBegin == null ? null : _sgIpAddressBegin.ToString(); }
    }

    public uint SgIpAddressBeginDword
    {
        get { return _sgIpAddressBegin == null ? 0 : ConfigUtil.IpAddressToDword( _sgIpAddressBegin ); }
    }

    public IPAddress SgIpAddressEnd
    {
        get { return _sgIpAddressEnd; }
        set { _sgIpAddressEnd = value ; }
    }

    public string SgIpAddressEndString
    {
        get { return _sgIpAddressEnd == null ? null : _sgIpAddressEnd.ToString(); }
    }

    public uint SgIpAddressEndDword
    {
        get { return _sgIpAddressEnd == null ? 0 : ConfigUtil.IpAddressToDword( _sgIpAddressEnd ); }
    }

    public int SgPortBegin
    {
        get { return _sgPortBegin; }
        set { _sgPortBegin = value; }
    }

    public int SgPortEnd
    {
        get { return _sgPortEnd; }
        set { _sgPortEnd = value; }
    }

    public bool NeedSGInfo
    {
        get { return _needSGInfo; }
        set { _needSGInfo = value; }
    }

    public IPAddress WiretapIpAddress
    {
        get { return _wiretapIpAddress; }
        set { _wiretapIpAddress = value ; }
    }

    public string WiretapIpAddressString
    {
        get { return _wiretapIpAddress == null ? null : _wiretapIpAddress.ToString(); }
    }

    public uint WiretapIpAddressDword
    {
        get { return _wiretapIpAddress == null ? 0 : ConfigUtil.IpAddressToDword( _wiretapIpAddress ); }
    }

    public bool NicDisabled
    {
        get { return _nicDisabled; }
        set { _nicDisabled = value; }
    }

    public string Username
    {
        get { return _username; }
        set { _username = value; }
    }

    public string Password
    {
        get { return _password; }
        set { _password = value; }
    }

    public string Info1
    {
        get { return _info1; }
        set { _info1 = value; }
    }

    public string Info2
    {
        get { return _info2; }
        set { _info2 = value; }
    }

    public string ServerName
    {
        get { return _serverName; }
        set { _serverName = value; }
    }

    public int? MinConnectionPoolSize
    {
        get { return _minConnectionPoolSize; }
        set { _minConnectionPoolSize = value; }
    }

    public int? MaxConnectionPoolSize
    {
        get { return _maxConnectionPoolSize; }
        set { _maxConnectionPoolSize = value; }
    }

    public int? LoadBalanceTimeout
    {
        get { return _loadBalanceTimeout; }
        set { _loadBalanceTimeout = value; }
    }

    public int? ConnectionTimeout
    {
        get { return _connectionTimeout; }
        set { _connectionTimeout = value; }
    }

    public Uri Url
    {
        get
        {
            if (Protocol == null || IPAddressString == null)
            {
                return null;
            }

            UriBuilder b = new UriBuilder();
            b.Scheme = Protocol;
            b.Host = IPAddressString;

            // Port == 0 means port was not specified, so leave it out
            // of the Uri
            if (Port != 0)
            {
                b.Port = Port;
            }

            return b.Uri;
        }
    }

    public string GetNotificationUrl(string notification)
    {
        if (_notificationUrls == null || 
            String.IsNullOrEmpty(notification))
        {
            return null;
        }
        notification = notification.ToLower();

        lock( _notificationLock )
        {
            string value = null;

            _notificationUrls.TryGetValue(notification, out value);
            return value;
        }
    }

    public void AddNotificationUrl(string notification, string url)
    {
        if (String.IsNullOrEmpty(notification))
        {
            return;
        }
        notification = notification.ToLower();

        lock( _notificationLock )
        {
            if (_notificationUrls == null)
            {
                _notificationUrls = new Dictionary<string,string>();
            }
            _notificationUrls[notification] = url;
        }
    }

    public string[] NotificationUrls
    {
        get
        {
            lock( _notificationLock )
            {
                if (_notificationUrls == null)
                {
                    return new string[0];
                }
                return _notificationUrls.Keys.ToArray();
            }
        }
    }

    public string SqlConnectionString
    {
        get
        {
            // only makes sense if the protocol is sql
            if (Protocol == null || Protocol != "sql")
            {
                string message = String.Format(
                    "InterfaceInfo.SqlConnectionString: Interface {0} does not have a Protocol of 'sql'.",
                    Interface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_240);
                throw ae;
            }

            // need an IPAddress
            if ((IPAddress == null) || (IPAddress == System.Net.IPAddress.None))
            {
                string message = String.Format(
                    "InterfaceInfo.SqlConnectionString: Interface {0} does not have a valid IP address.",
                    Interface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_241);
                throw ae;
            }

            // need a DBName
            if ((DBName == null) || (DBName.Length == 0))
            {
                string message = String.Format(
                    "InterfaceInfo.SqlConnectionString: Interface {0} does not have a database name specified.",
                    Interface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_242);
                throw ae;
            }

            SqlConnectionStringBuilder  scsb = new SqlConnectionStringBuilder();

            scsb.DataSource = IPAddressString;
            scsb.InitialCatalog = DBName;
            scsb.IntegratedSecurity=true;
            scsb.ApplicationName = Config.ComponentName;

            // Calculate the timeout of the connection. The value in NPDB is
            // stored in millisecs, but seconds is needed for the builder
            scsb.ConnectTimeout = Timeout / 1000;

            // optional fields
            if (_minConnectionPoolSize != null)
            {
                scsb.MinPoolSize = _minConnectionPoolSize.Value;
            }
            if (_maxConnectionPoolSize != null)
            {
                scsb.MaxPoolSize = _maxConnectionPoolSize.Value;
            }
            if (_loadBalanceTimeout != null)
            {
                // Calculate the load balance timeout. The value in NPDB is
                // stored in millisecs, but seconds is needed for the builder
                int loadBalanceTimeout = _loadBalanceTimeout.Value / 1000;

                if (loadBalanceTimeout > 0)
                {
                    scsb.LoadBalanceTimeout = loadBalanceTimeout;
                }
            }

            return scsb.ToString().Replace("Integrated Security=True", "Integrated Security=SSPI");
        }
    }

}

[ComVisible(false)]
public class InterfaceInfoServerComparer : IComparer
{
    public int Compare ( object x, object y )
    {
        InterfaceInfo iiA = x as InterfaceInfo;
        InterfaceInfo iiB = y as InterfaceInfo;

        if( null != iiA && null != iiB )
        {
            return string.Compare( iiA.ServerName, iiB.ServerName );
        }
        else
        {
            throw new ArgumentException();
        }
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IUserRole.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[Guid("261263AA-2F3D-4740-9548-0D78EFA11AA1")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IUserRole
{
	string Name
    {
        get;
    }

	string FullUsername
	{
		get;
	}

	string Domainname
	{
		get;
	}

    string Username
    {
        get;
    }

    string Password
    {
        get;
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\IVirtualInterfaceInfo.cs ===
using System;
using System.Net;
using System.Runtime.InteropServices;

namespace STF.common.config
{
    [ComVisible(true)]
[Guid("9625F602-A1C4-4F5C-ABF9-0CD504203A3A")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVirtualInterfaceInfo
{
    string VirtualInterface
    {
        get;
    }

    string Interface
    {
        get;
    }

    string Protocol
    {
        get;
    }

    IPAddress IPAddress
    {
        get;
    }

    string IPAddressString
    {
        get;
    }

    uint IPAddressDword
    {
        get;
    }

    int Port
    {
        get;
    }

    int PortEnd
    {
        get;
    }

    string VDir
    {
        get;
    }

    string WebstoreApp
    {
        get;
    }

    int Timeout
    {
        get;
    }

    int ServiceId
    {
        get;
    }

    string ServiceName
    {
        get;
    }

    bool NeedSGInfo
    {
        get;
    }

    int InternetPort
    {
        get;
    }

    int InternetPortEnd
    {
        get;
    }

    string Info1
    {
        get;
    }

    string Info2
    {
        get;
    }

    Uri Url
    {
        get;
    }

    string SqlConnectionString
    {
        get;
    }

    string GetNotificationUrl(string notification);

    string[] NotificationUrls
    {
        get;
    }

    string HealthCheckUrl
    {
        get;
    }

    string ToString();
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ListsProtocol.cs ===
using System;

using STF.common.service;


//--------------------------------------------------------------------------------
// NOTE:  changes to the WireData objects or to the Reply objects will impact classes in DownloadQueueProtocol.cs
//--------------------------------------------------------------------------------

namespace STF.common.protocol
{
    public class ListInfo : WireData
    {
        public int listType;
        public int listId;
        public DateTime lastModified;
        public int totalItems;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;
    }


    public class ListItem : WireData
    {
        public Guid itemId;
        public short priority;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemMod : WireData
    {
        public Guid itemId;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemIndex : WireData
    {
        public Guid itemId;
        public short priority;
        public int index;
    }


    public class CreateListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/CreateList.ashx";
            }
        }
    }


    public class CreateListResponse : XRLObject2
    {
        public int listId;
        public DateTime lastModified;

        public CreateListResponse( CreateListReply reply )
        {
            listId = reply.listId;
            lastModified = reply.lastModified;
        }
    }


    public class CreateListReply
    {
        public uint status = HResult.S_OK;
        public int listId = int.MinValue;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class DeleteListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteList.ashx";
            }
        }
    }


/*
    public class DeleteListResponse : XRLObject2
    {
        public DeleteListResponse( DeleteListReply reply )
        {
        }
    }
*/


    public class DeleteListReply
    {
        public uint status = HResult.S_OK;
    }


    public class ModifyListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyList.ashx";
            }
        }
    }


    public class ModifyListResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyListResponse( ModifyListReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyListReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class QueryListsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType; // int.MinValue is wildcard
        public int listId; // int.MinValue is wildcard
        public DateTime lastModified;
        public int pageSize;
        public int pageNum;
        public int orderDir;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryLists.ashx";
            }
        }
    }


    public class QueryListsResponse : XRLObject2
    {
        public ushort totalLists = 0;
        public ushort numLists = 0;

        [WireInfo( SizeParam = "numLists" )]
        public ListInfo[] resultLists = null;

        public QueryListsResponse( QueryListsReply reply )
        {
            totalLists = reply.totalLists;
            resultLists = reply.resultLists;
            if( resultLists != null ) {
                numLists = (ushort) resultLists.Length;
            }
        }
    }


    public class QueryListsReply
    {
        public uint status = HResult.S_OK;
        public ushort totalLists = 0;
        public ListInfo[] resultLists = null;
    }


    public class GrantListAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/Lists/GrantListAccess.ashx";
            }
        }
    }


/*
    public class GrantListAccessResponse : XRLObject2
    {
        public GrantListAccessResponse( GrantListAccessReply reply )
        {
        }
    }
*/


    public class GrantListAccessReply
    {
        public uint status = HResult.S_OK;
    }


    public class RevokeListAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public ulong machinePuid; // 0 is wildcard

        public override string Xrl
        {
            get
            {
                return "/Lists/RevokeListAccess.ashx";
            }
        }
    }


/*
    public class RevokeListAccessResponse : XRLObject2
    {
        public RevokeListAccessResponse( RevokeListAccessReply reply )
        {
        }
    }
*/


    public class RevokeListAccessReply
    {
        public uint status = HResult.S_OK;
    }


    public class InsertItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/InsertItems.ashx";
            }
        }
    }


    public class InsertItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public InsertItemsResponse( InsertItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class InsertItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class DeleteItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteItems.ashx";
            }
        }
    }


    public class DeleteItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public DeleteItemsResponse( DeleteItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class DeleteItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class ModifyItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyItems.ashx";
            }
        }
    }


    public class ModifyItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyItemsResponse( ModifyItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class QueryItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public int pageSize;
        public int pageNum;
        public int orderDir;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds; // empty array is wildcard

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryItems.ashx";
            }
        }
    }


    public class QueryItemsResponse : XRLObject2
    {
        public ushort totalItems = 0;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
        public ushort numItems = 0;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] resultItems = null;

        public QueryItemsResponse( QueryItemsReply reply )
        {
            totalItems = reply.totalItems;
            lastModified = reply.lastModified;
            resultItems = reply.resultItems;
            if( resultItems != null ) {
                numItems = (ushort) resultItems.Length;
            }
        }
    }


    public class QueryItemsReply
    {
        public uint status = HResult.S_OK;
        public ushort totalItems = 0;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
        public ListItem[] resultItems = null;
    }


    public class MoveItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numIndices;

        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get
            {
                return "/Lists/MoveItems.ashx";
            }
        }
    }


    public class MoveItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public MoveItemsResponse( MoveItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }

    
    public class MoveItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\LiveInfo.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * protocol\LiveInfo.cs
 *
 * Protocol Definition for LiveInfo
 *
 */

using STF.common.service;
using System;

namespace STF.common.protocol
{
    // GetLiveConfigRequest
    // GetLiveConfig request packet
    public class GetLiveConfigRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        public override string Xrl
        {
            get { return "/liveinfo/getliveconfig.ashx"; }
        }
    }

    // GetLiveConfigResponse
    public class GetLiveConfigResponse: XRLObject2
    {
        public const int CONFIG_BLOCK_MAX_COUNT = 10;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT * XeGenericBlock.BLOCK_MAX_LEN)]
        public uint configLen;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT)]
        public ushort configBlockCount;

        [WireInfo(SizeParam="configBlockCount")]
        public XeGenericBlock[] configBlocks;

        [WireInfo(Serialize=false)]
        public string config;
    }

    // GetLiveConfigIntRequest
    // This is a request to get the live config for an internal call, where we're not coming
    // from a user or have SG Info.  This is used by the liveinfoclient class for the cross
    // datacenter call.
    public class GetLiveConfigIntRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        public override string Xrl
        {
            get { return "/liveinfo/getliveconfigint.ashx"; }
        }
    }

    // GetLiveConfigResponse
    public class GetLiveConfigIntResponse : XRLObject2
    {
        public uint settingCount;

        [WireInfo(SizeParam="settingCount")]
        public LiveConfigSetting[] settings;
    }

    public class LiveConfigSetting : WireData
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        [WireInfoAttribute(Min=1)]
        public ushort nameLen;

        [WireInfoAttribute(SizeParam="nameLen")]
        public string name;

        public ushort valueLen;

        [WireInfoAttribute(SizeParam="valueLen")]
        public string value;
    }

    // GetNetworkAuthorizationListRequest
    // GetNetworkAuthorizationList request packet
    public class GetNetworkAuthorizationListRequest : XRLObject2
    {
        public override string Xrl
        {
            get { return "/liveinfo/getnetworkauthorizationlist.ashx"; }
        }
    }

    public class NetworkAuthorizationListItem : WireData
    {
        public ushort protocol;

        public ushort port; // can be 0, optional.

        public ushort serverLen;

        [WireInfoAttribute(SizeParam="serverLen")]
        public string server;

        // Path is optional.  Could just be a hostname or IP address.
        public ushort pathLen;

        [WireInfoAttribute(SizeParam="pathLen")]
        public string path;

        // IP Address range.  Optional.  0 if not used.
        // If it's one address, from = to.  If multiple, it's all the addresses
        // in between.
        public uint fromIP;

        public uint toIP;

        // Applies To is optional.
        public ushort appliesToLen;

        [WireInfoAttribute(SizeParam="appliesToLen")]
        public string appliesTo; // URI that it applies to?

    }

    // GetNetworkAuthorizationListResponse
    public class GetNetworkAuthorizationListResponse: XRLObject2
    {
        public ushort authorizationListCount;

        [WireInfo(SizeParam="authorizationListCount")]
        public NetworkAuthorizationListItem[] authorizationList;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\LockFreeQueue.cs ===
using System;
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

// Lock free queue implementation.  This implementation only works as managed code, as it relies on the GC memory allocator semantics
//   of not reusing a memory address for an object until it is no longer referenced by any running code.  To understand why
//   this is necessary, perform a search on The ABA problem to see the inherent issues around lock free data structures.  
//   In native implemenations, the recommendation is to use the InterlockedXXSList functions, as they implement the right 
//   lock free semantics in native code.
namespace STF.common.service
{
    public sealed class LockFreeQueue<T>
    {
        volatile Entry _head;
        volatile Entry _tail;
        bool _fUseExceptions;
        int _count;
        
        public LockFreeQueue() : this(true)
        {
        }
        public LockFreeQueue(bool fUseExceptions)
        {
            _head = new Entry();
            _tail = _head;
            _fUseExceptions = fUseExceptions;
            _count = 0;
        }

        public void Enqueue(T item)
        {
            Entry newNode = new Entry();
            newNode.Member = item;

            while (true)
            {
                Entry oldTail = _tail;
                Entry oldTailNext = oldTail.Next;

                if (_tail == oldTail)
                {
                    if (oldTailNext == null)
                    {
                        if (oldTailNext == Interlocked.CompareExchange(ref oldTail.Next, newNode, oldTailNext))
                        {
                            Interlocked.CompareExchange(ref _tail, newNode, oldTail);
                            Interlocked.Increment(ref _count);
                            return;
                        }
                    }
                    else
                    {
                        Interlocked.CompareExchange(ref _tail, oldTailNext, oldTail);
                    }
                }
            }
        }

        public bool TryDequeue(out T item)
        {
            while (true)
            {
                Entry oldHead = _head;
                Entry oldTail = _tail;
                Entry oldHeadNext = oldHead.Next;

                if (oldHead == _head)
                {
                    if (oldHead == oldTail)
                    {
                        if (oldHeadNext == null)
                        {
                            item = default(T);
                            return false;
                        }
                        
                        Interlocked.CompareExchange(ref _tail, oldHeadNext, oldTail);
                    }
                    else
                    {
                        item = oldHeadNext.Member;
                        if (oldHead == Interlocked.CompareExchange(ref _head, oldHeadNext, oldHead))
                        {
                            Interlocked.Decrement(ref _count);
                            return true;
                        }
                    }
                }
            }
        }

        public T Dequeue()
        {
            T result;
            
            bool fFound = TryDequeue(out result);
            
            if (_fUseExceptions && !fFound)
            {
                throw new InvalidOperationException("queue empty.");
            }
            
            return result;
        }

        public int Count
        {
            get { return _count; }
        }
        
        class Entry
        {
            public T Member;
            public volatile Entry Next;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Locale.cs ===
/*
 * Locale.cs
 *
 * Supports locales
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Author: Ben Zotto (benzotto)
 */

using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using STF.common.config;
using STF.common.service;

namespace STF.common.utilities
{
    public class Locale
    {

        private static string[] _validLocales = null;

        //
        // Get's a valid LCID from a real/fake LCID
        //
        public static int GetValidLCID(int LCID)
        {
            // Since LCIDs are short values, the max value would be 65535.  Fake LCIDs, then, will be based on real LCIDs plus multiples of 100000.
            // to get a real LCID from a dummy lcid, simply remove all multiples of 100000.
            LCID %= 100000;

            try
            {
                CultureInfo ci = new CultureInfo(LCID);
            }
            catch
            {
                throw new Exception("Locale.GetValidLCID: provided LCID does not map to a real LCID");
            }

            return LCID;
        }

        //
        // Get's a valid LCID from a locale
        //
        public static int GetLcidFromLocaleCode(string localeCode)
        {
            int lcid;
            try
            {
                CultureInfo ci = new CultureInfo(localeCode);
                lcid = ci.LCID;
            }
            catch
            {
                throw new Exception("Locale.GetLcidFromLocaleCode: provided locale does is not valid");
            }

            return lcid;
        }

        //
        // Default locale for a country
        //
        public static string DefaultByCountry(string countryCode)
        {
            string setting = "locale_" + countryCode;
            string locale = Config.GetSetting(setting).Trim();

            if (locale == null || locale == String.Empty)
            {
                throw new Exception("Locale.DefaultLocale: could not find default mapping in config file locale section for " + countryCode );
            }

            return locale;
        }

        public static string DefaultByLanguage(uint language)
        {
            string setting = "locale_language" + language;
            string val = Config.GetSetting(setting).Trim();

            if (val == null || val == String.Empty)
            {
                throw new Exception("Locale.DefaultByLanguage: could not find default language" + language + " mapping in config file locale section" );
            }

            return val;
        }

        public static string NeutralCultureFromLanguage(uint language)
        {
            string setting = "locale_language" + language;
            string val = Config.GetSetting(setting).Trim();

            if (val == null || val == String.Empty)
            {
                throw new Exception("Locale.NeutralCultureFromLanguage: could not find default language" + language + " mapping in config file locale section" );
            }

            return val.Substring(0, 2);
        }

        //
        // Determine if a given locale is considered a valid locale by the service
        //
        public static bool IsValidLocale(string candidate)
        {
            if (_validLocales == null)
            {
                string val = Config.GetSetting(Setting.locale_validLocales);
                if (val == null || val == String.Empty)
                {
                    throw new Exception("A ValidLocales setting is required in the config database");
                }

                string[] vals = val.Split(new char[] { ';', ',' });

                for (int i = 0; i < vals.Length; i++)
                {
                    vals[i] = vals[i].Trim().ToUpper();
                }

                Array.Sort(vals);

                _validLocales = vals;
            }

            if (Array.BinarySearch(_validLocales, candidate.ToUpper()) >= 0)
            {
                return true;
            }

            return false;
        }


        public static string BuildLocale(uint language, string countryCode)
        {
            Debug.Assert(countryCode != null);
            Debug.Assert(countryCode.Length == 2);

            return( NeutralCultureFromLanguage(language) + "-" + countryCode );
        }

        // BuildValidLocaleList
        // Build a list of valid locales sorted by priority based on two
        // languages and a country.
        public static string[] BuildValidLocaleList(uint language1, uint language2, string countryCode)
        {
            string     candidate;
            ArrayList  list = new ArrayList(3);

            if(language1 != 0)
            {
                // Try to patch together a valid locale from language + country
                candidate = BuildLocale(language1, countryCode);
                if(IsValidLocale(candidate))
                {
                    list.Add(candidate);
                }

                // Also get the raw language to locale mapping regardless of country
                candidate = LocaleFromv1LanguageId((ushort)language1);

                if(IsValidLocale(candidate))
                {
                    list.Add(candidate);
                }
            }

            if((language1 != language2) && (language2 != 0))
            {
                // We only need to evaluate language2 if it's different from
                // language1
                candidate = BuildLocale(language2, countryCode);

                if (IsValidLocale(candidate))
                {
                    list.Add(candidate);
                }

                // Also get the raw language to locale mapping regardless of country
                candidate = LocaleFromv1LanguageId((ushort)language2);

                if(IsValidLocale(candidate))
                {
                    list.Add(candidate);
                }
            }

            if (CountryDictionary.CountryId(countryCode) != 0)
            {
                // Try Country's default language
                candidate = DefaultByCountry(countryCode);

                if (IsValidLocale(candidate))
                {
                    list.Add(candidate);
                }
            }

            if(list.Count == 0)
            {
                throw new Exception(string.Format(
                    "Locale.BuildValidLocale: Cannot build a valid locale from "+
                    "languages {0} or {1} and country {2}! Bad country?",
                    language1.ToString(), language2.ToString(), countryCode));
            }

            return (string[])list.ToArray(typeof(string));
        }

        public static string BuildValidLocale(uint language, string countryCode)
        {
            return BuildValidLocaleList(language, language, countryCode)[0];
        }

        // From xbox.x, used by the String server and Messaging widget
        public enum v1LanguageID : ushort
        {
            unknown             = 0,
            english             = 1,
            japanese            = 2,
            german              = 3,
            french              = 4,
            spanish             = 5,
            italian             = 6,
            korean              = 7,
            chinese_traditional = 8,
            portuguese          = 9,
            chinese_simplified  = 10,
            polish              = 11,
            russian             = 12,
        };

        public static string LocaleFromv1LanguageId( ushort languageId )
        {
            string locale = "default";

            switch ((v1LanguageID)languageId)
            {
                case v1LanguageID.unknown:       locale = "default"; break;
                case v1LanguageID.english:       locale = "en-US"; break;
                case v1LanguageID.japanese:      locale = "ja-JP"; break;
                case v1LanguageID.german:        locale = "de-DE"; break;
                case v1LanguageID.french:        locale = "fr-FR"; break;
                case v1LanguageID.spanish:       locale = "es-ES"; break;
                case v1LanguageID.italian:       locale = "it-IT"; break;
                case v1LanguageID.korean:        locale = "ko-KR"; break;
                case v1LanguageID.chinese_traditional: locale = "zh-TW"; break;
                case v1LanguageID.portuguese:    locale = "pt-PT"; break;
                case v1LanguageID.chinese_simplified:  locale = "zh-CN"; break;
                case v1LanguageID.polish:        locale = "pl-PL"; break;
                case v1LanguageID.russian:       locale = "ru-RU"; break;
            }

            return locale;
        }

        public static ushort v1LanguageIdFromLocale( string locale )
        {
            v1LanguageID languageId = v1LanguageID.unknown;

            switch (locale)
            {
                case "default": languageId = v1LanguageID.unknown; break;
                case "en-US": languageId = v1LanguageID.english; break;
                case "en-AE": languageId = v1LanguageID.english; break;
                case "en-ZA": languageId = v1LanguageID.english; break;
                case "ja-JP": languageId = v1LanguageID.japanese; break;
                case "de-DE": languageId = v1LanguageID.german; break;
                case "fr-FR": languageId = v1LanguageID.french; break;
                case "es-CL": languageId = v1LanguageID.spanish; break;
                case "es-CO": languageId = v1LanguageID.spanish; break;
                case "es-ES": languageId = v1LanguageID.spanish; break;
                case "it-IT": languageId = v1LanguageID.italian; break;
                case "ko-KR": languageId = v1LanguageID.korean; break;
                case "zh-CHT": languageId = v1LanguageID.chinese_traditional; break;
                case "zh-TW": languageId = v1LanguageID.chinese_traditional; break;
                case "pt-BR": languageId = v1LanguageID.portuguese; break;
                case "pt-PT": languageId = v1LanguageID.portuguese; break;
                case "zh-CHS": languageId = v1LanguageID.chinese_simplified; break;
                case "zh-CN": languageId = v1LanguageID.chinese_simplified; break;
                case "pl-PL": languageId = v1LanguageID.polish; break;
                case "ru-RU": languageId = v1LanguageID.russian; break;
            }

            return (ushort)languageId;
        }

        public static uint CountryCodeFromv1LanguageId(ushort languageId)
        {
            uint countryCode = XOn.XONLINE_COUNTRY_UNITED_STATES;

            switch ((v1LanguageID)languageId)
            {
                case v1LanguageID.english: countryCode = XOn.XONLINE_COUNTRY_UNITED_STATES; break;
                case v1LanguageID.japanese: countryCode = XOn.XONLINE_COUNTRY_JAPAN; break;
                case v1LanguageID.german: countryCode = XOn.XONLINE_COUNTRY_GERMANY; break;
                case v1LanguageID.french: countryCode = XOn.XONLINE_COUNTRY_FRANCE; break;
                case v1LanguageID.spanish: countryCode = XOn.XONLINE_COUNTRY_SPAIN; break;
                case v1LanguageID.italian: countryCode = XOn.XONLINE_COUNTRY_ITALY; break;
                case v1LanguageID.korean: countryCode = XOn.XONLINE_COUNTRY_KOREA; break;
                case v1LanguageID.chinese_traditional: countryCode = XOn.XONLINE_COUNTRY_TAIWAN; break;
                case v1LanguageID.portuguese: countryCode = XOn.XONLINE_COUNTRY_PORTUGAL; break;
                case v1LanguageID.chinese_simplified: countryCode = XOn.XONLINE_COUNTRY_CHINA; break;
                case v1LanguageID.polish: countryCode = XOn.XONLINE_COUNTRY_POLAND; break;
                case v1LanguageID.russian: countryCode = XOn.XONLINE_COUNTRY_RUSSIAN_FEDERATION; break;
            }

            return countryCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\LSAUtil.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;


namespace STF.common.service
{
    [ComVisible(false)]
    public class LSAUtil
    {
        private static string szLogonService = "SeServiceLogonRight";

        // Import the LSA functions

        [DllImport("advapi32.dll", PreserveSig = true)]
        private static extern UInt32 LsaOpenPolicy(
            ref LSA_UNICODE_STRING SystemName,
            ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,
            Int32 DesiredAccess,
            out IntPtr PolicyHandle
        );

        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern long LsaAddAccountRights(
            IntPtr PolicyHandle,
            IntPtr AccountSid,
            LSA_UNICODE_STRING[] UserRights,
            long CountOfRights);

        [DllImport("advapi32")]
        public static extern void FreeSid(IntPtr pSid);

        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern bool LookupAccountName(
            [MarshalAs(UnmanagedType.LPStr)] string lpSystemName,
            [MarshalAs(UnmanagedType.LPStr)] string lpAccountName,
            IntPtr psid,
            ref int cbsid,
            [MarshalAs(UnmanagedType.LPStr)] StringBuilder domainName,
            ref int cbdomainLength,
            ref int use);

        [DllImport("advapi32.dll")]
        private static extern bool IsValidSid(IntPtr pSid);

        [DllImport("advapi32.dll")]
        private static extern long LsaClose(IntPtr ObjectHandle);

        [DllImport("kernel32.dll")]
        private static extern int GetLastError();

        [DllImport("advapi32.dll")]
        private static extern long LsaNtStatusToWinError(long status);

        // define the structures

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_UNICODE_STRING
        {
            public UInt16 Length;
            public UInt16 MaximumLength;
            public IntPtr Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public LSA_UNICODE_STRING ObjectName;
            public UInt32 Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        // enum all policies

        private enum LSAAccessPolicy : long
        {
            POLICY_VIEW_LOCAL_INFORMATION = 0x00000001L,
            POLICY_VIEW_AUDIT_INFORMATION = 0x00000002L,
            POLICY_GET_PRIVATE_INFORMATION = 0x00000004L,
            POLICY_TRUST_ADMIN = 0x00000008L,
            POLICY_CREATE_ACCOUNT = 0x00000010L,
            POLICY_CREATE_SECRET = 0x00000020L,
            POLICY_CREATE_PRIVILEGE = 0x00000040L,
            POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080L,
            POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100L,
            POLICY_AUDIT_LOG_ADMIN = 0x00000200L,
            POLICY_SERVER_ADMIN = 0x00000400L,
            POLICY_LOOKUP_NAMES = 0x00000800L,
            POLICY_NOTIFICATION = 0x00001000L
        }

        public static long GrantLogonRights(string szAccount)
        {
            IntPtr sid = IntPtr.Zero;
            int iSidSize = 0;

            IntPtr hPolicy = IntPtr.Zero;

            StringBuilder szDomainName = new StringBuilder();
            int iDomainNameSize = 0;
            int iAccountType = 0;

            bool fResult;
            long lErr = 0;
            uint dwLsaRet = 0;
            long lResult = 0;

            LookupAccountName(string.Empty, szAccount, sid, ref iSidSize, szDomainName, ref iDomainNameSize, ref iAccountType);
            szDomainName = new StringBuilder(iDomainNameSize);
            sid = Marshal.AllocHGlobal(iSidSize);

            fResult = LookupAccountName(string.Empty, szAccount, sid, ref iSidSize, szDomainName, ref iDomainNameSize, ref iAccountType);

            if (!fResult)
            {
                lErr = GetLastError();
                goto lDone;
            }

            LSA_UNICODE_STRING szSystemName = new LSA_UNICODE_STRING();
            LSA_OBJECT_ATTRIBUTES oObjectAttributes = new LSA_OBJECT_ATTRIBUTES();
            oObjectAttributes.Length = 0;
            oObjectAttributes.RootDirectory = IntPtr.Zero;
            oObjectAttributes.Attributes = 0;
            oObjectAttributes.SecurityDescriptor = IntPtr.Zero;
            oObjectAttributes.SecurityQualityOfService = IntPtr.Zero;

            int iAccess = (int)(
                LSAAccessPolicy.POLICY_AUDIT_LOG_ADMIN |
                LSAAccessPolicy.POLICY_CREATE_ACCOUNT |
                LSAAccessPolicy.POLICY_CREATE_PRIVILEGE |
                LSAAccessPolicy.POLICY_CREATE_SECRET |
                LSAAccessPolicy.POLICY_GET_PRIVATE_INFORMATION |
                LSAAccessPolicy.POLICY_LOOKUP_NAMES |
                LSAAccessPolicy.POLICY_NOTIFICATION |
                LSAAccessPolicy.POLICY_SERVER_ADMIN |
                LSAAccessPolicy.POLICY_SET_AUDIT_REQUIREMENTS |
                LSAAccessPolicy.POLICY_SET_DEFAULT_QUOTA_LIMITS |
                LSAAccessPolicy.POLICY_TRUST_ADMIN |
                LSAAccessPolicy.POLICY_VIEW_AUDIT_INFORMATION |
                LSAAccessPolicy.POLICY_VIEW_LOCAL_INFORMATION
                );

            dwLsaRet = LsaOpenPolicy(ref szSystemName, ref oObjectAttributes, iAccess, out hPolicy);
            lErr = LsaNtStatusToWinError(dwLsaRet);

            if (0 != lErr)
            {
                goto lDone;
            }

            LSA_UNICODE_STRING[] szUserRights = new LSA_UNICODE_STRING[1];
            szUserRights[0] = new LSA_UNICODE_STRING();
            szUserRights[0].Buffer = Marshal.StringToHGlobalUni(szLogonService);
            szUserRights[0].Length = (UInt16)(szLogonService.Length * UnicodeEncoding.CharSize);
            szUserRights[0].MaximumLength = (UInt16)((szLogonService.Length + 1) * UnicodeEncoding.CharSize);

            lResult = LsaAddAccountRights(hPolicy, sid, szUserRights, 1);
            lErr = LsaNtStatusToWinError(dwLsaRet);

            if (0 != lErr)
            {
                goto lDone;
            }

        lDone:

            if (IntPtr.Zero != hPolicy)
            {
                LsaClose(hPolicy);
            }

            if (IntPtr.Zero != sid)
            {
                FreeSid(sid);
            }

            return lErr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\LockFreeStack.cs ===
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

// Lock free stack implementation.  This implementation only works as managed code, as it relies on the GC memory allocator semantics
//   of not reusing a memory address for an object until it is no longer referenced by any running code.  To understand why
//   this is necessary, perform a search on The ABA problem to see the inherent issues around lock free data structures.  
//   In native implemenations, the recommendation is to use the InterlockedXXSList functions, as they implement the right 
//   lock free semantics in native code.
namespace STF.common.service
{
    public sealed class LockFreeStack<T>
    {
        volatile Entry _listHead;

        public T Pop()
        {
            Entry head;

            do
            {
                head = _listHead;
                if (head == null)
                {
                    return default(T);
                }
            } while (head != Interlocked.CompareExchange(ref _listHead, head.Next, head));

            return head.Member;
        }

        public void Push(T o)
        {
            Entry head;
            Entry newHead = new Entry(o);

            do
            {
                head = _listHead;
                newHead.Next = head;
            } while (head != Interlocked.CompareExchange(ref _listHead, newHead, head));
        }

        public bool IsEmpty
        {
            get { return _listHead == null; }
        }

        class Entry
        {
            T _member;
            Entry _next;

            public Entry(T o)
            {
                _member = o;
            }

            public T Member
            { get { return _member; } }

            public Entry Next
            {
                get { return _next; }
                set { _next = value; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\LimitedSizeDictionary.cs ===
// 
// LimitedSizeDictionary.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// LimitedSizeDictionary class
// Xbox Online Service
//
// This is a useful class for anti-dos request tracking, for when you need to track a 
// bunch of items in a hashtable, but don't want the hashtable to grow indefinitely. Think 
// of an anti-dos hashtable that hashes incoming ip addresses.
// 
// Example of usage (need to implement your own value class)
//
// class TestRecord : ILimitedSizeDictionaryValue<string>
// {
//     public string Key 
//     {
//         get { return _Key; }
//         set { _Key = value; }
//     }
// 
//     public void Init(string key)
//     {
//         _Key = key;
//         _Count = 0;
//     }
// 
//     public int      _Count;
//     public string   _Key;
// 
//     public override string ToString()
//     {
//         return String.Format("({0}, {1})", _Key, _Count);
//     }
// }
// 
// // Sample code snippet, pretty simple
//
// ...
//    LimitedSizeDictionary<string, TestRecord> dict;
//    dict = new LimitedSizeDictionary<string, TestRecord>(100);
//    string ip = "10.192.0.0";
//    TestRecord record = dict.Get(ip);
//    record._Count++;
// ...
//
//
// Author: kgoodier 9/2007
//

using System;
using System.Text;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace STF.common.utilities2
{


// -----------------------------------------------------------------------------------
// LimitedSizeDictionary 
// 
// This is a hashtable that will grow up to a certain size, at which point it will start 
// re-purposing existing records. That means records may be removed from the hashtable at 
// any point, but only the least-recently-used ones are repurposed. 
//
// Every single time you call Get, the record is marked as "touched" and moved to the top 
// of the LRU list.
//
// It is not thread safe.
// -----------------------------------------------------------------------------------
[ComVisible(false)]
public class LimitedSizeDictionary<TKey, TValue> 
    where TValue : ILimitedSizeDictionaryValue<TKey>, new()
{

    public LimitedSizeDictionary(
        uint maxSize)
    {
        _MaxSize = maxSize;
        // should we set the initial size of these? seems like no perf difference..
        _Dictionary = new Dictionary<TKey, LinkedListNode<TValue> >(); 
        _LruList = new LinkedList<TValue>();
    }

    public uint MaxSize
    {
        get { return _MaxSize; }
        set { _MaxSize = value; }
    }

    public uint Count
    {
        get { return (uint)_Dictionary.Count; }
    }

    // -------------------------------------------------------------------------------
    // Get - this will lookup a record and return the value. If a record is not found, a 
    // new one will be created or repurposed from the LRU list. 
    //
    // This function is guaranteed to return a valid record.
    //
    // Please remember this is not thread safe.
    // -------------------------------------------------------------------------------
    public TValue Get(TKey key)
    {
        LinkedListNode<TValue> record;
        if (_Dictionary.TryGetValue(key, out record))
        {
            // Found a record. Move position in LRU to the top
            _LruList.Remove(record);
            _LruList.AddFirst(record);
        }
        else
        {
            // No record found. Room to grow?
            if (_Dictionary.Count < _MaxSize)
            {
                // Create a new record.
                TValue val = new TValue();
                val.Init(key);
                record = new LinkedListNode<TValue>(val);

                _Dictionary[key] = record;
                _LruList.AddFirst(record);
            }
            else
            {
                // Repurpose an existing record as long as it isn't in use.
                int numTries = _LruList.Count;
                int currentTries;
                for (currentTries = 0; currentTries < numTries; currentTries++)
                {
                    record = _LruList.Last;
                    Debug.Assert(record != null);
                    Debug.Assert(record.Value != null);
                    _LruList.RemoveLast();
                    _LruList.AddFirst(record);
                    if (record.Value.IsReusable)
                    {
                        break;
                    }
                }
                if (currentTries == numTries)
                {
                    throw new Exception("No records found in LRU that are not in use after trying all " + 
                                        numTries + " records.");
                }

                // Remove old entry from dictionary using old key, and re-init it with the 
                // new key, and then stick it back in the dictionary. Remove then 
                // re-insert immediately to reduce risk of leaking records if Init() 
                // throws.
                _Dictionary.Remove(record.Value.Key);
                _Dictionary[key] = record;
                record.Value.Init(key);
            }
        }

        return record.Value;
    }



    internal bool TryGetWithoutUpdate(TKey key, out TValue val)
    {
        LinkedListNode<TValue> record;
        if (_Dictionary.TryGetValue(key, out record))
        {
            val = record.Value;
            return true;
        }
        val = default(TValue);
        return false;
    }


    public override string ToString()
    {
        StringBuilder sb = new StringBuilder(1000);
        foreach (TValue record in _LruList)
        {
             sb.AppendFormat("Key[{0}], Value[{1}]\n", record.Key, record);
        }
        return sb.ToString();
    }



    private Dictionary<TKey, LinkedListNode<TValue> > _Dictionary;
    private LinkedList<TValue>                        _LruList;
    private uint                                      _MaxSize;
}

// -----------------------------------------------------------------------------------
// ILimitedSizeDictionaryValue 
// 
// Interface for the value supplied to the LimitedSizeDictionary class. Your value must 
// also store the key, and it must support re-initialization for when the record gets 
// re-purposed.
// -----------------------------------------------------------------------------------
[ComVisible(false)]
public interface ILimitedSizeDictionaryValue<TKey>
{
    TKey Key { get; set; }
    bool IsReusable { get; }

    void Init(TKey key);
}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\MasterKey.cs ===
using System;
using System.IO;
using System.Security.Cryptography;

using STF.common.exceptions;

namespace STF.common.service
{
    public class MasterKey : IDisposable
    {
        private const int ENCRYPTED_BLOCK_SIZE   = 256;
        private const int UNENCRYPTED_BLOCK_SIZE = 128;

        int _masterKeyVersion;
        RSACryptoServiceProvider _cryptoServiceProvider;

        public MasterKey(int masterKeyVersion)
        {
            _masterKeyVersion = masterKeyVersion;

            CspParameters parameters = new CspParameters();
            parameters.Flags = CspProviderFlags.UseMachineKeyStore | CspProviderFlags.UseExistingKey;
            parameters.KeyContainerName = ContainerName(masterKeyVersion);

            try {
                _cryptoServiceProvider = new RSACryptoServiceProvider(parameters);
            } catch (Exception e) {
                throw new XblException(HResult.XONLINE_E_MASTER_KEY_ERROR, e, "Error getting master key, version = {0}", masterKeyVersion);
            }
        }

        public int MasterKeyVersion
        {
            get { return _masterKeyVersion; }
        }

        public byte[] Decrypt(byte[] encryptedBytes)
        {
            
            byte[] tempBytes;

            using (MemoryStream inputStream = new MemoryStream(encryptedBytes)) {
                using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                    using (MemoryStream outputStream = new MemoryStream()) {
                        
                        while ((tempBytes = binaryReader.ReadBytes(ENCRYPTED_BLOCK_SIZE)).Length > 0) {

                            // the native code writes bytes in the reverse order
                            // of managed code.  reverse bytes for compatibility

                            Array.Reverse(tempBytes);

                            // decrypt the bytes using the provider and then we
                            // write to the stream so we can get one big  array

                            tempBytes = _cryptoServiceProvider.Decrypt(tempBytes, false);
                            outputStream.Write(tempBytes, 0, tempBytes.Length);
                        }

                        return outputStream.ToArray();
                    }
                }
            }
        }
        
        public byte[] Encrypt(byte[] unencryptedBytes)
        {
            byte[] tempBytes;

            using (MemoryStream inputStream = new MemoryStream(unencryptedBytes)) {
                using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                    using (MemoryStream outputStream = new MemoryStream()) {

                        while ((tempBytes = binaryReader.ReadBytes(UNENCRYPTED_BLOCK_SIZE)).Length > 0)
                        {
                            tempBytes = _cryptoServiceProvider.Encrypt(tempBytes, false);

                            // the native code writes bytes in the reverse order
                            // of managed code.  reverse bytes for compatibility

                            Array.Reverse(tempBytes);
                            outputStream.Write(tempBytes, 0, tempBytes.Length);
                        }

                        return outputStream.ToArray();
                    }
                }
            }
        }




        public void Dispose()
        {
            _cryptoServiceProvider.Clear();
        }

        private static string ContainerName(int masterKeyVersion)
        {
            return "XOMasterKey" + masterKeyVersion;
        }

        public static byte[] Decrypt(int masterKeyVersion, byte[] buffer)
        {
            using (MasterKey masterKey = new MasterKey(masterKeyVersion))
            {
                return masterKey.Decrypt(buffer);
            }
        }

        public static byte[] Encrypt(int masterKeyVersion, byte[] buffer)
        {
            using (MasterKey masterKey = new MasterKey(masterKeyVersion))
            {
                return masterKey.Encrypt(buffer);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\lspprot.cs ===
//
// lspprot.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Lsp protocol
//
    
using System;
using STF.common.service;

namespace STF.common.protocol 
{
    public class LspProtocolConstants
    {
        public const uint XONLINE_LSP_MAX_USER_DATA_LEN         = 200;
        public const uint XONLINE_LSP_MAX_LSP_INFO              = 1000;
        public const uint XONLINE_LSP_XNKID_LEN                 = 8;
        public const uint XONLINE_LSP_XNKEY_LEN                 = 16;
        public const uint XONLINE_LSP_MAX_EXPIRATION_SECONDS    = 100000;
        public const uint XONLINE_LSP_DEFAULT_DATASET           = 0xAAAA;
        public const uint XONLINE_LSP_ATTR_TSADDR               = 0x80200001;
        public const uint XONLINE_LSP_ATTR_XNKID                = 0x80200002;
        public const uint XONLINE_LSP_ATTR_KEK                  = 0x80200003;
        public const uint XONLINE_LSP_ATTR_USER                 = 0x80100004;
        public const uint XONLINE_LSP_ATTR_PARAM_USER           = 0x02100004;
    }

    public class LspAdvertiseRequest : XRLObject2
    {
        // Advertise to this titleId
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       titleId;
        
        // You can find me at this IP (Network byte order)
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;
        
        // Expire after this many seconds
        [WireInfo(Min=10, Max=LspProtocolConstants.XONLINE_LSP_MAX_EXPIRATION_SECONDS)]
        public UInt32       ttlInSeconds;

        // Reserved. Zero for now.
        [WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       flags;

        // XNKID for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKID_LEN)]
        public byte[]       xnkid;

        // XNKEY for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKEY_LEN)]
        public byte[]       xnkey;

        // Length in bytes for user data (it's UTF8 encoded)
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public ushort       userDataLength;

        // User data.
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

        public override string Xrl
        {
            get { return "/lsp/advertise.ashx"; }
        }
    }

    public class LspEnumerateRequest : XRLObject2
    {
        // Title-id
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       titleId;
        
        // Length of user data
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public UInt16       userDataLength;

        // If specified (not empty, userDataLength > 0), only entries with 
        // matching userData will be enumerated. If not specified 
        // (userDataLength == 0), all entries will be enumerated
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

        // Return 'resultCount' results starting at 'resultIndex'. Zero is the 
        // first entry. One is the second and so on...
        [WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       resultIndex;

        // Maximum number of results to be returned
        [WireInfo(Min=1, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       resultCount;

        public override string Xrl
        {
            get { return "/lsp/enumerate.ashx"; }
        }
    }

    public class LspEnumerateReply : WireData
    {
        // Number of LspInfos returned in 'lspInfo'
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       lspInfoCount;
        
        // Array with information on Lsp Servers
        [WireInfo(SizeParam="lspInfoCount")]
        public LspEnumerateServerInfo[] lspInfo;
    }

    public class LspEnumerateServerInfo : WireData
    {
        // Ip of the SGLSP (Network byte order)
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;

        // Reserved. Zero for now.
        public UInt32       flags;

        // Length of user data
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public UInt32       userDataLength;

        // User data - the same user data that the server passed in 
        // LspAdvertiseRequest
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\MkcKeyLookup.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace STF.common.utilities2
{
    /// <summary>
    /// Facade for key lookup against a IMultiKeyCollection.
    /// </summary>
    /// <typeparam name="TDescId">Type associated with unique descriptor identifier.</typeparam>
    /// <typeparam name="TKey">Type associated with key for the specified descriptor id.</typeparam>
    /// <typeparam name="TValue">Value type associated with the collection.</typeparam>
    public class MultiKeyLookup<TDescId, TKey, TValue> : IEnumerable<TKey>
    {
        IMultiKeyCollection<TDescId, TValue> owner;
        TDescId descId;

        /// <summary>
        /// Initializes a new instance of the MultiKeyLookup class.
        /// </summary>
        /// <param name="owner">Owner MultiKeyCollection.</param>
        /// <param name="descId">Descriptor id associated with the keys handled by this class.</param>
        public MultiKeyLookup(IMultiKeyCollection<TDescId, TValue> owner, TDescId descId)
        {
            if (null == owner)
            {
                throw new ArgumentNullException("owner");
            }

            if (null == descId)
            {
                throw new ArgumentNullException("descId");
            }

            this.owner = owner;
            this.descId = descId;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">Key to lookup.</param>
        /// <returns>Returns the value associated with the specified oridinal.</returns>
        public TValue this[TKey key]
        {
            get
            {
                return owner[descId, key];
            }
        }

        /// <summary>
        /// Determines whether the specified key is present under the specified key descriptor.
        /// </summary>
        /// <param name="id">Identifier associated with the target key descriptor.</param>
        /// <param name="key">Key associated with the target key descripotor to query against.</param>
        /// <returns>Return true if the key is present under the specified descriptor; otherwise, false.</returns>
        public bool ContainsKey(TKey key)
        {
            return owner.ContainsKey(descId, key);
        }

        /// <summary>
        /// Gets a value from the collection with the specified key.
        /// </summary>
        /// <param name="id">Identifer associated with the target key descriptor.</param>
        /// <param name="key">Key of the value under the specified key descriptor.</param>
        /// <param name="value">
        /// When this method returns, contains the value associated with the specified 
        /// key/descriptor pair, if both are found; otherwise, the default value for 
        /// the associated type.
        /// </param>
        /// <returns>Returns true when the value is found; otherwise, false.</returns>
        public bool TryGetValue(TKey key, out TValue value)
        {
            return owner.TryGetValue(descId, key, out value);
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>An IEnumerator(TKey) object that can be used to iterate through the collection.</returns>
        public IEnumerator<TKey> GetEnumerator()
        {
            return owner.GetKeys<TKey>(descId).GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through a collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return owner.GetKeys<TKey>(descId).GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\MkcMultiKeyCollection.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace STF.common.utilities2
{
    /// <summary>
    /// Represents a collection of multiple key/value tuples.
    /// </summary>
    /// <typeparam name="TKeyId">Type associated with key identifier.</typeparam>
    /// <typeparam name="TValue">Type associated with values in the collection.</typeparam>
    public interface IMultiKeyCollection<TDescId, TValue> : ICollection<TValue>
    {
        /***** Descriptor Access *****/

        /// <summary>
        /// Get the IKeyDescriptor associated with the specified key identifier.
        /// </summary>
        /// <param name="id">Identifier associated with a descriptor.</param>
        /// <returns>Returns the IKeyDescriptor associated with the specified identifier.</returns>
        IKeyDescriptor<TDescId, TValue> this[TDescId id] { get; }

        /// <summary>
        /// Gets an enumerator of the key descriptors registered with this collection.
        /// </summary>
        IEnumerable<IKeyDescriptor<TDescId, TValue>> Descriptors { get; }

        /// <summary>
        /// Indicates whether a descriptor is mapped to the specified identifier.
        /// </summary>
        /// <param name="id">Descriptor identifier to perform the query against.</param>
        /// <returns>Returns true if a key descriptor is registered to the specified identifier; otherwise false.</returns>
        bool ContainsDescriptor(TDescId id);

        /// <summary>
        /// Gets the descriptor associated with the specified descriptor identifier.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="descriptor">
        /// When this method returns, contains the descriptor associated with the identifier if found; 
        /// otherwise, the default value for the associated type.
        /// </param>
        /// <returns>Returns true if the descriptor is found; otherwise, false.</returns>
        bool TryGetDescriptor(TDescId id, out IKeyDescriptor<TDescId, TValue> descriptor);

        /// <summary>
        /// Gets the strongly typed descriptor associated with the specified descriptor identifier.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="descriptor">
        /// When this method returns, contains the descriptor associated with the identifier if found; 
        /// otherwise, the default value for the associated type.
        /// </param>
        /// <returns>Returns true if the descriptor is found; otherwise, false.</returns>
        bool TryGetDescriptor<TKey>(TDescId id, out IKeyDescriptor<TDescId, TKey, TValue> descriptor);

        /// <summary>
        /// Rebuilds a key lookup table for the specified descriptor.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        void RebuildKey(TDescId id);

        /// <summary>
        /// Rebuilds the keys associated with the specified value.
        /// </summary>
        /// <param name="value">Value whose key set will be rebuilt for.</param>
        void RebuildValueKeys(TValue value);

        /***** Value Access *****/

        /// <summary>
        /// Gets the value associated with the specified key descriptor key.
        /// </summary>
        /// <param name="id">Identifier for the descriptor.</param>
        /// <param name="key">The key of the value to get.</param>
        /// <returns>Returns the value associated with the key descriptor key.</returns>
        TValue this[TDescId id, object key] { get; }

        /// <summary>
        /// Gets an enumerator for the values in this collection.
        /// </summary>
        IEnumerable<TValue> Values { get; }

        /// <summary>
        /// Gets an enumerator for the keys in the specified key descriptor.
        /// </summary>
        /// <typeparam name="TKey">Type associated with the keys being returned.</typeparam>
        /// <param name="id">Identifier for the target key descriptor.</param>
        /// <returns>Returns an enumerator for the keys of the specified descriptor.</returns>
        IEnumerable<TKey> GetKeys<TKey>(TDescId id);

        /// <summary>
        /// Determines whether the specified key is present under the specified key descriptor.
        /// </summary>
        /// <param name="id">Identifier associated with the target key descriptor.</param>
        /// <param name="key">Key associated with the target key descripotor to query against.</param>
        /// <returns>Return true if the key is present under the specified descriptor; otherwise, false.</returns>
        bool ContainsKey(TDescId id, object key);

        /// <summary>
        /// Adds multiple values to the collection.
        /// </summary>
        /// <param name="values">Enumeration of values to add.</param>
        void AddRange(IEnumerable<TValue> values);

        /// <summary>
        /// Removes an element from the collection via its key.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="key">Key associated with the value.</param>
        /// <returns>Return true if an item was removed; otherwise, false.</returns>
        bool Remove(TDescId id, object key);
        
        /// <summary>
        /// Gets a value from the collection with the specified key.
        /// </summary>
        /// <param name="id">Identifer associated with the target key descriptor.</param>
        /// <param name="key">Key of the value under the specified key descriptor.</param>
        /// <param name="value">
        /// When this method returns, contains the value associated with the specified 
        /// key/descriptor pair, if both are found; otherwise, the default value for 
        /// the associated type.
        /// </param>
        /// <returns>Returns true when the value is found; otherwise, false.</returns>
        bool TryGetValue(TDescId id, object key, out TValue value);
    }

    /// <summary>
    /// Represents a coupled-key associative collection of values.  In this construct multiple
    /// key mappings may be mapped to the values in this collection.
    /// </summary>
    /// <typeparam name="TDescId">Type associated with the key descriptor.</typeparam>
    /// <typeparam name="TValue">Type associated with the value.</typeparam>
    public class MultiKeyCollection<TDescId, TValue> : IMultiKeyCollection<TDescId, TValue>
    {
        private Dictionary<TDescId, DescriptorContext> descriptors;
        private LinkedList<TValue> values;
        private ReaderWriterLockSlim sync;
        private MultiKeyCollectionOptions<TDescId> options;

        #region Construction Helpers

        /// <summary>
        /// Initializes the descriptors.
        /// </summary>
        /// <param name="descriptors">Key descriptors to associate with the collection.</param>
        /// <param name="options">Key collection options.</param>
        private void InitializeDescriptors(IEnumerable<IKeyDescriptor<TDescId, TValue>> descriptors, MultiKeyCollectionOptions<TDescId> options)
        {
            this.options = options;
            this.options.NullOmittingDescriptors = null; // no need to persist this array

            if (null != descriptors)
            {
                TDescId[] nod; // null omitting descriptors

                nod = options.NullOmittingDescriptors ?? new TDescId[0];

                foreach (var descriptor in descriptors)
                {
                    DescriptorContext dc;
   
                    if (this.descriptors.ContainsKey(descriptor.Identifier))
                    {
                        throw new ArgumentException(
                            "Duplicate descriptor key for descriptor identifier: " + ((descriptor.Identifier == null) ? "(null)" : descriptor.Identifier.ToString()),
                            "descriptor");
                    }

                    dc = new DescriptorContext(descriptor);
                    dc.OmitNullKeys = nod.Contains(descriptor.Identifier);

                    this.descriptors.Add(descriptor.Identifier, dc);
                }
            }
        }

        #endregion

        /// <summary>
        /// Initializes a new instance of the MultiKeyCollection.
        /// </summary>
        private MultiKeyCollection()
        {
            this.descriptors = new Dictionary<TDescId, DescriptorContext>();
            this.sync = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
            this.values = new LinkedList<TValue>();
        }

        /// <summary>
        /// Initializes a new instance of the MultiKeyCollection.
        /// </summary>
        /// <param name="descriptors">Key descriptors to associate with the collection.</param>
        public MultiKeyCollection(params IKeyDescriptor<TDescId, TValue>[] descriptors) : this()
        {
            InitializeDescriptors(descriptors, new MultiKeyCollectionOptions<TDescId>());
        }

        /// <summary>
        /// Initializes a new instance of the MultiKeyCollection.
        /// </summary>
        /// <param name="descriptors">Key descriptors to associate with the collection.</param>
        public MultiKeyCollection(IEnumerable<IKeyDescriptor<TDescId, TValue>> descriptors) : this()
        {
            InitializeDescriptors(descriptors, new MultiKeyCollectionOptions<TDescId>());
        }

        /// <summary>
        /// Initializes a new instance of the MultiKeyCollection.
        /// </summary>
        /// <param name="options">Key collection options.</param>
        /// <param name="descriptors">Key descriptors to associate with the collection.</param>
        public MultiKeyCollection(MultiKeyCollectionOptions<TDescId> options, IEnumerable<IKeyDescriptor<TDescId, TValue>> descriptors) : this()
        {
            InitializeDescriptors(descriptors, options);
        }

        /// <summary>
        /// Initializes a new instance of the MultiKeyCollection.
        /// </summary>
        /// <param name="options">Key collection options.</param>
        /// <param name="descriptors">Key descriptors to associate with the collection.</param>
        public MultiKeyCollection(MultiKeyCollectionOptions<TDescId> options, params IKeyDescriptor<TDescId, TValue>[] descriptors)
            : this()
        {
            InitializeDescriptors(descriptors, options);
        }

        /// <summary>
        /// Get the IKeyDescriptor associated with the specified key identifier.
        /// </summary>
        /// <param name="id">Identifier associated with a descriptor.</param>
        /// <returns>Returns the IKeyDescriptor associated with the specified identifier.</returns>
        public IKeyDescriptor<TDescId, TValue> this[TDescId id]
        {
            get 
            {
                Sync.EnterReadLock();

                try
                {
                    return descriptors[id].Descriptor;
                }
                finally
                {
                    Sync.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Gets the ReaderWriterLockSlim used internally for synchronization to allow
        /// for external consumer synchronization.
        /// </summary>
        public ReaderWriterLockSlim Sync
        {
            get
            {
                return sync;
            }
        }

        /// <summary>
        /// Gets an enumerator of the key descriptors registered with this collection.
        /// </summary>
        public IEnumerable<IKeyDescriptor<TDescId, TValue>> Descriptors
        {
            get 
            {
                Sync.EnterReadLock();

                try
                {
                    return descriptors.Values.Select(dc => dc.Descriptor);
                }
                finally
                {
                    Sync.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Indicates whether a descriptor is mapped to the specified identifier.
        /// </summary>
        /// <param name="id">Descriptor identifier to perform the query against.</param>
        /// <returns>Returns true if a key descriptor is registered to the specified identifier; otherwise false.</returns>
        public bool ContainsDescriptor(TDescId id)
        {
            Sync.EnterReadLock();

            try
            {
                return descriptors.ContainsKey(id);
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets the descriptor associated with the specified descriptor identifier.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="descriptor">
        /// When this method returns, contains the descriptor associated with the identifier if found; 
        /// otherwise, the default value for the associated type.
        /// </param>
        /// <returns>Returns true if the descriptor is found; otherwise, false.</returns>
        public bool TryGetDescriptor(TDescId id, out IKeyDescriptor<TDescId, TValue> descriptor)
        {
            Sync.EnterReadLock();

            try
            {
                DescriptorContext desc;

                if (descriptors.TryGetValue(id, out desc))
                {
                    descriptor = desc.Descriptor;
                    return true;
                }

                descriptor = null;

                return false;
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets the strongly typed descriptor associated with the specified descriptor identifier.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="descriptor">
        /// When this method returns, contains the descriptor associated with the identifier if found; 
        /// otherwise, the default value for the associated type.
        /// </param>
        /// <returns>Returns true if the descriptor is found; otherwise, false.</returns>
        public bool TryGetDescriptor<TKey>(TDescId id, out IKeyDescriptor<TDescId, TKey, TValue> descriptor)
        {
            Sync.EnterReadLock();

            try
            {
                DescriptorContext desc;

                if (descriptors.TryGetValue(id, out desc))
                {
                    if (desc.Descriptor is IKeyDescriptor<TDescId, TKey, TValue>)
                    {
                        descriptor = (IKeyDescriptor<TDescId, TKey, TValue>)desc.Descriptor;
                        return true;
                    }
                }

                descriptor = null;

                return false;
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Rebuilds a key lookup table for the specified descriptor.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <remarks>
        /// This construct is ideal for structures with read-only keys, but
        /// when they are not, this method should be invoked to rebuild the
        /// key table.  In the event that a duplicate is found an exception
        /// will be throw, the collection will be left in the same state it
        /// was in prior to invoking this method.
        /// </remarks>
        public void RebuildKey(TDescId id)
        {
            Sync.EnterWriteLock();

            try
            {
                DescriptorContext oldDesc;

                if (descriptors.TryGetValue(id, out oldDesc))
                {
                    DescriptorContext newDesc;
                    var value = values.First;

                    newDesc = new DescriptorContext(oldDesc.Descriptor);
                    newDesc.OmitNullKeys = oldDesc.OmitNullKeys;

                    while (value != null)
                    {
                        object key;

                        key = oldDesc.Descriptor.KeyExtractor(value.Value);

                        // add null keys only if permitted
                        if (null != key)
                        {
                            if (newDesc.Values.ContainsKey(key))
                            {
                                throw new ArgumentException(
                                    string.Format("Duplicate key found for descriptor identifier: {0}, key: {1}", ((id == null) ? "(null)" : id.ToString()), key), 
                                    "id");
                            }

                            newDesc.Values.Add(key, value);
                        }
                        else if (newDesc.OmitNullKeys == false)
                        {
                            throw new ArgumentException("Null key for descriptor identifier: " + ((id == null) ? "(null)" : id.ToString()), "id");
                        }

                        value = value.Next;
                    }

                    descriptors[id] = newDesc;

                    oldDesc.Values.Clear();
                }
                else
                {
                    throw new ArgumentException(
                        "Descriptor not found with identifier: " + ((id == null) ? "(null)" : id.ToString()),
                        "id");
                }
            }
            finally
            {
                Sync.ExitWriteLock();
            }
        }

        /// <summary>
        /// Rebuilds the keys associated with the specified value.
        /// </summary>
        /// <param name="value">Value whose key set will be rebuilt for.</param>
        /// <remarks>
        /// This construct is ideal for structures with read-only keys, but
        /// when they are not, this method should be invoked to rebuild the
        /// key table.  Encountering an exception here may leave the collection 
        /// in a bad state.
        /// </remarks>
        public void RebuildValueKeys(TValue value)
        {
            LinkedListNode<TValue> target;

            Sync.EnterUpgradeableReadLock();

            try
            {
                // locate the correct linked list node
                target = values.Find(value);
                
                if (null == target)
                {
                    throw new ArgumentException("The specified value is not a member of the collection.", "value");
                }

                Sync.EnterWriteLock();

                try
                {
                    // remove mapping via value (instead of key)
                    foreach (var desc in descriptors.Values)
                    {
                        var pair = desc.Values.FirstOrDefault(p => p.Value == target);

                        // item may not be present if key is null
                        if (null != pair.Value)
                        {
                            desc.Values.Remove(pair.Key);
                        }
                    }

                    // remove the value for the linked list
                    values.Remove(target);
                }
                finally
                {
                    Sync.ExitWriteLock();
                }

                // add the item to the collection
                Add(value);
            }
            finally
            {
                Sync.ExitUpgradeableReadLock();
            }
        }

        /// <summary>
        /// Gets the value associated with the specified key descriptor key.
        /// </summary>
        /// <param name="id">Identifier for the descriptor.</param>
        /// <param name="key">The key of the value to get.</param>
        /// <returns>Returns the value associated with the key descriptor key.</returns>
        public TValue this[TDescId id, object key]
        {
            get
            {
                Sync.EnterReadLock();

                try
                {
                    return descriptors[id].Values[key].Value;
                }
                finally
                {
                    Sync.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Gets an enumerator for the values in this collection.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Sync.EnterReadLock();

                try
                {
                    return values.AsEnumerable();
                }
                finally
                {
                    Sync.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Gets an enumerator for the keys in the specified key descriptor.
        /// </summary>
        /// <typeparam name="TKey">Type associated with the keys being returned.</typeparam>
        /// <param name="id">Identifier for the target key descriptor.</param>
        /// <returns>Returns an enumerator for the keys of the specified descriptor.</returns>
        public IEnumerable<TKey> GetKeys<TKey>(TDescId id)
        {
            Sync.EnterReadLock();

            try
            {
                return descriptors[id].Values.Keys.Cast<TKey>();
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Determines whether the specified key is present under the specified key descriptor.
        /// </summary>
        /// <param name="id">Identifier associated with the target key descriptor.</param>
        /// <param name="key">Key associated with the target key descripotor to query against.</param>
        /// <returns>Return true if the key is present under the specified descriptor; otherwise, false.</returns>
        public bool ContainsKey(TDescId id, object key)
        {
            Sync.EnterReadLock();

            try
            {
                DescriptorContext dc;

                if (descriptors.TryGetValue(id, out dc))
                {
                    return dc.Values.ContainsKey(key);
                }

                return false;
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Removes an element from the collection via its key.
        /// </summary>
        /// <param name="id">Identifier associated with the key descriptor.</param>
        /// <param name="key">Key associated with the value.</param>
        /// <returns>Return true if an item was removed; otherwise, false.</returns>
        public bool Remove(TDescId id, object key)
        {
            Sync.EnterUpgradeableReadLock();

            try
            {
                DescriptorContext dc;

                if (descriptors.TryGetValue(id, out dc))
                {
                    LinkedListNode<TValue> node;

                    if (dc.Values.TryGetValue(key, out node))
                    {
                        Remove(node);

                        return true;
                    }
                }

                return false;
            }
            finally
            {
                Sync.ExitUpgradeableReadLock();
            }
        }

        /// <summary>
        /// Gets a value from the collection with the specified key.
        /// </summary>
        /// <param name="id">Identifer associated with the target key descriptor.</param>
        /// <param name="key">Key of the value under the specified key descriptor.</param>
        /// <param name="value">
        /// When this method returns, contains the value associated with the specified 
        /// key/descriptor pair, if both are found; otherwise, the default value for 
        /// the associated type.
        /// </param>
        /// <returns>Returns true when the value is found; otherwise, false.</returns>
        public bool TryGetValue(TDescId id, object key, out TValue value)
        {
            Sync.EnterReadLock();

            try
            {
                DescriptorContext dc;

                if (descriptors.TryGetValue(id, out dc))
                {
                    LinkedListNode<TValue> node;

                    if (dc.Values.TryGetValue(key, out node))
                    {
                        value = node.Value;

                        return true;
                    }
                }

                value = default(TValue);

                return false;
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Adds a new item to the collection.  The keys will automatically be
        /// associated with this item.
        /// </summary>
        /// <param name="item">Item to add to the collection.</param>
        public void Add(TValue item)
        {
            Sync.EnterUpgradeableReadLock();

            try
            {
                var keys = new List<KeyValuePair<DescriptorContext, object>>();

                // Verify that there are no duplicate keys
                foreach (var descriptor in descriptors.Values)
                {
                    TDescId id;
                    object key;

                    key = descriptor.Descriptor.KeyExtractor(item);
                    id = descriptor.Descriptor.Identifier;

                    // add null keys only if permitted
                    if (null != key)
                    {
                        if (descriptor.Values.ContainsKey(key))
                        {
                            throw new ArgumentException(
                                string.Format("Duplicate key found for descriptor identifier: {0}, key: {1}", ((id == null) ? "(null)" : id.ToString()), key),
                                "id");
                        }

                        keys.Add(new KeyValuePair<DescriptorContext, object>(descriptor, key));
                    }
                    else if (descriptor.OmitNullKeys == false)
                    {
                        throw new ArgumentException("Null key for descriptor identifier: " + ((id == null) ? "(null)" : id.ToString()), "id");
                    }
                }

                Sync.EnterWriteLock();

                try
                {
                    // Create the linked list node
                    var node = values.AddFirst(item);

                    // Attach the node to each key
                    foreach (var key in keys)
                    {
                        key.Key.Values.Add(key.Value, node);
                    }
                }
                finally
                {
                    Sync.ExitWriteLock();
                }
            }
            finally
            {
                Sync.ExitUpgradeableReadLock();
            }
        }

        /// <summary>
        /// Removes all values and key mappings in this collection.
        /// </summary>
        public void Clear()
        {
            Sync.EnterWriteLock();

            try
            {
                values.Clear();

                foreach (var descriptor in descriptors.Values)
                {
                    descriptor.Values.Clear();
                }
            }
            finally
            {
                Sync.ExitWriteLock();
            }
        }

        /// <summary>
        /// Determines whether the specified item is present in the collection.
        /// </summary>
        /// <remarks>
        /// This lookup is done against the collection instead of the key mappings.  There is
        /// a linear cost to this lookup.
        /// </remarks>
        /// <param name="item">Value in the collection to lookup.</param>
        /// <returns>Returns true if the item is found; otherwise, false.</returns>
        public bool Contains(TValue item)
        {
            Sync.EnterReadLock();

            try
            {
                return values.Contains(item);
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Copies the entire collection to a compatible one-dimensional array, 
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional array that is the destination of the elements copied 
        /// from the collection.
        /// </param>
        /// <param name="arrayIndex">The zero-based index in the array at which copying begins.</param>
        public void CopyTo(TValue[] array, int arrayIndex)
        {
            Sync.EnterReadLock();

            try
            {
                values.CopyTo(array, arrayIndex);
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets the number of elements in the collection.
        /// </summary>
        public int Count
        {
            get
            {
                Sync.EnterReadLock();

                try
                {
                    return values.Count;
                }
                finally
                {
                    Sync.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether the collection is read-only. This property 
        /// always returns false, indicating that the collection can be updated.
        /// </summary>
        public bool IsReadOnly
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Adds multiple values to the collection.
        /// </summary>
        /// <param name="values">Enumeration of values to add.</param>
        public void AddRange(IEnumerable<TValue> values)
        {
            if (null != values)
            {
                Sync.EnterWriteLock();

                try
                {
                    foreach (var value in values)
                    {
                        Add(value);
                    }
                }
                finally
                {
                    Sync.ExitWriteLock();
                }
            }
        }

        /// <summary>
        /// Removes a value and key mappings from the collection.
        /// </summary>
        /// <param name="item">Value to remove from the collection.</param>
        /// <returns>Returns true if an item was removed; otherwise, false.</returns>
        public bool Remove(TValue item)
        {
            Sync.EnterUpgradeableReadLock();

            try
            {
                var node = values.Find(item);

                if (null != node)
                {
                    Remove(node);

                    return true;
                }

                return false;
            }
            finally
            {
                Sync.ExitUpgradeableReadLock();
            }
        }

        /// <summary>
        /// Removes a value and key mappings from the collection.
        /// </summary>
        /// <param name="node">Node in the linked list to remove.</param>
        private void Remove(LinkedListNode<TValue> node)
        {
            Sync.EnterWriteLock();

            try
            {
                foreach (var descriptor in descriptors.Values)
                {
                    LinkedListNode<TValue> target;
                    object key;
                    TDescId id;

                    key = descriptor.Descriptor.KeyExtractor(node.Value);
                    id = descriptor.Descriptor.Identifier;

                    // Attempt to quickly remove the node via a current key.

                    if (null != key)
                    {
                        if (descriptor.Values.TryGetValue(key, out target))
                        {
                            if (node == target)
                            {
                                descriptor.Values.Remove(key);

                                continue;
                            }
                        }
                    }

                    // Key not current or null, perform collection scan for node.

                    var pair = descriptor.Values.FirstOrDefault(p => p.Value == node);

                    if (pair.Value == node)
                    {
                        descriptor.Values.Remove(pair.Key);

                        continue;
                    }
                    else if (key != null)
                    {
                        // Impossible!!
                        throw new InvalidOperationException(
                            string.Format("Unable to remove element due to null key for key descriptor: {0}", id));
                    }
                    else if (descriptor.OmitNullKeys == false)
                    {
                        // Impossible!!
                        throw new InvalidOperationException(
                            string.Format("Null key found for non-null omitting key descriptor: {0}", id));
                    }
                }

                values.Remove(node);
            }
            finally
            {
                Sync.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets a typed enumerator for the values in the collection.
        /// </summary>
        /// <returns>Returns an enumerator of the values in the collection.</returns>
        public IEnumerator<TValue> GetEnumerator()
        {
            Sync.EnterReadLock();

            try
            {
                return values.GetEnumerator();
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets an untyped enumerator for the values in the collection.
        /// </summary>
        /// <returns>Returns an enumerator of the values in the collection.</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            Sync.EnterReadLock();

            try
            {
                return values.GetEnumerator();
            }
            finally
            {
                Sync.ExitReadLock();
            }
        }

        #region Support Classes

        /// <summary>
        /// Key descriptor wrapper class that pairs the key descriptor with
        /// the value lookup dictionary.
        /// </summary>
        private class DescriptorContext
        {
            /// <summary>
            /// Initializes a DescriptorContext.
            /// </summary>
            /// <param name="descriptor">Key descriptor to associate with the context.</param>
            public DescriptorContext(IKeyDescriptor<TDescId, TValue> descriptor)
            {
                Values = new Dictionary<object, LinkedListNode<TValue>>();
                Descriptor = descriptor;
            }

            /// <summary>
            /// Gets the key descriptor.
            /// </summary>
            public IKeyDescriptor<TDescId, TValue> Descriptor
            {
                get;
                private set;
            }

            /// <summary>
            /// Gets the value lookup dictionary.
            /// </summary>
            public Dictionary<object, LinkedListNode<TValue>> Values
            {
                get;
                private set;
            }

            /// <summary>
            /// Gets or sets a value indicating whether null keys are omitted.
            /// </summary>
            public bool OmitNullKeys
            {
                get;
                set;
            }

            /// <summary>
            /// Gets the string representation of this object.
            /// </summary>
            /// <returns>Returns the string representation of this object.</returns>
            public override string ToString()
            {
                return string.Format("({0}, OmitNullKeys={1})", Descriptor, OmitNullKeys);
            }
        }

        #endregion
    }

    /// <summary>
    /// Behavior options for MultiKeyCollection.
    /// </summary>
    public struct MultiKeyCollectionOptions<TDescId>
    {
        /// <summary>
        /// Gets or sets an array of key descriptors which omit null
        /// keys.
        /// </summary>
        public TDescId[] NullOmittingDescriptors
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\MkcKeyDescriptor.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace STF.common.utilities2
{
    /// <summary>
    /// Describes essential details for MultiKeyCollection key's
    /// </summary>
    /// <typeparam name="TDescId">Type associated with unique descriptor identifier.</typeparam>
    /// <typeparam name="TValue">Value type associated with the collection.</typeparam>
    public interface IKeyDescriptor<TDescId, TValue>
    {
        /// <summary>
        /// Gets the type associated with the key.
        /// </summary>
        Type KeyType
        {
            get;
        }

        /// <summary>
        /// Gets a delegate responsible for extracting the key from the value.
        /// </summary>
        Func<TValue, object> KeyExtractor
        {
            get;
        }

        /// <summary>
        /// Gets the identifier associated with this descriptor.  This identifier must be 
        /// unique within the scope of a MultiKeyCollection.
        /// </summary>
        TDescId Identifier
        {
            get;
        }
    }

    /// <summary>
    /// Describes essential details for MultiKeyCollection key's.  The key type
    /// is strongly typed in this interface.
    /// </summary>
    /// <typeparam name="TDescId">Type associated with unique descriptor identifier.</typeparam>
    /// <typeparam name="TKey">Type associated with the key.</typeparam>
    /// <typeparam name="TValue">Value type associated with the collection.</typeparam>
    public interface IKeyDescriptor<TDescId, TKey, TValue> : IKeyDescriptor<TDescId, TValue>
    {
        /// <summary>
        /// Gets a delegate responsible for extracting the strongly typed key from the value.
        /// </summary>
        Func<TValue, TKey> TypedKeyExtractor
        {
            get;
        }
    }

    /// <summary>
    /// This class describes MultiKeyCollection key details in a strongly typed fashion.
    /// </summary>
    /// <typeparam name="TDescId">Type associated with unique descriptor identifier.</typeparam>
    /// <typeparam name="TKey">Type associated with the key.</typeparam>
    /// <typeparam name="TValue">Value type associated with the collection.</typeparam>
    public sealed class KeyDescriptor<TDescId, TKey, TValue> : IKeyDescriptor<TDescId, TKey, TValue>
    {
        private TDescId identifier;
        private Func<TValue, TKey> typed_extractor;
        private Func<TValue, object> untyped_extractor;

        /// <summary>
        /// Initializes a new instance of the KeyDescriptor.
        /// </summary>
        /// <param name="identifier">Identifier associated with the descriptor.</param>
        /// <param name="extractor">Delegate used to extract the key from the value.</param>
        public KeyDescriptor(TDescId identifier, Func<TValue, TKey> extractor)
        {
            if (null == extractor)
            {
                throw new ArgumentNullException("extractor");
            }

            if (null == identifier)
            {
                throw new ArgumentNullException("identifier");
            }

            this.identifier = identifier;
            this.typed_extractor = extractor;
            this.untyped_extractor = o => typed_extractor(o);
        }

        /// <summary>
        /// Gets a delegate responsible for extracting the strongly typed key from the value.
        /// </summary>
        public Func<TValue, TKey> TypedKeyExtractor
        {
            get { return typed_extractor; }
        }

        /// <summary>
        /// Gets the type associated with the key.
        /// </summary>
        public Type KeyType
        {
            get { return typeof(TKey); }
        }

        /// <summary>
        /// Gets a delegate responsible for extracting the key from the value.
        /// </summary>
        Func<TValue, object> IKeyDescriptor<TDescId, TValue>.KeyExtractor
        {
            get { return untyped_extractor; }
        }

        /// <summary>
        /// Gets the identifier associated with this descriptor.  This identifier must be 
        /// unique within the scope of a MultiKeyCollection.
        /// </summary>
        public TDescId Identifier
        {
            get { return identifier; }
        }

        /// <summary>
        /// Converts the object to a string represention.
        /// </summary>
        /// <returns>Returns the string representation of the object.</returns>
        public override string ToString()
        {
            if (null == Identifier)
            {
                return "(null)";
            }

            return Identifier.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\msgutil.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

using STF.common.config;
using STF.common.service;

namespace STF.common.protocol 
{
    // Common code shared by CUserMessage and CSystemMessage for building messages
    public class CMessage
    {
        public void AddProperty( ushort wPropTag )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_NULL != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-null property type to a null value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = 0; // For NULL types there is no data
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, byte bData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I1 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-byte property type to a byte value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = bData; // For I1 types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, ushort wData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I2 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-ushort property type to a ushort value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = wData; // For I2 types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, uint dwData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I4 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) &&
                MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-uint property type to a uint value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( dwData );
        }

        public void AddProperty( ushort wPropTag, ulong qwData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I8 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-ulong property type to a ulong value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( qwData );
        }

        public void AddProperty( ushort wPropTag, string strData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_STRING != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-string property type to a string value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            // New UTF8 encoding, no byte order mark, throw on bad encoding
            UTF8Encoding utf8 = new UTF8Encoding( false, true );

            MessageStringProperty str = new MessageStringProperty();
            str.cbString = (ushort) utf8.GetByteCount( strData );
            str.szString = strData;
            str.WriteStream( m_PropDataStream );
        }

        public void AddProperty( ushort wPropTag, DateTime ftData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-time property type to a time value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( ftData.ToFileTimeUtc() );
        }

        public void AddProperty( ushort wPropTag, byte[] rgbData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-binary property type to a binary value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            MessageBinaryProperty bin = new MessageBinaryProperty();
            bin.cbData = (ushort) rgbData.Length;
            bin.rgbData = rgbData;
            bin.WriteStream( m_PropDataStream );
        }

        public void AddAttachment( ushort wPropTag, string strStoragePath, uint cbAttachment, uint dwAttachFlags )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-attachment property type to an attachment value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            // New UTF8 encoding, no byte order mark, throw on bad encoding
            UTF8Encoding utf8 = new UTF8Encoding( false, true );

            MessageAttachmentProperty attach = new MessageAttachmentProperty();
            attach.cbAttach = cbAttachment;
            attach.dwAttachFlags = dwAttachFlags;
            attach.cbAttachUrl = (uint) utf8.GetByteCount( strStoragePath );
            attach.szAttachUrl = strStoragePath;
            attach.WriteStream( m_PropDataStream );
        }

        public void AddProperty( ushort wPropTag, bool fData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-bool property type to a bool value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = fData ? (ushort) 1 : (ushort) 0; // For BOOL types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public ushort SetDetails( ref MessageDetails details )
        {
            details.wPropCount = (ushort) m_alPropDescriptors.Count;

            if( 0 != m_alPropDescriptors.Count )
            {
                details.rgProperties = new MessageProperty[ m_alPropDescriptors.Count ];
                for( int iProp = 0; iProp < m_alPropDescriptors.Count; iProp++ )
                {
                    details.rgProperties[ iProp ] = (MessageProperty) m_alPropDescriptors[ iProp ];
                }

                details.rgbData = m_PropDataStream.ToArray();
                details.cbData = (ushort) m_PropDataStream.Length;

                return (ushort) details.Size();
            }
            else
            {
                details.cbData = 0;
                return 0;
            }
        }

        public void SetAuthData( string authdata )
        {
            m_AuthData = authdata;
        }

        public string GetAuthData()
        {
            return m_AuthData;
        }

        private ArrayList m_alPropDescriptors = new ArrayList();
        private MemoryStream m_PropDataStream = new MemoryStream();
        private string m_AuthData;

    } // class CMessage
 
    // Utility class for sending user messages
    public class CUserMessage : CMessage
    {
        public CUserMessage( ulong qwSenderPUID, ulong qwSenderContext, uint dwMessageFlags, uint dwSenderTitleID,
                            ushort wExpireMinutes, byte bMessageType, string strSenderName )
        {
            m_request = new SendMessageMsg();

            m_request.header.sgaddr.inaSg = 0;
            m_request.header.sgaddr.dwSpiSg = 0;
            m_request.header.sgaddr.qwXboxId = 0;
            m_request.header.sgaddr.abReserved = 0;
            m_request.header.dwSeqNum = 0;            

            m_request.qwSenderID = qwSenderPUID;
            m_request.qwSenderContext = qwSenderContext;
            m_request.dwMessageFlags = dwMessageFlags;
            m_request.dwSenderTitleID = dwSenderTitleID;
            m_request.wExpireMinutes = wExpireMinutes;
            m_request.cRecipients = 0;
            m_request.cbDetails = 0;
            m_request.bMessageType = bMessageType;
            m_request.szSenderName = strSenderName;
        
            m_request.details = new MessageDetails();
            m_request.details.wPropCount = 0;
            m_request.details.cbData = 0;
        }

        static public HResult SendUserMessageForGeneratedAccount( ulong userPuid )
        {
            HResult hr = HResult.E_UNEXPECTED;
            uint messageId = Config.GetUIntSetting(Setting.xuacs_WelcomeToXboxLiveMessageForGeneratedAccount);

            if ( 0 != messageId )
            {
                CUserMessage msg = new CUserMessage(
                      0                                     // qwSenderPUID
                    , 0                                     // qwSenderContext
                    , MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED  // dwMessageFlags
                    , XOn.DASH_TITLE_ID                     // dwSenderTitleID
                    , 0                                     // wExpireMinutes = default
                    , MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE // bMessageType
                    , "LIVE System"                         // strSenderName 
                    );

                msg.AddRecipient( userPuid );
                msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, messageId );

                hr = msg.Send();
            }

            return hr;
        }
        
        public void AddRecipient( ulong qwPUID )
        {
            m_alRecipients.Add( qwPUID );
        }

        public void AddRecipients( ulong[] rgqwPUIDs )
        {
            m_alRecipients.AddRange( rgqwPUIDs );
        }

        public SendMessageReply GetResponse()
        {
            return m_response;
        }

        public byte GetMessageType()
        {
            return m_request.bMessageType;
        }

        public ushort GetExpireMinutes()
        {
            return m_request.wExpireMinutes;
        }

        public uint GetSenderTitleId()
        {
            return m_request.dwSenderTitleID;
        }

        public ulong GetSenderId()
        {
            return m_request.qwSenderID;
        }

        public HResult Send()
        {
            ArrayList recipientList = (ArrayList)(m_alRecipients.Clone());

            // If there are no recipients, then there is nothing to send
            if( 0 == m_alRecipients.Count )
            {
                // Nothing to do
                m_response = new SendMessageReply();
                return 0;
            }

            return SendToList( recipientList );
        }


        /// <summary>
        /// Send message to given list of recipients, in batches of 100.
        /// </summary>
        /// 
        /// <param name="recipients">new list of recipients</param>
        /// <returns>HResult for last batch</returns>
        public HResult SendToList(ArrayList recipients)
        {
            return SendToList(recipients, 100);
        }

        /// <summary>
        /// Send message to given list of recipients, in batches with a size determined by the caller.
        /// </summary>
        /// 
        /// <param name="recipients">new list of recipients</param>
        /// <returns>HResult for last batch</returns>
        public HResult SendToList( ArrayList recipients, int batchLength )
        {
            int sent = 0; // messages sent
            
            // If there are no recipients, then there is nothing to send
            if( 0 == recipients.Count )
            {
                // Nothing to do
                m_response = new SendMessageReply();
                return HResult.S_OK;
            }

            HResult hr = HResult.S_OK;

            while( sent < recipients.Count )
            {
                // add the next batch of recipients
                m_request.cRecipients = (ushort)Math.Min(recipients.Count - sent, batchLength);
                m_request.qwRecipientIDs = new ulong[ m_request.cRecipients ]; 
                for( int iRecip = 0; iRecip < m_request.cRecipients; iRecip++ )
                {
                    m_request.qwRecipientIDs[ iRecip ] = (ulong) recipients[ sent + iRecip ];
                }

                hr = SendInternal();

                if (hr.IsFailure())
                {
                    return hr;
                }
                sent += m_request.cRecipients;
            }

            return hr;
        }
        

        private HResult SendInternal()
        {
            // Add any properties
            m_request.cbDetails = SetDetails( ref m_request.details );

            m_response = new SendMessageReply();
            XRLObject2 xrlo = (XRLObject2) m_response;

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", GetAuthData(), m_request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }                                    

            return m_response.hr;
        }

        private SendMessageMsg m_request;
        private SendMessageReply m_response;
        private ArrayList m_alRecipients = new ArrayList();

    }; // class CUserMessage

    // Utility class for sending system messages
    public class CSystemMessage : CMessage
    {
        public CSystemMessage( uint dwTitleID, ulong qwSenderContext, uint dwRegion, uint dwMessageFlags, 
                               ushort wExpireMinutes, byte bMessageType, string strSenderName, DateTime dtSentTime,
                               string strDescription )
        {
            m_request = new SendSystemMessageMsg();

            m_request.header.sgaddr.inaSg = 0;
            m_request.header.sgaddr.dwSpiSg = 0;
            m_request.header.sgaddr.qwXboxId = 0;
            m_request.header.sgaddr.abReserved = 0;
            m_request.header.dwSeqNum = 0;            

            m_request.dwTitleID = dwTitleID;
            m_request.qwSenderContext = qwSenderContext;
            m_request.dtSentTime = dtSentTime;
            m_request.dwRegion = dwRegion;
            m_request.dwMessageFlags = dwMessageFlags;
            m_request.wExpireMinutes = wExpireMinutes;
            m_request.cbDetails = 0;
            m_request.bMessageType = bMessageType;
            m_request.szSenderName = strSenderName;
            m_request.szDescription = strDescription;
        
            m_request.details = new MessageDetails();
            m_request.details.wPropCount = 0;
            m_request.details.cbData = 0;
        }

        public SendSystemMessageReply GetResponse()
        {
            return m_response;
        }

        public HResult Send()
        {
            // Add any properties
            m_request.cbDetails = SetDetails( ref m_request.details );

            m_response = new SendSystemMessageReply();
            XRLObject2 xrlo = (XRLObject2) m_response;

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", GetAuthData(), m_request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }                                    

            return m_response.hr;
        }

        private SendSystemMessageMsg m_request;
        private SendSystemMessageReply m_response;

    }; // class CSystemMessage

    //
    // Utility wrappers for making Messaging requests and replies as easy as a simple function call
    //
    public class MsgReq
    {
        // These two functions are used internally for all sending of requests.  They allow for overriding this class and
        // using some other sending mechanism besides PostXrlRequest.
        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb, ref respOb );
        }

        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb );
        }

        public HResult EnumMessages( ulong qwUserId, out ushort cMessages, out MessageSummary[] rgMessages )
        {
            EnumerateMessagesMsg request = new EnumerateMessagesMsg();
            EnumerateMessagesReply response = new EnumerateMessagesReply();

            // Build the request
            request.qwUserID = qwUserId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumMessages, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );
            if (hr.IsFailure())
            {
                cMessages = 0;
                rgMessages = null;
                return hr;
            }

            cMessages = response.cMessages;
            rgMessages = response.rgMessages;

            return response.hr;
        }

        public HResult GetMessageSummary( ulong qwUserId, uint dwMessageId, out MessageSummary summary )
        {
            MessageSummaryMsg request = new MessageSummaryMsg();
            MessageSummaryReply response = new MessageSummaryReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetMessageSummary, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if(hr.IsFailure())
            {
                summary = null;
                return hr;
            }

            summary = response.summary;

            return response.hr;
        }

        public HResult GetMessageDetails( ulong qwUserId, uint dwMessageId, uint dwSetFlags, uint dwUnsetFlags, out MessageSummary summary, out MessageDetails details )
        {
            MessageDetailsMsg request = new MessageDetailsMsg();
            MessageDetailsReply response = new MessageDetailsReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwSetFlags = dwSetFlags;
            request.dwUnsetFlags = dwUnsetFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetMessageDetails, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if(hr.IsFailure())
            {
                summary = null;
                details = null;
                return hr;
            }

            summary = response.summary;
            details = response.details;

            return response.hr;
        }

        public HResult DeleteMessage( ulong qwUserId, uint dwMessageId, uint dwFlags )
        {
            DeleteMessageMsg request = new DeleteMessageMsg();
            DeleteMessageReply response = new DeleteMessageReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwFlags = dwFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteMessage, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SetMessageFlags( ulong qwUserId, uint dwMessageId, uint dwSetFlags, uint dwUnsetFlags )
        {
            MessageFlagsMsg request = new MessageFlagsMsg();
            MessageFlagsReply response = new MessageFlagsReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwSetFlags = dwSetFlags;
            request.dwUnsetFlags = dwUnsetFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SetMessageFlags, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SendMessage( 
            ulong qwSenderId, 
            string szSenderName,
            uint dwSenderTitleId,
            ulong qwSenderContext, 
            uint dwMessageFlags,
            ushort wExpireMinutes,
            byte bMessageType,
            ulong[] rgqwRecipients,
            MessageDetails details,
            out RecipientResult[] rgResults )
        {
            SendMessageMsg request = new SendMessageMsg();
            SendMessageReply response = new SendMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.dwMessageFlags = dwMessageFlags;
            request.dwSenderTitleID = dwSenderTitleId;
            request.wExpireMinutes = wExpireMinutes;
            if( null != details )
            {
                request.cbDetails = (ushort) details.Size();
            }
            request.cRecipients = (ushort) rgqwRecipients.Length;
            request.bMessageType = bMessageType;
            request.szSenderName = szSenderName;
            request.qwRecipientIDs = rgqwRecipients;
            request.details = details;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SendMessage, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                rgResults = null;
                return hr;
            }

            rgResults = response.recipients;

            return response.hr;
        }

        public HResult RevokeMessage( ulong qwSenderId, ulong qwSenderContext, byte bMessageType, RecipientResult[] rgRecipients )
        {
            RevokeMessageMsg request = new RevokeMessageMsg();
            RevokeMessageReply response = new RevokeMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.cRecipients = (ushort) rgRecipients.Length;
            request.bMessageType = bMessageType;
            request.rgRecipients = rgRecipients;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "RevokeMessage, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult RevokeMessageEx(ulong qwSenderId, ulong qwSenderContext, byte bMessageType, uint flags, RecipientResult[] rgRecipients, ushort wPropTag, byte[] rgbProp)
        {
            RevokeMessageExMsg request = new RevokeMessageExMsg();
            RevokeMessageReply response = new RevokeMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.cRecipients = (ushort)rgRecipients.Length;
            request.bMessageType = bMessageType;
            request.rgRecipients = rgRecipients;
            request.dwFlags = flags;
            request.wPropTag = wPropTag;
            if (rgbProp != null)
            {
                request.cbProp = (ushort)rgbProp.Length;
                request.rgbProp = rgbProp;
            }
            //TODO: fill in other parameters and expand the API in the future.
            
            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest("RevokeMessageEx, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo);

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult DeleteUserTitle( ulong qwUserId, uint dwTitleId )
        {
            DeleteTitleMsg request = new DeleteTitleMsg();
            DeleteTitleReply response = new DeleteTitleReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteUserTitle, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult EnumUserTitles( ulong qwUserId, out ushort cTitles, out UserTitleData[] rgTitles )
        {
            EnumerateTitlesMsg request = new EnumerateTitlesMsg();
            EnumerateTitlesReply response = new EnumerateTitlesReply();

            // Build the request
            request.qwUserID = qwUserId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumUserTitles, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );
            
            if (hr.IsFailure())
            {
                cTitles = 0;
                rgTitles = null;
                return hr;
            }

            cTitles = response.cTitles;
            rgTitles = response.rgTitles;

            return response.hr;
        }

        public HResult EnumSystemMessages( uint dwTitleId, out ushort cMessages, out SystemMessageSummary[] rgMessages )
        {
            EnumerateSystemMessagesMsg request = new EnumerateSystemMessagesMsg();
            EnumerateSystemMessagesReply response = new EnumerateSystemMessagesReply();

            // Build the request
            request.dwTitleID = dwTitleId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumSystemMessages, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                cMessages = 0;
                rgMessages = null;
                return hr;
            }

            cMessages = response.cMessages;
            rgMessages = response.rgMessages;

            return response.hr;
        }

        public HResult GetSystemMessageDetails( uint dwTitleId, uint dwMessageId, out SystemMessageSummary summary, out MessageDetails details )
        {
            SystemMessageDetailsMsg request = new SystemMessageDetailsMsg();
            SystemMessageDetailsReply response = new SystemMessageDetailsReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.dwMessageID = dwMessageId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetSystemMessageDetails, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                summary = null;
                details = null;
                return hr;
            }

            summary = response.summary;
            details = response.details;

            return response.hr;
        }

        public HResult DeleteSystemMessage( uint dwTitleId, uint dwMessageId, uint dwFlags )
        {
            DeleteSystemMessageMsg request = new DeleteSystemMessageMsg();
            DeleteSystemMessageReply response = new DeleteSystemMessageReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.dwMessageID = dwMessageId;
            request.dwFlags = dwFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteSystemMessage, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SendSystemMessage( 
            uint dwTitleId, 
            string szSenderName,
            ulong qwSenderContext, 
            uint dwRegion,
            uint dwMessageFlags,
            ushort wExpireMinutes,
            byte bMessageType,
            DateTime dtSentTime,
            string szDescription,
            MessageDetails details,
            out uint dwMessageID )
        {
            SendSystemMessageMsg request = new SendSystemMessageMsg();
            SendSystemMessageReply response = new SendSystemMessageReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.qwSenderContext = qwSenderContext;
            request.dtSentTime = dtSentTime;
            request.dwRegion = dwRegion;
            request.dwMessageFlags = dwMessageFlags;
            request.wExpireMinutes = wExpireMinutes;
            if( null != details )
            {
                request.cbDetails = (ushort) details.Size();
            }
            request.bMessageType = bMessageType;
            request.szSenderName = szSenderName;
            request.szDescription = szDescription;
            request.details = details;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SendSystemMessage, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                dwMessageID = 0;
                return hr;
            }

            dwMessageID = response.dwMessageID;

            return response.hr;
        }

    } // class MsgReq

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\messageprot.cs ===
// 
// MessageProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Messaging Service Integration
// Xbox Online Service
// 
// Author: phansen, masonb
//

using System;
using System.IO;
using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.MessageProxy)]


namespace STF.common.protocol 
{    
    //
    // Messaging definitions
    //
    public class MsgDefs
    {
        public const uint XONLINE_MAX_TRANSIENT_MESSAGES              = 25;
        public const uint XONLINE_MAX_PERSISTENT_MESSAGES             = 100;
        public const uint XONLINE_MAX_NUM_MESSAGES                    = (XONLINE_MAX_TRANSIENT_MESSAGES + XONLINE_MAX_PERSISTENT_MESSAGES);
        public const uint XONLINE_MAX_MESSAGE_RECIPIENTS              = 100;
        public const uint XONLINE_MAX_MESSAGE_DETAILS                 = 4096;
        public const uint XONLINE_MAX_SYSTEM_MSGS                     = 100; // max that QMSG_ENUM_SYSTEM_MESSAGES will return

        //
        // Message Flags
        //
        public const uint XONLINE_MSG_FLAG_REQUIRED                   = 0x00000001; // The user is required to read this message
        public const uint XONLINE_MSG_FLAG_RECOMMENDED                = 0x00000002; // The user has a system recommended message
        public const uint XONLINE_MSG_FLAG_HAS_VOICE                  = 0x00000004; // This message contains a voice attachment
        public const uint XONLINE_MSG_FLAG_HAS_TEXT                   = 0x00000008; // This message contains a text body
        public const uint XONLINE_MSG_FLAG_READ                       = 0x00000010; // This message has been read
        public const uint XONLINE_MSG_FLAG_NON_EXPORTABLE             = 0x00000020; // This message should only be displayed on Xbox consoles, not the web
        public const uint XONLINE_MSG_FLAG_TEAM_CONTEXT               = 0x00000040; // This message's sender context refers to a team ID
        public const uint XONLINE_MSG_FLAG_COMP_CONTEXT               = 0x00000080; // This message's sender context refers to a competition event ID
        public const uint XONLINE_MSG_FLAG_ALTERNATE_TITLE            = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint XONLINE_MSG_FLAG_MARKETING                  = 0x00000200; // Used on title-wide messages to indicate the message is marketing related and opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_MS_MARKETING               = 0x00000400; // Used on title-wide messages to indicate the message is Microsoft marketing related and ms opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_HAS_PHOTO                  = 0x00000800; // This message has a photo attachment
        public const uint XONLINE_MSG_FLAG_XENON_COMPATIBLE           = 0x00001000; // This message is xenon only
        public const uint XONLINE_MSG_FLAGS_TITLE_RESERVED            = 0xFF000000; // Flags reserved for title custom messages
        public const uint XONLINE_MSG_FLAG_SENDER_IS_FRIEND           = 0x00800000; // Used by Notification to detect invites that should go to V1 clients
        public const uint XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED        = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint XONLINE_MSG_FLAG_SEND_MSG_OWNED             = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint XONLINE_MSG_FLAGS_RESERVED                  = 0x005FF000; // Flags reserved for future use
        public const uint XONLINE_MSG_FLAGS_VALID_SEND_MASK           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED | 
                                                                          XONLINE_MSG_FLAG_NON_EXPORTABLE |
                                                                          XONLINE_MSG_FLAG_REQUIRED |
                                                                          XONLINE_MSG_FLAG_RECOMMENDED |
                                                                          XONLINE_MSG_FLAG_HAS_VOICE |
                                                                          XONLINE_MSG_FLAG_HAS_TEXT |
                                                                          XONLINE_MSG_FLAG_TEAM_CONTEXT |
                                                                          XONLINE_MSG_FLAG_COMP_CONTEXT |
                                                                          XONLINE_MSG_FLAG_MARKETING |
                                                                          XONLINE_MSG_FLAG_MS_MARKETING |
                                                                          XONLINE_MSG_FLAG_HAS_PHOTO | 
                                                                          XONLINE_MSG_FLAG_XENON_COMPATIBLE); // Flags valid in a call to send a message
        public const uint XONLINE_MSG_FLAGS_TITLE_SETABLE             = ( XONLINE_MSG_FLAG_READ |
                                                                          XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to set on an already sent message
        public const uint XONLINE_MSG_FLAGS_TITLE_CLEARABLE           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to clear on an already sent message

        //
        // Message Property Types
        //
        public const byte XONLINE_MSG_PROP_TYPE_NULL                  = 1;   // The property contains no data
        public const byte XONLINE_MSG_PROP_TYPE_I1                    = 2;   // The property value points to 8-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I2                    = 3;   // The property value points to 16-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I4                    = 4;   // The property value points to 32-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I8                    = 5;   // The property value points to 64-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_STRING                = 6;   // The property value points to a NULL-terminated wide character string
        public const byte XONLINE_MSG_PROP_TYPE_FILETIME              = 7;   // The property value points to a time value
        public const byte XONLINE_MSG_PROP_TYPE_BINARY                = 8;   // The property value points to a binary blob that fits in the message details
        public const byte XONLINE_MSG_PROP_TYPE_ATTACHMENT            = 9;   // The property value points to a binary blob (or directory path, depending on attachment flags) that will be uploaded to storage during XOnlineMessageSend
        public const byte XONLINE_MSG_PROP_TYPE_BOOL                  = 10;  // The property value points to a boolean value (1=TRUE, 0=FALSE)
        public const byte XONLINE_MSG_PROP_TYPE_STRING_ID             = 11;  // The property value contains a string ID whose text can be requested from the string service

        //
        // Attachment Flags
        //
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_NON_EXPORTABLE  = 0x00000001; // This attachment should not be visible when the message is displayed on the web
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY       = 0x00000002; // The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED       = 0xFFFFFFFC; // Flags reserved for future use

        //
        // Message Property Tags
        // Property tags occupy a word where the upper byte indicates the property's data type, and 
        // the lower byte indicates a unique identifier for the property.  Property identifiers only
        // need to be unique within a given message type.
        //
        public static ushort XONLINE_MSG_PROP_TAG( byte type, byte id ) { return (ushort)( type << 8 | id ); }
        public static byte XOnlineMessageGetPropId( ushort tag )      { return (byte)( tag & 0xFF ); }
        public static byte XOnlineMessageGetPropType( ushort tag )    { return (byte)( tag >> 8 ); }

        //
        // Message Property IDs 
        // Property IDs should adhere to the following ranges:
        //
        // Range           Purpose
        // 0x00-0x7F       Reserved for use by titles
        // 0x80-0xBF       Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF       Reserved for use by Microsoft for properties that span all message types
        public const byte XONLINE_MSG_PROP_ID_BUILTIN                 = 0x80; // Used for properties defined by Microsoft
        public const byte XONLINE_MSG_PROP_ID_GLOBAL                  = 0x40; // Used for properties that can span all message types

        //
        // Message IDs
        //
        public const uint XONLINE_MSG_ID_SEND_FAILED                  = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint XONLINE_MSG_ID_SYSTEM_MESSAGE               = 0x40000000; // A message sent by the Live service or a publisher
        public const uint XONLINE_MSG_ID_TRANSIENT_MESSAGE            = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint XONLINE_MSG_ID_BASE_MASK                    = 0x00FFFFFF;
        public const uint XONLINE_MSG_ID_RESERVED_MASK                = 0x1F000000;

        public static bool IsMsgTransient( uint msgid )               { return 0 != ( msgid & XONLINE_MSG_ID_TRANSIENT_MESSAGE ); }

        //
        // Message Types
        //
        // A message type establishes the purpose of the message and the properties that 
        // are required for a message of that type.
        // NOTE: xpnconfig expects these to stay fairly sequential.
        //
        public const byte XONLINE_MSG_TYPE_TITLE_CUSTOM               = 1;  // context: title defined;    required props: title defined
        public const byte XONLINE_MSG_TYPE_FRIEND_REQUEST             = 2;  // context: 0;                required props: none
        public const byte XONLINE_MSG_TYPE_GAME_INVITE                = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte XONLINE_MSG_TYPE_TEAM_RECRUIT               = 4;  // context: inviting team ID; required props: none
        public const byte XONLINE_MSG_TYPE_COMP_REMINDER              = 5;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_EVENT_START
        public const byte XONLINE_MSG_TYPE_COMP_REQUEST               = 6;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_START, XONLINE_MSG_PROP_COMP_REG_CLOSE
        public const byte XONLINE_MSG_TYPE_LIVE_MESSAGE               = 7;  // context: 0                 required props: XONLINE_MSG_PROP_SYSTEM_TEXT
        public const byte XONLINE_MSG_TYPE_PERSONAL_MESSAGE           = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte XONLINE_MSG_TYPE_VIDEO_MESSAGE              = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte XONLINE_MSG_TYPE_QUICK_CHAT_INVITE          = 10; // context: 0
        public const byte XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE          = 11; // context: 0
        public const byte XONLINE_MSG_TYPE_PARTY_CHAT_INVITE          = 12; // context: 0

        public static bool IsNotifyMsgType( byte type )               { return ( type == XONLINE_MSG_TYPE_GAME_INVITE ); }


        //
        // Global property tags, allowed in any message type
        //
        public const ushort XONLINE_MSG_PROP_VOICE_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 2 ); 
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 3 ); 
        public const ushort XONLINE_MSG_PROP_TEXT                     = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_TEXT_LANGUAGE            = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 5 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 6 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 7 ); 
        public const ushort XONLINE_MAX_SUBJECT_SIZE                  = 20;

        //
        //Video Message Properties
        //
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_DATA         = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_CODEC        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );          //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 5 );

        //
        // Invite message properties
        //
        public const ushort XONLINE_MSG_PROP_SESSION_ID               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_SESSION_DESCRIPTION      = ( XONLINE_MSG_PROP_TYPE_STRING<< 8 )      | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_XNADDR      = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_KEY         = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Custom message properties
        //
        public const ushort XONLINE_MSG_PROP_GAME_MESSAGE             = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_PLAYER_MESSAGE           = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_ACTIONS           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_PAYLOAD           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Live system message properties
        //
        public const ushort XONLINE_MSG_PROP_SYSTEM_TEXT              = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_LINK_TO                  = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );

        //
        // Competitions message properties
        //
        public const ushort XONLINE_MSG_PROP_COMP_DATASET             = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        public const ushort XONLINE_MSG_PROP_COMP_NAME                = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x2 );
        public const ushort XONLINE_MSG_PROP_COMP_START               = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x3 );
        public const ushort XONLINE_MSG_PROP_COMP_ROUND               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x4 );
        public const ushort XONLINE_MSG_PROP_COMP_OPPONENT            = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x5 );
        public const ushort XONLINE_MSG_PROP_COMP_ADMIN               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x6 );
        public const ushort XONLINE_MSG_PROP_COMP_REG_CLOSE           = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x7 );
        public const ushort XONLINE_MSG_PROP_COMP_PRIVATE_SLOTS       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x8 );
        public const ushort XONLINE_MSG_PROP_COMP_PUBLIC_SLOTS        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x9 );
        public const ushort XONLINE_MSG_PROP_COMP_UNITS               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xA );
        public const ushort XONLINE_MSG_PROP_COMP_INTERVAL            = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xB );
        public const ushort XONLINE_MSG_PROP_COMP_DAYMASK             = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xC );
        public const ushort XONLINE_MSG_PROP_COMP_DESCRIPTION         = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xD );
        public const ushort XONLINE_MSG_PROP_COMP_URL                 = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xE );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_ID            = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x10 );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_START         = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x11 );

        //
        // Client Types
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE may use the qwSenderContext
        //  to specify specific clients that should suppress the message 
        //  or refer the user to xbox.com to consume the message
        //
        public const byte XONLINE_MSG_CLIENT_XBOXCOM                  = 0x0000000000000001;
        public const byte XONLINE_MSG_CLIENT_XBOX360                  = 0x0000000000000002;
        public const byte XONLINE_MSG_CLIENT_ZUNE                     = 0x0000000000000004;
        public const byte XONLINE_MSG_CLIENT_PANORAMA                 = 0x0000000000000008;

        //
        // LinkTo Destinations
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE has an optional property
        //  to specify a link to an abstract platform client destination that will allow
        //  the user to take action on the message. 
        //
        public const byte XONLINE_MSG_LINKTO_ACCOUNT_MANAGEMENT       = 0x00000001;

        //
        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_WMAVOICE_V90      = 1;
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_SASE3200          = 2;

        //
        // Photo Encoding types (values for XONLINE_MSG_PROP_PHOTO_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_PHOTO_DATA_CODEC_PNG      = 1;
        
        //
        //Personal Message Properties
        //None beyond the text and voice stuff above:
        //
         
        //
        //Quick Chat Invite Properties.
        //
        public const ushort XONLINE_HUD_MSG_PROP_VOICECHAT_PORT       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )           | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        
         
        //
        // Definitions that are internal only, in MSINTERNAL sections of STF.x
        //

        public const uint XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN         = 64;

        // Valid values that can be passed in the dwFlags member of DeleteMessageMsg
        public const uint XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER       = 0x00000001;

        // Valid values that can be found in the dwFlags member of UserTitleData
        public const uint XMSG_USER_TITLE_FLAG_ACCEPT_MARKETING       = 0x00000001;

        // Valid values that can be passed in the dwFlags member of DeleteSystemMessageMsg
        public const uint XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL  = 0x00000001;

        // Utility functions for converting message time values
        public static DateTime MsgTimeToDateTime( uint mt )
        {
            return DateTime.FromFileTimeUtc( (long)( ( (ulong) mt * 10000000 ) + 0x01C2B128BA2B4000 ) );
        }
        public static uint DateTimeToMsgTime( DateTime dt )
        {
            return (uint)( ( dt.ToFileTimeUtc() - 0x01C2B128BA2B4000 ) / 10000000 );
        }

        // RevokeMessageEx flags
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER    = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID          = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER      = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT     = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP        = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE        = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED       = 0xFFFFFFC0;
        
        // Message Notifications (Internal)
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_SAME_TITLE         = 0x000001;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     = 0x000002;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND = 0x000004;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_HAS_VOICE          = 0x000008;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_HAS_TEXT           = 0x000010;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_ALT_TITLE          = 0x000020;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_TITLE_RESERVED     = 0xFF0000;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_RESERVED           = 0x00FFC0;

    }; // end definitions


    public class MessagingXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xmessaging.srf";
            }
        }
    }
    //
    // Structure Representing a single message property. 
    //  Maps to XMSG_PROPERTY in STF.x
    //  
    public class MessageProperty : WireData
    {
        public ushort           wPropTag;           // This property's unique identifier

        // The following 3 fields are part of the unnamed union
        //  in _XMSG_PROPERTY
        public ushort           wPropOffset;        // The offset from the start of rgbData of this property's data
        // public ushort        wData;              // For type XONLINE_MSG_PROP_TYPE_I2 this contains the actual data
        // public byte          bData;              // For type XONLINE_MSG_PROP_TYPE_I1 and XONLINE_MSG_PROP_TYPE_BOOL this contains the actual data

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wPropTag);
            binaryWriter.Write(wPropOffset);
        }
    };

    
    //
    // Structure Representing the entire message details. 
    //  Maps to XMSG_DETAILS in STF.x
    //  
    public class MessageDetails : WireData
    {
        public ushort           wPropCount;
        public ushort           cbData;
              
        [WireInfo(SizeParam="wPropCount")]
        public MessageProperty[]  rgProperties;     // Property descriptors
        
        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data

        public override int Size()
        {
            // pDetails->cbData + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) )
            return cbData + 4 + ( wPropCount * 4 );
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the array sizes
            wPropCount = rgProperties == null ? (ushort)0 : (ushort)rgProperties.Length;
            cbData = rgbData == null ? (ushort)0 : (ushort)rgbData.Length;

            binaryWriter.Write(wPropCount);
            binaryWriter.Write(cbData);
            for (int i = 0; i < wPropCount; ++i)
            {
                rgProperties[i].WriteStream(binaryWriter);
            }
            if (rgbData != null && cbData > 0)
            {
                binaryWriter.Write(rgbData);
            }
        }
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_BINARY in STF.x
    //  
    public class MessageBinaryProperty : WireData
    {
        public ushort           cbData;

        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_STRING in STF.x
    //  
    public class MessageStringProperty : WireData
    {
        public ushort           cbString;

        [WireInfo(SizeParam="cbString", NullTerminate=true)]
        public string           szString;           // Property data
    };


    //
    // Structure Representing an attachment property. 
    //  Maps to XMSG_PROPERTY_ATTACHMENT in STF.x
    //  
    public class MessageAttachmentProperty : WireData
    {
        public uint             cbAttach;
        public uint             dwAttachFlags;
        public uint             cbAttachUrl;
        
        [WireInfo(SizeParam="cbAttachUrl", NullTerminate=true)]
        public string           szAttachUrl;     
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY in STF.x
    //  
    public class MessageSummary : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52;
        }
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY_2 in STF.x
    //  
    public class MessageSummary2 : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2)]
        public byte[]           rgbSubject;

        public string szSubject
        {
            get
            {
                int iMaxIndex = 0;
                for (int i = 0; i < rgbSubject.Length; i += 2)
                {
                    if (rgbSubject[i] == 0 && rgbSubject[i+1] == 0)
                    {
                        iMaxIndex = i;
                        break;
                    }
                }

                return new System.Text.UnicodeEncoding().GetString(rgbSubject, 0, iMaxIndex);
            }

            set
            { 
                string szText = value;
                if (szText.Length >= MsgDefs.XONLINE_MAX_SUBJECT_SIZE)
                {
                    szText = szText.Substring(0, MsgDefs.XONLINE_MAX_SUBJECT_SIZE - 1);
                }

                byte[] rgbData = (new System.Text.UnicodeEncoding()).GetBytes(szText);

                rgbSubject = new byte[MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2];
                for (int i = 0; i < rgbSubject.Length; i++)
                {
                    if (i < rgbData.Length)
                    {
                        rgbSubject[i] = rgbData[i];
                    }
                    else
                    {
                        rgbSubject[i] = 0;
                    }
                }
            }
        }

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52 + (MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2);
        }
    };


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_MSG in STF.x
    //  
    public class EnumerateMessagesMsg : MessagingXrlObject
    {
        public EnumerateMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in STF.x
    //  
    public class EnumerateMessagesReply : XRLObject2
    {
        public EnumerateMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_MESSAGE_SUMMARY )
            return 38 + ( cMessages * MessageSummary.StaticSize() );
        }        
    }


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_2_MSG in STF.x
    //  
    public class EnumerateMessages2Msg : MessagingXrlObject
    {
        public EnumerateMessages2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in STF.x
    //  
    public class EnumerateMessages2Reply : XRLObject2
    {
        public EnumerateMessages2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary2[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_REPLY_MSG ) + cMessages * sizeof( Q_ENUM_MESSAGE_2_REPLY )
            return 38 + ( cMessages * MessageSummary2.StaticSize() );
        }        
    }


    //
    // Structure Representing the reply for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_MSG in STF.x
    //  
    public class MessageSummaryMsg : XRLObject2
    {
        public MessageSummaryMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in STF.x
    //  
    public class MessageSummaryReply : XRLObject2
    {
        public MessageSummaryReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );
            if( HResult.Succeeded( hr ) )
            {
                summary = new MessageSummary();
                summary.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            ushort cbSummary = 0;
            if( HResult.Succeeded( hr ) )
            {
                cbSummary = (ushort) MessageSummary.StaticSize();
            }

            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY )
            return 36 + cbSummary;
        }        
    };


    //
    // Structure Representing the reply for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_2_MSG in STF.x
    //  
    public class MessageSummary2Msg : XRLObject2
    {
        public MessageSummary2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_2_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in STF.x
    //  
    public class MessageSummary2Reply : XRLObject2
    {
        public MessageSummary2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2_REPLY, this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary2  summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            summary = new MessageSummary2();
            summary.ReadStream( binaryReader );

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
            else 
            {
                // If there is a failure, write an empty summary.  This emulates the behavior of the INH's Switchboard::SendEmptyReply() function.
                MessageSummary2 emptySummary = new MessageSummary2();
                emptySummary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_2_MSG ) + sizeof( Q_MESSAGE_SUMMARY_2 )
            return 36 + MessageSummary2.StaticSize();
        }        
    };


    //
    // Structure Representing a request for the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_MSG in STF.x
    //  
    public class MessageDetailsMsg : MessagingXrlObject
    {
        public MessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_DETAILS_MSG )
            return 52;
        }
    };

    //
    // Structure Representing the reply or the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_REPLY_MSG in STF.x
    //  
    public class MessageDetailsReply : XRLObject2
    {
        public MessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            summary = new MessageSummary();
            summary.ReadStream( binaryReader );

            if( HResult.Succeeded( hr ) )
            {
                if( 0 != summary.cbDetails )
                {
                    details = new MessageDetails();
                    details.ReadStream( binaryReader );
                }
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );

                if( 0 != summary.cbDetails )
                {
                    details.WriteStream( binaryWriter );
                }
            }
            else 
            {
                // If there is a failure, write an empty summary.  This emulates the behavior of the INH's Switchboard::SendEmptyReply() function.
                MessageSummary emptySummary = new MessageSummary();
                emptySummary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY ) + cbDetails
            return 36 + MessageSummary.StaticSize() + summary.cbDetails;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_MESSAGE_MSG in STF.x
    //  
    public class DeleteMessageMsg : XRLObject2
    {
        public DeleteMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_MSG )
            return 48;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_MESSAGE_REPLY_MSG in STF.x
    //  
    public class DeleteMessageReply : XRLObject2
    {
        public DeleteMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing the result of a message send to a specific PUID
    //  maps to Q_RECIPIENT_RESULT in STF.x
    //  
    public class RecipientResult: WireData
    {
        public ulong            qwUserID;
        public uint             dwMessageID; // If the send failed, this is the error code, if it succeeded this is the message ID

        public static int StaticSize()
        {
            // sizeof( Q_RECIPIENT_RESULT )
            return 12;
        }        
    };  


    //
    // Structure Representing a request to send a message in the messaging service
    //  maps to Q_SEND_MESSAGE_MSG in STF.x
    //  
    public class SendMessageMsg: XRLObject2
    {
        public SendMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public ushort           cRecipients;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(SizeParam="cRecipients")]
        public ulong []         qwRecipientIDs;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_MSG ) + ( cRecipients * sizeof( ULONGLONG ) ) + cbDetails
            return 78 + ( cRecipients * 8 ) + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendMessage response message
    //  maps to Q_SEND_MESSAGE_REPLY_MSG in STF.x
    //  
    public class SendMessageReply: XRLObject2
    {   
        public SendMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cRecipients;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult [] recipients;            

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_REPLY_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 38 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    }    


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_MSG in STF.x
    //  
    public class RevokeMessageMsg : XRLObject2
    {
        public RevokeMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public ushort           cRecipients;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 51 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    };


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_EX_MSG in STF.x
    //  
    public class RevokeMessageExMsg : XRLObject2
    {
        public RevokeMessageExMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwFlags;
        public ushort           wPropTag;
        public ushort           cRecipients;
        public ushort           cbProp;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        [WireInfo(SizeParam="cbProp")]
        public byte[]           rgbProp;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_EX_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT ) + cbProp
            return 59 + ( cRecipients * RecipientResult.StaticSize() ) + cbProp;
        }        
    };


    //
    // Structure Representing the reply to a RevokeMessage message
    //  maps to Q_REVOKE_MESSAGE_REPLY_MSG in STF.x
    //  
    public class RevokeMessageReply : XRLObject2
    {
        public RevokeMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_TITLE_MSG in STF.x
    //  
    public class DeleteTitleMsg : XRLObject2
    {
        public DeleteTitleMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;    

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_TITLE_REPLY_MSG in STF.x
    //  
    public class DeleteTitleReply : XRLObject2
    {
        public DeleteTitleReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to enumerate titles for a user
    //  maps to Q_ENUM_TITLES_MSG in STF.x
    //  
    public class EnumerateTitlesMsg : XRLObject2
    {
        public EnumerateTitlesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_MSG )
            return 40;
        }        
    };

    //
    // Structure Representing a user-owned title
    //  maps to Q_USER_TITLE in STF.x
    //  
    public class UserTitleData : WireData
    {
        public uint             dwTitleID;
        public DateTime         dtLastLogon;
        public uint             dwFlags;

        public static int StaticSize()
        {
            // sizeof( Q_USER_TITLE )
            return 16;
        }   
    };

    //
    // Structure Representing the reply to an EnumerateTitles message
    //  maps to Q_ENUM_TITLES_REPLY_MSG in STF.x
    //  
    public class EnumerateTitlesReply : XRLObject2
    {
        public EnumerateTitlesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cTitles;    
    
        [WireInfo(SizeParam="cTitles")]
        public UserTitleData[]  rgTitles;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_REPLY_MSG ) + cTitles * sizeof( Q_USER_TITLE )
            return 38 + ( cTitles + UserTitleData.StaticSize() );
        }   
    };


    //
    // Structure Representing a request to set/unset flags on a particular message
    //  maps to Q_MESSAGE_FLAGS_MSG in STF.x
    //  
    public class MessageFlagsMsg : XRLObject2
    {
        public MessageFlagsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_MSG )
            return 52;
        }   
    };

    //
    // Structure Representing the reply to a MessageFlags message
    //  maps to Q_MESSAGE_FLAGS_REPLY_MSG in STF.x
    //  
    public class MessageFlagsReply : XRLObject2
    {
        public MessageFlagsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing summary system message data
    //  maps to Q_SYSTEM_MESSAGE_SUMMARY in STF.x
    //  
    public class SystemMessageSummary : WireData
    {
        public uint             dwTitleID;

        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        public static int StaticSize()
        {
            // sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 116;
        }   
    };


    //
    // Structure Representing a request to enumerate system messages on behalf of a title
    //  maps to Q_ENUM_SYSTEM_MESSAGES_MSG in STF.x
    //  
    public class EnumerateSystemMessagesMsg : XRLObject2
    {
        public EnumerateSystemMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_MSG )
            return 36;
        }   
    }

    //
    // Structure Representing the reply to an EnumerateSystemMessages message
    //  maps to Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG in STF.x
    //  
    public class EnumerateSystemMessagesReply : XRLObject2
    {
        public EnumerateSystemMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public SystemMessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 38 + ( cMessages * SystemMessageSummary.StaticSize() );
        }   
    }


    //
    // Structure Representing a request for the message details of a system message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_MSG in STF.x
    //  
    public class SystemMessageDetailsMsg : XRLObject2
    {
        public SystemMessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SYSTEM_MESSAGE_DETAILS_MSG )
            return 40;
        }   
    };

    //
    // Structure Representing the reply to a SystemMessageDetails message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG in STF.x
    //  
    public class SystemMessageDetailsReply : XRLObject2
    {
        public SystemMessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public SystemMessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override int Size()
        {
            // sizeof( part of Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ) + sizeof( Q_SYSTEM_MESSAGE_SUMMARY ) + cbDetails
            return 36 + SystemMessageSummary.StaticSize() + summary.cbDetails;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != summary.cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != summary.cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };


    // 
    // Structure Representing a request to delete a particular system message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_MSG in STF.x
    //  
    public class DeleteSystemMessageMsg : XRLObject2
    {
        public DeleteSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_MSG )
            return 44;
        }   
    };

    //
    // Structure Representing the reply to a DeleteSystemMessage message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG in STF.x
    //  
    public class DeleteSystemMessageReply : XRLObject2
    {
        public DeleteSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing a request to send a system message in the messaging service
    //  maps to Q_SEND_SYSTEM_MESSAGE_MSG in STF.x
    //  
    public class SendSystemMessageMsg: XRLObject2
    {
        public SendSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ) + cbDetails
            return 144 + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendSystemMessage response message
    //  maps to Q_SEND_SYSTEM_MESSAGE_REPLY_MSG in STF.x
    //  
    public class SendSystemMessageReply: XRLObject2
    {   
        public SendSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG )
            return 40;
        }   
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\NpdbRefreshTypes.cs ===
namespace STF.common.config
{
    public enum NpdbRefreshTypes
    {
        REFRESH_STARTS,
        REFRESH_SERVER_LIST,
        REFRESH_INTERFACES,
        REFRESH_INTERFACE_BUCKETS,
        REFRESH_VIRTUAL_INTERFACE_LISTS,
        REFRESH_VIRTUAL_INTERFACES,
        REFRESH_SETTINGS,
        REFRESH_MULTI_SETTINGS,
        REFRESH_XRL_MAPPINGS,
        REFRESH_XDELAY,
        REFRESH_GAME_CONFIG,
        REFRESH_HEALTH_MAPPINGS,
        REFRESH_LIVE_REGISTRY_SETTINGS,
        REFRESH_SERVICE_KEYS,
        REFRESH_CONFIG_BLOBS,
        REFRESH_ETX_MANIFEST,
        REFRESH_ENDS
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\matchprot.cs ===
//
// MatchProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Service Integration
// Xbox Online Service
//

using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Net;

using STF.common.mgmt;
using STF.common.service;

[assembly: XomAreaDefinition(XomAreaName.MatchProxy)]

namespace STF.common.protocol 
{
    //
    // Matchmaking definitions
    //
    public class MatchDefs
    {
        // this http header is used by stress to direct the match front door at a presence
        // emulator instead of the presence vip.
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";

        public const uint X_MAX_STRING_ATTRIBUTE_LEN                  = 400;
        public const uint X_MAX_BLOB_ATTRIBUTE_LEN                    = 800;

        public const uint X_ATTRIBUTE_SCOPE_MASK                      = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_GLOBAL                    = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC            = 0x00000000;

        // These are the datatypes that were supported in Xbox 1 matchmaking.
        // In Xenon, the match Attributes sent on the wire are actually Xenon
        // Properties and Contexts. Xenon Property and Context ids use the 
        // X_ATTRIBUTE_XENON_DATATYPE_XXX definitions in the next section, not
        // these definitions.
        //
        // We've chosen to extend this Xbox 1 wiredata object instead of
        // creating a similar but new wiredata object for Xenon. To retain
        // compatibility with both Xbox and Xenon clients, Xenon clients
        // will encode the integer, float, datetime, and context attributes as
        // X_ATTRIBUTE_DATATYPE_INTEGER, and use 64 bits on the wire for
        // all of them. The Xenon client will flag String properties with
        // X_ATTRIBUTE_DATATYPE_STRING before putting them on the wire, so
        // they are processed correctly by these wiredata classes.
        // X_ATTRIBUTE_DATATYPE_BLOB properties are not supported in Xenon.
        //
        // The attribute and parameter names in the generated sql code for Xenon
        // titles will not have this xbox 1 "match" datatype information, so the
        // names in the database match the ids in the xlast file. Therefore the front
        // door will mask out these bits before generating attribute or parameter names
        // for xenon titles.
        public const uint X_ATTRIBUTE_DATATYPE_MASK                   = 0x00F00000;
        public const uint X_ATTRIBUTE_DATATYPE_INTEGER                = 0x00000000;
        public const uint X_ATTRIBUTE_DATATYPE_STRING                 = 0x00100000;
        public const uint X_ATTRIBUTE_DATATYPE_BLOB                   = 0x00200000;
        public const uint X_ATTRIBUTE_DATATYPE_NULL                   = 0x00F00000;

        // see comment above on the usage of these datatypes by xenon titles
        public const uint X_ATTRIBUTE_XENON_DATATYPE_MASK                = 0x70000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_CONTEXT             = 0x00000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT32              = 0x10000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT64              = 0x20000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT64             = 0x30000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UNICODE             = 0x40000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT32             = 0x50000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_BINARY              = 0x60000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_DATETIME            = 0x70000000;

        public const uint X_ATTRIBUTE_ID_MASK                         = 0x0000FFFF;

        // These are not used in the wire protocol. They were defined for use
        // by xmltosql, and are now deprecated.
        public const uint X_ATTRIBUTE_TYPE_MASK                       = 0x0F000000;
        public const uint X_ATTRIBUTE_TYPE_SESSION                    = 0x00000000;
        public const uint X_ATTRIBUTE_TYPE_PARAM                      = 0x02000000;
        public const uint X_ATTRIBUTE_TYPE_BUILTIN                    = 0x03000000;
        public const uint X_ATTRIBUTE_TYPE_CONSTANT                   = 0x05000000;

        public const uint X_ATTRIBUTE_RESERVED                        = ~( X_ATTRIBUTE_SCOPE_MASK       |
                                                                           X_ATTRIBUTE_DATATYPE_MASK    |
                                                                           X_ATTRIBUTE_XENON_DATATYPE_MASK |
                                                                           X_ATTRIBUTE_TYPE_MASK        |
                                                                           X_ATTRIBUTE_ID_MASK );
        // Xbox 1 global attributes
        public const uint X_ATTRIBUTE_XBOX1_SESSION_ID = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000001;
        public const uint X_ATTRIBUTE_XBOX1_PUB_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000002;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000003;
        public const uint X_ATTRIBUTE_XBOX1_PUB_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000004;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000005;
        public const uint X_ATTRIBUTE_XBOX1_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000006;
        public const uint X_ATTRIBUTE_XBOX1_APPROX_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000007;
        public const uint X_ATTRIBUTE_XBOX1_NUM_ATTRS = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000011;
        public const uint X_ATTRIBUTE_XBOX1_HOST_ADDR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000012;
        public const uint X_ATTRIBUTE_XBOX1_SESSION_KEY = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000013;

        //
        // These are special, system defined attributes ids used for non-title
        // specific contexts and properties, and/or special query parameters
        //
        // All of these ids contain this flag, so they will not conflict with
        // title defined contexts and properties generated by xlast.
        //
        // These are also used by the 360 console.
        //
        public const uint X_ATTRIBUTE_SYSTEM_FLAG = 0x00008000;

        //
        // Game type context is either ranked or standard
        //
        public const uint X_ATTRIBUTE_GAME_TYPE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        //
        // Game mode context is defined by the game
        //
        public const uint X_ATTRIBUTE_GAME_MODE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;


        //
        // The attribute id used to pass the session id to the system FindById stored proc
        //
        public const uint X_ATTRIBUTE_SESSION_ID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x3;

        //
        // Imported from client tree:
        //
        // Several XLAST files have these defines, and XLAST's gameconfig.h defines
        // them.  They seem to be unused now but the should not be reused lest we
        // risk breaking existing titles.
        //
        public const uint X_ATTRIBUTE_MAX_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x4;
        public const uint X_ATTRIBUTE_MAX_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x5;
        public const uint X_ATTRIBUTE_OPEN_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x6;
        public const uint X_ATTRIBUTE_OPEN_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x7;
        public const uint X_ATTRIBUTE_FILLED_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x8;
        public const uint X_ATTRIBUTE_FILLED_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x9;

        //
        // Client properties used to write to skill leaderboards 
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_RELATIVE_SCORE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        public const uint X_ATTRIBUTE_SESSION_TEAM = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;

 

        //
        // Client properties written at the session level to override TrueSkill parameters
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_PLAYER_PARTIAL_PLAY_PERCENTAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xC;
        public const uint X_ATTRIBUTE_PLAYER_SKILL_UPDATE_WEIGHTING_FACTOR = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xD;
        public const uint X_ATTRIBUTE_SESSION_SKILL_BETA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xE;
        public const uint X_ATTRIBUTE_SESSION_SKILL_TAU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xF;
        public const uint X_ATTRIBUTE_SESSION_SKILL_DRAW_PROBABILITY =  X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10;

        //
        // Attachment size is written to a leaderboard when the entry qualifies for
        // a gamerclip.  The rating can be retrieved via XUserEstimateRankForRating.
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_ATTACHMENT_SIZE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x11;

        //
        // Attribute passed as parameter to session findbyid list
        //
        public const uint X_ATTRIBUTE_SESSION_ID_LIST = X_ATTRIBUTE_XENON_DATATYPE_BINARY
                                                 | X_ATTRIBUTE_DATATYPE_BLOB
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x12;

        // 
        // Gamer properties
        //
        public const uint X_ATTRIBUTE_GAMER_ZONE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x101;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x102;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x103;
        public const uint X_ATTRIBUTE_GAMER_RATING = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x104;
        public const uint X_ATTRIBUTE_GAMER_MU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x105;
        public const uint X_ATTRIBUTE_GAMER_SIGMA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x106;
        public const uint X_ATTRIBUTE_GAMER_PUID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x107;
        public const uint X_ATTRIBUTE_AFFILIATE_VALUE = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x108;
        public const uint X_ATTRIBUTE_GAMER_HOSTNAME = X_ATTRIBUTE_XENON_DATATYPE_UNICODE
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x109;
        public const uint X_ATTRIBUTE_SESSION_SCORE = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10A;
        
        // why did platform type/lock start over at 0x201?  We don't know.  Maybe these aren't "gamer properties"?
        public const uint X_ATTRIBUTE_PLATFORM_TYPE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x201;
        public const uint X_ATTRIBUTE_PLATFORM_LOCK = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x202;


        // list of system attributes that may have weights associated with them, when used 
        // as parameters to a weighted search query.  
        public static uint[] rgWeightablePlatformAttrs = 
        {
            X_ATTRIBUTE_GAMER_ZONE,
            X_ATTRIBUTE_GAMER_COUNTRY,
            X_ATTRIBUTE_GAMER_LANGUAGE,
            X_ATTRIBUTE_GAMER_RATING,
            X_ATTRIBUTE_GAMER_MU,
            X_ATTRIBUTE_GAMER_SIGMA
        };

        // Game type context values
        public const uint X_ATTRIBUTE_GAME_TYPE_RANKED = 0;
        public const uint X_ATTRIBUTE_GAME_TYPE_STANDARD = 1;

        // maximum and default values for legacy xbox 1 titles
        public const uint XMATCH_SCHEMA_MAX_TITLE_QUERIES           = 30;
        public const uint XMATCH_SCHEMA_MAX_CONSTS                  = 50;
        public const uint XMATCH_SCHEMA_MAX_QUERY_NAME_LEN          = 32;
        public const uint XMATCH_SCHEMA_MAX_ATTR_NAME_LEN           = 28;
        public const uint XMATCH_SCHEMA_MAX_CONST_NAME_LEN          = 28;
        public const uint XMATCH_SCHEMA_MAX_PARAM_NAME_LEN          = 24;
        public const uint XMATCH_SCHEMA_MAX_QUERY_FILTERS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_SORTOPS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_RETURNS           = 40;

        public const uint XMATCH_SCHEMA_DEFAULT_SESSION_EXPIRATION  = 86400;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_QUERY_RESULTS   = 25;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_CONSTS          = 50;

        // default values for the social match attributes
        public const uint X_ATTRIBUTE_GAMER_ZONE_DEFAULT            = 1;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT         = 103;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT        = 1;
        public const float X_ATTRIBUTE_GAMER_RATING_DEFAULT         = 58.72f;
        public const double X_ATTRIBUTE_GAMER_MU_DEFAULT            = 3.0d;
        public const double X_ATTRIBUTE_GAMER_SIGMA_DEFAULT         = 1.0d;

        // NOTE: Changing these values impacts both the client and the server.

        // Built-in attributes should not account against X_MATCH_MAX_TITLE_SCHEMA_ATTRS
        // this constant should be adjusted when adding new built-in schema attributes
        public const uint X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS            = 12;
        public const uint X_MATCH_MAX_TITLE_SCHEMA_ATTRS              = 50;
        public const uint X_MATCH_MAX_TOTAL_SCHEMA_ATTRS              = X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS + X_MATCH_MAX_TITLE_SCHEMA_ATTRS;

        public const uint X_MATCH_MAX_QUERY_PARAMS                    = X_MATCH_MAX_TOTAL_SCHEMA_ATTRS;
        public const uint X_MATCH_MAX_WEIGHTED_QUERY_PARAMS_PER_REQ   = 20; 
        public const uint X_MATCH_MAX_QUERY_RESULTS                   = 50;
        public const uint X_MATCH_MAX_ATTRIBUTE_DATA                  = 4096;
        public const uint X_MATCH_MAX_SESSION_LIST_IDS                = 100;

        // NOTES ON PARAMS:

        // X_MATCH_MAX_QUERY_PARAMS is used to express both the max number of params you can declare 
        // for a matchmaking query (in XLAST) and the max number you can pass in one request for that query

        // X_MATCH_MAX_WEIGHTED_PARAMS_PER_REQUEST is the max number of weighted params that can be passed 
        // in a single request for a single query.  This plus the number of non-weighted params will need 
        // to add up to <= X_MATCH_MAX_QUERY_PARAMS

        // both of the above constants have the complication that they include system-defined params and
        // title-defined params.  Right now, there are 12 system-defined params (NUM_BUILTIN_SCHEMA_ATTRS)
        // which we have to assume are always used.  The practical max # of title defined params is 50, 
        // because that's how many attributes they can declare (MAX_TITLE_SCHEMA_ATTRS) and you can't have 
        // a param without a corresponding attr.  12+50 = 62... we have a 

        // Values for MatchSearch.wFlags
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK    = 0x0003; // Contains the NAT type of the calling client, one of XONLINE_NAT_xxx
        public const ushort XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT     = 0x4000; // Indicates that the client wants weighted sort semantics for match search results.
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NO_CACHE         = 0x8000; // Don't use the session cache for this search
        public const ushort XONLINE_MATCH_SEARCH_FLAGS_RESERVED        = unchecked((ushort)
                                                                         ~(XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK |
                                                                          XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT |
                                                                          XONLINE_MATCH_SEARCH_FLAG_NO_CACHE));

        // Lengths of byte arrays used by Match protocols
        public const uint X_MATCH_KEY_EXCHANGE_KEY_LEN                = 16;
        public const uint X_MATCH_HOST_ADDRESS_LEN                    = 36;

        // XNKID definitions
        public const byte XNET_XNKID_MASK                             = 0xF0;    // Mask of flag bits in first byte of XNKID
        public const byte XNET_XNKID_NAT_MASK                         = 0x30;    // Mask of NAT bits for Match create in first byte of XNKID
        public const byte XNET_XNKID_DBINDEX_MASK                     = 0x0F;    // Mask of DB index the session is on for Match-created XNKIDs
        public const byte XNET_XNKID_SYSTEM_LINK                      = 0x00;    // Peer to peer system link session
        public const byte XNET_XNKID_ONLINE_PEER                      = 0x80;    // Peer to peer online session
        public const byte XNET_XNKID_ONLINE_SERVER                    = 0xC0;    // Client to server online session
        public const byte XNET_XNKID_ONLINE_TITLESERVER               = 0xE0;    // Client to title server online session

        // XNKID helper functions
        //
        //  The high four bits of xnkid are flags:
        //
        //  |0|0|x|x| = system link XNKID, xbox hosted
        //  |1|0|x|x| = online XNKID, xbox hosted
        //  |1|1|0|x| = online XNKID, pc server hosted
        //  |1|1|1|x| = online XNKID, title server (note: we should never get this as they should look like xbox hosted)
        //
        // NOTE: In a Matchmaking create call, the lower 2 bits of the high nibble are the NAT type for xbox hosted games
        // (which due to a legacy bug often get sent up looking like system link).
        //
        public static bool XNetXnKidIsSystemLink( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_SYSTEM_LINK; }
        public static bool XNetXnKidIsOnlinePeer( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_PEER; }
        public static bool XNetXnKidIsOnlineServer( ulong xnkid )      { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_SERVER; }
        public static bool XNetXnKidIsOnlineTitleServer( ulong xnkid ) { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_TITLESERVER; }
        public static byte XNetXnKidGetServerType( ulong xnkid )       
        { 
            if( ( xnkid & 0xC0 ) == 0xC0 )
            {
                return (byte)( xnkid & 0xE0 );
            }
            return (byte)( xnkid & 0xC0 );
        }
        public static byte XNetXnKidGetNatType( ulong xnkid ) 
        { 
            if( XNetXnKidIsSystemLink( xnkid ) ||
                XNetXnKidIsOnlinePeer( xnkid ) )
            {
                return (byte)( ( xnkid & XNET_XNKID_NAT_MASK ) >> 4 );
            }
            return 0;
        }
        public static byte XNetXnKidGetDatabaseIndex( ulong xnkid )    { return (byte)( xnkid & XNET_XNKID_DBINDEX_MASK ); }

        // NAT types
        public const byte XONLINE_NAT_UNKNOWN                         = 0;
        public const byte XONLINE_NAT_OPEN                            = 1;
        public const byte XONLINE_NAT_MODERATE                        = 2;
        public const byte XONLINE_NAT_STRICT                          = 3;

        // Default proc Ids used by legacy xbox 1 title config
        public const uint XMATCH_QUERY_TYPE_NORMAL                    = 0;
        public const uint XMATCH_QUERY_TYPE_FINDFROMID                = 1;
        public const uint XMATCH_QUERY_TYPE_AGGREGATE                 = 2;
        public const uint XMATCH_QUERY_TYPE_INVALID                   = 0xffffffff;

        // Filter operations Ids for legacy xbox 1 title config
        public const uint XMATCH_FILTEROP_EQUALS                      = 0;
        public const uint XMATCH_FILTEROP_NOTEQUALS                   = 1;
        public const uint XMATCH_FILTEROP_LESSEQUAL                   = 2;
        public const uint XMATCH_FILTEROP_GREATEREQUAL                = 3;
        public const uint XMATCH_FILTEROP_LESS                        = 4;
        public const uint XMATCH_FILTEROP_GREATER                     = 5;
        public const uint XMATCH_FILTEROP_INVALID                     = 0xffffffff;

        // Sort types for legacy xbox 1 title config
        public const uint XMATCH_SORTOP_ASCENDING                     = 0;
        public const uint XMATCH_SORTOP_DESCENDING                    = 1;
        public const uint XMATCH_SORTOP_NEAR                          = 2;
        public const uint XMATCH_SORTOP_FAR                           = 3;
        public const uint XMATCH_SORTOP_INVALID                       = 0xffffffff;

        // Return types for legacy xbox 1 title config 
        public const uint XMATCH_RETURN_TYPE_NORMAL                   = 0;
        public const uint XMATCH_RETURN_TYPE_AVERAGE                  = 1;
        public const uint XMATCH_RETURN_TYPE_SUM                      = 2;
        public const uint XMATCH_RETURN_TYPE_MINIMUM                  = 3;
        public const uint XMATCH_RETURN_TYPE_MAXIMUM                  = 4;
        public const uint XMATCH_RETURN_TYPE_COUNT                    = 5;
        public const uint XMATCH_RETURN_TYPE_INVALID                  = 0xffffffff;
        
        // Reserved title search sproc indices
        public const uint X_SSINDEX_GET_SESSION                       = 0xFFFFFFFF; // special sproc to retrieve session by session id
        public const uint X_SSINDEX_GET_SESSION_ATTRIBUTES            = 0xFFFFFFFE; // special sproc to retrieve session by session id with attributes
        public const uint X_SSINDEX_GET_SESSION_LIST                  = 0xFFFFFFFD; // special sproc to retrieve a list of sessions by id
        public const uint XMATCH_QUERYID_FLAG_SUMMARY_QUERY           = 0x80000000; // special flag on summary queries so front door can recognize them for caching
        public const uint XMATCH_QUERYID_FLAG_RESERVED                = 0x7FFF0000;

        // Some limitations on game type and mode
        public const uint XMATCH_MAX_GAMETYPE                         = 0x02;
        public const uint XMATCH_MAX_GAMEMODE                         = 0x3e;

        // Some helper functions to make code using the flags defined
        // above more readable.
        public static bool IsAttributeGlobal(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_GLOBAL;
        }

        public static bool IsAttributeTitleSpecific(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC;
        }

        public static bool IsAttributeIdValid(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_RESERVED) == 0;
        }

        public static bool IsAttributeTypeConst(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_TYPE_CONSTANT) 
                == X_ATTRIBUTE_TYPE_CONSTANT;
        }

        public static bool IsSystemAttribute(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SYSTEM_FLAG) 
                == X_ATTRIBUTE_SYSTEM_FLAG;
        }

        public static uint AttributeDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_DATATYPE_MASK;
        }

        public static uint AttributeXenonDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_XENON_DATATYPE_MASK;
        }

        public static uint AttributeType(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_TYPE_MASK;
        }

        public static bool IsAttributeTypeSession(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_SESSION;
        }

        public static bool IsAttributeTypeParam(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_PARAM;
        }

        // this is only used by xbox 1.  360 "builtin" attributes are called "system" attributes,  
        // and you should use IsSystemAttribute() to determine if your attr is one of those.
        public static bool IsAttributeTypeBuiltin(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_BUILTIN;
        }

        public static bool IsAttributeDatatypeInt(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_INTEGER;
        }

        public static bool IsAttributeDatatypeString(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_STRING;
        }

        public static bool IsAttributeDatatypeBlob(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_BLOB;
        }

        public static bool IsAttributeDatatypeNull(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_NULL;
        }

        public static bool IsSearchSystemFindByIdQuery(uint procedureIndex)
        {
            return (procedureIndex == X_SSINDEX_GET_SESSION) || (procedureIndex == X_SSINDEX_GET_SESSION_ATTRIBUTES) || (procedureIndex == X_SSINDEX_GET_SESSION_LIST);
        }

        public static bool IsSearchSummaryQuery(uint procedureIndex)
        {
            if (IsSearchSystemFindByIdQuery(procedureIndex))
            {
                // This is a system FindById query, therefore it is not a
                // summary query
                return false;
            }
            if ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0)
            {
                // the XMATCH_QUERYID_FLAG_SUMMARY_QUERY flag is set,
                // so this is a summary query
                return true;
            }
            return false;
        }

        public static bool IsSummaryQuery(uint procedureIndex)
        {
            return ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0);
        }

        public static bool IsValidQueryProcId(uint procedureIndex)
        {
            return (0 == (XMATCH_QUERYID_FLAG_RESERVED & procedureIndex));
        }

        public static byte SearchFlagsNatType(ushort flags)
        {
            return (byte)(flags & XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK);
        }

        public static bool AreSearchFlagsValid(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAGS_RESERVED & flags) == 0;
        }

        public static bool IsSearchFlagNoCacheSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE & flags) != 0;
        }

        public static bool IsWeightedSortFlagSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT & flags) != 0;
        }

        public static uint GetQueryTypeFromString(string strQueryType)
        {
            uint uiQueryType;
            switch(strQueryType.ToUpper())
            {
                default:
                    uiQueryType = XMATCH_QUERY_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiQueryType = XMATCH_QUERY_TYPE_NORMAL;
                    break;
                case "FINDFROMID":
                    uiQueryType = XMATCH_QUERY_TYPE_FINDFROMID;
                    break;
                case "AGGREGATE":
                    uiQueryType = XMATCH_QUERY_TYPE_AGGREGATE;
                    break;
            }

            return uiQueryType;
        }

        public static uint GetFilterOpFromString(string strFilterOp)
        {
            uint uiFilterOp;

            switch(strFilterOp)
            {
                default:
                    uiFilterOp = XMATCH_FILTEROP_INVALID;
                    break;
                case "==":
                    uiFilterOp = XMATCH_FILTEROP_EQUALS;
                    break;
                case "!=":
                    uiFilterOp = XMATCH_FILTEROP_NOTEQUALS;
                    break;
                case "<=":
                    uiFilterOp = XMATCH_FILTEROP_LESSEQUAL;
                    break;
                case ">=":
                    uiFilterOp = XMATCH_FILTEROP_GREATEREQUAL;
                    break;
                case "<":
                    uiFilterOp = XMATCH_FILTEROP_LESS;
                    break;
                case ">":
                    uiFilterOp = XMATCH_FILTEROP_GREATER;
                    break;
            }

            return uiFilterOp;
        }

        public static uint GetSortOpFromString(string strSortType)
        {
            uint uiSortType;

            switch(strSortType.ToUpper())
            {
                default:
                    uiSortType = XMATCH_SORTOP_INVALID;
                    break;
                case "ASCENDING":
                    uiSortType = XMATCH_SORTOP_ASCENDING;
                    break;
                case "DESCENDING":
                    uiSortType = XMATCH_SORTOP_DESCENDING;
                    break;
                case "NEAR":
                    uiSortType = XMATCH_SORTOP_NEAR;
                    break;
                case "FAR":
                    uiSortType = XMATCH_SORTOP_FAR;
                    break;
            }

            return uiSortType;
        }

        public static uint GetReturnTypeFromString(string strReturnType)
        {
            uint uiReturnType;

            switch(strReturnType.ToUpper())
            {
                default:
                    uiReturnType = XMATCH_RETURN_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiReturnType = XMATCH_RETURN_TYPE_NORMAL;
                    break;
                case "AVERAGE":
                    uiReturnType = XMATCH_RETURN_TYPE_AVERAGE;
                    break;
                case "SUM":
                    uiReturnType = XMATCH_RETURN_TYPE_SUM;
                    break;
                case "MINIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MINIMUM;
                    break;
                case "MAXIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MAXIMUM;
                    break;
                case "COUNT":
                    uiReturnType = XMATCH_RETURN_TYPE_COUNT;
                    break;
            }

            return uiReturnType;
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds)
        {
            return SessionIdListToBytes(rgqwSessionIds, false);
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds, bool swapBytes)
        {
            byte[] rgbSessionIds = new byte[rgqwSessionIds.Length * 8];
            BinaryWriter writer = new BinaryWriter(new MemoryStream(rgbSessionIds));

            // This is when creating the varbinary on SQL server so the conversion operators work
            // correctly
            if(swapBytes)
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    long l = IPAddress.HostToNetworkOrder((long)qwSessionId);
                    writer.Write(l);
                }
            }
            else
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    writer.Write((ulong)qwSessionId);
                }
            }

            return rgbSessionIds;
        }

        public static ulong[] SessionIdListFromBytes(byte []rgbSessionIds)
        {
            if(0 != (rgbSessionIds.Length & 0x3))
            {
                throw new ArgumentException("MatchDefs.SessionIdListFromBytes: Binary data was not a multiple of 8 bytes");
            }

            BinaryReader reader = new BinaryReader(new MemoryStream(rgbSessionIds));

            int cIds = rgbSessionIds.Length >> 3;
            ulong []rgqwSessionIds = new ulong[cIds];

            for(int i = 0; i < cIds; ++i)
            {
                rgqwSessionIds[i] = reader.ReadUInt64();
            }

            return rgqwSessionIds;
        }


        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameTypeFromSessionId(ulong sessionId)
        {
            // the GameType is the lowest 2 bits of the third nibble from the bottom.
            // TODOTHEOM: modify either this function or GetGameType(from attributes) so that
            // they handle the fact that Xbox1 titles current set FF in the type/mode nibbles
            // of the sessionid.  (also applies to GetGameMode)
            // (xbox 1 titles don't have type/mode, so they should return 0 and 0.
            return (byte)((sessionId & 0x0300) >> 8);
        }


        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameModeFromSessionId(ulong sessionId)
        {
            // the game mode is the 4th nibble from the bottom, plus the highest 2 bits
            // of the third nibble from the bottom.  (6 bits total)
            return (byte)((sessionId & 0xFF00) >> 10);
        }

        public static uint GetBucketIdFromSessionId(ulong qwSessionId)
        {
            byte bType = GetGameTypeFromSessionId(qwSessionId);
            byte bMode = GetGameModeFromSessionId(qwSessionId);
            byte bRRId = XNetXnKidGetDatabaseIndex(qwSessionId);
            return (uint)((bType << 16) | (bMode << 8) | bRRId);
        }
        
    }

    public class XNADDR : WireData
    {
        [WireInfo(HexString=true)]
        public uint                 ina;
        [WireInfo(HexString=true)]
        public uint                 inaOnline;
        public ushort               wPortOnline;
        [WireInfo(ArraySize=6)]
        public byte[]               abEnet;
        public SGADDR               sgaddr; // defined in sgprot.cs

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // Allocate members the user has not set explicitly
            if( null == abEnet )
            {
                abEnet = new byte[ 6 ];
            }
            if( null == sgaddr )
            {
                sgaddr = new SGADDR();
            }

            binaryWriter.Write(ina);
            binaryWriter.Write(inaOnline);
            binaryWriter.Write(wPortOnline);
            binaryWriter.Write(abEnet);
            sgaddr.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                ina = (uint)binaryReader.ReadInt32();
                inaOnline = (uint)binaryReader.ReadInt32();
                wPortOnline = (ushort)binaryReader.ReadInt16();
                abEnet = new byte[6];
                binaryReader.Read(abEnet, 0, 6);
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_9, 
                    "Reached end of stream trying to read XNADDR", e);
            }
            return this;
        }

        public XNADDR Copy()
        {
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina                  = ina;
            xnaddr.inaOnline            = inaOnline;
            xnaddr.wPortOnline          = wPortOnline;
            xnaddr.abEnet               = new byte[6];
            Array.Copy(abEnet, xnaddr.abEnet, 6);

            xnaddr.sgaddr = new SGADDR();
            xnaddr.sgaddr.inaSg         = sgaddr.inaSg;
            xnaddr.sgaddr.dwSpiSg       = sgaddr.dwSpiSg;
            xnaddr.sgaddr.qwXboxId      = sgaddr.qwXboxId; 
            xnaddr.sgaddr.abReserved    = sgaddr.abReserved;

            return xnaddr;
        }
    }

    // Structure representing a Matchmaking attribute
    //
    public class MatchAttribute : WireData
    {
        [WireInfo(HexString=true)]
        public uint             dwAttributeId;

        // Only one of the next 3 will be present, depending on the type of dwAttributeId

        [WireInfo(Serialize=false, HexString=true)]
        public ulong            qwValue;

        [WireInfo(Serialize=false)]
        public string           strValue;

        [WireInfo(Serialize=false)]
        public byte[]           rgbValue;


        public MatchAttribute()
        {
        }

        public MatchAttribute(uint dwAttributeId, ulong qwValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
        }

        public MatchAttribute(uint dwAttributeId, double d)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
        }

        public MatchAttribute(uint dwAttributeId, float f)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
        }

        public MatchAttribute(uint dwAttributeId, string strValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
        }

        public MatchAttribute(uint dwAttributeId, byte []rgbValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
        }

        public virtual uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1; // Add a null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                dwAttributeId = (uint)binaryReader.ReadInt32();

                switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
                {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    qwValue = binaryReader.ReadUInt64();
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    ushort cbString = binaryReader.ReadUInt16();
                    if( 0 == cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, XEvent.Id.XMATCHFD_WARN_GEN_1, "MatchAttribute: String attribute size is zero" );
                    }
                    else
                    if( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 < cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_STRING_TOO_LONG, XEvent.Id.COMMON_CODE_46, "MatchAttribute: String attribute exceeds max length (" + cbString.ToString() + " > " + ( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 ).ToString() + ")" );
                    }
                    strValue = Encoding.UTF8.GetString( binaryReader.ReadBytes( cbString - 1 ) ); // Remove the null terminator
                    if( 0 != binaryReader.ReadByte() ) // Consume the null terminator
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, XEvent.Id.XMATCHFD_WARN_GEN_2, "MatchAttribute: String attribute is not null terminated" );
                    }
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    ushort cb = binaryReader.ReadUInt16();
                    if( MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN < cb )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_BLOB_TOO_LONG, XEvent.Id.COMMON_CODE_48, "MatchAttribute: Blob attribute exceeds max length (" + cb.ToString() + " > " + MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN.ToString() + ")" );
                    }
                    rgbValue = binaryReader.ReadBytes( cb );
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                    break;
                default:
                    throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN_3, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttribute", e);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            binaryWriter.Write(dwAttributeId);

            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                binaryWriter.Write( qwValue );
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                byte[] rgbString = Encoding.UTF8.GetBytes( strValue );
                binaryWriter.Write( (ushort)( rgbString.Length + 1 ) ); // Add a null terminator to the length
                if(rgbString.Length > 0)
                {
                    binaryWriter.Write( rgbString );
                }
                binaryWriter.Write( (byte) 0 ); // Add a null terminator
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                binaryWriter.Write( (ushort) rgbValue.Length );
                if(rgbValue.Length > 0)
                {
                    binaryWriter.Write( rgbValue );
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                break;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN_4, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public double ToDouble()
        {
            double d = BitConverter.Int64BitsToDouble((long)qwValue);
            return d;
        }

        public float ToSingle()
        {
            float f = BitConverter.ToSingle(BitConverter.GetBytes(qwValue), 0);
            return f;
        }

        public void FromDouble(double d)
        {
           qwValue = (ulong)BitConverter.DoubleToInt64Bits(d);
        }

        public void FromSingle(float f)
        {
            qwValue = (ulong)(uint)BitConverter.ToInt32(BitConverter.GetBytes(f), 0);
        }
    }



    public class MatchAttributeWeighted : MatchAttribute
    {
        // has all the standard attribute fields, plus a weight
        // the weight should come first off the wire -- readstream controls this ordering
        public float             fltWeight = 0;

       public MatchAttributeWeighted()
        {
        }

        public MatchAttributeWeighted(uint dwAttributeId, ulong qwValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, double d, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, float f, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, string strValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, byte []rgbValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
            this.fltWeight = fltWeight;
        }

        public override uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8 + 4; // ID + VALUE + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1 + 4; // +1 is for null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length; // ID + 2? + byte array + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4 + 4; // ID + WEIGHT
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN, "MatchAttributeWeighted: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                this.fltWeight = binaryReader.ReadSingle();
                base.ReadStream(binaryReader);
                return this;
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttributeWeighted", e);
            }
        }
        
        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // noone should ever writestream on a weighted attribute
            System.Diagnostics.Debug.Assert(false,"WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
            throw new NotSupportedException("WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
        }

        public float GetWeight()
        {
            return fltWeight;
        }
    }



    // Structure representing a Matchmaking search result
    //  maps to XMATCH_SEARCHRESULT in STF.x
    //
    // NOTE: SearchResult's are padded to a 4-byte boundary
    //
    public class SearchResult : WireData
    {
        public uint             dwResultLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        public XNADDR           HostAddress;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        [WireInfo(Serialize=false)]
        public uint             rgbPaddingLen;
        public byte[]           rgbPadding;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfAffiliateValue = -1;

        [WireInfo(Serialize=false)]
        public int           attributeIndexOfScore = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfMu = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfSigma = -1;

        [WireInfo(Serialize=false)]
        public double           drawProbability = -1;

        public void SetDrawProbability(double searcherMu, double searcherSigma)
        {
            if (-1 != attributeIndexOfMu && -1 != attributeIndexOfSigma)
            {
                double resultMu = rgAttributes[attributeIndexOfMu].ToDouble();
                double resultSimga = rgAttributes[attributeIndexOfSigma].ToDouble();

                drawProbability = Math.Exp(
                    -( 
                        ((resultMu - searcherMu) * (resultMu - searcherMu)) +
                        (resultSimga * resultSimga) +
                        (searcherSigma * searcherSigma)
                    ));
            }
        }

        public uint GetBaseSize() { return 84; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwResultLength);
            binaryWriter.Write(qwSessionId);
            HostAddress.WriteStream(binaryWriter);
            binaryWriter.Write(rgbKeyExchangeKey);
            binaryWriter.Write(dwPublicOpen);
            binaryWriter.Write(dwPrivateOpen);
            binaryWriter.Write(dwPublicFilled);
            binaryWriter.Write(dwPrivateFilled);
            binaryWriter.Write(dwNumAttributes);
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                binaryWriter.Write(rgdwAttrOffsets[i]);
            }
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                rgAttributes[i].WriteStream(binaryWriter);
            }
            if (rgbPadding != null)
            {
                binaryWriter.Write(rgbPadding);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int padding;
            int start = (int)binaryReader.BaseStream.Position;

            // Invoke WireData functionality
            base.ReadStream(binaryReader);

            // Spool any padding bytes
            padding = (int)dwResultLength - ((int)binaryReader.BaseStream.Position - start);
            binaryReader.ReadBytes(padding);

            return this;
        }
    }

    public class SearchResultDrawProbabilityComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultDrawProbabilityComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered descending so reverse the usual semantics
            double compare = rhsSearchResult.drawProbability - lhsSearchResult.drawProbability;
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultDrawProbabilityComparer


    public class SearchResultScoreComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultScoreComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered ascending (lower score is better)
            float compare = lhsSearchResult.rgAttributes[lhsSearchResult.attributeIndexOfScore].ToSingle() - rhsSearchResult.rgAttributes[rhsSearchResult.attributeIndexOfScore].ToSingle();
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultScoreComparer



    // Structure representing a request to create or update a session
    //  maps to XMATCH_SESSION in STF.x
    //
    public class MatchSessionMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public override string Xrl { get { return "/xmatch/xmatchhost.srf"; } }
        public uint GetBaseSize() { return 72; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwPublicOpen        = binaryReader.ReadUInt32();
                dwPrivateOpen       = binaryReader.ReadUInt32();
                dwPublicFilled      = binaryReader.ReadUInt32();
                dwPrivateFilled     = binaryReader.ReadUInt32();
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            XEvent.Id.MATCH_HACK_SESSION_NUM_ATTR,
                            String.Format("MatchSessionMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.MATCH_HACK_SESSION_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSessionMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a session creation request
    //  maps to XMATCH_SESSION_INFO in STF.x
    //
    public class MatchSessionReply : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwSessionId);
            binaryWriter.Write(rgbKeyExchangeKey);
        }
    }

    // Structure representing a request to delete a session
    //  maps to XMATCH_SESSION_DELETE in STF.x
    // 
    public class MatchDeleteMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;

        public override string Xrl { get { return "/xmatch/xmatchhostdelete.srf"; } }
        public uint GetBaseSize() { return 16; }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength = (uint)binaryReader.ReadInt32();
                qwSessionId = (ulong)binaryReader.ReadInt64();
                dwTitleId = (uint)binaryReader.ReadInt32();

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_12, 
                    "Reached end of stream trying to read MatchDeleteMsg", e);
            }
            return this;
        }
    }

    // Structure representing a search request
    //  maps to XMATCH_SEARCH in STF.x
    //
    public class MatchSearchMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        [WireInfo(HexString=true)]
        public uint             dwProcedureIndex;
        public XNADDR           ClientAddress;
        public ushort           wNumUsers;
        [WireInfo(HexString=true)]
        public ushort           wFlags;
        public uint             dwNumParameters;

        [WireInfo(SizeParam="dwNumParameters")]
        public uint[]           rgdwParamOffsets;

        [WireInfo(SizeParam="dwNumParameters")]
        public MatchAttribute[] rgParameters;

        // Spring09 introduces the notion of per-parameter weighting, to allow titles
        // more control over search result ordering.
        [WireInfo(MinSchemaVersion="5.3")]
        public uint             dwNumWeightedParameters = 0;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public uint[]           rgdwWeightedParamOffsets;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public MatchAttributeWeighted[] rgWeightedParameters;


        public override string Xrl { get { return "/xmatch/xmatchclient.srf"; } }
        public uint GetBaseSize() { return 56; }

        // MatchSearchMsg uses the default WireData readstream implementation.
    }

    // Structure representing a search reply
    //  maps to XMATCH_SEARCHRESULT_HEADER in STF.x
    //
    public class MatchSearchReply : XRLObject2
    {
        public uint             dwMessageLength;
        public ushort           wNumSearchResults;
        [WireInfo(HexString=true)]
        public ushort           wFlags;             // Unused, always zero
        [WireInfo(HexString=true)]
        public uint             dwLoggingThreshold; // Unused, always zero

        [WireInfo(SizeParam="wNumSearchResults")]
        public SearchResult[]   rgResults;
        public uint GetBaseSize() { return 12; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwMessageLength);
            binaryWriter.Write(wNumSearchResults);
            binaryWriter.Write(wFlags);
            binaryWriter.Write(dwLoggingThreshold);
            for (int i = 0; i < wNumSearchResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }

    }

    // Structure representing a request to split an existing session
    //  maps to XMATCH_SPLIT in STF.x
    //
    public class MatchSplitMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public ulong            qwSplitSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public override string Xrl { get { return "/xmatch/xmatchsplit.ashx"; } }
        public uint GetBaseSize() { return 64; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                qwSplitSessionId    = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            XEvent.Id.MATCH_HACK_SPLIT_NUM_ATTR,
                            String.Format("MatchSplitMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.MATCH_HACK_SPLIT_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSplitMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a split a session
    //  maps to a single XMATCH_SEARCHSESSION in STF.x
    //
    //  We need to work with XRLObject2 but don't want 
    //  SearchResult to extend XRLObject2. On the wire
    //  this is just a search result object.
    //
    public class MatchSplitReply : XRLObject2
    {
        public SearchResult     Session;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // Don't write the padding in a split reply since there is only
            // one result and the client doesn't want padding if there's only
            // one and not an array.
            Session.rgbPadding = null;

            Session.WriteStream(binaryWriter);
        }
    }
} // namespace STF.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\MusicnetToken.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using STF.common.config;
using STF.common.mgmt;
using STF.common.service;
using STF.common.utilities;

namespace STF.common.crypto
{
    public class MusicnetToken
    {
        private static RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();


        public static string GetMusicNetAuthToken(ulong userPuid)
        {
            return GetMusicNetAuthToken(userPuid.ToString("x"));
        }


        public static string GetMusicNetAuthToken(string customerId)
        {
            // get timestamp
            string utcNow = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ssUTC");

            // generate random salt
            int saltLength = Config.GetIntSetting("crux_MusicNetTokenSaltLen");
            byte[] salt = new byte[saltLength];
            rng.GetBytes(salt);

            // generate random IV
            byte[] iv = new byte[16];
            rng.GetBytes(iv);

            // build the encrypted token
            string token = GetMusicNetAuthToken(customerId, utcNow, salt, iv);

            return token;
        }


        public static string GetMusicNetAuthToken(string customerId, string utcNow, byte[] salt, byte[] iv)
        {
            int keyType = Config.GetIntSetting("crux_MusicNetAESKeyType");
            int keyVersion = Config.GetIntSetting("crux_MusicNetAESKeyVer");

            byte[] key = null;

            // get the raw MusicNet key
            try
            {
                key = CryptoReader.GetKey(keyType, keyVersion);
            }
            catch (Exception e)
            {
                HResult hr = HResult.XONLINE_E_UODB_KEY_NOT_FOUND;

                string msg = "GetMusicNetAuthToken: failed to load MusicNet key from UODB.  Verify that xkeymgr been run to add key type 20 to UODB.\r\nException: " + e;

                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR, msg );

                throw new XRLException( hr, XEvent.Id.CRUX_MUSICNET_KEY_LOAD_ERROR, msg );
            }

            string authToken = GetMusicNetAuthToken(key, customerId, utcNow, salt, iv);
            
            return authToken;
        }


        public static string GetMusicNetAuthToken(byte[] key, string customerId, string utcNow, byte[] salt, byte[] iv)
        {
            Xom.Trace(XomAreaName.cryptotools, LogLevel.L_LOW, "ArgoSignIn.GetMusicNetAuthToken: generating authtoken for user: 0x" + customerId);

            string token =
                  Config.GetSetting("crux_MusicNetTokenMagicString") // "TKN"
                + customerId                                         // xuid
                + "|"
                + utcNow;

            Xom.Trace(XomAreaName.cryptotools, LogLevel.L_LOW, "GetMusicNetAuthToken: token: " + token);

            byte[] payload = Encoding.ASCII.GetBytes(token);

            // plaintext is composed of the salt + payload
            byte[] plainText = new byte[salt.Length + payload.Length];

            // first, the salt
            salt.CopyTo(plainText, 0);

            // next, the payload itself
            payload.CopyTo(plainText, salt.Length);

            // encrypt the plain text
            byte[] cipherText = null;
            AesUtil.Encrypt(plainText, key, iv, out cipherText);

            // token = Base64.Encode(iv + cipherText)

            byte[] tokenBytes = new byte[iv.Length + cipherText.Length];
            iv.CopyTo(tokenBytes, 0);
            cipherText.CopyTo(tokenBytes, iv.Length);

            string authToken = Convert.ToBase64String(tokenBytes);

            return authToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\OfferId.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace STF.common.service
{
    [ComVisible(false)]
    public partial struct OfferId : IEquatable<OfferId>
    {
        private ulong _value;

        private OfferId(ulong value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an OfferId
            return "0x" + _value.ToString("X016");
        }

        public static implicit operator OfferId(ulong value)
        {
            return new OfferId(value);
        }

        public static implicit operator ulong(OfferId OfferId)
        {
            // convert a OfferId to ulong
            return OfferId._value;
        }

        #region IEquatable<OfferId> Members

        public bool Equals(OfferId other)
        {
            return _value == other._value;
        }

        #endregion

        public static OfferId Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new OfferId(Convert.ToUInt64(s, 16));
        }

        public static bool TryParse(string s, out OfferId offerId)
        {
            try
            {
                offerId = OfferId.Parse(s);
                return true;
            }
            catch
            {
                offerId = new OfferId(0);
                return false;
            }
        }

        public TitleId TitleId
        {
            get
            {
                return (TitleId)(uint) (_value >> 32);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\NativeSocket.cs ===
using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security;

namespace STF.common.service
{
    // NOTE: This class is incomplete!  Add any additional api wrappers as needed.
    public sealed class NativeSocket : IDisposable
    {
        static NativeSocket()
        {
            // NOTE: There is no matching call to WSACleanup().  If this is a problem, implement and find a good place to call it.
            Int32 iRet = WinApiWSAStartup((UInt16)0x0002, ref _wsaData);
            if (iRet != 0)
            {
                throw new Exception("NativeSocket static constructor: WSAStartup returned " + iRet.ToString());
            }
        }

        public NativeSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
        {
            // it looks like these enums match up to the winsock constants when casted to ints.
            _socket = WinApiSocket((Int32)addressFamily, (Int32)socketType, (Int32)protocolType);
            if (_socket.ToInt32() == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("WinApiSocket() returned INVALID_SOCKET.  WSAGetLastError = " + iError.ToString());
            }
        }

        ~NativeSocket()
        {
            Dispose();
        }

        public void Bind(IPEndPoint localEP)
        {
            byte[] sockaddr_in = BuildSockAddr(localEP);

            Int32 iRet = WinApiBind(_socket, sockaddr_in, (Int32)(sockaddr_in.Length));
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Bind() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }
        }

        public int SendTo(byte[] buffer, IPEndPoint remoteEP)
        {
            byte[] sockaddr_in = BuildSockAddr(remoteEP);
            Int32 iRet = WinApiSendTo(_socket, buffer, (Int32)(buffer.Length), SocketFlags.None, sockaddr_in, (Int32)(sockaddr_in.Length));

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("SendTo() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            return (int)iRet;
        }

        public int ReceiveFrom(byte[] buffer, ref IPEndPoint remoteEP)
        {
            Int32 fromlen = 16;
            byte[] sockaddr_in = new byte[(int)fromlen];
            Int32 iRet = WinApiRecvFrom(_socket, buffer, (Int32)(buffer.Length), SocketFlags.None, sockaddr_in, ref fromlen);

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("ReceiveFrom() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            if (fromlen != (Int32)16)
            {
                throw new Exception("ReceiveFrom() unsupported 'from' length.");
            }

            BuildIPEndpoint(sockaddr_in, ref remoteEP);

            return (int)iRet;
        }

        public bool Select(int microseconds, SelectMode mode)
        {
            FileDescriptorSet fd_set = new FileDescriptorSet(1);
            FileDescriptorSet fd_set_empty = new FileDescriptorSet(0);

            fd_set.Array[0] = (IntPtr)_socket.ToInt32();

            // ... but it doesn't JIT
            TimeValue timeval = new TimeValue();

            timeval.Seconds = 0;
            timeval.Microseconds = microseconds;

            Int32 iRet = (Int32)(-1);

            switch (mode)
            {
                case SelectMode.SelectRead:
                    iRet = WinApiSelect((Int32)1, ref fd_set, ref fd_set_empty, ref fd_set_empty, ref timeval);
                    break;

                case SelectMode.SelectWrite:
                    iRet = WinApiSelect((Int32)1, ref fd_set_empty, ref fd_set, ref fd_set_empty, ref timeval);
                    break;

                case SelectMode.SelectError:
                    iRet = WinApiSelect((Int32)1, ref fd_set_empty, ref fd_set_empty, ref fd_set, ref timeval);
                    break;
            }

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Select() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            return (iRet != (Int32)0);
        }

        public void Shutdown(SocketShutdown how)
        {
            Int32 iRet = WinApiShutdown(_socket, (Int32)how);
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Shutdown() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }
        }

        public void Close()
        {
            Int32 iRet = WinApiCloseSocket(_socket);
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Close() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            _socket = IntPtr.Zero;
        }

        public void Dispose()
        {
            if (_socket != IntPtr.Zero)
            {
                Shutdown(SocketShutdown.Both);
                Close();
            }
        }

        static private void BuildIPEndpoint(byte[] sockaddr_in, ref IPEndPoint ep)
        {
            Int16 sin_family = (Int16)(sockaddr_in[0] + (sockaddr_in[1] << 8));
            UInt16 sin_port = (UInt16)((sockaddr_in[2] << 8) + sockaddr_in[3]);
            string sin_addr =
                sockaddr_in[4].ToString() + "." +
                sockaddr_in[5].ToString() + "." +
                sockaddr_in[6].ToString() + "." +
                sockaddr_in[7].ToString();

            ep.Port = sin_port;
            ep.Address = IPAddress.Parse(sin_addr);
        }

        static private byte[] BuildSockAddr(IPEndPoint ep)
        {
            if (ep.AddressFamily != AddressFamily.InterNetwork)
            {
                throw new Exception("BuildSockAddr(): unsupported Address Family.");
            }

            byte[] sockaddr_in = new byte[16];

            Int16 sin_family = (Int16)ep.AddressFamily;
            UInt16 sin_port = (UInt16)ep.Port;
            byte[] sin_addr = ep.Address.GetAddressBytes();

            sockaddr_in[0] = (byte)(sin_family & 0xFF);
            sockaddr_in[1] = (byte)((sin_family >> 8) & 0xFF);

            sockaddr_in[2] = (byte)((sin_port >> 8) & 0xFF);
            sockaddr_in[3] = (byte)(sin_port & 0xFF);

            for (int i = 0; i < 4; i++)
            {
                sockaddr_in[4 + i] = sin_addr[i];
            }

            // sin_zero
            for (int i = 8; i < 16; i++)
            {
                sockaddr_in[i] = 0;
            }

            return sockaddr_in;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct WSAData
        {
            public Int16 wVersion;
            public Int16 wHighVersion;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 257)]
            public String szDescription;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 129)]
            public String szSystemStatus;
            public Int16 iMaxSockets;
            public Int16 iMaxUdpDg;
            public IntPtr lpVendorInfo;
        }


        [Flags]
        private enum SocketFlags
        {
            None                = 0x0000,
            OutOfBand           = 0x0001,
            Peek                = 0x0002,
            DontRoute           = 0x0004,
            // see: http://as400bks.rochester.ibm.com/pubs/html/as400/v4r5/ic2978/info/apis/recvms.htm
            MaxIOVectorLength   = 0x0010,
            Partial             = 0x8000,
        }; // enum SocketFlags


        // Structure used in select() call, taken from the BSD file sys/time.h.
        [StructLayout(LayoutKind.Sequential)]
        private struct TimeValue
        {
            public int Seconds;
            public int Microseconds;
        } // struct TimeValue


        [StructLayout(LayoutKind.Sequential)]
        private struct FileDescriptorSet
        {
            //
            // how many are set?
            //
            public int Count;
            //
            // an array of Socket handles
            //
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MaxCount)]
            public IntPtr[] Array;

            public static readonly int Size = Marshal.SizeOf(typeof(FileDescriptorSet));
            public static readonly FileDescriptorSet Empty = new FileDescriptorSet(0);
            public const int MaxCount = 64;

            public FileDescriptorSet(int count)
            {
                Count = count;
                Array = count == 0 ? null : new IntPtr[MaxCount];
            }
        }   // class FileDescriptorSet


        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="WSAStartup",
         SetLastError=true,
         CharSet=CharSet.Auto)]
        static private extern Int32 WinApiWSAStartup(UInt16 wVersion, ref WSAData wsaData);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="socket",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern IntPtr WinApiSocket(Int32 af, Int32 type, Int32 protocol);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="bind",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiBind(IntPtr socket, byte[] name, Int32 namelen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="sendto",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiSendTo(IntPtr socket, byte[] buf, Int32 len, SocketFlags flags, byte[] to, Int32 tolen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="recvfrom",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiRecvFrom(IntPtr socket, byte[] buf, Int32 len, SocketFlags flags, byte[] from, ref Int32 fromlen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="select",
         SetLastError=true,
         CharSet = CharSet.Ansi)]
        static private extern Int32 WinApiSelect(Int32 nfds, ref FileDescriptorSet readfds, ref FileDescriptorSet writefds, ref FileDescriptorSet exceptfds, ref TimeValue timeout);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="shutdown",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiShutdown(IntPtr socket, Int32 how);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="closesocket",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiCloseSocket(IntPtr socket);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="WSAGetLastError",
         SetLastError=true,
         CharSet=CharSet.Auto)]
        static private extern Int32 WinApiWSAGetLastError();

        static private WSAData _wsaData = new WSAData();

        private IntPtr _socket = IntPtr.Zero;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\PathInfo.cs ===
using System;
using System.Text.RegularExpressions;

using STF.common.service;
using STF.common.mgmt;


// trace area for PathInfo code
[assembly: XomAreaDefinition(XomAreaName.pathTrace)]

namespace STF.common.protocol 
{
    public class PathInfo
    {
        public string _ipAddress;
        public string _domainQualifiers;
        public StorageDomain _domain;
        public IdType _keyType;
        public ulong  _keyValue;
        public string _pathName;
        public string _unparsedPathName;
        public string _partitionInfo;
        
        // Parse
        // Parse pathname info into its distinct components
        public static PathInfo Parse(string name)
        {
            // don't bother with null or empty strings
            if ( name == null || name == "" )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_163,
                    "PathInfo.Parse: null or empty pathName");
            }
            
            Match pathMatch = _filePathRegex.Match(name);
            
            if ( pathMatch.Success )
            {
                string value;

                PathInfo pi = new PathInfo();

                pi._ipAddress = pathMatch.Groups["ipaddr"].Value.ToLower();
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._ipAddress: " + pi._ipAddress);

                value = pathMatch.Groups["domain"].Value.ToLower();
                try
                {
                    pi._domain = StorageDomainList.GetDomain(value);
                }
                catch (Exception e)
                {
                    XRLException se = e as XRLException;
                    if ( se == null )
                    {
                        se = new XRLException(
                            HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_164,
                            "Parse: invalid domain; found: " + value,
                            e);
                    }
                    if ( se != e )
                    {
                        throw se;
                    }
                    else
                    {
                        throw;
                    }
                }
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._domain: " + pi._domain._name);

                pi._domainQualifiers = pathMatch.Groups["qualifiers"].Value.ToLower();
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._domainQualifiers: " + pi._domainQualifiers);

                value = pathMatch.Groups["keytype"].Value.ToLower();
                pi._keyType = GetKeyType(value);

                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, String.Format("PathInfo._keyType: {0} ({1})", value, pi._keyType));
                
                if ( pi._keyType == IdType.Undefined )  
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_165, 
                            "PathInfo.Parse: key type: " + value + 
                            " is not a valid identifier type.");
                }
                

                try
                {
                    pi._keyValue = Convert.ToUInt64(pathMatch.Groups["keyval"].Value.ToLower(), 16);
                    Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._keyValue: " + pi._keyValue);
                }
                catch (Exception e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_166, 
                            "PathInfo.Parse: key value: " + pathMatch.Groups["keyval"].Value.ToLower() + 
                            " is not a valid hex key value (caught exception: " + e + 
                            ").");
                }

                pi._pathName = pathMatch.Groups["path"].Value;
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._pathName: " + pi._pathName);
                
                pi._unparsedPathName = name;

                // expose just the partition portion of the path component
                pi._partitionInfo =
                    "/" + pi._ipAddress +
                    "/" + pi._domain._name + pi._domainQualifiers +
                    "/" + pathMatch.Groups["keytype"].Value.ToLower() + ":" + pathMatch.Groups["keyval"].Value.ToLower();

                return pi;
            }
            else
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_167,
                    "PathInfo.Parse: malformed pathName: " + name);
            }
        }

        private static IdType GetKeyType(string value)
        {
            IdType id;
            switch ( value )
            {
                case "u":
                    id = IdType.UserId;
                    break;
                case "t":
                    id = IdType.TitleId;
                    break;
                default:
                    id = IdType.Undefined;
                    break;
            }

            return id;
        }

        public void Validate()
        {
            Validate(true);
        }
    
        public void Validate(bool checkPathRegex)
        {
            if ( ( _domain._name.Length + _domainQualifiers.Length ) > ProtocolConstants.maxSizeDomain )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_168,
                    "Validate: domain component too large: " + _domain._name + _domainQualifiers);
            }
            
            if ( _keyType >= IdType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_169,
                    "Validate: invalid key type: " + _keyType);
            }
            
            if ( _pathName == null || _pathName.Length == 0 )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_170,
                    "Validate: invalid empty pathName: " + _pathName);
            }

            // the following checks are applied the to last portion of the path, since
            // the xbox client code will use that in a Win32 CreateFile call

            int lastSlash = _pathName.LastIndexOf('/');
            string fileNameLower = _pathName.Substring(lastSlash + 1).ToLower();

            // these characters are not allowed anywhere in a filename
            char [] invalidCharacters = { '<', '>', ':', '"', '\\', '|' };
            if ( fileNameLower.LastIndexOfAny(invalidCharacters) != -1)
                throw new XRLException(HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH, XEvent.Id.COMMON_CODE_171,
                    "Validate: invalid character in pathName: " + _pathName);

            // these are device names and cannot be used as a filename
            string [] invalidFileNames = {
                "con", "prn", "aux", "clock$", "nul", "com1", "com2", "com3", "com4", "com5", "com6", 
                "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"
            };
            for (int i = 0; i < invalidFileNames.Length; i++)
            {
                if ( string.CompareOrdinal(fileNameLower, invalidFileNames[i]) == 0)
                    throw new XRLException(HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH, XEvent.Id.COMMON_CODE_172,
                        "Validate: invalid pathName, contains a reserved file name: " + _pathName);
            }
            
            if ( checkPathRegex && _domain.Policy.PathValidationRegex != null )
            {
                Match m = _domain.Policy.PathValidationRegex.Match( _pathName );
                if ( !m.Success )
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_173,
                        "Validate: invalid nonconforming pathName: " + _pathName);
                }
            }
        }
    
        public void Validate(IStorageRequest req, bool checkPathRegex)
        {
            Validate(checkPathRegex);
        }

        public void Validate(IStorageRequest req)
        {
            Validate(true);
        }

        public string IpAddress
        {
            get { return _ipAddress; }
        }
    
        public string DomainQualifiers
        {
            get { return _domainQualifiers; }
        }
    
        public StorageDomain Domain
        {
            get { return _domain; }
        }

        public IdType KeyType
        {
            get { return _keyType; }
        }
    
        public ulong KeyValue
        {
            get { return _keyValue; }
        }
    
        public string PathName
        {
            get { return _pathName; }
        }

        public string UnparsedPathName
        {
            get { return _unparsedPathName; }
        }

        public string PartitionInfo
        {
            get { return _partitionInfo; }
        }
    
        // regular expression to parse filepaths
        // [^\p{Cc}] means any character not in the Unicode Control category
        //    so embedded nul characters and other control characters are not
        //    allowed
        private const string filePathRegexSpec =
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
            +   @"/(?<domain>\w+)"                                  // storage domain
            +   @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
            +   @"/(?:"
            +        @"(?<keytype>[u]):(?<keyval>[0-9a-z]{1,16})|"  // key type and key value
            +        @"(?<keytype>[t]):(?<keyval>[0-9a-f]{1,8})"    // key type and key value
            +   @")"
            +   @"(?<path>/[^\p{Cc}]+)$";                           // pathname (with leading /)
            
        private static Regex _filePathRegex = new Regex(filePathRegexSpec, RegexOptions.IgnoreCase|RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Npdb.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.Collections;

namespace STF.common.config
{
   public partial class ConfigInstance
   {
        internal class NpdbAccess
        {
            public static Hashtable GetBatchSettingsFromDB(string npdbConnectionString, string szEnvironment, int iSiteId, string szServer, string szComponent, string szXmlQuery)
            {
                //This calls NPDB p_config_batch_get_settings_ranked
                //input XML String = <a vc_setting="" /> ==> NOTE ALL SETTINGS MUST BE UNIQUE
                //output RowSet = (vc_setting, vc_value)
                //If the setting is not found in NPDB, vc_value is NULL.
                //NOTE: the old common config used to throw an exception when vc_value is NULL
                Hashtable htSettings = new Hashtable();
                
                using (SqlConnection npdbConnection = new SqlConnection(npdbConnectionString))
                {
                    npdbConnection.Open();

                    SqlCommand cmd = npdbConnection.CreateCommand();
                    cmd.CommandText = "p_config_batch_get_settings_ranked";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.Add("@vc_environment_override_info", SqlDbType.NVarChar).Value = szEnvironment;
                    cmd.Parameters.Add("@i_site_id_override_info", SqlDbType.Int).Value = iSiteId;
                    cmd.Parameters.Add("@vc_server_override_info", SqlDbType.NVarChar).Value = szServer;
                    cmd.Parameters.Add("@vc_component_override_info", SqlDbType.NVarChar).Value = szComponent;
                    cmd.Parameters.Add("@xml_setting_input", SqlDbType.Xml).Value = szXmlQuery;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader != null)
                        {
                            while (reader.Read())
                            {
                                string szValue = null;

                                string szSetting = (string) reader["vc_setting"];

                                if (!DBNull.Value.Equals(reader["vc_value"]))
                                {
                                    szValue = (string) reader["vc_value"];
                                }

                                if (null == szValue)
                                {
                                    //The setting does not exist or has been deleted
                                    string szMessage = String.Format("Expected Setting {0} not found in NPDB", szSetting);

                                    LogNtEvent("XblConfig", szMessage, ConfigEvent.Id.COMMON_SETTING_BATCH_SETTING_DELETED);
                                    continue; //move to next setting
                                }

                                SettingsKey settingkey = new SettingsKey(szEnvironment, iSiteId, szServer, szComponent,
                                                                         szSetting);

                                if (null == htSettings[settingkey])
                                {
                                    htSettings.Add(settingkey, szValue);
                                }
                            }
                        }
                    }
                }

                return htSettings;
            }


            public static Hashtable GetBatchBucketsFromDB(string npdbConnectionString, string szXmlQuery)
            {
                Hashtable htBuckets = new Hashtable();
                
                using (SqlConnection npdbConnection = new SqlConnection(npdbConnectionString))
                {
                    npdbConnection.Open();

                    SqlCommand cmd = npdbConnection.CreateCommand();
                    cmd.CommandText = "p_config_batch_get_interface_buckets";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.Add("@xml_bucket_input", SqlDbType.Xml).Value = szXmlQuery;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader != null)
                        {
                            while (reader.Read())
                            {
                                string szEnvironment = (string) reader["vc_environment"];
                                string szInterface = (string) reader["vc_interface"];
                                uint titleId = (uint) ((int) reader["i_title_id"]);
                                uint bucketId = (uint) ((int) reader["i_bucket"]);

                                if (
                                    DBNull.Value.Equals(reader["vc_server"]) &&
                                    DBNull.Value.Equals(reader["vc_next_server"]) &&
                                    DBNull.Value.Equals(reader["dt_migration_start"]) &&
                                    DBNull.Value.Equals(reader["vc_info1"]) &&
                                    DBNull.Value.Equals(reader["vc_info2"]) &&
                                    DBNull.Value.Equals(reader["vc_info3"]) &&
                                    DBNull.Value.Equals(reader["vc_info4"])
                                    )
                                {
                                    //The bucket does not exist or has been deleted
                                    string szMessage =
                                        String.Format(
                                            "Expected Bucket {0} Interface {1} Title {2} Environment {3} not found in NPDB",
                                            bucketId, szInterface, titleId, szEnvironment);

                                    LogNtEvent("XblConfig", szMessage, ConfigEvent.Id.COMMON_BUCKET_BATCH_DELETED);
                                    continue; //move to next bucket
                                }

                                InterfaceBucketKey bucketKey = new InterfaceBucketKey(szEnvironment, szInterface,
                                                                                      titleId, bucketId);
                                BucketServer bucketserver = new BucketServer(szInterface);

                                bucketserver.CurrentServerName = ((string) reader["vc_server"]).ToUpper();
                                bucketserver.NextServerName = ((string) reader["vc_next_server"]).ToUpper();
                                bucketserver.NextServerStart = (DateTime) reader["dt_migration_start"];
                                bucketserver.Info1 = (string) reader["vc_info1"];
                                bucketserver.Info2 = (string) reader["vc_info2"];
                                bucketserver.Info3 = (string) reader["vc_info3"];
                                bucketserver.Info4 = (string) reader["vc_info4"];

                                if (null == htBuckets[bucketKey])
                                {
                                    htBuckets.Add(bucketKey, bucketserver);
                                }
                            }
                        }
                    }
                }

                return htBuckets;
            }


            //returns A hash table of ArrayList, Hashtable1 =  (function, ArrayList) and ArrayList = (table)
            public static Hashtable GetAllRefreshFunctions(string npdbConnectionString)
            {
                Hashtable htFunctionTableMapping = new Hashtable();
                
                using (SqlConnection npdbConnection = new SqlConnection(npdbConnectionString))
                {
                    npdbConnection.Open();

                    SqlCommand cmd = npdbConnection.CreateCommand();
                    cmd.CommandText = "p_config_get_all_refresh_functions";
                    cmd.CommandType = CommandType.StoredProcedure;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader != null)
                        {
                            while (reader.Read())
                            {
                                string szfunction = "";
                                string sztable = "";
                                try
                                {
                                    szfunction = (string) reader["vc_function"];
                                    sztable = (string) reader["vc_table"];

                                    //converting the function to internal enum
                                    NpdbRefreshTypes refreshType =
                                        (NpdbRefreshTypes)
                                        Enum.Parse(typeof (NpdbRefreshTypes), szfunction);

                                    if (null == htFunctionTableMapping[refreshType])
                                    {
                                        htFunctionTableMapping.Add(refreshType, new ArrayList());
                                    }

                                    ArrayList arrTableExist = (ArrayList) htFunctionTableMapping[refreshType];
                                    arrTableExist.Add(sztable);
                                }
                                catch (Exception e)
                                {
                                    LogNtEvent(
                                        "XblConfig", String.Format(
                                        "Error Processing Refresh Functions szFunction {0}, szTable {1}\r\n {2}",
                                        szfunction, sztable, e), ConfigEvent.Id.COMMON_CONFIG_GET_REFRESH_FUNCTIONS
                                    );
                                }
                            }
                        }
                    }
                }

                return htFunctionTableMapping;
            }
        }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\presutil.cs ===
using STF.common.service;

namespace STF.common.protocol 
{
    //
    // Utility wrappers for making Presence requests and replies as easy as a simple function call
    //
    public class PresReq
    {
        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb, ref respOb );
        }

        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb );
        }

        public HResult Alive( ulong qwUserId, 
                                  uint dwTitleId, 
                                  uint dwBuddyListVersion, 
                                  uint dwBlockListVersion, 
                                  uint dwState,            // Must be ( PresDefs.P_STATE_MASK_ONLINE | PresDefs.P_STATE_MASK_CLOAKED )
                                  ulong qwMatchSessionId,  // Must be zero
                                  string szAcctName, 
                                  byte[] rgbTitleStuff,    // Must be null
                                  byte[] rgbNickName,      // Must be null
                                  out uint dwRetBuddyListVersion,
                                  out uint dwRetBlockListVersion,
                                  out ReplyBuddy[] rgReplyBuddies,
                                  out ulong[] rgqwBlockIDs )
        {
            PresenceAliveMsg request = new PresenceAliveMsg();
            PresenceAliveReply response = new PresenceAliveReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.dwBuddyListVersion = dwBuddyListVersion;
            request.dwBlockListVersion = dwBlockListVersion;
            request.dwState = dwState;
            request.qwMatchSessionID = qwMatchSessionId;
            request.szAcctName = szAcctName;
            request.rgbTitleStuff = rgbTitleStuff;
            request.rgbNickName = rgbNickName;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the front door to handle the request
            HResult hr = SendRequest( "Alive, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                dwRetBuddyListVersion = 0;
                dwRetBlockListVersion = 0;
                rgReplyBuddies = null;
                rgqwBlockIDs = null;

                return hr;
            }

            dwRetBuddyListVersion = response.dwBuddyListVersion;
            dwRetBlockListVersion = response.dwBlockListVersion;
            rgReplyBuddies = response.rgReplyBuddies;
            rgqwBlockIDs = response.rgqwBlockIDs;

            return response.hr;
        }

        public HResult Alive2( ulong qwUserId, 
                            uint dwTitleId,
                            XNADDR xnaddr,
                            ulong xnkid,
                            byte[] xnkey, // 16 bytes
                            uint dwBuddyListVersion, 
                            uint dwBlockListVersion, 
                            string szAcctName, 
                            out uint dwRetBuddyListVersion,
                            out uint dwRetBlockListVersion,
                            out ReplyBuddy[] rgReplyBuddies,
                            out ulong[] rgqwBlockIDs )
        {
            PresenceAlive2Msg request = new PresenceAlive2Msg();
            PresenceAliveReply response = new PresenceAliveReply();

            // Build the request
            request.header.sgaddr = xnaddr.sgaddr;
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.xnaddr = xnaddr;
            request.xnkid = xnkid;
            request.xnkey = xnkey;
            request.dwBuddyListVersion = dwBuddyListVersion;
            request.dwBlockListVersion = dwBlockListVersion;
            request.szAcctName = szAcctName;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the front door to handle the request
            HResult hr = SendRequest( "Alive2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                dwRetBuddyListVersion = 0;
                dwRetBlockListVersion = 0;
                rgReplyBuddies = null;
                rgqwBlockIDs = null;

                return hr;
            }

            dwRetBuddyListVersion = response.dwBuddyListVersion;
            dwRetBlockListVersion = response.dwBlockListVersion;
            rgReplyBuddies = response.rgReplyBuddies;
            rgqwBlockIDs = response.rgqwBlockIDs;

            return response.hr;
        }
       
        public HResult DeadUser( ulong qwUserId )
        {
            PresenceDeadUserMsg request = new PresenceDeadUserMsg();

            // Build the request
            request.qwUserID = qwUserId;

            return SendRequest( "DeadUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request );
        }

        public HResult State( ulong qwUserId, 
                                  uint dwState,
                                  ulong qwMatchSessionId,
                                  byte[] rgbTitleStuff )
        {
            PresenceStateMsg request = new PresenceStateMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwState = dwState;
            request.qwMatchSessionID = qwMatchSessionId;
            request.rgbTitleStuff = rgbTitleStuff;

            // Call the front door to handle the request
            HResult hr = SendRequest("State, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AddFriend( ulong qwUserId,
                                      ulong qwFriendId,
                                      string szFriendAcctName )
        {
            PresenceAddBuddyMsg request = new PresenceAddBuddyMsg();

            // Build the request
            request.qwSenderID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.szBuddyAcctName = szFriendAcctName;

            // Call the front door to handle the request
            HResult hr = SendRequest("AddFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AddFriend2( ulong qwUserId,
                                       ulong qwFriendId,
                                       string szFriendAcctName,
                                       uint dwMessageFlags,
                                       MessageDetails details )
        {
            PresenceAddBuddy2Msg request = new PresenceAddBuddy2Msg();

            // Build the request
            request.qwSenderID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.szBuddyAcctName = szFriendAcctName;
            request.dwMessageFlags = dwMessageFlags;
            request.cbDetails = (ushort) details.Size();
            request.details = details;

            // Call the front door to handle the request
            HResult hr = SendRequest("AddFriend2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult RemoveFriend(ulong qwUserId,
                                         ulong qwFriendId )
        {
            PresenceDeleteBuddyMsg request = new PresenceDeleteBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;

            // Call the front door to handle the request
            HResult hr = SendRequest("RemoveFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AcceptFriend(ulong qwUserId,
                                         ulong qwFriendId )
        {
            PresenceAcceptBuddyMsg request = new PresenceAcceptBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;

            // Call the front door to handle the request
            HResult hr = SendRequest("AcceptFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult RejectFriend(ulong qwUserId,
                                         ulong qwFriendId,
                                         bool fNever )
        {
            PresenceRejectBuddyMsg request = new PresenceRejectBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.fNever = fNever;

            // Call the front door to handle the request
            HResult hr = SendRequest("RejectFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult MuteUser(ulong qwUserId,
                                     ulong qwBlockId )
        {
            PresenceMuteUserMsg request = new PresenceMuteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBlockID = qwBlockId;

            // Call the front door to handle the request
            HResult hr = SendRequest("MuteUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult UnmuteUser(ulong qwUserId,
                                       ulong qwBlockId )
        {
            PresenceUnmuteUserMsg request = new PresenceUnmuteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBlockID = qwBlockId;

            // Call the front door to handle the request
            HResult hr = SendRequest("UnmuteUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult GameInvite(ulong qwUserId,
                                       uint dwTitleId,
                                       ulong qwMatchSessionId,
                                       ulong[] rgqwInvitees )
        {
            PresenceInviteUserMsg request = new PresenceInviteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest("GameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult GameInvite2(ulong qwUserId,
                                        ulong qwSenderContext,
                                        uint dwTitleId,
                                        uint dwMessageFlags,
                                        MessageDetails details,
                                        ulong[] rgqwInvitees )
        {
            PresenceInviteUser2Msg request = new PresenceInviteUser2Msg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwSenderContext = qwSenderContext;
            request.dwTitleID = dwTitleId;
            request.dwMessageFlags = dwMessageFlags;
            request.cbDetails = (ushort) details.Size();
            request.details = details;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest( "GameInvite2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request );

            return hr;
        }

        public HResult CancelGameInvite(ulong qwUserId,
                                             ulong qwMatchSessionId,
                                             ulong[] rgqwInvitees )
        {
            PresenceCancelInviteMsg request = new PresenceCancelInviteMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest("CancelGameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AnswerGameInvite(ulong qwUserId,
                                             ulong qwHostId,
                                             ulong qwMatchSessionId,
                                             ushort wAnswer )
        {
            PresenceAnswerInviteMsg request = new PresenceAnswerInviteMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwHostID = qwHostId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.wAnswer = wAnswer;

            // Call the front door to handle the request
            HResult hr = SendRequest("AnswerGameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

    } // class PresReq

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\PipeStream.cs ===
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Security;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;


namespace STF.common.mgmt
{

    [ComVisible(false)]
    public class PipeStream : IDisposable
    {

        private FileStream _stream;
        private BinaryReader _reader;
        private BinaryWriter _writer;

        public PipeStream(string name, int bufferSize)
        {
            Open(name, bufferSize);
        }


        public void Open(string name, int bufferSize)
        {
            SafeFileHandle hPipe = new SafeFileHandle(PipeNative.CreateFile(
                                            name,
                                            PipeNative.GENERIC_READ | PipeNative.GENERIC_WRITE, 
                                            0,
                                            0, 
                                            PipeNative.OPEN_EXISTING, 
                                            PipeNative.FILE_FLAG_OVERLAPPED, 
                                            0), true);

            if( hPipe.IsInvalid )
            {
                ulong err =(ulong) Marshal.GetLastWin32Error();
                if ( err!= PipeNative.ERROR_PIPE_BUSY )
                {
                    throw new Exception("Could not open pipe: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                }
                // if pipe is busy, retry later
                if ( PipeNative.WaitNamedPipe ( name, 60000 ) )
                {
                    hPipe = new SafeFileHandle(PipeNative.CreateFile(
                        name,
                        PipeNative.GENERIC_READ | PipeNative.GENERIC_WRITE, 
                        0,
                        0, 
                        PipeNative.OPEN_EXISTING, 
                        PipeNative.FILE_FLAG_OVERLAPPED, 
                        0), true);

                    if( hPipe.IsInvalid )
                    {
                        throw new Exception("Second attempt to open pipe failed: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                    }
                }

                if( hPipe.IsInvalid )
                {
                    throw new Exception("Timed out waiting for named pipe to connect: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                }
            }

            
            uint dwMode = PipeNative.PIPE_READMODE_MESSAGE;

            int iRes = PipeNative.SetNamedPipeHandleState(
                                            hPipe.DangerousGetHandle(),
                                            ref dwMode,
                                            IntPtr.Zero,
                                            IntPtr.Zero );

            if( iRes == 0 )
            {
                throw new Exception( "SetNamedPipeHandleState failed: 0x" + Marshal.GetLastWin32Error().ToString("x") );
            }

            _stream = new FileStream( hPipe, FileAccess.ReadWrite, bufferSize, true );
            _reader = new BinaryReader( _stream );
            _writer = new BinaryWriter( _stream );
        }

        public IAsyncResult BeginRead(byte[] array, int offset, int numBytes,  AsyncCallback userCallback, object stateObject)
        {
            return _stream.BeginRead(array, offset, numBytes, userCallback, stateObject);
        }

        public IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
        {
            return _stream.BeginWrite(array, offset, numBytes, userCallback, stateObject);
        }

        public int EndRead(IAsyncResult result)
        {
            return _stream.EndRead(result);
        }
        
        public void EndWrite(IAsyncResult result)
        {
            _stream.EndWrite(result);
        }

        public int Read(byte[] array, int offset, int count)
        {
            return _stream.Read(array, offset, count);
        }

        public void Write(byte[] array, int offset, int count)
        {
            _stream.Write(array, offset, count);
        }

        public bool CanRead
        {
            get { return _stream.CanRead; }
        }

        public bool CanWrite
        {
            get { return _stream.CanWrite; }
        }
        

        public void Flush()
        {
            _stream.Flush();
        }

        public void Close()
        {
            _stream.Close();
        }

        public BinaryReader Reader
        {
            get { return _reader; }
        }

        public BinaryWriter Writer
        {
            get { return _writer; }
        }

        public void Dispose()
        {
            Close();
            GC.SuppressFinalize(this);
        }

        
    }

    [ComVisible(false)]
    [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
    [SuppressUnmanagedCodeSecurity]
    public class PipeNative 
    {
        public const uint PIPE_ACCESS_OUTBOUND = 0x00000002;
        public const uint PIPE_ACCESS_DUPLEX = 0x00000003;
        public const uint PIPE_ACCESS_INBOUND = 0x00000001;
        
        public const uint PIPE_WAIT = 0x00000000;
        public const uint PIPE_NOWAIT = 0x00000001;
        public const uint PIPE_READMODE_BYTE = 0x00000000;
        public const uint PIPE_READMODE_MESSAGE = 0x00000002;
        public const uint PIPE_TYPE_BYTE = 0x00000000;
        public const uint PIPE_TYPE_MESSAGE = 0x00000004;
        
        public const uint PIPE_CLIENT_END = 0x00000000;
        public const uint PIPE_SERVER_END = 0x00000001;
        
        public const uint PIPE_UNLIMITED_INSTANCES = 255;
        
        public const uint NMPWAIT_WAIT_FOREVER = 0xffffffff;
        public const uint NMPWAIT_NOWAIT = 0x00000001;
        public const uint NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;
        
        public const uint GENERIC_READ = (0x80000000);
        public const uint GENERIC_WRITE = (0x40000000);
        public const uint GENERIC_EXECUTE = (0x20000000);
        public const uint GENERIC_ALL = (0x10000000);

        public const uint FILE_FLAG_OVERLAPPED = 0x40000000;
        
        public const uint CREATE_NEW        = 1;
        public const uint CREATE_ALWAYS     = 2;
        public const uint OPEN_EXISTING     = 3;
        public const uint OPEN_ALWAYS       = 4;
        public const uint TRUNCATE_EXISTING = 5;
        
        public const int INVALID_HANDLE_VALUE = -1;
        public const ulong ERROR_PIPE_BUSY = 231;
        public const ulong ERROR_NO_DATA = 232;
        public const ulong ERROR_PIPE_NOT_CONNECTED = 233;
        public const ulong ERROR_PIPE_CONNECTED = 535;
        public const ulong ERROR_PIPE_LISTENING = 536;


        [DllImport("kernel32.dll", SetLastError = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        public static extern IntPtr CreateFile(
                                            [MarshalAs(UnmanagedType.LPStr)] String lpFileName,				// file name
                                            uint dwDesiredAccess,			// access mode
                                            uint dwShareMode,				// share mode
                                            uint attr,				        // SD
                                            uint dwCreationDisposition,		// how to create
                                            uint dwFlagsAndAttributes,		// file attributes
                                            uint hTemplateFile);			// handle to template file
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int SetNamedPipeHandleState(
                                            IntPtr hPipe,
                                            ref uint dwMode,
                                            IntPtr MaxCollectionCount,
                                            IntPtr CollectDataTimeout );

        [DllImport("kernel32.dll", SetLastError = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        public static extern bool WaitNamedPipe(
            [MarshalAs(UnmanagedType.LPStr)] String lpNamedPipeName,
            uint nTimeOut
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\profileprot.cs ===
/*==========================================================================
 *
 *  xqrywire.cs -- This module defines the wire protocol for query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using STF.common.service;

namespace STF.common.protocol 
{
    public class ProfileProperty : WireData
    {
        public ushort Id;
        public ushort ValueLen;
        
        [WireInfo(SizeParam="ValueLen")]        
        public byte[] Value;
    }
    
    public class ProfileReadRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ushort[] propertyIds;
    }
    
    
    public class ProfileReadResponse : XRLObject2
    {
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ProfileProperty[] properties;
    
    }    
    
    
    public class ProfileWriteRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ProfileProperty[] properties;
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ProofData.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using STF.common.service;

namespace STF.common.protocol
{
    public class ProofData : WireData
    {
        /// <summary>
        /// Enumeration detailing the type of the strong proof
        /// </summary>
        public ProofTypeEnum proofType;

        /// <summary>
        /// Protocol element to hold the length of the string
        /// </summary>
        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort proofDataLength;

        /// <summary>
        /// The actual data of the strong proof.
        /// </summary>
        [WireInfo(SizeParam = "proofDataLength")]
        public string proofData;
    }

    public class ProofStatus : ProofData
    {
        /// <summary>
        /// Flag to state if the strong proof has already been confirmed
        /// </summary>
        public bool isConfirmed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ProofTypeEnum.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

namespace STF.common.protocol
{
    public enum ProofTypeEnum : byte
    {
        /// <summary>
        /// A telephone number capable of accepting text messages.
        /// </summary>
        SMS = 1,

        /// <summary>
        /// This proof is an alternative email address to the membername
        /// </summary>
        Email = 2

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\PriorityQueue.cs ===
using System;
using System.Collections;
using System.Threading;
using STF.common.service;


namespace STF.common.utilities 
{
    public class PriorityQueue
    {
        private ArrayList _heap;
        private int _count;
        
        public PriorityQueue(int InitialSize)
        {
            _heap = new ArrayList(InitialSize);
            _count = 0;
        }

        // Inserts a new object into the priority queue
        public int Insert(IComparable obj)
        {
            int count;
            lock(this)
            {
                if (_count < _heap.Count)
                {
                    _heap[_count] = obj;
                }
                else
                {
                    _heap.Add(obj);
                }
                _count++;

                if (_count > 1)
                {
                    heapify(_count - 1);
                }
                count = _count;
            }
            return count;
        }

        // Returns the highest priority object without removing it
        // Returns null if the queue is empty
        public IComparable PeekHead()
        {
            IComparable head = null;
            lock(this)
            {
                if (_count > 0)
                {
                    head = (IComparable)_heap[0];
                }
            }
            return head;
        }

        // Removes the highest priority object and returns it
        // Returns null if the queue is empty
        public IComparable GetHead()
        {
            IComparable head = null;
            lock(this)
            {
                if (_count > 0)
                {
                    head = (IComparable)_heap[0];

                    --_count;
                    _heap[0] = _heap[_count];
                    _heap[_count] = null;
                    reheapify(0, _count);
                }
            }
            return head;
        }

        // Peek at a leaf item
        public IComparable PeekItem(int i)
        {
            IComparable item = null;
            lock(this)
            {
                if ((_count/2) < i && i < _count)
                {
                    item = (IComparable)_heap[i];
                }
            }
            return item;
        }

        // Remove a leaf item
        public IComparable GetItem(int i)
        {
            IComparable item = null;
            lock(this)
            {
                if ((_count/2) < i && i < _count)
                {
                    item = (IComparable)_heap[i];

                    --_count;
                    _heap[i] = _heap[_count];
                    _heap[_count] = null;
                    heapify(i);
                }
            }
            return item;
        }

        public int Count
        {
            get { return _count; }
        }

        private void heapify(int start)
        {
            // always gets a heap with at least 2 elements
            int c_node, p_node;       // c_node = current node, p_node = parent node
            c_node = start;           // last element in the heap
            object temp;
            
            while (c_node > 0)
            {
                p_node  = (c_node - 1)/2;  // p_node is index of parent
                if ( ((IComparable)_heap[p_node]).CompareTo(_heap[c_node]) >= 0 )
                {
                    break;
                }
                temp = _heap[p_node];
                _heap[p_node] = _heap[c_node];
                _heap[c_node] = temp;
                c_node = p_node;
            }
        }

        private void reheapify (int n, int stop)
        {
            object temp;
            int leftchild, rightchild, k;
            while (n < stop/2)
            {
                leftchild = 2 * n + 1;
                rightchild = 2 * n + 2;
                
                // handle special case of no rightchild
                if (rightchild >= stop)
                {
                    k = leftchild;
                }
                else // usual case
                {
                    if ( ((IComparable)_heap[leftchild]).CompareTo(_heap[rightchild]) > 0 )
                    {
                        k = leftchild;
                    }
                    else
                    {
                        k = rightchild;
                    }
                }

                // k now is the index of the larger of the 2 children of n
                if ( ((IComparable)_heap[n]).CompareTo(_heap[k]) >= 0 )
                {
                    break;
                }
                temp = _heap[n];
                _heap[n] = _heap[k];
                _heap[k] = temp;
                n = k;
            }
        }

        
    }

    public interface IPrioritizedTask : IComparable
    {
        TimeSpan Delay { get; }
    }
        
    public delegate void HandleTask( IPrioritizedTask task );
    public delegate object QueueExaminer( PriorityQueue queue );

    public class PrioritizedThreadPool
    {
        private PriorityQueue _queue;
        private XboxLiveThread[] _threads;
        private ManualResetEvent _tasksAvailable;
        private ManualResetEvent _noTasksLeft;
        private HandleTask _taskHandler;
        private bool _enforceDelay;
        
        public PrioritizedThreadPool(int NumberOfThreads, ThreadPriority priority, int InitialQueueSize, HandleTask TaskHandler)
        {
            _queue = new PriorityQueue( InitialQueueSize );
            _tasksAvailable = new ManualResetEvent(false);
            _noTasksLeft = new ManualResetEvent(false);
            _taskHandler = TaskHandler;
            _threads = new XboxLiveThread[ NumberOfThreads ];
            _enforceDelay = true;

            for( int i = 0; i < NumberOfThreads; i++ )
            {
                _threads[i] = new XboxLiveThread( new ThreadStart( ThreadLoop ) );
                _threads[i].Priority = priority;
                _threads[i].Start();
            }
        }

        ~PrioritizedThreadPool()
        {
            lock(this)
            {
                _noTasksLeft.Reset();
                _enforceDelay = false;
                _tasksAvailable.Set();
            }
            _noTasksLeft.WaitOne();
        }

        public object ExamineQueue( QueueExaminer examiner )
        {
            object o;
            lock(this)
            {
                o = examiner(_queue);
            }
            return o;
        }
            
        public int SubmitTask(IPrioritizedTask task)
        {
            int count;
            lock(this)
            {
                count = _queue.Insert(task);
                _tasksAvailable.Set();
            }
            return count;
        }

        public void FlushAllTasks()
        {
            lock(this)
            {
                _noTasksLeft.Reset();
                _enforceDelay = false;
                _tasksAvailable.Set();
            }
            _noTasksLeft.WaitOne();
            _enforceDelay = true;
        }
        
        public int TaskCount
        {
            get { return _queue.Count; }
        }

        private void ThreadLoop()
        {
            IPrioritizedTask nextTask;
            IPrioritizedTask processTask;
            TimeSpan delay;
            TimeSpan tempDelay;
            while (true)
            {
                try
                {
                    lock(this)
                    {
                        delay = TimeSpan.Zero;
                        nextTask = (IPrioritizedTask)_queue.PeekHead();
                        processTask = null;
                        if (nextTask == null)
                        {
                            _noTasksLeft.Set();
                            _tasksAvailable.Reset();
                        }
                        else
                        {
                            tempDelay = nextTask.Delay;
                            if (_enforceDelay && tempDelay > TimeSpan.Zero)
                            {
                                delay = tempDelay;
                                _tasksAvailable.Reset();
                            }
                            else
                            {
                                // We know we will consume the task, remove it from queue
                                processTask = (IPrioritizedTask)_queue.GetHead();
                                if (processTask != nextTask)
                                {
                                    EventBuilder.LogEvent(XEvent.Id.MC_APPLICATION_ERROR_5, "PrioritizedThreadPool processTask == nextTask assertion failed", null);
                                }
                            }
                        }
                    }

                    if (nextTask == null)
                    {
                        // no tasks available, wait until one is available
                        _tasksAvailable.WaitOne();
                    }
                    else
                    {
                        if (delay > TimeSpan.Zero)
                        {
                            // Wait until delayed task schedule time or event, whichever comes first
                            _tasksAvailable.WaitOne(delay,false);
                        }
                        else // do this task immediately
                        {
                            try
                            {
                                _taskHandler(processTask);
                            }
                            catch (Exception e)
                            {
                                EventBuilder.LogEvent(XEvent.Id.MC_APPLICATION_ERROR_6, "PrioritizedThreadPool task handler threw exception:", e);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    EventBuilder.LogEvent(XEvent.Id.MC_APPLICATION_ERROR_7, "PrioritizedThreadPool ThreadLoop threw exception:", e);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\queryprot.cs ===
/*==========================================================================
 *
 *  xqrywire.cs -- This module defines the wire protocol for query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using STF.common.service;


namespace STF.common.protocol 
{

    //
    // Base data for QueryATtribute. This class is used for serialization and deserialization via XML
    // 
    public class QueryAttribute : WireData
    {
        public QueryAttribute() { }
        public QueryAttribute(uint id)
        {
            Id = id;
        }    
        public QueryAttribute(uint id, long l)
        {
            Id = id;
            lValue = l;
        }    
        public QueryAttribute(uint id, string str)
        {
            Id = id;
            strValue = str;
        }    
        public QueryAttribute(uint id, byte[] b)
        {
            Id = id;
            binValue = b;
        }    
        
        
        
        //
        // Data exposed to SOAP
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors
        //
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        
        
        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            len = binaryReader.ReadInt32();

            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                lValue = binaryReader.ReadInt64();
                break;
            
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                strValue = Encoding.UTF8.GetString(binaryReader.ReadBytes(len));
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_BAD_PARAMETER, 
                    "Unrecgonized datatype: 0x" + (Id & XOn.X_ATTRIBUTE_DATATYPE_MASK).ToString("x") + "! attribute id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                binaryWriter.Write((int)8);
                binaryWriter.Write(lValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                {
                    byte[] buf;
                    
                    buf = Encoding.UTF8.GetBytes(strValue);
                    binaryWriter.Write((int)buf.Length);
                    
                    //
                    // In .Net 2.0, attempting to write a 0 byte
                    // array to the HttpResponse stream results
                    // in an ArgumentOutOfRangeException thrown.
                    // As a result, a WireData object with an empty
                    // string as a member would fail to be written.
                    //
                    if (buf.Length > 0)
                    {
                        binaryWriter.Write(buf);
                    }
                }
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                binaryWriter.Write(binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_BAD_PARAMETER_1, 
                    "Unexpected datatype: 0x" + (Id & XOn.X_ATTRIBUTE_DATATYPE_MASK).ToString("x") + "! attribute id: " + Id);
            }
        }


        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                str.Append(lValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                str.Append(strValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                str.Append(ByteConvert.ToString(binValue));                    
                break;
            }
            
            return str.ToString();
        }
        
    }

    
    //
    // Structure Representing a single message property. 
    //  Maps to _XONLINE_ATTRIBUTE_SPEC, XONLINE_ATTRIBUTE_SPEC, *PXONLINE_ATTRIBUTE_SPEC in STF.x
    //  
    public class QueryAttributeSpec : XRLObject2
    {
        public QueryAttributeSpec() { }
        public QueryAttributeSpec(uint id)
        {
            type = id;
        }    
        public QueryAttributeSpec(uint id, uint maxlen)
        {
            type = id;
            len = maxlen;
        }    
        
        
        [SoapElement(ElementName="type")]
        [WireInfo(HexString=true)]
        public uint type;

        [SoapElement(ElementName="len")]
        public uint len;
    }
    
    public class AddRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Add.ashx";
            }
        }
    }
    
    

    public class AddResponse : XRLObject2
    {
        public ulong entityId;
    }
    
    
    public class SearchRequest : XRLObject2
    {
        public uint titleId;
        public uint datasetId;
        public uint procIndex;
        public uint page;
        public uint resultsPerPage;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_SPECS)]
        public uint specCount;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;        

        [WireInfo(SizeParam="specCount")]        
        public QueryAttributeSpec[] specs;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Search.ashx";
            }
        }        
    }

    
    public class SearchResponse : XRLObject2
    {
        public uint totalResults;
        public uint returnedResults;        // Number of "rows"
        
        public uint attribCount;            // Total attributes        

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;
    }

    
    public class FindFromIdsRequest : XRLObject2
    {
        public uint titleId;
        public uint datasetId;
        public uint procIndex;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_SPECS)]
        public uint specCount;
        
        [WireInfo(Max=10)]
        public uint idCount;

        [WireInfo(SizeParam="specCount")]        
        public QueryAttributeSpec[] specs;

        [WireInfo(SizeParam="idCount")]        
        public ulong[] entityIds;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/FindFromIds.ashx";
            }
        }
        
    }
    
    
    public class FindFromIdsResponse : XRLObject2
    {
        public uint returnedResults;

        public uint attribCount;            // Total attributes        

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;
    }
    
    
    
    public class RemoveRequest : XRLObject2
    {
        public uint titleId = 0;
        public ulong userId = 0;
        public ulong teamId = 0;
        public uint datasetId = 0;
        public uint procIndex = 0;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        
        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Remove.ashx";
            }
        }                
    }


    public class RemoveIdRequest : XRLObject2
    {
        public uint titleId = 0;
        public ulong userId = 0;
        public ulong teamId = 0;
        public uint datasetId = 0;
        public ulong entityId = 0;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/RemoveId.ashx";
            }
        }
    }

    
    public class SelectRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public ulong entityId;
        public uint actionId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Select.ashx";
            }
        }
    }

    public class UpdateRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public uint procIndex;        
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/update.ashx";
            }
        }        
    }
    
    public class UpdateIdRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public uint procIndex;
        public ulong entityId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/UpdateId.ashx";
            }
        }        
    }
    
    public class QueryTimeWarpRequest : XRLObject2
    {
        public long offsetSeconds;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/timewarp.ashx";
            }
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Puid.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace STF.common.service
{
    [ComVisible(false)]
    [XmlSchemaProvider("PuidSchema")]
    [WireInfo(SerializeAs=typeof(ulong))]
    public partial struct Puid : IEquatable<Puid>, IXmlSerializable
    {
        private ulong _value;

        private Puid(ulong value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X016");
        }

        public static implicit operator Puid(ulong value)
        {
            return new Puid(value);
        }

        public static implicit operator ulong(Puid Puid)
        {
            // convert a puid to ulong
            return Puid._value;
        }


        // explicit cast...
        public static explicit operator Puid(long value)
        {
            return new Puid((ulong)value);
        }

        public static explicit operator long(Puid Puid)
        {
            return (long)Puid._value;
        }

        #region IEquatable<Puid> Members

        public bool Equals(Puid other)
        {
            return _value == other._value;
        }

        #endregion

        public static Puid Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new Puid(Convert.ToUInt64(s, 16));
        }

        public static bool TryParse(string s, out Puid Puid)
        {
            try
            {
                Puid = Puid.Parse(s);
                return true;
            }
            catch
            {
                Puid = new Puid(0);
                return false;
            }
        }

        #region IXmlSerializable Members
        
        public void ReadXml(XmlReader reader)
        {
            _value = (ulong) XmlConvert.ToUInt64(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion
        
        public static XmlQualifiedName PuidSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedLong", XmlSchema.Namespace);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\RateMediaProtocol.cs ===
using System;
using STF.common.service;

namespace STF.common.protocol 
{
    /// <summary>
    /// Wire Data Rate Media Request class
    /// </summary>
    public class RateMediaRequest : XRLObject2
    {
        public Guid mediaId;
        
        public int ratingValue;

        [WireInfo(HexString=true)]
        public ulong userXuid;

        public byte userCountryId;
       
        //TODO: url subjected to change
        public override string Xrl
        {
            get { return "/ratings/submitrating.ashx"; }
        }
    }

    public class GetRatingRequest : XRLObject2
    {
        public Guid mediaId;

        [WireInfo(HexString=true)]
        public ulong userXuid;

        public byte userCountryId;
        
        //TODO: url subjected to change
        public override string Xrl
        {
            get { return "/ratings/getrating.ashx"; }
        }
    }
    
    public class GetRatingResponse : XRLObject2
    {
        public int userValue;
        
        public double ratingsAverage;
        
        public int ratingsCount;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ReportConnection.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;
using STF.common.mgmt;
using STF.common.service;

// trace area for ReportConnection code
[assembly: XomAreaDefinition(XomAreaName.ReportConnection)]

namespace STF.common.mgmt
{
    using WireData = STF.common.service.WireData;

    [ComVisible(false)]
    public class ReportConnection
    {
        private class ConnectionContext
        {
            public byte[] ReceiveBuffer;
            public int ReceiveBufferOffset;
            public int Receiving;
            public int State;
            public NetworkStream NetworkStream;
            public TcpClient TcpClient;
            public object ConnectionLock = new object();

            public bool IsConnected
            {
                get { return (State != S_NOT_CONNECTED && NetworkStream != null); }
            }
        }
        
        public int MaxQueueSize { get; set; }

        private const int s_iReceiveBufferSize = 16384;

        public ReportConnection( )
            : this(10240)
        {
        }

        public ReportConnection( int maxQueueSize )
        {
            MaxQueueSize = maxQueueSize;

            _listBuffers = new LinkedList<WireData>();
            _iDroppedEvent = 0;

            // Try to obtain the host name
            string hostName = "Unknown";
            try{
                hostName = Dns.GetHostName();
            }
            catch(Exception) // Silently fail - use "Unknown"
            {

            }
            _vcServer = hostName;
            _iComponentID = 0;

            _iInitialized = 0;
            _threadSend = null;
            _iShutdown = 0;
            _hSendThread = new AutoResetEvent( false );

        }

        public void Startup( )
        {
            //
            // Just return if we've already been called
            //
            if( 1 == Interlocked.Exchange( ref _iInitialized, 1 ) )
            {
                goto lDone;
            }

            ReportTargetCounters.Current(Component).MessagesTotal.RawValue = 0;
            ReportTargetCounters.Current(Component).QueueLength.RawValue = 0;

            try
            {
                _threadSend = new XboxLiveThread( new ThreadStart( this._SendThread ) );
                _threadSend.Start( );
            }
            catch( Exception )
            {
                Interlocked.Exchange( ref _iInitialized, 0 );
                throw;
            }

        lDone:

            return;
        }

        public void Shutdown( )
        {
            //
            // Return if we're not initialized
            //
            if( 0 == _iInitialized )
            {
                goto lDone;
            }

            //
            // Just return if we've already been called
            //
            if( 1 == Interlocked.Exchange( ref _iShutdown, 1 ) )
            {
                goto lDone;
            }

            //
            // Abort the send thread
            //
            if( !_hSendThread.Set( ) )
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_27, "[ReportConnection.Shutdown]: Unable to signal thread to shutdown. Going to abort the thread." );
                _threadSend.Abort( );
            }

        lDone:
            return;
        }

        private void OnConnect( ConnectionContext context )
        {
            ReportMessageConnect msgConnect;

            msgConnect = new ReportMessageConnect( );
            msgConnect.vcServer = _vcServer;
            msgConnect.iComponentID = _iComponentID;

            try
            {
                WireData wireData;
                wireData = msgConnect;
                byte[] rgbData = ( byte[] ) wireData;
                lock (context.ConnectionLock)
                {
                    context.NetworkStream.Write( rgbData, 0, rgbData.Length );
                    context.State = S_CONNECTED;
                }
                _hSendThread.Set( );
                StartReceiving( context );
            }
            catch(Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_28, e, "[ReportConnection.OnConnect]: NetStream::Write failed");

                // uhhh
                throw;
            }
        }

        public void AttachAndConnect(string host, int port)
        {
            //
            // We require a valid end point
            //
            if (String.IsNullOrEmpty(host))
            {
                throw new ArgumentNullException("host");
            }

            AttachAndConnect(() =>
                {
                    TcpClient client = new TcpClient();
                    client.Connect(host, port);
                    return client;
                });

            Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_NORMAL, "[ReportConnnection.AttachAndConnect]: Attached TcpClient to {0}:{1}", host, port);
        }

        public void AttachAndConnect(IPEndPoint ipAddr)
        {
            //
            // We require a valid end point
            //
            if (null == ipAddr)
            {
                throw new ArgumentNullException("ipAddr");
            }

            AttachAndConnect(() =>
            {
                TcpClient client = new TcpClient();
                client.Connect(ipAddr);
                return client;
            });

            Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_NORMAL, "[ReportConnnection.AttachAndConnect]: Attached TcpClient to " + ipAddr.ToString());
        }

        private void AttachAndConnect(Func<TcpClient> clientFactory)
        {
            ConnectionContext context;
            ConnectionContext old;

            context = new ConnectionContext();

            context.ReceiveBuffer = new byte[s_iReceiveBufferSize];
            context.ReceiveBufferOffset = 0;
            context.Receiving = 0;
            context.State = S_NOT_CONNECTED;

            // Heads up, This may throw if the write fails.
            for (int retry = 0; retry < 3; retry++)
            {
                try
                {
                    //
                    // Connect to the server
                    //
                    context.TcpClient = clientFactory();
                    context.NetworkStream = context.TcpClient.GetStream();

                    OnConnect(context);
                    break;
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_ERROR,
                              "[AttachAndConnect]: Connection attempt #{0} of 3 failed: {1}", 
                              retry+1, e.ToString());

                    try
                    {
                        if (context.NetworkStream != null)
                        {
                            context.NetworkStream.Close();
                            context.NetworkStream = null;
                        }
                        if (context.TcpClient != null)
                        {
                            context.TcpClient.Close( );
                        }
                    }
                    catch (Exception)
                    {
                    }

                    if (retry == 2)
                    {
                        // aw crap
                        throw;
                    }
                }
            }

            old = Interlocked.Exchange(ref _connectionContext, context);

            //
            // Close any existing tcp client object and net stream object
            //
            if (null != old)
            {
                Disconnect(old);
            }
        }

        public void Send( WireData wireData )
        {
            lock( _listBuffers )
            {
                //
                // If the queue is full, drop the buffer.
                // We'll slightly cheat for a "must send first" package and just send that one.
                //
                if( _listBuffers.Count >= MaxQueueSize )
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.Send]: Outbound queue is full. Dropping buffer.");
                    if( 1 != Interlocked.Exchange( ref _iDroppedEvent, 1 ) )
                    {
                        Xom.NtEvent( XEvent.Id.COMMON_COMM_8, "[ReportConnection.Send]: Outbound queue is full. Dropping buffer. Queue size is: " + MaxQueueSize.ToString() );
                    }
                    goto lDone;
                }

                if( 0 != Interlocked.Exchange( ref _iDroppedEvent, 0 ) )
                {
                    Xom.NtEvent( XEvent.Id.COMMON_INFO_45, "[ReportConnection.Send]: Outbound queue is no longer full. Accepting new buffers." );
                }
                _listBuffers.AddLast( wireData );
            }

            ReportTargetCounters.Current(Component).MessagesPerSecond.Increment();
            ReportTargetCounters.Current(Component).MessagesTotal.Increment();
            ReportTargetCounters.Current(Component).QueueLength.Increment();

        lDone:
            _hSendThread.Set( );

            return;
        }

        public void Disconnect( )
        {
            Disconnect(_connectionContext);
        }

        private void Disconnect( ConnectionContext context )
        {
            lock (context.ConnectionLock)
            {
                if( S_NOT_CONNECTED != Interlocked.Exchange( ref context.State, S_NOT_CONNECTED ) )
                {
                    Interlocked.Exchange( ref context.Receiving, 0 );

                    context.NetworkStream.Close();
                    context.NetworkStream = null;

                    context.TcpClient.Close( );
                }
            }
        }        

        public bool IsConnected
        {
            get 
            {
                ConnectionContext context = _connectionContext;

                return null != context && context.IsConnected;
            }
        }

        protected void ParseReceiveBuffer( byte[] rgbBuffer, ref int iBufferBytes )
        {
            iBufferBytes = 0;
        }

        private void StartReceiving( ConnectionContext context )
        {
            if( !context.IsConnected )
            {
                //
                // Socket isn't connected, can't receive
                //
                return;
            }

            if( 0 != Interlocked.Exchange( ref context.Receiving, 1 ) )
            {
                //
                // We are already receiving something
                //
                return;
            }

            try
            {
                lock (context.ConnectionLock)
                {
                    if (context.IsConnected)
                    {
                        context.NetworkStream.BeginRead(
                            context.ReceiveBuffer, 
                            context.ReceiveBufferOffset, 
                            context.ReceiveBuffer.Length,
                            new AsyncCallback(this.ReadCallback), 
                            context);
                    }
                }
            }
            catch
            {
                Disconnect( context );
                throw;
            }
        }

        private void ReadCallback( IAsyncResult ar )
        {
            int iBytesRead = 0;

            // use this instead of the member function because it is possible that the service disconnected before the callback
            // leaving the member variable null.
            ConnectionContext context = (ConnectionContext)ar.AsyncState;

            Interlocked.Exchange(ref context.Receiving, 0);
            
            try
            {
                lock (context.ConnectionLock)
                {
                    if (context.IsConnected)
                    {
                        iBytesRead = context.NetworkStream.EndRead( ar );
                    }
                }
            }
            catch( Exception exc )
            {
                Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: EndRead failed: " + exc.ToString());
                goto lDone;
            }

            if( 0 != iBytesRead )
            {
                //
                // _iReceiveBufferOffset is how much data we have to process - so include received data
                //
                context.ReceiveBufferOffset += iBytesRead;

                ParseReceiveBuffer(context.ReceiveBuffer, ref context.ReceiveBufferOffset);
                
                if (context.ReceiveBufferOffset >= context.ReceiveBuffer.Length)
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: Receive buffer is completely full after ParseReceiveBuffer.");
                    Disconnect( context );
                }

                //
                // If we're connected, keep things going
                //
                if( context.IsConnected )
                {
                    try
                    {
                        StartReceiving( context );
                    }
                    catch( Exception exc )
                    {
                        Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: StartReceiving failed: " + exc.ToString());
                        Disconnect( context );
                    }
                }
            }

        lDone:

            if( 0 == iBytesRead )
            {
                Disconnect( context );
            }

            return;
        }

        private void _SendThread()
        {
            WireData wireData;
            byte[] rgbData;

        Restart:
            try
            {
                while( true )
                {
                    ConnectionContext context;
                    
                    if( ( true == _hSendThread.WaitOne( ) ) && ( _iShutdown == 1 ) )
                    {
                        //
                        // Received a signal and the target is shutting down
                        //
                        break;
                    }

                    context = _connectionContext;

                    wireData = null;

                    if (context == null || !context.IsConnected)
                    {
                        //
                        // Socket isn't connected, can't send
                        //
                        continue;
                    }

                    while( true )
                    {
                        lock( _listBuffers ) 
                        {
                            if( 0 == _listBuffers.Count )
                            {
                                //
                                // Empty queue, nothing to send
                                //
                                break;
                            }
                            wireData = _listBuffers.First.Value;
                            _listBuffers.RemoveFirst();

                            ReportTargetCounters.Current(Component).QueueLength.Decrement();
                        }

                        if( null != wireData )
                        {
                            try
                            {
                                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                                rgbData = ( byte[] ) wireData;

                                if (wireData is ReportMessageData2)
                                {
                                    // We need to set the usSize member to the size of 
                                    // this message minus the 12 bytes of headers. It's a 
                                    // bit of a hack, sorry.
                                    ushort sizeMsg = (ushort)(rgbData.Length - ReportMessageBase.cMinMessageSizeBytes);
                                    byte[] sizeBytes = BitConverter.GetBytes(sizeMsg);
                                    Array.Copy(sizeBytes, 0, rgbData, 2, 2);
                                }
                                
                                // Grab the freshest one
                                context = _connectionContext;

                                lock (context.ConnectionLock)
                                {
                                    if (context.IsConnected)
                                    {
                                        context.NetworkStream.Write( rgbData, 0, rgbData.Length );
                                        wireData = null; // indicates we consumed this
                                    }
                                }

                                ReportTargetCounters.Current(Component).AverageSendTime.IncrementBy(timeElapsed.TimeElapsed);
                                ReportTargetCounters.Current(Component).AverageSendTimeBase.Increment();
                            }
                            catch( Exception exc )
                            {
                                Disconnect( context );

                                Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection._SendThread] - Send error: " + exc.ToString());
                                throw;
                            }
                            finally
                            {
                                if (null != wireData)
                                {
                                    //
                                    // Throw the item back at the beginning of the queue
                                    //
                                    lock( _listBuffers )
                                    {
                                        _listBuffers.AddFirst( wireData );
                                    }
                                    ReportTargetCounters.Current(Component).QueueLength.Increment();
                                }
                            }
                            if (null != wireData)
                            {
                                goto Restart;
                            }
                        }
                    }
                }
            }
            catch( ThreadAbortException threadExc )
            {
                //
                // We are being forced to shutdown
                //
                Xom.NtEvent( XEvent.Id.COMMON_CODE_29, threadExc, "[ReportConnection._SendThread] - Thread being aborted");
                goto lDone;
            }
            catch( Exception exc )
            {
              Xom.NtEvent( XEvent.Id.COMMON_CODE_30, exc, "[ReportConnection._SendThread] - Restarting send logic from unexpected exception");
                goto Restart;
            }

        lDone:
            return;
        }

        public string Server
        {
            get { return _vcServer; }
            set { _vcServer = value; }
        }

        public Int32 ComponentID
        {
            get { return _iComponentID; }
            set { _iComponentID = value; }
        }

        public string Component
        {
            get { return _strComponent; }
            set { _strComponent = value; }
        }

        //
        // Some state information
        //
        private const Int32 S_NOT_CONNECTED = 0; // Not connected.
        private const Int32 S_CONNECTED = 1; // Connected

        ConnectionContext _connectionContext;

        private LinkedList<WireData> _listBuffers;

        private Int32 _iDroppedEvent;

        private string _vcServer;
        private Int32 _iComponentID;
        private string _strComponent;

        private int _iInitialized;
        private XboxLiveThread _threadSend;
        private int _iShutdown;
        private AutoResetEvent _hSendThread;
    };

    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "Reporting Target", "XBox Live Reporting Target", true )]
    public class ReportTargetCounters : XomPerformanceCounterCategory
    {
        static private ReportTargetCounters _instance = new ReportTargetCounters();

        static public ReportTargetCounters Current()
        {
            return Current(null);
        }

        static public ReportTargetCounters Current(string component)
        {
            if (component == null)
            {
                component = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (ReportTargetCounters)_instance.GetInstance(component);
        }

        [XomPerformanceCounterAttr(
            "Messages/sec",
            "Messages per second collected from core XBL components",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesPerSecond;

        [XomPerformanceCounterAttr(
            "Messages total",
            "Total messages collected from core XBL components from the service startup.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesTotal;

        [XomPerformanceCounterAttr(
            "Queued messages",
            "Total messages in the target queue.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueueLength;

        [XomPerformanceCounterAttr(
            "Reporting target avg. send time",
            "Reporting target average request send time in the current service.",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageSendTime;

        [XomPerformanceCounterAttr(
            "Reporting target avg. send time base",
            "Reporting target base for the average request send time in the current service.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageSendTimeBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\presenceprot.cs ===
// 
// PresenceProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Service Integration
// Xbox Online Service
// 
// Author: phansen, masonb
//

using System.IO;
using System.Text;
using STF.common.service;
using STF.common.mgmt;
using STF.common.config;

[assembly: XomAreaDefinition(XomAreaName.PresenceProxy)]


namespace STF.common.protocol 
{
    //
    // Enum of message types. 
    //  Maps to Q_MSG_TYPES in STF.x
    //  
    public enum Q_MSG_TYPES
    {
        //
        // Incoming messages
        //
        QMSG_MIN_REQ_TYPE                  =  0,
        QMSG_HELLO                         =  0,
        QMSG_USER_INFO                     =  1,
        QMSG_ADD                           =  2,
        QMSG_DELETE                        =  3,
        QMSG_DELETE_MATCHES                =  4,
        QMSG_DEAD_XBOX                     =  5,
        QMSG_DEAD_SG                       =  6,
        QMSG_LIST                          =  7,
        QMSG_DEQUEUE                       =  8,
        QMSG_DEAD_USER                     =  9,
        QMSG_WEB_USER_INFO                 = 10,
        QMSG_WEB_PRESENCE                  = 11,
        QMSG_WEB_LIST                      = 12,
        QMSG_ENUM_MESSAGES                 = 13,
        QMSG_MESSAGE_SUMMARY               = 14,
        QMSG_MESSAGE_DETAILS               = 15,
        QMSG_DELETE_MESSAGE                = 16,
        QMSG_SEND_MESSAGE                  = 17,
        QMSG_REVOKE_MESSAGE                = 18,
        QMSG_DELETE_TITLE                  = 19,
        QMSG_ENUM_TITLES                   = 20,
        QMSG_MESSAGE_FLAGS                 = 21,
        QMSG_ENUM_SYSTEM_MESSAGES          = 22,
        QMSG_SYSTEM_MESSAGE_DETAILS        = 23,
        QMSG_DELETE_SYSTEM_MESSAGE         = 24,
        QMSG_SEND_SYSTEM_MESSAGE           = 25,
        QMSG_REVOKE_MESSAGE_EX             = 26,
        QMSG_ENUM_MESSAGES_2               = 27,
        QMSG_MESSAGE_SUMMARY_2             = 28,
        QMSG_MAX_REQ_TYPE                  = 28,

        //
        // Outgoing messages
        //
        QMSG_MIN_REPLY_TYPE                = 100,
        QMSG_LIST_REPLY                    = 100,
        QMSG_WEB_LIST_REPLY                = 101,
        QMSG_ENUM_MESSAGES_REPLY           = 102,
        QMSG_MESSAGE_SUMMARY_REPLY         = 103,
        QMSG_MESSAGE_DETAILS_REPLY         = 104,
        QMSG_DELETE_MESSAGE_REPLY          = 105,
        QMSG_SEND_MESSAGE_REPLY            = 106,
        QMSG_REVOKE_MESSAGE_REPLY          = 107,
        QMSG_DELETE_TITLE_REPLY            = 108,
        QMSG_ENUM_TITLES_REPLY             = 109,
        QMSG_MESSAGE_FLAGS_REPLY           = 110,
        QMSG_ENUM_SYSTEM_MESSAGES_REPLY    = 111,
        QMSG_SYSTEM_MESSAGE_DETAILS_REPLY  = 112,
        QMSG_DELETE_SYSTEM_MESSAGE_REPLY   = 113,
        QMSG_SEND_SYSTEM_MESSAGE_REPLY     = 114,
        QMSG_ENUM_MESSAGES_2_REPLY         = 115,
        QMSG_MESSAGE_SUMMARY_2_REPLY       = 116,
        QMSG_LIST_REPLY_2                  = 117,
        QMSG_MAX_REPLY_TYPE                = 117
    };       


    public enum P_MSG_TYPES
    {
        //
        // Incoming messages
        //
        PMSG_MIN_REQ_TYPE                  = 1000,
        PMSG_HELLO                         = 1000,
        PMSG_ALIVE                         = 1001,
        PMSG_SYNC                          = 1002,
        PMSG_REFRESH                       = 1003,
        PMSG_ADD                           = 1004,
        PMSG_DELETE                        = 1005,
        PMSG_ACCEPT                        = 1006,
        PMSG_REJECT                        = 1007,
        //Mute is the right name which is used internally. Adding PMSG_MUTE. Leaving PMSG_BLOCK so that if we do a search, we still find it.
        //PMSG_BLOCK                         = 1008, 
        PMSG_MUTE                          = 1008,
        //UnMute is the right name which is used internally. Adding PMSG_UNMUTE. Leaving PMSG_UNBLOCK so that if we do a search, we still find it.
        //PMSG_UNBLOCK                       = 1009, 
        PMSG_UNMUTE                        = 1009,
        PMSG_INVITE                        = 1010,
        PMSG_CANCEL                        = 1011,
        PMSG_INVITE_ANSWER                 = 1012,
        PMSG_NICKNAME                      = 1013,
        PMSG_STATE                         = 1014,
        PMSG_DEAD_XBOX                     = 1015,
        PMSG_DEAD_SG                       = 1016,
        PMSG_ANNOUNCE                      = 1017,
        PMSG_SUBSCRIBED                    = 1018,
        PMSG_UNSUBSCRIBE                   = 1019,
        PMSG_ADDED                         = 1020,
        PMSG_ACCEPTED                      = 1021,
        PMSG_REMOVED                       = 1022,
        PMSG_KICK                          = 1023,
        PMSG_DEAD_USER                     = 1024,
        PMSG_ALIVE_2                       = 1025,
        PMSG_WEB_FRIENDS                   = 1026,
        PMSG_WEB_ALIVE                     = 1027,
        PMSG_WEB_ANNOUNCE                  = 1028,
        PMSG_WEB_SUBSCRIBED                = 1029,
        PMSG_WEB_UNSUBSCRIBE               = 1030,
        PMSG_PEER_SESSION                  = 1031,
        PMSG_TEAM_LIST_TEAMS               = 1032,
        PMSG_TEAM_LIST_MEMBERS             = 1033,
        PMSG_TEAM_CREATE                   = 1034,
        PMSG_TEAM_DELETE                   = 1035,
        PMSG_TEAM_REMOVE                   = 1036,
        PMSG_TEAM_MANAGE_TEAM              = 1037,
        PMSG_TEAM_MANAGE_MEMBER            = 1038,
        PMSG_TEAM_RECRUIT                  = 1039,
        PMSG_TEAM_JOIN                     = 1040,
        PMSG_TEAM_GET_TICKET               = 1041,
        PMSG_PEER_SUBSCRIBE                = 1042,
        PMSG_PEER_UNSUBSCRIBE              = 1043,
        PMSG_WATCH_START                   = 1044,
        PMSG_WATCH_STOP                    = 1045,
        PMSG_ADD_2                         = 1046,
        PMSG_INVITE_2                      = 1047,
        PMSG_ALIVE_INTERNAL                = 1048,
        PMSG_STATE_2                       = 1049,        
        PMSG_GET_STATE                     = 1050,
        PMSG_TEAM_CREATE_XE                = 1051,
        PMSG_TEAM_MANAGE_TEAM_XE           = 1052,
        PMSG_ADD_AFFILIATES                = 1053,
        PMSG_IS_AFFILIATE                  = 1054,
        PMSG_QUERY_AFFILIATES              = 1055,
        PMSG_GET_PRESENCE_INFO             = 1056,
        PMSG_PRESENCE_INFO_REPLY            =1057,
        PMSG_INVALIDATE_USER               = 1058,
        PMSG_FIND_USER                     = 1059,
        PMSG_CHECK_TITLE_MESSAGES          = 1060,
        PMSG_TEAM_LIST_USER_TEAMS          = 1061,
        PMSG_USER_PRE_MIGRATION            = 1062,
        PMSG_USER_FULL_MIGRATION           = 1063,
        PMSG_LOGON_CHECK                   = 1064,
        PMSG_FIND_USERS                    = 1065,
        PMSG_ALIVE_INTERNAL_2              = 1066,
        PMSG_PEER_SUBSCRIBE_EX             = 1067,
        PMSG_PURGE_USER                    = 1068,
        PMSG_GET_FRIENDS_LIST              = 1069,
        PMSG_CONTINUATION                  = 1070,
        PMSG_CONNECTION_HEALTH             = 1071,
        PMSG_ADD_USERS_TO_NEVERLIST        = 1072,
        PMSG_REMOVE_USERS_FROM_NEVERLIST   = 1073,
        PMSG_CAN_SEND_MESSAGE              = 1074,
	    PMSG_WEB_ALIVE2                    = 1075,
        PMSG_GET_FRIENDS_NO_PRESENCE       = 1076,
        PMSG_GET_FRIENDS_LIMITED_PRESENCE  = 1077,
        PMSG_MAX_REQ_TYPE                  = 1077,
        


        //
        // Outgoing messages
        //
        PMSG_MIN_REPLY_TYPE                = 1101,
        PMSG_ALIVE_REPLY                   = 1101,
        PMSG_SYNC_REPLY                    = 1102,
        PMSG_WEB_FRIENDS_REPLY             = 1103,
        PMSG_WEB_ALIVE_REPLY               = 1104,
        PMSG_PEER_SESSION_REPLY            = 1105,
        PMSG_INVITE_REPLY                  = 1106,
        PMSG_TEAM_LIST_TEAMS_REPLY         = 1107,
        PMSG_TEAM_LIST_MEMBERS_REPLY       = 1108,
        PMSG_TEAM_CREATE_REPLY             = 1109,
        PMSG_TEAM_DELETE_REPLY             = 1110,
        PMSG_TEAM_REMOVE_REPLY             = 1111,
        PMSG_TEAM_MANAGE_TEAM_REPLY        = 1112,
        PMSG_TEAM_MANAGE_MEMBER_REPLY      = 1113,
        PMSG_TEAM_RECRUIT_REPLY            = 1114,
        PMSG_TEAM_JOIN_REPLY               = 1115,
        PMSG_TEAM_GET_TICKET_REPLY         = 1116,
        PMSG_PEER_SUBSCRIBE_REPLY          = 1117,
        PMSG_PEER_UNSUBSCRIBE_REPLY        = 1118,
        PMSG_GET_STATE_REPLY               = 1119,
        PMSG_IS_AFFILIATE_REPLY            = 1120,
        PMSG_QUERY_AFFILIATES_REPLY        = 1121,
        PMSG_FIND_USER_REPLY               = 1122,
        PMSG_CHECK_TITLE_MESSAGES_REPLY    = 1123,
        PMSG_TEAM_LIST_USER_TEAMS_REPLY    = 1124,
        PMSG_LOGON_CHECK_REPLY             = 1125,
        PMSG_FIND_USERS_REPLY              = 1126,
        PMSG_PEER_SUBSCRIBE_EX_REPLY       = 1127,
        PMSG_PURGE_USER_REPLY              = 1128,
        PMSG_GET_FRIENDS_LIST_REPLY        = 1129,
        PMSG_CONNECTION_HEALTH_REPLY       = 1130,
        PMSG_CAN_SEND_MESSAGE_REPLY        = 1131,
        PMSG_GET_FRIENDS_NO_PRESENCE_REPLY = 1132,
        PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY = 1133,
        PMSG_MAX_REPLY_TYPE                = 1133
    };

    public enum P_QUEUE_TYPES : ushort
    {
        //
        // Outgoing queued response items
        //
        PQUEUE_BUDDY_REQ            = 0,
        PQUEUE_LIST_CHANGE          = 1,
        PQUEUE_PRESENCE             = 2,
        PQUEUE_INVITE               = 3,
        PQUEUE_INVITE_ANSWER        = 4,
        PQUEUE_TRANSIENT_MSGS       = 5,
        PQUEUE_PEER_PRESENCE        = 6,
        PQUEUE_PRESENCE_2           = 7,
       
        PQUEUE_NUM_TYPES            = 8
    };


    public class PresDefs
    {
        public const int CURRENT_XPPROTOCOL_VER = 0x00010000;
        
        public const int XONLINE_GAMERTAG_SIZE             = 16;
        public const int XONLINE_PRESENCE_LOCALE_SIZE      = 40;
        public const int MAX_TITLE_STATE_BYTES             = 32;

        // public system set state flags
        public const uint P_STATE_FLAG_NONE                = 0;
        public const uint P_STATE_FLAG_ONLINE              = 0x00000001; // Set if online
        public const uint P_STATE_FLAG_PLAYING             = 0x00000002; // Set if playing a game
        public const uint P_STATE_FLAG_CLOAKED             = 0x00000004; // Set to fake being offline
        public const uint P_STATE_FLAG_VOICE               = 0x00000008; // Set if supports voice
        public const uint P_STATE_FLAG_JOINABLE            = 0x00000010; // Set if session is joinable
        public const uint P_STATE_MASK_GUESTS              = 0x00000060;
        public const uint P_STATE_FLAG_RESERVED0           = 0x00000080;
        public const uint P_STATE_MASK_JOINABLE_FRIENDS_ONLY = 0x00000100;
        public const uint P_STATE_MASK_PARTY_JOINABLE = 0x00000200;
        public const uint P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY = 0x00000400;
        public const uint P_STATE_MASK_PARTY_PLAYING = 0x00000800;

        // reuse of client flags for server-specific flags
        public const uint P_STATE_MASK_CLIENTFLAGS   = 0xFC000000;
        public const uint P_STATE_MASK_TITLEID_CHANGED = 0x80000000;
        public const uint P_STATE_MASK_TITLEDATA_CHANGED = 0x40000000;
        public const uint P_STATE_MASK_SESSIONID_CHANGED = 0x20000000;
        public const uint P_STATE_MASK_RICHPRES_CHANGED = 0x10000000;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;

        // console types
        public const uint P_STATE_MASK_CONSOLE_TYPE        = 0x00007000;
        public const uint P_STATE_ENUM_CONSOLE_XBOX        = 0x00000000;
        public const uint P_STATE_ENUM_CONSOLE_XENON       = 0x00001000;
        public const uint P_STATE_ENUM_CONSOLE_WINPC       = 0x00002000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD1       = 0x00003000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD2       = 0x00004000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD3       = 0x00005000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD4       = 0x00006000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD5       = 0x00007000;

        // messaging/notification state flags
        public const uint P_STATE_FLAG_VOICE_TV            = 0x02000000;
        public const uint P_STATE_FLAG_SENTINVITE          = 0x04000000;
        public const uint P_STATE_FLAG_RECEIVEDINVITE      = 0x08000000;
        public const uint P_STATE_FLAG_INVITEACCEPTED      = 0x10000000;
        public const uint P_STATE_FLAG_INVITEREJECTED      = 0x20000000;
        public const uint P_STATE_FLAG_SENTREQUEST         = 0x40000000;
        public const uint P_STATE_FLAG_RECEIVEDREQUEST     = 0x80000000;

        // User buddy status
        public const uint P_BUDDY_STATUS_OK                = 0; // Mutually accepted buddy
        public const uint P_BUDDY_STATUS_PENDING           = 1; // Buddy request pending acceptance
        public const uint P_BUDDY_STATUS_REQUEST           = 2; // Buddy request to accept or reject
 
        // Invite answers
        public const ushort PINVITE_REPLY_NO               = 0;
        public const ushort PINVITE_REPLY_YES              = 1;
        public const ushort PINVITE_REPLY_NEVER            = 2;

        // Affiliate flags for valid list types
        public const uint X_AFFILIATE_ENCOUNTERED_INDEX         = 0;
        public const uint X_AFFILIATE_COMPLETED_GAME_INDEX      = 1;
        public const uint X_AFFILIATE_POSITIVE_FEEDBACK_INDEX   = 2;
        public const uint X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX   = 3;
        public const uint X_AFFILIATE_AVOIDING_ME_INDEX         = 4;
        public const uint X_AFFILIATE_FAVORITES_INDEX           = 5;
        // Affiliate flags for other types
        public const uint X_AFFILIATE_FRIEND_INDEX              = 16;
        public const uint X_AFFILIATE_BLOCK_INDEX               = 17;
        public const uint X_AFFILIATE_MUTE_INDEX                = 18;

        public const uint X_AFFILIATE_INDEX_ERROR = 0xFFFFFFFF;

        public const uint NUM_STORED_AFFILIATE_LISTS            = 6;

        public static int MAX_AFFILIATES(uint dwListType)
        {
            switch(dwListType)
            {
                case X_AFFILIATE_ENCOUNTERED_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesEncounteredListSize);
                case X_AFFILIATE_COMPLETED_GAME_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesCompletedGameListSize);
                case X_AFFILIATE_POSITIVE_FEEDBACK_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesPositiveFeedbackListSize);
                case X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesNegativeFeedbackListSize);
                case X_AFFILIATE_AVOIDING_ME_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesAvoidingMeListSize);
                case X_AFFILIATE_FAVORITES_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesFavoritesListSize);
                default:
                    return 0;
            }
        }

        public static uint X_AFFILIATE_INDEX_TO_FLAG(uint dwIndex) { return (uint)(1 << (int)dwIndex); }
        public static uint X_AFFILIATE_FLAG_TO_INDEX(uint dwFlag)
        {
            return (
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX)) ? PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX)) ? PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)) ? PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)) ? PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX)) ? PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FAVORITES_INDEX)) ? PresDefs.X_AFFILIATE_FAVORITES_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX)) ? PresDefs.X_AFFILIATE_FRIEND_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_BLOCK_INDEX)) ? PresDefs.X_AFFILIATE_BLOCK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_MUTE_INDEX)) ? PresDefs.X_AFFILIATE_MUTE_INDEX : PresDefs.X_AFFILIATE_INDEX_ERROR
            );
        }

        public const uint X_AFFILIATE_MASK_POSITIVE =
            X_AFFILIATE_COMPLETED_GAME_INDEX |
            X_AFFILIATE_ENCOUNTERED_INDEX |
            X_AFFILIATE_FAVORITES_INDEX |
            X_AFFILIATE_FRIEND_INDEX |
            X_AFFILIATE_POSITIVE_FEEDBACK_INDEX;

        public const uint MAX_ADD_AFFILIATE = 16;

        public const uint MAX_FIND_USERS_REQUESTS = 100;

        public const uint XONLINE_PRESENCE_LOGON_KNOWN_CONSOLE = 0;
        public const uint XONLINE_PRESENCE_LOGON_FIRST_TIME_CONSOLE = 1;
        public const uint XONLINE_PRESENCE_LOGON_FIRST_TIME_LIVE = 2;


        public static byte GetPlatformType(uint dwState)
        {
            switch (dwState & P_STATE_MASK_CONSOLE_TYPE)
            {
                case P_STATE_ENUM_CONSOLE_XBOX:
                    return XOn.XPLT_XBOX1;
                case P_STATE_ENUM_CONSOLE_XENON:
                    return XOn.XPLT_XBOX360;
                case P_STATE_ENUM_CONSOLE_WINPC:
                    return XOn.XPLT_PC;
                default:
                    return XOn.XPLT_INVALID;
            }
        }
    };



    //
    // Structure Representing base Presence & Notification Message info
    //  Maps to BASE_MSG_HEADER in STF.x
    //  
    public class BaseHeader : WireData
    {
        public uint     dwMsgType;
        public uint     dwMsgLen;
        [WireInfo(HexString=true)]
        public uint     dwSeqNum;
        public SGADDR   sgaddr;

        // BYTE rgbMsgData[ dwMsgLen ];

        [WireInfo(Serialize=false)]
        private WireData container;

        public WireData Container
        {
            get {return container;}
            set {container = value;}
        }
        
        // 
        // WireData requires a default constructor with no args for deserialization, so this must exist
        //        
        public BaseHeader()
        {
        }
        
        // 
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        //        
        public BaseHeader( Q_MSG_TYPES msgType, WireData parent )
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public BaseHeader(P_MSG_TYPES msgType, WireData parent)
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // 
            // NOTE!! The containing WireData object MUST also override Size() otherwise
            //  this will result in an infinite recursion/stack overflow situation
            // 
            if( null != container )
            {
                dwMsgLen = (uint)( container.Size() - Size() );
            }
            else
            {
                // We allow this case for unit tests that want to simulate truncated messages by just sending 
                // the correct base header.
                dwMsgLen = 0;
            }

            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
            sgaddr.WriteStream(binaryWriter);

        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwMsgType = (uint)binaryReader.ReadInt32();
                dwMsgLen = (uint)binaryReader.ReadInt32();
                dwSeqNum = (uint)binaryReader.ReadInt32();
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_14, 
                    "Reached end of stream trying to read BaseHeader", e);
            }
            return this;
        }

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER )
            return 32;
        }        
    };

    public class PresenceXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xpresence.srf";
            }
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_HELLO_MSG in STF.x
    //
    public class PresenceHelloMsg : XRLObject2
    {
        public PresenceHelloMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_HELLO, this );
        }

        public BaseHeader       header;
        public uint             dwProtocolVersion;

        [WireInfo(NullTerminate=true, ArraySize=79)]
        public string           szDescription;      

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceHelloMsg )
            return 32 + 4 + 80;
        }        
    }


    public class PresenceConnectionHealthMsg : XRLObject2
    {
        public PresenceConnectionHealthMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH, this );
        }

        public BaseHeader       header;
        public uint             dwVersion;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthMsg )
            return 32 + 8;
        }        
    }

    public class PresenceConnectionHealthReplyMsg : XRLObject2
    {
        public PresenceConnectionHealthReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthReplyMsg )
            return 32 + 8;
        }        
    }

    // Structures returned by APIs ///////////////////////////////////////////////////////////

    //
    // Structure representing a buddy in an Alive reply
    //  maps to P_REPLY_BUDDY in STF.x
    //
    public class ReplyBuddy : WireData
    {
        public ulong            qwBuddyID;
        public ushort           cbAcctName; // Includes the '\0'
        public byte             bStatus;    // See P_BUDDY_STATUS_XXX
       
        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName; // ASCII Null terminated

        override public int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            return 11 + cbAcctName;
        }
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in STF.x
    //
    public class QueryAffiliatesReplyData : WireData
    {
        [WireInfo(HexString=true)]
        public ulong            qwAffiliateID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        [WireInfo(HexString=true)]
        public uint             dwTitleID;
        [WireInfo(HexString=true)]
        public ulong            qwSessionID;
        [WireInfo(HexString=true)]
        public uint             mtDateUpdated;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag; // ASCII Null terminated

        override public int Size()
        {
            return 44;
        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwAffiliateID = (ulong)binaryReader.ReadInt64();
                dwListFlags = (uint)binaryReader.ReadInt32();
                dwTitleID = (uint)binaryReader.ReadInt32();
                qwSessionID = (ulong)binaryReader.ReadInt64();
                mtDateUpdated = (uint)binaryReader.ReadInt32();
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_GAMERTAG_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szGamerTag = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szGamerTag = s;
                }
                else
                {
                    szGamerTag = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_15, 
                    "Reached end of stream trying to read QueryAffiliatesReplyData", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwAffiliateID);
            binaryWriter.Write(dwListFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(qwSessionID);
            binaryWriter.Write(mtDateUpdated);

            byte[] b;
            if (szGamerTag != null)
            {
                // write the string, but only up to XONLINE_GAMERTAG_SIZE
                b = new UTF8Encoding().GetBytes(szGamerTag);
                if (b.Length <= PresDefs.XONLINE_GAMERTAG_SIZE)
                {
                    binaryWriter.Write(b);
                }
                else
                {
                    binaryWriter.Write(b, 0, PresDefs.XONLINE_GAMERTAG_SIZE);
                }
            }
            else
            {
                b = new byte[0];
            }

            // if we need to, zero pad the string out to XONLINE_GAMERTAG_SIZE
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }
        }
    }


    // Externally-callable Presence APIs /////////////////////////////////////////////////////

    //
    // Structure representing a request to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_MSG in STF.x
    //
    public class PresenceLogonCheckMsg : XRLObject2
    {
        public PresenceLogonCheckMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        public override int Size()
        {
            return 32 + 8;
        }
    }

    //
    // Structure representing a the response to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_REPLY_MSG in STF.x
    //
    public class PresenceLogonCheckReplyMsg : XRLObject2
    {
        public PresenceLogonCheckReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK_REPLY, this);
        }

        public BaseHeader header;
        public HResult hr;

        public override int Size()
        {
            return 32 + 4;
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_ALIVE_MSG in STF.x
    //
    public class PresenceAliveMsg : XRLObject2
    {
        public PresenceAliveMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ushort           cbAcctName;
        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;
        public uint             dwState;            // Must be ( P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED )
        public ulong            qwMatchSessionID;   // Must be zero
        public ushort           cbNickname;         // Must be zero
        public ushort           cbTitleStuff;       // Must be zero

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;
 
        [WireInfo(SizeParam="cbNickname")]
        public byte[]           rgbNickName;        

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;
            cbNickname = null == rgbNickName ? (ushort) 0 : (ushort) rgbNickName.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveMsg ) + cbAcctName + cbTitleStuff + cbNickname
            return 32 + 38 + cbAcctName + cbTitleStuff + cbNickname;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                cbAcctName = binaryReader.ReadUInt16();
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                cbNickname = binaryReader.ReadUInt16();
                cbTitleStuff = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }

                rgbTitleStuff = binaryReader.ReadBytes(cbTitleStuff);
                rgbNickName = binaryReader.ReadBytes(cbNickname);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_16, 
                    "Reached end of stream trying to read PresenceAliveMsg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, version 2
    //  maps to P_ALIVE_2_MSG in STF.x
    //
    public class PresenceAlive2Msg : XRLObject2
    {
        public PresenceAlive2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public ulong            clientVersion;
        public uint             dwTitleID;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAlive2Msg ) + cbAcctName
            return 32 + 120 + cbAcctName;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                cbAcctName = binaryReader.ReadUInt16();
                xnaddr = new XNADDR();
                xnaddr.ReadStream(binaryReader);
                xnkid = binaryReader.ReadUInt64();
                xnkey = binaryReader.ReadBytes(16);
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                clientVersion = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwTitleVersion = binaryReader.ReadUInt32();
                dwTitleRegion = binaryReader.ReadUInt32();
                ipportI = binaryReader.ReadUInt16();
                ipaI = binaryReader.ReadUInt32();
                liNonce = binaryReader.ReadUInt64();
                liTimeInit = binaryReader.ReadUInt64();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_17, 
                    "Reached end of stream trying to read PresenceAlive2Msg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, internal version
    //  maps to P_ALIVE_INTERNAL_MSG in STF.x
    //
    public class PresenceAliveInternalMsg : XRLObject2
    {
        public PresenceAliveInternalMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 140 + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    public class PresenceAliveInternal2Msg : XRLObject2
    {
        public PresenceAliveInternal2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        public ulong            qwVersionFlags;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 148 + PresDefs.XONLINE_PRESENCE_LOCALE_SIZE + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            int iLocaleLen = 0;
            if (szLocale != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szLocale);
                binaryWriter.Write(b);
                iLocaleLen = b.Length;
            }
            for (int iByte = iLocaleLen; iByte < PresDefs.XONLINE_PRESENCE_LOCALE_SIZE; iByte++)
            {
                binaryWriter.Write((byte)0);
            }
            binaryWriter.Write(qwVersionFlags);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    //
    // Structure representing a reply to an Alive request
    //  maps to P_ALIVE_REPLY_MSG in STF.x
    //
    public class PresenceAliveReply : XRLObject2
    {
        public PresenceAliveReply()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;                         // On fail other fields set to 0
        public uint             dwBuddyListVersion;
        public ushort           cBuddiesSent;
        public uint             dwBlockListVersion;
        public ushort           cBlocksSent;

        [WireInfo(SizeParam="cBuddiesSent")]
        public ReplyBuddy[]     rgReplyBuddies;
      
        [WireInfo(SizeParam="cBlocksSent")]
        public ulong[]          rgqwBlockIDs; // maps to P_REPLY_BLOCK in STF.x

        public override int Size()
        {
            // Get the correct sizes before we use them
            cBuddiesSent = null == rgReplyBuddies ? (ushort) 0 : (ushort) rgReplyBuddies.Length;
            cBlocksSent = null == rgqwBlockIDs ? (ushort) 0 : (ushort) rgqwBlockIDs.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveReply ) + cBuddiesSent * sizeof( ReplyBuddy ) + cBlocksSent * sizeof( ulong )
            int iSize = 32 + 16 + cBlocksSent * 8;
            for( int iBuddy = 0; iBuddy < cBuddiesSent; iBuddy++ )
            {
                iSize += rgReplyBuddies[ iBuddy ].Size();
            }
            return iSize;
        }        
    }

    //
    // Structure representing a request to take a user offline
    //  maps to P_DEAD_USER_MSG/Q_DEAD_USER_MSG
    //
    public class PresenceDeadUserMsg : XRLObject2
    {
        public PresenceDeadUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DEAD_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeadUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in STF.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceStateMsg : PresenceXrlObject
    {
        public PresenceStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;
        public ushort           cbTitleStuff;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + cbTitleStuff
            return 32 + 22 + cbTitleStuff;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cbTitleStuff = rgbTitleStuff == null ? (ushort)0 : (ushort)rgbTitleStuff.Length;
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(cbTitleStuff);
            binaryWriter.Write(rgbTitleStuff);
        }
    }
    

    //
    // Structure representing a rich presence state data
    //  maps to P_RICH_PRESENCE in STF.x
    //
    public class RichPresence : WireData
    {
        public uint             titlePresence;
        
        public ushort           cContexts;
        public ushort           cProperties;

        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;

        public override int Size()
        {
            cContexts = rgContexts == null ? (ushort)0 : (ushort)rgContexts.Length;
            cProperties = rgProps == null ? (ushort)0 : (ushort)rgProps.Length;            
            
            // sizeof( RichPresence )
            int cb = 8;

            // add all the contexts
            cb += cContexts * 8;
            
            // add all the props
            if (cProperties > 0)
            {
                foreach (GIProperty prop in rgProps)
                {
                    cb += prop.Size();
                }
            }

            return cb;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                titlePresence = binaryReader.ReadUInt32();
                cContexts = binaryReader.ReadUInt16();
                cProperties = binaryReader.ReadUInt16();
                rgContexts = new GIContext[cContexts];
                for (int i = 0; i < cContexts; ++i)
                {
                    rgContexts[i] = new GIContext();
                    rgContexts[i].ReadStream(binaryReader);
                }
                rgProps = new GIProperty[cProperties];
                for (int i = 0; i < cProperties; ++i)
                {
                    rgProps[i] = new GIProperty();
                    rgProps[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_18, 
                    "Reached end of stream trying to read RichPresence", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cContexts = rgContexts == null ? (ushort)0 : (ushort)rgContexts.Length;
            cProperties = rgProps == null ? (ushort)0 : (ushort)rgProps.Length;

            binaryWriter.Write(titlePresence);
            binaryWriter.Write(cContexts);
            binaryWriter.Write(cProperties);
            for (int i = 0; i < cContexts; ++i)
            {
                rgContexts[i].WriteStream(binaryWriter);
            }
            for (int i = 0; i < cProperties; ++i)
            {
                rgProps[i].WriteStream(binaryWriter);
            }
        }
    }

        
    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in STF.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceState2Msg : PresenceXrlObject
    {
        public PresenceState2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        public uint             cbRichPresence;     // Count of RP data

        public ushort           cbMemcacheData;     // Count of memcache data
        
        public RichPresence     rpData;

        [WireInfo(SizeParam="cbMemcacheData")]
        public byte[] rgbMemcacheData;

        public override int Size()
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence ) + sizeof(rgbMemcacheData)
            int cb = 32 + 30 + rpData.Size() + cbMemcacheData;
            
            return cb;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;
            
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(dwTitleId);
            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbMemcacheData);
            rpData.WriteStream(binaryWriter);

            if (rgbMemcacheData != null)
            {
                binaryWriter.Write(rgbMemcacheData);
            }
        }
    }

    //
    // Structure representing a request to fetch a user's state
    //  maps to P_GET_STATE_MSG in STF.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateMsg : PresenceXrlObject
    {
        public PresenceGetStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( qwUserID )
            return 32 + 8;
        }        
        
    }

    //
    // Structure representing a reply to a PresenceGetStateMsg request
    //  maps to P_GET_STATE_MSG in STF.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateReplyMsg : PresenceXrlObject
    {
        public PresenceGetStateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE_REPLY, this );
            presenceData = new RichPresence();
        }

        public BaseHeader       header;
        public HResult          hr;
        
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        
        RichPresence            presenceData;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence )
            int cb = 32 + 20 + presenceData.Size();

            return cb;
        }                
    }
    
    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_MSG in STF.x
    // 
    public class PresenceAddBuddyMsg : PresenceXrlObject
    {
        public PresenceAddBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public ushort           cbBuddyAcctName;
 
        [WireInfo(SizeParam="cbBuddyAcctName", NullTerminate=true)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbBuddyAcctName = null == szBuddyAcctName ? (ushort) 0 : (ushort) Encoding.UTF8.GetByteCount( szBuddyAcctName );
            // add one for the null terminator
            cbBuddyAcctName ++; 

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddyMsg ) + cbBuddyAcctName
            return 32 + 18 + cbBuddyAcctName;
        }        
        
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwSenderID = binaryReader.ReadUInt64();
                qwBuddyID = binaryReader.ReadUInt64();
                cbBuddyAcctName = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbBuddyAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szBuddyAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szBuddyAcctName = s;
                }
                else
                {
                    szBuddyAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_19, 
                    "Reached end of stream trying to read PresenceAddBuddyMsg", e);
            }
            return this;
        }
     }

    //
    // Structure representing a request to add  users to another user's affiliates list
    //  maps to P_ADD_AFFILIATES_MSG in STF.x
    // 
    public class PresenceAddAffiliatesMsg : PresenceXrlObject
    {
        public PresenceAddAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_AFFILIATES, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public uint             dwListFlag;
        public uint             dwTitleID;
        public ushort           cwAffiliates;
 
        [WireInfo(SizeParam="cwAffiliates")]
        public ulong[]          pqwAffiliates;
        
        public override int Size()
        {
            cwAffiliates = (pqwAffiliates == null) ? (ushort)0 : (ushort)pqwAffiliates.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddAffiliatesMsg ) + cwAffiliates * sizeof(ulong);
            return 32 + 18 + (8 * cwAffiliates);
        }        
    }

    //
    // Structure representing a request to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_MSG in STF.x
    // 
    public class PresenceIsAffiliateMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwAffiliateID;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a reply to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_REPLY_MSG in STF.x
    // 
    public class PresenceIsAffiliateReplyMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwAffiliateID;
        public uint             dwListFlags;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateReplyMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_MSG in STF.x
    // 
    public class PresenceQueryAffiliatesMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public ulong            qwSenderID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        public uint             cdwLimit;
        [WireInfo(HexString=true)]
        public uint             dwOnlineTitleID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesMsg );
            return 32 + 20;
        }        
    }

    //
    // Structure representing a reply with the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_REPLY_MSG in STF.x
    // 
    public class PresenceQueryAffiliatesReplyMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES_REPLY, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public HResult          hr;
        public uint             cdwResults;

        [WireInfo(SizeParam="cdwResults")]
        public QueryAffiliatesReplyData[]      rgResults;
        
        public override int Size()
        {
            cdwResults = rgResults == null ? (uint)0 : (uint)rgResults.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesReplyMsg ) + cdwResults * sizeof( QueryAffiliatesReplyData );
            return (int)(32 + 8 + (cdwResults * 44));
        }        
        
         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                hr = (uint)binaryReader.ReadInt32();
                cdwResults = (uint)binaryReader.ReadInt32();
                rgResults = new QueryAffiliatesReplyData[cdwResults];
                for (int i = 0; i < cdwResults; ++i)
                {
                    rgResults[i] = new QueryAffiliatesReplyData();
                    rgResults[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_20, 
                    "Reached end of stream trying to read PresenceQueryAffiliatesReplyMsg", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cdwResults = rgResults == null ? (uint)0 : (uint)rgResults.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(hr);
            binaryWriter.Write(cdwResults);
            for (int i = 0; i < cdwResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }
    }


    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_2_MSG in STF.x
    // 
    public class PresenceAddBuddy2Msg : PresenceXrlObject
    {
        public PresenceAddBuddy2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_2, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public uint             dwMessageFlags;
        public ushort           cbDetails;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        [WireInfo(SizeParam="cbDetails")]
        public byte[]   rgbDetails;

        public MessageDetails details
        {
            get
            {
                if ((rgbDetails != null) && (rgbDetails.Length > 0))
                {
                    MessageDetails ret = new MessageDetails();
                    ret.ReadBytes(rgbDetails);
                    return ret;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                if (value == null)
                {
                    rgbDetails = null;
                }
                else
                {
                    rgbDetails = (byte[])value;
                    cbDetails = (ushort)(rgbDetails.Length);
                }
            }
        }

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbDetails = (null == rgbDetails) ? (ushort) 0 : (ushort) rgbDetails.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddy2Msg ) + cbDetails
            return 32 + 38 + cbDetails;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwSenderID);
            binaryWriter.Write(qwBuddyID);
            binaryWriter.Write(dwMessageFlags);
            binaryWriter.Write(cbDetails);

            byte[] b;
            if (szBuddyAcctName != null)
            {
                b = Encoding.UTF8.GetBytes(szBuddyAcctName);
                binaryWriter.Write(b);
            }
            else
            {
                b = new byte[0];
            }

            // zero pad out to PresDefs.XONLINE_GAMERTAG_SIZE length
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }

            if (rgbDetails != null)
            {
                binaryWriter.Write(rgbDetails);
            }
        }
     }

    //
    // Structure representing a request to remove a user from another user's friends list
    //  maps to P_DELETE_MSG in STF.x
    // 
    public class PresenceDeleteBuddyMsg : PresenceXrlObject
    {
        public PresenceDeleteBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DELETE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeleteBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to accept a friend request
    //  maps to P_ACCEPT_MSG in STF.x
    // 
    public class PresenceAcceptBuddyMsg : PresenceXrlObject
    {
        public PresenceAcceptBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ACCEPT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAcceptBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to reject a friend request
    //  maps to P_REJECT_MSG in STF.x
    // 
    public class PresenceRejectBuddyMsg : PresenceXrlObject
    {
        public PresenceRejectBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_REJECT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;
        public uint             dwNever;
        
        
        public bool fNever
        {
            get { return (dwNever == 0 ? false : true); }
            set { dwNever = (uint)(value ? 1 : 0); }
        }    

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceRejectBuddyMsg )
            return 32 + 20;
        }        
    }
    
    //
    // Structure representing a request to add a user to another user's mute list
    //  maps to old P_BLOCK_MSG in STF.x
    // 
    public class PresenceMuteUserMsg : PresenceXrlObject
    {
        public PresenceMuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_MUTE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceMuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to remove a user from another user's mute list
    //  maps to old P_UNBLOCK_MSG in STF.x
    // 
    public class PresenceUnmuteUserMsg : PresenceXrlObject
    {
        public PresenceUnmuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_UNMUTE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID; // If qwBlockID == 0, clear the entire block list

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceUnmuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to add a list of users to neverlist (block communications)
    // 
    public class AddUsersToNeverListMsg : PresenceXrlObject
    {
        public AddUsersToNeverListMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cNeverListUserCount;

        [WireInfo(SizeParam = "cNeverListUserCount")]
        public ulong[] rgqwNeverListUsers;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cNeverListUserCount) + cNeverListUserCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cNeverListUserCount*sizeof(ulong);
        }     
    }


    //
    // Structure representing a request to remove a list of users from neverlist (allow previously blocked communication)
    // 
    public class RemoveUsersFromNeverListMsg : PresenceXrlObject
    {
        public RemoveUsersFromNeverListMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST, this);
        }

        public BaseHeader header;
        public ulong qwUserID;
        
        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cNeverListUserCount;

        [WireInfo(SizeParam = "cNeverListUserCount")]
        public ulong[] rgqwNeverListUsers;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cNeverListUserCount) + cNeverListUserCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cNeverListUserCount * sizeof(ulong);
        }   
    }


    //
    // Structure representing a request to check if a given user can send communication to another user
    // 
    public class CanSendMessageToUsersMsg : PresenceXrlObject
    {
        public CanSendMessageToUsersMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cUserListCount;

        [WireInfo(SizeParam = "cUserListCount")]
        public ulong[] rgqwUsers;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cUserListCount) + cUserListCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cUserListCount * sizeof(ulong);
        }   
    }

    public class CanSendMessageToUsersResponse : PresenceXrlObject
    {
        public CanSendMessageToUsersResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE_REPLY, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cResponseListCount;

        [WireInfo(SizeParam = "cResponseListCount")]
        public uint[] rghrResponses;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cResponseListCount) + cResponseListCount * sizeof (uint)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cResponseListCount * sizeof(uint);
        } 
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_MSG in STF.x
    // 
    public class PresenceInviteUserMsg : PresenceXrlObject
    {
        public PresenceInviteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUserMsg ) + cInvitees * sizeof( ulong )
            return 32 + 22 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_2_MSG in STF.x
    // 
    public class PresenceInviteUser2Msg : PresenceXrlObject
    {
        public PresenceInviteUser2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwSenderContext;
        public uint             dwTitleID;
        public uint             dwMessageFlags;
        public ushort           cInvitees;
        public ushort           cbDetails;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public MessageDetails   details;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;
            cbDetails = null == details ? (ushort) 0 : (ushort) details.Size();

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUser2Msg ) + cInvitees * sizeof( ulong ) + cbDetails
            return 32 + 28 + cInvitees * 8 + cbDetails;
        }        
    }

    //
    // Structure representing a request to cancel an invitation to a game session
    //  maps to P_CANCEL_MSG in STF.x
    // 
    public class PresenceCancelInviteMsg : PresenceXrlObject
    {
        public PresenceCancelInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CANCEL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceCancelInviteMsg ) + cInvitees * sizeof( ulong )
            return 32 + 18 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to answer an invitation to a game session
    //  maps to P_INVITE_ANSWER_MSG in STF.x
    // 
    public class PresenceAnswerInviteMsg : PresenceXrlObject
    {
        public PresenceAnswerInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_ANSWER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;
        public ulong            qwMatchSessionID;
        public ushort           wAnswer;          // See PINVITE_REPLY_XXX

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAnswerInviteMsg )
            return 32 + 26;
        }        
    }


    // Externally-callable Notification APIs /////////////////////////////////////////////////

    //
    // Structure representing a request to dequeue notification items on behalf of a user
    //  maps to Q_DEQUEUE_MSG in STF.x
    //  
    public class NotificationDequeueMsg : XRLObject2
    {
        public NotificationDequeueMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DEQUEUE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public uint             dwStartItemID;
        public ushort           wMaxItems;
        public uint             dwMaxTotalItemDataSize;

        public override int Size()
        {
            // sizeof( Q_DEQUEUE_MSG )
            return 52;
        }
    }


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_LIST_CHANGE
    //
    public class ListChangeItem : WireData
    {
        public uint        dwListVersion;
        public ulong       qwTargetID;
        public ushort      wOperationID;
        public HResult     hr;
        public ushort      cbTargetAcctName;
        
        [WireInfo(SizeParam="cbTargetAcctName")]  // ASCII string null terminated
        public string      szTargetAcctName;

        public override int Size()
        {
            cbTargetAcctName = (szTargetAcctName == null) ? (ushort)0 : (ushort)Encoding.UTF8.GetByteCount(szTargetAcctName);

            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 20 + cbTargetAcctName;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE
    //
    public class PresenceItem : WireData
    {
        public ulong      qwBuddyID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbNickname;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbNickname")]
        public byte[]     rgbNickName;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            cbNickname = (rgbNickName == null) ? (ushort)0 : (ushort)rgbNickName.Length;
            cbTitleStuff = (rgbTitleStuff == null) ? (ushort)0 : (ushort)rgbTitleStuff.Length;
            
            // sizeof( PresenceItem ) + cbNickname + cbTitleStuff
            return 28 + cbNickname + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE
    //
    public class InvitationItem : WireData
    {
        public ulong      qwHostID;
        public ulong      qwMatchSessionID;
        public uint       dwTitleID;
        public ulong      ftSent;

        public override int Size()
        {
            // sizeof( InvitationItem ) 
            return 28;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE_ANSWER
    //
    public class InvitationAnswerItem : WireData   
    {
        public ulong      qwInviteeID;
        public ulong      qwMatchSessionID;
        public ulong      ftSent;
        public ushort     wAnswer;

        public override int Size()
        {
            // sizeof( InvitationAnswerItem ) 
            return 26;
        }        
    };


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PEER_PRESENCE
    //
    public class PeerPresenceItem : WireData
    {
        public ulong      qwUserID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            cbTitleStuff = (rgbTitleStuff == null) ? (ushort)0 : (ushort)rgbTitleStuff.Length;

            // sizeof( PeerPresenceItem ) + cbTitleStuff
            return 26 + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE_2
    //
    public class Presence2Item : WireData
    {
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             dwState;
        public ulong            qwMatchSessionID;
        public uint             mtUserTime;
        
        public ushort           cbRichPresence;
        public ushort           cbrpData;

        [WireInfo(SizeParam="cbRichPresence")]
        public string           szRichPresence;        
        
        [WireInfo(SizeParam="cbData", Serialize=false)]
        public RichPresence     rpData;

        public override int Size()
        {
            cbRichPresence = (szRichPresence == null) ? (ushort)0 : (ushort)Encoding.UTF8.GetByteCount(szRichPresence);
            cbrpData = (ushort)rpData.Size();
            
            // sizeof( Presence2Item ) + cbRichPresence + cbData
            return 32 + cbRichPresence + rpData.Size();
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                mtUserTime = binaryReader.ReadUInt32();
                cbRichPresence = binaryReader.ReadUInt16();
                cbrpData = binaryReader.ReadUInt16();
                byte[] byteString = binaryReader.ReadBytes(cbRichPresence);
                szRichPresence = new UTF8Encoding().GetString(byteString);

                if (cbrpData > 0)
                {
                    rpData = new RichPresence();
                    rpData.ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_21, 
                    "Reached end of stream trying to read Presence2Item", e);
            }

            return this;
        }        

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // Implement a little trickery. To the client, rgbData is an array of bytes with 
            //  cbData as the SizeParam. Set the size properly here since WireData won't
            if (null != rpData)
            {
                cbrpData = (ushort)rpData.Size();
            }
            else
            {
                cbrpData = 0;
            }

            byte[] b;
            if (szRichPresence != null)
            {
                b = new UTF8Encoding().GetBytes(szRichPresence);
            }
            else
            {
                b = new byte[0];
            }

            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(mtUserTime);

            // fixup cbRichPresence before we write it
            cbRichPresence = (ushort)b.Length;

            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbrpData);
            if (szRichPresence != null)
            {
                binaryWriter.Write(b);
            }

        }
    };

    //
    // Structure representing a single list item in a dequeue response
    //  maps to Q_LIST_ITEM in STF.x
    //
    public class NotificationListItem : WireData
    {
        public uint             dwItemID;
        public ushort           wItemLen;
 
        [WireInfo(SizeParam="wItemLen")]
        public byte[]           rgbItemData;

        public override int Size()
        {
            // Get the correct sizes before we use them
            wItemLen = null == rgbItemData ? (ushort) 0 : (ushort) rgbItemData.Length;

            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 6 + wItemLen;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwItemID = binaryReader.ReadUInt32();
                wItemLen = binaryReader.ReadUInt16();
                rgbItemData = binaryReader.ReadBytes(wItemLen);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_22, 
                    "Reached end of stream trying to read NotificationListItem", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            wItemLen = rgbItemData == null? (ushort)0 : (ushort)rgbItemData.Length;

            binaryWriter.Write(dwItemID);
            binaryWriter.Write(wItemLen);
            binaryWriter.Write(rgbItemData);
        }

    }
    
    //
    // Structure representing reply to a request to dequeue notification items on behalf of a user
    //  maps to Q_LIST_REPLY_MSG in STF.x
    //  
    public class NotificationDequeueReply : XRLObject2
    {
        public NotificationDequeueReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public HResult          hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }

    }

    public class NotificationDequeueReply2 : XRLObject2
    {
        public NotificationDequeueReply2()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public HResult          hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            // we continue to use Q_LIST_REPLY_MSG size rather than Q_LIST_REPLY_2 size, so that writestream serializes this the same way.
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_PRESENCE_LOCALE_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szLocale = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szLocale = s;
                }
                else
                {
                    szLocale = null;
                }                
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        // write stream does not include the szLocale field.  szLocale is an internal only field.
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }
    }

    public class PurgeUserRequest : PresenceXrlObject
    {
        public PurgeUserRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }
    
    public class PurgeUserResponse : PresenceXrlObject
    {
        public PurgeUserResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;
                
        public override int Size()
        {
            return header.Size() + 20;
        }        
    }
    
    public class WebAliveRequest : PresenceXrlObject
    {
        public WebAliveRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }
    
    public class WebAliveResponse : PresenceXrlObject
    {
        public WebAliveResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 12;
        }        
    }

    public class WebAlive2Request : PresenceXrlObject
    {
        public WebAlive2Request()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE2, this);
        }

        public BaseHeader header;
        public ulong puid;
        public uint titleId;

        public override int Size()
        {
            return header.Size() + 12;
        }
    }

    public class WebFriendsRequest : PresenceXrlObject
    {
        public WebFriendsRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }    
    
    public class WebFriendsResponse : PresenceXrlObject
    {
        public WebFriendsResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public WebFriendsData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class WebFriendsData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;

            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }

    public class GetFriendsLimitedPresenceRequest : PresenceXrlObject
    {
        public GetFriendsLimitedPresenceRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }    
    
    public class GetFriendsLimitedPresenceResponse : PresenceXrlObject
    {
        public GetFriendsLimitedPresenceResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint cdwFriends;
        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsLimitedPresenceData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }

            return header.Size() + 16 + cbFriends;
        }        
    }
    
    public class GetFriendsLimitedPresenceData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastSeen;
        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;
        public override int Size()
        {
            return 24 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }
    }

    public class GetFriendsNoPresenceRequest : PresenceXrlObject
    {
        public GetFriendsNoPresenceRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }

    public class GetFriendsNoPresenceResponse : PresenceXrlObject
    {
        public GetFriendsNoPresenceResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsNoPresenceData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 16 + cbFriends;
        }        
    }

    public class GetFriendsNoPresenceData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public override int Size()
        {
            return 12;
        }
    }

    public class GetFriendsListRequest : PresenceXrlObject
    {
        public GetFriendsListRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST, this);
        }
        
        public BaseHeader header;
        public ulong qwSender;
        public ulong qwTarget;
        
        
        public override int Size()
        {
            return header.Size() + 16;
        }        
    }    
    
    public class GetFriendsListResponse : PresenceXrlObject
    {
        public GetFriendsListResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsListData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;

            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class GetFriendsListData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;
            
            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
                
    public class GetPresenceInfoRequest : PresenceXrlObject
    {
        public GetPresenceInfoRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_PRESENCE_INFO, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public ulong[] rgUsers;        
        
        public override int Size()
        {
            cdwUsers = (rgUsers == null) ? 0 : (uint)rgUsers.Length;
            
            return header.Size() + 16 + ((int)cdwUsers * 8);
        }        
    }    
    
    public class PresenceInfoResponse : PresenceXrlObject
    {
        public PresenceInfoResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PRESENCE_INFO_REPLY, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public PresenceInfoData[] rgUsers;        
        
        public override int Size()
        {
            cdwUsers = (rgUsers == null) ? 0 : (uint)rgUsers.Length;

            int cbUsers = 0;
            for (int iUser = 0; iUser < cdwUsers; iUser++)
            {
                cbUsers += rgUsers[iUser].Size();
            }
            
            return header.Size() + 16 + cbUsers;
        }        
    }    
    
    public class PresenceInfoData : PresenceXrlObject
    {
        public ulong Puid;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ulong qwSessionID;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;

            return 50 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
        
    //
    // Structure representing a request to invalidate a user's cached data
    //  maps to PMSG_INVALIDATE_USER
    //
    public class InvalidateUserMsg : PresenceXrlObject
    {
        public InvalidateUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVALIDATE_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( InvalidateUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION
    //
    public class PeerSessionMsg : PresenceXrlObject
    {
        public PeerSessionMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;       

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION_REPLY
    //
    public class PeerSessionReplyMsg : PresenceXrlObject
    {
        public PeerSessionReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION_REPLY, this );
        }

        public BaseHeader       header;

        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;

        public XNADDR xnaddr;
        [WireInfo(ArraySize=8)]
        public byte[] xkid;
        [WireInfo(ArraySize=16)]
        public byte[] xnkey;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionReplyMsg )
            return 32 + 12 + 36 + 8 + 16;
        }        
    }


    //
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUserMsg : PresenceXrlObject
    {
        public FindUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER, this );
        }

        public BaseHeader       header;
        
        public ulong            qwUserID;       // User making the request

        public ulong            qwFindID;       // User to be found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag to be found

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 16 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUserReplyMsg : PresenceXrlObject
    {
        public FindUserReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER_REPLY, this );
        }

        public BaseHeader       header;
        
        public ulong            qwFoundID;      // User found - 0 if not found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag found - only valid if qwUserID is not 0

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 8 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    public class FindUsersData : PresenceXrlObject
    {
        public ulong qwUserID;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        public override int Size()
        {
            return 24;
        }        
    }
    
    //
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUsersMsg : PresenceXrlObject
    {
        public FindUsersMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
        }
        
        public FindUsersMsg(uint cdwQueries)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
            this.cdwQueries = cdwQueries;
            rgQueries = new FindUsersData[cdwQueries];
        }

        public BaseHeader header;
        
        public ulong qwUserID;       // User making the request

        [WireInfo(Min=1, Max=PresDefs.MAX_FIND_USERS_REQUESTS)]
        public uint cdwQueries;

        [WireInfo(SizeParam="cdwQueries")]
        public FindUsersData[] rgQueries;

        public override int Size()
        {
            cdwQueries = (rgQueries == null) ? 0 : (uint)rgQueries.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUsersMsg ) + ( cdwQueries * sizeof( FindUsersData ) )
            return 32 + 12 + (24 * (int)cdwQueries);
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUsersReplyMsg : PresenceXrlObject
    {
        public FindUsersReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
        }
        
        public FindUsersReplyMsg(uint cdwResults)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
            this.cdwResults = cdwResults;
            rgResults = new FindUsersData[cdwResults];
        }

        public BaseHeader       header;

        public uint cdwResults;
        
        [WireInfo(SizeParam="cdwResults")]
        public FindUsersData[] rgResults;

        public override int Size()
        {
            cdwResults = (rgResults == null) ? 0 : (uint)rgResults.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg ) + ( cdwResults * sizeof( FindUsersData ) )
            return 32 + 4 + (24 * (int)cdwResults);
        }        
    }

    //
    // Structure representing a request to ick a user off the system
    //  maps to PMSG_KICK
    //
    public class KickMsg : PresenceXrlObject
    {
        public BaseHeader  header;
        public ulong       qwUserID;
        public uint        fFlushTickets;

        public KickMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_KICK, this );
        }

        public override int Size()
        {
            return header.Size() + 12;
        }
    }
    

} // namespace XBOX.Online.Protocol.Presence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\RWLock.cs ===
using System;
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

namespace STF.common.service
{
    // IDisposable wrapper for RWLock
    public class RWLockHandle : IDisposable
    {
        public RWLockHandle(RWLock rwLock)
        {
            m_rwLock = rwLock;
            m_rwLock.ReadLock();
        }

        public void UpgradeToWriter()
        {
            // do we already have the write lock?
            if (IsWriter())
            {
                return;
            }

            // drop the read lock, get the write lock.  yes, this means another writer could sneak in here.
            // we have to drop the reader lock, or else there's no way for other writers to succeed.  consider the case where two
            // simultaneous readers both call upgrade.  both upgraders will be stuck waiting for the other to release the reader lock.
            m_rwLock.ReadUnlock();
            m_rwLock.WriteLock();

            // mark that we have the write lock.
            m_fWriteLock = true;
        }

        public bool IsWriter()
        {
            return m_fWriteLock;
        }

        public void Dispose()
        {
            if (m_fWriteLock)
            {
                m_rwLock.WriteUnlock();
            }
            else
            {
                m_rwLock.ReadUnlock();
            }
        }

        protected bool m_fWriteLock;
        protected RWLock m_rwLock;
    }
    
    public class RWLock
    {
        public RWLock()
        {
            m_evtWriter = new ManualResetEvent(false);
        }
        
        public void ReadLock()
        {
            // declare a new reader.
            Interlocked.Increment(ref m_cReaders);

            // check to see if a writer has annouced himself.
            while (m_fWriter)
            {
                // a pending writer exists.  remove ourselves from the reader count and block.
                Interlocked.Decrement(ref m_cReaders);
                m_evtWriter.WaitOne();

                // woke up again.  declare a new reader again and start over.
                Interlocked.Increment(ref m_cReaders);
            }
        }

        public void ReadUnlock()
        {
            // remove the reader.
            Interlocked.Decrement(ref m_cReaders);
        }

        public void WriteLock()
        {
            while (true)
            {
                // lock the write internals.
                lock (this)
                {
                    // check for an existing pending writer
                    if (!m_fWriter)
                    {
                        // none found.  we are the next writer.  set the pending flag and block the event.
                        m_fWriter = true;
                        m_evtWriter.Reset();
                        break;
                    }
                }

                // a previous writer is still active.  we have to wait and try again.
                m_evtWriter.WaitOne();
            }

            // we're scheduled to write.  wait for all the existing readers to exit.                
            while (m_cReaders > 0)
            {
                Thread.Sleep(0);
            }
        }

        public void WriteUnlock()
        {
            // lock the write internals.
            lock (this)
            {
                // clear the writer flag and wake up the event.
                m_fWriter = false;
                m_evtWriter.Set();
            }
        }

        protected volatile int m_cReaders;
        protected volatile bool m_fWriter;
        protected ManualResetEvent m_evtWriter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\RsaPublicKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace STF.common.service
{
    [ComVisible(false)]
    public class RsaPublicKey : IDisposable
    {
        private RSACryptoServiceProvider _csp = new RSACryptoServiceProvider();
        private int _keyVersion;

        public RsaPublicKey(ServiceKeyType keyType)
        {
            ServiceKey serviceKey = ServiceKey.GetLatest(keyType);

            _keyVersion = serviceKey.KeyVersion;
            _csp.ImportCspBlob(serviceKey.Key);
        }

        public RsaPublicKey(ServiceKeyType keyType, int keyVersion)
        {
            ServiceKey serviceKey = ServiceKey.Get(keyType, keyVersion);

            _keyVersion = serviceKey.KeyVersion;
            _csp.ImportCspBlob(serviceKey.Key);
        }

        public RsaPublicKey(int keyVersion, byte[] cspBlob)
        {
            _keyVersion = keyVersion;
            _csp.ImportCspBlob(cspBlob);
        }

        public byte[] Encrypt(byte[] buffer)
        {
            return _csp.Encrypt(buffer, false);
        }

        public int KeyVersion
        {
            get { return _keyVersion; }
        }

        public void  Dispose()
        {
            _csp.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SerializableDictionary.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;

namespace STF.common.utilities2
{
    #region SerializableDictionary

    // --------------------------------------------------------------------------------------
    // SerializableDictionary
    //
    // Basic generic Dictionary<,> that can be used with XmlSerialize. Borrowed from 
    // http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
    // --------------------------------------------------------------------------------------
    public class SerializableDictionary<TKey, TValue>
        : Dictionary<TKey, TValue>, IXmlSerializable
    {
        public SerializableDictionary()
            : base()
        {
        }

        public SerializableDictionary(IEqualityComparer<TKey> comparer)
            : base(comparer)
        {
        }

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(System.Xml.XmlReader reader)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            bool wasEmpty = reader.IsEmptyElement;
            reader.Read();

            if (wasEmpty)
                return;

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                reader.ReadStartElement("item");

                reader.ReadStartElement("key");
                TKey key = (TKey)keySerializer.Deserialize(reader);
                reader.ReadEndElement();

                reader.ReadStartElement("value");
                TValue value = (TValue)valueSerializer.Deserialize(reader);
                reader.ReadEndElement();

                this.Add(key, value);

                reader.ReadEndElement();
                reader.MoveToContent();
            }
            reader.ReadEndElement();
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            foreach (TKey key in this.Keys)
            {
                writer.WriteStartElement("item");

                writer.WriteStartElement("key");
                keySerializer.Serialize(writer, key);
                writer.WriteEndElement();

                writer.WriteStartElement("value");
                TValue value = this[key];
                valueSerializer.Serialize(writer, value);
                writer.WriteEndElement();

                writer.WriteEndElement();
            }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ServiceKey.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using STF.common.config;
using STF.common.exceptions;
using STF.common.mgmt;

namespace STF.common.service
{
    public class ServiceKey
    {
        private ServiceKeyType _keyType;
        private int            _keyVersion;
        private int            _masterKeyVersion;
        private int?           _siteId;
        private int?           _lifetime;
        private string         _serviceData1;
        private string         _serviceData2;

        private byte[]         _key;
        private Exception      _e;

        private ServiceKey(ServiceKeyType keyType, int keyVersion, int masterKeyVersion, byte[] key)
        {
            _keyType          = keyType;
            _keyVersion       = keyVersion;
            _masterKeyVersion = masterKeyVersion;
            _key              = key;
        }

        private ServiceKey(ServiceKeyType keyType, int keyVersion, int masterKeyVersion, Exception e)
        {
            _keyType          = keyType;
            _keyVersion       = keyVersion;
            _masterKeyVersion = masterKeyVersion;
            _e                = e;
        }

        // all the key fields have only private setters

        public ServiceKeyType KeyType
        {
            get { return _keyType; }
            private set { _keyType = value; }
        }

        public string ServiceData1
        {
            get { return _serviceData1; }
            private set { _serviceData1 = value; }
        }

        public string ServiceData2
        {
            get { return _serviceData2; }
            private set { _serviceData2 = value; }
        }

        public int KeyVersion
        {
            get { return _keyVersion; }
            private set { _keyVersion = value; }
        }

        public int MasterKeyVersion
        {
            get { return _masterKeyVersion; }
        }

        public byte[] Key
        {
            get { return _key; }
        }

        public int? Lifetime
        {
            get { return _lifetime; }
            set { _lifetime = value; }
        }

        public int? SiteId
        {
            get { return _siteId; }
            set { _siteId = value; }
        }

        private Exception Exception
        {
            get { return _e; }
        }

        internal void Save()
        {
            string connectionString = Config.NpdbConnectionString;
            byte[] encryptedKey = MasterKey.Encrypt(_masterKeyVersion, _key);

            try
            {
                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    using (SqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = "p_service_keys_set";
                        command.CommandType = CommandType.StoredProcedure;

                        command.Parameters.Add("@i_key_type", SqlDbType.Int).Value           = (int) _keyType;
                        command.Parameters.Add("@i_key_version", SqlDbType.Int).Value        = _keyVersion;
                        command.Parameters.Add("@i_master_key_version", SqlDbType.Int).Value = _masterKeyVersion;
                        command.Parameters.Add("@i_site_id", SqlDbType.Int).Value            = _siteId;
                        command.Parameters.Add("@i_service_data1", SqlDbType.VarChar).Value  = _serviceData1;
                        command.Parameters.Add("@i_service_data2", SqlDbType.VarChar).Value  = _serviceData2;
                        command.Parameters.Add("@bin_key", SqlDbType.Binary).Value           = encryptedKey;

                        connection.Open();
                        command.ExecuteNonQuery();
                    }
                }
            }

            catch (Exception e)
            {
                // everything thrown from the try block above will be
                // a sql or runtime exception. it needs to be wrapped
                
                throw new XRLException(
                    XRLException.ToHResult(e, HResult.XONLINE_E_DATABASE_ERROR), XEvent.Id.SERVICE_KEY_SAVE_ERROR,
                    string.Format("Error saving service key, keyType = {0}, keyVersion = {1}", _keyType, _keyVersion), e
                );
            }
        }

        public override string ToString()
        {
            return GetHashKey(_keyType, _keyVersion);
        }


#region static
        private static Hashtable _cache = null;

        static ServiceKey()
        {
            Config.ServiceKeysChange += new ServiceKeysChangeEventHandler(OnServiceKeysChange);
        }

        private static void OnServiceKeysChange(object sender, EventArgs e)
        {
            _cache = null;
        }

        public static ServiceKey Get(ServiceKeyType keyType, int keyVersion)
        {
            string serviceKeyHash = GetHashKey(keyType, keyVersion);
            ServiceKey serviceKey = (ServiceKey) Cache[serviceKeyHash];

            // the cache contains both valid and invalid keys.  if the key is
            // invalid (then throw the exception explaining why it is invalid)

            if (serviceKey != null)
            {
                if (serviceKey.Exception == null)
                {
                    return serviceKey;
                }

                throw new XblException(
                    HResult.XONLINE_E_SERVICE_KEY_ERROR, serviceKey.Exception, "Error getting service key, type = {0}, version = {1}", keyType, keyVersion
                );
            }

            // if we get here, then there was no entry in the cache  at  all

            throw new XRLException(
                HResult.XONLINE_E_SERVICE_KEY_NOT_FOUND, XEvent.Id.SERVICE_KEY_NOT_FOUND,
                string.Format("Service key not found, keyType = {0} ({1}), keyVersion = {2}", keyType, (int) keyType, keyVersion)
            );
        }

        public static ServiceKey GetLatest(ServiceKeyType keyType)
        {
            return Get(keyType, int.MaxValue);
        }

        private static Hashtable Cache
        {
            get
            {
                Hashtable cache = _cache;
                if (cache != null) return cache;

                lock (typeof(ServiceKey))
                {
                    cache = _cache;
                    if (cache != null) return cache;

                    cache = new Hashtable();

                    try
                    {
                        using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
                        {
                            using (SqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = "p_service_keys_get";
                                command.CommandType = CommandType.StoredProcedure;

                                connection.Open();

                                using (SqlDataReader reader = command.ExecuteReader())
                                {
                                    int siteIdOrdinal   = reader.GetOrdinal("i_site_id");
                                    int lifetimeOrdinal = reader.GetOrdinal("i_ticket_lifetime_secs");

                                    while (reader.Read()) 
                                    {
                                        // figure out how many bytes  are  in  the  key
                                        // allocate a buffer and read the encrypted key

                                        int ordinal = reader.GetOrdinal("bin_key");
                                        byte[] encryptedBytes = new byte[reader.GetBytes(ordinal, 0, null, 0, 0)];
                                        reader.GetBytes(ordinal, 0, encryptedBytes, 0, encryptedBytes.Length);

                                        // instantiate a new service key  objects  with
                                        // the key fields, then fill  in  other  fields

                                        ServiceKey serviceKey = null;
                                        ServiceKeyType keyType = (ServiceKeyType) reader["i_key_type"];
                                        int keyVersion = (int) reader["i_key_version"];
                                        int masterKeyVersion = (int)reader["i_master_key_version"];

                                        try
                                        {
                                            serviceKey = new ServiceKey(
                                                keyType, keyVersion, masterKeyVersion, MasterKey.Decrypt(masterKeyVersion, encryptedBytes)
                                            );
                                        }
                                        catch (Exception e)
                                        {
                                            Xom.NtEvent(XEvent.Id.SERVICE_KEY_LOAD_ERROR, e,
                                                "Error loading service key, keyType = {0} ({1}), keyVersion = {2}", keyType, (int)keyType, keyVersion
                                            );

                                            // create a poisoned key that will throw an
                                            // exception when someone tries to  get  it

                                            serviceKey = new ServiceKey(keyType, keyVersion, masterKeyVersion, e);
                                        }

                                        // get other key data - even if key is poisoned

                                        serviceKey.ServiceData1 = (string) reader["vc_service_data1"];
                                        serviceKey.ServiceData2 = (string) reader["vc_service_data2"];

                                        // special handling for fields with null values

                                        if (! reader.IsDBNull(siteIdOrdinal))   serviceKey.SiteId   = reader.GetInt32(siteIdOrdinal);
                                        if (! reader.IsDBNull(lifetimeOrdinal)) serviceKey.Lifetime = reader.GetInt32(lifetimeOrdinal);

                                        // add key to cache using a hash key  comprised
                                        // derived from the key type  and  key  version

                                        string serviceKeyHash = GetHashKey(serviceKey);
                                        cache[serviceKeyHash] = serviceKey;

                                        // then check if the latest key exists  and  if
                                        // this version exceeds the version of that one

                                        string latestKeyHash = GetHashKey(serviceKey.KeyType, int.MaxValue);
                                        ServiceKey latestKey = (ServiceKey) cache[latestKeyHash];

                                        if ((latestKey == null) || (serviceKey.KeyVersion > latestKey.KeyVersion))
                                        {
                                            cache[latestKeyHash] = serviceKey;
                                        }
                                    }
                                } // using
                            } // using
                        } // using
                    } // try

                    catch (Exception e)
                    {
                        throw new XRLException(
                            XRLException.ToHResult(e, HResult.XONLINE_E_DATABASE_ERROR),
                            XEvent.Id.SERVICE_KEY_LOAD_ERROR, e, "Error loading service key cache"
                        );
                    }  // catch

                    return _cache = cache;
                } // lock
            }
        }

        private static string GetHashKey(ServiceKey serviceKey)
        {
            return GetHashKey(serviceKey.KeyType, serviceKey.KeyVersion);
        }

        private static string GetHashKey(ServiceKeyType keyType, int keyVersion)
        {
            return ((int) keyType).ToString() + "." + keyVersion.ToString();
        }
        
#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\RsaPrivateKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace STF.common.service
{
    [ComVisible(false)]
    public class RsaPrivateKey : IDisposable
    {
        private RSACryptoServiceProvider _csp = new RSACryptoServiceProvider();

        public RsaPrivateKey(ServiceKeyType keyType) {
            Init(ServiceKey.GetLatest(keyType));
        }

        public RsaPrivateKey(ServiceKeyType keyType, int keyVersion) {
            Init(ServiceKey.Get(keyType, keyVersion));
        }

        private void Init(ServiceKey serviceKey)
        {
            try {
                _csp.ImportCspBlob(serviceKey.Key);
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_SERVICE_KEY_IMPORT_ERROR, XEvent.Id.SERVICE_KEY_IMPORT_ERROR,
                    "Error importing service key, keyType = " + ((int) serviceKey.KeyType) +
                    ", keyVersion = " + serviceKey.KeyVersion, e
                );
            }
        }

        public byte[] Decrypt(byte[] buffer)
        {
            return _csp.Decrypt(buffer, false);
        }

        public void  Dispose()
        {
            _csp.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ServiceKeyType.cs ===
namespace STF.common.service
{
    public enum ServiceKeyType
    {
        KDC_PASSPORT_NET         = 1,
        KDC_XBOX_COM             = 2,
        PASSPORT_DELADMIN        = 3,
        BILLING                  = 4,
        KEY_ENCRYPTION_KEY       = 5,
        SECURITY_GATEWAY         = 6,
        SIGNATURE_SERVER         = 7,
        WMDRM_GROUP_PRIVATE_KEY  = 8,
        KDC_ECHO_DATA            = 9,
        WMRM_EMS_SEED_ID         = 10,
        WMRM_SYNCCAST_AES_KEY    = 11,
        WIREDATA_PRIVATE_KEY     = 12,
        WIREDATA_PUBLIC_KEY      = 13,
        SECP_DB_PRIVATE_KEY      = 14,
        SECP_DB_PUBLIC_KEY       = 15,
        TOKEN_KEY_ENCRYPTION_KEY = 16,
        PLAYREADY_XBOX360_MODEL_PRIVATE_KEY = 17,
        XAUTHDATA_SIGNING_KEY    = 18,
        MUSICNET_AES_KEY         = 20,
        TESTONLY_XKEYMGR         = 999
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\HResult.cs ===
//
// HResult.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Managed HResult class, and constant HResult definitions
// used within Xbox Live.
//

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace STF.common.service
{

    // list of services as defined in STF.x
    [ComVisible(false)]
    public enum XOService
    {
        InvalidService    = 0,
        PresNotification  = 1,
        StringService     = 2,
        Auto_Update       = 3,
        Base_Subscription = 4,
        User_Account      = 5,
        Matchmaking       = 6,
        Stats             = 7,
        Feedback          = 8,
        Billing_Offering  = 9,
        Lists             = 10,
        Tou               = 11,
        Signature_Server  = 12,
        Query             = 13,
        Name_Resolution   = 14,
        Storage           = 15,
        Arbitration       = 16,
        Cron              = 17,
        MessagingService  = 18,
        Teams             = 19,
        NatDetection      = 20,
        DRM               = 21,
        Massive           = 22,
        PCLocator         = 23,
        Crypto            = 24,
        Liveinfo          = 25,
        Connection_Server = 26,
        Ratings           = 27,
        TestFD            = 28,
        Sts               = 29,
        Reflector         = 30,
        SocialQuery       = 31,
        Vortex            = 32,
        XSts              = 33,
        Profile           = 34,
        Progress          = 35,
        MaxService        = 35      // update this const while adding new services
    }

    /// <summary>
    /// Constants required for Win32 Error conversion to Hresults.
    /// Add new constants required for Win32 errors here.
    /// </summary>
    [ComVisible(false)]
    public static class Win32ErrorCode
    {
        /// <summary>
        /// Picked up from winerror.h in the platform sdk
        /// </summary>
        ///
        public enum Codes
        {
        ERROR_USER_EXISTS = 1316,
        ERROR_NO_SUCH_USER = 1317
        }

        private const uint WIN32_FACILITY_PREFIX = 0x80070000;

        public static HResult GetHResult(Codes code)
        {
            return GetHResult((int)code);
        }

        /// <summary>
        /// Keep this private for now since it takes any uint
        /// Be mindful that during the int to uint promotion for less than zero values
        /// a simple conversion to HResult may lead to FACILITY_NULL in most cases.
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        private static HResult GetHResult(int code)
        {
            return ( code < 0 ? ((uint)code) : (uint)(WIN32_FACILITY_PREFIX | ((uint)code & 0x0000ffff)) );
        }

        static Win32ErrorCode()
        {
            HResult.AddConstsAsHResults(typeof(Codes), o => GetHResult((int)o));
        }
    }

    public partial struct HResult : IEquatable<HResult>, IXmlSerializable
    {
        //
        //
        // NOTE: These defines should be a superset of everything defined in XONLINE.X which are exposed to the client
        //
        //


        //
        // standard HRESULTS
        //
        public const uint S_OK                      = 0x0;
        public const uint S_FALSE                   = 0x1;
        public const uint E_FAIL                    = 0x80004005;
        public const uint E_INVALIDARG              = 0x80070057;
        public const uint E_ABORT                   = 0x80004004;
        public const uint E_INVALID_DATA            = 0x8007000D;
        public const uint E_OUTOFMEMORY             = 0x8007000E;
        public const uint E_ACCESSDENIED            = 0x80070005;
        public const uint E_UNEXPECTED              = 0x8000FFFF;

        //
        // XOnline facility-wide HRESULTS                                            = 0x80150XXX
        //
        public const uint XONLINE_E_OVERFLOW                                         = 0x80150001;
        public const uint XONLINE_E_NO_SESSION                                       = 0x80150002;
        public const uint XONLINE_E_USER_NOT_LOGGED_ON                               = 0x80150003;
        public const uint XONLINE_E_NO_GUEST_ACCESS                                  = 0x80150004;
        public const uint XONLINE_E_NOT_INITIALIZED                                  = 0x80150005;
        public const uint XONLINE_E_NO_USER                                          = 0x80150006;
        public const uint XONLINE_E_INTERNAL_ERROR                                   = 0x80150007;
        public const uint XONLINE_E_OUT_OF_MEMORY                                    = 0x80150008;
        public const uint XONLINE_E_TASK_BUSY                                        = 0x80150009;
        public const uint XONLINE_E_SERVER_ERROR                                     = 0x8015000A;
        public const uint XONLINE_E_IO_ERROR                                         = 0x8015000B;
        public const uint XONLINE_E_BAD_CONTENT_TYPE                                 = 0x8015000C;
        public const uint XONLINE_E_USER_NOT_PRESENT                                 = 0x8015000D;
        public const uint XONLINE_E_PROTOCOL_MISMATCH                                = 0x8015000E;
        public const uint XONLINE_E_INVALID_SERVICE_ID                               = 0x8015000F;
        public const uint XONLINE_E_INVALID_REQUEST                                  = 0x80150010;
        public const uint XONLINE_E_TASK_THROTTLED                                   = 0x80150011;
        public const uint XONLINE_E_TASK_ABORTED_BY_DUPLICATE                        = 0x80150012;
        public const uint XONLINE_E_INVALID_TITLE_ID                                 = 0x80150013;
        public const uint XONLINE_E_SERVER_CONFIG_ERROR                              = 0x80150014;
        public const uint XONLINE_E_END_OF_STREAM                                    = 0x80150015;
        public const uint XONLINE_E_ACCESS_DENIED                                    = 0x80150016;
        public const uint XONLINE_E_GEO_DENIED                                       = 0x80150017;
        public const uint XONLINE_E_UNSUPPORTED_METHOD                               = 0x80150018; // XRL has wiredata request for an old/deprecated API-call received from new flash/client (or viceversa)
        public const uint XONLINE_E_RESOURCE_UNAVAILABLE                             = 0x80150019; // FastFail blocked the call
        public const uint XONLINE_E_AUTHDATA_MISMATCH                                = 0x80150020; // values in authdata don't match those in request
        public const uint XONLINE_E_ACCESS_TOKEN_ERROR                               = 0x80150021; // generic AccessToken error
        public const uint XONLINE_E_HEALTH_ERROR                                     = 0x80150022; // non-specific (catch all) health error
        public const uint XONLINE_E_RESPONSE_ERROR                                   = 0x80150023; // non-specific (catch all) response error
        public const uint XONLINE_E_ACTIVE_AUTH_ERROR                                = 0x80150024; // non-specific (catch all) active auth error
        public const uint XONLINE_E_MULTIPLE_USERS                                   = 0x80150025; // received multiple users when only one is expected
        public const uint XONLINE_E_CALL_SOURCE_INVALID                              = 0x80150026;
        public const uint XONLINE_E_DECRYPTION_ERROR                                 = 0x80150027; // error decrypting incoming request
        public const uint XONLINE_E_DESERIALIZATION_ERROR                            = 0x80150028; // error deserializing incoming request
        public const uint XONLINE_E_SERVICE_KEY_ERROR                                = 0x80150029; // error accessing service key (generic, look for inner exception, hr)
        public const uint XONLINE_E_MASTER_KEY_ERROR                                 = 0x80150030; // error accessing master key (generic, look for inner exception, hr)
        public const uint XONLINE_E_USER_NOT_FOUND                                   = 0x80150031; // user not found in t_users 
        public const uint XONLINE_E_MACHINE_NOT_FOUND                                = 0x80150032; // user not found in t_machines 

        //
        // SQL errors of various sorts                                               = 0x801501xx
        //
        public const uint XONLINE_E_DATABASE_ERROR                                   = 0x80150100; // unspecified database error
        public const uint XONLINE_E_DATABASE_EXECUTE_ERROR                           = 0x80150101; // database query failed, typically a sql exception
        public const uint XONLINE_E_DATABASE_RESULT_ERROR                            = 0x80150102; // too many, too few results, or unexpected return value
        public const uint XONLINE_E_DATABASE_TRANSACTION_ERROR                       = 0x80150103; // transaction operation has no transaction
        public const uint XONLINE_E_DATABASE_PARAMETER_NOT_FOUND                     = 0x80150104; // parameter name not found in GetXxxParameter
        public const uint XONLINE_E_DATABASE_DEADLOCK                                = 0x80150105; // sql detected a deadlock and terminated call
        public const uint XONLINE_E_DATABASE_PARAMETER_INVALID                       = 0x80150106; // failed sproc specific parameter validation
        public const uint XONLINE_E_DATABASE_FOREIGN_KEY_VIOLATION                   = 0x80150107; // a SQL operation would have resulted in a foreign key exception
        public const uint XONLINE_E_DATABASE_DUPLICATE_KEY                           = 0x80150108; // duplicate primary or unique key
        public const uint XONLINE_E_DATABASE_TIMEOUT                                 = 0x80150109; // what it says, the query did not response within a specified time

        //
        // XOnlineLogon HRESULTS                                                     = 0x80151XXX
        //
        // Failures from XOnlineLogon                                                = 0x801510XX
        public const uint XONLINE_E_LOGON_NO_NETWORK_CONNECTION                      = 0x80151000;

        // XOnlineLogon task successful return states
        public const uint XONLINE_S_LOGON_CONNECTION_ESTABLISHED                     = 0x001510F0;

        // XOnlineLogon task failure return values
        public const uint XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE                      = 0x80151001;
        public const uint XONLINE_E_LOGON_UPDATE_REQUIRED                            = 0x80151002;
        public const uint XONLINE_E_LOGON_SERVERS_TOO_BUSY                           = 0x80151003;
        public const uint XONLINE_E_LOGON_CONNECTION_LOST                            = 0x80151004;
        public const uint XONLINE_E_LOGON_KICKED_BY_DUPLICATE_LOGON                  = 0x80151005;
        public const uint XONLINE_E_LOGON_INVALID_USER                               = 0x80151006;
        public const uint XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED                      = 0x80151007;
        public const uint XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED                  = 0x80151008;
        public const uint XONLINE_E_LOGON_USER_TITLE_ACTIVATION_REQUIRED             = 0x80151009;
        public const uint XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED                      = 0x8015100A;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_TERMINATED                   = 0x8015100B;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_TIMEDOUT                     = 0x8015100C;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_RESET                        = 0x8015100D;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_FAILED                       = 0x8015100E;
        public const uint XONLINE_E_LOGON_USER_NOT_TRUSTED                           = 0x8015100F;
        public const uint XONLINE_E_LOGON_USER_RPS_EXPIRED                           = 0x80151010;
        public const uint XONLINE_E_LOGON_PPLOGIN_PASSWORD_PROBLEM                   = 0x80151011;
        public const uint XONLINE_E_LOGON_PPLOGIN_VERIFICATION_REQUIRED              = 0x80151012;
        public const uint XONLINE_E_LOGON_USER_UNKNOWN_TRUST                         = 0x80151013;
        public const uint XONLINE_E_LOGON_PPLOGIN_MISMATCH                           = 0x80151014;

        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102A
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102B
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102C
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102D
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102E
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102F
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151030
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151031
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151032

        // Failures from XOnlineSilentLogon
        public const uint XONLINE_E_SILENT_LOGON_DISABLED                            = 0x80151080;
        public const uint XONLINE_E_SILENT_LOGON_NO_ACCOUNTS                         = 0x80151081;
        public const uint XONLINE_E_SILENT_LOGON_PASSCODE_REQUIRED                   = 0x80151082;

        // Service errors after XOnlineLogon task completion                         = 0x801511XX
        public const uint XONLINE_E_LOGON_SERVICE_NOT_REQUESTED                      = 0x80151100;
        public const uint XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED                     = 0x80151101;
        public const uint XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE            = 0x80151102;

        // User warnings after XOnlineLogon task completion                          = 0x801512XX
        public const uint XONLINE_S_LOGON_USER_HAS_MESSAGE                           = 0x001512F0;
        public const uint XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED            = 0x001512F1;

        // User errors after XOnlineLogon task completion
        public const uint XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT           = 0x80151200;

        // XOnlineChangeLogonUsers task successful return states                     = 0x801513XX
        public const uint XONLINE_S_LOGON_COMMIT_USER_CHANGE                         = 0x001513F0;
        public const uint XONLINE_S_LOGON_USER_CHANGE_COMPLETE                       = 0x001513F1;

        // XOnlineChangeLogonUsers task failure return values
        public const uint XONLINE_E_LOGON_CHANGE_USER_FAILED                         = 0x80151300;

        // Other generic auth related errors                                         = 0x801518XX
        public const uint XONLINE_E_LOGON_MU_NOT_MOUNTED                             = 0x80151800;
        public const uint XONLINE_E_LOGON_MU_IO_ERROR                                = 0x80151801;
        public const uint XONLINE_E_LOGON_NOT_LOGGED_ON                              = 0x80151802;


        // XKDC client errors (error codes ranging from 80151901-8015191A)
        public const uint XONLINE_E_LOGON_NO_IP_ADDRESS                              = 0x80151901;
        public const uint XONLINE_E_LOGON_NO_DNS_SERVICE                             = 0x80151902;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_FAILED                          = 0x80151903;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT                        = 0x80151904;
        public const uint XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO                   = 0x80151905;
        public const uint XONLINE_E_LOGON_MACS_FAILED                                = 0x80151906;
        public const uint XONLINE_E_LOGON_MACS_TIMEDOUT                              = 0x80151907;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_FAILED                      = 0x80151908;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT                    = 0x80151909;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_FAILED                       = 0x8015190A;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT                     = 0x8015190B;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID                       = 0x8015190C;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED                        = 0x8015190D;
        public const uint XONLINE_E_LOGON_SG_SERVICE_FAILED                          = 0x8015190E;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED                    = 0x8015190F;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_TIMEDOUT                  = 0x80151910;
        public const uint XONLINE_E_LOGON_TIMEDOUT                                   = 0x80151911;
        public const uint XONLINE_E_LOGON_UNKNOWN_TITLE                              = 0x80151912;
        public const uint XONLINE_E_LOGON_INTERNAL_ERROR                             = 0x80151913;
        public const uint XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED              = 0x80151914;
        public const uint XONLINE_E_LOGON_TGT_REVOKED                                = 0x80151915;
        public const uint XONLINE_E_LOGON_CACHE_MISS                                 = 0x80151916;
        public const uint XONLINE_E_LOGON_NOT_UPNP_NAT                               = 0x80151917;
        public const uint XONLINE_E_LOGON_INCONCLUSIVE_UPNP_NAT                      = 0x80151918;
        public const uint XONLINE_E_LOGON_UPNP_NAT_HARD_FAILURE                      = 0x80151919;
        public const uint XONLINE_E_LOGON_UPNP_PORT_UNAVAILABLE                      = 0x8015191A;
        public const uint XONLINE_E_LOGON_PPLOGIN_OFFLINE                            = 0x8015191B;
        public const uint XONLINE_E_LOGON_KERBEROS_BIND_FAILURE                      = 0x8015191C;
        public const uint XONLINE_E_LOGON_LIVE_PORT_UNAVAILABLE                      = 0x8015191D;
        public const uint XONLINE_E_LOGON_LIVE_PORT_OVERRIDE_UNAVAILABLE             = 0x8015191E;
        public const uint XONLINE_E_LOGON_SG_SERVICE_NIC_MISMATCH                    = 0x8015191F;
        public const uint XONLINE_E_LOGON_WLID_XUID_MISMATCH                         = 0x80151920;
        public const uint XONLINE_E_LOGON_SU_MANIFEST_MISMATCH                       = 0x80151921;
        public const uint XONLINE_E_LOGON_SU_FLASH_MISMATCH                          = 0x80151922;
        public const uint XONLINE_E_LOGON_SYSTEM_UPDATE_REQUIRED                     = 0x80151923;
        public const uint XONLINE_E_LOGON_UPDATE_NOT_PROPPED                         = 0x80151924;
        public const uint XONLINE_E_LOGON_LIVEHIVE_FAILED                            = 0x80151925;
        public const uint XONLINE_E_LOGON_INVALID_CONSOLE_ID                         = 0x80151926;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_TEMP                   = 0x80151927;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_REPAIR                 = 0x80151928;
        public const uint XONLINE_E_LOGON_DUPLICATE_CONSOLE_ID                       = 0x80151929;
        public const uint XONLINE_E_LOGON_MISSING_CONSOLE_ID                         = 0x8015192A;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_TITLE_BANNED                  = 0x8015192B;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_TITLE_BANNED_TEMP             = 0x8015192C;

        //
        // Presence/Notification HRESULTS                                            = 0x801520XX
        //
        public const uint XONLINE_E_NOTIFICATION_ERROR                               = 0x80152000;
        public const uint XONLINE_E_NOTIFICATION_SERVER_BUSY                         = 0x80152001;
        public const uint XONLINE_E_NOTIFICATION_LIST_FULL                           = 0x80152002;
        public const uint XONLINE_E_NOTIFICATION_BLOCKED                             = 0x80152003;
        public const uint XONLINE_E_NOTIFICATION_FRIEND_PENDING                      = 0x80152004;
        public const uint XONLINE_E_NOTIFICATION_FLUSH_TICKETS                       = 0x80152005;
        public const uint XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS                   = 0x80152006;
        public const uint XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS                 = 0x80152007;
        public const uint XONLINE_E_NOTIFICATION_USER_NOT_FOUND                      = 0x80152008;
        public const uint XONLINE_E_NOTIFICATION_OTHER_LIST_FULL                     = 0x80152009;
        public const uint XONLINE_E_NOTIFICATION_SELF                                = 0x8015200A;
        public const uint XONLINE_E_NOTIFICATION_SAME_TITLE                          = 0x8015200B;
        public const uint XONLINE_E_NOTIFICATION_NO_TASK                             = 0x8015200C;
        public const uint XONLINE_E_NOTIFICATION_NO_DATA                             = 0x8015200D;
        public const uint XONLINE_E_NOTIFICATION_NO_PEER_SUBSCRIBE                   = 0x0015200E;
        public const uint XONLINE_E_NOTIFICATION_THREAD_ERROR                        = 0x8015200F; // thread wait timeout
        public const uint XONLINE_E_NOTIFICATION_STATE_ERROR                         = 0x80152010;
        public const uint XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE                   = 0x0015200E;

        //
        // Errors returned by Teams                                                  = 0x801521XX
        //
        public const uint XONLINE_E_TEAMS_SERVER_BUSY                                = 0x80152100;
        public const uint XONLINE_E_TEAMS_TEAM_FULL                                  = 0x80152101;
        public const uint XONLINE_E_TEAMS_MEMBER_PENDING                             = 0x80152102;
        public const uint XONLINE_E_TEAMS_TOO_MANY_REQUESTS                          = 0x80152103;
        public const uint XONLINE_E_TEAMS_USER_ALREADY_EXISTS                        = 0x80152104;
        public const uint XONLINE_E_TEAMS_USER_NOT_FOUND                             = 0x80152105;
        public const uint XONLINE_E_TEAMS_USER_TEAMS_FULL                            = 0x80152106;
        public const uint XONLINE_E_TEAMS_SELF                                       = 0x80152107;
        public const uint XONLINE_E_TEAMS_NO_TASK                                    = 0x80152108;
        public const uint XONLINE_E_TEAMS_TOO_MANY_TEAMS                             = 0x80152109;
        public const uint XONLINE_E_TEAMS_TEAM_ALREADY_EXISTS                        = 0x8015210A;
        public const uint XONLINE_E_TEAMS_TEAM_NOT_FOUND                             = 0x8015210B;
        public const uint XONLINE_E_TEAMS_INSUFFICIENT_PRIVILEGES                    = 0x8015210C;
        public const uint XONLINE_E_TEAMS_NAME_CONTAINS_BAD_WORDS                    = 0x8015210D;
        public const uint XONLINE_E_TEAMS_DESCRIPTION_CONTAINS_BAD_WORDS             = 0x8015210E;
        public const uint XONLINE_E_TEAMS_MOTTO_CONTAINS_BAD_WORDS                   = 0x8015210F;
        public const uint XONLINE_E_TEAMS_URL_CONTAINS_BAD_WORDS                     = 0x80152110;
        public const uint XONLINE_E_TEAMS_NOT_A_MEMBER                               = 0x80152111;
        public const uint XONLINE_E_TEAMS_NO_ADMIN                                   = 0x80152112;

        // errors returned by XUSER                                                  = 0x801522XX
        public const uint XONLINE_E_XUSER_ERROR                                      = 0x80152200;
        public const uint XONLINE_E_XUSER_KEY_NOT_FOUND                              = 0x80152201;
        public const uint XONLINE_E_XUSER_KEY_DECRYPTION_ERROR                       = 0x80152202;

        //
        // XBOS HRESULTS                                                             = 0x801530XX + 0x801531XX
        //
        public const uint XOFF_E_BAD_REQUEST                                         = 0x80153001;
        public const uint XOFF_E_INVALID_USER                                        = 0x80153002;
        public const uint XOFF_E_INVALID_OFFER_ID                                    = 0x80153003;
        public const uint XOFF_E_INELIGIBLE_FOR_OFFER                                = 0x80153004;
        public const uint XOFF_E_OFFER_EXPIRED                                       = 0x80153005;
        public const uint XOFF_E_SERVICE_UNREACHABLE                                 = 0x80153006;
        public const uint XOFF_E_PURCHASE_BLOCKED                                    = 0x80153007;
        public const uint XOFF_E_PURCHASE_DENIED                                     = 0x80153008;
        public const uint XOFF_E_BILLING_SERVER_ERROR                                = 0x80153009;
        public const uint XOFF_E_OFFER_NOT_CANCELABLE                                = 0x8015300A;
        public const uint XOFF_E_NOTHING_TO_CANCEL                                   = 0x8015300B;
        public const uint XOFF_E_ALREADY_OWN_MAX                                     = 0x8015300C;
        public const uint XOFF_E_NO_CHARGE                                           = 0x8015300D;
        public const uint XOFF_E_PERMISSION_DENIED                                   = 0x8015300E;
        public const uint XOFF_E_INVALID_PRODUCT                                     = 0x8015300F;

        public const uint XONLINE_E_BILLING_ERROR                                    = 0x80153000;  // server received incorrectly formatted request
        public const uint XONLINE_E_OFFERING_BAD_REQUEST                             = 0x80153001;  // server received incorrectly formatted request
        public const uint XONLINE_E_OFFERING_INVALID_USER                            = 0x80153002;  // cannot find account for this user
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_ID                        = 0x80153003;  // offer does not exist
        public const uint DEPRECATED_XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER         = 0x80153004;  // )] private /title not allowed to purchase offer
        public const uint XONLINE_E_OFFERING_OFFER_EXPIRED                           = 0x80153005;  // offer no longer available
        public const uint XONLINE_E_OFFERING_SERVICE_UNREACHABLE                     = 0x80153006;  // apparent connectivity problems
        public const uint XONLINE_E_OFFERING_PURCHASE_BLOCKED                        = 0x80153007;  // this user is not allowed to make purchases
        public const uint XONLINE_E_OFFERING_PURCHASE_DENIED                         = 0x80153008;  // this user's payment is denied by billing provider
        public const uint XONLINE_E_OFFERING_BILLING_SERVER_ERROR                    = 0x80153009;  // nonspecific billing provider error
        public const uint XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE                    = 0x8015300A;  // either this offer doesn't exist, or it's marked as un-cancelable
        public const uint XONLINE_E_OFFERING_NOTHING_TO_CANCEL                       = 0x8015300B;  // this user doesn't have one of these anyways
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX                         = 0x8015300C;  // this user already owns the maximum allowed
        public const uint XONLINE_E_OFFERING_NO_CHARGE                               = 0x8015300D;  // this is a free offer; no purchase is necessary
        public const uint XONLINE_E_OFFERING_PERMISSION_DENIED                       = 0x8015300E;  // permission denied
        public const uint XONLINE_E_OFFERING_NAME_TAKEN                              = 0x8015300F;  // Name given to XOnlineVerifyNickname is taken (dosen't vet)
        public const uint XONLINE_E_OFFERING_BASE_OFFER_NOT_CANCELABLE               = 0x80153010;  // Base subscription not cancelable due to dependent subscriptions
        public const uint XONLINE_E_AUTOUPD_MACHINE_BLOCKED                          = 0x80153011;  // No autoupd referrals given because machine puid is blocked
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_TYPE                      = 0x80153012;  // PurchaseSubscription called with non-subscription offer or PurchaseContent called with non-content offer
        public const uint XONLINE_E_OFFERING_INVALID_CONSUME_ITEMS                   = 0x80153013;  // Consume was called with an asset that had insufficient quantity owned by the user.
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_OFFER_TYPE                = 0x80153014;  // A multi purchase was requested, but not all of the offers were of the allowed type for a multi-purchase
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PAYMENT_TYPE              = 0x80153015;  // A multi purchase was requested with an unsupported payment type
        public const uint XONLINE_E_OFFERING_PRICE_CHANGED                           = 0x80153016;  // The client expected a certain price but that price didn't match the server-defined price
        public const uint DEPRECATED_XONLINE_E_OFFERING_NOT_ACQUIRABLE               = 0x80153017;  // A purchase was attempted on a video offer which is currently not Acquirable
        public const uint XONLINE_E_PENDING_POINTS_PURCHASE                          = 0x80153018;  // A points purchase is already pending, and so a new points purchase cannot be started
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_NOT_FOUND                  = 0x80153019;  // User has no subscription for given service component or service id
        public const uint XONLINE_E_OFFERING_UNKNOWN_OFFER_TYPE                      = 0x8015301A;  // Unknown offer type.
        public const uint XONLINE_E_OFFERING_UNKNOWN_PAYMENT_TYPE                    = 0x8015301B;  // Unknown payment type.
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_SOURCE_MACHINE       = 0x8015301C;  // The source machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_DEST_MACHINE         = 0x8015301D;  // The destination machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_S_OTHER_LICENSE_TRANSFER_FAILED         = 0x0015301E;  // Success code indicating that the license transfer succeeded for the calling user, but one or more licenses on the box belonging to other users could not be migrated.
        public const uint XONLINE_S_USER_OWNS_NO_LICENSES                            = 0x0015301F;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_MEDIA_INSTANCE_NOT_ACQUIRABLE                    = 0x80153020;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_PURCHASE_PENDING                                 = 0x80153021;  // The user has a pending purchase transaction already.  Please wait and try again later.
        public const uint XONLINE_E_OFFERING_OFFER_MISCONFIGURED                     = 0x80153022;  // offer exists but is misconfigured in some way
        public const uint XONLINE_E_OFFERING_OFFER_NOT_VISIBLE                       = 0x80153023;  // offer exists but has a visibilityDate in the future
        public const uint XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED            = 0x80153024;  // offer exists but has a visibilityStatusId that does not allow purchase
        public const uint XONLINE_E_OFFERING_GRANTS_NOTHING                          = 0x80153025;  // offer exists but currently grants no mediaInstances, so purchase was blocked
        public const uint XONLINE_E_OFFERING_INVALID_PAYMENT_TYPE                    = 0x80153026;  // offer does not allow the given payment type
        public const uint XONLINE_E_OFFERING_MEDIA_TYPE_MISMATCH                     = 0x80153027;  // offer media type in the catalog does not match the given media type
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PLATFORM_TYPE             = 0x80153028;  // A multi purchase was requested from a platform type that either could not be determed or is unsupported.
        public const uint XONLINE_E_BILLING_NOT_CONNECTED                            = 0x80153029;  // connection to billing system is not configured
        public const uint XONLINE_E_OFFERING_MISSING_RESULTS                         = 0x8015302A;  // expected additional results from sproc
        public const uint XONLINE_E_OFFERING_PAYMENT_INFO_TOO_LONG                   = 0x8015302B;  // length of payment info exceeds width of database columsn
        public const uint XONLINE_E_OFFERING_MIGRATION_ERROR                         = 0x8015302C;  // error migrating xbox1 offer to xenon offer
        public const uint XONLINE_E_GEOFENCING_LOOKUP_ERROR                          = 0x8015302D;  // geofencing returned an exception during lookup
        public const uint XONLINE_E_GEOFENCING_RETURNED_NULL                         = 0x8015302E;  // returned null from IP lookup
        public const uint XONLINE_E_OFFERING_VERIFY_TOKEN_ERROR                      = 0x8015302F;  // exception while verifying token
        public const uint XONLINE_E_BILLING_USER_QUEUED                              = 0x80153030;  // operation not allowed because user is queued
        public const uint XONLINE_E_BILLING_KEY_NOT_FOUND                            = 0x80153031;  // billing provider key is not configured
        public const uint XONLINE_E_BILLING_COUNTRY_ID_NOT_FOUND                     = 0x80153032;  // invalid country id
        public const uint XONLINE_E_BILLING_LOCALE_NOT_FOUND                         = 0x80153033;  // locale not found
        public const uint XONLINE_E_BILLING_QUEUED_ACCOUNT_NOT_FOUND                 = 0x80153034;  // error loading billing queue item
        public const uint XONLINE_E_OFFERING_AUTOUPD_ERROR                           = 0x80153035;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_BANNER_LIST_ERROR                       = 0x80153036;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_AVAILABLE_ERROR                 = 0x80153037;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_DETAILS_ERROR                   = 0x80153038;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_ENUMERATE_ERROR                 = 0x80153039;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_HISTORY_ERROR                   = 0x8015303A;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_REFERRAL_ERROR                  = 0x8015303B;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_UPDATE_ERROR                    = 0x8015303C;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ENUMERATE_GENRES_ERROR                  = 0x8015303D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ENUMERATE_TITLES_ERROR                  = 0x8015303E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_FIND_MEDIA_INSTANCE_URLS_ERROR          = 0x8015303F;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_TITLE_ACTIVATION_ERROR              = 0x80153040;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_TITLE_DETAILS_ERROR                 = 0x80153041;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_IN_GAME_CONTENT_AVAILABLE_ERROR         = 0x80153042;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_IN_GAME_CONTENT_ENUMERATE_ERROR         = 0x80153043;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_DETAILS_ERROR                           = 0x80153044;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_DETAILS_NO_USER_ERROR                   = 0x80153045;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_DETAILS_ERROR              = 0x80153046;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CANCEL_ERROR                            = 0x80153047;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR                   = 0x80153048;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_ENUMERATE_ERROR            = 0x80153049;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_VERIFY_NICKNAME_ERROR                   = 0x8015304A;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_REFRESH_LICENSE_ERROR           = 0x8015304B;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_POINTS_PURCHASE_STATUS_ERROR        = 0x8015304C;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_REVOCATION_LIST_ERROR               = 0x8015304D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_OFFER_PURCHASE_ERROR                    = 0x8015304E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_MUSIC_ERROR                    = 0x8015304F;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CREATE_CERTIFICATE_ERROR                = 0x80153050;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_GAMERTAG_ERROR                 = 0x80153051;  // non-specific (catch all) api error
        public const uint XONLINE_E_BILLING_PAYMENT_INFO_NOT_FOUND_ERROR             = 0x80153052;  // payment info not found
        public const uint XONLINE_E_BILLING_FRIENDLY_NAME_NOT_FOUND_ERROR            = 0x80153053;  // friendly name not found
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_ANNIVERSARY_DATE_ERROR    = 0x80153054;  // anniversary date was specified
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_ACCOUNT_ID_ERROR          = 0x80153055;  // account id was specified
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_PAYMENT_ID_ERROR          = 0x80153056;  // payment instrument id was specified
        public const uint XONLINE_E_BILLING_AREA_CODE_NOT_FOUND_ERROR                = 0x80153057;  // area code not found
        public const uint XONLINE_E_BILLING_PHONE_NUMBER_NOT_FOUND_ERROR             = 0x80153058;  // phone number not found
        public const uint XONLINE_E_BILLING_ADDRESS_NOT_FOUND_ERROR                  = 0x80153059;  // address not found
        public const uint XONLINE_E_BILLING_ACCOUNT_HOLDER_NAME_NOT_FOUND_ERROR      = 0x8015305A;  // account holder name not found
        public const uint XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR           = 0x8015305B;  // account number not found
        public const uint XONLINE_E_BILLING_EXPIRATION_DATE_NOT_FOUND_ERROR          = 0x8015305C;  // expiration date not found
        public const uint XONLINE_E_BILLING_BAD_CREDIT_CARD_TYPE_ERROR               = 0x8015305D;  // bad credit card type
        public const uint XONLINE_E_BILLING_BRANCH_CODE_NOT_FOUND_ERROR              = 0x8015305E;  // expiration date not found
        public const uint XONLINE_E_BILLING_EXTERNAL_REFERENCE_ID_NOT_FOUND          = 0x8015305F;  // external reference id not found
        public const uint XONLINE_E_BILLING_WHOLESALE_PARTNER_NOT_FOUND              = 0x80153060;  // wholesale partner id not found
        public const uint XONLINE_E_BILLING_ENCRYPTED_PASSWORD_NOT_FOUND             = 0x80153061;  // encrypted password id not found
        public const uint XONLINE_E_BILLING_STREET_1_NOT_FOUND_ERROR                 = 0x80153062;  // street 1 id not found
        public const uint XONLINE_E_BILLING_CITY_NOT_FOUND_ERROR                     = 0x80153063;  // city id not found
        public const uint XONLINE_E_BILLING_COUNTRY_CODE_NOT_FOUND_ERROR             = 0x80153064;  // country code not found
        public const uint XONLINE_E_BILLING_CHILD_CONTENT_PURCHASE_NOT_ALLOWED       = 0x80153065;  // child accounts not allowed to purchase content in the user's country
        public const uint XONLINE_E_BILLING_CALCULATE_TAX_ERROR                      = 0x80153066;  // non-specific error calling SCS CalculateTax
        public const uint XONLINE_E_BILLING_SUBMIT_ORDER_ERROR                       = 0x80153067;  // non-specific error calling SCS SubmitOrder
        public const uint XONLINE_E_BILLING_SCS_SQL_TRANSACTION_FAILED               = 0x80153068;  // a SQL transaction failed during an SCS SubmitOrder purchase
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_NOT_FOUND                = 0x80153069;  // the SCS SubmitOrder tracking guid could not be found
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_CANCELLED                = 0x8015306A;  // the SCS SubmitOrder tracking guid has already been cancelled
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_UNEXPECTED_STATE         = 0x8015306B;  // the SCS SubmitOrder tracking guid was found with an unexpected status id
        public const uint XONLINE_E_BILLING_CHILD_OFFER_PURCHASE_NOT_ALLOWED         = 0x8015306C;  // child accounts not allowed to purchase offer in user's country
        public const uint XONLINE_E_OFFERING_ASSET_CONSUME_ERROR                     = 0x8015306D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ASSET_ENUMERATE_ERROR                   = 0x8015306E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SIGN_ASSETS_ERROR                       = 0x8015306F;  // non-specific (catch all) api error
        public const uint XONLINE_E_BILLING_FINBUS_MISSING_XNA_CREATOR_ID_ERROR      = 0x80153070;  // Media purchased is of type XNA Community Game but catalog looking did not find an XNA Creator Id
        public const uint XONLINE_E_BILLING_CTP_COMMUNICATION_ERROR                  = 0x80153075;  // Error raised when we communication exception is received from CTP
        public const uint XONLINE_E_BILLING_CTP_VALIDATION_RENEWAL_ERROR             = 0x80153076;   //Renewal Path Error
        public const uint XONLINE_E_BILLING_CTP_INVALIDRESPONSE                      = 0x80153077;   //Multiple nodes returned for Purchase call.Should not be happening.
        public const uint XONLINE_E_BILLING_CTP_AUTHORIZATION                        = 0x80153078;   //CTP Auth error
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENT                      = 0x80153079;   //Payment instrument errors
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRACKING_GUID                = 0x8015307A;   //Invalid Tracking Guid
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENTPROVIDER              = 0x8015307B;   //Invalid Payment Provider
        public const uint XONLINE_E_BILLING_CTP_INVALID_CALLINGPARTNER               = 0x8015307C;   //Invalid Calling partner
        public const uint XONLINE_E_BILLING_CTP_INVALID_ITEM                         = 0x8015307D;   //Invalid Purchase Item passed
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRANSACTIONSTATUS            = 0x8015307E;   //Invalid Transaction status
        public const uint XONLINE_E_BILLING_CTP_UNKNOWN                              = 0x8015307F;   //Unknown Error
        public const uint XONLINE_E_BILLING_CTP_INVALID_OFFER_NOTFOUND               = 0x80153080;   //OfferId not found for Billing OfferId
        public const uint XONLINE_E_BILLING_CTP_NOTSUPPORTED_MEDIATYPE               = 0x80153081;   //Mediatype not supported
        public const uint XONLINE_E_BILLING_CTP_INVALID_TOKEN                        = 0x80153082;   //Token is invalid
        public const uint XONLINE_E_BILLING_CTP_INVALID_SUB_OFFER_COUNT              = 0x80153083;   //More than one offer found for subscription purchase
        public const uint XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR                   = 0x80153084;   //Error encountered looking up legacy offerId
        public const uint XONLINE_E_OFFERING_GET_OFFERINSTANCE_ERROR                 = 0x80153085;   //Error looking up the mapping for OfferInstance and Offer
        public const uint XONLINE_E_OFFERING_INVALID_RENEWAL                         = 0x80153086;   //No renewal path existing
        public const uint XONLINE_E_OFFERING_MULTIPLE_RENEWAL                        = 0x80153087;   //Multiple renewal path existing
        public const uint XONLINE_E_BILLING_CTP_INVALID_TIMEEXTENSION                = 0x80153088;   //Time Extension passed is invalid
        public const uint XONLINE_E_BILLING_CTP_RATING_RULES_ERROR                   = 0x80153089;   //Invalid rating rules
        public const uint XONLINE_E_BILLING_CTP_INVALID_MODE                         = 0x8015308A;   //CTP Convert mode is invalid.Renewal not supported
        public const uint XONLINE_E_BILLING_CTP_NO_RETRYABLE_PURCHASE                = 0x8015308B;   //No retryable items in CTP queue
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_NOT_FOUND                = 0x8015308C;   //No transaction found update
        public const uint XONLINE_E_BILLING_CTP_RETRY_INTERVAL_EXCEEDED              = 0x8015308D;   //Retry interval exceeded
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_SQL_ERROR                = 0x8015308E;   //Unknown SQL error
        public const uint XONLINE_E_BILLING_CTP_QUEUE_ITERATOR_ERROR                 = 0x8015308F;   //Cannot build Queue Iterator
        public const uint XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE        = 0x80153090;   //Error creating CTP Purchase intent
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_CREDIT_VALUE_MAPPING_ERROR  = 0x80153091;   //Error loading CTP SubscriptionCreditValue mapping
        public const uint XONLINE_E_BILLING_BAD_CREDIT_VALUE                         = 0x80153092;   //Negative credit value configured
        public const uint XONLINE_E_OFFERING_GET_OFFERINGGUID_ERROR                  = 0x80153093;   //Error encountered looking up mapping for legacy id to guid
        public const uint XONLINE_E_OFFERING_GET_LEGACYID_ERROR                      = 0x80153094;   //Error encountered looking up mapping for guid to legacy id
        public const uint XONLINE_E_BILLING_CTP_PARTNERCONFIG_UNKNOWN_ERROR          = 0x80153095;   // Error encountered during CTP Partner Configuration
        public const uint XONLINE_E_BILLING_CTP_INVALID_OVERRIDDEN_PRICE             = 0x80153096;   // Overridden Price is negative
        public const uint XONLINE_E_BILLING_NOUNLIST_NOT_CONFIGURED                  = 0x80153097;   // Noun List not configured for country id
        public const uint XONLINE_E_BILLING_ADJECTIVELIST_NOT_CONFIGURED             = 0x80153098;   // Adjective List not configured for country id
        public const uint XONLINE_E_OFFERING_FAMILY_TO_CLASSIC_DOWNGRADE_NOT_ALLOWED = 0x80153099;  // Family Gold users cannot purchase a Classic Gold subscription. They must wait for their subscription to expire to Silver before they can downgrade to Gold.
        public const uint XONLINE_E_BILLING_CTP_DIRECT_DEBIT_NOT_SUPPORTED           = 0x8015309A;   // Direct Debit operation like convert is not supported in Mega API
        public const uint XONLINE_E_OFFERING_FAMILY_DEPENDENT_PURCHASE_NOT_ALLOWED   = 0x8015309B;   // Family Gold dependents cannot purchase classic gold or family gold subscriptions
        public const uint XONLINE_E_OFFERING_FAMILY_CHILD_PURCHASE_NOT_ALLOWED       = 0x8015309C;   // Child/Juvenille users cannot purchase family gold subscriptions
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX_MACHINE                 = 0x8015309D;   // PPV offer has already been purchased within the past 24 hours on the same machine/device i.e. this user already owns the maximum allowed on the machine -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX
        public const uint XONLINE_E_OFFERING_LICENSE_AVAILABLE                       = 0x8015309E;   // There is an existing license available that has not been downloaded and acknowledged for that offer -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX
        public const uint XONLINE_E_BILLING_CTP_INVALID_PRICE                        = 0x8015309F;   //Price passed from console does not match compute only
        public const uint XONLINE_E_BILLING_INVALID_TRACKING_GUID                    = 0x801530A0;   // Transaction id passed is not valid for this API or user

        //
        // XBOS success HRESULTS                                                     = 0x001531XX
        //
        public const uint XONLINE_S_OFFERING_NEW_CONTENT                             = 0x00153101;
        public const uint XONLINE_S_OFFERING_NO_NEW_CONTENT                          = 0x00153102;

        //
        // Internal DMP HRESULTS                                                     = 0x801532XX
        //
        public const uint XONLINE_E_DMP_TRANSACTION_CANCELLED                        = 0x80153200;  // the DMP transaction was cancelled
        public const uint XONLINE_E_DMP_CANT_GRANT_LICENSE                           = 0x80153201;  // there was an error adding a row to t_licenses
        public const uint XONLINE_E_DMP_CANT_REMOVE_LICENSE                          = 0x80153202;  // there was an error removing a row from t_licenses
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCELLED                 = 0x80153203;  // there was an error marking a DMP transaction as cancelled
        public const uint XONLINE_E_DMP_CANCEL_SUCCESSFULL                           = 0x80153204;  // the call to CancelPurchaseItem returned successfully
        public const uint XONLINE_E_DMP_CANCEL_TRANS_NOT_FOUND                       = 0x80153205;  // the call to CancelPurchaseItem returned "transaction not found"
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_SUCCESS                   = 0x80153206;  // there was an error marking a DMP transaction as successfull
        public const uint XONLINE_E_DMP_UNEXPECTED_STATE                             = 0x80153207;  // the DMP transaction service encountered an unexpected state
        public const uint XONLINE_E_DMP_TRANSACTION_NOT_FOUND                        = 0x80153208;  // the DMP transaction guid could not be found in the table
        public const uint XONLINE_S_DMP_TRANSACTION_ALREADY_CANCELLED                = 0x00153209;  // the DMP transaction has already been cancelled
        public const uint XONLINE_S_DMP_NO_CANCELABLE_TRANSACTIONS                   = 0x0015320A;  // there are no DMP purchase transactions to be cancelled
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCEL_FAILED             = 0x8015320B;  // there was an error marking a DMP transaction as cancelFailed
        public const uint XONLINE_S_DMP_NO_RETRYABLE_REWARD                          = 0x0015320C;  // there are no DMP reward transactions to be retriedg
        public const uint XONLINE_E_DMP_INVALID_REWARD                               = 0x8015320D;  // the reward does not exist or is misconfigured
        public const uint XONLINE_E_DMP_SQL_TRANSACTION_FAILED                       = 0x8015320E;  // a transaction failed to complete during a DMP operation
        public const uint XONLINE_S_DMP_RETRY_INTERVAL_EXCEEDED                      = 0x0015320F;  // a transaction was moved more to failure state because the retry interval was exceeded
        public const uint XONLINE_E_DMP_E_DELEGATE_NOT_SUPPORTED                     = 0x80153210;  // delegation not supported
        public const uint XONLINE_E_DMP_E_DESTINATION_ZERO                           = 0x80153211;  // error in destination puid's account
        public const uint XONLINE_E_DMP_E_INVALID_DESTINATION_ACCOUNT                = 0x80153212;  // destination billing account is invalid
        public const uint XONLINE_E_DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED  = 0x80153213;  // transfer maximum exceeded
        public const uint XONLINE_E_DMP_E_SOURCE_TRANSFER_PUIDS_SAME                 = 0x80153214;  // source and destination puids are the same
        public const uint XONLINE_E_DMP_E_SOURCE_ZERO                                = 0x80153215;  // error in source puid's account
        public const uint XONLINE_E_DMP_E_ZERO_NEGTIVE_TRANSFER                      = 0x80153216;  // error when source has zero points in account
        public const uint XONLINE_E_DMP_E_RISK_UNEXPECTED_RESULT                     = 0x80153217;  // Unexpected error in Risk data


        //
        // Internal XBOS HRESULTS                                                    = 0x801533XX
        //
        public const uint XONLINE_S_NO_RETRYABLE_SCS_PURCHASES                       = 0x00153300;  // there are no retryable SCS::PurchaseItem transactions
        public const uint XONLINE_E_SCS_TRANSACTION_NOT_FOUND                        = 0x80153301;  // the SCS transaction guid could not be found in the table
        public const uint XONLINE_E_CONTENT_NOT_FOUND                                = 0x80153302;  // Content not found
        public const uint XONLINE_E_MACHINE_ID_NOT_FOUND                             = 0x80153303;  // Machine id not found

        // DMP-specific XBOS HRESULTS                                                = 0x801534XX

        // internal hresults
        public const uint XONLINE_E_DMP_E_STATUS_UNREGISTERED                        = 0x80153400; // User is not registered with DMP.
        public const uint XONLINE_E_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND             = 0x80153401; // The original record was not found, possibly archived
        public const uint XONLINE_E_DMP_E_DUPLICATE_EXTERNAL_ORDER_ID                = 0x80153402; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.

        // hresults that the client must be able to handle
        public const uint XONLINE_E_DMP_E_UNKNOWN_ERROR                              = 0x80153410; // Generic DMP error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_DMP_E_REQUEST_CANNOT_BE_COMPLETED                = 0x80153411; // The request cannot be completed due to user state. If the user is disabled then AddPromotionalBalance cannot be called upon that user.
        public const uint XONLINE_E_DMP_E_INSUFFICIENT_BALANCE                       = 0x80153412; // There is not sufficient balance to support this transaction
        public const uint XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED                       = 0x80153413; // The result point balance will exceed the policy max balance
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITION_EXCEEDED                   = 0x80153414; // The point amount exceeds the policy max acquisition limit per transaction
        public const uint XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED                   = 0x80153415; // The user consumption per period of time would exceed the policy limit
        public const uint XONLINE_E_DMP_E_NO_MORE_PROMO_POINTS                       = 0x80153416; // There are no more points to distribute for this tenant sku combination. All the promo points for this partner's promotional SKU are gone already!
        public const uint XONLINE_E_DMP_E_PROMOTION_LIMIT_LIFE_MAX                   = 0x80153417; // The promotional points user obtained would exceed the sku limit. There is a configurable per user limit on each promotion. The partner sets it in offer modeling time
        public const uint XONLINE_E_DMP_E_PROMO_EXPIRED                              = 0x80153418; // The promotional SKU has expired. The enddate for a promo is a configured limit set by the partner. If a request comes in after that configured deadline then the request is rejected
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED            = 0x80153419; // User attempt to acquire more points than is allowed in a given time span
        public const uint XONLINE_E_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x8015341A; // TransferBalance initiated within the no transfer window for the target account
        public const uint XONLINE_E_DMP_E_COUNTRY_CODE_MISMATCH                      = 0x8015341B; // TransferBalance failed because DMP source and destination accounts are in different countries
        public const uint XONLINE_E_DMP_E_USER_REGISTERED                            = 0x8015341C; // RegisterUser called for user already registered with DMP
        public const uint XONLINE_E_DMP_E_UNKNOWNSERVER_ERROR                        = 0x8015341D; // Unknown Server Error.
        public const uint XONLINE_E_DMP_E_SYSTEM_INTERNAL_ERROR                      = 0x8015341E; // A system internal error has occurred.
        public const uint XONLINE_E_DMP_E_INVALID_SOURCE_ACCOUNT                     = 0x8015341F; // Source Account is not in Active State for the Transaction.
        public const uint XONLINE_E_DMP_E_USER_DISABLED                              = 0x80153420; // User is disabled.
        public const uint XONLINE_E_DMP_E_PROMO_POINTS_UNAVAILIABLE                  = 0x80153421; // Promo points is unavailable
        public const uint XONLINE_E_DMP_E_INVALID_SKU                                = 0x80153422; // Sku passed for DMP purchase is invalid
        public const uint XONLINE_E_DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x80153423; // TransferBalance initiated within the no transfer window for the source account

        //
        // XCBK HRESULTS                                                             = 0x801535XX
        //
        public const uint XCBK_E_INVALID_SVC_COMPONENT                               = 0x80153500;
        public const uint XCBK_E_SUBSCRIPTION_NOT_FOUND                              = 0x80153501;
        public const uint XCBK_E_KEY_NOT_FOUND_IN_MESSAGE                            = 0x80153502;
        public const uint XCBK_E_SETTING_KEY_NOT_FOUND                               = 0x80153503;
        public const uint XCBK_E_UNAUTHORIZED_REQUEST                                = 0x80153504;
        public const uint XCBK_E_UNKNOWN_ERROR                                       = 0x80153505;
        public const uint XCBK_E_SUBSCRIPTION_ACCOUNT_MISMATCH                       = 0x80153506;

        //
        // Diet Orange HResults                                                      = 0x8015360X
        //
        public const uint XONLINE_E_ORANGE_INVALID_REQUEST                           = 0x80153601;

        // MusicNet-specific XBOS HRESULTS                                           = 0x801537XX

        public const uint XONLINE_E_MUSICNET_BEGIN_ERROR_RANGE                       = 0x80153700; // marks beginning of musicnet-related error codes

        public const uint XONLINE_E_MUSICNET_UNKNOWN_ERROR                           = 0x80153700; // Generic MusicNet error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_S_MUSICNET_NO_RETRYABLE_PURCHASE_ASSETS            = 0x00153701; // no retryable MusicNet.PurchaseAssets transactions were found
        public const uint XONLINE_E_MUSICNET_TRANSACTION_NOT_FOUND                   = 0x80153702; // the transaction guid could not be found in the table
        public const uint XONLINE_E_MUSICNET_ORDERITEMS_ITEMS_WITH_ERRORS            = 0x80153703; // a musicnet.orderitems call returned a non-empty itemsWithErrors
        public const uint XONLINE_E_MUSICNET_INVALID_ORDER_ID                        = 0x80153704; // musicnet already has processed the transaction with the specified order id (209)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_SUSPENDED_OR_CLOSED             = 0x80153705; // the musicnet account referenced has been suspended or is closed (424)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_SUBSCRIBER              = 0x80153706; // the musicnet account already has an active subscription offer. (216)
        public const uint XONLINE_E_MUSICNET_INVALID_CANCEL_REQUEST                  = 0x80153707; // Invalid cancelation request.  This account is already canceled. (204)
        public const uint XONLINE_E_MUSICNET_SUBSCRIPTION_ACCOUNT_CLOSED             = 0x80153708; // Subscription account closed. (233)
        public const uint XONLINE_E_MUSICNET_INVALID_SKU_NUMBER                      = 0x80153709; // Invalid SKU number. (207)
        public const uint XONLINE_E_MUSICNET_INVALID_TRANSACTION_DATE                = 0x8015370A; // Transaction date is in the future. Request denied. (206)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_CANCELED                        = 0x8015370B; // This account is canceled.  Requested operation not allowed. (205)
        public const uint XONLINE_E_MUSICNET_INVALID_RESUME_REQUEST                  = 0x8015370C; // Invalid resume request. This account is already active. (203)
        public const uint XONLINE_E_MUSICNET_CANNOT_CHANGE_OFFER                     = 0x8015370D; // Cannot change to an offer that is the same as the current offer. (202)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_HAS_EXPIRED_TRIAL               = 0x8015370E; // This account has an expired trial. Cannot change the queued offer. (201)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_HAS_TRIAL               = 0x8015370F; // Already have a trial. (228)
        public const uint XONLINE_E_MUSICNET_TRIAL_OFFER_EXPIRED                     = 0x80153710; // Trial offer has expired. (210)
        public const uint XONLINE_E_MUSICNET_MAXIMUM_PURCHASE_COMPONENTS_EXCEEDED    = 0x80153711; // Maximum number of purchase components per order exceeded. (229)
        public const uint XONLINE_E_MUSICNET_DUPLICATE_USER_NAME                     = 0x80153712; // Duplicate user name found (25)
        public const uint XONLINE_E_MUSICNET_INSUFFICIENT_FREE_TRACKS                = 0x80153713; // Insufficient free tracks remain to complete purchase (432)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_HAS_QUEUED_OFFER        = 0x80153714; // Account already has a queued subscription offer (212)
        public const uint XONLINE_E_MUSICNET_INVALID_SUBSCRIPTION_FREE_PURCHASE       = 0x80153715; // Invalid subscription free purchase type(434)
        public const uint XONLINE_E_MUSICNET_CONTENT_RIGHT_UNAVAILABLE                = 0x80153716; // Content right not available for requested component(312)
        public const uint XONLINE_E_MUSICNET_END_ERROR_RANGE                         = 0x801537FF; // marks end of musicnet-related error codes

        // WMIS-specific XBOS HRESULTS                                               = 0x801538XX

        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR                               = 0x80153800; // Generic WMIS error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_WMIS_PURCHASE_DETAILS_NULL                       = 0x80153801; // WMIS is returning null on a GetVideoPurchaseDetails call.
        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR_CONSOLE                       = 0x80153802; // Generic WMIS error on the console side.  The server should never return this error.
        public const uint DEPRECATED_XONLINE_E_WMIS_EMPTY_TITLE_TEXT                 = 0x80153803; // WMIS GetVideoPurchaseDetails returned an invalid empty title text field.

        // SyncCast-specific XBOS HRESULTS                                           = 0x801539XX
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_UNKNOWN_ERROR                = 0x80153900; // Generic SyncCast error.  See server event log for specific details about what went wrong.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_TOO_LARGE            = 0x80153901; // SyncCast has returned a license too large to return to the client.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_EMPTY                = 0x80153902; // SyncCast has returned an empty license when an exception was expected
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_INVALID          = 0x80153903; // Client cert is missing or invalid
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_ACCESS_DENIED    = 0x80153904; // Client cert access denied on the web service or the offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_INVALID_OFFER_ACTION         = 0x80153905; // An invalid action was requested for the given offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_COUNTER_LIMIT        = 0x80153906; // Attempted to fulfill a request beyond the counter limit
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_EXPIRATION_DATE      = 0x80153907; // Attempted to fulfill a request beyond the expiration date
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_EMPTY_DEVICE_NAME            = 0x80153908; // An empty device name was provided

        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_REVOKED           = 0x80153A00; // The player application has been revoked
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_SECURITY_UPGRADE  = 0x80153A01; // A security upgrade id required for the player application
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_DEVICE_REVOKED               = 0x80153A02; // The device has been revoked


        // DRM License specific HRESULTS
        public const uint DEPRECATED_XONLINE_E_NO_VALID_LICENSE                      = 0x80153B01; // No license was available to acquire.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_EXPIRED                   = 0x80153B02; // Could not issue license as the VOD license acquisition window has closed
        public const uint DEPRECATED_XONLINE_E_NO_SCOID                              = 0x80153B03; // Could not retrieve SyncCast OfferId from WMIS
        public const uint DEPRECATED_XONLINE_E_VOD_INVALID_MACHINE                   = 0x80153B04; // Invalid machine.  Can only issue licenses to the purchasing machine.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_DELIVERED                 = 0x80153B05; // License has already been delivered and acknowledged

        // Internal FinBus HRESULTS                                                  = 0x80153CXX
        //

        public const uint XONLINE_S_FINBUS_NO_RETRYABLE_TRANSACTIONS                 = 0x00153C00;  // there are no retryable FinBus transactions in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_TRANSACTION_NOT_FOUND                     = 0x80153C01;  // the FinBus transation does not exist in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_SQL_TRANSACTION_FAILED                    = 0x80153C02;  // a SQL transaction using the t_finbus_transactions_table failed
        public const uint XONLINE_E_FINBUS_REDEMPTION_TRANSACTION_FAILED             = 0x80153C03;  // there was an error updating the FinBus item's status to Pending from PrePending
        public const uint XONLINE_S_FINBUS_RETRY_INTERVAL_EXCEEDED                   = 0x00153C04;  // a FinBus transaction was moved more to failure state becuase the retry interval was exceeded
        public const uint XONLINE_E_FINBUS_HEALTH_CHECK_ERROR                        = 0x80153C05;  // Error calling the finbus health check
        public const uint XONLINE_E_FINBUS_FAST_FAIL_ERROR                           = 0x80153C06;  // Fast fail error when calling FinBus endpoint
        public const uint XONLINE_E_FINBUS_PUBLISH_MESSAGE_ERROR                     = 0x80153C07;  // non-specific (catch all) FinBus PublishMessage error
        public const uint XONLINE_E_FINBUS_IS_SERVICE_ALIVE_ERROR                    = 0x80153C08;  // non-specific (catch all) FinBus IsServiceAlive error

        // Tracked API HRESULTs                                                      = 0x80153DXX
        public const uint XONLINE_E_TRACKED_API_DUPLICATE_TRACKING_GUID              = 0x80153D00;  // duplicate tracking guid found
        public const uint XONLINE_E_TRACKED_API_DATABASE_ERROR                       = 0x80153D01;  // error recording tracked api to database

        //
        // xuacs HRESULTS                                                            = 0x801540XX
        //
        public const uint XONLINE_S_ACCOUNTS_NAME_TAKEN                              = 0x00000010;

        public const uint XONLINE_E_ACCOUNTS_NAME_TAKEN                              = 0x80154000;
        public const uint XONLINE_E_ACCOUNTS_INVALID_KINGDOM                         = 0x80154001;
        public const uint XONLINE_E_ACCOUNTS_INVALID_USER                            = 0x80154002;
        public const uint XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD                         = 0x80154003;
        public const uint XONLINE_E_ACCOUNTS_BAD_BILLING_ADDRESS                     = 0x80154004;
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_BANNED                          = 0x80154005;
        public const uint XONLINE_E_ACCOUNTS_PERMISSION_DENIED                       = 0x80154006;
        public const uint XONLINE_E_ACCOUNTS_INVALID_VOUCHER                         = 0x80154007;
        public const uint XONLINE_E_ACCOUNTS_DATA_CHANGED                            = 0x80154008; // unexpected modifications made during request.  commit is aborted to avoid overwriting modifcations.
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED                    = 0x80154009;
        public const uint XONLINE_E_ACCOUNTS_OPERATION_BLOCKED                       = 0x8015400A;
        public const uint XONLINE_E_ACCOUNTS_POSTAL_CODE_REQUIRED                    = 0x8015400B;
        public const uint XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER                         = 0x8015400C;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_RENEWAL_OFFER                     = 0x8015400D;
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_IS_LOCKED                       = 0x8015400E;
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_REQUIRED                        = 0x8015400F;
        public const uint XONLINE_E_ACCOUNTS_ALREADY_DEPROVISIONED                   = 0x80154010;
        public const uint XONLINE_E_ACCOUNTS_INVALID_PRIVILEGE                       = 0x80154011;
        public const uint XONLINE_E_ACCOUNTS_INVALID_SIGNED_PASSPORT_PUID            = 0x80154012;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_ALREADY_LINKED                 = 0x80154013;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOX1_USER                  = 0x80154014;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_BAD_SUBSCRIPTION                = 0x80154015;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_NOT_LINKED                     = 0x80154016;
        public const uint XONLINE_E_ACCOUNTS_NOT_XENON_USER                          = 0x80154017;
        public const uint XONLINE_E_ACCOUNTS_CREDIT_CARD_REQUIRED                    = 0x80154018;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOXCOM_USER                = 0x80154019;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_VOUCHER_OFFER                     = 0x8015401A;
        public const uint XONLINE_E_ACCOUNTS_REACHED_TRIAL_OFFER_LIMIT               = 0x8015401B; // Can't use trial offer because the limit for this console has already been reached
        public const uint XONLINE_E_ACCOUNTS_XBOX1_MANAGEMENT_BLOCKED                = 0x8015401C; // A Xenon user is not allowed to access certain features (such as account management) from an xbox1 console
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID_ALREADY_USED               = 0x8015401D; // The provided offline xuid has already been used to create an account
        public const uint XONLINE_E_ACCOUNTS_BILLING_PROVIDER_TIMEOUT                = 0x8015401E; // The billing provider operation timed out
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_OFFER_NOT_FOUND               = 0x8015401F; // The billing offer id for the Xbox1 migration offer was not found
        public const uint XONLINE_E_ACCOUNTS_UNDER_AGE                               = 0x80154020; // Request cannot be processed because user is under-age.
        public const uint XONLINE_E_ACCOUNTS_XBOX1_LOGON_BLOCKED                     = 0x80154021; // The user account is restricted from signing on with Xbox1 titles
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_INVALID_FOR_TIER                = 0x80154022; // The voucher supplied is valid but not for the user's tier
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_QUEUED                  = 0x80154023; // The SwitchUserPassport operation was interrupted due to SCS or DB error and will be retried
        public const uint XONLINE_E_ACCOUNTS_SERVICE_NOT_PROVISIONED                 = 0x80154024; // The user account is not provisioned for this service type
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_UNBAN_BLOCKED                   = 0x80154025; // The user account has been permantely banned and cannot be revoked by a CUST tool
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_INELIGIBLE              = 0x80154026; // The user has switched passports less than 30 days ago
        public const uint XONLINE_E_ACCOUNTS_ADDITIONAL_DATA_REQUIRED                = 0x80154027; // The user has not provided address or phone information for XeSetAccountInfo
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_SCS_PENDING             = 0x80154028; // The user has a pending SCS points purchase request
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NO_BIRTHDATE            = 0x80154029; // The user has no birthdate present in their Passport profile
        // NOTE - THE NUMBERS BELOW ARE OUT OF ORDER, BUT WE RELEASED IT SO IT STAYS
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PRIVILEGE              = 0x8015102A; // User does not have privilege to graduate
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_CHILD                 = 0x8015102B; // User does not have a child account
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_ADULT                 = 0x8015102C; // User is not an adult (in their country)
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PI                     = 0x8015102D; // Client didn't specify payment instrument when one was required
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_PI_MISMATCH               = 0x8015102E; // User supplied existing payment instrument but personal information does not match
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ALREADY                   = 0x8015102F; // User supplied is already graduated
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ADULT_TO_CHILD          = 0x80154030; // The user has an adult account but is trying to switch to a juvenile Passport
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_QUEUED                    = 0x80151031; // Graduation of the user was queued
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NEW_PASSPORT_INELIGIBLE = 0x80151032; // Cannot switch ownership of the specified account
        // NOTE - THE NUMBERS ABOVE ARE OUT OF ORDER, BUT WE RELEASED IT SO IT STAYS
        public const uint XONLINE_E_ACCOUNTS_NO_AUTHENTICATION_DATA                  = 0x80154033; // no authentication data was provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR                = 0x80154034; // npdb configuration of client types in t_multisettings is invalid
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_MISSING                     = 0x80154035; // client type is missing,  was not provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_INVALID                     = 0x80154036; // client type provided is invalid
        public const uint XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED                  = 0x80154037; // service type / client type combination is not authorized for specified country
        public const uint XONLINE_E_ACCOUNTS_TAG_CHANGE_REQUIRED                     = 0x80154038; // account is required to change their gamertag
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_SUSPENDED                       = 0x80154039; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_NOT_ACCEPTED           = 0x8015403A; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_QUEUED                   = 0x8015403B; // set passport no age out flag operation has been queued
        public const uint XONLINE_E_BILLING_USERACCOUNT_USER_NOT_FOUND               = 0x8015403C; // User not found in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_INVALID_CLIENT               = 0x8015403D; // Invalid client in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER     = 0x8015403E; // Xuid does not match user in GetANID call.
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_ERROR                         = 0x8015403F; // unspecified error migrating an XBOX 1 offer
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_ERROR                      = 0x80154040; // unspecified error converting puid to anid
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOAD_USER_ERROR                = 0x80154041; // Error loading user by pasport puid
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ERROR                   = 0x80154042; // unspecified error switching user passport
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID                            = 0x80154043; // offline xuid prevents operation
        public const uint XONLINE_E_ACCOUNTS_RECOVER_ACCOUNT_ERROR                   = 0x80154044; // unspecified error recovering account
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_ERROR                           = 0x80154045; // unspecified subscription renewal error
        public const uint XONLINE_E_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR  = 0x80154046; // Failed to talk to ABCH.
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_FAILED                     = 0x80154047; // Couldn't transform a puid to an anid.
        public const uint XONLINE_E_ACCOUNTS_UPDATE_XBOX_COM_ACTIVITY_ERROR          = 0x80154048; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_GET_PROFILE_ERROR                   = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_UPDATE_PROFILE_ERROR                = 0x8015404A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_INFO_ERROR                  = 0x8015404B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR            = 0x8015404C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_ENCRYPTED_PROXY_PARAMETERS_ERROR = 0x8015404D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_FRIEND_MEMBER_NAME_ERROR   = 0x8015404E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_PUID_FROM_MEMBER_NAME_ERROR = 0x8015404F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_SECRET_QUESTIONS_ERROR     = 0x80154050; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOGIN_ERROR                    = 0x80154051; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_ERROR                  = 0x80154052; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_STATUS_ERROR                = 0x80154053; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_SIGN_IN_ERROR                      = 0x80154054; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_AUTHENTICATE_ACCOUNT_ERROR         = 0x80154055; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CHANGE_SUBSCRIPTION_PAYMENT_INSTRUMENT_ERROR = 0x80154056; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CLEAR_SUBSCRIPTIONS_ERROR               = 0x80154057; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CREATE_ACCOUNT_ERROR                    = 0x80154058; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_DISABLE_SUBSCRIPTION_ERROR              = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ENUMERATE_ELIGIBLE_ERROR                = 0x8015405A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ANID_ERROR                          = 0x8015405B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_LINKED_GAMERTAG_ERROR               = 0x8015405C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_NO_AGE_OUT_ERROR                    = 0x8015405D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMNET_INFO_ERROR                  = 0x8015405E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR           = 0x8015405F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POSTAL_CODE_ERROR                   = 0x80154060; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_STATUS_ERROR           = 0x80154061; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_INFO_ERROR                     = 0x80154062; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ERROR                     = 0x80154063; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_LINK_ACCOUNT_ERROR                      = 0x80154064; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_USER_ERROR                      = 0x80154065; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_USER_DATA_ERROR            = 0x80154066; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REMOVE_PAYMENT_INSTRUMENT_ERROR         = 0x80154067; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_NAME_ERROR                      = 0x80154068; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESTORE_ACCOUNT_ERROR                   = 0x80154069; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_ERROR                    = 0x80154070; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_USE_ERROR                      = 0x80154071; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_PAYMENT_INFO_ERROR                  = 0x80154072; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_STATUS_ERROR                = 0x80154073; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_PIN_ERROR                      = 0x80154074; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_SETTINGS_ERROR                 = 0x80154075; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TROUBLESHOOT_ACCOUNT_ERROR              = 0x80154076; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PARENTAL_CONTROLS_ERROR          = 0x80154077; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PAYMENT_INSTRUMENT_ERROR         = 0x80154078; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_INFO_ERROR               = 0x80154079; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_PIN_ERROR                = 0x8015407A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR         = 0x8015407B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_ERROR                    = 0x8015407C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_GET_OFFER_ERROR          = 0x8015407D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_WEB_GET_USER_SETTINGS_ERROR             = 0x8015407E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ACKNOWLEDGE_DOWNGRADE_ERROR             = 0x8015407F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_ERROR                  = 0x80154080; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_FROM_PASSPORT_ERROR    = 0x80154081; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POINTS_BALANCE_ERROR                = 0x80154082; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_SUBSCRIPTION_DETAILS_ERROR     = 0x80154083; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TYPE_ERROR                     = 0x80154084; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_WEB_INFO_ERROR                 = 0x80154085; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CHANGE_PASSWORD_ERROR          = 0x80154086; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CREATE_ERROR                   = 0x80154087; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_BUDDY_GAMERTAG_ERROR       = 0x80154088; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_GAMERTAG_ERROR                  = 0x80154089; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_MEMBER_NAME_ERROR          = 0x8015408A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PAYPAL_UNSUPPORTED_COUNTRY              = 0x8015408B; // PayPal not supported in user's country
        public const uint XONLINE_E_ACCOUNTS_CANNOT_REPLACE_VALID_PASSPORT           = 0x8015408D;
        public const uint XONLINE_E_ACCOUNTS_REPLACE_OWNER_PASSPORT_ERROR            = 0x8015408E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REPLACE_USER_PASSPORT_ERROR             = 0x8015408F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REPLACE_PASSPORT_QUEUED                 = 0x80154090; // The XeReplaceUserPassport operation was interrupted due to SCS or DB error and will be retried
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_ERROR                   = 0x80154091; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_DATABASE_ERROR          = 0x80154092;
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_DATE_OF_BIRTH_ERROR         = 0x80154093; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SWITCH_OWNER_PASSPORT_ERROR             = 0x80154094; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_INVALID_OWNER_PASSPORT_ERROR            = 0x80154095;
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_INFO_ERROR             = 0x80154096; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_BILLING_NOTIFICATIONS_ERROR         = 0x80154097; // no notifications found
        public const uint XONLINE_E_ACCOUNTS_USER_GET_ACCOUNT_INFO_ERROR             = 0x80154098; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_OPTED_OUT                          = 0x80154099;
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_POLICY               = 0x8015409A; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_TENURE               = 0x8015409B;
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_LEVELS               = 0x8015409C; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_MILESTONES           = 0x8015409D; // a configuration error
        public const uint XONLINE_I_ACCOUNTS_GET_USER_TENURE_NO_NEXT_MILESTONE       = 0x0015409E; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_INFO_SILVER_USER       = 0x8015409F; // User is a silver account...
        public const uint XONLINE_E_ACCOUNTS_CANNOT_UNGRADUATE_USER                  = 0x801540A0; // cannot change a user's birthday from adult to child
        public const uint XONLINE_E_ACCOUNTS_INVALID_AGE                             = 0x801540A1; // cannot change a user's birthday to a date in the future, or long ago
        public const uint XONLINE_E_ACCOUNTS_MAX_ACCOUNTS_REACHED                    = 0x801540A2; // Max number of xbox accounts created from a machine has been reached
        public const uint XONLINE_E_ACCOUNTS_GENERATE_GAMERTAG_ERROR                 = 0x801540A3; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_FREE_GAMERTAG_CHANGE_NOT_ELIGIBLE_ERROR = 0x801540A4; // User is not eligible for Free gamertag change
        public const uint XONLINE_E_ACCOUNTS_GET_CONSOLE_TRUST_LEVEL                 = 0x801540A5; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_CONSOLE_TRUST_LEVEL                 = 0x801540A6; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_INVALID_CONSOLE_TRUST_LEVEL             = 0x801540A7; // Console Trust Level outside valid range
        public const uint XONLINE_E_ACCOUNTS_CREATE_MOBILE_ACCOUNT_ERROR             = 0x801540A8; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ENUM_FAMILY_MEMBERS_ERROR               = 0x801540A9; // Error occurred during call to EnumFamilyMembers API
        public const uint XONLINE_E_ACCOUNTS_ADD_DEPENDENT_ERROR                     = 0x801540AA; // Error occurred during call to AddDependent API
        public const uint XONLINE_E_ACCOUNTS_INVALID_FAMILY_SUBSCRIPTION             = 0x801540AB; // No corresponding family subscription offer found in catalog.
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_BASE                  = 0x801540AC; // Dependent does not have base subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_TIER                  = 0x801540AD; // Dependent is not silver
        public const uint XONLINE_E_ACCOUNTS_UNKNOWN_ERROR_CHANGE_STATE              = 0x801540AE; // Unknow error changing the state
        public const uint XONLINE_E_ACCOUNTS_UNKNOWN_ERROR_MOVE_DEP_SUBSCRIPTION     = 0x801540AF; // Unknow error moving dependent subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_COUNTRYID                       = 0x801540B0; // CountryDictionary.CountryCode returns null
        public const uint XONLINE_E_ACCOUNTS_INVALID_GAMERTAG                        = 0x801540B1; // VerifyGamerTag rejected gamertag
        public const uint XONLINE_E_ACCOUNTS_BIRTHDATE_INVALID                       = 0x801540B2; // Birthdate Invalid (future)
        public const uint XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG                      = 0x801540B3; // VetName failed for gamertag
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_ASSIGNMENT_INELIGIBLE_ERROR = 0x801540B4; // User is not elegible to be granted dependent gold right in family subscription
        public const uint XONLINE_E_ACCOUNTS_GET_PARENTAL_CONTROLS_ERROR             = 0x801540B5; // Error in parental controls
        public const uint XONLINE_E_ACCOUNTS_GET_DEPENDENT_SIGNED_PUID_ERROR         = 0x801540B6; // Error in GetDependentSignedPuid
        public const uint XONLINE_E_ACCOUNTS_GET_BASE_SUBSCRIPTION_ERROR             = 0x801540B7; // No Base subscription for the user
        public const uint XONLINE_E_ACCOUNTS_MULTIPLE_ACTIVE_BASE_SUBSCRIPTION       = 0x801540B8; // Multiple Active base subscription
        public const uint XONLINE_E_ACCOUNTS_NO_ACTIVE_BASE_SUBSCRIPTION             = 0x801540B9; // No Active base subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE     = 0x801540BA; // Invalid value configured for Family gold convertion value
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_NOT_DEPENDENT_ERROR         = 0x801540BB; // User is not a dependent and can't be granted a gold seat in a family subscription
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_NO_SEATS_REMAIN_ERROR       = 0x801540BC; // A dependent can't be assigned a gold seat in a family subscription because no seats remain.
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_ALREADY_ASSIGNED_ERROR      = 0x801540BD; // A dependent can't be assigned a gold seat because they already occupy one
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_BILLING_REGION_ERROR        = 0x801540BE; // A dependent can't be assigned a gold seat because their billing region does not match the owner's
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_COOLDOWN_ERROR              = 0x801540BF; // A dependent can't be assigned a gold seat because the cooldown period has no expired
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_TOO_MANY_USERS_ERROR        = 0x801540C0; // A dependent can't be assigned a gold seat because too many dependents have been assigned to gold seats recently
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_UNTRUSTED_CONSOLE_ERROR     = 0x801540C1; // A dependent can't be assigned a gold seat because the console is not trusted
        public const uint XONLINE_E_ACCOUNTS_INVALID_MACHINEPUID                     = 0x801540C2; // Can't find the specified machine
        public const uint XONLINE_E_ACCOUNTS_INVALID_BETA_GROUPID                    = 0x801540C3; // Can't find the specified beta group
        public const uint XONLINE_E_ACCOUNTS_POINTS_TRANSFER_ERROR                   = 0x801540C4; // Unkown error transfering points balance
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_PRIMARY               = 0x801540C5; // There is no parent child relationship between users
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_ERROR               = 0x801540C7; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INELIGIBLE          = 0x801540C8; // The user has switched countries less than one year ago
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INVALID_COUNTRY     = 0x801540C9; // The country requested is not a LIVE-enabled country
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_DEPENDENT_HAS_FAMILY        = 0x801540CA; // A dependent can't be added because they have a family membership.
        public const uint XONLINE_E_ACCOUNTS_GET_PARENTAL_CONTROL_GROUP_TEMPLATES_ERROR = 0x801540CB; // Error in GetParentalControlGroupTemplates
        public const uint XONLINE_E_ACCOUNTS_GET_USER_PARENTAL_CONTROL_GROUP_ERROR   = 0x801540CC; // Error in GetUserParentalControlGroup
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INVALID_LOCALE      = 0x801540CD; // The locale requested is not a valid LIVE locale
        public const uint XONLINE_S_ACCOUNTS_SWITCH_USER_COUNTRY_SAME_COUNTRY        = 0x001540CE; // The user requested a switch to the country already associated with their account
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_TRY_AGAIN           = 0x801540CF; // The operation was interrupted or timed out. Retry the call to determine the result.
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PARENTAL_CONTROL_GROUP_ERROR     = 0x801540D0; // Error in UpdateParentalControlGroup
        public const uint XONLINE_E_ACCOUNTS_NEGATIVE_POINTS_VALUE                   = 0x801540D1; // Negative points value passed
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_ADULT_TO_CHILD      = 0x801540D2; // The user switching is an adult but would be a child in the new country.
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_DATABASE_ERROR      = 0x801540D3; // Database error as part of executing SwitchUserCountry
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER  = 0x801540D4; // No migration offer found for SwitchUserCountry
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_SUSPENDED_SUBSCRIPTION = 0x801540D5; // SwitchUserCountry does not allow migration for users with Xbox subscription which is suspended or expired
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_NON_XBOX_SUBSCRIPTION = 0x801540D6; // SwitchUserCountry does not allow migration for users with non-Xbox subscriptions such as Zune Pass, XNA Creators' Club, etc.
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_CHILD_ACCOUNT       = 0x801540D7; // SwitchUserCountry does not allow child accounts to migrate
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_FAMILY_ACCOUNT      = 0x801540D8; // SwitchUserCountry does not allow family accounts to migrate
        public const uint XONLINE_E_ACCOUNTS_GET_DEPENDENT_POINTS_BALANCE_ERROR      = 0x801540D9; // Unkown error getting dependent point balance
        public const uint XONLINE_E_ACCOUNTS_DEPENDENT_MOVE_SUBSCRIPTION             = 0x801540DA; // Error when moving dependents subscription
        public const uint XONLINE_E_ACCOUNTS_CREDENTIAL_LIST_BY_NAME_ERROR           = 0x801540DB; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_GET_AGE_ERROR                      = 0x801540DC; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_GET_AGE_GROUP_ERROR                = 0x801540DD; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_DEPENDENT_USER_IS_OWNER                 = 0x801540DE; // Error while creating owner a dependent user
        public const uint XONLINE_E_ACCOUNTS_OWNER_IS_DEPENDENT                      = 0x801540DF; // Error while creating dependent user as owner
        public const uint XONLINE_E_CREATE_BULK_USER_ERROR                           = 0x801540E0; // non-specific (catch all) api error
        public const uint XONLINE_E_USER_REWARDS_ELIGIBILITY_ERROR                   = 0x801540E1; // non-specific (catch all) api error
        public const uint XONLINE_E_SET_FAMILY_GOLD_SEAT_EXEMPTION_ERROR             = 0x801540E2; // non-specific (catch all) api error
        public const uint XONLINE_E_SET_FREE_GAMERTAG_ELIGIBLE_ERROR                 = 0x801540E3; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PREVIEW_SWITCH_USER_COUNTRY_ERROR       = 0x801540E4; // non-specific (catch all) api error
        public const uint XONLINE_S_ACCOUNTS_SWITCH_USER_COUNTRY_NO_MIGRATION_PATH   = 0x001540E5; // no country migration allowed from the current subscription offer
        public const uint XONLINE_S_ACCOUNTS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER  = 0x001540E6; // no country  migration offer found for the subscription offer
        public const uint XONLINE_E_ACCOUNTS_SWITCH_OWNER_PASSPORT_USER_INELIGIBLE   = 0x801540E7; // user attempting to switch owner passport puids does not meet certain requirements
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_ADD_PROOF_ERROR                = 0x801540E8; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_PROOFS_ERROR               = 0x801540E9; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_PROOF_TYPES_ERROR          = 0x801540EA; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_HCP_SERVICE_CALL_ERROR                  = 0x801540EB; // HCP service call failed

        // MSN RR-specific XBOS HRESULTS                                             = 0x801541XX
        public const uint XONLINE_E_MSNRR_BEGIN_ERROR_RANGE                          = 0x80154100; // marks beginning of msnrr-related error codes

        public const uint XONLINE_E_MSNRR_UNKNOWN_ERROR                              = 0x80154100; // Generic MSNRR error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_MSNRR_INVALID_CONTENT_TYPE_ID                    = 0x80154101; // Invalid content type id. This error also occurs if content type does not have a rating attribute or review field.
        public const uint XONLINE_E_MSNRR_INVALID_ITEM_ID                            = 0x80154102; // Invalid item id
        public const uint XONLINE_E_MSNRR_PUID_CANNOT_BE_ZERO                        = 0x80154103; // PUID cannot be zero
        public const uint XONLINE_E_MSNRR_USE_MULTIPLE_RATING                        = 0x80154104; // Content type has multiple rating attribute ids, use the Multiple Rating Interface.
        public const uint XONLINE_E_MSNRR_INVALID_TRANSACTION_TOKEN                  = 0x80154105; // Token does not match request parameters, start over with no token.


        // Token related HRESULTS                                                    = 0x801542XX
        public const uint XONLINE_E_TOKEN_UNKNOWN_ERROR                              = 0x80154200; // Generic token error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_TOKEN_FILE_NOT_FOUND                             = 0x80154201; // Token File Not Found
        public const uint XONLINE_E_TOKEN_REQUESTED_TOKENS_EXCEEDS_MAXIMUM_ALLOWABLE = 0x80154202;
        public const uint XONLINE_E_TOKEN_INVALID_START_PARAMETER                    = 0x80154203;
        public const uint XONLINE_E_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND                = 0x80154204;
        public const uint XONLINE_E_TOKEN_MALFORMED_5X5_TOKEN_CODE_FOUND             = 0x80154205;
        public const uint XONLINE_E_TOKEN_FILE_COULD_NOT_BE_DECRYPTED                = 0x80154206;
        public const uint XONLINE_E_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED    = 0x80154207;
        public const uint XONLINE_E_TOKEN_JOB_NOT_IN_REQUIRED_STATE                  = 0x80154208;
        public const uint XONLINE_E_TOKEN_NOT_YET_REDEEMABLE                         = 0x80154209; // token cannot be redeemed yet because the token category is not flagged as redeemable
        public const uint XONLINE_E_TOKEN_LOAD_SCS_ERROR                             = 0x80154210;

        // Token category related HRESULTS                                           = 0x8015421X;
        public const uint XONLINE_E_TOKEN_DUPLICATE_CATEGORY_NAME                    = 0x80154211; // A duplicate token category name is found when trying to create a new token category.
        public const uint XONLINE_E_TOKEN_NO_CATEGORY_FOUND                          = 0x80154212; // Cannot find the token category.
        public const uint XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE         = 0x80154213; // The "read only" properties of token category cannot be changed.
        // Token Job related HRESULTS
        public const uint XONLINE_E_TOKEN_JOB_DATABASE_ERROR                         = 0x80154220; // Unexpected database error manipulating Token Job in NPDB
        public const uint XONLINE_E_TOKEN_JOB_NOT_FOUND                              = 0x80154221; // Token Job either not present or not currently in Pending or abandoned state
    // Token sequence number HRESULTS
        public const uint XONLINE_E_TOKEN_SEQUENCE_NUMBER_INVALID_INDEX              = 0x80154231; // We can't generate sequence number because the index is too large.
        public const uint XONLINE_E_TOKEN_EXPIRED_TOKEN_CATEGORY                     = 0x80154232; // Tokens cannot be generated for an expired token category

        //
        // Notification HRESULTS                                                     = 0x801550XX
        //
        public const uint XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE                    = 0x80155000;
        public const uint XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL                   = 0x80155001;
        public const uint XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE                = 0x80155002;
        public const uint XONLINE_E_NOTIFICATION_NO_ADDRESS                          = 0x80155003;
        public const uint XONLINE_E_NOTIFICATION_INVALID_PUID                        = 0x80155004;
        public const uint XONLINE_E_NOTIFICATION_NO_CONNECTION                       = 0x80155005;
        public const uint XONLINE_E_NOTIFICATION_SEND_FAILED                         = 0x80155006;
        public const uint XONLINE_E_NOTIFICATION_RECV_FAILED                         = 0x80155007;
        public const uint XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED                   = 0x80155008;

        //
        // Match Service HRESULTS                                                    = 0x801551XX
        //
        public const uint XONLINE_E_MATCH_INVALID_SESSION_ID                         = 0x80155100;  // specified session id does not exist
        public const uint XONLINE_E_MATCH_INVALID_TITLE_ID                           = 0x80155101;  // specified title id is zero, or does not exist
        public const uint XONLINE_E_MATCH_INVALID_DATA_TYPE                          = 0x80155102;  // attribute ID or parameter type specifies an invalid data type
        public const uint XONLINE_E_MATCH_REQUEST_TOO_SMALL                          = 0x80155103;  // the request did not meet the minimum length for a valid request
        public const uint XONLINE_E_MATCH_REQUEST_TRUNCATED                          = 0x80155104;  // the self described length is greater than the actual buffer size
        public const uint XONLINE_E_MATCH_INVALID_SEARCH_REQ                         = 0x80155105;  // the search request was invalid
        public const uint XONLINE_E_MATCH_INVALID_OFFSET                             = 0x80155106;  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
        public const uint XONLINE_E_MATCH_INVALID_ATTR_TYPE                          = 0x80155107;  // the attribute type was something other than user or session
        public const uint XONLINE_E_MATCH_INVALID_VERSION                            = 0x80155108;  // bad protocol version in request
        public const uint XONLINE_E_MATCH_OVERFLOW                                   = 0x80155109;  // an attribute or parameter flowed past the end of the request
        public const uint XONLINE_E_MATCH_INVALID_RESULT_COL                         = 0x8015510A;  // referenced stored procedure returned a column with an unsupported data type
        public const uint XONLINE_E_MATCH_INVALID_STRING                             = 0x8015510B;  // string with length-prefix of zero, or string with no terminating null
        public const uint XONLINE_E_MATCH_STRING_TOO_LONG                            = 0x8015510C;  // string exceeded 400 characters
        public const uint XONLINE_E_MATCH_BLOB_TOO_LONG                              = 0x8015510D;  // blob exceeded 800 bytes
        public const uint XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID                       = 0x80155110;  // attribute id is invalid
        public const uint XONLINE_E_MATCH_SESSION_ALREADY_EXISTS                     = 0x80155112;  // session id already exists in the db
        public const uint XONLINE_E_MATCH_CRITICAL_DB_ERR                            = 0x80155115;  // critical error in db
        public const uint XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS                         = 0x80155116;  // search result set had too few columns
        public const uint XONLINE_E_MATCH_PERMISSION_DENIED                          = 0x80155117;  // incorrect permissions set on search sp
        public const uint XONLINE_E_MATCH_INVALID_PART_SCHEME                        = 0x80155118;  // title specified an invalid partitioning scheme
        public const uint XONLINE_E_MATCH_INVALID_PARAM                              = 0x80155119;  // bad parameter passed to sp
        public const uint XONLINE_E_MATCH_DATA_TYPE_MISMATCH                         = 0x8015511D;  // data type specified in attr id did not match type of attr being set
        public const uint XONLINE_E_MATCH_SERVER_ERROR                               = 0x8015511E;  // error on server not correctable by client
        public const uint XONLINE_E_MATCH_NO_USERS                                   = 0x8015511F;  // no authenticated users in search request.
        public const uint XONLINE_E_MATCH_INVALID_BLOB                               = 0x80155120;  // invalid blob attribute
        public const uint XONLINE_E_MATCH_TOO_MANY_USERS                             = 0x80155121;  // too many users in search request
        public const uint XONLINE_E_MATCH_INVALID_FLAGS                              = 0x80155122;  // invalid flags were specified in a search request
        public const uint XONLINE_E_MATCH_PARAM_MISSING                              = 0x80155123;  // required parameter not passed to sp
        public const uint XONLINE_E_MATCH_TOO_MANY_PARAM                             = 0x80155124;  // too many paramters passed to sp or in request structure
        public const uint XONLINE_E_MATCH_DUPLICATE_PARAM                            = 0x80155125;  // a paramter was passed to twice to a search procedure
        public const uint XONLINE_E_MATCH_TOO_MANY_ATTR                              = 0x80155126;  // too many attributes in the request structure
        public const uint XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT                    = 0x80155127;  // this request conflicted with another that was in progress
        public const uint XONLINE_E_MATCH_SESSION_TYPE_MISMATCH                      = 0x80155128;  // this request was operation of a row type (breadcrumb vs. sandwich) which mismatched.
        public const uint XONLINE_E_MATCH_LOCK_ALREADY_RELEASED                      = 0x80155129;  // the session was expected to be locked, but it was actually unlocked..

        //
        // Session API HRESULTS                                                      = 0x801552XX
        //
        public const uint XONLINE_E_SESSION_NOT_FOUND                                = 0x80155200;   // the specified session was not found
        public const uint XONLINE_E_SESSION_INSUFFICIENT_PRIVILEGES                  = 0x80155201;   // the requester does not have permissions to perform this operation

        //
        // Audit API HRESULTS                                                        = 0x80155300 - 0x8015537F
        // These don't ever go on the wire.
        //
        public const uint XONLINE_E_AUDIT_INVALID_SUBSYSTEM                          = 0x80155300;   // use specified unknown subsystem
        public const uint XONLINE_E_AUDIT_NO_SETTING                                 = 0x80155301;   // npdb setting for subsystem does not defined
        public const uint XONLINE_E_AUDIT_LOG_FAILURE                                = 0x80155302;   // error writing to audit log (database)

        //
        // Fse API HRESULTS                                                          = 0x80155380 - 0x801553FF
        //
        public const uint XONLINE_E_FSE_ERROR                                        = 0x80155380;   // generic unhandled fse exception
        public const uint XONLINE_E_FSE_BOOKMARK_INVALID_SETTING                     = 0x80155381;   // invalid bookmark setting (range)
        public const uint XONLINE_E_FSE_BOOKMARK_NO_SETTING                          = 0x80155382;   // missing bookmark setting

        public const uint XONLINE_E_FSE_HANDLER_MISSING                              = 0x80155388;   // application page or result handler is missing
        public const uint XONLINE_E_FSE_HANDLER_CREATE_ERROR                         = 0x80155389;   // unhandled application exception derializing result
        public const uint XONLINE_E_FSE_HANDLER_MERGE_ERROR                          = 0x8015538A;   // unhandled application exception merge pages
        public const uint XONLINE_E_FSE_HANDLER_EXTRACT_ERROR                        = 0x8015538B;   // unhandled application exception extracting from page
        public const uint XONLINE_E_FSE_HANDLER_SPLIT_ERROR                          = 0x8015538C;   // unhandled application exception splitting page

        public const uint XONLINE_E_FSE_CACHE_INVALID_EXPIRATION                     = 0x80155390;   // invalid cache expriation time
        public const uint XONLINE_E_FSE_CACHE_KEY_TOO_LONG                           = 0x80155391;   // cache key is longer than xbanc configuration setting
        public const uint XONLINE_S_FSE_CACHE_ENTRY_FOUND                            = 0x00155392;   // cache entry found successfully
        public const uint XONLINE_E_FSE_CACHE_TIMEOUT                                = 0x80155393;   // timeout waiting for cache entry
        public const uint XONLINE_E_FSE_CACHE_ERROR                                  = 0x80155394;   // exception thrown out of xbanc proxy
        public const uint XONLINE_E_FSE_CACHE_QUERY_ERROR                            = 0x80155395;   // exception thrown out of xbanc proxy
        public const uint XONLINE_E_FSE_CACHE_INSERT_ERROR                           = 0x80155396;   // exception thrown out of xbanc proxy

        public const uint XONLINE_E_FSE_CONFIG_METHOD_NOT_FOUND                      = 0x801553A0;   // configured method was not found
        public const uint XONLINE_E_FSE_CONFIG_NO_INTERFACE                          = 0x801553A1;   // no interface for configured method
        public const uint XONLINE_E_FSE_CONFIG_PARAM_ERROR                           = 0x801553A2;   // parameter configuration is invalid (couldn't be parsed)
        public const uint XONLINE_E_FSE_CONFIG_UNKNOWN_TYPE                          = 0x801553A3;   // unknown parameter type (won't be able to convert)
        public const uint XONLINE_E_FSE_CONFIG_MIN_OCCURS_INVALID                    = 0x801553A4;   // minOccurs < 0
        public const uint XONLINE_E_FSE_CONFIG_MAX_OCCURS_INVALID                    = 0x801553A5;   // maxOccurs < 1
        public const uint XONLINE_E_FSE_CONFIG_OCCURENCE_INVERSION                   = 0x801553A6;   // minOccurs > maxOccurs
        public const uint XONLINE_E_FSE_CONFIG_DUPLICATE_DELEGATE                    = 0x801553A7;   // parameter delegate already exists
        public const uint XONLINE_E_FSE_CONFIG_PAGE_SIZE_INVALID                     = 0x801553A8;   // cache page size or db page size are invalid

        public const uint XONLINE_E_FSE_DATABASE_ERROR                               = 0x801553B0;   // generic database error
        public const uint XONLINE_E_FSE_DATABASE_CONNECT_ERROR                       = 0x801553B1;   // generic database connection error
        public const uint XONLINE_E_FSE_DATABASE_EXECUTE_ERROR                       = 0x801553B2;   // generic database execute error

        public const uint XONLINE_E_FSE_METHOD_ERROR                                 = 0x801553C0;   // generic method error
        public const uint XONLINE_E_FSE_METHOD_NOT_FOUND                             = 0x801553C1;   // method called by user does not exist
        public const uint XONLINE_E_FSE_METHOD_RETRY_COUNT_EXCEEDED                  = 0x801553C2;   // retry count exceeded when calling database
        public const uint XONLINE_E_FSE_METHOD_RESULT_NOT_PAGED                      = 0x801553C3;   // error constructing paged result

        public const uint XONLINE_E_FSE_PARAM_LIST_INVALID                           = 0x801553D0;   // number of names and values do not match
        public const uint XONLINE_E_FSE_PARAM_MISSING                                = 0x801553D1;   // missing required (non-optional) parameter
        public const uint XONLINE_E_FSE_PARAM_UNEXPECTED                             = 0x801553D2;   // extra unrecognized / unexpected parameter
        public const uint XONLINE_E_FSE_PARAM_INTERNAL_ERROR                         = 0x801553D3;   // internal programming error
        public const uint XONLINE_E_FSE_PARAM_TOO_MANY                               = 0x801553D4;   // too many parameters
        public const uint XONLINE_E_FSE_PARAM_INVALID_VALUE                          = 0x801553D5;   // invalid param value (fails regex checks)
        public const uint XONLINE_E_FSE_PARAM_CONVERSION_ERROR                       = 0x801553D6;   // error converting value to configured type
        public const uint XONLINE_E_FSE_PARAM_DELEGATE_FAILURE                       = 0x801553D7;   // a parameter modifying delegate defined by the application threw an exception
        public const uint XONLINE_E_FSE_PARAM_IS_NULL                                = 0x801553D8;   // required parameter is null
        public const uint XONLINE_E_FSE_PARAM_TOO_FEW                                = 0x801553D9;   // number of values are is too few
        public const uint XONLINE_E_FSE_PARAM_INTERNAL                               = 0x801553DA;   // supplied parameter is internal only
        public const uint XONLINE_E_FSE_PARAM_RESERVED                               = 0x801553DB;   // supplied parameter name is reserved

        public const uint XONLINE_E_FSE_BIN_ERROR_EXECUTING                          = 0x801553E0;   // Error executing the FsePlugin
        public const uint XONLINE_E_FSE_BIN_ERROR_CONSTRUCTING                       = 0x801553E1;   // Error contructing the FsePlugin

        //
        // Catalog Stored Procedure HRESULTS                                         = 0x80155400 - 0x8015547F
        //
        public const uint XONLINE_E_CATALOG_INVALID_DETAIL_VIEW                      = 0x80155400;   // detail view value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_OFFER_FILTER_LEVEL               = 0x80155401;   // offer filter level value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_BY                         = 0x80155402;   // order by value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_DIRECTION                  = 0x80155403;   // order direction value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_RANKING_TYPE                     = 0x80155404;   // invalid ranking type in full text search
        public const uint XONLINE_E_CATALOG_INVALID_LOCALE                           = 0x80155405;   // invalid locale in full text search
        public const uint XONLINE_E_CATALOG_INVALID_VIDEO_FILTER                     = 0x80155406;   // invalid video filter in FindVideos
        public const uint XONLINE_E_CATALOG_INVALID_EDITORIAL_PRIV                   = 0x80155407;   // invalid editorial privilege

        public const uint XONLINE_E_CATALOG_INVALID_SETTING                          = 0x80155410;   // catalog service could not process a setting update
        public const uint XONLINE_E_CATALOG_ERROR                                    = 0x80155411;   // unspecified catalog error
        public const uint XONLINE_E_CATALOG_DESERIALIZATION_ERROR                    = 0x80155412;   // could not deserialize catalog result
        public const uint XONLINE_E_CATALOG_SUBSCRIPTIONS_INVALID_ARGS               = 0x80155413;   // Invalid Argument passed to FindSubscriptionProducts API

        // Service Tunnel HRESULTS                                                   = 0x80155480 - 0x801554FF

        public const uint XONLINE_E_SVCTUNNEL_ERROR                                  = 0x80155480; // unspecified svctunnel error
        public const uint XONLINE_E_SVCTUNNEL_TIMEOUT                                = 0x80155481; // svctunnel timeout error
        public const uint XONLINE_E_SVCTUNNEL_GET_USER_INFO_ERROR                    = 0x80155482; // unspecified svctunnel get user info error
        public const uint XONLINE_E_SVCTUNNEL_SEND_USER_FEEDBACK_ERROR               = 0x80155483; // unspecified svctunnel send feedback error
        public const uint XONLINE_E_SVCTUNNEL_GET_GAMERTAG_ERROR                     = 0x80155484; // unspecified svctunnel get gamertag error
        public const uint XONLINE_E_SVCTUNNEL_GET_USER_ID_ERROR                      = 0x80155485; // unspecified svctunnel get user id error
        public const uint XONLINE_E_SVCTUNNEL_GET_FRIENDS_ERROR                      = 0x80155486; // unspecified svctunnel get friends error
        public const uint XONLINE_E_SVCTUNNEL_GET_MESSAGES_ERROR                     = 0x80155487; // unspecified svctunnel get messages error
        public const uint XONLINE_E_SVCTUNNEL_FRIEND_REQUEST_ERROR                   = 0x80155488; // unspecified svctunnel friend request error
        public const uint XONLINE_E_SVCTUNNEL_GAME_INVITE_ERROR                      = 0x80155489; // unspecified svctunnel game invite error
        public const uint XONLINE_E_SVCTUNNEL_MUTE_USER_ERROR                        = 0x8015548A; // unspecified svctunnel mute user error
        public const uint XONLINE_E_SVCTUNNEL_SET_NOTIFICATION_ERROR                 = 0x8015548B; // unspecified svctunnel set notification error

        //
        // XCrypto HRESULTS                                                          = 0x801555XX
        //
        public const uint XONLINE_E_XCRYPTO_ERROR                                    = 0x80155500;   // Generic error
        public const uint XONLINE_E_XCRYPTO_CONFIG_ERROR                             = 0x80155501;   // NPDB configuration error.
        public const uint XONLINE_E_XCRYPTO_KEY_ERROR                                = 0x80155502;   // Error creating crypto key.
        public const uint XONLINE_E_XCRYPTO_CACHE_ERROR                              = 0x80155503;   // Error creating / refreshing a cache.  Most likely due to a key error.
        public const uint XONLINE_E_XCRYPTO_REQUEST_FAILED                           = 0x80155504;   // An xcrypto request has failed.
        public const uint XONLINE_E_XCRYPTO_NCIPHER_ERROR                            = 0x80155505;   // Error calling down into nCipher wrap, which goes down to the nCipher hardware device.

        //
        // Messaging Service HRESULTS                                                = 0x80155AXX
        //
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_ID                       = 0x80155A01;   // the specified message was not found
        public const uint XONLINE_E_MESSAGE_PROPERTY_DOWNLOAD_REQUIRED               = 0x80155A02;   // the property was too large to fit into the details block, it must be retrieved separately using XOnlineMessageDownloadAttachmentxxx
        public const uint XONLINE_E_MESSAGE_PROPERTY_NOT_FOUND                       = 0x80155A03;   // the specified property tag was not found
        public const uint XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE                 = 0x80155A04;   // no valid sends to revoke were found
        public const uint XONLINE_E_MESSAGE_NO_MESSAGE_DETAILS                       = 0x80155A05;   // the specified message does not have any details
        public const uint XONLINE_E_MESSAGE_INVALID_TITLE_ID                         = 0x80155A06;   // an invalid title ID was specified
        public const uint XONLINE_E_MESSAGE_SENDER_BLOCKED                           = 0x80155A07;   // a send failed because the recipient has blocked the sender
        public const uint XONLINE_E_MESSAGE_MAX_DETAILS_SIZE_EXCEEDED                = 0x80155A08;   // the property couldn't be added because the maximum details size would be exceeded
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_TYPE                     = 0x80155A09;
        public const uint XONLINE_E_MESSAGE_USER_OPTED_OUT                           = 0x80155A0A;
        public const uint XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES                  = 0x80155A0B;   // the sender does not have permissions to send this message
        public const uint XONLINE_E_MESSAGE_UNDELIVERABLE                            = 0x80155A0C;   // the recipient does not have permissions to receive this message
        public const uint XONLINE_E_MESSAGE_THROTTLED                                = 0x80155A0D;  // the sender has sent too many messages today.
        // Success codes returned by Messages                                        = 0x00155AXX
        public const uint XONLINE_S_MESSAGE_PENDING_SYNC                             = 0x00155A01;   // updated message list is currently being retrieved (after logon or disabling summary refresh), returned results may be out of date

        //
        // Errors returned by uodb procs                                             = 0x801560XX
        //
        public const uint XONLINE_E_UODB_KEY_ALREADY_EXISTS                          = 0x80156000;  // service key already exists when attempting to insert key
        public const uint XONLINE_E_UODB_INEXISTENT_TITLE_ID                         = 0x80156001;
        public const uint XONLINE_E_UODB_KEY_NOT_FOUND                               = 0x80156002;
        public const uint XONLINE_E_SERVICE_KEY_NOT_FOUND                            = 0x80156002;
        public const uint XONLINE_E_UODB_INEXISTENT_OFFER_ID                         = 0x80156003;
        public const uint XONLINE_E_SERVICE_KEY_IMPORT_ERROR                         = 0x80156004;
        public const uint XONLINE_E_UODB_INVALID_SUBSCRIPTION_PAYMENT_TYPE           = 0x80156005;
        public const uint XONLINE_E_UODB_DUPLICATE_SUBSCRIPTION_INFO                 = 0x80156006;

        //
        // Query service HRESULTS                                                    = 0x801561XX
        //
        public const uint XONLINE_E_QUERY_ERROR                                      = 0x80156100; // unspecified query error
        public const uint XONLINE_E_QUERY_QUOTA_FULL                                 = 0x80156101; // this user or team's quota for the dataset is full.  you must remove an entity first.
        public const uint XONLINE_E_QUERY_ENTITY_NOT_FOUND                           = 0x80156102; // the requested entity didn't exist in the provided dataset.
        public const uint XONLINE_E_QUERY_PERMISSION_DENIED                          = 0x80156103; // the user tried to update or delete an entity that he didn't own.
        public const uint XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG                         = 0x80156104; // attribute passed exceeds schema definition
        public const uint XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE                       = 0x80156105; // attribute passed was a bad param for the database operation
        public const uint XONLINE_E_QUERY_RETHROW_ERROR                              = 0x80156106; // rethrow the original exception (used internally only)
        public const uint XONLINE_E_QUERY_INVALID_ACTION                             = 0x80156107; // the specified action (or dataset) doesn't have a select action associated with it.
        public const uint XONLINE_E_QUERY_SPEC_COUNT_MISMATCH                        = 0x80156108; // the provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure
        public const uint XONLINE_E_QUERY_DATASET_NOT_FOUND                          = 0x80156109; // The specified dataset id was not found.
        public const uint XONLINE_E_QUERY_PROCEDURE_NOT_FOUND                        = 0x8015610A; // The specified proc index was not found.
        public const uint XONLINE_E_QUERY_DUPLICATE_ENTRY                            = 0x8015610B; // An entry already exists that conflicts with the unique data index specified for this dataset
        public const uint XONLINE_E_QUERY_RETRY                                      = 0x8015610C; // Retry if possible

        //
        // Competitions plugin HRESULTS                                              = 0x801562XX
        //
        public const uint XONLINE_E_COMP_ERROR                                       = 0x80156200; // Unspecified comp error
        public const uint XONLINE_E_COMP_ACCESS_DENIED                               = 0x80156202; // The specified source (client) is not permitted to execute this method
        public const uint XONLINE_E_COMP_REGISTRATION_CLOSED                         = 0x80156203; // The competition is closed to registration
        public const uint XONLINE_E_COMP_FULL                                        = 0x80156204; // The competition has reached it's max enrollment
        public const uint XONLINE_E_COMP_NOT_REGISTERED                              = 0x80156205; // The user or team isn't registered for the competition
        public const uint XONLINE_E_COMP_CANCELLED                                   = 0x80156206; // The competition has been cancelled, and the operation is invalid.
        public const uint XONLINE_E_COMP_CHECKIN_TIME_INVALID                        = 0x80156207; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_CHECKIN_BAD_EVENT                           = 0x80156208; // The user is attempting to checkin to an event in which they are not a valid participant.
        public const uint XONLINE_E_COMP_CHECKIN_EVENT_SCORED                        = 0x80156209; // The user is attempting to checkin to an event which has already been scored by the service (user has forfeited or been ejected)
        public const uint XONLINE_S_COMP_CHECKIN_EVENT_SCORED                        = 0x00156209; // The user is attempting to checkin to an event but the users event has been updated. Re-query for a new event
        public const uint XONLINE_E_COMP_UNEXPECTED                                  = 0x80156210; // Results from the Database are unexpected or inconsistent with the current operation.
        public const uint XONLINE_E_COMP_TOPOLOGY_ERROR                              = 0x80156216; // The topology request cannot be fulfilled by the server
        public const uint XONLINE_E_COMP_TOPOLOGY_PENDING                            = 0x80156217; // The topology request has not completed yet
        public const uint XONLINE_E_COMP_CHECKIN_TOO_EARLY                           = 0x80156218; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_ALREADY_REGISTERED                          = 0x80156219; // The user has already registered for this competition
        public const uint XONLINE_E_COMP_INVALID_ENTRANT_TYPE                        = 0x8015621A; // A team was specified for a non-team competition, or a user was specified for a team competition
        public const uint XONLINE_E_COMP_TOO_LATE                                    = 0x8015621B; // The time alloted for performing the requested action has already passed.
        public const uint XONLINE_E_COMP_TOO_EARLY                                   = 0x8015621C; // The specified action cannot yet be peformed.
        public const uint XONLINE_E_COMP_NO_BYES_AVAILABLE                           = 0x8015621D; // No byes remain to be granted
        public const uint XONLINE_E_COMP_SERVICE_OUTAGE                              = 0x8015621E; // A service outage has occured, try again in a bit
        public const uint XONLINE_S_COMP_SERVICE_OUTAGE                              = 0x0000000F; // A service outage was detected, evevnts were successfully rescheduled.  (used by cron/logging only)

        //
        // v1 Message Service HRESULTS                                               = 0x801570XX
        //
        public const uint XONLINE_E_MSGSVR_INVALID_REQUEST                           = 0x80157001; // request type was not one of the expected values

        //
        // String Service HRESULTS                                                   = 0x801571XX
        //
        public const uint XONLINE_E_STRING_ERROR                                     = 0x80157100;  // unspecified error
        public const uint XONLINE_E_STRING_TOO_LONG                                  = 0x80157101; // the string was longer than the allowed maximum
        public const uint XONLINE_E_STRING_OFFENSIVE_TEXT                            = 0x80157102; // the string contains offensive text
        public const uint XONLINE_E_STRING_NO_DEFAULT_STRING                         = 0x80157103; // returned by AddString when no string of the language specified as the default is found
        public const uint XONLINE_E_STRING_INVALID_LANGUAGE                          = 0x80157104; // returned by AddString when an invalid language is specified for a string
        public const uint XONLINE_E_STRING_LANGUAGE_DUPLICATE                        = 0x80157105; // returned by AddString when a language is specified more than once in a single request
        public const uint XONLINE_E_STRING_ADD_STRING_ERROR                          = 0x80157106;  // unspecified error in stringsvr add string
        public const uint XONLINE_E_STRING_GET_STRING_ERROR                          = 0x80157107;  // unspecified error in stringsvr get string
        public const uint XONLINE_E_STRING_LOAD_STRING_ERROR                         = 0x80157108;  // unspecified error in stringsvr load string
        public const uint XONLINE_E_STRING_LOG_STRING_ERROR                          = 0x80157109;  // unspecified error in stringsvr log string
        public const uint XONLINE_E_STRING_TITLE_ID_ERROR                            = 0x8015710A;  // unspecified error in stringsvr v1titleid
        public const uint XONLINE_E_STRING_VET_STRING_ERROR                          = 0x8015710B;  // unspecified error in stringsvr vet string

        //
        // Alerts Service HRESULTS                                                   = 0x801572XX
        //
        public const uint XONLINE_E_ALERTS_SUBSCRIPTION_NOT_FOUND                    = 0x80157201;   // user attempted to operate on a subscriptionid not present in the DB
        public const uint XONLINE_E_ALERTS_SUBSCRIBER_NOT_FOUND                      = 0x80157202;   // user attempted to operate on a subscriber not present in the DB

        //
        // Support (cxsuppapi) Service HRESULTS                                      = 0x801573XX
        //
        public const uint XONLINE_E_SUPPORT_ERROR                                    = 0x80157300;   // unspecified support error

        //
        // Feedback Service HRESULTS                                                 = 0x801580XX
        //
        public const uint XONLINE_E_FEEDBACK_ERROR                                   = 0x80158000;
        public const uint XONLINE_E_FEEDBACK_NULL_TARGET                             = 0x80158001;
        public const uint XONLINE_E_FEEDBACK_BAD_TYPE                                = 0x80158002;
        public const uint XONLINE_E_FEEDBACK_USER_NOT_FOUND                          = 0x80158003;
        public const uint XONLINE_E_FEEDBACK_CANNOT_LOG                              = 0x80158006;
        public const uint XONLINE_E_FEEDBACK_REVIEW_INVALID                          = 0x80158007;
        public const uint XONLINE_E_FEEDBACK_DATABASE_ERROR                          = 0x80158008;
        public const uint XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED                   = 0x80158009;
        public const uint XONLINE_E_FEEDBACK_GET_AGGREGATE_REVIEW_ERROR              = 0x8015800A;
        public const uint XONLINE_E_FEEDBACK_USER_NOT_PRESENT                        = 0x8015800B;
        public const uint XONLINE_E_FEEDBACK_SUBMIT_COMPLAINT_ERROR                  = 0x8015800C;
        public const uint XONLINE_E_FEEDBACK_SUBMIT_REVIEW_ERROR                     = 0x8015800D;

        //
        // Lists Service HRESULTS                                                    = 0x801581XX
        //
        public const uint XONLINE_E_LISTS_ERROR                                      = 0x80158100; // non-specific (catch-all) component error
        public const uint XONLINE_E_LISTS_PROPERTIES_TOO_LONG                        = 0x80158101; // list properties XML exceeds maximum length (1000)
        public const uint XONLINE_E_LISTS_INVALID_XML                                = 0x80158102; // XML failed schema validation
        public const uint XONLINE_E_LISTS_MALFORMED_XML                              = 0x80158103; // XML not well-formed
        public const uint XONLINE_E_LISTS_ID_MUST_BE_WILDCARD                        = 0x80158104; // list ID must be wildcard when list type is wildcard
        public const uint XONLINE_E_LISTS_ITEM_TOO_LONG                              = 0x80158105; // list item XML exceeds maximum length
        public const uint XONLINE_E_LISTS_DUPLICATE_IDS                              = 0x80158106; // arguments contain duplicate item IDs
        public const uint XONLINE_E_LISTS_EMPTY_PARAMETER                            = 0x80158107; // null or empty parameter array
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST_TYPE                      = 0x80158108; // nonexistent list type
        public const uint XONLINE_E_LISTS_TOO_MANY_INSTANCES                         = 0x80158109; // new list would exceed maximum instances
        public const uint XONLINE_E_LISTS_NAME_TOO_LONG                              = 0x8015810A; // list name exceeds maximum length (100)
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST                           = 0x80158110; // nonexistent list instance
        public const uint XONLINE_E_LISTS_TOO_MANY_ITEMS                             = 0x80158111; // new items would exceed maximum items
        public const uint XONLINE_E_LISTS_DUPLICATE_ITEM                             = 0x80158112; // item with given ID already exists in the list
        public const uint XONLINE_E_LISTS_NONEXISTENT_ITEM                           = 0x80158113; // nonexistent list item
        public const uint XONLINE_E_LISTS_DUPLICATE_INDEX                            = 0x80158114; // duplicate index given
        public const uint XONLINE_E_LISTS_INVALID_INDEX                              = 0x80158115; // invalid index given
        public const uint XONLINE_E_LISTS_DUPLICATE_LIST                             = 0x80158116; // user already has list with given name
        public const uint XONLINE_E_LISTS_INVALID_PAGE_SIZE                          = 0x80158117; // invalid page size (1 <= pageSize <= max results)
        public const uint XONLINE_E_LISTS_INCONSISTENT_VIEW                          = 0x80158118; // timestamp argument does not match list timestamp
        public const uint XONLINE_E_LISTS_INVALID_ORDER                              = 0x80158119; // invalid order direction (1 ascending, 2 descending)
        public const uint XONLINE_E_LISTS_API_MISMATCH                               = 0x80158120; // lists of this type should use a different API set

        public const uint XONLINE_E_LISTS_CREATE_LIST_ERROR                          = 0x80158180; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_ITEMS_ERROR                         = 0x80158181; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_LIST_ERROR                          = 0x80158182; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_GRANT_ACCESS_ERROR                         = 0x80158183; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_INSERT_ITEMS_ERROR                         = 0x80158184; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_ITEMS_ERROR                         = 0x80158185; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_LIST_ERROR                          = 0x80158186; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_ITEMS_ERROR                          = 0x80158187; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_LISTS_ERROR                          = 0x80158188; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_REVOKE_ACCESS_ERROR                        = 0x80158189; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MOVE_ITEMS_ERROR                           = 0x8015818A; // non-specific (catch-all) api error

        public const uint XONLINE_E_DOWNLOAD_QUEUE_CREATE_QUEUE_ERROR                = 0x801581C0; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_ITEMS_ERROR                = 0x801581C1; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_QUEUE_ERROR                = 0x801581C2; // non-specific (catch-all) api error (not used)
        public const uint XONLINE_E_DOWNLOAD_QUEUE_GRANT_ACCESS_ERROR                = 0x801581C3; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_INSERT_ITEMS_ERROR                = 0x801581C4; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_ITEMS_ERROR                = 0x801581C5; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_QUEUE_ERROR                = 0x801581C6; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_ITEMS_ERROR                 = 0x801581C7; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_QUEUES_ERROR                = 0x801581C8; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_REVOKE_ACCESS_ERROR               = 0x801581C9; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MOVE_ITEMS_ERROR                  = 0x801581CA; // non-specific (catch-all) api error

        //
        // Stats HRESULTS                                                            = 0x801590XX
        //
        public const uint XONLINE_E_STAT_ERROR                                       = 0x80159000;  // unspecified stat error
        public const uint XONLINE_E_STAT_BAD_REQUEST                                 = 0x80159001;  // server received incorrectly formatted request.
        public const uint XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD                = 0x80159002;  // title or leaderboard id were not recognized by the server.
        public const uint XONLINE_E_STAT_USER_NOT_FOUND                              = 0x80159003;  // user not found.
        public const uint XONLINE_E_STAT_TOO_MANY_SPECS                              = 0x80159004;  // too many stat specs in a request.
        public const uint XONLINE_E_STAT_TOO_MANY_STATS                              = 0x80159005;  // too manu stats in a spec.
        public const uint XONLINE_E_STAT_SET_FAILED_0                                = 0x80159100;  // set operation failed on spec index 0
        public const uint XONLINE_E_STAT_PERMISSION_DENIED                           = 0x80159200;  // operation failed because of credentials. UserId is not logged in or this operation is not supported in production (e.g. userId=0 in XOnlineStatReset)
        public const uint XONLINE_E_STAT_LEADERBOARD_WAS_RESET                       = 0x80159201;  // operation failed because user was logged on before the leaderboard was reset.
        public const uint XONLINE_E_STAT_INVALID_ATTACHMENT                          = 0x80159202;  // attachment is invalid.
        public const uint XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT                       = 0x00159203;  // Use XOnlineStatWriteGetResults to get a handle to upload a attachment.
        public const uint XONLINE_E_STAT_TOO_MANY_PARAMETERS                         = 0x80159204;
        public const uint XONLINE_E_STAT_TOO_MANY_PROCEDURES                         = 0x80159205;
        public const uint XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS                       = 0x80159208;
        public const uint XONLINE_E_STAT_INVALID_PROCEDURE                           = 0x80159209;
        public const uint XONLINE_E_STAT_EXCEEDED_WRITE_READ_LIMIT                   = 0x8015920a;
        public const uint XONLINE_E_STAT_LEADERBOARD_READONLY                        = 0x8015920b;
        public const uint XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW                 = 0x8015920c;
        public const uint XONLINE_E_STAT_READ_NO_SPEC                                = 0x8015920d;
        public const uint XONLINE_E_STAT_MUSIGMA_NO_GAME_MODE                        = 0x8015920e;  // no game mode found for this leaderboard
        public const uint XONLINE_E_STAT_MISSING_RESULTS                             = 0x8015920f;  // not enough results returned from lb server
        public const uint XONLINE_E_STAT_EXTRA_RESULTS                               = 0x80159210;  // too many results returned from lb server
        public const uint XONLINE_E_STAT_SERVER_NOT_FOUND                            = 0x80159211;  // server not found
        public const uint XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED                  = 0x80159212;  // achievements not supported for title/platform
        public const uint XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED                 = 0x80159213;  // avatar assets not supported for title/platform
        public const uint XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED                  = 0x80159214;  // console audit list not supported for platform
        public const uint XONLINE_E_STAT_CONSOLE_LIST_EMPTY                          = 0x80159215;  // console audit list is empty

        //
        // XSUPPAPI HRESULTS                                                         = 0x8015A0XX
        //
        public const uint XSUPP_E_EMAIL_ALREADY_SENT                                 = 0x8015A000;
        public const uint XSUPP_E_INVALID_PUID_OR_SUB                                = 0x8015A001;
        public const uint XSUPP_E_INVALID_EMAIL_SENT_DATE                            = 0x8015A002;
        public const uint XSUPP_E_INVALID_SUBSCRIPTION_CODE                          = 0x8015A003;
        public const uint XSUPP_E_USER_DOES_NOT_OWN_OFFER                            = 0x8015A004;
        public const uint XSUPP_E_TOO_MANY_EXTRA_LICENSES                            = 0x8015A005;
        public const uint XSUPP_E_LICENSE_INCREMENT_GENERIC_ERROR                    = 0x8015A006;
        public const uint XSUPP_E_OWNER_PASSPORT_SWAP_CHILD_ONLY                     = 0x8015A007;
        public const uint XSUPP_E_NO_NEW_PASSPORT_SPECIFIED                          = 0x8015A008;
        public const uint XSUPP_E_USER_PASSPORT_SWAP                                 = 0x8015A009;
        public const uint XSUPP_E_OWNER_PASSPORT_SWAP                                = 0x8015A00A;
        public const uint XSUPP_E_USER_DATE_OF_BIRTH_SWAP                            = 0x8015A00B;
        public const uint XSUPP_E_NEW_PASSPORT_MEMBER_NAME_MISMATCH                  = 0x8015A00C;
        public const uint XSUPP_E_INVALID_NEW_PASSPORT_MEMBER_NAME                   = 0x8015A00D;
        public const uint XSUPP_E_MULTIPLE_CREDENTIALS_FOR_THIS_MEMBER_NAME          = 0x8015A00E;
        public const uint XSUPP_E_USER_NOT_FOUND                                     = 0x8015A00F;
        public const uint XSUPP_E_USER_MACHINE_NOT_FOUND                             = 0x8015A010;
        public const uint XSUPP_E_USER_UNIQUE_MACHINE_NOT_FOUND                      = 0x8015A011;

        //
        // Signature Service HRESULTS                                                = 0x8015b0XX
        //
        public const uint XONLINE_E_SIGNATURE_ERROR                                  = 0x8015b000;   // unspecified signature error
        public const uint XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE                  = 0x8015b001;   // presented signature does not match
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER                    = 0x8015b002;   // signature key version specified is not found among the valid signature keys
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER              = 0x8015b003;   // signature version is unknown, currently only version 1 is supported
        public const uint XONLINE_E_SIGNATURE_BANNED_XBOX                            = 0x8015b004;   // signature is not calculated or revoked because Xbox is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_USER                            = 0x8015b005;   // signature is not calculated or revoked because at least one user is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_TITLE                           = 0x8015b006;   // signature is not calculated or revoked because the given title and version is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_DIGEST                          = 0x8015b007;   // signature is not calculated or revoked because the digest is banned
        public const uint XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA                      = 0x8015b008;   // fail to retrieve AuthData from SG, returned by GetSigningKey api
        public const uint XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE                    = 0x8015b009;   // fail to retrieve a signature server master key, returned by GetSigningKey or SignOnBehalf api
        public const uint XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE                 = 0x8015b00a;   // AcquireMediaLicenses will not be able to acquire the license without a state change (like repurchase)
        public const uint XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED                 = 0x8015B00B;   // The user already has the limit of licenses allowed.
        public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND           = 0x8015B00C;   // Tried to send a command that is inconsistent with the curent state of the transfer.
//      public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_UNAUTHORIZED          = 0x8015B00D;   // The user requesting a transfer is not authorized due to a missing profile setting.
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_INVALID                    = 0x8015B00E;   // this is what we return to the user for invalid certificates
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_USAGE_INVALID              = 0x8015B00F;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_CHAIN_INVALID              = 0x8015B010;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_EXPIRED                    = 0x8015B011;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_EMPTY            = 0x8015B012;   // The playready device certificate we generated is empty (internal only)
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_TOO_BIG          = 0x8015B013;   // The playready device certificate we generated is too big (internal only)
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_FAILED           = 0x8015B014;   // Failed to generate a playready device certificate. This is what we return to the caller.

        // non-specific (catch-all) signature API errors
        public const uint XONLINE_E_SIGNATURE_ACKNOWLEDGE_LICENSE_DELIVERY_ERROR     = 0x8015b080; // non-specific acknowldege license delivery error
        public const uint XONLINE_E_SIGNATURE_ACQUIRE_MEDIA_LICENSES_ERROR           = 0x8015b081; // non-specific acquire media licenses error
        public const uint XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR               = 0x8015b082; // non-specific create certificate error
        public const uint XONLINE_E_SIGNATURE_GET_AA_INFO_ERROR                      = 0x8015b083; // non-specific get aa info error
        public const uint XONLINE_E_SIGNATURE_GET_SIGNED_HEADER_ERROR                = 0x8015b084; // non-specific get signed header error
        public const uint XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR        = 0x8015b085; // non-specific generate license response error
        public const uint XONLINE_E_SIGNATURE_REFRESH_GAME_LICENSE_ERROR             = 0x8015b086; // non-specific refresh game license error
        public const uint XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR           = 0x8015b087; // non-specific transfer user licenses error
        public const uint XONLINE_E_SIGNATURE_VALIDATE_CERTIFICATE_ERROR             = 0x8015b089; // non-specific validate certificate error

        //
        // Arbitration HRESULTS                                                      = 0x8015b1XX
        //
        public const uint XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE                  = 0x8015b101; // Service temporarily unavailable
        public const uint XONLINE_E_ARBITRATION_INVALID_REQUEST                      = 0x8015b102; // The request is invalidly formatted
        public const uint XONLINE_E_ARBITRATION_SESSION_NOT_FOUND                    = 0x8015b103; // The session is not found or has expired
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_FLAGS_MISMATCH          = 0x8015b104; // The session was registered with different flags by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_SESSION_TIME_MISMATCH   = 0x8015b105; // The session was registered with a different session time by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_TOO_LATE                = 0x8015b106; // Registration came too late, the session has already been arbitrated
        public const uint XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST               = 0x8015b107; // Must register in seesion first, before any other activity
        public const uint XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED           = 0x8015b108; // Time extension of this session not allowed, or session is already arbitrated
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS                   = 0x8015b109; // Inconsistent flags are used in the request
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_COMPETITION_STATUS      = 0x8015b10A; // Whether the session is a competition is inconsistent between registration and report
        public const uint XONLINE_E_ARBITRATION_REPORT_ALREADY_CALLED                = 0x8015b10B; // Report call for this session already made by this client
        public const uint XONLINE_E_ARBITRATION_TOO_MANY_XBOXES_IN_SESSION           = 0x8015b10C; // Only up to 255 Xboxes can register in a session
        public const uint XONLINE_E_ARBITRATION_1_XBOX_1_USER_SESSION_NOT_ALLOWED    = 0x8015b10D; // Single Xbox single user sessions should not be arbitrated
        public const uint XONLINE_E_ARBITRATION_REPORT_TOO_LARGE                     = 0x8015b10E; // The stats or query submission is too large
        public const uint XONLINE_E_ARBITRATION_INVALID_TEAMTICKET                   = 0x8015b10F; // An invalid team ticket was submitted

        //
        // Arbitration success HRESULTS
        //
        public const uint XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED               = 0x0015b1F0; // Invalid/duplicate Xbox specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_INVALID_USER_SPECIFIED               = 0x0015b1F1; // Invalid/duplicate user specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED           = 0x0015b1F2; // Differing result submissions have been detected in this session. Never the less, this report submission is accepted

        //
        // Storage Service HRESULTS                                                  = 0x8015C0XX
        //
        public const uint XONLINE_E_STORAGE_ERROR                                    = 0x8015c000; // non-specific storage error
        public const uint XONLINE_E_STORAGE_INVALID_REQUEST                          = 0x8015c001; // Request is invalid
        public const uint XONLINE_E_STORAGE_ACCESS_DENIED                            = 0x8015c002; // Client doesn't have the rights to upload the file
        public const uint XONLINE_E_STORAGE_FILE_IS_TOO_BIG                          = 0x8015c003; // File is too big
        public const uint XONLINE_E_STORAGE_FILE_NOT_FOUND                           = 0x8015c004; // File not found
        public const uint XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN                     = 0x8015c005; // Access token signature is invalid
        public const uint XONLINE_E_STORAGE_CANNOT_FIND_PATH                         = 0x8015c006; // name resolution failed
        public const uint XONLINE_E_STORAGE_FILE_IS_ELSEWHERE                        = 0x8015c007; // redirection request
        public const uint XONLINE_E_STORAGE_INVALID_STORAGE_PATH                     = 0x8015c008; // Invalid storage path
        public const uint XONLINE_E_STORAGE_INVALID_FACILITY                         = 0x8015c009; // Invalid facility code
        public const uint XONLINE_E_STORAGE_UNKNOWN_DOMAIN                           = 0x8015c00A; // Name resolver has no idea where to send you.
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW                           = 0x8015c00B; // SyncDomain timestamp skew
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW_LOCALTIME                 = 0x8015c00C; // SyncDomain timestamp appears to be localtime
        public const uint XONLINE_E_STORAGE_QUOTA_EXCEEDED                           = 0x8015c00D; // Quota exceeded for storage domain
        public const uint XONLINE_E_STORAGE_FILE_ALREADY_EXISTS                      = 0x8015c011; // File already exists and storage domain does not allow overwrites
        public const uint XONLINE_E_STORAGE_DATABASE_ERROR                           = 0x8015c012; // Unknown database error
        public const uint XONLINE_S_STORAGE_FILE_NOT_MODIFIED                        = 0x0015c013; // File hasn't been modified since given date
        public const uint XONLINE_E_STORAGE_INVALID_PATH                             = 0x8015c014; // Invalid file path
        public const uint XONLINE_E_STORAGE_TITLE_FILES_NOT_FOUND                    = 0x8015c015; // No storage files were found for the specified title

        //
        // Live Info Service HRESULTS                                                = 0x8015C1XX
        //
        public const uint XONLINE_E_LIVEINFO_ERROR                                   = 0x8015C100;
        public const uint XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG                     = 0x8015c101; // Config name is invalid
        public const uint XONLINE_E_LIVEINFO_HIVE_ERROR_LOADING_CONFIG               = 0x8015C102; // Error occured loading config
        public const uint XONLINE_E_LIVEINFO_CLIENT_ERROR                            = 0x8015C103; // General error for client failures

        //
        // Lsp HRESULTS                                                              = 0x8015C2xx
        //
        public const uint XONLINE_E_LSP_ERROR                                        = 0x8015C200;
        public const uint XONLINE_E_LSP_BUCKET_INTERFACE_CONFIG_ERROR                = 0x8015C201; // Bucket Interface not configured

        //
        // Passport HRESULTS (mapped from idsapi/passport return codes) 0x8015d0XX
        //
        public const uint XONLINE_E_PASSPORT_ERROR                                   = 0x8015d000; // generic passport error for when we can't find a mapping
        public const uint XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN                      = 0x8015d001; // Failed to create passport: name already taken
        public const uint XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD                  = 0x8015d002; // Wrong password and/or membername dose not exist.
        public const uint XONLINE_E_PASSPORT_LOCKED_OUT                              = 0x8015d003; // The credential is locked out.
        public const uint XONLINE_E_PASSPORT_FORCE_RENAME                            = 0x8015d004; // The credential is in a forced renamed state
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_PASSWORD                   = 0x8015d005; // The password has to be changed.
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_SQ_SA                      = 0x8015d006; // The secret question and answer has to be changed.
        public const uint XONLINE_E_PASSPORT_PASSWORD_EXPIRED                        = 0x8015d007; // The password for the account has expired.
        public const uint XONLINE_E_PASSPORT_REQUIRE_EMAIL_VALIDATION                = 0x8015d008; // The account is blocked pending email address validation.
        public const uint XONLINE_E_FORBIDDEN_WORD                                   = 0x8015d009; // String contained words that are forbidden by namespace administrator, examine input.
        public const uint XONLINE_E_PASSWORD_BLANK                                   = 0x8015d00a; // The password is blank.
        public const uint XONLINE_E_PASSWORD_TOO_SHORT                               = 0x8015d00b; // The password is too short
        public const uint XONLINE_E_PASSWORD_TOO_LONG                                = 0x8015d00c; // The password is too long
        public const uint XONLINE_E_PASSWORD_CONTAINS_MEMBER_NAME                    = 0x8015d00d; // The password contains the member name.
        public const uint XONLINE_E_PASSWORD_CONTAINS_INVALID_CHARACTERS             = 0x8015d00e; // The password contains invalid characters.
        public const uint XONLINE_E_SQ_CONTAINS_PASSWORD                             = 0x8015d00f; // The secret question contains the password.
        public const uint XONLINE_E_SA_CONTAINS_PASSWORD                             = 0x8015d010; // The answer for the secret question contains the password.
        public const uint XONLINE_E_PASSWORD_CONTAINS_SA                             = 0x8015d011; // The password validation code detected the answer to the secret question in the password.
        public const uint XONLINE_E_SQ_CONTAINS_SA                                   = 0x8015d015; // The secret question contains the answer.
        public const uint XONLINE_E_SA_TOO_SHORT                                     = 0x8015d017;
        public const uint XONLINE_E_SA_CONTAINS_SQ                                   = 0x8015d018; // The answer to the secret question contains that question.
        public const uint XONLINE_E_SA_CONTAINS_MEMBER_NAME                          = 0x8015d019; // The answer for the secret question contains the member name.
        public const uint XONLINE_E_MEMBER_NAME_TOO_SHORT                            = 0x8015d01a; // The signin name is too short.
        public const uint XONLINE_E_MEMBER_NAME_INVALID                              = 0x8015d01b; // The signin name is incomplete or has invalid characters.
        public const uint XONLINE_E_PASSPORT_INVALID_DOMAIN                          = 0x8015d01c; // Cannot create EASI passport on reserved domain (e.g. hotmail.com)
        public const uint XONLINE_E_PASSPORT_INVALID_POSTAL_CODE                     = 0x8015d01d; // The postal code specified is invalid
        public const uint XONLINE_E_PASSPORT_SQ_TOO_SHORT                            = 0x8015d01f; // Secret question is too short
        public const uint XONLINE_E_PASSPORT_SQ_TOO_LONG                             = 0x8015d020; // Secret question is too long
        public const uint XONLINE_E_PASSPORT_KIDS_ACCOUNT_NO_CONSENT                 = 0x8015d021; // The PP Kids account does not have consent
        public const uint XONLINE_E_PASSPORT_SITE_NOT_AUTHORIZED                     = 0x8015d022; // xbox live service is not authorized to call the passport api

        // errors above are translations of passport errors
        // update PassportHelper.IsUserError() as necessary
        // errors below are xonline error codes

        public const uint XONLINE_E_PASSPORT_INVALID_ID                              = 0x8015d080; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_INVALID_RESPONSE                        = 0x8015d081; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_TOO_MANY_SECRET_QUESTIONS               = 0x8015d082; // too many secret questions
        public const uint XONLINE_E_PASSPORT_TIMEOUT                                 = 0x8015d083; // timeout talking to passport
        public const uint XONLINE_E_PASSPORT_NO_SECRET_QUESTIONS                     = 0x8015d084; // no secret questions for country and language
        public const uint XONLINE_E_PASSPORT_NO_DATA                                 = 0x8015d085; // passport could not find any data to return
        public const uint XONLINE_E_PASSPORT_ASM_KEY_NOT_FOUND                       = 0x8015d086; // key sent to passport is not valid (old version, expired, etc.)


        public const uint XONLINE_E_UPS_ERROR                                        = 0x8015d100; // error talking to UPS
        public const uint XONLINE_E_UPS_TIMEOUT_ERROR                                = 0x8015d101; // timeout error talking to UPS
        public const uint XONLINE_E_UPS_GET_PROFILE_ERROR                            = 0x8015d102; // non-specific (catch-all) error calling get profile
        public const uint XONLINE_E_UPS_UPDATE_PROFILE_ERROR                         = 0x8015d103; // non-specific (catch-all) error calling update profile

        //
        //RATINGS hresults                                                           = Ox8015d2xx
        //
        public const uint XONLINE_E_RATINGS_UNKNOWNERROR                             = 0x8015D200; //Unhandled/unknownError
        public const uint XONLINE_E_RATINGS_INVALID_COUNTRY                          = 0x8015D201; //Invalid country passed
        public const uint XONLINE_E_RATINGS_INVALID_USER                             = 0x8015D203; //Invalid user not presetn in UODB
        public const uint XONLINE_E_RATINGS_INVALID_RATING                           = 0x8015D204; //Invalid Rating value (<0 or >5)
        public const uint XONLINE_E_RATINGS_INVALID_MEDIATYPE                        = 0x8015D205; //Invalid Mediatype which cannot be rated
        public const uint XONLINE_E_RATINGS_MSN_ERROR                                = 0x8015D206; //General Error saving the rating
        public const uint XONLINE_E_RATINGS_UNKNOWNCATALOG_ERROR                     = 0x8015D207; //Unknown Catalog error cannling getbasicmediainfo
        public const uint XONLINE_E_RATINGS_MULTISETTING_ERROR                       = 0x8015D208; //Error getting the Multisettign for ratings mediatypes
        public const uint XONLINE_E_RATINGS_MEDIATYPE_VALIDATION                     = 0x8015D209; //Error validatign the mediatype for ratigns
        public const uint XONLINE_E_RATINGS_ERROR_GETUSER                            = 0x8015D20A; //Error getting the user details
        public const uint XONLINE_E_RATINGS_ERROR_MEDIAGET                           = 0x8015D20B; //Error getting thr Media Information from Catalog
        public const uint XONLINE_E_RATINGS_CONTENTTYPE_SETTING_ERROR                = 0x8015D20C; //Error retrieving contentTypesetting from npdb
        public const uint XONLINE_E_RATINGS_CONTENTTYPE_MAPPING_ERROR                = 0x8015D20D; //Error mapping contentType to Mediatype
        public const uint XONLINE_E_RATINGS_MSN_CONNECTION_ERROR                     = 0x8015D20E; //Error connecting to MSN Ratings service
        public const uint XONLINE_E_RATINGS_CRON_UNKNOWN_ERROR                       = 0x8015D20F; //Unknown Error in MSNRRAverages CRON plug-in
        public const uint XONLINE_E_RATINGS_CRON_SAVE_AVERAGE_ERROR                  = 0x8015D211; //Error saving Rating averages
        public const uint XONLINE_E_RATINGS_CRON_TRANSACTION_DATE_ERROR              = 0x8015D212; //Error retrieving TransactionDate
        public const uint XONLINE_E_RATINGS_CRON_NPDB_SETTING_ERROR                  = 0x8015D213; //Error retrieving npdb setting
        public const uint XONLINE_E_RATINGS_CRON_TRANSACTION_DATE_SAVE_ERROR         = 0x8015D214; //Error saving transaction date
        public const uint XONLINE_E_RATINGS_MISSING_COUNTRY_CODE_ON_GET_MEDIA_INFO   = 0x8015D215; //GetMediaInfo invoked without specifying countryCode when retrieving user aggregate
        public const uint XONLINE_E_RATINGS_MISSING_MEDIA_ID_ON_GET_MEDIA_INFO       = 0x8015D216; //GetMediaInfo invoked with empty/null guid for media id
        public const uint XONLINE_E_RATINGS_INVALID_MEDIA                            = 0x8015D217; //Media Queried for does not exist in the catalog

        //
        //ContentIngestion WebService                                                = 0x8015d3xx
        //
        public const uint XONLINE_E_CONTENTINGESTION_UNKNOWNERROR                    = 0x8015d300; //Unhandled/Unknown Error
        public const uint XONLINE_E_CONTENTINGESTION_INVALIDARGS                     = 0x8015d301; //Invalid Argument Specified


        //
        // Reflector HRESULTS                                                        = 0x8015d4xx
        //
        public const uint XONLINE_E_REFLECTOR_GENERIC_ERROR                          = 0x8015D400; // Generic error
        public const uint XONLINE_E_REFLECTOR_NO_TOKEN                               = 0x8015D401; // The user does not have a token for the specified network Id


        //
        //MigrateUser HRESULTS                                                       = 0x8015d5xx
        //
        public const uint XONLINE_E_MIGRATEUSER_GENERIC_ERROR                        = 0x8015D500; // generic error
        public const uint XONLINE_E_MIGRATEUSER_USER_DOES_NOT_EXIST_ERROR            = 0x8015D501; // specified user does not exist
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_LOAD_USER_ERROR            = 0x8015D502; // failed to load the user for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_WRITE_XML_ERROR            = 0x8015D503; // failed to write the user's data to xml for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_READ_XML_ERROR             = 0x8015D504; // failed to read the user's data from xml for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_CREATE_USER_ERROR          = 0x8015D505; // failed to create the user for some reason.
        public const uint XONLINE_E_MIGRATEUSER_USER_ALREADY_EXISTS_ERROR            = 0x8015D506; // specified user already exists
        public const uint XONLINE_E_MIGRATEUSER_WRITE_TO_PROD_ERROR                  = 0x8015D507; // can't write a user to prod

        //TESTFD hresults                                                            = 0x8015d6xx
        //
        public const uint XONLINE_E_TESTFD_GENERIC_ERROR                             = 0x8015D600; // generic error
        public const uint XONLINE_E_TESTFD_API_NOT_AVAILABLE_ERROR                   = 0x8015D601; // insufficient permissions to access this API
        public const uint XONLINE_E_TESTFD_INVALID_DATABASE_ERROR                    = 0x8015D602; // database specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_TABLE_ERROR                       = 0x8015D603; // table specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_COLUMN_ERROR                      = 0x8015D604; // column specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_VALUE_ERROR                       = 0x8015D605; // value for specified column invalid
        public const uint XONLINE_E_TESTFD_INVALID_SQL_ERROR                         = 0x8015D606; // invalid sql statement
        public const uint XONLINE_E_TESTFD_BAD_COMMAND_ERROR                         = 0x8015D607; // command failed
        public const uint XONLINE_E_TESTFD_COMMAND_TIMEOUT_ERROR                     = 0x8015D608; // command took longer than expected to run
        public const uint XONLINE_E_TESTFD_BAD_PARTITION_ERROR                       = 0x8015D609; // invalid partition parameter
        public const uint XONLINE_E_TESTFD_BAD_PARTITION_HASH_TYPE_ERROR             = 0x8015D60A; // invalid partition hashtype parameter
        public const uint XONLINE_E_TESTFD_SQL_NO_VALUE_ERROR                        = 0x8015D60B; // no value returned for a sql query
        public const uint XONLINE_E_TESTFD_NOT_ENOUGH_TITLES_PROPPED                 = 0x8015D60C; // not enough titles are propped to the environment to fufil the request

        // Social query HRESULTs
        public const uint XONLINE_E_SOCIAL_QUERY_GENERIC_ERROR                       = 0x8015D700; // generic error

        //Cert Grabber hresults                                                      = 0x8015d8xx

        //
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_GET_NEW_CERT              = 0x8015D800; // failed to query/retrieve the latest cert
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_PARSE_NEW_CERT            = 0x8015D801; // failed to parse the latest cert
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_UPDATE_CERT               = 0x8015D802; // failed to update npdb with the latest cert

        //XTOU hresults                                                              = 0x8015d9xx
        //
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_GENERIC_ERROR                 = 0x8015D900; // generic error for GetTermsOfUse
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_URL_PARSE_ERROR               = 0x8015D901; // GetTermsOfUse failed to parse the URL
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_URL_GET_FILE_ERROR            = 0x8015D902; // GetTermsOfUse failed to retrieve a TOU file from the database
        public const uint XONLINE_E_XTOU_GETLANGUAGESFORCOUNTRY_GENERIC_ERROR        = 0x8015D903; // generic error for GetLanguagesForCountry

        //
        // XSTS HRESULTS                                                             = 0x8015DAxx
        //
        public const uint XONLINE_E_XSTS_RST_ACTASSTS                                = 0x8015DA00; // Invalid RST ActAs
        public const uint XONLINE_E_XSTS_RST_ADDITIONALCONTEXT                       = 0x8015DA01; // Invalid RST AdditionalContext
        public const uint XONLINE_E_XSTS_RST_CANCELTARGET                            = 0x8015DA02; // Invalid RST CancelTarget
        public const uint XONLINE_E_XSTS_RST_CLIENTPSEUDONYM                         = 0x8015DA03; // Invalid RST ClientPseudonym
        public const uint XONLINE_E_XSTS_RST_COMPUTEDKEYALGORITHM                    = 0x8015DA04; // Invalid RST ComputedKeyAlgorithm
        public const uint XONLINE_E_XSTS_RST_DELEGATABLE                             = 0x8015DA05; // Invalid RST Delegatable
        public const uint XONLINE_E_XSTS_RST_DELEGATETO                              = 0x8015DA06; // Invalid RST DelegateTo
        public const uint XONLINE_E_XSTS_RST_DISPLAYTOKENLANGUAGE                    = 0x8015DA07; // Invalid RST DisplayTokenLanguage
        public const uint XONLINE_E_XSTS_RST_ENCRYPTION                              = 0x8015DA08; // Invalid RST Encryption
        public const uint XONLINE_E_XSTS_RST_FORWARDABLE                             = 0x8015DA09; // Invalid RST Forwardable
        public const uint XONLINE_E_XSTS_RST_INFORMATIONCARDREFERENCE                = 0x8015DA0A; // Invalid RST InformationCardReference
        public const uint XONLINE_E_XSTS_RST_ISSUER                                  = 0x8015DA0B; // Invalid RST Issuer
        public const uint XONLINE_E_XSTS_RST_ONBEHALFOF                              = 0x8015DA0C; // Invalid RST OnBehalfOf
        public const uint XONLINE_E_XSTS_RST_PARTICIPANTS                            = 0x8015DA0D; // Invalid RST Participants
        public const uint XONLINE_E_XSTS_RST_PROOFENCRYPTION                         = 0x8015DA0E; // Invalid RST ProofEncryption
        public const uint XONLINE_E_XSTS_RST_RENEWING                                = 0x8015DA0F; // Invalid RST Renewing
        public const uint XONLINE_E_XSTS_RST_RENEWTARGET                             = 0x8015DA10; // Invalid RST RenewTarget
        public const uint XONLINE_E_XSTS_RST_REQUESTDISPLAYTOKEN                     = 0x8015DA11; // Invalid RST RequestDisplayToken
        public const uint XONLINE_E_XSTS_RST_SECONDARYPARAMETERS                     = 0x8015DA12; // Invalid RST SecondaryParameters
        public const uint XONLINE_E_XSTS_RST_VALIDATETARGET                          = 0x8015DA13; // Invalid RST ValidateTarget

        public const uint XONLINE_E_XSTS_RST_ALLOWPOSTDATING                         = 0x8015DA20; // Invalid RST AllowPostdating
        public const uint XONLINE_E_XSTS_RST_APPLIESTO                               = 0x8015DA21; // Invalid RST AppliesTo
        public const uint XONLINE_E_XSTS_RST_AUTHENTICATIONTYPE                      = 0x8015DA22; // Invalid RST AuthenticationType
        public const uint XONLINE_E_XSTS_RST_BINARYEXCHANGE                          = 0x8015DA23; // Invalid RST BinaryExchange
        public const uint XONLINE_E_XSTS_RST_CANONICALIZATIONALGORITHM               = 0x8015DA24; // Invalid RST CanonicalizationAlgorithm
        public const uint XONLINE_E_XSTS_RST_ENCRYPTIONALGORITHM                     = 0x8015DA25; // Invalid RST EncryptionAlgorithm
        public const uint XONLINE_E_XSTS_RST_ENCRYPTWITH                             = 0x8015DA26; // Invalid RST EncryptWith
        public const uint XONLINE_E_XSTS_RST_ENTROPY                                 = 0x8015DA27; // Invalid RST Entropy
        public const uint XONLINE_E_XSTS_RST_KEYSIZEINBITS                           = 0x8015DA28; // Invalid RST KeySizeInBits
        public const uint XONLINE_E_XSTS_RST_KEYTYPE                                 = 0x8015DA29; // Invalid RST KeyType
        public const uint XONLINE_E_XSTS_RST_KEYWRAPALGORITHM                        = 0x8015DA2A; // Invalid RST KeyWrapAlgorithm
        public const uint XONLINE_E_XSTS_RST_LIFETIME                                = 0x8015DA2B; // Invalid RST Lifetime
        public const uint XONLINE_E_XSTS_RST_REPLYTO                                 = 0x8015DA2C; // Invalid RST ReplyTo
        public const uint XONLINE_E_XSTS_RST_REQUESTTYPE                             = 0x8015DA2D; // Invalid RST RequestType
        public const uint XONLINE_E_XSTS_RST_SIGNATUREALGORITHM                      = 0x8015DA2E; // Invalid RST SignatureAlgorithm
        public const uint XONLINE_E_XSTS_RST_SIGNWITH                                = 0x8015DA2F; // Invalid RST SignWith
        public const uint XONLINE_E_XSTS_RST_TOKENTYPE                               = 0x8015DA30; // Invalid RST TokenType
        public const uint XONLINE_E_XSTS_RST_USEKEY                                  = 0x8015DA31; // Invalid RST UseKey

        public const uint XONLINE_E_XSTS_CONFIGURATIONPROVIDER_LOAD                  = 0x8015DA40; // Error in configuration provider loading XSts configuration data
        public const uint XONLINE_E_XSTS_LOADCONFIGURATION                           = 0x8015DA41; // General failure loading XSts configuration
        public const uint XONLINE_E_XSTS_CONFIGURATION_NOAPPIESTOES                  = 0x8015DA42; // Configuration data does not contain any AppliesToes or could not be loaded
        public const uint XONLINE_E_XSTS_CONFIGURATION_NOCLAIMPROVIDERS              = 0x8015DA43; // Configuration data does not contain any Claim Providers or could not be loaded
        public const uint XONLINE_E_XSTS_APPLIESTO_NOTFOUND                          = 0x8015DA44; // Token requested for an AppliesTo XSts is not configured to support
        public const uint XONLINE_E_XSTS_PRINCIPAL_NOTAUTHORIZED                     = 0x8015DA45; // Principal not authorized
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_NO_CERTCLAIM       = 0x8015DA46; // Delegation operation invalid. No client cert claim.
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_MULTIPLE_CERTCLAIMS = 0x8015DA47; // Delegation operation invalid. Multiple client cert claims.
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_CLIENTCERT_SALT_MISMATCH = 0x8015DA48; // Delegation operation invalid. Delegation token to client certificate mismatch.
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_NO_PRINCIPAL       = 0x8015DA49; // Delegation operation invalid. No principal.
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_HASXUID            = 0x8015DA4A; // Delegation operation invalid. Principal already has a xuid.
        public const uint XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_HASPUID            = 0x8015DA4B; // Delegation operation invalid. Principal already has a puid.

        public const uint XONLINE_E_XSTS_CONFIG_CP_INVALID                           = 0x8015DA50; // The claim provider descriptor is empty or null
        public const uint XONLINE_E_XSTS_CONFIG_CP_TYPE_INVALID                      = 0x8015DA51; // The claim provider type name is empty or null
        public const uint XONLINE_E_XSTS_CONFIG_CP_ASSEMBLY_INVALID                  = 0x8015DA52; // The claim provider assembly name is empty or null
        public const uint XONLINE_E_XSTS_CONFIG_CP_LOAD_ERROR                        = 0x8015DA53; // The claim provider type could not be loaded from the claim provider assembly
        public const uint XONLINE_E_XSTS_CONFIG_CP_CLAIM_TYPE_NOT_SUPPORTED          = 0x8015DA54; // The claim provider does not support one of the configured claim types
        public const uint XONLINE_E_XSTS_CONFIG_CP_DUPLICATE_CLAIM_TYPE              = 0x8015DA55; // Multiple claim providers offer the same claim type
        
        public const uint XONLINE_E_XSTS_CONFIG_RP_CLAIM_TYPE_NOT_SUPPORTED          = 0x8015DA60; // No claim providers offers the claim configured for the relying party        
        
        public const uint XONLINE_E_XSTS_PROVIDER_GETOUTPUTCLAIMSIDENTITY            = 0x8015DB00; // Exception calling Provider IClaimProvider::GetOutputClaimsIdentity
        public const uint XONLINE_E_XSTS_PROVIDER_SERVICEHOSTOPENED                  = 0x8015DB01; // Exception calling Provider IClaimProvider::ServiceHostOpened
        public const uint XONLINE_E_XSTS_PROVIDER_SERVICEHOSTCLOSED                  = 0x8015DB02; // Exception calling Provider IClaimProvider::ServiceHostClosed


        //
        // Passport RPS HRESULTS
        //
        public const uint XONLINE_E_RPS_NOT_INITIALIZED                              = 0x8015e200; // RPS is not initialized. Other RPS methods can be called only after the RPS.Initialize method has succeeded.
        public const uint XONLINE_E_RPS_FAILED_TO_CREATE_DOM                         = 0x8015e201; // Failed to create DOM object.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR                               = 0x8015e202; // Internal program or unexpected error. Could also be caused by programming or configuration error.
        public const uint XONLINE_E_RPS_INVALID_OBJECT_ID                            = 0x8015e203; // The object ID is invalid. This condition can be caused by an internal RPS error or an error from a custom component.
        public const uint XONLINE_E_RPS_OBJECT_ID_CANNOT_OVERWRITE                   = 0x8015e204; // The object ID cannot be overridden. Custom component only: this error is caused by an attempt to override an object that cannot be overridden.
        public const uint XONLINE_E_RPS_FAILED_TO_TLS                                = 0x8015e205; // TLS (thread local storage) call failed. The system is in a bad state. TlsAlloc failed.
        public const uint XONLINE_E_RPS_XML_FILE_ERROR                               = 0x8015e206; // XML file error. RPS has encountered an invalid XML configuration file.
        public const uint XONLINE_E_RPS_READ_ONLY                                    = 0x8015e207; // Property is read only. This error is caused by an attempt to write to a read-only property bag.
        public const uint XONLINE_E_RPS_SERVER_CONFIG_ALREADY_INITTED                = 0x8015e208; // The server configuration has already been initialized. This condition is caused by an internal RPS error.
        public const uint XONLINE_E_RPS_INVALIDCONFIG                                = 0x8015e209; // Invalid configuration.
        public const uint XONLINE_E_RPS_CERT_NOT_FOUND                               = 0x8015e20a; // Certificate cannot be found. A certificate required for the operation was not found.
        public const uint XONLINE_E_RPS_SKIBUFFER_TOO_SMALL                          = 0x8015e20b; // Buffer for subject key identifier (SKI) is too small. This condition is caused by an internal RPS error or an invalid certificate with a large SKI.
        public const uint XONLINE_E_RPS_FILE_TOO_LARGE                               = 0x8015e20c; // File is too large. This condition is caused by large certificate file. The maximum size is 512 kilobytes.
        public const uint XONLINE_E_RPS_INVALID_DATATYPE                             = 0x8015e20d; // Data type is invalid. The data type is different from the expected data type.
        public const uint XONLINE_E_RPS_MORE_DATA                                    = 0x8015e20e; // Insufficient data buffer.
        public const uint XONLINE_E_RPS_INVALID_SIGNATURE                            = 0x8015e20f; // Signatures do not match.
        public const uint XONLINE_E_RPS_ENCRYPTEDKEY_TOO_LARGE                       = 0x8015e211; // The encrypted key data is too large. The maximum size is 1024 bytes.
        public const uint XONLINE_E_RPS_DATA_INTEGRITY_CHECK_FAILED                  = 0x8015e212; // The data integrity check failed. There was a hash mismatch.
        public const uint XONLINE_E_RPS_CERT_WITHOUT_PRIVATE_KEY                     = 0x8015e214; // The certificate used for decryption did not have private key.
        public const uint XONLINE_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED             = 0x8015e215; // Network configuration cache has already been initialized. Caused by an internal RPS error.
        public const uint XONLINE_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND                   = 0x8015e216; // The requested domain attribute was not found in RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALIDDATA                                  = 0x8015e217; // The data to pack or unpack is not valid RPS data.
        public const uint XONLINE_E_RPS_TICKET_NOT_INITIALIZED                       = 0x8015e218; // Ticket was not initialized.
        public const uint XONLINE_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE  = 0x8015e219; // Ticket has already been initialized. A ticket object cannot be reused.
        public const uint XONLINE_E_RPS_SAML_ASSERTION_MISSINGDATA                   = 0x8015e21a; // A SAML assertion or WebSSO ticket is missing a data member. Invalid assertion.
        public const uint XONLINE_E_RPS_INVALID_TIMEWINDOW                           = 0x8015e21b; // Invalid time window. The time window parameter in the site configuration or supplied as an input parameter is either too large or too small.
        public const uint XONLINE_E_RPS_HTTP_BODY_REQUIRED                           = 0x8015e21d; // The HTTP body is required to authenticate. The application should call the method again with the HTTP body.
        public const uint XONLINE_E_RPS_INVALID_TICKET_TYPE                          = 0x8015e21e; // The ticket type is invalid. This condition could be caused by an incorrect ticket type or a switching of the RPSAuth and RPSSecAuth cookies.
        public const uint XONLINE_E_RPS_INVALID_SLIDINGWINDOW                        = 0x8015e21f; // Sliding time window is invalid. The input parameter for the sliding time window must be smaller than the parameter for the time window. These values can come from site configuration or method arguments.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD                    = 0x8015e220; // The Validate call failed because the AuthMethod check failed.
        public const uint XONLINE_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE                    = 0x8015e222; // The attribute index requested is greater than the attribute count in the profile schema.
        public const uint XONLINE_E_RPS_INVALID_PROFILESCHEMA_TYPE                   = 0x8015e223; // The data type requested is not defined in the profile schema. The data type is not supported.
        public const uint XONLINE_E_RPS_FAILED_DOWNLOAD                              = 0x8015e224; // The RPS service failed to download RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALID_SITEID                               = 0x8015e226; // The SiteId does not match the Ticket TargetId or audience.
        public const uint XONLINE_E_RPS_BASE64DECODE_FAILED                          = 0x8015e227; // Failed to do base64 decoding.
        public const uint XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED                    = 0x8015e228; // The Validate call failed because the time window expired.
        public const uint XONLINE_E_RPS_REASON_SLIDINGWINDOW_EXPIRED                 = 0x8015e229; // The Validate call failed because the sliding time window expired.
        public const uint XONLINE_E_RPS_CERT_INVALID_KEY_SPEC                        = 0x8015e22a; // The certificate private key has an invalid key spec. The key spec should be AT_KEYEXCHANGE.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION       = 0x8015e22b; // Internal program error.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE          = 0x8015e22c; // An invalid AuthInstant data type was encountered during time-window validation.
        public const uint XONLINE_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED      = 0x8015e22d; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_INCORRECT_IV_BYTES                    = 0x8015e22e; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED          = 0x8015e22f; // Passport f-code error was encountered in the query string.
        public const uint XONLINE_E_RPS_NO_SESSION_KEY                               = 0x8015e230; // There is no session key in the ticket.
        public const uint XONLINE_E_RPS_INVALID_COOKIE_NAME                          = 0x8015e231; // The reserved cookie name is specified.
        public const uint XONLINE_E_RPS_INVALID_AUTHPOLICY                           = 0x8015e232; // The AuthPolicy parameter in site configuration or input parameter is invalid or missing. Check the RPSNetwork.xml file for valid AuthPolicy names.
        public const uint XONLINE_E_RPS_INVALID_ENCRYPT_ALGID                        = 0x8015e233; // The encryption method algId is invalid.
        public const uint XONLINE_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED        = 0x8015e234; // Post ticket time window expired. Ticket could be reposted.
        public const uint XONLINE_E_RPS_TICKET_HAS_NO_SESSIONKEY                     = 0x8015e235; // The ticket does not have a session key.
        public const uint XONLINE_E_RPSDATA_DATA_TOO_LARGE                           = 0x8015e400; // The data is larger than the RPSData limit.
        public const uint XONLINE_E_RPSDATA_INVALID_DATATYPE                         = 0x8015e401; // The data type in the data schema is not supported.
        public const uint XONLINE_E_RPSDATA_MORE_DATA                                = 0x8015e402; // The data buffer is insufficient.
        public const uint XONLINE_E_RPSDATA_INVALID_DATAOFFSET                       = 0x8015e403; // The data offset is too large or invalid.
        public const uint XONLINE_E_RPSDATA_INVALIDDATA                              = 0x8015e404; // The data is invalid.


        //
        //
        // NOTE: For new services, please use a range of 100 return codes, preferably between some existing services
        //
        //


        //
        // Billing Service HRESULTS                                                  = 0x80160000 - 0x8016FFFF
        //

        // IMPORTANT: DO NOT INTRODUCE ANY HRESULT VALUES IN THE RANGE: 0x80160000-0x8016ffff!
        //
        // The const definitions for the SCS/Billing HRESULTS are no longer defined here
        // but instead are autogenerated from the SCS bdkerror.xml file using an XSL script.
        //
        // Previously, this list was hand-generated or built from quick-and-dirty Perl script
        // that was not part of the build environment.  By making sure these errors are
        // always generated from the errors defined by current SCS SDK, the Xbox translations
        // of those errors should never lag too far behind SCS.
        //

        // Unfortunately, two Xbox-specific errors were introduced into this range which the
        // client now has a dependency on.  At present, SCS is not returning either of these
        // two error codes but if they ever do, code will need to be introduced to the BdkError
        // constructor to recognize and re-map them or there will be a potential ambiguity as to
        // what this error actually means.
        public const uint XONLINE_E_BILLING_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED                  = 0x8016148b;  // Payment instrument changes are restricted through user (or tier or offer) privilege
        public const uint XONLINE_E_BILLING_PASSPORT_SWITCHING_RESTRICTED                          = 0x8016148c;  // Payment instrument changes are restricted through user (or tier or offer) privilege

        //
        // Private server-internal HRESULTS (never exposed to clients)
        // (range of 0x8017xxxx)
        //
        public const uint XONLINE_E_PUID_IS_MACHINE     = 0x80170000;

        // tools management server
        public const uint TOOLS_SERVER_E_FILE_NOT_FOUND                              = 0x80170100; // tools service failed to find a file on file share to be propped to the data center
        public const uint TOOLS_SERVER_E_SD_ADD_FAILED                               = 0x80170101; // tools service failed to add a file to title manager repository
        public const uint TOOLS_SERVER_E_SD_SUBMIT_FAILED                            = 0x80170102; // tools service failed to submit a file into title manager repository
        public const uint TOOLS_SERVER_E_TMR_STATS                                   = 0x80170103; // title manager failed to prop the package
        public const uint TOOLS_SERVER_E_INTERRUPTED_TASK                            = 0x80170104; // tools service was stopped while processing a job. The job should be rolled back manually
        public const uint TOOLS_SERVER_E_INVALID_TITLE_ID                            = 0x80170105; // tools service cannot process the job because title id is invalid

        //
        // livecache hresult (not exposed to consoles)                               = 0x80171xxx
        //
        public const uint XONLINE_E_LIVECACHE_EMPTY_RESULT                           = 0x80171001; // live service replied with empty result, this should not happen
        public const uint XONLINE_E_LIVECACHE_FORWARD_FAILED                         = 0x80171002; // failed to forward the request to live service: failed to connect or not getting response
        public const uint XONLINE_E_LIVECACHE_OFFLINE                                = 0x80171003; // the requested service has been turned off at livecache
        public const uint XONLINE_E_LIVECACHE_USER_OVERHEAT                          = 0x80171004; // too many requests from this same user within the current hour
        public const uint XONLINE_E_LIVECACHE_INEXIST_KEY                            = 0x80171005; // the key specified in LoadData request was not found, timed out?
        public const uint XONLINE_E_LIVECACHE_MAX_HEADER_COLLECTION_LIMIT            = 0x80171006; // max header limit exceeded.


        //
        // wcmusic hresults (exposed to mtv, not consoles)                              = 0x80172xxx
        //
        public const uint XONLINE_E_WCMUSIC_TEST_FAULT                                  = 0x80172000; // returned by TestConnection in order to test throwing faults
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_SUSPENDED                           = 0x80172001; // returned by orderItems if account is suspended because of unconfirmed free trial
        public const uint XONLINE_E_WCMUSIC_INSUFFICIENT_BALANCE                        = 0x80172002; // returned by orderItems if no points available
        public const uint XONLINE_E_WCMUSIC_ITEM_ALREADY_PURCHASED                      = 0x80172003; // returned by orderItems if repurchaseOverride is false, which it never is currently
        public const uint XONLINE_E_WCMUSIC_ITEM_UNAVAILABLE                            = 0x80172004; // returned by orderItems if the component is unavailable from MusicNet
        public const uint XONLINE_E_WCMUSIC_TOO_MANY_ITEMS                              = 0x80172005; // returnded by orderItems if item count > 100
        public const uint XONLINE_E_WCMUSIC_NOT_SUSPENDED_BY_PARTNER                    = 0x80172006; // returned by orderItems if account is suspended manually by Customer Service Rep, or returned by resumeAccount if account is suspended manually by a Customer Service Rep
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_ELIGIBLE                        = 0x80172007; // returned by AuthenticateAccount if user is not eligible for the Argo service due to country, age, restrictions, etc.
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_PROVISIONED                     = 0x80172008; // returned by AuthenticateAccount if user has not been provisioned for Argo service
        public const uint XONLINE_E_WCMUSIC_INVALID_ARGUMENT                            = 0x80172009; // returned when an argument passed in to the API was not allowed/expected.
        public const uint XONLINE_E_WCMUSIC_TRANSACTION_PENDING                         = 0x8017200A; // returned from OrderItems when something went wrong and the purchase transaction is in an inderterminate state.  Calling GetOrderByExternalOrderId should be called to get the updated status on the transaction.
        public const uint XONLINE_E_WCMUSIC_DUPLICATE_EXTERNAL_ORDER_ID                 = 0x8017200B; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.
        public const uint XONLINE_E_WCMUSIC_RPS_TICKET_EXPIRED                          = 0x8017200C; // returned from AuthenticateAccount when the Passport RPS ticket has expired
        public const uint XONLINE_E_WCMUSIC_INVALID_RETAILER_ID                         = 0x8017200D; // returned by any API that takes a retailerID, if the value specified was not expected
        public const uint XONLINE_E_WCMUSIC_MAX_CONSUMPTION_EXCEEDED                    = 0x8017200E; // returned by orderItems if the maximum number of points (defined by DMP policy) has been reached for the user making the purchase
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_REQUIRES_MANAGEMENT                 = 0x8017200F; // returned if the account is otherwise disabled, banned, suspended, etc. and requires management on Argo.com
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_INVALID_USER                        = 0x80172010; // returned if the RPS ticket is valid but for a user without an account
        public const uint XONLINE_E_WCMUSIC_MUSICNET_ERROR                              = 0x80172011; // returned if there was some sort of error returned from MusicNet
        public const uint XONLINE_E_WCMUSIC_MUSICNET_COMMUNICATION_ERROR                = 0x80172012; // returned if there was communication error talking to musicnet


        //
        // Sts hresults                                                                 = 0x80173xxx
        //
        public const uint XONLINE_E_STS_ERROR                                           = 0x80173000; // Unsepecified STS error
        public const uint XONLINE_E_STS_CONFIGURATION_ERROR                             = 0x80173001; // STS configuration error
        public const uint XONLINE_E_STS_INVALID_ARGUMENT                                = 0x80173002; // STS invalid argument error
        public const uint XONLINE_E_STS_INVALID_PLATFORM_TYPE                           = 0x80173003; // STS token requested for unsupported platform type
        public const uint XONLINE_E_STS_XSTSTOKEN_NULL                                  = 0x80173004; // GetXStsToken returned NULL token
        public const uint XONLINE_E_STS_GETXSTSTOKEN_ERROR                              = 0x80173005; // GetXStsToken caught exception


        //
        // ConfigDB hresults                                                            = 0x80174xxx
        //
        public const uint XONLINE_E_CONFIGDB_INVALID_COMPONENT                          = 0x80174000; // Caller specified a component name that does not exist in t_components
        public const uint XONLINE_E_CONFIGDB_INVALID_INSTANCE                           = 0x80174001; // Caller specified an instance name that does not exist in t_instances
        public const uint XONLINE_E_CONFIGDB_NO_DEFAULT_INSTANCE                        = 0x80174002; // This operation cannot be completed without a default instance specified in t_instances
        public const uint XONLINE_E_CONFIGDB_INVALID_SERVER                             = 0x80174003; // Caller specified a server name that does not exist in t_servers
        public const uint XONLINE_E_CONFIGDB_INVALID_SETTING                            = 0x80174004; // Caller specified a setting name that does not exist in t_settings
        public const uint XONLINE_E_CONFIGDB_INVALID_PARENT                             = 0x80174005; // Caller specified an instance that is already a child and cannot be used as a parent instance.
        public const uint XONLINE_E_CONFIGDB_CANNOT_DEMOTE_PARENT                       = 0x80174006; // Parent instances cannot be demoted back into children.
        public const uint XONLINE_E_CONFIGDB_INVALID_INTERFACE                          = 0x80174007; // Caller specified an interface that does not exist in t_interfaces.
        public const uint XONLINE_E_CONFIGDB_NAME_TOO_LONG                              = 0x80174008; // Caller specified a named item (component, server, setting, etc.) whose name exceeeded the allowable limit.
        public const uint XONLINE_E_CONFIGDB_NO_PARAMETERS_SPECIFIED                    = 0x80174009; // Call specified no parameters where at least one is required.

        /// <summary>
        /// Catalog Watcher Events                                                      = 0x80175xxx
        /// </summary>
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_ID                           = 0x80175000; // The ID does not exist in the database
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_ERROR                       = 0x80175001; // Generic producer error
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_ERROR                      = 0x80175002; // Generic publisher error
        public const uint XONLINE_E_CATALOGWATCHER_WATCHER_ERROR                        = 0x80175003; // Generic Watcher error
        public const uint XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR    = 0x80175004; // ESP operation error
        public const uint XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING  = 0x80175005; // ESP operation warning
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME             = 0x80175006; // The destination name is invalid
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME                = 0x80175007; // The resource name is invalid
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_QUEUE_OPERATION     = 0x80175008; // The producer did not add anything to the queue
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED          = 0x80175009; // The publisher could not update the LSN
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_INVALID_QUEUE_OPERATION    = 0x8017500A; // The publisher did not dequeue
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_INCORRECT_LSN_ORDER        = 0x8017500B; // LSN's were not in monotonically increasing order
        public const uint XONLINE_E_CATALOGWATCHER_MEDIA_EXTRACTOR_MISSING_DOCUMENT     = 0x8017500C; // Missing Document
        public const uint XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE               = 0x8017500D; // Null document in queue
        public const uint XONLINE_E_CATALOGWATCHER_ZERO_QUEUE_SIZE                      = 0x8017500E; // Queue is being initialized with size 0
        public const uint XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT     = 0x8017500F; // Count of <= 0 passed to GenerateDocuments
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY   = 0x80175010; // Producer not initialized correctly
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_NEGATIVE_BUCKET            = 0x80175011; // Bucket identifier is negative
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT              = 0x80175012; // Document is null
        public const uint XONLINE_E_CATALOGWATCHER_NULL_LSN                             = 0x80175013; // LSN is null
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER              = 0x80175014; // Invalid input parameter
        public const uint XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER                    = 0x80175015; // Missing input parameter
        public const uint XONLINE_E_CATALOGWATCHER_COMMAND_FAILURE                      = 0x80175016; // Generic Command Failure
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE               = 0x80175017; // Producer method has been invoked either without initializing or after an exception was thrown.
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_PDLC_CONFIG              = 0x80175018; // pdlc_mediatypes setting is absent in t_multisettings in npdb
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_RATEABLE_CONFIG          = 0x80175019; // ratings_mediatypes setting is absent in t_multisettings in npdb
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING      = 0x8017501A; // The setting is not an integer
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTGCFORTITLES        = 0x8017501B; // Missing exempt game content for titles multisetting
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTMEDIATYPES         = 0x8017501C; // Missing exempt media types multisetting
        public const uint XONLINE_E_CATALOGWATCHER_DOCUMENT_TOO_LARGE                   = 0x8017501D; // Document has been generated that is larger then FAST ESP can store
        public const uint XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR         = 0x8017501E; // AzureStorage Publisher Error
        public const uint XONLINE_E_CATALOGWATCHER_SPEECH_EXTRACTOR_MISSING_DOCUMENT    = 0x8017501F; // Missing Document

        ///<summary>
        ///Mix Common HResults                                                          = 0x80176xxx
        ///</summary>
        public const uint XONLINE_E_MIX_UNKNOWNERROR                                    = 0x80176000; // Unknown Error
        public const uint XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR                = 0x80176001; // SQL & Entity Framework Connection Error
        public const uint XONLINE_E_MIX_CONFIGUREPRODUCT                                = 0x80176002; // Configure Product Error
        public const uint XONLINE_E_MIX_GETPRODUCT                                      = 0x80176003; // Get Product Error
        public const uint XONLINE_E_MIX_CONFIGUREOFFER                                  = 0x80176004; // Configure Offer Error
        public const uint XONLINE_E_MIX_GETOFFER                                        = 0x80176005; // Get Offer Error
        public const uint XONLINE_E_MIX_WEBSGVALIDATIONERROR                            = 0x80176006; // WebSG Validation Error
        public const uint XONLINE_E_MIX_ARGUMENT_NULL                                   = 0x80176007; // Null input to mix
        public const uint XONLINE_E_MIX_ARGUMENT_NULL_INTERNAL                          = 0x80176008; // Null input within mix
        public const uint XONLINE_E_MIX_NOT_FOUND_IN_CATALOG                            = 0x80176009; // Item not found in catalog
        public const uint XONLINE_E_MIX_INVALID_MEDIA_RELATIONSHIP_TYPE                 = 0x8017600A; // MediaRelationShipType is invalid
        public const uint XONLINE_E_MIX_INVALID_OFFER_RELATIONSHIP_TYPE                 = 0x8017600B; // Offer relationship type is invalid
        public const uint XONLINE_E_MIX_NEW_MEDIA_FOR_EXISTING_OFFER                    = 0x8017600C; // New media id given for existing offer
        public const uint XONLINE_E_MIX_NEW_OFFER_FOR_EXISTING_OFFERINSTANCE            = 0x8017600D; // New offer id given for existing offer instance
        public const uint XONLINE_E_MIX_INVALID_DURATION_TYPE                           = 0x8017600E; // DurationType is Invalid
        public const uint XONLINE_E_MIX_INVALID_OFFER_RELATIONSHIP_MEDIA                = 0x8017600F; // related Medias are Invalid
        public const uint XONLINE_E_MIX_INVALID_OFFERTYPE_MEDIA                         = 0x80176010; // Offertype and MediaIds mismatch
        public const uint XONLINE_E_MIX_INVALID_TITLE_ID                                = 0x80176011; // Invalid Title ID Used
        public const uint XONLINE_E_MIX_INVALID_LEADERBOARD_ID                          = 0x80176012; // Invalid Leaderboard ID Used
        public const uint XONLINE_E_MIX_INVALID_XLAST                                   = 0x80176013; // Invalid Xlast Used
        public const uint XONLINE_E_MIX_DECOMPRESSION_ERROR                             = 0x80176014; // Decompression error when decompressing xlast
        public const uint XONLINE_E_MIX_INVALID_VERSION                                 = 0x80176015; // Invalid Version Used
        public const uint XONLINE_E_MIX_INVALID_PLATFORM                                = 0x80176016; // Invalid Platform Used
        public const uint XONLINE_E_MIX_INVALID_FILE_TYPE                               = 0x80176017; // Invalid File Type Used
        public const uint XONLINE_E_MIX_INVALID_GUID                                    = 0x80176018; // Empty GUID Used
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY                  = 0x80176019; // Unknown game attribute property encountered
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY_TYPE             = 0x8017601A; // Unknown game attribute property type encountered
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY_VALUE            = 0x8017601B; // Unknown game attribute property value encountered
        public const uint XONLINE_E_MIX_MEDIALOCALEMAPS_INVALID_MAPPING                 = 0x8017601C; // Invalid mapping encountered processing MediaLocaleMaps
        public const uint XONLINE_E_MIX_INVALID_CONSUMABLE_QUANTITY                     = 0x8017601D; // Invalid quantity for game consumable offer
        public const uint XONLINE_E_MIX_FORBIDDEN_ENVIRONMENT                           = 0x8017601E; // Environment not allowed
        public const uint XONLINE_E_MIX_INVALID_MEDIATYPE                               = 0x8017601F; // Invalid MediaType used for a Product
        public const uint XONLINE_E_MIX_NEW_LIVEOFFERID_FOR_EXISTING_OFFER              = 0x80176020; // Attempt to change a live offer id mapping
        public const uint XONLINE_E_MIX_UNIQUE_RATINGSYSTEMS_ERROR                      = 0x80176021; // The rating list contains at least more than one instance from the same rating system
        public const uint XONLINE_E_MIX_PRODUCT_LOCALIZATION_NOT_FOUND                  = 0x80176022; // No localization text for this product is found the particular country for the offer instance
        public const uint XONLINE_E_MIX_CONCURRENCY_ERROR                               = 0x80176023; // Concurrency issue occured in Entity Framework
        public const uint XONLINE_E_MIX_INVALID_SERVICE_TYPE                            = 0x80176024; // invalid service type - xbox or zune
        public const uint XONLINE_E_MIX_INVALID_SUBSCRIPTION_TYPE                       = 0x80176025; // invalid subscription type - base, game, content
        public const uint XONLINE_E_MIX_INVALID_TIER                                    = 0x80176026; // invalid tier (0, 3, 6 ...)
        public const uint XONLINE_E_MIX_INVALID_SERVICE_PRIVILEGE_SET                   = 0x80176027; // invalid service privilege set (e.g. gold, silver, family, zune pass, phantasy star ...)
        public const uint XONLINE_E_MIX_CATALOG_CONSTRAINT_ERROR                        = 0x80176028; // Catalog SQL Constraint error occured
        public const uint XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED                           = 0x80176029; // The API does not support empty guids.
        public const uint XONLINE_E_MIX_GROUP_DOES_NOT_EXIST                            = 0x8017602A; // The group requested does not exist.
        public const uint XONLINE_E_MIX_INVALID_PRODUCTFAMILY                           = 0x8017602B; //product ->offerInstance mapping is happening even before service sets are defined
        public const uint XONLINE_E_MIX_INVALID_SKU_DELETE                              = 0x8017602C; // Invalid sku delete operation
        public const uint XONLINE_E_MIX_DUPLICATE_GROUP_NAME_NOT_ALLOWED                = 0x8017602D; // Group names must be unique
        public const uint XONLINE_E_MIX_INVALID_GROUP_NAME                              = 0x8017602E; // The group name is invalid.
        public const uint XONLINE_E_MIX_INVALID_GROUP_CREATOR                           = 0x8017602F; // The group creator is invalid.
        public const uint XONLINE_E_MIX_ARGUMENT_EMPTY                                  = 0x80176030; // Empty string passed into mix that needs to be filled in
        public const uint XONLINE_E_MIX_INVALID_CONFIG                                  = 0x80176031; // Invalid combination of configuration parameters.
        public const uint XONLINE_E_MIX_STATS_FORCE_REQUIRED                            = 0x80176032; // Leaderboard update needs force parameter to be successful
        public const uint XONLINE_E_MIX_MATCH_MISSING_REMOVE_MODE                       = 0x80176033; // MixMatch attemped to remove a mode with removeMode set to false
        public const uint XONLINE_E_MIX_MATCH_NEW_MODE_FOUND                            = 0x80176034; // MixMatch found a new mode added to the XLAST. This must be configured manually.
        public const uint XONLINE_E_MIX_MATCH_SQL_EXCEPTION                             = 0x80176035; // MixMatch encountered a SQL exception. This may be due to dropTable being set to false.
        public const uint XONLINE_E_MIX_GROUP_MUST_BE_EMPTY                             = 0x80176036; // The operation is not valid unless the group is empty.
        public const uint XONLINE_E_MIX_STRING_TOO_LONG                                 = 0x80176037; // A string parameter is too long
        public const uint XONLINE_E_MIX_MACHINE_NOT_IN_GROUP                            = 0x80176038; // The machine was not in the given group.
        public const uint XONLINE_E_MIX_CANNOT_MIGRATE_TO_SELF                          = 0x80176039; // Cannot migrate a group to itself.
        public const uint XONLINE_E_MIX_DUPLICATE_XRL_NOT_ALLOWED                       = 0x8017603A; // Duplicate title update location XRLs aren't allowed.
        public const uint XONLINE_E_MIX_FRONT_DOOR_RESET_ERROR                          = 0x8017603B; // Front Door Reset Error
        public const uint XONLINE_E_MIX_DUPLICATE_APP_NOT_ALLOWED                       = 0x8017603C; // Duplicate App Not Allowed
        public const uint XONLINE_E_MIX_ARRAY_TOO_LONG                                  = 0x80176040; // An array parameter is too long
        public const uint XONLINE_E_MIX_DUPLICATE_RANK_NOT_ALLOWED                      = 0x80176041; // Duplicate title update location ranks aren't allowed.
        public const uint XONLINE_E_MIX_OFFER_INVALID_SUBSCRIPTIONFAMILY_CONFIG         = 0x80176042; // Wrong LiveSubscriptionFamily Configuration
        public const uint XONLINE_E_MIX_OFFER_INVALID_SUBSCRIPTION_CONFIG               = 0x80176043; // Wrong LiveSubscription Configuration
        public const uint XONLINE_E_MIX_OFFER_NO_TIER_FOUND                             = 0x80176044; // No tier found
        public const uint XONLINE_E_MIX_OFFER_NO_FREQUENCY_FOUND                        = 0x80176045; // No Offer frequency found
        public const uint XONLINE_E_MIX_OFFER_ERROR_FAMILY_INGESTION                    = 0x80176046; //No family content ingestion supported
        public const uint XONLINE_E_MIX_OFFER_ERROR_LEGACY_OFFER                        = 0x80176047; //No Legacy offer mapping
        public const uint XONLINE_E_MIX_DUPLICATE_CONTENTID                             = 0x80176048; // A ContentId can only be associated with one MediaInstance/ProductPackage
        public const uint XONLINE_E_MIX_ERROR_INGESTING_MANIFEST                        = 0x80176049; // There was an error ingesting a new Etx manifest
        public const uint XONLINE_E_MIX_INVALID_VISIBILITY_STATUS                       = 0x80176050; // Invalid visibilitystatus (only allows 3,5 through mix)
        public const uint XONLINE_E_MIX_PRODUCT_DUPLICATE_IMAGE_INSTANCE_ID             = 0x80176051; // Duplicate Image Instance Id (ImageId, Lcid, SizeId, FormatId) not allowed through MIX
        public const uint XONLINE_E_MIX_OPERATION_NOT_SUPPORTED                         = 0x80176052; // Operation not supported or not yet implemented.
        public const uint XONLINE_E_MIX_PRODUCT_TOOMANYPUBLISHERBITCATEGORIES           = 0x80176053; // More than one Publisher Bit Category provided. Only 1 publisher bit is supported for in game browsing apis.
        public const uint XONLINE_E_MIX_NO_SETTING                                      = 0x80176054; // NPDB setting value is missing
        public const uint XONLINE_E_MIX_DUPLICATE_RATINGDESCRIPTOR                      = 0x80176056; // Duplicate RatingDescriptor provided
        public const uint XONLINE_E_MIX_PRODUCT_PUBLISHERBITCATEGORYMISSING             = 0x80176057; // Publisher Bit Category was not provided but is needed for this GameContent type
        public const uint XONLINE_E_MIX_BUSINESS_PARTNER_DOES_NOT_EXIST                 = 0x80176058; // STS Business Partner doesn't exist.
        public const uint XONLINE_E_MIX_TITLE_HAS_NO_BUSINESS_PARTNER                   = 0x80176059; // Setting a title's endpoints doesn't work when the title doesn't have a business partner.
        public const uint XONLINE_E_MIX_TITLE_TOO_MANY_ENDPOINTS                        = 0x8017605A; // Setting a title's endpoints doesn't work when the title doesn't have a business partner.
        public const uint XONLINE_E_MIX_APPLIES_TO_DOES_NOT_EXIST                       = 0x8017605B; // Setting a title's endpoint to an applies to that doesn't exist.
        public const uint XONLINE_E_MIX_UNSUPPORTED_TOKEN_TYPE                          = 0x8017605C; // Setting an applies to to an unsupported token type.
        public const uint XONLINE_E_MIX_UNSUPPORTED_ENDPOINT_PROTOCOL                   = 0x8017605D; // Invalid protocol for a title endpoint.
        public const uint XONLINE_E_MIX_INVALID_CLAIM_TYPE                              = 0x8017605E; // Invalid claim type.
        public const uint XONLINE_E_MIX_PRIVATE_CLAIM_TYPE                              = 0x8017605F; // Cannot use a private claim type in an applies to.
        public const uint XONLINE_E_MIX_PRODUCT_DUPLICATETERM                           = 0x80176060; // Duplicate Term in SearchInformation 
        public const uint XONLINE_E_MIX_PRODUCT_DUPLICATESEARCHLOCALE                   = 0x80176061; // Duplicate SearchInformation with the same Locale

        ///<summary>
        ///FML Common HResults                                                          = 0x80177xxx
        ///<summary>
        public const uint XONLINE_E_FML_UNKNOWN_ERROR                                   = 0x80177000; // Unknown Error
        public const uint XONLINE_E_FML_ALREADY_EXECUTING                               = 0x80177001; // Trying to start a new job while a job is currently executing.
        public const uint XONLINE_E_FML_ARGUMENT_NOT_FOUND                              = 0x80177002; // An argument was not found during the running of a job.
        public const uint XONLINE_E_FML_JOB_FAILED                                      = 0x80177003; // A job encountered an exception and was stopped.
        public const uint XONLINE_E_FML_OPERATION_FAILED                                = 0x80177004; // A job encountered an exception and was stopped.

        /// <summary>
        /// FAST ESP Engine Events                                                      = 0x80178xxx
        /// </summary>
        public const uint XONLINE_E_ESP_ENGINE_UNKNOWN_ERROR                            = 0x80178000; // Unknown error
        public const uint XONLINE_E_ESP_ENGINE_INVALID_PARAMETER                        = 0x80178001; // An invalid datatype was used
        public const uint XONLINE_E_ESP_ENGINE_INVALID_SYNTAX                           = 0x80178002; // Invalid syntax used for value type
        public const uint XONLINE_E_ESP_ENGINE_INVALID_DATA_TYPE                        = 0x80178003; // Invalid data type was used
        public const uint XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND                      = 0x80178004; // Could not find the parameter in the filter criteria
        public const uint XONLINE_E_ESP_ENGINE_INVALID_RULE                             = 0x80178005; // Rule could not be processed and had invalid data
        public const uint XONLINE_E_ESP_ENGINE_SEARCH_TERM_TO_LONG                      = 0x80178006; // Search term used is beyond the proper length allowed
        public const uint XONLINE_E_ESP_ENGINE_INVALID_PARAMETER_GROUPING               = 0x80178007; // An invalid grouping of parameters was used

        /// <summary>
        /// Marketplace Catalog Events                                                  = 0x80179xxx
        /// </summary>
        public const uint XONLINE_E_MARKETPLACECATALOG_UNKNOWN_ERROR                    = 0x80179000; // Unknown error
        public const uint XONLINE_E_MARKETPLACECATALOG_PARAMETER_MISSING                = 0x80179001; // A parameter is missing
        public const uint XONLINE_E_MARKETPLACECATALOG_BAD_FORMAT                       = 0x80179002; // A parameter is not formatted properly
        public const uint XONLINE_E_MARKETPLACECATALOG_DETAIL_LEVEL_MISSING             = 0x80179003; // A detail level is missing for a search hit

        //
        // XboxLive Token HRESULTS
        //
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION                       = 0x80180000; // Token Major or Minor version number invalid
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_ISSUER                        = 0x80180001; // Token Issuer invalid
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_COUNT               = 0x80180002; // Token contains an unexpected number of statements
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_TYPE                = 0x80180003; // Token statement is not of the expected type
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_THUMBPRINT                    = 0x80180004; // Token not signed by expected certificate
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_CLIENTTHUMBPRINT              = 0x80180005; // Token not being used with the certificate for which it was issued
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE                  = 0x80180006; // Platform type not valid or inconsistent with token claims

        public const uint XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG                           = 0x80180020; // Configuration problem caused GetCertificate failure

        //
        // Active Auth HRESULTS
        //
        public const uint XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND                          = 0x80180101; // AA Token Data not found
        public const uint XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID                         = 0x80180102; // AA Token field not valid with Token


        //DO NOT ADD EVENTS IN 0x80190000 to 0x8019FFFF.These are new ctp error codes


        //
        // XClaimProvider HRESULTS                                                      = 0x801A05xx
        //
        public const uint XONLINE_E_XCLAIMPROVIDER_NOXUIDCLAIM                          = 0x801A0500; // A Xuid Claim is not present, user specific claim types are not possible
        public const uint XONLINE_E_XCLAIMPROVIDER_DELEGATIONTOKEN_INVALID              = 0x801A0501; // Invalid Delegation Token
        public const uint XONLINE_E_XCLAIMPROVIDER_DELEGATIONTOKEN_VERSION_INVALID      = 0x801A0502; // Invalid Delegation Token version
        public const uint XONLINE_E_XCLAIMPROVIDER_XUIDCLAIM_INVALID                    = 0x801A0503; // Invalid Xuid claim
        public const uint XONLINE_E_XCLAIMPROVIDER_PUIDCLAIM_INVALID                    = 0x801A0504; // Invalid Puid claim

        // implementation to make this behave like a value type

        private uint _value;


        private HResult(uint value)
        {
            _value = value;
        }


        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }


        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X08");
        }


        public bool HasName
        {
            get { return _nameMap.ContainsKey(_value); }
        }

        public string Name
        {
            get
            {
                string s = null;
                if (!_nameMap.TryGetValue(_value, out s))
                {
                    s = ToString();
                }
                return s;
            }
        }

        public static implicit operator HResult(uint value)
        {
            return  new HResult(value);
        }

        public static implicit operator uint(HResult hResult)
        {
            // convert a HResult to uint
            return hResult._value;
        }

        #region IEquatable<HResult> Members


        public bool Equals(HResult other)
        {
            return _value == other._value;
        }

        #endregion

        public static HResult Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new HResult(Convert.ToUInt32(s, 16));
        }


        public static bool TryParse(string s, out HResult hr)
        {
            try
            {
                hr = HResult.Parse(s);
                return true;
            }
            catch
            {
                hr = new HResult(0);
                return false;
            }
        }

        #region IXmlSerializable Members

        public void ReadXml(XmlReader reader)
        {
            _value = (uint) XmlConvert.ToUInt32(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion

        public static XmlQualifiedName HResultSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedInt", XmlSchema.Namespace);
        }

        public bool IsFailure()
        {
            return (_value >> 31 == 1);
        }

        public bool IsSuccess()
        {
            return (_value >> 31 == 0);
        }

        public bool IsOk()
        {
            return (_value == HResult.S_OK);
        }

        public static bool Failed(HResult hr)
        {
            return hr.IsFailure();
        }

        public static bool Succeeded(HResult hr)
        {
            return hr.IsSuccess();
        }

        static Dictionary<uint, string> _nameMap;

        static object lockObject = new object();
        static internal void AddConstsAsHResults(Type t, Func<object, uint> selector)
        {
            lock (lockObject)
            {
                var newDict = new Dictionary<uint, string>(_nameMap);

                var enums = from f in t.GetFields(BindingFlags.Static | BindingFlags.DeclaredOnly | BindingFlags.Public)
                            where f.IsLiteral
                            let key = selector(f.GetValue(null))
                            where !newDict.ContainsKey(key)
                            select new KeyValuePair<uint, string>(key, f.Name);

                foreach (var e in enums)
                {
                    newDict[e.Key] = e.Value;
                }

                _nameMap = newDict;
            }
        }

        static HResult()
        {
            _nameMap = new Dictionary<uint, string>();

            try
            {
                AddConstsAsHResults(typeof(HResult), o => (uint)o);
            }
            catch (Exception)
            {
                // Nothing really to do, dictionary will just be empty
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SettingChangeFilter.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

namespace STF.common.config
{

    /// <summary>
    /// Implements a SettingChangeEventHandler that vetos any changes to settings that
    /// are not supposed to be dynamically consumed.
    /// </summary>
    /// <remarks>
    /// This is really a last minute hack to make up for a design shortcoming with the Config class.
    /// The Config library was designed to not accept any changes to items in the NPDB config database
    /// unless a SettingChangeEventHandler was registered with the Config class to allow components that
    /// were not designed to handle dynamic changes. Unfortunatly this did not take into account that 
    /// components that can not handle values to dynamically change might link in untiltiy libraries that
    /// were designed to accept dynamic changes. Once one of these utility libraries regestered an EventHandler
    /// to accept their setting changes, all settings were then allowed to be updated dynamically. 
    /// To get around this issue, this global SettingChangeEventHandler was created that would veto changes for
    /// any item that had not been marked as dynamic.
    /// To mark an item as one that can be dynamically consumed, add a dynamic="true" attribute to
    /// the setting element for that element in the common/config/configItems.xml file. If your setting is not
    /// defined in the XML file, you can also register the setting as dynamic by calling the RegisterDynamicSetting 
    /// method of this class.
    /// </remarks>
    public class SettingChangeFilter
    {
        private static SortedDictionary<string, string> dynamicSettings;

        private static SortedDictionary<string, string> GetDynamicSettingsTable()
        {
            if (dynamicSettings == null)
            {
                lock (typeof(SettingChangeFilter))
                {
                    if (dynamicSettings == null)
                    {
                        SortedDictionary<string, string> newSettingTable = new SortedDictionary<string, string>();

                        foreach (string settingName in Setting.DynamicSettings)
                        {
                            newSettingTable.Add(settingName, settingName);
                        }

                        dynamicSettings = newSettingTable;
                    }
                }
            }

            return dynamicSettings;
        }

        public static void RegisterDynamicSetting(string settingName)
        {
            if (settingName == null)
            {
                throw new ArgumentNullException("settingName");
            }

            SortedDictionary<string, string> dynamicSettingsTable = GetDynamicSettingsTable();

            if (!dynamicSettingsTable.ContainsKey(settingName))
            {
                dynamicSettingsTable.Add(settingName, settingName);
            }
        }

        public static void UnRegisterDynamicSetting(string settingName)
        {
            if (settingName == null)
            {
                throw new ArgumentNullException("settingName");
            }

            SortedDictionary<string, string> dynamicSettingsTable = GetDynamicSettingsTable();

            if(dynamicSettingsTable.ContainsKey(settingName))
            {
                dynamicSettingsTable.Remove(settingName);
            }
        }

        public static void GlobalHandler(object sender, SettingChangeEventArgs e)
        {
            // anything we accept dynamically should be listed here.
            // anything we reject changes to gets the default, which calls VetoSettingChange
            // some servers still register their own handlers to do extra processing
            // when settings change, but those handlers should not call VetoSettingChange,
            // nor should they do anything with any setting that's not listed below.
        
            SortedDictionary<string, string> dynamicSettingsTable = GetDynamicSettingsTable();

            if (!dynamicSettingsTable.ContainsKey(e.Setting))
            {
                Config.VetoSettingChange();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SGAddressValidator.cs ===
//
// SGAddressValidator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Simple, fast, static class for determining if a request came from a real SG's client ip 
// range or not. 
//
// 7/2007 kgoodier
//

using System;
using System.Collections.Generic;
using System.Net;
using System.Web;

using STF.common.config;
using STF.common.mgmt;

namespace STF.common.service
{

public static class SGAddressValidator
{

    public enum Answer 
    {
        Yes,
        No,
        Unknown
    };

    // -------------------------------------------------------------------------
    // Check - did this request come from a real SG? Note this doesn't work on Xblobs 
    // (returns Unknown) nor does it work for STF requests (FakeSG) -- it will return No 
    // when it should probably return Yes.
    //
    // Returns 
    // Yes if request ip came from real SG
    // No if it didn't
    // Unknown if Xblob or STF or otherwise unknown
    // -------------------------------------------------------------------------
    public static Answer Check(HttpContext ctx)
    {
        return Check(new HttpContextAdapter(ctx));
    }

    public static Answer Check(HttpContextAdapter ctx)
    {
        // Don't blow up if HttpContext is null
        if (ctx == null)
        {
            return Answer.Unknown;
        }

        IPAddress srcIP = null;
        ushort srcPort  = 0;
        GetSourceAddress(ctx, ref srcIP, ref srcPort);
        Answer ans = Check(srcIP, srcPort);

        // We need to check for STF tests, which will use FakeSG to provide SGInfo but 
        // won't come from any known IP address.  The http header that identifies tests is 
        // "Relja: true".
        if (ans == Answer.No && ctx.Request != null && ctx.Request.Headers["Relja"] != null)
        {
            ans = Answer.Unknown;
        }

        return ans;
    }

    // -------------------------------------------------------------------------
    // Check - overload for IPAddress
    // -------------------------------------------------------------------------
    public static Answer Check(IPAddress ipAddr, ushort port)
    {
        UInt32 ip = ConfigUtil.IpAddressToDword(ipAddr);
        return Check(ip, port);
    }

    // -------------------------------------------------------------------------
    // Check - overload for uint32 ip (real implementation)
    // -------------------------------------------------------------------------
    public static Answer Check(UInt32 ip, ushort port)
    {
        // Ensure static initialization complete, see Initialize
        Initialize();
        
        // Grab a local copy of the global
        Dictionary<string, IInterfaceInfo> sgInterfaces = _SgInterfaces;
        if (sgInterfaces == null)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, "SGAddressValidator: Check returning Unknown, not initialized");
            return Answer.Unknown;
        }

        // Handy IInterfaceInfo fields:
        //   SgIpAddressBegin (IPAddress)
        //   SgIpAddressBeginDword
        //   SgIpAddressEnd (IPAddress)
        //   SgIpAddressEndDword
        //   SgPortBegin (int)
        //   SgPortEnd (int)
   
        foreach (IInterfaceInfo ifInfo in sgInterfaces.Values)
        {
            if (ip < ifInfo.SgIpAddressBeginDword ||
                ip > ifInfo.SgIpAddressEndDword)
            {
                continue;
            }

            if (port < ifInfo.SgPortBegin ||
                port > ifInfo.SgPortEnd)
            {
                continue;
            }

            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, String.Format(
                    "SGAddressValidator: Check returning Yes for ip 0x{0:X}, port {1}", 
                    ip, port));
            return Answer.Yes;
        }
   
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, String.Format(
                "SGAddressValidator: Check returning No for ip 0x{0:X}, port {1}", 
                ip, port));
        return Answer.No;
    }
    


    // -------------------------------------------------------------------------
    // SGAddressValidator - static constructor, loads all SG ip settings from NPDB 
    // (t_server_nics).
    // -------------------------------------------------------------------------
    static SGAddressValidator()
    {
        // register for callbacks
        Config.ServerListChange += new ServerListChangeEventHandler(SGAddressValidator.OnServerListChange);
        Config.InterfaceChange += new InterfaceChangeEventHandler(SGAddressValidator.OnInterfaceChange);
    }

    //////////////////////////////////////////////////////////
    // Initialize
    //
    // Public static methods of this class MUST call this method (Initialize) to guarantee
    // all static members are properly initialized before doing any work.
    // Note: Right now this is really limited to just public methods that need to access _SgInterfaces
    private static void Initialize()
    {
        if ( !_fInitialized )
        {
            lock ( _lockInit )
            {
                if ( !_fInitialized )
                {
                    Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, "SGAddressValidator: Initializing...");

                    // Kick off a fresh refresh
                    string[] servers = Config.GetServerListByInterface(Interface.sgsvc_int);
                    Dictionary<string, IInterfaceInfo> sgInterfaces = new Dictionary<string, IInterfaceInfo>(servers.Length);
                    RefreshServerList(servers, sgInterfaces);
                    
                    // Swap out member with fresh local copy real fast like
                    _SgInterfaces = sgInterfaces;
                    _fInitialized = true;

                    Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, "SGAddressValidator: Done initializing.");
                }
            }
        }
    }

    // -------------------------------------------------------------------------
    // Callback from Config when server lists change
    // -------------------------------------------------------------------------
    public static void OnServerListChange(
        object sender, 
        ServerListChangeEventArgs args)
    {
        if (args.Interface != Interface.sgsvc_int)
        {
            // we're only concerned with the sg's internal interfaces
            return;
        }

        // Ensure static initialization complete, see Initialize
        Initialize();

        // We're dumb. Maybe only 1 server changed, but we're going to rebuild the whole 
        // thing. Not too expensive, much simpler.
        Dictionary<string, IInterfaceInfo> sgInterfaces = new Dictionary<string, IInterfaceInfo>(args.ValueNew.Length);
        RefreshServerList(args.ValueNew, sgInterfaces);
        
        // Swap out member with fresh local copy real fast like
        _SgInterfaces = sgInterfaces;
    }

    // -------------------------------------------------------------------------
    // Callback from Config when interfaces change
    // -------------------------------------------------------------------------
    public static void OnInterfaceChange(
        object sender,
        InterfaceChangeEventArgs args)
    {
        if (args.Interface != Interface.sgsvc_int)
        {
            // we're only concerned with the sg's internal interfaces
            return;
        }

        // Ensure static initialization complete, see Initialize
        Initialize();

        RefreshInterface(args.ValueNew, _SgInterfaces);
    }

    // -------------------------------------------------------------------------
    // RefreshServerList - reloads the entire list of SG ips
    // -------------------------------------------------------------------------
    private static void RefreshServerList(
        string[] serverList, 
        Dictionary<string, IInterfaceInfo> sgInterfaces)
    {
        foreach (string server in serverList)
        {
            IInterfaceInfo ifInfo = Config.GetInterface(server, Interface.sgsvc_int);
            RefreshInterface(ifInfo, sgInterfaces);
        }
    }

    // -------------------------------------------------------------------------
    // RefreshInterface - reloads only a single SG ip and replaces its entry in the 
    // dictionary.
    // -------------------------------------------------------------------------
    private static void RefreshInterface(
        IInterfaceInfo ifInfo,
        Dictionary<string, IInterfaceInfo> sgInterfaces)
    {
        // nothing fancy... but it could be!
        sgInterfaces[ifInfo.ServerName] = ifInfo;
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, String.Format(
                "SGAddressValidator: Server({0}) Ip({1} - {2}) Port({3} - {4})",
                ifInfo.ServerName, 
                ifInfo.SgIpAddressBeginString, ifInfo.SgIpAddressEndString,
                ifInfo.SgPortBegin, ifInfo.SgPortEnd));
    }

    // -------------------------------------------------------------------------
    // Retrieve the request's IP address and port
    // -------------------------------------------------------------------------
    public static void GetSourceAddress(
        HttpContext ctx,
        ref IPAddress srcIP,
        ref ushort srcPort)
    {
        GetSourceAddress(new HttpContextAdapter(ctx), ref srcIP, ref srcPort);
    }

    public static void GetSourceAddress(
        HttpContextAdapter ctx,
        ref IPAddress srcIP, 
        ref ushort srcPort)
    {
        string sgIPPort = ctx.Request.Headers[XHttpHdr.SGIPPORT];
        if (sgIPPort != null)
        {
            // The UDP adaptor adds this header so the front door attempts to talk back to the
            // correct IP and port.
            // XrlScan also adds this header, because the GetServerVariables() call below
            // is incredibly expensive (for reasons beyond our understanding...)
            int colon = sgIPPort.IndexOf(':');
            if (colon == -1)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sgIPPort);
            }
            srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
            srcPort = Convert.ToUInt16(sgIPPort.Substring(colon + 1));
        }
        else
        {
            srcIP = ctx.Request.RemoteEP.Address;
            srcPort = (ushort)ctx.Request.RemoteEP.Port;
        }
    }

    private static Dictionary<string, IInterfaceInfo>    _SgInterfaces = null;
    private static volatile bool _fInitialized = false;
    private static object _lockInit = new object();

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\setupdecode.cs ===
using System;
using System.Xml;
using System.IO;
using System.Runtime.InteropServices;
using System.Collections;
using System.Reflection;

using STF.common.config;

namespace STF.common.config
{

    public class CSetupSecureResolver
    {
        public XmlDocument Doc
        {
            get
            {
                if (_doc == null)
                {
                    _doc = new XmlDocument();
                    _doc.Load(Path);
                }
                return _doc;
            }
        }

        public string Path
        {
            get
            {
                if (_path == null)
                {
                    _path = System.IO.Path.Combine(SetupUNC, "SITE.XML");
                }

                return _path;
            }
        }

        public String SetupUNC
        {
            get
            {
                if (_setupUNC == null)
                {
                    _setupUNC = Config.GetSetting(Setting.setup_secureUNC);
                }

                return _setupUNC;
            }
        }

        public string UserSecret(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Domain/Account[@Identifier = \"" + identifier + "\"]/Password");

            if (node == null)
            {
                throw new ApplicationException("ConfigDB specified account with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return node.InnerText;
            }
        }


        public string SSL_Secret(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]/Password");

            if (node == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return node.InnerText;
            }
        }

        [Obsolete("Please use SSL_PFXFilePath(identifier) instead", false)]
        public string SSL_File(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");
            
            if (node == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return node.Attributes.GetNamedItem("File").Value;
            }         
        }

        public string SSL_PFXFilePath(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");
            XmlNode node2 = node != null ? node.Attributes.GetNamedItem("File") : null;
            
            if (node == null || node2 == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return GetFullPath(node2.Value);
            }         
        }

        [Obsolete("Please use SSL_CTLFilePath(identifier) instead", false)]
        public string SSL_CTLFile(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");

            if (node == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert (CTL) with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return node.Attributes.GetNamedItem("CTLFile").Value;
            }
        }

        public string SSL_CTLFilePath(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");
            XmlNode node2 = node != null ? node.Attributes.GetNamedItem("CTLFile") : null;

            if (node == null || node2 == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert (CTL) with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return GetFullPath(node2.Value);
            }
        }

        [Obsolete("Please use SSL_P7BFilePath(identifier) instead", false)]
        public string SSL_P7BFile(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");

            if (node == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert (P7B) with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return node.Attributes.GetNamedItem("P7BFile").Value;
            }
        }

        public string SSL_P7BFilePath(string identifier)
        {
            XmlNode node = Doc.DocumentElement.SelectSingleNode("//Site/Certificates/SSLCert[@Identifier = \"" + identifier + "\"]");
            XmlNode node2 = node != null ? node.Attributes.GetNamedItem("P7BFile") : null;

            if (node == null || node2 == null)
            {
                throw new ApplicationException("ConfigDB specified an SSL Cert (P7B) with identifier " + identifier + " that was not found in " + Path);
            }
            else
            {
                return GetFullPath(node2.Value);
            }
        }

        private string GetFullPath(String filePath)
        {
            if (System.IO.Path.IsPathRooted(filePath))
            {
                return filePath;
            }
            else
            {
                return System.IO.Path.Combine(SetupUNC, filePath);
            }
        }

        private String _setupUNC = null;
        private XmlDocument _doc = null;
        private string _path = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\sgprot.cs ===
// 
// SgProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SG Service Integration
// Xbox Online Service
// 
// Author: phansen
//

using System.IO;
using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.SGProxy)]


namespace STF.common.protocol 
{
    public class SgDefs
    {
        public const int XONLINE_MAX_LOGON_USERS                = 4;
        public const int XONLINE_MAX_ALTERNATE_TITLE_ID         = 4;
        public const int XONLINE_KEY_LENGTH                     = 16;
        public const int XONLINE_NUM_PRIVILEGE_DWORDS           = 8;
        public const int XONLINE_MAX_DWORD_SERVICEIDS           = 4;
    }

    //
    // Structure Representing the SGADDR info
    //  Maps to SGADDR in STF.x
    //  
    public class SGADDR : WireData
    {
        public uint                 inaSg;
        public uint                 dwSpiSg;
        public ulong                qwXboxId;
        public uint                 abReserved;
        
        /// <summary
        /// Function to Compare this to another SGADDR
        /// Could be part of IEquatable but don't know
        /// how that works with serialization.
        /// Returns true if the two are equal.
        /// </summary>
        public bool IsEqual(SGADDR sgaddr)
        {
            return (inaSg == sgaddr.inaSg && dwSpiSg == sgaddr.dwSpiSg && 
                    qwXboxId == sgaddr.qwXboxId && abReserved == sgaddr.abReserved);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(inaSg);
            binaryWriter.Write(dwSpiSg);
            binaryWriter.Write(qwXboxId);
            binaryWriter.Write(abReserved);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                inaSg = (uint)binaryReader.ReadInt32();
                dwSpiSg = (uint)binaryReader.ReadInt32();
                qwXboxId = (ulong)binaryReader.ReadInt64();
                abReserved = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_24, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }
    }

    public class XBOX_LIBRARY_VERSION : WireData
    {
        public ushort               wMajorVersion;
        public ushort               wMinorVersion;
        public ushort               wBuildNumber;
        public ushort               wQFENumber;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wMajorVersion);
            binaryWriter.Write(wMinorVersion);
            binaryWriter.Write(wBuildNumber);
            binaryWriter.Write(wQFENumber);
         }

    }

    public class XUID : WireData
    {
        public ulong                qwUserId;                   // or qwTeamId
        public uint                 dwUserFlags;                // The high 16 bits should come from the UODB User Table.
    }

    public enum SG_MSG_TYPES : ushort
    {
        // Definitions (0x47 is 'G') ---------------------------------------------------------
        SGMSG_TYPE_KICK_REQ         = 0x4705,  // CSgMsgKickReq
        SGMSG_TYPE_KICK_REP         = 0x4706,  // CSgMsgKickRep
        SGMSG_TYPE_XBTOXB_FORWARD   = 0x470A,  // CSgMsgXbToXbForward
        SGMSG_TYPE_SET_QVALS_LAZY   = 0x470B,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_PUSH   = 0x470C,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_REP    = 0x470D,  // CSgMsgSetQValsRep
        SGMSG_TYPE_SPIDATA_REQ      = 0x4710,  // CSgMsgSpiReq
        SGMSG_TYPE_SPIDATA_REP      = 0x4711,  // CSgMsgSpiRep
        SGMSG_TYPE_NOTIFY_CLI_DEL   = 0x4712,  // CSgMsgNotifyCliDelete
        SGMSG_TYPE_NOTIFY_CLI_UPD   = 0x4713,  // CSgMsgNotifyCliUpdate
        SGMSG_TYPE_NOTIFY_CLI_TCHG  = 0x4714,  // CSgMsgNotifyCliTitleChange
        SGMSG_TYPE_XBTOXB_FORWARD2  = 0x4715,  // CSgMsgXbToXbForward2
        SGMSG_TYPE_SPIDATA_REQ2     = 0x4716,  // CSgMsgSpiReq2 

        SGMSG_TYPE_SPIDATA          = 0x4782,  // CSgMsgSpiData in the payload
        SGMSG_TYPE_AUTHDATA         = 0x4783,  // CAuthData in the payload
    }

    // Base class that other SG messages derive from
    //
    public class CSgMsgHdr : WireData
    {
        // WireData requires a default constructor with no args for deserialization, so this must exist
        public CSgMsgHdr()
        {
        }
        
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        public CSgMsgHdr( SG_MSG_TYPES msgType, ushort size )
        {
            _wType = (ushort) msgType;
            _cbEnt = size;
        }

        public ushort           _wType;                         // See SGMSG_TYPE_* above
        public ushort           _cbEnt;                         // Size of this entry (including header)

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                _wType = (ushort)binaryReader.ReadInt16();
                _cbEnt = (ushort)binaryReader.ReadInt16();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_25, 
                    "Reached end of stream trying to read CSgMsgHdr", e);
            }
            return this;
        }

    }

    public class CAuthData : WireData
    {
        public CAuthData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_AUTHDATA, 218 );
            wAuthDataVersion = 3;
            wAuthDataSize = 214;
        }

        public CSgMsgHdr            header;
        public ushort               wAuthDataVersion;
        public ushort               wAuthDataSize;
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint                 dwTitleID;
        public uint                 dwTitleVersion;
        public uint                 dwTitleRegion;
        public uint                 dwConsoleRegion;
        public uint                 dwMediaID;
        public uint                 dwLanguageID;
        public uint                 dwAuthDataFlags;
        public ushort               wNumPrivileges;
        [WireInfo(ArraySize=SgDefs.XONLINE_NUM_PRIVILEGE_DWORDS)]
        public uint[]               dwPrivileges;
        public ulong                qwXboxID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public XUID[]               users;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public float[]              afltTrustFactor;
        public uint                 wNumDwordServices;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]               dwServiceID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_ALTERNATE_TITLE_ID)]
        public uint[]               dwAltTitleID;
        [WireInfo(ArraySize=SgDefs.XONLINE_KEY_LENGTH)]
        public byte[]               abKey;
    }

    public class CSgMsgSpiData : WireData
    {
        public CSgMsgSpiData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA, 54 );
        }

        public CSgMsgHdr            header;
        public ushort               _ipportI;                   // IP port of the client on the Internet
        public uint                 _ipaI;                      // IP address of the client on the Internet
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ushort               _wVersionKeyEx;             // KeyEx version of the client
        public ushort               _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        public long                 _liNonce;                   // A random nonce associated with this session
        public long                 _liTimeInit;                // FILETIME marking session initiation
        public uint                 _fCs;                       // TRUE if SG is providing connection services
    }

    public class CSgMsgSpiReq : WireData
    {
        public CSgMsgSpiReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ, 14 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Request number from requester
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
    }

    public class CSgMsgSpiReq2 : WireData
    {
        public CSgMsgSpiReq2()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ2, 16 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Request number from requester
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
        public ushort               _wAuthDataVersion;          // Maximum supported authdata version
    }

    public class CSgMsgSpiRep : WireData
    {
        public CSgMsgSpiRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REP, 15 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Copy of _dwReqNum from request
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
        public bool                 _fNotFound;                 // TRUE if client not found (no auth-data enclosed)

        [WireInfo(Serialize=false)]
        public CSgMsgSpiData        _spiData;                   // only present if _fNotFound is FALSE

        [WireInfo(Serialize=false)]
        public CAuthData            _authData;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( !_fNotFound )
            {
                _spiData = new CSgMsgSpiData();
                _spiData.ReadStream( binaryReader );
                _authData = new CAuthData();
                _authData.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( !_fNotFound )
            {
                _spiData.WriteStream( binaryWriter );
                _authData.WriteStream( binaryWriter );
            }
        }
    }

    public class CSgMsgSetQValsReq : WireData
    {
        public CSgMsgSetQValsReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_LAZY, 36 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context to be returned in reply

        // The rest of this entry contains a packed series of CQVal structures.
        [WireInfo(Serialize=false)]
        public uint[]               _qvals;

        public void SetPush()
        {
            header._wType = (ushort) SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_PUSH;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( header._cbEnt > 36 )
            {
                ushort cbQVals = (ushort)( header._cbEnt - 36 );
                ushort cQVals = (ushort)( cbQVals / 4 );
                _qvals = new uint[ cQVals ];
                for( int iQVal = 0; iQVal < cQVals; iQVal++ )
                {
                    _qvals[ iQVal ] = binaryReader.ReadUInt32();
                }
            }
            else
            {
                // Make _qvals.Length valid even when there aren't any
                _qvals = new uint[ 0 ];
            }

            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            header._cbEnt = (ushort)(36 + (_qvals.Length * 4));
            base.WriteStream(binaryWriter);
            for (int iQVal = 0; iQVal < _qvals.Length; iQVal++)
            {
                binaryWriter.Write(_qvals[iQVal]);
            }
        }
    }

    public class CSgMsgSetQValsRep : WireData
    {
        public CSgMsgSetQValsRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_REP, 38 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context from corresponding request
        public bool                 _fNotFound;                 // TRUE if client not found
        public bool                 _fNoSuchUser;               // TRUE if SG doesn't know about qwUserId
    }

    public class CSgMsgKickReq : WireData
    {
        public CSgMsgKickReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REQ, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client to kick
    }

    public class CSgMsgKickRep : WireData
    {
        public CSgMsgKickRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REP, 25 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that was kicked
        public bool                 _fNotFound;                 // TRUE if client not found
    }

    public class CSgMsgXbToXbForward : WireData
    {
        public CSgMsgXbToXbForward()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_XBTOXB_FORWARD, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the target client

        // The rest of this entry contains the actual message being forwarded.
    }

    // If _sgaddr._dwSpiSg and _sgaddr._qwXboxId are zero, then the whole SG is going offline
    public class CSgMsgNotifyCliDelete : XRLObject2
    {
        public CSgMsgNotifyCliDelete()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL, 28 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that is going offline
        public uint                 _dwTitleId;                 // The title the client was last in

        public override int Size()
        {
            return 28;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwTitleId = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_26, 
                    "Reached end of stream trying to read CSgMsgNotifyCliDelete", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliUpdate : XRLObject2
    {
        public CSgMsgNotifyCliUpdate()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_UPD, 310 );
            _sgaddr = new SGADDR();
            _rgbTitleData = new byte[ 256 ];
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr; // SGADDR of the client that was updated
        public ulong                _qwUserId;
        public ulong                _qwXnkid;
        public uint                 _dwAuthFlags;
        public uint                 _dwState;
        public uint                 _dwTitleId;
        public ushort               _cbTitleData;

        [WireInfo(ArraySize=256)]
        public byte[]               _rgbTitleData;

        public override int Size()
        {
            return 310;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _qwUserId = binaryReader.ReadUInt64();
                _qwXnkid = binaryReader.ReadUInt64();
                _dwAuthFlags = binaryReader.ReadUInt32();
                _dwState = binaryReader.ReadUInt32();
                _dwTitleId = binaryReader.ReadUInt32();
                _cbTitleData = binaryReader.ReadUInt16();
                _rgbTitleData = binaryReader.ReadBytes(256);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_27, 
                    "Reached end of stream trying to read CSgMsgNotifyCliUpdate", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliTitleChange : XRLObject2
    {
        public CSgMsgNotifyCliTitleChange()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG, 32 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;
        public uint                 _dwOldTitleId;
        public uint                 _dwNewTitleId;

        public override int Size()
        {
            return 32;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwOldTitleId = (uint)binaryReader.ReadInt32();
                _dwNewTitleId = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_28, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }

    }

} // namespace STF.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\sqlclient.cs ===
/*==========================================================================
 *
 *  sqlclient.cs
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using STF.common.config;
using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.sqltrace)]

namespace STF.common.sql.sqlclient
{
    public class SqlClient : IDisposable
    {
        private StringBuilder _paramString = new StringBuilder();
        private bool _isFirstParam = true;
        private bool _closeUnderlyingConnection = true;
        private SqlCommand _cmd;


        // Allow initialization for typed interfaces such as NPDB
        public SqlClient(IInterfaceInfo iface)
        {
            Initialize(BuildConnectionString(iface));
        }

        // Allow initialization for typed virtualized interfaces such as CatalogDB
        public SqlClient(IVirtualInterfaceInfo viface)
        {
            Initialize(BuildConnectionString(viface));
        }

        // Assume the interface in question is a singleton, such as NPDB
        public SqlClient(string iface) : this(iface, false)
        {
        }

        // Find the referenced interface or virtualInterface
        public SqlClient(string iface, bool isVirtual)
        {
            if (iface == Interface.npdb)
            {
                // Special case for npdb connections, because it isn't required to
                // load the config from npdb in order to figure out how to talk to npdb
                Initialize(Config.NpdbConnectionString);
            }
            else if (isVirtual)
            {
                IVirtualInterfaceInfo iVirtualInterfaceInfo = null;
                iVirtualInterfaceInfo = Config.GetVirtualInterface(iface);
                Initialize(BuildConnectionString(iVirtualInterfaceInfo));
            }

            else
            {
                IInterfaceInfo iInterfaceInfo = null;
                iInterfaceInfo = Config.GetSingleInterface(iface);
                Initialize(BuildConnectionString(iInterfaceInfo));
            }
        }

        // Lookup based partitioning
        public SqlClient(string iface, uint titleid, uint bucket)
        {
            IBucketServer bucketServer = Config.GetTitleBucketServer(iface, titleid, bucket);

            if (null == bucketServer)
            {
                throw new XRLException(HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.MC_BAD_CONFIG_DATA_5,
                        "SqlClient.SqlClient: BucketServer not found for " + iface.ToString() + " titleid " + titleid + " bucket " + bucket);
            }

            IInterfaceInfo iInterfaceInfo = bucketServer.CurrentServer;

            Initialize(BuildConnectionString(iInterfaceInfo));
        }


        private string Initialize(string cxnStr)
        {
            SqlConnection cxn;

            cxn = new SqlConnection(cxnStr);
            cxn.Open();

            _cmd = new SqlCommand("", cxn);

            // Propagate the timeout value from NPDB to the command
            SqlConnectionStringBuilder  scsb = new SqlConnectionStringBuilder(cxnStr);
            _cmd.CommandTimeout = scsb.ConnectTimeout;

            return cxnStr;
        }

        public string StoredProc
        {
            get { return _cmd.CommandText; }
            set
            {
                _cmd.CommandText = value;
                _cmd.CommandType = CommandType.StoredProcedure;
            }
        }

        public SqlCommand Command
        {
            get { return _cmd; }
            set { _cmd = value; }
        }

        /// <summary>
        /// Wrapper for AddParameter junk.  This version assumes Input parameter type.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="val">The value of the parameter</param>
        public void AddParameter(string name, string val)
        {
            AddParameter(ParameterDirection.Input, name, val, val.Length);
        }
        public void AddParameter(ParameterDirection pt, string name, string val, int len)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.NVarChar;
            param.Value = val;
            param.Size = len;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "='" + val + "'");
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Wrapper for AddParameter junk.  This version assumes Input parameter type.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="val">The value of the parameter</param>
        public void AddParameter(string name, byte[] val)
        {
            AddParameter(ParameterDirection.Input, name, val, (val == null ? 0 : val.Length));
        }
        public void AddParameter(ParameterDirection pt, string name, byte[] val, int len)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Binary;
            param.Value = val;
            param.Size = len;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=0x" + ByteConvert.ToString(val));
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }


        }

        /// <summary>
        /// Overloaded method for ints.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, byte val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, byte val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.TinyInt;
            param.Value = val;

            _cmd.Parameters.Add(param);


            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for shorts.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, short val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, short val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.SmallInt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }


        /// <summary>
        /// Overloaded method for ushorts.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, ushort val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, ushort val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.SmallInt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }


        /// <summary>
        /// Overloaded method for ints.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, int val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, int val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Int;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for uints.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, uint val)
        {
            AddParameter(ParameterDirection.Input, name, (int)val);
        }
        public void AddParameter(ParameterDirection pt, string name, uint val)
        {
            AddParameter(pt, name, (int)val);
        }

        /// <summary>
        /// Overloaded method for longs.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, long val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, long val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.BigInt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for ulongs.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, ulong val)
        {
            AddParameter(ParameterDirection.Input, name, (long)val);
        }
        public void AddParameter(ParameterDirection pt, string name, ulong val)
        {
            AddParameter(pt, name, (long)val);
        }

        /// </summary>
        public void AddParameter(string name, DateTime val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, DateTime val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.DateTime;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for Guids.  Unless noted, assumes Input parameter.
        /// </summary>
        /// <param name="name">Name of the parameter.</param>
        /// <param name="val">Value to assign to the parameter.</param>
        public void AddParameter(string name, Guid val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, Guid val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.UniqueIdentifier;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val.ToString());
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Overloaded method for doubles.  Unless noted, assumes Input parameter.
        /// </summary>
        public void AddParameter(string name, double val)
        {
            AddParameter(ParameterDirection.Input, name, val);
        }
        public void AddParameter(ParameterDirection pt, string name, double val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Float;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParameterDirection.Output) _paramString.Append(" output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Overloaded method for DbType'd Objects.  Unless noted, assumes Input parameter.
        /// </summary>
        /// <param name="name">Name of the parameter.</param>
        /// <param name="val">Value to assign to the parameter.</param>
        /// <param name="dbType">The database type of the parameter</param>
        public void AddParameter(string name, object val, DbType dbType)
        {
            AddParameter(ParameterDirection.Input, name, val, dbType);
        }
        public void AddParameter(ParameterDirection pt, string name, object val, DbType dbType)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.DbType = dbType;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val.ToString());
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Add object parameter. Useful if you want to pass a DBNull value for example. I
        /// opted to name this differently from 'AddParameter' to avoid conflicts.
        /// </summary>
        /// <param name="name">Name of the parameter.</param>
        /// <param name="val">Value to assign to the parameter.</param>
        public void AddParameterObject(string name, object val)
        {
            AddParameterObject(ParameterDirection.Input, name, val);
        }
        public void AddParameterObject(ParameterDirection pt, string name, object val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = pt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParameterDirection.ReturnValue)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val.ToString());
                if (pt == ParameterDirection.Output) _paramString.Append(" Output");
                _isFirstParam = false;
            }
        }

        public string GetStringParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE, "No parameter found with the name " + name + "!");
            return (string)(param.Value == DBNull.Value ? null : param.Value);
        }

        public byte[] GetByteArrayParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_1, "No parameter found with the name " + name + "!");
            return (byte[])(param.Value == DBNull.Value ? null : param.Value);
        }

        public byte GetByteParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_2, "No parameter found with the name " + name + "!");
            return (byte)(param.Value == DBNull.Value ? 0 : param.Value);
        }

        public short GetShortParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_3, "No parameter found with the name " + name + "!");
            return (short)(param.Value == DBNull.Value ? 0 : param.Value);
        }

        public int GetIntParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_4, "No parameter found with the name " + name + "!");
            return (int)(param.Value == DBNull.Value ? 0 : param.Value);
        }

        public long GetLongParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_5, "No parameter found with the name " + name + "!");
            return (long)(param.Value == DBNull.Value ? 0 : param.Value);
        }

        public DateTime GetDateParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_6, "No parameter found with the name " + name + "!");
            return (DateTime)(param.Value == DBNull.Value ? null : param.Value);
        }

        public Decimal GetDecimalParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_15, "No parameter found with the name " + name + "!");
            return (Decimal)(param.Value == DBNull.Value ? null : param.Value);
        }

        public Guid GetGuidParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_16, "No parameter found with the name " + name + "!");
            return (Guid)(param.Value == DBNull.Value ? null : param.Value);
        }

        public static byte[] GetBytes(SqlDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);

            // find the number of bytes to be read
            long numBytes = rdr.GetBytes(ordinal, 0, null, 0, 0);

            // allocate the new buffer based on the size
            byte[] b = new byte[numBytes];

            // read the bytes
            rdr.GetBytes(ordinal, 0, b, 0, b.Length);

            return b;
        }

        /// <summary>
        /// Used to Execute the given string on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public SqlDataReader Execute(string cmd)
        {
            _cmd.CommandText = cmd;
            return Execute();
        }


        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public SqlDataReader Execute()
        {
#if !NOCSPP
            Xom.Trace(XomAreaName.sqltrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString());
#endif
            try
            {
                SprocFailure.HandleBehaviorInjection(_cmd.Connection.Database, StoredProc);
                return _cmd.ExecuteReader();
            }
            catch(Exception e)
            {
                string msg = (e is SqlException ? BuildSqlExceptionMessage((SqlException)e) : e.Message);
                msg += "\r\nConnection string: " + _cmd.Connection.ConnectionString;

                throw new XRLException(
                    GetHResult(e), XEvent.Id.SQL_EXECUTE_READER,
                    "Error executing " +  _cmd.CommandText + " " + _paramString.ToString() + "\r\n" + msg, e
                );
            }
        }

        /// <summary>
        /// Used to Execute the property Cmd to which the client is bound with specific CommandBehaviors
        /// </summary>
        /// <remarks>
        /// Specifying CommandBehavior.CloseConnection as one of the passed behaviors will alter the way that the
        /// SqlClient handles its Close() and Dispose() functionality. If CommandBehavior.CloseConnection is specified,
        /// it is expected that the caller is responsible for closing the connection by calling the Close method of the
        /// returned SqlDataReader. This allows for the separation of the code that is performing the query from the code
        /// that is processing the results, allowing the data processing code to close the connection (through SqlDataReader.Close())
        /// when it is done with it. See the code below for an example of how this is used.
        /// </remarks>
        /// <example>
        /// class CultureDataAccess
        /// {
        ///     public static SqlDataReader GetSupportedCultures()
        ///     {
        ///         SqlDataReader reader = null;
        ///         SqlClient client = new SqlClient(iface);
        ///
        ///         using (client)
        ///         {
        ///             client.StoredProc = "p_culture_GetSupportedCultures";
        ///             reader = client.Execute(CommandBehavior.CloseConnection | CommandBehavior.SingleResult);
        ///         }
        ///
        ///         return reader;
        ///     }
        /// }
        ///
        /// class SupportedCultures
        /// {
        ///     public Hashtable Cultures = null;
        ///     private void PopulateCultures()
        ///     {
        ///         Hashtable newCultures = new Hashtable();
        ///
        ///         SqlDataReader reader = CultureDataAccess.GetSupportedCultures();
        ///         using(reader)
        ///         {
        ///             int userLanguageOrdinal = reader.GetOrdinal("UserLanguage");
        ///             int cultureOrdinal = reader.GetOrdinal("CultureName");
        ///
        ///             while (reader.Read())
        ///             {
        ///                 newCultures.Add((string) reader.GetValue(userLanguageOrdinal), (string) reader.GetValue(cultureOrdinal));
        ///             }
        ///         }
        ///         cultures = newCultures;
        ///     }
        /// }
        /// </example>
        /// <param name="behavior">Provides a description of the results of the query and its effect on the database.</param>
        /// <returns>A SqlDataReader containing the results of the query.</returns>
        public SqlDataReader Execute(CommandBehavior behavior)
        {
#if !NOCSPP
            Xom.Trace(XomAreaName.sqltrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString());
#endif
            SqlDataReader reader = null;

            try
            {
                SprocFailure.HandleBehaviorInjection(_cmd.Connection.Database, StoredProc);
                reader = _cmd.ExecuteReader(behavior);
            }
            catch(Exception e)
            {
                string msg = (e is SqlException ? BuildSqlExceptionMessage((SqlException)e) : e.Message);
                msg += "\r\nConnection string: " + _cmd.Connection.ConnectionString;

                throw new XRLException(GetHResult(e),
                    XEvent.Id.SQL_EXECUTE_READER_BEHAVIOR,
                    "Error executing " +  _cmd.CommandText + " " + _paramString.ToString() + "\r\n" + msg, e
                );
            }

            if ((behavior & CommandBehavior.CloseConnection) == CommandBehavior.CloseConnection)
            {
                _closeUnderlyingConnection = false;
            }

            return reader;

        }
        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound, without returning a resultset.
        /// </summary>
        public void ExecuteNonQuery(string cmd)
        {
            _cmd.CommandText = cmd;
            ExecuteNonQuery();
        }

        public void ExecuteNonQuery()
        {
#if DEBUG && !NOCSPP
            Xom.Trace(XomAreaName.sqltrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString() );
#endif
            try
            {
                SprocFailure.HandleBehaviorInjection(_cmd.Connection.Database, StoredProc);
                _cmd.ExecuteNonQuery();
            }
            catch(Exception e)
            {
                string msg = (e is SqlException ? BuildSqlExceptionMessage((SqlException)e) : e.Message);
                msg += "\r\nConnection string: " + _cmd.Connection.ConnectionString;

                throw new XRLException(
                    GetHResult(e), XEvent.Id.SQL_EXECUTE_NON_QUERY,
                    "Error executing " +  _cmd.CommandText + " " + _paramString.ToString() + "\r\n" + msg, e
                );
            }
        }


        public object ExecuteScalar()
        {
#if DEBUG && !NOCSPP
            Xom.Trace(XomAreaName.sqltrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString() );
#endif
            try
            {
                SprocFailure.HandleBehaviorInjection(_cmd.Connection.Database, StoredProc);
                return _cmd.ExecuteScalar();
            }
            catch(Exception e)
            {
                string msg = (e is SqlException ? BuildSqlExceptionMessage((SqlException)e) : e.Message);

                throw new XRLException(
                    GetHResult(e), XEvent.Id.SQL_EXECUTE_SCALAR,
                    "Error executing " +  _cmd.CommandText + " " + _paramString.ToString() + "\r\n" + msg, e
                );
            }
        }

        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public XmlReader ExecuteXmlReader()
        {
#if DEBUG && !NOCSPP
            Xom.Trace(XomAreaName.sqltrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString());
#endif
            try
            {
                SprocFailure.HandleBehaviorInjection(_cmd.Connection.Database, StoredProc);
                return _cmd.ExecuteXmlReader();
            }
            catch(Exception e)
            {
                string msg = (e is SqlException ? BuildSqlExceptionMessage((SqlException)e) : e.Message);
                msg += "\r\nConnection string: " + _cmd.Connection.ConnectionString;

                throw new XRLException(
                    GetHResult(e), XEvent.Id.SQL_EXECUTE_READER,
                    "Error executing " +  _cmd.CommandText + " " + _paramString.ToString() + "\r\n" + msg, e
                );
            }
        }



        public void BeginTransaction()
        {
            if (_cmd.Transaction != null)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_74,
                    "Attempted to create a transaction when one is already pending!"
                );
            }

            _cmd.Transaction = _cmd.Connection.BeginTransaction();
        }

        public void CommitTransaction()
        {
            if (_cmd.Transaction == null)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_75,
                    "Attempting to commit a non-existent transaction!"
                );
            }

            _cmd.Transaction.Commit();
            _cmd.Transaction = null;
        }

        public void RollbackTransaction()
        {
            if (_cmd.Transaction == null)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_76,
                    "Attempting to roll back a non-existent transaction!"
                );
            }

            _cmd.Transaction.Rollback();
            _cmd.Transaction = null;
        }


        public void ClearParameters()
        {
            _paramString = new StringBuilder();
            _cmd.Parameters.Clear();
        }


        public void Close()
        {
            if (_closeUnderlyingConnection)
            {
                _cmd.Connection.Close();
            }
        }

        public void Dispose()
        {
            if (_closeUnderlyingConnection)
            {
                _cmd.Connection.Dispose();
            }
        }



        private string BuildConnectionString(IInterfaceInfo iInterfaceInfo)
        {
            if (null == iInterfaceInfo)
            {
                throw new XRLException(HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.MC_BAD_CONFIG_DATA_6,
                        "SqlClient.BuildConnectionString: Interface provided is null!");
            }

            string connectString;

            try
            {
                connectString = iInterfaceInfo.SqlConnectionString;
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.MC_BAD_CONFIG_DATA_7,
                    "SqlClient.BuildConnectionString: Can't get connection string", ex);
            }

            return connectString;
        }

        private string BuildConnectionString(IVirtualInterfaceInfo viInterfaceInfo)
        {
            if (null == viInterfaceInfo)
            {
                throw new XRLException(HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.MC_BAD_CONFIG_DATA_6,
                        "SqlClient.BuildConnectionString: VirtualInterface provided is null!");
            }

            string connectString;

            try
            {
                connectString = viInterfaceInfo.SqlConnectionString;
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.MC_BAD_CONFIG_DATA_7,
                    "SqlClient.BuildConnectionString: Can't get connection string", ex);
            }

            return connectString;
        }


        private static string BuildSqlExceptionMessage(SqlException e)
        {
            StringBuilder bldr = new StringBuilder();
            bldr.Append(e.Message + "\r\n\r\n");

            foreach (SqlError serr in e.Errors)
            {
                bldr.Append(serr.ToString() + "\r\n");
            }

            return bldr.ToString();
        }

        public static HResult GetHResult(Exception e)
        {
            if (e is SqlException)
            {
                // to lower up front to ease comparisons
                string message = e.Message.ToLower();

                if (message.Contains("timeout"))
                    return HResult.XONLINE_E_DATABASE_TIMEOUT;
                else if (message.Contains("deadlock"))
                    return HResult.XONLINE_E_DATABASE_DEADLOCK;
                else if (message.Contains("primary key constraint") || message.Contains("unique key constraint"))
                    return HResult.XONLINE_E_DATABASE_DUPLICATE_KEY;
                else if (message.Contains("reference constraint") || message.Contains("foreign key constraint")) {
                    return HResult.XONLINE_E_DATABASE_FOREIGN_KEY_VIOLATION;
                }
            }

            return HResult.XONLINE_E_DATABASE_EXECUTE_ERROR;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SocialQueryProt.cs ===
﻿/*==========================================================================
 *
 *  SocialQueryProt.cs -- This module defines the wire protocol for social query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/
using STF.common.service;

namespace STF.common.protocol.socialquery
{
    #region Basic wiredata objects

    public class SocialQueryDefs
    {
        // SQ_FLAG_* constants correspond to XONLINE_FRIENDSTATE_FLAG_* constants on the client

        public const uint SQ_FLAG_ONLINE = 0x00000001; // Set if online

        public const uint SQ_FLAG_PARTY_PLAYING = 0x00000800; // Set if the user is in a party

        public const uint SQ_FLAG_FRIEND_REQUEST_ACCEPTED = 0x00000000;
        public const uint SQ_FLAG_SENTREQUEST = 0x40000000;
        public const uint SQ_FLAG_RECEIVEDREQUEST = 0x80000000;
    }

    public class SocialQueryUser : WireData
    {
        public SocialQueryUser()
        {
        }

        public SocialQueryUser(ulong Xuid, string Gamertag, uint UserState, uint FriendStatus, uint TitleId)
        {
            this.Xuid = Xuid;
            this.Gamertag = Gamertag;
            this.TitleId = TitleId;

            // Generate the Flags field that the client expects.
            if ((UserState & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE)
                this.Flags |= SocialQueryDefs.SQ_FLAG_ONLINE;

            if ((UserState & PresDefs.P_STATE_MASK_PARTY_PLAYING) == PresDefs.P_STATE_MASK_PARTY_PLAYING)
                this.Flags |= SocialQueryDefs.SQ_FLAG_PARTY_PLAYING;

            if ((FriendStatus & PresDefs.P_BUDDY_STATUS_PENDING) == PresDefs.P_BUDDY_STATUS_PENDING)
                this.Flags |= SocialQueryDefs.SQ_FLAG_SENTREQUEST;

            if ((FriendStatus & PresDefs.P_BUDDY_STATUS_REQUEST) == PresDefs.P_BUDDY_STATUS_REQUEST)
                this.Flags |= SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST;
        }

        public ulong Xuid;

        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string Gamertag;

        // User flags - party playing, online status, friend status
        // See SocialQueryDefs for valid values.
        public uint Flags;

        // Title currently being played
        public uint TitleId;
    }

    /// <summary>
    /// Types of sorting available to the GetFriendsXrlRequest
    /// </summary>
    public enum GetFriendSortType : uint
    {
        Activity,
        Gamertag,
        OnlineStatus
    }

    /// <summary>
    /// Describes the paging information requested by the client
    /// </summary>
    public class PagingInfo : WireData
    {
        /// <summary>
        /// Size of the page to return
        /// </summary>
        public int              PageSize;

        /// <summary>
        /// Index within the sorted response to begin the returned page
        /// </summary>
        public int              PageStart;

        /// <summary>
        /// Xuid of the user to focus on when pivoting.
        /// </summary>
        public ulong            FocusXuid;
    }

    #endregion

    #region XrlRequest objects

    /// <summary>
    /// The basic friends list request for the current user.
    /// </summary>
    public class GetFriendsXrlRequest : XRLObject2
    {
        /// <summary>
        /// The requesting user
        /// </summary>
        public ulong              RequestorXuid;

        /// <summary>
        /// The owner xuid
        /// </summary>
        public ulong              OwnerXuid;

        /// <summary>
        /// The locale id of the requesting user.
        /// </summary>
        public ushort             LocaleId;

        /// <summary>
        /// How the response should be sorted
        /// </summary>
        public GetFriendSortType  SortType;

        /// <summary>
        /// Title Id used when sorting by activity
        /// </summary>
        public uint               TitleId;

        /// <summary>
        /// Paging information.
        /// </summary>
        public PagingInfo         PagingInfo;

        /// <summary>
        /// The Xrl
        /// </summary>
        public override string  Xrl 
        {
            get { return ("/socialqueryfd/getfriends.ashx"); }
        }
    }

    #endregion

    #region XrlResponse objects

    /// <summary>
    /// Response to GetFriendsXrlRequest,
    /// GetFavoriteFriendsXrlRequest,
    /// GetOnlineFriendsXrlRequest
    /// & GetPendingAndSuggestedFriendsXrlRequest
    /// </summary>
    public class GetFriendsXrlResponse : XRLObject2
    {
        /// <summary>
        /// The hr.
        /// </summary>
        public HResult              hr;

        /// <summary>
        /// The requesting Xuid
        /// </summary>
        public ulong                RequestorXuid;

        /// <summary>
        /// The owner xuid
        /// </summary>
        public ulong                OwnerXuid;

        /// <summary>
        /// The version of the friend list
        /// </summary>
        public uint                 FriendListVersion;

        /// <summary>
        /// The total number of users in the response set
        /// </summary>
        public uint                 TotalNumUsers;

        /// <summary>
        /// The start index of the page within the total set
        /// </summary>
        public uint                 PageStartIndex;

        /// <summary>
        /// The number of friends in this page
        /// </summary>
        public uint                 NumFriends;

        /// <summary>
        /// The page of results
        /// </summary>
        [WireInfo(SizeParam = "NumFriends")]
        public SocialQueryUser[]    Friends;
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\StorageConstants.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage 
 * 
 * StorageConstants.cs
 * 
 * Protocol stuff
 * 
 * */


namespace STF.common.protocol 
{
    // Protocol Constants
    public class ProtocolConstants
    {
        public const int    sizeSignature           = 100;
        public const int    sizeHash                = 20;
        public const int    maxSizeAttributes       = 256;
        public const int    maxSizeName             = 255;
        public const int    maxSizeDomain           = 63;
        public const ushort accessTokenVersion      = 1;
        public const int    sizeAccessTokenBase     = 48 + sizeSignature;
        public const int    maxAccessTokenSize      = sizeAccessTokenBase + maxSizeName;
        public const int    syncDomainReservedSize  = 64;
        public const int    maxStorageOperations    = 100;
        
        // Temporary constants. Have to transform them into configurable 
        // settings at some point.
        public const int        maxFileSize     = 10*1024*1024;
        public const string     wstStoreApp     = "StoreDb";

        public const string     AvatarDomainName = "avatar";

    }



    // Storage Operations
    public enum Operation
    {
        Undefined               = 0,
        FileWrite               = 1,
        FileRead                = 2,
        FileRemove              = 3,
        FileEnumerate           = 4,
        FileEnumeratedRead      = 5,
        ReadTitleFiles          = 6
    }

    public enum Allowed: uint
    {
        None                    = 0,
        All                     = 1,
        Owner                   = 2,
        Team                    = 4,
        UserToken               = 8,
        ServiceToken            = 16,
        ServiceAddr             = 32
    }


    // Each of these enumerations is represented by a uint and each should
    // always have an Invalid member that is defined as 1 greater than the
    // the last legal value.  This allows validation to easily be done and
    // not require changes when new legal values are added.

    // Identity Types
    public enum IdType: uint
    {
        Undefined       = 0,
        UserId          = 1,
        GroupId         = 2,
        TournamentId    = 3,
        TitleId         = 4,
        Invalid         = 5
    }

    // Storage Content Types
    public enum ContentType: uint
    {
        ContentPackage          = 0,
        ContentBlob             = 1,
        Invalid                 = 2 
    }

    // Storage Compression Types
    public enum CompressionType: uint
    {
        Uncompressed            = 0,
        NoCompression           = 1,
        LZX                     = 2,
        Invalid                 = 3
    }

    // Storage Flag Types
    public enum FlagType: uint
    {
        TeamTicket              = 1
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\StorageProtocol.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 *
 * Storage
 *
 * Protocol.cs
 *
 * Protocol stuff
 *
 * */

using System;
using System.Collections.Specialized;
using System.IO;
using System.Text;

using STF.common.service;

namespace STF.common.protocol
{
    public interface IStorageRequest
    {
        uint  Flags {get;}
        uint  TitleId {get;}
        uint  TitleVersion {get;}
        byte  UserCountryId { get; }
        ulong UserPuid {get;}
        ulong XboxPuid {get;}
        AccessToken Token { get; }
        TeamTickets Tickets { get; }
    }


    public interface IStorageRequestLight
    {
        uint TitleId { get;}
        uint TitleVersion { get;}
    }


    // ReqHdrWriteFile
    // Header of the WriteFile request
    public class ReqHdrWriteFile : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public byte         _compressionType;
        public uint         _contentType;
        public byte[]       _blobHash;
        public byte[]       _blobSignature;
        public uint         _blobSizeUncompressed;
        public ushort       _attributesSize;
        public uint         _blobSize;

        public byte[]       _attributes;
        public WriteFileToken _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/writefile.ashx";
        }

        // ReadFrom
        // Parse message from stream
        public void ReadFrom(BinaryReader r)
        {
            _accessToken              = new WriteFileToken(r);
            _titleId                  = r.ReadUInt32();
            _titleVersion             = r.ReadUInt32();
            _userCountryId            = r.ReadByte();
            _compressionType          = r.ReadByte();
            _contentType              = r.ReadUInt32();
            _blobHash                 = r.ReadBytes(ProtocolConstants.sizeHash);
            _blobSignature            = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed     = r.ReadUInt32();
            _attributesSize           = r.ReadUInt16();
            _blobSize                 = r.ReadUInt32();


            _attributes = ( 0 == _attributesSize ) ? null : r.ReadBytes(_attributesSize);

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        // WriteTo
        // Write message to stream
        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            _accessToken.WriteTo(w);

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobHash);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();

            if ( _contentType >= (uint) ContentType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_174,
                    "Validate: invalid content type: " + _contentType);
            }

            if ( _compressionType >= (uint) CompressionType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_175,
                    "Validate: invalid compression type: " + _compressionType);
            }

            if ( _attributes != null && _attributes.Length > ProtocolConstants.maxSizeAttributes )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_176,
                    "Validate: attributes size too large: " + _attributes.Length);
            }
        }

        public uint Size()
        {
            return
                ( _accessToken == null ? 0 : (uint) _accessToken.Size() ) +
                ( _attributes == null ? 0 : (uint) _attributes.Length ) +
                144;
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userCountryId:"+_userCountryId+
                " _compressionType:"+_compressionType+
                " _contentType:"+_contentType+
                " _blobHash:"+(_blobHash!=null ? "(binary)" : "null")+
                " _blobSignature:"+(_blobSignature!=null ? "(binary)" : "null")+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _attributesSize:"+_attributesSize+
                " _blobSize:"+_blobSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null")+
                " _accessToken:"+(_accessToken!=null ? "(" + _accessToken.ToString()+ ")" : "null")+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // ReqReadFile
    // ReadFile request
    public class ReqReadFile : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public uint         _rangeStart;
        public uint         _rangeEnd;
        public long         _ifModifiedSinceDate;

        public ReadFileToken  _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/readfile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();
            _userCountryId   = r.ReadByte();
            _rangeStart      = r.ReadUInt32();
            _rangeEnd        = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_rangeStart);
            w.Write(_rangeEnd);
            w.Write(_ifModifiedSinceDate);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

 
        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _rangeStart:"+_rangeStart+
                " _rangeEnd:"+_rangeEnd+
                " _ifModifiedSinceDate:"+_ifModifiedSinceDate+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // EnumeratedReadFilerequest fields
    public class EnumeratedReadFileParameters
    {
        public const string IfModifiedSince     = "_ifModifiedSinceDate";

        public const string TitleId             = "_titleId";

        public const string TitleVersion        = "_titleVersion";

        public const string PathName            = "_pathName";

        public const string PathNameSize        = "_pathNameSize";

        public const string SendXRLResponse     = "_sendXRLResponse";

    }


    // This class represents all of the data of a EnumeratedReadFile 
    public class EnumeratedReadFileInfo
    {
        public ushort _pathNameSize;
        public string _pathName;
        //public long _creationDate = new long();
        public long _modifiedDate = new long();


        public EnumeratedReadFileInfo()
        {
        }

        public EnumeratedReadFileInfo(string path, DateTime modifiedDate)
        {
            _pathName = path;
            _pathNameSize = (ushort) path.Length;
            _modifiedDate = modifiedDate.ToFileTimeUtc();
        }

        public void ReadFrom(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryReader reader = new BinaryReader(stream))
                {
                    _pathNameSize = reader.ReadUInt16();                    
                    if (_pathNameSize > 0)
                    {
                        //_pathName = Encoding.ASCII.GetString(reader.ReadBytes(_pathNameSize));
                        _pathName = reader.ReadString(); 
                    }
                    _modifiedDate = reader.ReadInt64();
                    //_creationDate = reader.ReadInt64();
                }
            }
        }

        public void WriteTo(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryWriter w = new BinaryWriter(stream))
                {
                    w.Write(_pathNameSize);
                    if (_pathNameSize > 0)
                        w.Write(_pathName);
                    w.Write(_modifiedDate);
                    //w.Write(_creationDate);
                }
            }
        }

        public int Size()
        {
                        
            if (_pathNameSize == 0)
                return (int) (sizeof(ushort) + sizeof(long) );
            else
                return (int) (sizeof(ushort) + sizeof(long) + (_pathName.Length * sizeof(char)));
        }


        // ToString
        public override string ToString()
        {
            return (
                " _path :" + _pathName 
                //+ " _creationDate:" + _creationDate
                + " _modifiedDate:" + _modifiedDate );
        }

    }


    // ReqEnumeratedReadFile
    // EnumeratedReadFile request
    public class ReqEnumeratedReadFile : IStorageRequestLight
    {
        public long _ifModifiedSinceDate;
        public uint _titleId;
        public uint _titleVersion;
        public ushort _pathNameSize;
        public string _pathName;

        //public uint _rangeStart;
        //public uint _rangeEnd;
        //public ReadFileToken _accessToken;

        public string GetXRL()
        {
            return "/stfd/enumeratedreadfile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _pathNameSize = r.ReadUInt16();
            if (_pathNameSize > 0)
            {
                _pathName = r.ReadString();
            }
            _ifModifiedSinceDate = r.ReadInt64();

            //_accessToken = new ReadFileToken(r);
            //_rangeStart = r.ReadUInt32();
            //_rangeEnd = r.ReadUInt32();           
                     
        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_pathNameSize);
            w.Write(_pathName);
            w.Write(_ifModifiedSinceDate);
        }

        public ReqEnumeratedReadFile()
        {

        }

        public ReqEnumeratedReadFile(NameValueCollection parameters)
        {


            string[] values = new string[] { };
            string key = "";

            //PathName parameter
            key = EnumeratedReadFileParameters.PathName;
            values = parameters.GetValues(key);
            if ((values == null ) || (values.Length !=1 ))
            {
                throw new ApplicationException(" PathName parameter required ");
            }
            else if (values.Length == 1)
            {
                _pathName = parameters[key];
            }


            //PathNameSize
            _pathNameSize = Convert.ToUInt16(_pathName.Length);


            //IfModifiedSince parameter
            key = EnumeratedReadFileParameters.IfModifiedSince;
            values = parameters.GetValues(key);
            if ((values == null) ||  (values.Length == 0))
            {
                _ifModifiedSinceDate = 0;
            }
            else if (values.Length == 1)
            {
                _ifModifiedSinceDate = Convert.ToDateTime(parameters[key]).ToFileTime();
            }
            else
            {
                throw new ApplicationException(" Only one IfModifiedSinceDate parameter expected");
            }


            //TitleId parameter
            key = EnumeratedReadFileParameters.TitleId;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleId = 0;
            }
            else if (values.Length == 1)
            {
                _titleId = Convert.ToUInt32(parameters[key]);
            }

            else
            {
                throw new ApplicationException(" Only one TitleId parameter expected");
            }


            //TitleVersion parameter
            key = EnumeratedReadFileParameters.TitleVersion;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleVersion = 0;
            }
            else if (values.Length == 1)
            {
                _titleVersion = Convert.ToUInt32(parameters[key]);
            }
            else
            {
                throw new ApplicationException(" Only one TitleVersion parameter expected");
            }
        }


        public void Validate()
        {
            //_accessToken.Validate();
            if (_pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName)
            {
                //XommTrace(atTrace, L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_148,
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if (_pathNameSize != _pathName.Length)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_149,
                    "Validate: pathNameSize mismatch.");
            }

        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _pathNameSize:" + _pathNameSize +
                " _pathName:" + _pathName +
                " _ifModifiedSinceDate:" + _ifModifiedSinceDate
                ;
        }

        // Implement StorageRequest properties
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
    }

    // RepReadFile
    // ReadFile reply header
    public class RepHdrReadFile
    {
        public uint         _titleId           = 0;
        public uint         _titleVersion      = 0;
        public ulong        _userPuid          = 0;
        public byte         _userCountryId     = 0;
        public ulong        _xboxPuid          = 0;
        public byte         _compressionType   = 0;
        public uint         _contentType       = 0;
        public byte[]       _blobSignature     = new byte[ProtocolConstants.sizeSignature];
        public uint         _blobSizeUncompressed = 0;
        public long         _creationDate      = 0;
        public long         _modifiedDate      = 0;
        public ushort       _attributesSize    = 0;
        public uint         _blobSize          = 0;
        public byte[]       _attributes        = null;

        public void ReadFrom(BinaryReader r)
        {
            _titleId           = r.ReadUInt32();
            _titleVersion      = r.ReadUInt32();
            _userPuid          = r.ReadUInt64();
            _userCountryId     = r.ReadByte();
            _xboxPuid          = r.ReadUInt64();
            _compressionType   = r.ReadByte();
            _contentType       = r.ReadUInt32();
            _blobSignature     = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed  = r.ReadUInt32();
            _creationDate      = r.ReadInt64();
            _attributesSize    = r.ReadUInt16();
            _blobSize          = r.ReadUInt32();

            if ( _attributesSize > 0 )
            {
                _attributes = r.ReadBytes(_attributesSize);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _compressionType:"+_compressionType+
                " _contentType:"+_contentType+
                " _blobSignature:"+_blobSignature+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _creationDate:"+_creationDate+
                " _modifiedDate:"+_modifiedDate+
                " _attributesSize:"+_attributesSize+
                " _blobSize:"+_blobSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null");
        }
    }


    // RepEnumeratedReadFile
    // EnumeratedReadFile reply header
    public class RepHdrEnumeratedReadFile
    {
        public string _path;
        public long _creationDate;
        public long _modifiedDate;

        public void ReadFrom(BinaryReader r)
        {
            _creationDate = r.ReadInt64();
        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_creationDate);
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return (
                " _path :" + _path+
                " _modifiedDate:" + _modifiedDate +
                " _creationDate:" + _creationDate );
        }
    }


    public class ReqRemoveFile : IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public RemoveFileToken _accessToken;
        public TeamTickets _teamTickets;

        public string GetXRL()
        {
            return "/stfd/removefile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken     = new RemoveFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return 0; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    public class ReadFileHashRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=ProtocolConstants.maxSizeName)]
        public ushort pathNameLen;

        [WireInfoAttribute(SizeParam="pathNameLen")]
        public string pathName;

        public override string Xrl
        {
            get { return "/stfd/readfilehash.ashx"; }
        }

        public override string ToString()
        {
            return
                " pathNameLen:"+pathName.Length+
                " pathName:"+pathName;
        }
    }

    public class ReadFileHashResponse : XRLObject2
    {
        [WireInfoAttribute(ArraySize=(int)ProtocolConstants.sizeHash)]
        public byte[] hash;

        public override string ToString()
        {
            return
                " hash:"+(hash == null ? "" : ByteConvert.ToString(hash));
        }
    }

    public class GetQuotaRequest : XRLObject2
    {
        public uint  _domainId;
        public uint  _titleId;
        public uint  _keyType;
        public ulong _keyValue;

        public override string Xrl
        {
            get { return "/stfd/getquota.ashx"; }
        }

        public override int Size()
        {
            return 20;
        }
    }

    public class GetQuotaResponse : XRLObject2
    {
        public ulong _maxFileSize;
        public ulong _totalBytesMax;
        public ulong _totalBytesUsed;
        public uint  _totalFilesMax;
        public uint  _totalFilesUsed;

        public override int Size()
        {
            return 24;
        }
    }

    public class ReportBrokenLinkRequest : XRLObject2
    {
        public uint statusData;

        [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam="pathnameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam="pathnameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameResponse : XRLObject2
    {
        public uint primaryIP;
        public ushort primaryPort;
        public uint alternateIP;
        public ushort alternatePort;
        public DateTime expiration;
        public ushort ruleLen;

        [WireInfoAttribute(SizeParam="ruleLen")]
        public string rule;
    }

    // ReqEnumerateFiles
    // EnumerateFile request
    public class ReqEnumerateFiles : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public uint         _resultsStart;
        public uint         _resultsEnd;
        public long         _ifModifiedSinceDate;

        public ReadFileToken  _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/enumeratefiles.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();
            _userCountryId   = r.ReadByte();
            _resultsStart    = r.ReadUInt32();
            _resultsEnd      = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_resultsStart);
            w.Write(_resultsEnd);
            w.Write(_ifModifiedSinceDate);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _resultsStart:"+_resultsStart+
                " _resultsEnd:"+_resultsEnd+
                " _ifModifiedSinceDate:"+_ifModifiedSinceDate+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // RepEnumerateFiles
    // ReadFile reply header
    public class RepEnumerateFiles
    {
        public uint         _titleId           = 0;
        public uint         _titleVersion      = 0;
        public ulong        _userPuid          = 0;
        public byte         _userCountryId     = 0;
        public ulong        _xboxPuid          = 0;
        public uint         _contentType       = 0;
        public uint         _blobSize          = 0;
        public uint         _blobSizeUncompressed = 0;
        public long         _creationDate      = 0;
        public long         _modifiedDate      = 0;
        public ushort       _pathNameSize      = 0;
        public ushort       _attributesSize    = 0;
        public string       _pathName          = null;
        public byte[]       _attributes        = null;

        public void ReadFrom(BinaryReader r)
        {
            _titleId           = r.ReadUInt32();
            _titleVersion      = r.ReadUInt32();
            _userPuid          = r.ReadUInt64();
            _userCountryId     = r.ReadByte();
            _xboxPuid          = r.ReadUInt64();
            _contentType       = r.ReadUInt32();
            _blobSize          = r.ReadUInt32();
            _blobSizeUncompressed  = r.ReadUInt32();
            _creationDate      = r.ReadInt64();
            _modifiedDate      = r.ReadInt64();
            _attributesSize    = r.ReadUInt16();
            _pathNameSize      = r.ReadUInt16();

            if ( _attributesSize > 0 )
            {
                _attributes = r.ReadBytes(_attributesSize);
            }
            if ( _pathNameSize > 0 )
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            byte[] encName = null;
            if ( _pathName != null )
            {
                encName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort) encName.Length;
            }
            else
            {
                _pathNameSize = 0;
            }

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_contentType);
            w.Write(_blobSize);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_modifiedDate);
            w.Write(_attributesSize);
            w.Write(_pathNameSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }
            if ( _pathName != null && _pathNameSize > 0 )
            {
                w.Write(encName);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _contentType:"+_contentType+
                " _blobSize:"+_blobSize+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _creationDate:"+_creationDate+
                " _modifiedDate:"+_modifiedDate+
                " _attributesSize:"+_attributesSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null")+
                " _pathNameSize:"+_pathNameSize+
                " _pathName:"+_pathName;
        }
    }

    public class Translator
    {
        public static ReqReadFile TranslateRequest(ReqEnumeratedReadFile reqEnum)
        {
            ReqReadFile reqReadFile = new ReqReadFile();

            reqReadFile._accessToken = null;
            reqReadFile._ifModifiedSinceDate = reqEnum._ifModifiedSinceDate;
            reqReadFile._titleId = reqEnum._titleId;
            reqReadFile._titleVersion= reqEnum._titleVersion;

            reqReadFile._rangeEnd = reqReadFile._rangeStart = 0;

            return reqReadFile;
        }

        

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SymmetricKey.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace STF.common.service
{
    [ComVisible(false)]
    public class SymmetricKey : IDisposable
    {
        private Rijndael _rijndael = new RijndaelManaged();

        public SymmetricKey()
        {
            _rijndael.Mode    = CipherMode.CBC;
            _rijndael.KeySize = 128;

            _rijndael.GenerateKey();
            _rijndael.GenerateIV();
        }

        public SymmetricKey(byte[] key, byte[] iv)
        {
            _rijndael.Mode    = CipherMode.CBC;
            _rijndael.KeySize = 128;
            _rijndael.Key     = key;
            _rijndael.IV      = iv;
        }

        public byte[] Key {
            get { return _rijndael.Key; }
        }

        public byte[] IV {
            get { return _rijndael.IV; }
        }

        public string Encrypt(string s)
        {
            return Convert.ToBase64String(Encrypt(Encoding.ASCII.GetBytes(s)));
        }

        public byte[] Encrypt(byte[] buffer)
        {
            using (MemoryStream memoryStream = new MemoryStream())
            {
                using (ICryptoTransform cryptoTransform = _rijndael.CreateEncryptor())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(buffer, 0, buffer.Length);
                        cryptoStream.FlushFinalBlock();
                    }
                }

                return memoryStream.ToArray();
            }
        }

        public byte[] Decrypt(byte[] buffer)
        {
            using (MemoryStream memoryStream = new MemoryStream(buffer))
            {
                return Decrypt(memoryStream);
            }
        }

        public byte[] Decrypt(Stream stream)
        {
            using (ICryptoTransform cryptoTransform = _rijndael.CreateDecryptor())
            {
                using (CryptoStream cryptoStream = new CryptoStream(stream, cryptoTransform, CryptoStreamMode.Read))
                {
                    using (MemoryStream memoryStream = new MemoryStream())
                    {
                        int bytesRead;
                        byte[] tempBuffer = new byte[256];

                        while ((bytesRead = cryptoStream.Read(tempBuffer, 0, tempBuffer.Length)) > 0)
                        {
                            memoryStream.Write(tempBuffer, 0, bytesRead);
                        }

                        return memoryStream.ToArray();
                    }
                }
            }
        }

        void IDisposable.Dispose()
        {
            _rijndael.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\stringprot.cs ===
// 
// StringProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// String Service Protocol Definitions
// Xbox Online Service
// 
// Author: masonb
//

using System;
using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.StringProxy)]


namespace STF.common.protocol 
{    
    //
    // String definitions
    //
    public class StringDefs
    {
        public const uint MAX_STRINGSVR_STRING_LEN                    = 512; // characters
    };
    
    //
    // Structure representing a request to look up a string from the String Service.  If
    //  the string exists, but not in the requested language, the string for the default 
    //  language will be returned.
    //  
    public class StringLookupRequest : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wLanguage;
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rgdwStringIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/getstring.ashx";
            }
        }
    };

    public class StringLookup2Request : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wNumStrings;
        public ushort           wLocaleLen;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rgdwStringIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/getstring2.ashx";
            }
        }
    };

    public class StringData : WireData
    {
        public ushort           wStringSize;

        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    };

    public class StringLookupResponse : XRLObject2
    {
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;
    };

    //
    // Structure representing a string in a single language.
    //  
    public class LanguageString : WireData
    {
        public ushort           wLanguage;
        public ushort           wStringSize;

        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    }

    public class LocaleString : WireData
    {
        public ushort           wLocaleLen;
        public ushort           wStringSize;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;
        
        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    }

    //
    // Structure representing a request to add a new string to the String Service.  Strings
    //  are specified in one or more languages with one language being chosen as the default
    //  language to return if a string is requested in an unknown language.
    //  
    public class StringAddRequest : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwStringID;         // Use 0xFFFFFFFF to have the service pick an available ID
        public DateTime         dtExpire;
        public ushort           wDefaultLanguage;
        public byte             cLangStrings;
        public bool             fVetText;

        [WireInfo(SizeParam="cLangStrings")]
        public LanguageString[] rgLangStrings;

        public override string Xrl
        {
            get
            {
                return "/msgserver/addstring.ashx";
            }
        }
    };

    public class StringAddResponse : XRLObject2
    {
        public uint             dwStringID;
    };

    public class StringAdd2Request : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwStringID;         // Use 0xFFFFFFFF to have the service pick an available ID
        public DateTime         dtExpire;
        public ushort           wLocaleLen;
        public byte             cLocaleStrings;
        public bool             fVetText;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szDefaultLocale;
        
        [WireInfo(SizeParam="cLocaleStrings")]
        public LocaleString[]   rgLocaleStrings;

        public override string Xrl
        {
            get
            {
                return "/msgserver/addstring2.ashx";
            }
        }
    };

    public class StringAdd2Response : XRLObject2
    {
        public uint             dwStringID;
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rghrString;
    };


    //
    // Structure representing a request to vet a particular string for profanity.
    //  
    public class StringVetRequest : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wLanguage;
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;

        public override string Xrl
        {
            get
            {
                return "/msgserver/vetstring.ashx";
            }
        }
    };

    public class StringVet2Request : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwFlags;
        public ushort           wLocaleLen;
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;
        
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;

        public override string Xrl
        {
            get
            {
                return "/msgserver/vetstring2.ashx";
            }
        }
    };
    
    public class StringVetResponse : XRLObject2
    {
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rghrString;
    };

    //
    // Structure representing a request to look-up the text representation of a title ID.
    //  
    // NOTE: StringLookupResponse is used to respond
    //
    public class V1TitleIDRequest : XRLObject2
    {
        public ushort           wType; // type=1 for title id lookups, 0 was used for message lookups
        public ushort           wLanguage;
        public ushort           wNumTitles;

        [WireInfo(SizeParam="wNumTitles")]
        public uint[]           rgdwTitleIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/msgserver.ashx";
            }
        }
    };

    public class StringLogRequest : XRLObject2
    {
        public ushort          logLinesLength;
      
        [WireInfo(SizeParam="logLinesLength")]
        public string          logLines;
        
        public override string Xrl
        {
            get
            {
                return "/msgserver/logstring.ashx";
            }
        }
    };    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\TargetDictionary.cs ===
using System.Runtime.InteropServices;

using STF.common.config;

namespace STF.common.mgmt
{
[ComVisible(false)]
public class TargetDictionary : XomDictionary<XomLogTarget>
{
    public TargetDictionary() : base()
    {
    }

    private XomLogTarget Add(string key, string[,] parameters, uint requestnum)
    {
        XomLogTarget target = null;
        string type = null;
        bool persist = true;

        //
        // find the target type
        //
        for (int n = 0; n < parameters.GetLength(0); n++)
        {
            if (parameters[n,0] == "type")
            {
                type = parameters[n,1];
            }
            else if (parameters[n, 0] == "persist")
            {
                string val = parameters[n, 1].ToLower();
                persist = val == "true" || val == "on" || val == "1";
            }
        }

        if (type == null)
        {
            // TODO: log event
            return null;
        }

        type = type.ToLower();

        //
        // create a log of the appropriate type
        //
        switch (type)
        {
        case "debugoutput":
            target = new XomDebugOutputTarget(null);
            break;

        case "console":
            target = new XomConsoleTarget(null);
            break;

        case "ntlog":
            target = new XomNtLogTarget(parameters);
            break;

        case "remote":
            target = new XomRemoteTarget(parameters);
            break;

        case "file":
            target = new XomFileTarget(parameters);
            break;

        case "report":
            target = new XomReportTarget(parameters);
            break;

        default:
            // TODO: log event
            break;
        }

        if (target != null)
        {
            target.Name = key;
            target.Session = persist ? 0 : requestnum;
            target.Params = ConfigUtil.GetParams(parameters);
            this[key] = target;
        }
        return target;
    }

    public XomLogTarget Add(string key, string settings)
    {
        string[,] parameters = ConfigUtil.GetParams(settings);

        return Add(key, parameters, 0 );
    }

    public XomLogTarget Add(string key, string settings, string defaultSettings)
    {

        string[,] parameters = ConfigUtil.GetParams(settings, defaultSettings);

        return Add(key, parameters, 0 );
    }

    public XomLogTarget Add(string key, string settings, uint requestnum)
    {
        string[,] parameters = ConfigUtil.GetParams(settings);

        return Add(key, parameters, requestnum );
    }

}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\teamprot.cs ===
// 
// Message.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Service Integration
// Xbox Online Service
// 
// Author: phansen
//

using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.TeamProxy)]

namespace STF.common.protocol 
{    
    //
    // Teams Definitions
    //
    public class TeamDefs
    {
        public const uint MAX_TEAM_COUNT                            = 8;
        public const uint MAX_TEAM_MEMBER_COUNT                     = 100;

        //
        // Unicode zero-teminated strings length
        //
        public const uint MAX_TEAM_NAME_SIZE                        = 16;
        public const uint MAX_TEAM_DESCRIPTION_SIZE                 = 256;
        public const uint MAX_TEAM_MOTTO_SIZE                       = 256;
        public const uint MAX_TEAM_URL_SIZE                         = 256;

        public const uint MAX_TEAM_DATA_SIZE                        = 100;
        public const uint MAX_TEAM_MEMBER_DATA_SIZE                 = 100;

        //
        // Team constants
        //
        public const uint MAX_TEAMS                                 = MAX_TEAM_COUNT;
        public const uint MAX_TEAM_NAME_CHAR                        = MAX_TEAM_NAME_SIZE;
        public const uint MAX_TEAM_NAME_BYTES                       = MAX_TEAM_NAME_SIZE * 2;
        public const uint MAX_TEAM_DESCRIPTION_CHAR                 = MAX_TEAM_DESCRIPTION_SIZE;
        public const uint MAX_TEAM_DESCRIPTION_BYTES                = MAX_TEAM_DESCRIPTION_SIZE * 2;
        public const uint MAX_TEAM_MOTTO_CHAR                       = MAX_TEAM_MOTTO_SIZE;
        public const uint MAX_TEAM_MOTTO_BYTES                      = MAX_TEAM_MOTTO_SIZE * 2;
        public const uint MAX_TEAM_URL_CHAR                         = MAX_TEAM_URL_SIZE;
        public const uint MAX_TEAM_URL_BYTES                        = MAX_TEAM_URL_SIZE * 2;
        public const uint MAX_TEAM_DATA_BYTES                       = MAX_TEAM_DATA_SIZE;
        public const uint MAX_TEAM_MEMBER_DATA_BYTES                = MAX_TEAM_MEMBER_DATA_SIZE;
        
    };
    
    public class TeamsXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xteams.srf";
            }
        }   
    }

    //
    // Structure Representing a request to get a team ticket for a ser
    //  maps to PMSG_TEAM_GET_TICKET in STF.x
    //  
    public class TeamGetTicketMsg : XRLObject2
    {
        public TeamGetTicketMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_GET_TICKET,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( PMSG_TEAM_GET_TICKET )
            return 44;
        }        
        
    };

    //
    // Structure Representing the reply to an TeamGetTicketMsg message
    //  maps to PMSG_TEAM_GET_TICKET_REPLY in STF.x
    //  
    public class TeamGetTicketReply : XRLObject2
    {
        public TeamGetTicketReply()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_GET_TICKET_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public TeamTicket       sTeamTicket;

        public override int Size()
        {
            // sizeof( PMSG_TEAM_GET_TICKET_REPLY )
            return 36 + sTeamTicket.Size();
        }        
    };

    //
    //  Maps to P_TEAM_CREATE_MSG in STF.x
    //  
    public class TeamCreateMsg : TeamsXrlObject
    {
        public TeamCreateMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             dwMaxMembers;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;
        public short            cbCreatorData;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;
        
        [WireInfo(SizeParam="cbCreatorData")]
        public byte[]           rgbCreatorData;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamCreateMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData
            return 32 + 28 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData;
        }
    };

    public class TeamCreateXeMsg : TeamCreateMsg
    {
        public TeamCreateXeMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE_XE,this);
        }
    }

    //
    //  Maps to P_TEAM_CREATE_REPLY_MSG in STF.x
    //  
    public class TeamCreateReplyMsg : XRLObject2
    {
        public TeamCreateReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwTeamID;
        public ulong            ftCreated;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamCreateReplyMsg )
            return 32 + 20;
        } 
    }; 

    //
    //  Maps to P_TEAM_DELETE_MSG in STF.x
    //  
    public class TeamDeleteMsg : TeamsXrlObject
    {
        public TeamDeleteMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_DELETE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamDeleteMsg )
            return 32 + 20;
        } 
    };
 
    //
    // Structure Representing a request to get a team ticket for a ser
    //  maps to P_TEAM_DELETE_REPLY_MSG in STF.x
    //  
    public class TeamDeleteReplyMsg : XRLObject2
    {
        public TeamDeleteReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_DELETE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamDeleteReplyMsg )
            return 32 + 4;
        } 
    };

    //
    // Maps to P_TEAM_REMOVE_MSG in STF.x
    //  
    public class TeamRemoveMsg : TeamsXrlObject
    {
        public TeamRemoveMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_REMOVE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRemoveMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData
            return 32 + 28;
        }
    };
 
    //
    //  Maps to P_TEAM_REMOVE_REPLY_MSG in STF.x
    //  
    public class TeamRemoveReplyMsg : XRLObject2
    {
        public TeamRemoveReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_REMOVE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRemoveReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_MANAGE_TEAM_MSG in STF.x
    //  
    public class TeamManageTeamMsg : TeamsXrlObject
    {
        public TeamManageTeamMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData
            return 32 + 30 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData;
        }
    };

    public class TeamManageTeamXeMsg : TeamManageTeamMsg
    {
        public TeamManageTeamXeMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM_XE,this);
        }
    }

    //
    //  Maps to P_TEAM_MANAGE_TEAM_REPLY_MSG in STF.x
    //  
    public class TeamManageTeamReplyMsg : XRLObject2
    {
        public TeamManageTeamReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamReplyMsg )
            return 32 + 4;
        } 
    };
 
    //
    //  Maps to P_TEAM_MANAGE_MEMBER_MSG in STF.x
    //  
    public class TeamManageMemberMsg : TeamsXrlObject
    {
        public TeamManageMemberMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_MEMBER,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;
        public uint             dwMemberPriv;
        public short            cbMemberData;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbMemberData
            return 32 + 34 + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_MANAGE_MEMBER_REPLY_MSG in STF.x
    //  
    public class TeamManageMemberReplyMsg : XRLObject2
    {
        public TeamManageMemberReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_MEMBER_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageMemberReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_RECRUIT_MSG in STF.x
    //  
    public class TeamRecruitMsg : TeamsXrlObject
    {
        public TeamRecruitMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_RECRUIT,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szMemberName;
        public uint             dwMemberPriv;
        public uint             dwMessageFlags;
        public short            cbMemberData;
        public short            cbDetails;

        [WireInfo(SizeParam="cbDetails")]
        public byte[]           rgbDetails;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;  

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbDetails + cbMemberData
            return 32 + 56 + cbDetails + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_RECRUIT_REPLY_MSG in STF.x
    //  
    public class TeamRecruitReplyMsg : XRLObject2
    {
        public TeamRecruitReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_RECRUIT_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRecruitReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_JOIN_MSG in STF.x
    //  
    public class TeamJoinMsg : TeamsXrlObject
    {
        public TeamJoinMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_JOIN,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public uint             dwRecruitMsgID;
        public byte             bAnswer;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamJoinMsg )
            return 32 + 25;
        }
    };

    //
    //  Maps to P_TEAM_JOIN_REPLY_MSG in STF.x
    //  
    public class TeamJoinReplyMsg : XRLObject2
    {
        public TeamJoinReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_JOIN_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamJoinReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_REPLY_TEAM in STF.x
    //  
    public class ReplyTeam : TeamsXrlObject
    {
        public ulong            qwTeamID;
        public uint             dwNumMembers;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;
        public ulong            ftCreated;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;

        public override int Size()
        {
            // sizeof( ReplyTeam ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData
            return 30 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData;
        } 
    };

    //
    //  Maps to P_REPLY_USER_TEAM in STF.x
    //  
    public class ReplyUserTeam : WireData
    {
        public ulong            qwTeamID;
        public uint             fMember;

        [WireInfo(ArraySize=(int)TeamDefs.MAX_TEAM_NAME_BYTES)]
        public byte[]           rgbTeamName;

        public override int Size()
        {
            // sizeof( ReplyUserTeam ) 
            return 12 + (int)TeamDefs.MAX_TEAM_NAME_BYTES;
        } 
    };

    //
    //  Maps to P_REPLY_TEAM_MEMBER in STF.x
    //  
    public class ReplyTeamMember : XRLObject2
    {
        public ulong            qwMemberID;
        public byte             cbMemberName;
        public uint             fMember;
        public uint             dwMemberPriv;
        public short            cbMemberData;
        public ulong            ftJoined;

        [WireInfo(SizeParam="cbMemberName")]
        public string           szMemberName;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;

        public override int Size()
        {
            // sizeof( ReplyTeamMember ) + cbMemberName + cbMemberData
            return 27 + cbMemberName + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_MSG in STF.x
    //  
    public class TeamListTeamsMsg : TeamsXrlObject
    {
        public TeamListTeamsMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_TEAMS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             cTeamIDs;

        [WireInfo(SizeParam="cTeamIDs")]
        public ulong[]          rgqwTeamIDs;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListTeamsMsg )
            return 32 + 16 + ((int)cTeamIDs * 8);
        }       
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_REPLY_MSG in STF.x
    //  
    public class TeamListTeamsReplyMsg : XRLObject2
    {
        public TeamListTeamsReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_TEAMS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             cTeams;

        [WireInfo(SizeParam="cTeams")]
        public ReplyTeam[]      replyTeam;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListTeamsReplyMsg )
            iSize += 8;

            for (i=0; i<cTeams; i++)
            {
                iSize += replyTeam[i].Size();
            }

            return iSize;
        }
    };

    //
    //  Maps to P_TEAM_LIST_USER_TEAMS_MSG in STF.x
    //  
    public class TeamListUserTeamsMsg : TeamsXrlObject
    {
        public TeamListUserTeamsMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_USER_TEAMS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListUserTeamsMsg )
            return 32 + 12;
        }       
    };

    //
    //  Maps to P_TEAM_LIST_USER_TEAMS_REPLY_MSG in STF.x
    //  
    public class TeamListUserTeamsReplyMsg : XRLObject2
    {
        public TeamListUserTeamsReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_USER_TEAMS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             cTeams;

        [WireInfo(SizeParam="cTeams")]
        public ReplyUserTeam[] replyUserTeam;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListUserTeamsReplyMsg )
            iSize += 8;

            for (i=0; i<cTeams; i++)
            {
                iSize += replyUserTeam[i].Size();
            }
            
            return iSize;
        }
    };

    //
    //  Maps to P_TEAM_LIST_MEMBERS_MSG in STF.x
    //  
    public class TeamListMembersMsg : TeamsXrlObject
    {
        public TeamListMembersMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_MEMBERS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public uint             fShowRecruits;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListMembersMsg )
            return 32 + 24;
        }
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_REPLY_MSG in STF.x
    //  
    public class TeamListMembersReplyMsg : XRLObject2
    {
        public TeamListMembersReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_MEMBERS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwTeamID;
        public ushort           cMembers;

        [WireInfo(SizeParam="cMembers")]
        public ReplyTeamMember[]      replyTeamMember;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListMembersReplyMsg )
            iSize += 14;

            for (i=0; i<cMembers; i++)
            {
                iSize += replyTeamMember[i].Size();
            }

            return iSize;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\teamticket.cs ===
//
// TeamTicket.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
using System;
using System.IO;

using STF.common.service;


namespace STF.common.protocol 
{
    public class TeamTicket : WireData
    {
        public ulong userID;
        public short cTeams;
        public short cbSignature;
        
        [WireInfo(SizeParam="cTeams")] 
        public ulong [] rgqwTeamIDs;
        
        [WireInfo(SizeParam="cbSignature")] 
        public byte [] rgbSignature;

        [WireInfo(Serialize=false)]
        private bool verified = false;
        
        [WireInfo(Serialize=false)]
        public const int TEAM_TICKET_SIGNATURE_LENGTH = 8;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAMS_PER_TICKET = 8;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTicket()
        {
        }
        
        public TeamTicket(ulong userId, ulong teamId)
        {
            userID = userId;
            cTeams = 1;
            rgqwTeamIDs = new ulong[1];
            rgqwTeamIDs[0] = teamId;

            cbSignature = 0;
            rgbSignature = null;
        }
        
        public TeamTicket(BinaryReader reader)
        {
            base.ReadStream(reader);
            if (cTeams > MAXIMUM_TEAMS_PER_TICKET)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS, "TeamTicket contains too many teams: " + cTeams);
            }
            verified = false;
        }


        // 
        // Methods for creating and validating a ticket given SGInfo
        // 
        private byte[] TicketSignature(SGInfo sginfo)
        {
            MemoryStream m = new MemoryStream(100);
            BinaryWriter w = new BinaryWriter(m);

            w.Write(userID);
            w.Write((short)rgqwTeamIDs.Length);
            w.Write((short)TEAM_TICKET_SIGNATURE_LENGTH);
            foreach(ulong t in rgqwTeamIDs)
            {
                w.Write(t);
            }
            byte[] teamTicket = m.ToArray();

            byte[] fullSignature = sginfo.SignWithKey(teamTicket, 0, teamTicket.Length);
            byte[] signature = new byte[TEAM_TICKET_SIGNATURE_LENGTH];
            Array.Copy(fullSignature,signature,TEAM_TICKET_SIGNATURE_LENGTH);

            return signature;
        }

        public void SignTicket(SGInfo sginfo)
        {
            cbSignature = TEAM_TICKET_SIGNATURE_LENGTH;
            rgbSignature = TicketSignature(sginfo);
        }

        public void SignTicket()
        {
            SignTicket(SGInfo.Current);
        }
        
        public void VerifyTicket(SGInfo sginfo)
        {
            if (!verified && AuthToggle.On)
            {
                if (rgbSignature == null || !ByteArray.Equals(TicketSignature(sginfo), rgbSignature))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_1, "TeamTicket signature verification failed");
                }
                if (!sginfo.IsUserPresent(userID))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_2, "Team ticket is for user not present in auth data: " + userID.ToString("X"));
                }
                verified = true;
            }            
        }

        public void VerifyTicket()
        {
            VerifyTicket(SGInfo.Current);
        }
        
        //
        // Return size of this team ticket after serialization
        //
        public override int Size()
        {
            return 12 + (8 * cTeams) + cbSignature;
        }

        public bool Signed()
        {
            return (cbSignature != 0);
        }
        
        public void ClearSignature()
        {
            cbSignature = 0;
            rgbSignature = null;
        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            bool fResult = false;

            if (userId == userID)
            {
                foreach(ulong t in rgqwTeamIDs)
                {
                    if (t == teamId)
                    {
                        fResult = true;
                        break;
                    }
                }
            }
            
            return fResult;            
        }
    }
    
    public class TeamTickets : WireData
    {
        public ushort wType; // == TEAM_TICKETS_TYPE
        public ushort wLength; // number of bytes following this ushort
        public ushort cTickets; // maximum of MAXIMUM_TEAM_TICKETS
        
        [WireInfo(SizeParam="cTickets")] 
        public TeamTicket[] teamTickets;
        
        [WireInfo(Serialize=false)]
        public const ushort TEAM_TICKETS_TYPE = 0x0001;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAM_TICKETS = 1024;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTickets()
        {
        }
        
        public TeamTickets(BinaryReader reader)
        {
            ReadStream(reader);
        }

        public TeamTickets(TeamTicket[] paramTeamTickets)
        {
            teamTickets = paramTeamTickets;

            cTickets = (ushort)teamTickets.Length;
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_3, "Team Tickets contains too many tickets: " + cTickets);
            }
        }

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int actualLength = 2;

            try
            {
                wType = binaryReader.ReadUInt16();
            }
            catch (EndOfStreamException)
            {
                //We need to throw a peekcharendofstreamexception instead of a plain endofstream exception
                //This is to accurately tell the same thing as what peekchar would have told us
                //that is there were no more data in the stream
                throw new PeekCharEndOfStreamException();
            }
            
            if (wType != TEAM_TICKETS_TYPE)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_4, "Team Tickets type expected. Received: " + wType.ToString("X"));
            }
            wLength = binaryReader.ReadUInt16();          
            cTickets = binaryReader.ReadUInt16();
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_5, "Team Tickets contains too many tickets: " + cTickets);
            }
            teamTickets = new TeamTicket[cTickets];
            for (int i = 0; i < cTickets; ++i)
            {
                teamTickets[i] = new TeamTicket(binaryReader);
                actualLength += teamTickets[i].Size();
            }
            if (actualLength != wLength)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_6, "Team Tickets length inconsistent. Stated:" + wLength + " Actual:" + actualLength);
            }

            return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            wType = TEAM_TICKETS_TYPE;
            cTickets = (ushort)teamTickets.Length;
            wLength = 2; // length of cTickets
            for (int i = 0; i < cTickets; ++i)
            {
                wLength += (ushort)teamTickets[i].Size();
            }
            base.WriteStream(binaryWriter);
        }

        public void VerifyTickets(SGInfo sginfo)
        {
            foreach(TeamTicket t in teamTickets)
            {
                t.VerifyTicket(sginfo);
            }
        }
        
        public void VerifyTickets()
        {
            VerifyTickets(SGInfo.Current);
        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            foreach(TeamTicket t in teamTickets)
            {
                if (t.userID == userId)
                {
                    return t.VerifyMembership(userId, teamId);
                }
            }

            return false;
        }

        public void VerifyMembershipThrow(ulong userId, ulong teamId)
        {
            if (false == VerifyMembership(userId, teamId))
            {
                throw new XRLException(HResult.XONLINE_E_TEAMS_NOT_A_MEMBER, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_7, "User " + userId + " is not a member of team " + teamId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\testutils.cs ===
using System.Runtime.InteropServices;
using STF.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.TestUtilities)]


namespace STF.common.service 
{
    [ComVisible(false)]
    public class Utils
    {
        //
        // Format binary data in hex and ascii representations
        //
        public static void OutputHexBytes(byte[] data)
        {
            string  line;            

            if (null != data)
            {
                line = "";
                foreach (byte b in data)
                {                
                    System.Console.Write(b.ToString("x2") + " ");
                    if (b >= 0x21 && b <= 0x7e)
                    {
                        line += (char)b;
                    }
                    else
                    {
                        line += '.';
                    }

                    if (line.Length == 16)
                    {
                        System.Console.WriteLine(line);
                        line = "";
                    }
                }                       

                // Need to write the last ascii line
                line = line.PadLeft((16 - line.Length) * 3 + line.Length);
                System.Console.WriteLine(line);
            }
            else
            {
                System.Console.WriteLine("data is null");                
            }           
        }

        //
        // Print a string containing newlines to the console window
        //
        public static void WriteLines(string str)
        {
            string     delimiter = "\n";
            string []  lines = str.Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                System.Console.WriteLine(s);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\TitleConfig.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;

namespace STF.common.config
{
    public enum ConsoleTypeEnum
    {
        Xbox1 = 0,
        XboxCom = 1,
        Xenon = 2,
        Marketplace = 3,
        PC = 4,
        Mobile = 5,
        WebGames = 6
    }

    public class TitleConfig : ConfigEventLogger
    {
        public const uint          X_STRINGID_TITLE = 0x8000;

        public enum SupportedPlatforms
        {
            Xbox360 = 0, // Xbox1 doesn't have achievements
            PC,
            Mobile,
            WebGames,
            MaxPlatforms,
        };

        public uint                TitleId;
        public string              XlastVersion;
        public string              ProjectVersion;
        public LocalizedDictionary Names;
        public SortedList          Achievements;
        public SortedList          AvatarAssets;
        public SortedList          Contexts;
        public SortedList          GameModes;
        public SortedList          Leaderboards;
        public uint                MaxCred;
        public bool[]              Platforms;

        // Key: attribute id
        public SortedList          MatchConstants;

        // use an arraylist for MatchSchema to preserve order. This is important
        // for generating SQL code for legacy xbox 1 titles
        public ArrayList           MatchSchema;

        // Key: query id
        public SortedList          MatchQueries;

        private string             _defaultLocale;

        private static Hashtable   _titleConfigs = new Hashtable();
        private static DateTime    _dtLastChange = DateTime.Now;
        private static Hashtable   _titleLocks = new Hashtable();
        private static object      _allTitlesLock = new Object();

        static TitleConfig()
        {
            Config.GameConfigChange += new GameConfigChangeEventHandler(TitleConfig.OnGameConfigChange);
        }

        public static TitleConfig GetTitle(uint titleId)
        {
            return(GetTitle(titleId, true));
        }

        public static int LoadTitleConnectionTimeout
        {
            get
            {
                const int DefaultLoadTitleConnectionTimeoutSeconds = 60;  // long enough to handle large xlast files (like Lips... 33 MB!)

                int timeoutSeconds;

                try
                {
                    timeoutSeconds = Config.GetIntSetting(Setting.config_loadTitleConnectionTimeoutSeconds);
                }
                catch (Exception) // ignore any exception, use the default timeout instead
                {
                    // We don't want LoadTitle to fail if the default loadtitle timeout config setting
                    // can't be determined, so ignore any exception and use the default timeout instead.

                    // There is no XomTrace available in the STF.common.config namespace and we don't
                    // want to create Event spam for this case.  Also, this code will change for Brandenberg
                    // in several months' time, so there is no event fired for this failure.

                    timeoutSeconds = DefaultLoadTitleConnectionTimeoutSeconds;
                }

                if (timeoutSeconds < Config.NpdbConnectionTimeout)
                {
                    timeoutSeconds = Config.NpdbConnectionTimeout; // put a floor on the timeout
                }

                return timeoutSeconds;
            }
        }

        public static TitleConfig GetTitle(uint titleId, bool throwWhenNotFound)
        {
            TitleConfig cfg;

            cfg = (TitleConfig)_titleConfigs[titleId];

            if (cfg == null) // optimize the common case (don't take a per-title lock if already non-null)
            {
                lock (_allTitlesLock) // all threads block here...
                {
                    if (_titleLocks[titleId] == null) // ensure the titleId locks exists, and if not, create it
                    {
                        _titleLocks[titleId] = new object();
                    }
                }

                lock (_titleLocks[titleId]) // only threads representing titleIds that are already loading block here...
                {
                    cfg = (TitleConfig)_titleConfigs[titleId];

                    if (cfg == null)
                    {
                        cfg = LoadTitle(titleId);

                        if (cfg == null && throwWhenNotFound)
                        {
                            throw new ApplicationException("Configuration for title id " + titleId.ToString("x") + " not found!");
                        }
                        else
                        {
                            lock (typeof(TitleConfig))
                            {
                                _titleConfigs[titleId] = cfg;
                            }
                        }
                    }
                }
            }

            return cfg;
        }

        public static Hashtable AllTitles
        {
            get
            {
                return _titleConfigs;
            }
        }



        public static TitleConfig LoadTitle(uint titleId)
        {
            TitleConfig cfg = null;

            using (SqlConnection npdbConnection = new SqlConnection(Config.NpdbConnectionStringWithTimeout(LoadTitleConnectionTimeout)))
            {
                npdbConnection.Open();

                using (SqlCommand cmd = npdbConnection.CreateCommand())
                {
                    cmd.CommandText = "p_game_get_config";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            try
                            {
                                cfg = new TitleConfig(titleId, (string)reader["xml_config"]);
                            }
                            catch (Exception)
                            {
                                // eat any exception and return null.
                            }
                        }
                    }
                }
            }

            return cfg;
        }

        public static void LoadChangedTitles() {
            DateTime dtNow = DateTime.Now;

            using (SqlConnection conn = new SqlConnection(Config.NpdbConnectionStringWithTimeout(LoadTitleConnectionTimeout)))            
            {
                conn.Open();

                using (SqlCommand cmd = new SqlCommand("p_game_get_all_configs", conn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter param = new SqlParameter();

                    param.ParameterName = "@dt_changed";
                    param.Direction = ParameterDirection.Input;
                    param.DbType = DbType.Date;
                    param.Value = _dtLastChange;

                    cmd.Parameters.Add(param);

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        int titleIdOrd = reader.GetOrdinal("i_title_id");
                        int xmlConfOrd = reader.GetOrdinal("xml_config");

                        while ( reader.Read() )
                        {
                            uint   titleId = (uint)reader.GetInt32( titleIdOrd );
                            string xmlConf = reader.GetString( xmlConfOrd );

                            try
                            {
                                TitleConfig cfg = new TitleConfig(titleId, xmlConf);
                                lock (typeof(TitleConfig))
                                {
                                    _titleConfigs[titleId] = cfg;
                                }
                            }
                            catch (Exception e)
                            {
                                Config.LogNtEvent(Config.ComponentName,
                                                  "Invalid title config found for title id " + titleId.ToString("x") + ":\n" + e.ToString(),
                                                  ConfigEvent.Id.COMMON_CONFIG_BAD_XLAST_FILE);

                                //Continue loading title config data after exception
                            }
                        }

                    }
                }
            }

            _dtLastChange = dtNow;
        }

        public static void OnGameConfigChange(object sender, EventArgs e)
        {
            // $QFE (jojohn): erasing all config entries causes ASP.NET queueing on requests
            LoadChangedTitles();
        }



        public TitleConfig() {}
        public TitleConfig(uint titleId, string xlastXml)
        {
            ParseXml(titleId, xlastXml);
        }

        public void ParseXml(uint titleId, string xlastXml)
        {
            // i hate namespaces
            xlastXml = xlastXml.Replace("xmlns=\"http://www.xboxlive.com/xlast\"", String.Empty);

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xlastXml);
            XPathNavigator root = doc.CreateNavigator();

            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject");
            if (it.Count == 0)
            {
                throw new ApplicationException("Invalid game config xml found for title id " + titleId.ToString("x") + ":" +
                    "Could not find /XboxLiveSubmissionProject");
            }
            if (it.Count > 1)
            {
                // we can't handle this.. is it necessary?
                throw new ApplicationException("Invalid game config xml found for title id " + titleId.ToString("x") + ":" +
                    "Too many XboxLiveSubmissionProject nodes!");
            }
            it.MoveNext();

            // grab the xlast version
            XlastVersion = it.Current.GetAttribute("Version", String.Empty);

            it = root.Select("/XboxLiveSubmissionProject/GameConfigProject");
            if (it.Count == 0)
            {
                throw new ApplicationException("Invalid game config xml found for title id " + titleId.ToString("x") + ":" +
                    "Could not find /XboxLiveSubmissionProject/GameConfigProject");
            }
            if (it.Count > 1)
            {
                // we can't handle this.. is it necessary?
                throw new ApplicationException("Invalid game config xml found for title id " + titleId.ToString("x") + ":" +
                    "Too many GameConfigProject nodes!");
            }

            // titleid
            it.MoveNext();
            TitleId = ParseUInt32(it.Current.GetAttribute("titleId", String.Empty));
            ProjectVersion = it.Current.GetAttribute("projectVersion", String.Empty);

            // locale
            //
            it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/LocalizedStrings");
            if (it.Count != 1)
            {
                throw new ApplicationException("Invalid game config xml found for title id " + titleId.ToString("x") + ":" +
                    "Unexpected number of LocalilzedStrings nodes (" + it.Count + ")!");
            }


            it.MoveNext();
            _defaultLocale = it.Current.GetAttribute("defaultLocale", String.Empty);


            //
            // title names
            //
            it = root.Select("/XboxLiveSubmissionProject/GameConfigProject");
            it.MoveNext();

            Names = GetLocalizedStrings(root, (int)X_STRINGID_TITLE);

            ParseAchievements(root);
            ParseAvatarAssets(titleId, root);
            ParseContexts(root);
            ParseGameModes(root);
            ParseMatch(root);
            ParseLeaderboards(root);
            ParsePlatforms(root);

        }

        private void ParseAchievements(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/Achievements/Achievement");
            XPathNodeIterator it2;
            int i;

            Achievements = new SortedList(it.Count);
            MaxCred = 0;

            while (it.MoveNext())
            {
                TitleAchievement a = new TitleAchievement();

                a.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                a.Cred = XmlConvert.ToInt32(it.Current.GetAttribute("cred", String.Empty));
                a.ShowUnachieved = XmlConvert.ToBoolean(it.Current.GetAttribute("showUnachieved", String.Empty));
                a.Type = (TitleAchievementType)Enum.Parse(typeof(TitleAchievementType), it.Current.GetAttribute("achievementType", String.Empty), true);

                a.FriendlyName = it.Current.GetAttribute("titleStringId", String.Empty);
                a.Title = GetLocalizedStrings(root, XmlConvert.ToInt32(it.Current.GetAttribute("titleStringId", String.Empty)));

                if (String.IsNullOrEmpty(it.Current.GetAttribute("unachievedStringId", String.Empty)))
                    i = -1;
                else
                    i = XmlConvert.ToInt32(it.Current.GetAttribute("unachievedStringId", String.Empty));

                a.Unachieved = GetLocalizedStrings(root, i);

                a.Description = GetLocalizedStrings(root, XmlConvert.ToInt32(it.Current.GetAttribute("descriptionStringId", String.Empty)));

                if (!String.IsNullOrEmpty(it.Current.GetAttribute("imageId", String.Empty)))
                    a.ImageId = XmlConvert.ToUInt32(it.Current.GetAttribute("imageId", String.Empty));

                // next ids
                //
                it2 = it.Current.Select("Next");
                a.NextIds = new uint[it2.Count];
                i = 0;
                while (it2.MoveNext())
                {
                    a.NextIds[i++] = ParseUInt32(it2.Current.GetAttribute("id", String.Empty));
                }

                // replace ids
                //
                it2 = it.Current.Select("Replace");
                a.ReplaceIds = new uint[it2.Count];
                i = 0;
                while (it2.MoveNext())
                {
                    a.ReplaceIds[i++] = ParseUInt32(it2.Current.GetAttribute("id", String.Empty));
                }


                Achievements.Add(a.Id, a);
                MaxCred += (uint)a.Cred;
            }
        }

        private TitleAvatarAsset ParseAvatarAward(XPathNodeIterator it, XPathNavigator root,
            bool showUnachieved, LocalizedDictionary unachievedStrings, LocalizedDictionary descriptionStrings, string friendlyName, // shared attributes
            string guidAttr, string imageAttr, string displayStringAttr, string subCategoryAttr) // names of award-specific attributes
        {
            string guidValue = it.Current.GetAttribute(guidAttr, String.Empty);
            if (String.IsNullOrEmpty(guidValue) || guidValue == "0" || guidValue == "{00000000-0000-0000-0000-000000000000}")
            {
                return null;
            }

            TitleAvatarAsset a = new TitleAvatarAsset();

            a.ShowUnachieved = showUnachieved;
            a.Unachieved = unachievedStrings;
            a.Description = descriptionStrings;
            a.FriendlyName = friendlyName;

            // Create awards using award-specific fields
            a.Id = new AvatarAssetId(new Guid(guidValue));

            a.Title = GetLocalizedStrings(root, XmlConvert.ToInt32(it.Current.GetAttribute(displayStringAttr, String.Empty)));

            string imageId = it.Current.GetAttribute(imageAttr, String.Empty);
            if (!String.IsNullOrEmpty(imageId))
                a.ImageId = XmlConvert.ToUInt32(imageId);

            a.SubCategory = XmlConvert.ToUInt32(it.Current.GetAttribute(subCategoryAttr, String.Empty));

            return a;
        }

        private void ParseAvatarAssets(uint titleId, XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/AvatarItems/AvatarItem");
            int i;

            AvatarAssets = new SortedList(it.Count);

            while (it.MoveNext())
            {
                // Each element in the XLAST can contain 1 or 2 awards. If the item is gender-neutral, it will
                // only have 1 award. Gender-specific items can have 2 awards. Generate 1 entry in the array
                // for each award.
                //
                // Sample:
                //
                //<!-- Gender award -->
                //<AvatarAwards clsid="{5A72CE58-51F0-4AA4-980F-782210E96671}">
                //   <AvatarAward clsid="{9FE46E41-6718-4CEF-AA72-422186EF67C3}" showUnachieved="true" unachievedStringId="18" friendlyName="award" descriptionStringId="19"
                //      guid1="{00000002-0002-4101-C111-01235841089A}" imageId1="0" displayStringId1="20" subCategory1="0" binLocation1="..\avatar1.bin" imageMedLocation1="..\avatar1_128_128.png"
                //      guid2="{00000002-0002-4102-C111-01235841089A}" imageId2="0" displayStringId2="21" subCategory2="0" binLocation2="..\avatar2.bin" imageMedLocation2="..\avatar2_128_128.png"/>
                //</AvatarAwards>
                //
                //<!-- Neutral award -->
                //<AvatarAwards clsid="{5A72CE58-51F0-4AA4-980F-782210E96671}">
                //   <AvatarAward clsid="{9FE46E41-6718-4CEF-AA72-422186EF67C3}" showUnachieved="true" unachievedStringId="18" friendlyName="award" descriptionStringId="19"
                //      guid1="{00000002-0002-4103-C111-01235841089A}" imageId1="0" displayStringId1="20" subCategory1="0" binLocation1="..\avatar2.bin" imageMedLocation1="..\avatar3_128_128.png"
                //      guid2="{00000000-0000-0000-0000-000000000000}" imageId2="0" displayStringId2="21" subCategory2="0" binLocation2="0" imageMedLocation2="0"/>
                //</AvatarAwards>

                // Retrieve the shared fields
                bool showUnachieved = XmlConvert.ToBoolean(it.Current.GetAttribute("showUnachieved", String.Empty));

                string unachievedStringId = it.Current.GetAttribute("unachievedStringId", String.Empty);
                if (String.IsNullOrEmpty(unachievedStringId))
                {
                    i = -1;
                }
                else
                {
                    i = XmlConvert.ToInt32(unachievedStringId);
                }
                LocalizedDictionary unachievedStrings = GetLocalizedStrings(root, i);
                LocalizedDictionary descriptionStrings = GetLocalizedStrings(root, XmlConvert.ToInt32(it.Current.GetAttribute("descriptionStringId", String.Empty)));

                string friendlyName = it.Current.GetAttribute("friendlyName", String.Empty);

                TitleAvatarAsset a;
                a = ParseAvatarAward(it, root, showUnachieved, unachievedStrings, descriptionStrings, friendlyName, "guid1", "imageId1", "displayStringId1", "subCategory1");
                if (a != null)
                {
                    AvatarAssets.Add(new TitleAvatarAssetKey(titleId, a.Id.AwardOrdinal, a.Id.BodyTypeMask), a);
                }

                a = ParseAvatarAward(it, root, showUnachieved, unachievedStrings, descriptionStrings, friendlyName, "guid2", "imageId2", "displayStringId2", "subCategory2");
                if (a != null)
                {
                    AvatarAssets.Add(new TitleAvatarAssetKey(titleId, a.Id.AwardOrdinal, a.Id.BodyTypeMask), a);
                }
            }
        }

        private void ParseContexts(XPathNavigator root)
        {

            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/Contexts/Context");
            XPathNodeIterator it2;

            Contexts = new SortedList(it.Count);

            while (it.MoveNext())
            {
                TitleContext c = new TitleContext();

                c.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));

                it2 = it.Current.Select("ContextValue");
                c.Values = new SortedList(it2.Count);

                while (it2.MoveNext())
                {
                    TitleContextValue cv = new TitleContextValue();
                    cv.Id = ParseUInt32(it2.Current.GetAttribute("value", String.Empty));
                    cv.Name = GetLocalizedStrings(root, XmlConvert.ToInt32(it2.Current.GetAttribute("stringId", String.Empty)));

                    c.Values.Add(cv.Id, cv);
                }

                Contexts.Add(c.Id, c);
            }

        }

        private void ParseGameModes(XPathNavigator root)
        {

            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/GameModes/GameMode");

            GameModes = new SortedList(it.Count);

            while (it.MoveNext())
            {
                GameMode m = new GameMode();

                m.Id = ParseUInt32(it.Current.GetAttribute("value", String.Empty));
                m.DrawProbability = ParseUInt32(it.Current.GetAttribute("drawProbability", String.Empty));
                m.Name = GetLocalizedStrings(root, XmlConvert.ToInt32(it.Current.GetAttribute("stringId", String.Empty)));

                GameModes.Add(m.Id, m);
            }
        }


        private void ParseMatch(XPathNavigator root)
        {
            ParseMatchConstants(root);
            ParseMatchSchema(root);
            ParseMatchQueries(root);
        }

        private void ParseMatchConstants(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject"+
                "/GameConfigProject/Matchmaking/Constants/Constant");

            MatchConstants = new SortedList(it.Count);

            while (it.MoveNext())
            {
                MatchConstant c = new MatchConstant();

                c.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                c.Name = it.Current.GetAttribute("name", String.Empty);
                c.Value = it.Current.GetAttribute("value", String.Empty);

                MatchConstants.Add(c.Id, c);
            }
        }

        private void ParseMatchSchema(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject"+
                "/GameConfigProject/Matchmaking/Schema/Attribute");

            MatchSchema = new ArrayList(it.Count);

            while (it.MoveNext())
            {
                MatchSchemaAttribute a = new MatchSchemaAttribute();

                a.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));

                MatchSchema.Add(a);
            }
        }

        private void ParseMatchQueries(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject"+
                "/GameConfigProject/Matchmaking/Queries/Query");

            MatchQueries = new SortedList(it.Count);

            while (it.MoveNext())
            {
                MatchQuery q = ParseMatchQuery(it.Current);
                MatchQueries.Add(q.Id, q);
            }
        }

        private void ParseLeaderboards(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/StatsViews/StatsView");

            Leaderboards = new SortedList(it.Count);

            while (it.MoveNext())
            {
                Leaderboard lb = new Leaderboard();

                lb.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                lb.MaxAttachments = ParseUInt32(it.Current.GetAttribute("maxAttachments", String.Empty));

                // todo: add all the other stuff for leaderboards..

                Leaderboards.Add(lb.Id, lb);
            }
        }

        private void ParsePlatforms(XPathNavigator root)
        {
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/ProductInformation/Platform");

            Platforms = new bool[(int)SupportedPlatforms.MaxPlatforms];
            for (int i = 0; i < (int)SupportedPlatforms.MaxPlatforms; i++)
            {
                Platforms[i] = false;
            }

            if (it.Count == 0)
            {
                // There's no Platform Defined, meaning it is a 360
                Platforms[(int)SupportedPlatforms.Xbox360] = true;
            }
            else
            {
                while (it.MoveNext())
                {
                    string idAttr = it.Current.GetAttribute("id", String.Empty);
                    if(idAttr.Length == 0)
                    {
                        throw new ApplicationException("Missing Platform 'id' attribute.");
                    }

                    int platId;
                    if (int.TryParse(idAttr, out platId) == false)
                    {
                        throw new ApplicationException("Non-integer Platform 'id' value ('" + idAttr + "')");
                    }

                    switch ((ConsoleTypeEnum)platId)
                    {
                        case ConsoleTypeEnum.Xenon:
                            Platforms[(int)SupportedPlatforms.Xbox360] = true;
                            break;
                        case ConsoleTypeEnum.PC:
                            Platforms[(int)SupportedPlatforms.PC] = true;
                            break;
            case ConsoleTypeEnum.Mobile:
                            Platforms[(int)SupportedPlatforms.Mobile] = true;
                            break;
            case ConsoleTypeEnum.WebGames:
                Platforms[(int)SupportedPlatforms.WebGames] = true;
                break;
                        default:
                            throw new ApplicationException("Unrecognized Platform 'id' value ('" + platId + "')");
                    }
                }
            }
        }


        private MatchQuery ParseMatchQuery(XPathNavigator query)
        {
            MatchQuery q = new MatchQuery();
            q.Id = ParseUInt32(query.GetAttribute("id", String.Empty));
            q.FriendlyName = query.GetAttribute("friendlyName", String.Empty);
            q.MaxResults = ParseUInt32(query.GetAttribute("maxResults", String.Empty));
            q.Type = query.GetAttribute("type", String.Empty);
            q.GroupBy = ParseUInt32(query.GetAttribute("groupBy", String.Empty));
            q.Parameters = ParseMatchQueryParams(query);
            q.Filters = ParseMatchQueryFilters(query);
            q.SortOps = ParseMatchQuerySortOps(query);
            q.Returns = ParseMatchQueryReturns(query);
            return q;
        }

        private ArrayList ParseMatchQueryParams(XPathNavigator query)
        {
            XPathNodeIterator it = query.Select("Parameters/Parameter");

            ArrayList paramList = new ArrayList(it.Count);

            while (it.MoveNext())
            {
                MatchQueryParam p = new MatchQueryParam();
                p.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                paramList.Add(p);
            }

            return paramList;
        }

        private ArrayList ParseMatchQueryFilters(XPathNavigator query)
        {
            XPathNodeIterator it = query.Select("Filters/Filter");

            ArrayList filters = new ArrayList(it.Count);

            while (it.MoveNext())
            {
                MatchQueryFilter f = new MatchQueryFilter();
                f.Left = ParseUInt32(it.Current.GetAttribute("left", String.Empty));
                f.LeftType = it.Current.GetAttribute("leftType", String.Empty);
                f.Op = it.Current.GetAttribute("op", String.Empty);
                f.Right = ParseUInt32(it.Current.GetAttribute("right", String.Empty));
                f.RightType = it.Current.GetAttribute("rightType", String.Empty);
                filters.Add(f);
            }

            return filters;
        }

        private SortedList ParseMatchQuerySortOps(XPathNavigator query)
        {
            XPathNodeIterator it = query.Select("SortOperations/SortOperation");

            SortedList sortOps = new SortedList(it.Count);

            while (it.MoveNext())
            {
                MatchQuerySortOp s = new MatchQuerySortOp();
                s.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                s.Type = it.Current.GetAttribute("type", String.Empty);
                s.Distanceid = ParseUInt32(it.Current.GetAttribute("distanceid", String.Empty));
                s.Ordinal = ParseUInt32(it.Current.GetAttribute("ordinal", String.Empty));
                sortOps.Add(s.Ordinal, s);
            }

            return sortOps;
        }

        private SortedList ParseMatchQueryReturns(XPathNavigator query)
        {
            XPathNodeIterator it = query.Select("Returns/Return");

            SortedList returns = new SortedList(it.Count);

            while (it.MoveNext())
            {
                MatchQueryReturn r = new MatchQueryReturn();
                r.Id = ParseUInt32(it.Current.GetAttribute("id", String.Empty));
                r.Type = it.Current.GetAttribute("type", String.Empty);
                r.Ordinal = ParseUInt32(it.Current.GetAttribute("ordinal", String.Empty));
                returns.Add(r.Ordinal, r);
            }

            return returns;
        }


        private LocalizedDictionary GetLocalizedStrings(XPathNavigator root, int id)
        {
            LocalizedDictionary dict = new LocalizedDictionary(_defaultLocale);
            if (id == -1)
            {
                dict.Add(_defaultLocale, String.Empty);
                return dict;
            }

            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject/LocalizedStrings/LocalizedString[@id=" + id + "]/Translation");

            if (it.Count == 0)
                throw new ApplicationException("Couldn't find localized strings with id " + id);

            while (it.MoveNext())
            {
                dict.Add(it.Current.GetAttribute("locale", String.Empty), it.Current.Value);
            }

            return dict;
        }


        private uint ParseUInt32(string str)
        {
            int fromBase = 10;

            if (str.StartsWith("0x"))
            {
                fromBase = 16;
                str = str.Substring(2);
            }

            return Convert.ToUInt32(str, fromBase);
        }
    }

    public enum TitleAchievementType
    {
        Completion = 1,
        Leveling,
        Unlock,
        Event,
        Tournament,
        Checkpoint,
        Other
    }

    public class TitleAchievement
    {
        public uint Id;
        public string FriendlyName;
        public string DefaultLocale;

        public TitleAchievementType Type;
        public int Cred;
        public bool ShowUnachieved;

        public uint[] NextIds;
        public uint[] ReplaceIds;

        public uint ImageId = 0xffffffff;
        public LocalizedDictionary Title;
        public LocalizedDictionary Unachieved;
        public LocalizedDictionary Description;
    }

    // Key for the SortedList TitleConfig.AvatarAssets, containing TitleAvatarAsset objects
    public class TitleAvatarAssetKey : IComparable
    {
        public TitleAvatarAssetKey(uint TitleId, uint Ordinal, byte BodyTypeMask)
        {
            this.TitleId = TitleId;
            this.Ordinal = Ordinal;
            this.BodyTypeMask = BodyTypeMask;
        }

        public uint TitleId;
        public uint Ordinal;
        public byte BodyTypeMask;

        public override int GetHashCode()
        {
            // Ordinal will generally be in the range 1..5, though if we use a fake title
            // to contain free downloads for the 'asset refresh' functionality, it may potentially
            // hold hundreds of assets. BodyTypeMask will be 1, 2, or 3.
            // Given the above, use 1009 as an arbitrary prime to generate a hash.
            return (int) (Ordinal + BodyTypeMask*1009 + TitleId);
        }

        public override bool Equals(object obj)
        {
            TitleAvatarAssetKey other = (TitleAvatarAssetKey)obj;

            return (TitleId == other.TitleId) && (Ordinal == other.Ordinal) && (BodyTypeMask == other.BodyTypeMask);
        }

        // Provide an order for avatar assets. This defines the order in which unawarded
        // assets are returned to a client.
        public int CompareTo(object obj)
        {
            TitleAvatarAssetKey other = (TitleAvatarAssetKey)obj;

            if (TitleId != other.TitleId)
                return TitleId.CompareTo(other.TitleId);

            if (Ordinal != other.Ordinal)
                return Ordinal.CompareTo(other.Ordinal);

            return BodyTypeMask.CompareTo(other.BodyTypeMask);
        }
    }

    public class TitleAvatarAsset
    {
        public AvatarAssetId Id;
        public string FriendlyName;
        public string DefaultLocale;

        public bool ShowUnachieved;

        public uint SubCategory;

        public uint ImageId = 0xffffffff;
        public LocalizedDictionary Title;
        public LocalizedDictionary Unachieved;
        public LocalizedDictionary Description;
    }

    public class TitleContext
    {
        public uint Id;
        public SortedList Values;
    }

    public class TitleContextValue
    {
        public uint Id;
        public LocalizedDictionary Name;
    }

    public class Leaderboard
    {
        public uint Id;
        public uint MaxAttachments;
    }

    public class GameMode
    {
        public uint Id;
        public uint DrawProbability;
        public LocalizedDictionary Name;
    }


    public class MatchConstant
    {
        public string Name;
        public uint Id;
        public string Value;
    }

    public class MatchSchemaAttribute
    {
        public uint Id;
    }

    public class MatchQuery
    {
        public uint Id;
        public string FriendlyName;
        public uint MaxResults;
        public string Type;
        // don't bother with qosProbe attribute
        public uint GroupBy;

        // order is significant in parameters for xbox 1 titles, so
        // use array list
        public ArrayList Parameters;

        // filters don't have an order, but also don't have a natural key
        // so use an array list
        public ArrayList Filters;

        // sort operations have an explicit ordering by the ordinal attribute
        // so use a sorted list
        public SortedList SortOps;

        // returns also have an explicity ordering by ordinal
        public SortedList Returns;
    }

    public class MatchQueryParam
    {
        public uint Id;
    }

    public class MatchQueryFilter
    {
        public uint Left;
        public string LeftType;
        public string Op;
        public uint Right;
        public string RightType;
    }

    public class MatchQuerySortOp
    {
        public uint Id;
        public string Type;
        public uint Distanceid;
        public uint Ordinal;
    }

    public class MatchQueryReturn
    {
        public uint Id;
        public string Type;
        public uint Ordinal;
    }

    public class LocalizedDictionary : HybridDictionary
    {
        public LocalizedDictionary(string defaultLocale)
        {
            _defaultLocale = defaultLocale.ToLower();
        }

        [Obsolete]
        public string this[int key]
        {
            get {return null;}
            set {}
        }

        public string this[string key]
        {
            set { base[key.ToLower()] = value; }
            get { return (string)(this.Contains(key.ToLower()) ? base[key.ToLower()] : base[_defaultLocale]); }
        }
        public new string this[object key]
        {
            set { base[(string)key] = value; }
            get { return (string)(this.Contains(((string)key).ToLower()) ? base[((string)key).ToLower()] : base[_defaultLocale]); }
        }

        public string this[string[] keys]
        {
            get {
                foreach (string key in keys)
                {
                    if (this.Contains(key.ToLower()))
                        return (string)base[key.ToLower()];
                }

                return (string)base[_defaultLocale];
            }
        }

        public void Add(string name, string value)
        {
            base.Add(name.ToLower(), value);
        }

        public bool ContainsKey(string key)
        {
            return base.Contains(key.ToLower());
        }


        private string _defaultLocale;
    }

    public class LocaleMapper
    {
        public static string[] LocaleIdToString(ushort locale)
        {
            string loc = Enum.GetName(typeof(Locales), locale);

            if (null == loc)
                loc = "en-us";
            else
                loc = loc.Replace("_", "-");

            return(new string[] { loc });
        }
    }


    public enum Locales
    {
        // Using Country-Specific Locales, as defined at
        // http://msdn2.microsoft.com/en-us/library/system.globalization.cultureinfo(VS.80).aspx
        // and http://msdn2.microsoft.com/en-us/library/ms776260.aspx
        // and http://www.microsoft.com/globaldev/reference/lcid-all.mspx
        zh_CHS = 0004, // Chinese (Simplified)
        zh_TW = 1028, // Chinese (Taiwan)
        da_DK = 1030, // Danish (Denmark)
        de_DE = 1031, // German (Germany)
        el_GR = 1032, // Greek (Greece)
        en_US = 1033, // English (United States)
        fi_FI = 1035, // Finnish (Finland)
        fr_FR = 1036, // French (France)
        hu_HU = 1038, // Hungarian (Hungary)
        it_IT = 1040, // Italian (Italy)
        ja_JP = 1041, // Japanese (Japan)
        ko_KR = 1042, // Korean (Korea)
        nl_NL = 1043, // Dutch (Netherlands)
        nb_NO = 1044, // Norwegian (Bokml) (Norway)
        pl_PL = 1045, // Polish (Poland)
        pt_BR = 1046, // Portuguese (Brazil)
        ru_RU = 1049, // Russian (Russian Federation)
        sv_SE = 1053, // Swedish (Sweden)
        zh_CN = 2052, // Chinese (China)
        de_CH = 2055, // German (Switzerland)
        en_GB = 2057, // English (United Kingdom)
        es_MX = 2058, // Spanish (Mexico)
        fr_BE = 2060, // French (Belgium)
        nl_BE = 2067, // Dutch (Belgium)
        pt_PT = 2070, // Portuguese (Portugal)
        zh_HK = 3076, // Chinese (Hong Kong S.A.R.)
        de_AT = 3079, // German (Austria)
        en_AU = 3081, // English (Australia)
        es_ES = 3082, // Spanish (Spain)
        fr_CA = 3084, // French (Canada)
        zh_SG = 4100, // Chinese (Singapore)
        en_CA = 4105, // English (Canada)
        fr_CH = 4108, // French (Switzerland)
        en_NZ = 5129, // English (New Zealand)
        en_IE = 6153, // English (Ireland)
        en_ZA = 7177, // English (South Africa)
        es_CO = 9226, // Spanish (Colombia)
        es_CL = 13322, // Spanish (Chile)
        en_AE = 14337, // English (United Arab Emirates)
        en_IN = 16393, // English (India)
        zh_CHT = 31748, // Chinese (Traditional)

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\SGInfo.cs ===
//
// SGInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a class that exposes ticket/auth client data from the security gateway.
//
//  To use it, simply instantiate SGInfo in front-door code, and use the gettable properties
//  on this object.  Note that due to current limitations in ASP.NET, this class will NOT
//  be able to get good auth data in environments where the SG is doing port translation.
//
// Xbox Online Common Managed Code
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.ServiceModel;
using System.Collections.Generic;

using STF.common.config;
using STF.common.mgmt;
using STF.common.utilities;
using STF.common.utilities2;

[assembly: XomAreaDefinition(XomAreaName.sginfotrace)]

namespace STF.common.service
{
    [ComVisible(false)]
    public class CallSource
    {
        private const string CALL_SOURCE_INFO = "CallSourceInfo";

        public static bool IsVirtualInterfacePort( string viface, ushort port )
        {
            bool isVirtualInterface = false;
            IVirtualInterfaceInfo viinfo;

            viinfo = Config.GetVirtualInterface(viface);
            if (null != viinfo)
            {
                if (viinfo.Port == port)
                {
                    isVirtualInterface = true;
                }
            }

            return isVirtualInterface;
        }

        public static string Check(params string[] virtualInterfaces)
        {
            return Check(HttpContextAdapter.Current, virtualInterfaces);
        }

        public static string Check(HttpContext context, params string[] virtualInterfaces)
        {
            return Check(new HttpContextAdapter(context), virtualInterfaces);
        }

        public static string Check(HttpContextAdapter context, params string[] virtualInterfaces)
        {
            // Check the port the request was sent to
            ushort portUsed = (ushort)context.Request.LocalEP.Port;

            foreach (string virtualInterface in virtualInterfaces)
            {
                if (! IsVirtualInterfacePort(virtualInterface, portUsed)) continue;
                context.Items[CALL_SOURCE_INFO] = virtualInterface;
                return virtualInterface;
            }

            throw new XRLException(
                HResult.XONLINE_E_CALL_SOURCE_INVALID, XEvent.Id.SGINFO_CALL_SOURCE_INVALID,
                string.Format("'{0}' called through invalid port '{1}'", context.Request.Url, portUsed)
            );
        }

        public static ushort GetPort(HttpContext ctx)
        {
            // For some reason, HttpContext.Request.Url is rather slow.
            // To help us out, xrlscan has dropped the request port into an
            // HTTP header, which seems to be quicker than getting the port
            // out of the URL. If the header is there, use it.
            string serverPort = ctx.Request.Headers[XHttpHdr.SERVERPORT];
            if (serverPort != null)
            {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                return Convert.ToUInt16(serverPort);
            }
            else
            {
                return (ushort)(ctx.Request.Url.Port);
            }
        }

        // set the call source directly.   this is used to fake
        // out the SG and is generally only used by INH servers
        public static void Set(HttpContext context, string virtualInterface)
        {
            context.Items[CALL_SOURCE_INFO] = virtualInterface;
        }

        public static void Set(HttpContextAdapter context, string virtualInterface)
        {
            context.Items[CALL_SOURCE_INFO] = virtualInterface;
        }

        public static string Get(HttpContext context)
        {
            return (string)context.Items[CALL_SOURCE_INFO];
        }

        public static string Get(HttpContextAdapter context)
        {
            return (string) context.Items[CALL_SOURCE_INFO];
        }
    }

    [ComVisible(false)]
    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK           = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK         = 0x0000FF00;
        private const uint XONLINE_USER_TIER_MASK            = 0x00F00000;
        private const uint XONLINE_USER_PARENTAL_CONTROLLED  = 0x01000000;
        private const uint XONLINE_USER_LANGUAGE_MASK        = 0x3E000000;

        public ulong    qwUserID;
        public uint     dwUserFlags;
        public float    userTrust;

        public static void SetUserFlagCountry(ref uint flags, uint country)
        {
            flags &= ~XONLINE_USER_COUNTRY_MASK;
            flags |= (country<<8) & XONLINE_USER_COUNTRY_MASK;
        }

        public static void SetUserFlagLanguage(ref uint flags, uint language)
        {
            flags &= ~XONLINE_USER_LANGUAGE_MASK;
            flags |= (language<<25) & XONLINE_USER_LANGUAGE_MASK;
        }

        public static void SetUserFlagTier(ref uint flags, uint tier)
        {
            flags &= ~XONLINE_USER_TIER_MASK;
            flags |= (tier<<20) & XONLINE_USER_TIER_MASK;
        }

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }

        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust) obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public byte UserTier()
        {
            return (byte)((dwUserFlags & XONLINE_USER_TIER_MASK) >> 20);
        }

        public byte UserLanguage()
        {
            return (byte)((dwUserFlags & XONLINE_USER_LANGUAGE_MASK) >> 25);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }
    }

    [ComVisible(false)]
    public class BundledAuthData
    {
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION  = 1;
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2 = 2;

        // don't use this constructor, please provide a flow token.
        // @@@ TODO deprecate this, and v1, eventually
        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            wBundledAuthDataVersion = HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION;
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers, Floken paramFlowToken)
        {
            wBundledAuthDataVersion = HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2;
            titleID = paramTitleID;
            users = paramUsers;
            flowToken = paramFlowToken;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));

            wBundledAuthDataVersion = reader.ReadUInt16();
            if(wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                users = new XUIDAndTrust[reader.ReadUInt16()];
                titleID = reader.ReadUInt32();
                for (int i=0; i<users.Length; ++i)
                {
                    users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
                }
                flowToken = Floken.None;
            }
            else if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2)
            {
                users = new XUIDAndTrust[reader.ReadUInt16()];
                titleID = reader.ReadUInt32();
                for (int i=0; i<users.Length; ++i)
                {
                    users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
                }
                flowToken = new Floken(reader);
            }
            else
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_BUNDLED_AUTHDATA, "BundledAuthData: Auth data version ("
                    + wBundledAuthDataVersion + ") is incorrect!");
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                writer.Write(wBundledAuthDataVersion);
                writer.Write((ushort)users.Length);
                writer.Write(titleID);
                for (int i=0; i<users.Length; ++i)
                {
                    writer.Write(users[i].qwUserID);
                    writer.Write(users[i].dwUserFlags);
                    writer.Write(users[i].userTrust);
                }
            }
            else if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2)
            {
                writer.Write(wBundledAuthDataVersion);
                writer.Write((ushort)users.Length);
                writer.Write(titleID);
                for (int i=0; i<users.Length; ++i)
                {
                    writer.Write(users[i].qwUserID);
                    writer.Write(users[i].dwUserFlags);
                    writer.Write(users[i].userTrust);
                }
                flowToken.Write(writer);
            }
            else
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_BUNDLED_AUTHDATA, 
                                               "BundledAuthData: Auth data version (" + wBundledAuthDataVersion + ") is incorrect!");
            }

            return Convert.ToBase64String(memStream.ToArray());
        }
 
        public readonly uint    titleID;
        public XUIDAndTrust[]   users;
        public readonly Floken  flowToken;

        private ushort          wBundledAuthDataVersion;

        public void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            if( titleId != titleID )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR, "BundleAuthData.Verify: Title ID *" + titleId.ToString("X") + "* (Bundle says " + titleID.ToString("X") + ") cannot be verified.");
            }
        }


    }

    [ComVisible(false)]
    public class HTTPAuthData : SGInfo
    {
        public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData( ) : this( 0, 0, 0, 0, 0, 0, 0, 0 )
        {

        }

        //use this ONLY if you are using XRL common code and won't have SGInfo available (like for tools)
        public HTTPAuthData( Floken flowToken ) : this( flowToken, 0, 0, 0, 0, 0, 0, 0, 0 )
        {

        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, 0, userID, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(flowToken, port, ip, requestId, 0, userID, titleID, serviceId1, serviceId2)
        {
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, xboxID, userID, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            // Common code initialization
            Initialize( xboxID, titleID, flowToken);

            // Set the specified user
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);

            // Make sure that the rest of the user array is empty
            for( int i = 1; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // Count the number of users present in the ticket
            if (userID != 0)
            {
                dwNumUsers = 1;
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i]       = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, xboxID, users, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            // Common Code Initialization
            Initialize( xboxID, titleID, flowToken);

            // Fill in the user array
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2, uint[,] userPrivileges)
            : this(Floken.None, port, ip, requestId, xboxID, users, titleID, serviceId1, serviceId2, userPrivileges)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2, uint[,] userPrivileges)
            : base(port, ip, requestId)
        {
            // Common Code Initialization
            Initialize( xboxID, titleID, flowToken );

            // Fill in the user array
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }

                // Did the caller specify privileges for this user?
                if (i >= userPrivileges.GetLength(0))
                {
                    // No, zero out the privileges then
                    for ( int j = 0; j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                    {
                        dwUserPrivileges[i,j] = 0;
                    }
                }
                else
                {
                    // Copy in the specified privileges
                    for ( int j = 0; j < userPrivileges.GetLength(1); j++)
                    {
                        dwUserPrivileges[i,j] = userPrivileges[i,j];
                    }
                    for ( int j = userPrivileges.GetLength(1); j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                    {
                        dwUserPrivileges[i,j] = 0;
                    }

                }

            }

            // Initialize the common privileges
            if (dwNumUsers > 0)
            {
                for (int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
                {
                    uint mask = 0xFFFFFFFF;

                    for (int j = 0; i < XOn.XONLINE_MAX_LOGON_USERS; j++)
                    {
                        if (xUsers[j].qwUserID == 0)
                        {
                            continue;
                        }
                        mask &= dwUserPrivileges[j,i];
                    }
                    dwPrivileges[i] = mask;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // Worker function
        private void Initialize(ulong xboxID, uint titleID, Floken flowtok)
        {
            // @@@ kgoodier This is highly redundant, since we called the base constructor 
            // already. It in turn calls CreateSGInfoData(), which does all of this.  
            // Should clean it up after debugging to verify this hypothesis is true.

            qwXboxID              = xboxID;
            dwTitleID             = titleID;
            wAuthDataSize         = 0;
            wMajorVersion         = 0;
            wMinorVersion         = 0;
            wBuildNumber          = 0;
            wQFENumber            = 0;
            dwTitleVersion        = 0;
            dwTitleRegion         = 0;
            dwConsoleRegion       = 0;
            dwMediaID             = 0;
            wLanguageID           = 0;
            dwAuthDataFlags       = 0;
            wNumPrivileges        = 0;
            wNumDwordServices     = 0;
            fltConsoleTrustRating = 0.0F;
            dwNumUsers            = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];
            flowToken             = flowtok;

            // Initialize empty global privileges
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;

                // Initialize empty user privileges
                for ( int j = 0; j < XOn.XONLINE_MAX_LOGON_USERS; j++)
                {
                    dwUserPrivileges[j,i] = 0;
                }
            }
        }

        // This only sets the privilege when it is within XONLINE_MAX_PRIVILEGE_ID - enforced by casting to byte
        public void SetPrivilege(byte privilegeId)
        {
            int nIndex    = privilegeId / 32;
            int nbitIndex = privilegeId % 32;
            uint mask    = ((uint)1) << nbitIndex;

            // Only incremement the privilege count if he hadn't seen it before
            if ((dwPrivileges[nIndex] & mask) == 0)
            {
                wNumPrivileges++;
            }

            // Set the privilege across all the users.
            dwPrivileges[nIndex] |= mask;

            // Only set per-user privileges if the user is actually present
            // No privileges to be granted to empty slots
            for (int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++)
            {
                if (xUsers[u].qwUserID != 0)
                {
                    dwUserPrivileges[u,nIndex] |= mask;
                }
            }
        }

        // This only sets the for a specific user slot privilege when it is
        // within XONLINE_MAX_PRIVILEGE_ID - enforced by casting to byte
        public void SetUserPrivilege(uint userSlot, byte privilegeId)
        {
            int nIndex    = privilegeId / 32;
            int nbitIndex = privilegeId % 32;
            uint mask    = ((uint)1) << nbitIndex;

            if (userSlot >= XOn.XONLINE_MAX_LOGON_USERS)
            {
                return;
            }

            // Set this privilege for the user
            dwUserPrivileges[userSlot,nIndex] |= mask;

            // If the privilege is present between all the users
            if ((dwPrivileges[nIndex] & mask) != 0)
            {
                // The top level privilege mask has this bit set so
                // de won't have to do any more work
                return;
            }

            // Build the mask of all the bit across all the present users
            for (int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++)
            {
                if (xUsers[u].qwUserID != 0)
                {
                    mask &= dwUserPrivileges[u,nIndex];
                }
            }

            // Finally determine if we should set that bit in the top level
            // privilege bit mask
            if (mask != 0)
            {
                dwPrivileges[nIndex] |= mask;
                wNumPrivileges++;
            }
        }

        // This will set a service id or privlege depending on where it should
        // live in the ticket
        public void SetService( uint ServiceId )
        {
            // Simple No-Op Case
            if (ServiceId == 0)
            {
                return;
            }

            // If the service is within the PRIVILEGE_ID space, set the
            // service via that mechanism
            if (ServiceId < XOn.XONLINE_MAX_PRIVILEGE_ID)
            {
                SetPrivilege( (byte) ServiceId );
                return;
            }

            // Do we have any space left in the extended services location?
            if (wNumDwordServices >= XOn.XONLINE_MAX_DWORD_SERVICEIDS)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_NO_MORE_SERVICES_ERROR, "Too many requested services" );
            }

            // Set the service and keep track of the total
            dwServiceIds[ wNumDwordServices ] = ServiceId;
            wNumDwordServices++;
        }

        public string GetBase64EncodedString()
        {
            return ConstructBase64String();
        }
    }

    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "SGInfo", "XBox Online CLR Auth check component", true )]
    public class SGInfoCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Auth requests per second",
            "Auth requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AuthRequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Auth requests total",
            "Auth requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AuthRequestsTotal;

        [XomPerformanceCounterAttr(
            "Retries per second",
            "Retries per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RetriesPerSecond;

        [XomPerformanceCounterAttr(
            "Retries total",
            "Retries total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RetriesTotal;

        [XomPerformanceCounterAttr(
            "Failed requests per second",
            "Failed requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Failed requests total",
            "Failed requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedRequestsTotal;

        [XomPerformanceCounterAttr(
            "Avg waiting time",
            "Average waiting time spent in auth request",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgWaitingTime;

        [XomPerformanceCounterAttr(
            "Avg waiting time base",
            "Avg waiting time base",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgWaitingTimeBase;

        static public SGInfoCounters Counters = new SGInfoCounters();
    }


    //
    //  AuthToggle: Wraps the guts of turning on/off SG auth checking by config file.
    //
    [ComVisible(false)]
    public class AuthToggle
    {
        private static bool mGotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //
        private static bool mVerifyAuthData = true;

        // static constructor to get config settings for XBOS.
        private static void GetAuthToggle()
        {
            string r = Config.GetSetting(Setting.sginfo_verifyAuth);
            if(r != null)
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" )
                {
                    // have to tell EventBuilder to not get SGInfo, or else we'll cause
                    // infinite recursion!
                    EventBuilder.ShowSGInfo = false;
                    Xom.NtEvent( XEvent.Id.MC_SGINFO_IS_OFF,
                        "SG AUTH DATA VERIFICATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    mVerifyAuthData = false;
                }
            }
            mGotSetting = true;
        }

        public static bool On
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == true);
            }
        }

        public static bool Off
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == false);
            }
        }

    }

    [ComVisible(false)]
    public class SGInfo
    {
        private enum SgInfoSource
        {
            RealSg,         // From a "real" SG 
            FakeSg,         // From the FakeSgService, i.e. STF test
            HttpAuthData,   // From HTTP headers
            Placeholder,    // No headers, so a bogus local copy
            Local,          // Constructed locally
            Unknown         // Total mystery
        }

        private SgInfoSource _sgInfoSource = SgInfoSource.Unknown;  // Where did this sginfo come from?

        public bool IsSgInfoSourceInternal
        {
            get 
            { 
                return _sgInfoSource != SgInfoSource.RealSg &&
                       _sgInfoSource != SgInfoSource.FakeSg;
            }
        }

        // the following structures are defined in STF.x for the XSGInfo stuff.
        // they are mirrored here.
        //
        private struct sgMessageHeader
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        const int sizeMessageHeader = 4;

        private struct sgMessageSpiRequest
        {
            public uint   _dwReqNum;    // request number from requester
            public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
            public ushort _ipportZ;     // IP port of client on DMZ
        }
        const int sizeMessageSpiRequest = 10;

        // Unused, for reference only. sgprot.cs is a better bet.
//         private struct sgMessageSpiRequest2
//         {
//             public uint   _dwReqNum;    // request number from requester
//             public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
//             public ushort _ipportZ;     // IP port of client on DMZ
//             public ushort _dwAuthDataVersion; // Maximum supported authdata version
//         }
        const int sizeMessageSpiRequest2 = 12;

        private struct sgMessageSpiResponse
        {
            public uint   _dwReqNum;
            public uint   _ipaZ;
            public ushort _ipportZ;
            public byte   _fNotFound;
        }
        const int sizeMessageSpiResponse = 11;

        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;

        protected const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
        protected const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
        protected const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
                                                                      // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        public const ushort XONLINE_AUTHDATA_VERSION        = 0x02 ;
        public const ushort XONLINE_XENON_AUTHDATA_VERSION  = 0x03 ;
        public const ushort XONLINE_XENON2_AUTHDATA_VERSION = 0x04 ;

        // Not really a good namespace for this number, so we'll set the high bit.
        public const ushort XONLINE_V4V3DIFF_AUTHDATA_VERSION = 0x8004 ;

        const ushort sizeXenonAuthData = 194; // sizeof(XKERB_AD_XENON)
        const ushort sizeXenon2AuthData = 256; // sizeof(XKERB_AD_XENON2)
        const ushort sizeXenon2AuthDataReserved = 16; // sizeof(XKERB_AD_XENON2.abReserved)
        const ushort sizeV4V3DiffAuthData = 64;  // diff fields plus headers

        protected const ushort SGMSG_TYPE_SPIDATA_REQ     = 0x4710;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REQ2    = 0x4716;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REP     = 0x4711;  // CSgMsgSpiRep2

        protected const ushort SGMSG_TYPE_SPIDATA         = 0x4782;  // CSgMsgSpiData in the payload
        protected const ushort SGMSG_TYPE_AUTHDATA        = 0x4783;  // AuthData in the payload

        //  the following fields are in the SG Info structure. (XKERB_AD_XENON)
        //

        protected ushort    wAuthDataVersion;
        protected ushort    wAuthDataSize;        // Size of this struct in bytes

        // XBOX_LIBRARY_VERSION     clientVersion;
        protected ushort    wMajorVersion;
        protected ushort    wMinorVersion;
        protected ushort    wBuildNumber;
        protected ushort    wQFENumber;
        //

        protected uint      dwTitleID;
        protected uint      dwTitleVersion;
        protected uint      dwTitleRegion;
        protected uint      dwConsoleRegion;
        protected uint      dwMediaID;
        protected ushort    wLanguageID;

        // authdata flags
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENON_MASK      = 0x01;  // Deprecated!
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT = 0x02;
        public const uint XONLINE_AUTHDATA_FLAGS_ISDEVKIT          = 0x04;
        public const uint XONLINE_AUTHDATA_FLAGS_ISTESTKIT         = 0x08;
        public const uint XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE     = 0x10;
        public const uint XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE  = 0x20;

        protected uint      dwAuthDataFlags;

        protected ushort    wNumPrivileges;
        protected uint[]    dwPrivileges;
        protected uint[,]   dwUserPrivileges;

        protected ulong     qwXboxID;
        protected float     fltConsoleTrustRating;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        protected uint[]    dwAltTitleID;

        // The flowtoken in v4 tickets
        protected Floken    flowToken;

        // Key used for signing data within a session
        protected byte[]    key;

        // The high 16 bits of dwUserFlags should come from the UODB User Table.

        protected XUIDAndTrust[]   xUsers;
        protected uint             dwNumUsers;

        // user guest range
        public const ulong XONLINE_GUEST_XUID_START                = 0x0040000000000000;
        public const ulong XONLINE_GUEST_XUID_END                  = 0x004fffffffffffff;


        protected uint     dwNumServices;
        protected ushort   wNumDwordServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        protected uint[]   dwServiceIds;
        //

        // the rest of the spidata structure (CSgMsgSpiData)

        protected ushort  _ipportI;                   // IP port of the client on the Internet
        protected uint    _ipaI;                      // IP address of the client on the Internet
        protected byte[]  _sgaddr;                    // SGADDR of the client
        protected ushort  _wVersionKeyEx;             // KeyEx version of the client
        protected ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        protected ulong   _liNonce;                   // A random nonce associated with this session
        protected ulong   _liTimeInit;                // FILETIME marking session initiation
        protected uint    _fCs;                       // TRUE if SG is providing connection services

        // size of the spidata structure
        protected const int sizeSpiData = 54;


        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        protected static int staticRequestNumber = 0;

        // the instance reqnum, set when a request is first made.
        protected int thisRequestNumber;

        // config settings
        //
        protected static int _maxRetries;
        protected static int _sgTimeout;
        protected static bool _verifyTestTitleVersion;
        protected static bool _useOldProtocol;
        protected static int _supportedHttpAuthDataVersion;

        // SG ip
        protected IPAddress _srcIP;
        protected ushort    _srcPort;


        public static SGInfo Current
        {
            get
            {
                if (AuthToggle.Off)
                    return null;

                SGInfo sg = null;
                if (HttpContextAdapter.Current != null)
                {
                    sg = (SGInfo)HttpContextAdapter.Current.Items["SGInfo"];
                }

                if (sg == null)
                {
                    sg = new SGInfo();
                    if (HttpContextAdapter.Current != null)
                    {
                        HttpContextAdapter.Current.Items["SGInfo"] = sg;
                    }
                }

                return sg;
            }
        }

        // Toggle forceful retrieval of SGInfo for a flow token
        public static bool RetrieveSgInfoForFlowToken { get; set; }

        public static bool IsCached
        {
            get 
            {
                try
                {
                    return IsCachedInContext(HttpContextAdapter.Current);
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }

        public static bool IsAvailable
        {
            get
            {
                try 
                {
                    return IsAvailableInContext(HttpContextAdapter.Current);
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }

        public static bool IsCachedInContext(HttpContext ctx)
        {
            return IsCachedInContext(new HttpContextAdapter(ctx));
        }

        public static bool IsCachedInContext(HttpContextAdapter ctx)
        {
            try
            {
                if (ctx == null)
                {
                    return false;
                }
                return ctx.Items["SGInfo"] != null;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public static bool IsAvailableInContext(HttpContext ctx)
        {
            return IsAvailableInContext(new HttpContextAdapter(ctx));
        }

        public static bool IsAvailableInContext(HttpContextAdapter ctx)
        {
            if (ctx == null)
            {
                return false;
            }

            if (IsCachedInContext(ctx))
            {
                return true;
            }

            // If request definitely came from an SG, say yes. If request did not come 
            // from an SG and there is httpauthdata available, say yes. Otherwise say no. 
            //
            // What matters is we get close to the right answer.

            try 
            {
                if (ctx.Request == null)
                {
                    return false;
                }

                // Need to be an internal interface for HttpAuthData to be valid.
                if (CallSource.Get(ctx) != null)
                {
                    string viface = CallSource.Get(ctx);
                    if (viface != VirtualInterface.None)
                    {
                        IVirtualInterfaceInfo viinfo = Config.GetVirtualInterface(viface);
                        // Interface configured for SG SGInfo or HttpAuthData SGInfo?
                        if (null != viinfo && !viinfo.NeedSGInfo)
                        {
                            // SGInfo is available if header is present, otherwise no
                            return (null != ctx.Request.Headers[XHttpHdr.HTTPAUTHDATA]);
                        }
                    }
                }

                // Looks like a real SG. So let's check the source IP/port with known 
                // SG client ranges.
                //
                // @@@ Treat Unknown as yes or no? basically means no httpcontext (not 
                // true here), no interface info (errr), or from an STF test. I think 
                // we should go with yes.
                //
                SGAddressValidator.Answer ans = SGAddressValidator.Check(ctx);
                switch (ans)
                {
                case SGAddressValidator.Answer.Yes:
                case SGAddressValidator.Answer.Unknown:
                    return true;
                case SGAddressValidator.Answer.No:
                    return false;
                default:
                    return false;
                }
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static LockFreeStack<SGSocket> _socketPool = new LockFreeStack<SGSocket>();

        class SGSocket
        {
            public NativeSocket _socket;
            public byte[] _buffer;

            public SGSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, int cbBuffer)
            {
                _socket = new NativeSocket(addressFamily, socketType, protocolType);
                _buffer = new byte[cbBuffer];
            }
        }

        static SGInfo()
        {
            // load config settings
            Config.SettingChange += new SettingChangeEventHandler(SettingChangeEventHandler);

            _maxRetries = Config.GetIntSetting(Setting.sginfo_maxRetries);
            _sgTimeout = Config.GetIntSetting(Setting.sginfo_timeout);
            _verifyTestTitleVersion = Config.GetBoolSetting(Setting.sginfo_verifyTestTitleVersion);

            try
            {
                _useOldProtocol = Config.GetBoolSetting(Setting.sginfo_useOldProtocol);
            }
            catch (Exception)
            {
                _useOldProtocol = true;
            }

            try
            {
                // Basically just a chicken switch
                _supportedHttpAuthDataVersion = Config.GetIntSetting(Setting.sginfo_supportedHttpAuthDataVersion);
            }
            catch (Exception)
            {
                _supportedHttpAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;  // v3
            }

            try
            {
                RetrieveSgInfoForFlowToken = Config.GetBoolSetting(Setting.sginfo_retrieveForFlowToken);
            }
            catch (Exception)
            {
                RetrieveSgInfoForFlowToken = false;
            }
        }

        private static void SettingChangeEventHandler(object sender, SettingChangeEventArgs args)
        {
            string valueNew = args.ValueNew.ToLower();

            if (args.Setting == Setting.sginfo_maxRetries)
            {
                _maxRetries = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_timeout)
            {
                _sgTimeout = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_verifyTestTitleVersion)
            {
                _verifyTestTitleVersion = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
            else if (args.Setting == Setting.sginfo_useOldProtocol)
            {
                _useOldProtocol = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
            else if (args.Setting == Setting.sginfo_supportedHttpAuthDataVersion)
            {
                _supportedHttpAuthDataVersion = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_retrieveForFlowToken)
            {
                RetrieveSgInfoForFlowToken = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
        }


        // This is a special constructor for HTTPAuthData construction
        public SGInfo(ushort port, uint ip, ulong requestId)
        {
            _sgInfoSource = SgInfoSource.Local;
            CreateSGInfoData(port, ip, requestId);
        }

        /// <summary>
        /// The default constructor will create a new SGInfo with all the current information from
        /// the security gateway.
        /// </summary>
        public SGInfo()
            : this(HttpContextAdapter.Current)
        {
        }

        public SGInfo(HttpContext ctx)
            : this(new HttpContextAdapter(ctx))
        {
        }

        public SGInfo(string sIPPort)
        {
            int colon = sIPPort.IndexOf(':');
            if (colon == -1)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sIPPort);
            }
            _srcIP = IPAddress.Parse(sIPPort.Substring(0,colon));
            _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)Convert.ToUInt16(sIPPort.Substring(colon + 1)));

            GetInfoFromSG();
        }

        public SGInfo(IPAddress ipAddr, ushort wPort)
        {
            _srcIP = ipAddr;
            _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)wPort);

            GetInfoFromSG();
        }

        public SGInfo(HttpContextAdapter ctx)
        {
            // Useful for local testing without an HttpContext.
            if (ctx == null)
            {
                return;
            }

            string httpAuthData = ctx.Request.Headers[XHttpHdr.HTTPAUTHDATA];
            string viface = VirtualInterface.None;
            bool fGetSGInfo = true;

            if (CallSource.Get(ctx) != null)
            {
                viface = CallSource.Get(ctx);
            }

            string sgIPPort = ctx.Request.Headers[XHttpHdr.SGIPPORT];
            if (sgIPPort != null)
            {
                // The UDP adaptor adds this header so the front door attempts to talk back to the
                // correct IP and port.
                // XrlScan also adds this header, because the GetServerVariables() call below
                // is incredibly expensive (for reasons beyond our understanding...)
                Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_LOW, "SGIPPort header detected, value: " + sgIPPort + " (note port value is in network order)");
                // USe the last index because the address could be an IPv6 addr if running on xblob.
                int colon = sgIPPort.LastIndexOf(':');
                if (colon == -1)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sgIPPort);
                }
                _srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
                _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)Convert.ToUInt16(sgIPPort.Substring(colon + 1)));
            }
            else
            {
                _srcIP = ctx.Request.RemoteEP.Address;
                _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)ctx.Request.RemoteEP.Port);
            }

            if (viface != VirtualInterface.None)
            {
                IVirtualInterfaceInfo viinfo = Config.GetVirtualInterface(viface);
                if (null != viinfo)
                {
                    if (!viinfo.NeedSGInfo)
                    {
                        fGetSGInfo = false;
                    }
                }

            }

            if (fGetSGInfo)
            {
                GetInfoFromSG();

                // check this after getting the SGInfo, because we log out the info on the error.
                if (httpAuthData != null)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_2, "SGInfo: This SG("+_srcIP+") tried to send us fake HTTP AuthData: " + ToString());
                }
            }
            else
            {
                GetInfoFromHttp(httpAuthData);
            }
        }

        protected void GetInfoFromSG()
        {
            // Determine source. This class stores _srcPort in network order, but 
            // SGAddressValidator requires host order.
            SGAddressValidator.Answer ans = SGAddressValidator.Check(
                _srcIP, 
                (ushort)IPAddress.NetworkToHostOrder((short)_srcPort));
            switch (ans)
            {
            case SGAddressValidator.Answer.Yes:
                _sgInfoSource = SgInfoSource.RealSg;
                break;
            case SGAddressValidator.Answer.Unknown:
            case SGAddressValidator.Answer.No:
            default:
                // with HttpContext, SGAddressValidator would report "unknown" for the 
                // fakesg (test) case. but since we're only giving it an ip address, it 
                // can't make this determination and so only returns yes/no. Thus we have 
                // to assume "no" means FakeSg, even though it could be wrong. :(
                _sgInfoSource = SgInfoSource.FakeSg;
                break;
            }

            BinaryReader sgInfo = null;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            SGSocket sgsock;
            byte[] sgRequest;
            byte[] sgResponse = null;
            bool haveData = false;
            int recBytes = 0;
            bool fRetry = true;


            lRetry:

            try
            {
                SGInfoCounters.Counters.AuthRequestsPerSecond.Increment();
                SGInfoCounters.Counters.AuthRequestsTotal.Increment();

                Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_LOW, "Requesting auth data from security gateway for user at "
                    + _srcIP.ToString() + ":" + _srcPort + "..." );

                sgsock = _socketPool.Pop();

                if (sgsock == null)
                {
                    sgsock = new SGSocket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp, 1500);
                    // removed:  is this important here?
                    // sock.Blocking = false;
                    IPEndPoint epLocal = new IPEndPoint(IPAddress.Any, 0);
                    sgsock._socket.Bind(epLocal);
                }

                // build SG request.
                sgRequest = BuildRequest(_srcIP, _srcPort);

                IPEndPoint SgMsgPort = new IPEndPoint(_srcIP, XONLINE_SG_MESSAGE_PORT);

                try
                {
                    IPEndPoint ep = new IPEndPoint(IPAddress.Any, 0);

                    // first clear any remaining traffic sitting on this old socket.
                    while (sgsock._socket.Select(0, SelectMode.SelectRead))
                    {
                        sgsock._socket.ReceiveFrom(sgsock._buffer, ref ep);
                    }

                    for(int i=0; i < _maxRetries; i++ )
                    {
                        //send the request
                        sgsock._socket.SendTo(sgRequest, SgMsgPort);

                        if(sgsock._socket.Select(_sgTimeout * 1000 * (1 << i), SelectMode.SelectRead))
                        {
                            sgResponse = sgsock._buffer;

                            recBytes = sgsock._socket.ReceiveFrom(sgResponse, ref ep);

                            if(sgResponse != null && recBytes > 0)
                            {
                                sgInfo = new BinaryReader(new MemoryStream(sgResponse));

                                // we've succeeded in getting results if we're here.
                                // see if they're meaningful.
                                haveData = VerifyResponse(sgInfo, true);

                                if (haveData)
                                {
                                    break;
                                }
                                else
                                {
                                    haveData = false;
                                    sgInfo = null;
                                    sgResponse = null;
                                    recBytes = 0;
                                }
                            }
                        }

                        SGInfoCounters.Counters.RetriesPerSecond.Increment();
                        SGInfoCounters.Counters.RetriesTotal.Increment();
                    }

                    _socketPool.Push(sgsock);
                }
                catch(Exception e)
                {
                    sgsock._socket.Shutdown(SocketShutdown.Both);
                    sgsock._socket.Close();
                    sgsock._socket = null;
                    sgsock._buffer = null;
                    sgsock = null;

                    if (fRetry == false)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_SG_COMMUNICATION_ERROR, "SG("+_srcIP+"): " + e);
                    }
                    else
                    {
                        fRetry = false;
                        goto lRetry;
                    }
                }

                if(sgResponse != null && recBytes > 0)
                {
                    // @@@ kgoodier Why are we doing this twice?!

                    sgInfo = new BinaryReader(new MemoryStream(sgResponse));

                    // we've succeeded in getting results if we're here.
                    // see if they're meaningful.
                    haveData = VerifyResponse(sgInfo, true);
                }
                else
                {
                    // @@@ kgoodier better event here - maybe print out the received 
                    // response and/or received req num
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_COMM_31, "SGInfo: Can't talk to SG("+_srcIP+"). Timed out after " + _maxRetries
                        + " attempts! (req #" + thisRequestNumber + "). Using old protocol: " + _useOldProtocol);

                    // @@@ if this happens too often and _useOldProtocol=false, maybe fall 
                    // back to using the old protocol?
                }

                // make sure we have valid data.
                if (haveData == false)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_SG_COMMUNICATION_ERROR_1, "SGInfo: can't successfully contact SG("+_srcIP
                        + ") for auth data. Using old protocol: " + _useOldProtocol);
                }

                ReadSgInfo(sgInfo, false);
            }
            catch(Exception)
            {
                SGInfoCounters.Counters.FailedRequestsPerSecond.Increment();
                SGInfoCounters.Counters.FailedRequestsTotal.Increment();

                throw;
            }
            finally
            {
                long elapsed = timeElapsed.TimeElapsed;

                SGInfoCounters.Counters.AvgWaitingTime.IncrementBy(elapsed);
                SGInfoCounters.Counters.AvgWaitingTimeBase.Increment();
            }
        }

        protected void GetInfoFromHttp(string httpAuthData)
        {
            BinaryReader sgInfo = null;

            if (httpAuthData == null)
            {
                _sgInfoSource = SgInfoSource.Placeholder;
                // This is a datacenter call, but the header is missing, so create a placeholder
                // @@@ kgoodier WHY ARE WE DOING THIS?!
                CreateSGInfoData(_srcPort, 0, 0);
            }
            else
            {
                _sgInfoSource = SgInfoSource.HttpAuthData;

                byte[] httpBytes = Convert.FromBase64String(httpAuthData);
                sgInfo = new BinaryReader(new MemoryStream(httpBytes));

                ushort version = sgInfo.ReadUInt16();
                if (version == SGMSG_TYPE_SPIDATA_REP)
                {
                    // auth data from an SG, treat it like normal sg information
                    sgInfo.BaseStream.Seek(0, SeekOrigin.Begin);

                    VerifyResponse(sgInfo, false);
                    ReadSgInfo(sgInfo, false);
                }
                else if (version == HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION)
                {
                    _ipportI         = sgInfo.ReadUInt16();
                    _ipaI            = sgInfo.ReadUInt32();
                    _sgaddr          = null;
                    _wVersionKeyEx   = 0;
                    _wFlagsKeyEx     = 0;
                    _liNonce         = sgInfo.ReadUInt64();
                    _liTimeInit      = (ulong)DateTime.Now.Ticks;
                    _fCs             = 0;

                    ReadSgInfo(sgInfo, true);

                    // More bytes? Maybe there's a diff structure here
                    if (_supportedHttpAuthDataVersion > XONLINE_XENON_AUTHDATA_VERSION)
                    {
                        ushort wDiffVersion;
                        long bytesRemaining = sgInfo.BaseStream.Length - sgInfo.BaseStream.Position;
                        if (bytesRemaining > 2)
                        {
                            wDiffVersion = sgInfo.ReadUInt16();
                            if (wDiffVersion == XONLINE_V4V3DIFF_AUTHDATA_VERSION)
                            {
                                ReadAuthDataV4V3Diff(sgInfo);
                            }
                        }
                        // Ignore any unknown versions
                    }
                }
                else
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_HTTP_AUTHDATA, "SGInfo: HTTP AuthData has bad version: " + version.ToString() );
                }
            }
        }

        // This is a special constructor for HTTPAuthData construction
        public void CreateSGInfoData(ushort port, uint ip, ulong requestId)
        {
            wAuthDataVersion      = XONLINE_XENON2_AUTHDATA_VERSION;
            _ipportI              = port;
            _ipaI                 = ip;
            _liNonce              = requestId;

            _sgaddr               = null;
            _wVersionKeyEx        = 0;
            _wFlagsKeyEx          = 0;
            _liTimeInit           = (ulong)DateTime.Now.Ticks;
            _fCs                  = 0;

            wMajorVersion         = 0;
            wMinorVersion         = 0;
            wBuildNumber          = 0;
            wQFENumber            = 0;
            dwTitleID             = 0;
            dwTitleVersion        = 0;
            dwTitleRegion         = 0;
            dwConsoleRegion       = 0;
            dwMediaID             = 0;
            wLanguageID           = 0;
            dwAuthDataFlags       = 0;

            wNumPrivileges        = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];

            wNumDwordServices     = 0;
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];

            qwXboxID              = 0;
            fltConsoleTrustRating = 0.0F;

            // users (XUIDAndTrust)
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwNumUsers            = 0;

            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];

            // Fill in the empty users
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

#region Serializers / deserializers
        // {{{

        private void ReadSgInfo(BinaryReader reader, bool onlyAuthData)
        {
            sgMessageHeader authHdr;
            authHdr._wType = SGMSG_TYPE_AUTHDATA;
            authHdr._cbEnt = 0;

            // if we're getting more than authdata then get ready to read the spi data.
            if (!onlyAuthData)
            {
                _ipportI         = reader.ReadUInt16();
                _ipaI            = reader.ReadUInt32();
                _sgaddr          = reader.ReadBytes(20);
                _wVersionKeyEx   = reader.ReadUInt16();
                _wFlagsKeyEx     = reader.ReadUInt16();
                _liNonce         = reader.ReadUInt64();
                _liTimeInit      = reader.ReadUInt64();
                _fCs             = reader.ReadUInt32();

                // read the spi header.
                authHdr._wType   = reader.ReadUInt16();
                authHdr._cbEnt   = reader.ReadUInt16();
            }

            wAuthDataVersion = reader.ReadUInt16();
            if ( wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION )
            {
                ReadXenonV2SgInfo( reader, authHdr, onlyAuthData );
            }
            else if ( wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION )
            {
                ReadXenonSgInfo( reader, authHdr, onlyAuthData );
            }
            else if ( wAuthDataVersion == XONLINE_AUTHDATA_VERSION )
            {
                ReadV2SgInfo( reader, authHdr, onlyAuthData );
            }
            else
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA,
                    "SGInfo: Auth data from SG("+_srcIP+") version ("
                    + wAuthDataVersion + ") is incorrect!"
                    );
            }

        }

        private void ReadXenonSgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            dwConsoleRegion       = reader.ReadUInt32();
            dwMediaID             = reader.ReadUInt32();
            wLanguageID           = reader.ReadUInt16();
            dwAuthDataFlags       = reader.ReadUInt32();
            wNumPrivileges        = reader.ReadUInt16();

            dwNumUsers            = 0;
            fltConsoleTrustRating = 0.0F;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];

            // read in the privileges
            for( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++ )
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }

            // read Xbox puid
            qwXboxID = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);

                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }
                dwNumUsers++;

                // Make a per-user privilege table
                for ( int j = 0; j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read user trust factors.
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                xUsers[i].userTrust = reader.ReadSingle();
            }

            // read the number of extended services. Should we throw something
            // if we get more than XONLINE_MAX_DWORD_SERVICEIDS here?
            wNumDwordServices = reader.ReadUInt16();

            // read DWORD service ids
            for( int i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++ )
            {
                uint serviceID = reader.ReadUInt32();
                if ( serviceID != 0 )
                {
                    dwServiceIds[dwNumServices++] = serviceID;
                }
            }

            // Calculate the total number of services present
            dwNumServices = (uint)(wNumPrivileges + wNumDwordServices);

            // read alternate title IDs
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }

            // read ticket key
            key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
        }

        private void ReadXenonV2SgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwAuthDataFlags       = reader.ReadUInt32();
            qwXboxID              = reader.ReadUInt64();
            fltConsoleTrustRating = reader.ReadSingle();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            dwConsoleRegion       = reader.ReadUInt32();
            dwMediaID             = reader.ReadUInt32();
            wLanguageID           = reader.ReadUInt16();
            wNumDwordServices     = reader.ReadUInt16();
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwNumUsers            = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];

            int i, j;

            // read DWORD service ids
            for( i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++ )
            {
                uint serviceID = reader.ReadUInt32();
                if ( serviceID != 0 )
                {
                    dwServiceIds[dwNumServices++] = serviceID;
                }
            }

            // read users (XUIDAndTrust)
            for( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read user trust factors.
            for( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                xUsers[i].userTrust = reader.ReadSingle();
            }

            // Read in privileges
            for( i = 0; i < XOn.XONLINE_NUM_BASE_SERVICES_DWORDS; i++ )
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }

            // Read in machine privileges
            dwPrivileges[XOn.XONLINE_NUM_BASE_SERVICES_DWORDS] = reader.ReadUInt32();

            // Read in per-user privileges
            for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = reader.ReadUInt32();
                }

                // Was there a user present in this slot?
                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }

                // Since there is a user at this slot, copy in the base services and
                // machine privileges for this user.
                for ( j = 0;
                      j < XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }

            // Are there users present?
            if (dwNumUsers > 0)
            {
                // Yes. Figure out what the least common demonimator for the
                // per-user privileges are
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    uint mask = 0xFFFFFFFF;
                    for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                    {
                        if (xUsers[i].qwUserID == 0)
                        {
                            continue;
                        }
                        mask &= dwUserPrivileges[i,j];
                    }
                    dwPrivileges[j] = mask;
                }
            }

            // Finally, count how many privileges are set
            wNumPrivileges = 0;
            for ( i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++ )
            {
                uint mask = dwPrivileges[i];

                while (mask != 0)
                {
                    mask &= (mask -1);
                    wNumPrivileges++;
                }
            }

            dwNumServices = (uint)(wNumPrivileges + wNumDwordServices);

            // read alternate title IDs
            for( i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }

            flowToken = new Floken(reader);

            // Throw away this info for now
            reader.ReadBytes( sizeXenon2AuthDataReserved );

            // read ticket key
            key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
        }

        private void ReadV2SgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            qwXboxID              = reader.ReadUInt64();
            wNumPrivileges        = 0;
            dwNumUsers            = 0;
            fltConsoleTrustRating = 0.0F;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];


            // read users (XUIDAndTrust)
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read services
            dwNumServices = reader.ReadUInt32();
            for( int i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++ )
            {
                dwServiceIds[i]  = reader.ReadUInt32();
            }

            //  read additional auth data information for later auth data structures.
            if ( authHdr._wType  == SGMSG_TYPE_AUTHDATA )
            {
                // read user truct factors.
                for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    // set the user trust factor.
                    xUsers[i].userTrust = reader.ReadSingle();
                }

                // read alternate title IDs
                for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = reader.ReadUInt32();
                }

                // read ticket key
                key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
            }
            else
            {
                for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = 0;
                }
                key = new byte[XOn.XONLINE_KEY_LENGTH];
            }

            // dummy data from v3 privs
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }
        }

        private void ReadAuthDataV4V3Diff(BinaryReader reader)
        {
            // Note: see WriteAuthDataV4V3Diff for layout description.

            ushort wDiffSize;

            wDiffSize = reader.ReadUInt16();
            if (wDiffSize != sizeV4V3DiffAuthData)
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA,
                    "SGInfo: Auth data from SG("+_srcIP+") version ("
                    + wAuthDataVersion + ") is incorrect! Found V4V3Diff blob "
                    + "but size is " + wDiffSize + ", expected " 
                    + sizeV4V3DiffAuthData + "."
                    );
            }

            fltConsoleTrustRating = reader.ReadSingle();
            flowToken = new Floken(reader);

            if (dwUserPrivileges == null)
            {
                dwUserPrivileges = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            }

            // Read in per-user privileges
            int i, j;
            for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = reader.ReadUInt32();
                }

                // Was there a user present in this slot?
                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }

                // Since there is a user at this slot, copy in the base services and
                // machine privileges for this user.
                for ( j = 0;
                      j < XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }

            // This is actually a V4 Authdata, not a V3, so promote it.
            wAuthDataVersion = XONLINE_XENON2_AUTHDATA_VERSION;
            wAuthDataSize = sizeXenon2AuthData;
        }

        private void WriteXenonSgInfo(BinaryWriter w)
        {
            long startPosition = w.BaseStream.Position;

            int i;

            w.Write(XONLINE_XENON_AUTHDATA_VERSION);
            w.Write( (ushort) sizeXenonAuthData);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);
            w.Write(dwAuthDataFlags);

            w.Write(wNumPrivileges);
            Debug.Assert( dwPrivileges.Length == XOn.XONLINE_NUM_PRIVILEGE_DWORDS );
            for (i=0; i < dwPrivileges.Length; i++)
            {
                w.Write(dwPrivileges[i]);
            }

            w.Write(qwXboxID);
            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            w.Write(wNumDwordServices);

            for (i=0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);
            long endPosition = w.BaseStream.Position;

            Debug.Assert( sizeXenonAuthData == (endPosition - startPosition) );
        }

        private void WriteXenonV2SgInfo(BinaryWriter w)
        {
            long startPosition = w.BaseStream.Position;

            int i,j;

            w.Write(XONLINE_XENON2_AUTHDATA_VERSION);
            w.Write( (ushort) sizeXenon2AuthData);

            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwAuthDataFlags);
            w.Write(qwXboxID);
            w.Write(fltConsoleTrustRating);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);

            w.Write(wNumDwordServices);
            for (i=0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            for (i=0; i < XOn.XONLINE_NUM_BASE_SERVICES_DWORDS; i++)
            {
                w.Write(dwPrivileges[i]);
            }
            w.Write(dwPrivileges[XOn.XONLINE_NUM_BASE_SERVICES_DWORDS]);

            for (i=0; i < xUsers.Length; i++)
            {
                for (j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                     j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                     j++)
                {
                    w.Write( dwUserPrivileges[i,j] );
                }
            }

            for (i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            flowToken.Write(w);

            w.Write( new byte[sizeXenon2AuthDataReserved] );
            w.Write(key);

            Debug.Assert( sizeXenon2AuthData == (w.BaseStream.Position - startPosition) );
        }

        private void WriteAuthDataV4V3Diff(BinaryWriter w)
        {
            // What's new?
            //   console trust rating (4 bytes)
            //   flow token (8 bytes)
            //   per-user privileges (12 DWORDS, 48 bytes)

            long startPosition = w.BaseStream.Position;
            int i,j;

            w.Write((ushort)XONLINE_V4V3DIFF_AUTHDATA_VERSION);
            w.Write((ushort)sizeV4V3DiffAuthData);
            w.Write(fltConsoleTrustRating);
            flowToken.Write(w);

            // 96 bits, or 3 DWORDS, per user
            for (i=0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for (j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                     j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                     j++)
                {
                    w.Write( dwUserPrivileges[i,j] );
                }
            }

            Debug.Assert( sizeV4V3DiffAuthData == (w.BaseStream.Position - startPosition) );
        }

        // }}}
#endregion

        private byte[] BuildRequest(IPAddress ip, ushort port)
        {
            byte[] addr = ip.GetAddressBytes();
            uint ipaZ   = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
            thisRequestNumber = Interlocked.Increment(ref staticRequestNumber);

            if (_useOldProtocol)
            {
                MemoryStream ms = new MemoryStream();
                BinaryWriter wr = new BinaryWriter(ms);
                sgMessageHeader header;
                sgMessageSpiRequest req;
                byte[] reqSize;

                // build the data into structs for clean maintenance
                header._wType = SGMSG_TYPE_SPIDATA_REQ;
                header._cbEnt = sizeMessageHeader + sizeMessageSpiRequest;
                req._dwReqNum = (uint)thisRequestNumber;
                req._ipaZ     = ipaZ;
                req._ipportZ  = port;

                // now stream the structs out into a byte array.
                wr.Write(header._wType);
                wr.Write(header._cbEnt);
                wr.Write(req._dwReqNum);
                wr.Write(req._ipaZ);
                wr.Write(req._ipportZ);
                reqSize = ms.ToArray();
                Debug.Assert (reqSize.Length == header._cbEnt);

                return reqSize;

            }
            else
            {
#if USEPROTOCOL
                // Not available at the moment due to XLUSE and configsn build issues. But 
                // this is the better way to do this.
                CSgMsgSpiReq2 req = new CSgMsgSpiReq2();
                req._dwReqNum = (uint)thisRequestNumber;
                req._ipaZ = ipaZ;
                req._ipportZ = port;
                req._wAuthDataVersion = XONLINE_XENON2_AUTHDATA_VERSION;
                byte[] reqBytes = req.ToArray();

                Debug.Assert(reqBytes.Length == req.header._cbEnt);
                return reqBytes;
#else
                MemoryStream ms = new MemoryStream(sizeMessageHeader + sizeMessageSpiRequest);
                BinaryWriter wr = new BinaryWriter(ms);
                ushort cbEnt = sizeMessageHeader + sizeMessageSpiRequest2;
                wr.Write((ushort)SGMSG_TYPE_SPIDATA_REQ2);
                wr.Write((ushort)cbEnt);
                wr.Write((uint)thisRequestNumber);
                wr.Write((uint)ipaZ);
                wr.Write((ushort)port);
                wr.Write((ushort)XONLINE_XENON2_AUTHDATA_VERSION);  // this is the version we want, but we'll accept older

                byte[] reqBytes = ms.ToArray();
                Debug.Assert(reqBytes.Length == cbEnt);
                return reqBytes;
#endif
            }
        }

        bool VerifyResponse(BinaryReader br, bool verifyRequestNum)
        {
            sgMessageHeader header;
            sgMessageSpiResponse reply;

            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA_REP)
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_1, "SGInfo: Unhandleable response type 0x" + header._wType.ToString("x"));
            }

            header._cbEnt = br.ReadUInt16();
            if (header._cbEnt != (sizeMessageHeader + sizeMessageSpiResponse))
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_2, "SGInfo: Unexpected SG reply size (" + header._cbEnt + ")."
                    + " Expected size is " + (sizeMessageHeader + sizeMessageSpiResponse));
            }

            reply._dwReqNum = br.ReadUInt32();
            reply._ipaZ = br.ReadUInt32();
            reply._ipportZ = br.ReadUInt16();
            reply._fNotFound = br.ReadByte();

            // make sure reqnum is the same as the request we sent.
            if (verifyRequestNum && reply._dwReqNum != (uint)thisRequestNumber)
            {
                return false;
            }

            if (reply._fNotFound != 0)
            {
                IPAddress ipZ = new IPAddress (reply._ipaZ);
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_3, "SGInfo: SG replies saying auth data NOT FOUND for " +
                    ipZ.ToString() + ":" + reply._ipportZ + " (DMZ)");
            }

            // next reade the header on the auth data itself (as distinct from the
            // header on the SG reply, which is read above).
            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA)
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_4, "SGInfo: Unexpected auth payload type 0x" + header._wType.ToString("x")
                    + "... Expected type SGMSG_TYPE_SPIDATA" );
            }

            header._cbEnt = br.ReadUInt16();
            if ( header._cbEnt != sizeSpiData )
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_5, "SGInfo: Unexpected SG auth data size (" + header._cbEnt + ")."
                    + " Expected size is " + sizeSpiData);
            }

            // if we made it this far, we should be ready to roll.
            return true;
        }


        public override string ToString()
        {
            try
            {
                int i;
                int count;
                StringBuilder bldr = new StringBuilder();

                if (wAuthDataVersion != XONLINE_XENON2_AUTHDATA_VERSION)
                {
                    // Only log version if not the latest
                    bldr.AppendFormat("Version: {0}\r\n", wAuthDataVersion);
                }

                // The SGIPPORT header, basically
                bldr.AppendFormat("Source: {0}:{1} ({2})\r\n",
                                  _srcIP, (ushort)IPAddress.NetworkToHostOrder((short)_srcPort),
                                  _sgInfoSource);

                // From inside the SGInfo data, presumably the Internet IP of the client.
                // Little fuzzier for HTTPAuthData.
                bldr.AppendFormat("ExternalIP: {0}:{1}\r\n",
                                  ClientIP, (ushort)IPAddress.NetworkToHostOrder((short)ClientPort));

                bldr.AppendFormat("Nonce: {0:X16}\r\n", _liNonce);
                bldr.AppendFormat("KeyExFlags: 0x{0:X}\r\n", _wFlagsKeyEx);
                bldr.Append("TitleId: 0x");
                bldr.Append(TitleId.ToString("X"));
                bldr.Append("\r\nTitleVer: 0x");
                bldr.Append(dwTitleVersion.ToString("X"));
                bldr.Append("\r\nTitleRgn: 0x");
                bldr.Append(dwTitleRegion.ToString("X"));
                bldr.Append("\r\nConsoleRgn: 0x");
                bldr.Append(dwConsoleRegion.ToString("X"));
                bldr.Append("\r\nMediaID: 0x");
                bldr.Append(dwMediaID.ToString("X"));
                bldr.Append("\r\nLanguageID: ");
                bldr.Append(wLanguageID);
                bldr.Append("\r\nAuthDataFlags: 0x");
                bldr.Append(dwAuthDataFlags.ToString("X"));

                bldr.AppendFormat("\r\nXboxLibVer: {0}.{1}.{2}.{3}", wMajorVersion, wMinorVersion, wBuildNumber, wQFENumber);
                bldr.AppendFormat("\r\nMachineId: 0x{0:X16}", MachineId);
                bldr.AppendFormat("\r\nPlatform: {0}", GetPlatformType());

                count = 0;
                for (i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append("\r\nU" + i.ToString() + ": 0x" + xUsers[i].qwUserID.ToString("X") + " (" + xUsers[i].dwUserFlags.ToString("X") + "," + xUsers[i].userTrust.ToString() + ")");
                        ++count;
                    }

                }
                if (count == 0)
                {
                    bldr.Append("\r\nno users present.");
                }

                count = 0;
                bldr.Append("\r\nServices: ");
                for (i = 0; i < XOn.XONLINE_MAX_PRIVILEGE_ID / 2; i++)
                {
                    if ( dwPrivileges != null && IsServicePresent(i) )
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append(i.ToString());
                    }
                }
                for (i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
                {
                    if (dwServiceIds != null && dwServiceIds[i] != 0)
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append("0x" + dwServiceIds[i].ToString("X"));
                    }
                }
                if (count == 0)
                {
                    bldr.Append("no services present (WARNING: TEST ONLY!)");
                }

                count = 0;
                bldr.Append("\r\nPrivileges: ");
                for (i = XOn.XONLINE_MAX_PRIVILEGE_ID / 2; i < XOn.XONLINE_MAX_PRIVILEGE_ID; i++)
                {
                    if ( IsPrivilegePresent(i) )
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append(i.ToString());
                    }
                }

                count = 0;
                for (i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
                {
                    if (dwAltTitleID != null && dwAltTitleID[i] != 0)
                    {
                        bldr.Append("\r\nAltTitleID" + i.ToString() + ": 0x" + dwAltTitleID[i].ToString("X"));
                        ++count;
                    }
                }
                if (count == 0)
                {
                    bldr.Append("\r\nno AltTitleID present");
                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToString(): " + e.ToString();
            }
        }


        public string ToXomLogString()
        {
            try
            {
                StringBuilder bldr = new StringBuilder();

                bldr.Append(TitleId.ToString("X8")+"|");
                bldr.Append(dwTitleVersion.ToString("X8")+"|");
                bldr.Append(dwTitleRegion.ToString("X8")+"|");
                bldr.Append(ClientIP.ToString() + "|");
                bldr.Append(MachineId.ToString("X16")+"|");

                for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append(xUsers[i].qwUserID.ToString("X16") + "|" );
                    }
                    else
                    {
                        bldr.Append("0|");
                    }

                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToXomLogString(): " + e.ToString();
            }
        }


        // public accessors and helper methods
        public ushort AuthDataVersion { get { return wAuthDataVersion; } }
        public ushort AuthDataSize { get { return wAuthDataSize; } }

        public ushort MajorVersion { get { return wMajorVersion; } }
        public ushort MinorVersion { get { return wMinorVersion; } }
        public ushort BuildNumber { get { return wBuildNumber; } }
        public ushort QFENumber { get { return wQFENumber; } }

        public uint ClientVersion
        {
            get {
                return (uint) ((MajorVersion &    0xF) << 28) |
                       (uint) ((MinorVersion &    0xF) << 24) |
                       (uint) ((BuildNumber  & 0xFFFF) <<  8) |
                       (uint)  (QFENumber    &   0xFF);
            }
        }

        public uint AltTitleId1 { get { return dwAltTitleID[ 0 ]; } }
        public uint AltTitleId2 { get { return dwAltTitleID[ 1 ]; } }
        public uint AltTitleId3 { get { return dwAltTitleID[ 2 ]; } }
        public uint AltTitleId4 { get { return dwAltTitleID[ 3 ]; } }
        public uint TitleRegion { get { return dwTitleRegion; } }
        public ushort ClientPort { get { return _ipportI; } }

        public uint TitleId
        {
            get { return dwTitleID; }
        }

        public uint TitleVersion
        {
            get { return dwTitleVersion; }
        }

        public uint ConsoleRegion
        {
            get { return dwConsoleRegion; }
        }

        public uint MediaID
        {
            get { return dwMediaID; }
        }

        public ushort LanguageID
        {
            get { return wLanguageID; }
        }

        public uint AuthDataFlags
        {
            get { return dwAuthDataFlags; }
        }

        public ulong MachineId
        {
            get { return qwXboxID; }
        }

        public IPAddress ClientIP
        {
            get { return new IPAddress(_ipaI); }
        }

        public ulong TimeSessionStarted
        {
            get { return _liTimeInit; }
        }

        public XUIDAndTrust[] LogonUsers
        {
            get { return xUsers; }
        }

        public ulong PrimaryUserXuid
        {
            get 
            {
                // Return first signed-in users. This is consistent with how we've been 
                // doing this for the BI team, but is still somewhat arbitrary.
                int userIndex = PrimaryUserIndex;
                if (userIndex >= 0)
                {
                    return xUsers[userIndex].qwUserID;
                }
                return 0;
            }
        }

        public int PrimaryUserIndex
        {
            get 
            {
                // Return first signed-in users. This is consistent with how we've been 
                // doing this for the BI team, but is still somewhat arbitrary.
                for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers[i].qwUserID != 0 && !xUsers[i].IsGuest())
                    {
                        return i;
                    }
                }
                return -1;
            }
        }

        public ulong Nonce
        {
            get { return _liNonce; }
        }

        public Floken FlowToken
        {
            get { return flowToken; }
        }

        public float ConsoleTrustRating
        {
            get { return fltConsoleTrustRating; } 
        }

        public bool IsUserPresent(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public bool CanUserPurchase(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid)
                    {
                        if(xUsers[i].CanPurchase())
                        {
                            return true;
                        }
                    }
                }
            }

            // user not found, or can't purchase
            return false;
        }

        public byte GetUserCountry(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].UserCountry());
                    }
                }
            }

            // user not found
            return 0;
        }

        public byte GetUserLanguage(ulong userId)
        {
            int i;

            if (userId != 0)
            {
                for(i=0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if(xUsers[i].qwUserID == userId && !xUsers[i].IsGuest())
                    {
                        return xUsers[i].UserLanguage();
                    }
                }
            }

            // user not found
            return 0;
        }

        public byte GetUserTier(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].UserTier());
                    }
                }
            }

            // user not found
            return 0;
        }

        public float GetUserTrust(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].userTrust);
                    }
                }
            }

            // user not found
            return Single.NaN;
        }

        public bool IsServicePresent(XOService serviceId)
        {
            return IsServicePresent((int) serviceId);
        }

        public bool IsServicePresent(int serviceId)
        {
            // base services are represented using the privilege bits
            // dword services are stored in a separate four element array
            if ( serviceId < XOn.XONLINE_MAX_PRIVILEGE_ID )
            {
                // We explicitly don't allow the caller to determine if
                // anything other than a service is present
                if (serviceId >= XOn.MPRIVILEGE_MIN)
                {
                    return false;
                }

                // find the DWORD containing this bit
                int dwordIndex = serviceId / 32;

                // find the bit offset within the DWORD
                int bitIndex = serviceId - dwordIndex*32;

                // create the mask
                uint mask = ((uint)1) << bitIndex;

                if ( (dwPrivileges[dwordIndex] & mask) == mask )
                {
                    return true;
                }
            }
            else
            {
                for (int i=0; i < dwServiceIds.Length; i++)
                {
                    if ( dwServiceIds[i] == (uint)serviceId )
                    {
                        return true;
                    }
                }
            }

            // service not found
            return false;
        }

        public bool IsPrivilegePresent(int privilegeId)
        {
            // Explicitly don't allow the calller to check for anything
            // other than privileges
            if (privilegeId < XOn.MPRIVILEGE_MIN || 
                privilegeId >= XOn.XONLINE_MAX_PRIVILEGE_ID)
            {
                return false;
            }

            // find the DWORD containing this bit
            int dwordIndex = privilegeId / 32;

            // find the bit offset within the DWORD
            int bitIndex = privilegeId - dwordIndex*32;

            // create the mask
            uint mask = ((uint)1) << bitIndex;

            return ((dwPrivileges[dwordIndex] & mask) == mask);
        }

        public bool IsPrivilegePresent(ulong xuid, int privilegeId)
        {
            // Explicitly don't allow the calller to check for anything
            // other than privileges
            if (privilegeId < XOn.MPRIVILEGE_MIN || 
                privilegeId >= XOn.XONLINE_MAX_PRIVILEGE_ID ||
                xuid == 0)
            {
                return false;
            }

            // find the DWORD containing this bit
            int dwordIndex = privilegeId / 32;

            // find the bit offset within the DWORD
            int bitIndex = privilegeId - dwordIndex*32;

            // create the mask
            uint mask = ((uint)1) << bitIndex;

            int i;

            for (i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
            {
                if (xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                {
                    return ((dwUserPrivileges[i,dwordIndex] & mask) == mask);
                }
            }
            return false;
        }

        public byte[] GetMachinePrivileges()
        {
            List<byte> retServices = new List<byte>(64);
            for (int i = XOn.MPRIVILEGE_MIN; i < XOn.MPRIVILEGE_MAX; i++)
            {
                if (dwPrivileges != null && IsPrivilegePresent(i))
                {
                    retServices.Add((byte)i);
                }
            }
            return retServices.ToArray();
        }

        public byte[] GetUserPrivileges(ulong xuid)
        {
            List<byte> retPrivs = new List<byte>(64);
            for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
            {
                if (xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                {
                    for (int privilegeId = XOn.MPRIVILEGE_MAX; privilegeId < XOn.XONLINE_MAX_PRIVILEGE_ID; privilegeId++)
                    {
                        // find the DWORD containing this bit
                        int dwordIndex = privilegeId / 32;

                        // find the bit offset within the DWORD
                        int bitIndex = privilegeId - dwordIndex * 32;

                        // create the mask
                        uint mask = ((uint)1) << bitIndex;

                        bool hasPrivilege = ((dwUserPrivileges[i, dwordIndex] & mask) == mask);
                        if (hasPrivilege)
                        {
                            retPrivs.Add((byte)privilegeId);
                        }
                    }
                }
            }
            return retPrivs.ToArray();
        }

        public uint[] GetServices()
        {
            List<uint> retServices = new List<uint>(64);
            int i;
            for (i = 0; i < XOn.MPRIVILEGE_MIN; i++)
            {
                if (dwPrivileges != null && IsServicePresent(i))
                {
                    retServices.Add((uint)i);
                }
            }
            for (i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                if (dwServiceIds != null && dwServiceIds[i] != 0)
                {
                    retServices.Add(dwServiceIds[i]);
                }
            }
            return retServices.ToArray();
        }

        // PlatformType
        // Returns the client's platform type. Returns one of the XOn.XPLT_* constants.
        public byte GetPlatformType()
        {
            return GetPlatformType(HttpContextAdapter.Current);
        }

        public byte GetPlatformType(HttpContextAdapter ctx)
        {
            // Find out what sort of machine the client is. Each platform type has
            // its own range of ids so that's easy to figure out. The only trick is
            // that an Xbox 360 running in backcompat mode should be treated as an
            // Xbox 1.

            if(IsSgInfoSourceInternal)
            {
                string h = null;
                try
                {
                    if (ctx != null)
                    {
                        h = ctx.Request.Headers[XHttpHdr.XPLT];
                    }
                } catch (Exception) {}

                if (h == null)
                {
                    // generic bucket
                    return XOn.XPLT_INTERNAL;
                }
                // Expected to be: XPLT_INTERNAL_*
                byte plat = byte.Parse(h);
                return plat;
            }
            else if((this.AuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) != 0)
            {
                return XOn.XPLT_XBOX1;
            }
            else
            {
                try
                {
                    return XOn.XboxId.GetPlatformType(this.MachineId);
                }
                catch (Exception e)
                {
                    throw new Exception(
                        string.Format("Invalid platform type. Machine-id=0x{0}, Flags=0x{1}",
                                  this.MachineId,
                                  this.AuthDataFlags), e);
                }
            }
        }

        // IsXbox360
        // Returns whether the client is Xbox360
        public bool _IsXbox360()
        {
            return GetPlatformType() == XOn.XPLT_XBOX360;
        }

        // IsXbox
        // Returns whether the client is an original Xbox
        public bool _IsXbox()
        {
            return GetPlatformType() == XOn.XPLT_XBOX1;
        }

        // IsPc
        // Returns whether the client is a PC (Panorama)
        public bool _IsPc()
        {
            return GetPlatformType() == XOn.XPLT_PC;
        }

        public static void VerifyPlatformType(params byte[] xplts)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            byte xpltFromSg = sg.GetPlatformType();
            if (!Array.Exists(xplts, delegate(byte b) { return b == xpltFromSg; }))
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_10,
                    String.Format(
                    EnumerableFormatter.Instance,
                    "SGInfo.Verify: None of the platform types in {0:ef} can be verified (SG says {1}).",
                    xplts, xpltFromSg));
            }
        }

        // IsInternal
        // Returns whether the client is internal (cross-service communication, webcache,
        // etc.)
        public bool _IsInternal()
        {
            byte plat = GetPlatformType();
            return
                plat == XOn.XPLT_INTERNAL ||
                plat == XOn.XPLT_INTERNAL_XBOXCOM ||
                plat == XOn.XPLT_INTERNAL_ZUNE ||
                plat == XOn.XPLT_INTERNAL_XNA ||
                plat == XOn.XPLT_INTERNAL_WGX ||
                plat == XOn.XPLT_INTERNAL_LIVEN;
        }

        // IsFromLiveCache
        // Returns whether the is being made through LiveCache.
        public bool _IsFromLiveCache()
        {
            byte plat = GetPlatformType();
            return
                plat == XOn.XPLT_INTERNAL_XBOXCOM ||
                plat == XOn.XPLT_INTERNAL_ZUNE ||
                plat == XOn.XPLT_INTERNAL_XNA ||
                plat == XOn.XPLT_INTERNAL_WGX ||
                plat == XOn.XPLT_INTERNAL_LIVEN;
        }

        // IsLimited
        // Returns whether the client is marked with the Limited Machine flag
        public bool _IsLimited()
        {
            return ((this.AuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE) != 0);
        }

        // IsBeta
        // Returns whether the client has the beta bit set
        public bool _IsBeta()
        {
            return ((this.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE) != 0);
        }

        public byte[] SignWithKey( byte[] data, int offset, int count )
        {
            HMACSHA1 shaM = new HMACSHA1(key);

            shaM.ComputeHash(data, offset, count);

            return shaM.Hash;
        }

        //
        // Set of public functions to perform verification on users, machines, and titles.
        //  All of these functions will throw exceptions if data doesn't match.
        //

        public static void VerifyMachineId(ulong machineId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( sg.MachineId != machineId )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_3, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verified "
                    + "(SG says " + sg.MachineId.ToString("X") + ")");
            }
        }

        public void VerifyMachineId2(ulong machineId)
        {
            if (AuthToggle.Off)
                return;

            if( this.MachineId != machineId )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_61, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verified "
                    + "(SG says " + this.MachineId.ToString("X") + ")");
            }
        }

        public static void VerifyServiceId(XOService serviceId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsServicePresent(serviceId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_4, "SGInfo.Verify: Machine " + sg.MachineId.ToString("X") +
                    " is not supposed to have access to this service ("+ (int)serviceId + ")");
            }
        }

        public static void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( titleId != sg.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_5, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") cannot be verified [" + "machine " + sg.MachineId.ToString("X") + "]");
            }
        }

        public void VerifyTitleId2(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            if( titleId != this.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_64, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + this.TitleId.ToString("X")
                    + ") cannot be verified [" + "machine " + this.MachineId.ToString("X") + "]");
            }
        }

        // Returns true if the title id in the authdata is the title id of either
        // xbox dashboard, xenon dashboard or xbox.com
        public static bool IsDashboardTitleId()
        {
            if(AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            if(sg.TitleId == XOn.DASH_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) != 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_65, string.Format(
                        "Detected xbox dashboard title id running on a xenon console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.XENON_DASH_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_66, string.Format(
                        "Detected xenon dashboard title id running on a xbox console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.XENON_LIVE_SIGNUP_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_67, string.Format(
                        "Detected Xenon Live Signup title id running on an Xbox console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.WEB_TITLE_ID)
            {
                return true;
            }

            return false;
        }

        // Returns true if the title id in the authdata is the title id of xbox.com or zune.net
        public static bool IsWebTitleId()
        {
            if(AuthToggle.Off)
                return true;

            return (SGInfo.Current.TitleId == XOn.WEB_TITLE_ID || SGInfo.Current.TitleId == XOn.ZUNE_TITLE_ID);
        }

        // IsXbox360
        // Returns whether the client is Xbox360
        public static bool IsXbox360()
        {
            return SGInfo.Current._IsXbox360();
        }

        // IsXbox
        // Returns whether the client is an original Xbox
        public static bool IsXbox()
        {
            return SGInfo.Current._IsXbox();
        }

        // IsPc
        // Returns whether the client is a PC (Panorama)
        public static bool IsPc()
        {
            return SGInfo.Current._IsPc();
        }

        // IsInternal
        // Returns whether the client is internal (cross-service communication, webcache,
        // etc.)
        public static bool IsInternal()
        {
            return SGInfo.Current._IsInternal();
        }

        // IsFromLiveCache
        // Returns whether the call is being made through LiveCache.
        public static bool IsFromLiveCache()
        {
            return SGInfo.Current._IsFromLiveCache();
        }

        // IsLimited
        // Returns whether the client is marked with the Limited Machine flag
        public static bool IsLimited()
        {
            return SGInfo.Current._IsLimited();
        }

        // IsBeta
        // Returns whether the client is marked with the Beta Machine flag
        public static bool IsBeta()
        {
            return SGInfo.Current._IsBeta();
        }

        // IsActiveAuth
        // Returns whether this client came from the ActiveAuth module / gateway. If so,
        // SGInfo really doesn't apply, and you should be using AAInfo instead.
        public static bool IsActiveAuth()
        {
            // 1. Check context (from aamodule on local machine).
            // 2. Check headers (from authsg remotely).
            return AAInfo.IsActiveAuthAvailable;
        }

        // PlatformType
        // Returns the client's platform type. Returns one of the XOn.XPLT_* constants.
        public static byte GetPlatform()
        {
            return SGInfo.Current.GetPlatformType();
        }

        // VerifyDashboardTitleId
        // This method started out just checking the title-id but at some point it
        // started doing way more stuff. Its core goal remains, which is to restrict
        // access to account management / PII / billing APIs.
        public static void VerifyDashboardTitleId()
        {
            if(IsXbox() && IsDashboardTitleId())
            {
                // Original Xbox can only access using dashboard title id
                return;
            }

            if(IsXbox360() || IsInternal())
            {
                // Xbox 360 and internal calls have access using whatever title-id.
                // Original comment for historical purposes:
                // Xenon calls lots of account/marketplace SPIs from the HUD which uses
                // the "identity" of whatever title id it's running under. And this check
                // is breaking a bunch of scenarios. We could just remove the check from
                // all of those SPIs except that some of them are also called by Xbox and
                // we've got more confidence on xenon's security than we have on xbox's.
                // Not that this check is going to prevent much, it was more a kind of
                // assert for us anyways.
                return;
            }

            if(IsPc() && Config.GetBoolSetting(Setting.global_enableTestApis))
            {
                // PCs have access only if test APIs are enabled globally
                return;
            }

            // Access is denied to any other configuration

            throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_68, string.Format(
                    "SGInfo.VerifyDashboardTitleId: Access denied to title-id (0x{0}) / "+
                    "platform ({1}) configuration.",
                    SGInfo.Current.TitleId.ToString("X8"), SGInfo.GetPlatform().ToString()));
        }

        // Verifies if the title id in the authdata is the title id of xbox.com
        // Throws an exception if not
        public static void VerifyWebTitleId()
        {
            if(!IsWebTitleId())
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_69, string.Format(
                    "SGInfo.VerifyDashboardTitleId: xbox.com title Id expected. Instead we got: 0x{0}",
                    SGInfo.Current.TitleId.ToString("X8")));
            }
        }

        public static void VerifyFamilyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if((titleId & XOn.TITLE_FAMILY_MASK) != (sg.TitleId & XOn.TITLE_FAMILY_MASK))
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_70, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") is not in the same family!");
            }
        }


        public static void VerifyTitleIdOrAlternate(uint titleId)
        {
            if (AuthToggle.Off)
            {
                return;
            }

            SGInfo sg = SGInfo.Current;

            if( titleId == sg.TitleId )
            {
                return;
            }

            for (int i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                if (titleId == sg.dwAltTitleID[i])
                {
                    return;
                }
            }

            throw new XRLException(HResult.XONLINE_E_INVALID_TITLE_ID, XEvent.Id.AUTHDATA_VERIFICATION_ERROR_6, "SGInfo.VerifyTitleIdOrAlternate: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                + "," + sg.dwAltTitleID[0].ToString("X")
                + "," + sg.dwAltTitleID[1].ToString("X")
                + "," + sg.dwAltTitleID[2].ToString("X")
                + "," + sg.dwAltTitleID[3].ToString("X")
                + ") cannot be verified [" + "machine " + sg.MachineId.ToString("X") + "]");
        }

        public void VerifyTitleIdOrAlternate2(uint titleId)
        {
            if (AuthToggle.Off)
            {
                return;
            }

            if( titleId == this.TitleId )
            {
                return;
            }

            for (int i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                if (titleId == this.dwAltTitleID[i])
                {
                    return;
                }
            }

            throw new XRLException(HResult.XONLINE_E_INVALID_TITLE_ID, XEvent.Id.COMMON_HACK_72, "SGInfo.VerifyTitleIdOrAlternate: Title ID *" + titleId.ToString("X") + "* (SG says " + this.TitleId.ToString("X")
                + "," + this.dwAltTitleID[0].ToString("X")
                + "," + this.dwAltTitleID[1].ToString("X")
                + "," + this.dwAltTitleID[2].ToString("X")
                + "," + this.dwAltTitleID[3].ToString("X")
                + ") cannot be verified [" + "machine " + this.MachineId.ToString("X") + "]");
        }

        public static void VerifyTitleVersion(uint titleVersion)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            // only applies to test environments when your sginfo version is 0xFFFFFFFF.
            // This is the special and hopefully temporary hack for the NULL cipher
            // scenarios.
            if (!_verifyTestTitleVersion && sg.TitleVersion == 0xFFFFFFFF)
            {
                return;
            }

            if( titleVersion != sg.TitleVersion )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_7, "SGInfo.Verify: Title Version *" + titleVersion.ToString("x") + "* (SG says " + sg.TitleVersion.ToString("x")
                    + ") cannot be verified [" + "machine " + sg.MachineId + "]");
            }
        }

        public static void VerifyUserId(ulong xuid)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsUserPresent(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_8, "SGInfo.Verify: *User " + xuid.ToString("X") + "* cannot be verified ["
                    + "machine " + sg.MachineId.ToString("X") + "; title " + sg.TitleId.ToString("X") + "]");
            }
        }

        public static void VerifyUserCountryId(ulong xuid, byte countryId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( countryId != sg.GetUserCountry(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_9,
                    "SGInfo.Verify: User country (" + xuid.ToString("x") +
                    ";" + countryId + ") cannot be verified [countryId " +
                    sg.GetUserCountry(xuid) + "]");
            }
        }

        public static void VerifyUserTier(ulong xuid, byte tier)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( tier != sg.GetUserTier(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_76,
                    "SGInfo.Verify: User tier (" + xuid.ToString("x") +
                    ";" + tier + ") cannot be verified [tier " +
                    sg.GetUserTier(xuid) + "]");
            }
        }


        public static void VerifyPrivilege(params byte[] privileges)
        {
            foreach (byte privilege in privileges)
            {
                if (! HasPrivilege(privilege))
                {
                    SGInfo sg = SGInfo.Current;

                    throw new XRLException(
                        HResult.XONLINE_E_ACCESS_DENIED, XEvent.Id.SGINFO_VERIFY_PRIVILEGE,
                        "SGInfo.Verify: User privilege *" + privilege.ToString() + "* cannot be verified, " +
                        "[ machine " + sg.MachineId.ToString("X") + "]"
                    );
                }
            }
        }

        public static void VerifyPrivilege(ulong xuid, params byte[] privileges)
        {
            foreach (byte privilege in privileges)
            {
                if (! HasPrivilege(xuid, privilege))
                {
                    SGInfo sg = SGInfo.Current;

                    throw new XRLException(
                        HResult.XONLINE_E_ACCESS_DENIED, XEvent.Id.SGINFO_VERIFY_PRIVILEGE,
                        "SGInfo.Verify: User privilege *" + privilege.ToString() + "* cannot be verified, " +
                        "[ user " + xuid.ToString("x") +"] " +
                        "[ machine " + sg.MachineId.ToString("X") + "]"
                    );
                }
            }

        }

        public static bool HasPrivilege(byte priv)
        {
            if (AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            return sg.IsPrivilegePresent((int)priv);
        }

        public static bool HasPrivilege(ulong xuid, byte priv)
        {
            if (AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            return sg.IsPrivilegePresent(xuid, (int)priv);
        }

        // GetUserLocaleList
        // Returns a list of locales for a user sorted by priority. If
        // useUserLanguage==true, the user's live language will be considered
        // and given priority to.
        public static string[] GetUserLocaleList(ulong xuid, bool useUserLanguage)
        {
            string[] list = null;

            try
            {
                if (AuthToggle.Off)
                {
                    return null;
                }

                return SGInfo.Current.GetUserLocaleList2(xuid, useUserLanguage);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CODE_58, e, "Attempt to build locale threw exception.");
                list = null;
            }

            return list;
        }

        public string[] GetUserLocaleList2(ulong xuid, bool useUserLanguage)
        {
            string[] list = null;

            try
            {
                if (AuthToggle.Off)
                {
                    return null;
                }

                byte    countryId           = xuid != 0 ? this.GetUserCountry(xuid) : (byte)0;
                ushort  userLanguageId      = xuid != 0 ? this.GetUserLanguage(xuid) : (ushort)0;
                ushort  consoleLanguageId   = this.LanguageID;
                string  countryCode         = CountryDictionary.CountryCode(countryId);

                // User language takes precedent over console language
                list = Locale.BuildValidLocaleList(
                    useUserLanguage ? userLanguageId : consoleLanguageId,
                    consoleLanguageId,
                    countryCode);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CODE_59, e, "Attempt to build locale threw exception.");
                list = null;
            }

            return list;
        }

        // GetPrimaryUserLocale
        // Get a locale string based on the user's country, the console's
        // language and optionally on the user's language (stored on live)
        public string GetPrimaryUserLocale()
        {
            string[] list;

            list = GetUserLocaleList2(PrimaryUserXuid, true);

            if ( (null == list) || (list.Length == 0) )
            {
                return "en-US";  // @@@ Which default?  "en-US" or String.Empty?
            }

            return list[0];
        }


        public static bool IsGuestXuid(ulong xuid)
        {
            return (xuid >= XONLINE_GUEST_XUID_START && xuid <= XONLINE_GUEST_XUID_END);
        }


        public static string ToStr()
        {
            try
            {
                return Current != null ? Current.ToString() : "(sgauth=off)";
            }
            catch(Exception e)
            {
                return "Error from SGInfo.ToString(). Exception:\n"+e.ToString();
            }
        }

        public byte[] ConstructAuthData()
        {
            return ConstructAuthData(wAuthDataVersion);
        }

        protected byte[] ConstructAuthData(ushort authdataVersion)
        {
            MemoryStream m      = new MemoryStream(300);
            BinaryWriter writer = new BinaryWriter(m);

            // Construct either a V3 or V4 authdata response based
            // upon what authdata we were passed
            if (authdataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
            {
                WriteXenonV2SgInfo( writer );
            }
            else
            {
                WriteXenonSgInfo( writer );
            }
            return m.ToArray();
        }

        public static string ToBase64String()
        {
            SGInfo sg;
            if (AuthToggle.Off)
            {
                //return "Auth Data is turned off!";
                sg = new SGInfo(0, 0, 0);
            }
            else
            {
                sg = SGInfo.Current;
            }

            return sg.ConstructBase64String();
        }

        public string ConstructBase64String()
        {
            MemoryStream m = new MemoryStream(400);
            BinaryWriter w = new BinaryWriter(m);
            w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
            w.Write(_ipportI);
            w.Write(_ipaI);
            w.Write(_liNonce);

            // Always do v3 for back-compat purposes
            w.Write(ConstructAuthData(XONLINE_XENON_AUTHDATA_VERSION));

            // Append the differential to the end for modern consumers
            if (_supportedHttpAuthDataVersion > XONLINE_XENON_AUTHDATA_VERSION)
            {
                if (wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
                {
                    WriteAuthDataV4V3Diff(w);
                }
            }

            return Convert.ToBase64String(m.ToArray());
        }

        public ushort OverrideMajorVersion
        {
            get { return wMajorVersion; }
            set { wMajorVersion = value; }
        }

        public ushort OverrideMinorVersion
        {
            get { return wMinorVersion; }
            set { wMinorVersion = value; }
        }

        public ushort OverrideBuildNumber
        {
            get { return wBuildNumber; }
            set { wBuildNumber = value; }
        }

        public ushort OverrideQFENumber
        {
            get { return wQFENumber; }
            set { wQFENumber = value; }
        }


        public uint OverrideTitleID
        {
            get { return dwTitleID; }
            set { dwTitleID = value; }
        }

        public uint OverrideTitleVersion
        {
            get { return dwTitleVersion; }
            set { dwTitleVersion = value; }
        }

        public uint OverrideTitleRegion
        {
            get { return dwTitleRegion; }
            set { dwTitleRegion = value; }
        }

        public uint OverrideConsoleRegion
        {
            get { return dwConsoleRegion; }
            set { dwConsoleRegion = value; }
        }

        public uint OverrideMediaID
        {
            get { return dwMediaID; }
            set { dwMediaID = value; }
        }

        public ushort OverrideLanguageID
        {
            get { return wLanguageID; }
            set { wLanguageID = value; }
        }

        public uint OverrideAuthDataFlags
        {
            get { return dwAuthDataFlags; }
            set { dwAuthDataFlags = value; }
        }

        public ushort OverrideNumPrivileges
        {
            get { return wNumPrivileges; }
            set { wNumPrivileges = value; }
        }

        public uint[] OverridePrivileges
        {
            get { return dwPrivileges; }
            set { dwPrivileges = value; }
        }

        public uint[,] OverrideUserPrivileges
        {
            get { return dwUserPrivileges; }
            set { dwUserPrivileges = value; }
        }

        public ulong OverrideXboxID
        {
            get { return qwXboxID; }
            set { qwXboxID = value; }
        }

        public byte[] OverrideKey
        {
            get { return key; }
            set { key = value; }
        }

        public uint[] OverrideAltTitleID
        {
            get { return dwAltTitleID; }
            set { dwAltTitleID = value; }
        }

        public XUIDAndTrust[] OverrideXUsers
        {
            get { return xUsers; }
            set { xUsers = value; }
        }

        public uint[] OverrideServiceIds
        {
            get { return dwServiceIds; }
            set { dwServiceIds = value; }
        }

        public float OverrideConsoleTrustRating
        {
            get { return fltConsoleTrustRating; }
            set { fltConsoleTrustRating = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\TitleId.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace STF.common.service
{
    [ComVisible(false)]
    [XmlSchemaProvider("TitleIdSchema")]
    [WireInfo(SerializeAs = typeof(uint))]
    public partial struct TitleId : IEquatable<TitleId>, IXmlSerializable
    {
        private uint _value;

        private TitleId(uint value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X08");
        }

        public static implicit operator TitleId(uint value)
        {
            return new TitleId(value);
        }

        public static implicit operator uint(TitleId titleId)
        {
            // convert a TitleId to uint
            return titleId._value;
        }

        #region IEquatable<TitleId> Members

        public bool Equals(TitleId other)
        {
            return _value == other._value;
        }

        #endregion

        public static TitleId Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new TitleId(Convert.ToUInt32(s, 16));
        }

        public static bool TryParse(string s, out TitleId titleId)
        {
            try
            {
                titleId = TitleId.Parse(s);
                return true;
            }
            catch
            {
                titleId = new TitleId(0);
                return false;
            }
        }           
        #region IXmlSerializable Members

        public void ReadXml(XmlReader reader)
        {
            _value = (uint) XmlConvert.ToUInt32(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion

        public static XmlQualifiedName TitleIdSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedInt", XmlSchema.Namespace);
        }

        public ushort PublisherID
        {
            get { return (ushort)(_value >> 16); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\statsprot.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections;
using STF.common.service;
using STF.common.mgmt;

namespace STF.common.protocol
{
    public class ProtocolConstant
    {
        public const uint   MaxNicknameLength = 31;
        public const uint   MaxSpecsPerRequest = 101;
        public const uint   MaxSpecsPerSetDataRequest = 20;
        public const uint   MaxAttrPerSpec = 64;
        public const uint   MaxAttrPerUnitSpec = 70;
        public const string AttachStorageDomain = "Stats";

        // BUGBUG: review V2 protocol parameters:
        public const uint   MaxProcedureCount = 1000;
        public const uint   MaxUtf8StringParamSize = 1024;
        public const uint   MaxStatPostParamCount = 256;
        public const uint   MaxStatUnitGetSpecs   = 5;
        public const uint   MaxStatUnitEnumEntries = 100;
    }

    // Reserved attribute ids for special types of stats
    public class SpecialAttrib
    {
        public const ushort Rank                = 0xFFFF;
        public const ushort Rating              = 0xFFFE;
        public const ushort Nickname            = 0xFFFD;
        public const ushort LeaderboardSize     = 0xFFFC;
        public const ushort AttachmentPathName  = 0xFFFB;
        public const ushort AttachmentSize      = 0xFFFA;
        public const ushort UnitActivity        = 0xFFF9;
        public const ushort UnitLastPlayedDate  = 0xFFF8;

        // MuSigma attributes
        public const ushort Skill               = 61;
        public const ushort GamesPlayed         = 62;
        public const ushort Mu                  = 63;
        public const ushort Sigma               = 64;
    }

    public class StatParam
    {
        public const byte Null         = 0;
        public const byte Int8         = 1;
        public const byte Int16        = 2;
        public const byte Int32        = 3;
        public const byte Int64        = 4;
        public const byte Float        = 5;
        public const byte Utf8string   = 6;
        public const byte Puid         = 7;

        static public byte MapFromAttrType(AttrType attrType)
        {
            byte statParamType = 0;

            switch (attrType)
            {
                case AttrType.None:
                    statParamType = StatParam.Null;
                    break;

                case AttrType.Long:
                    statParamType = StatParam.Int32;
                    break;

                case AttrType.LongLong:
                    statParamType = StatParam.Int64;
                    break;

                case AttrType.Double:
                    statParamType = StatParam.Float;
                    break;

                case AttrType.String:
                    statParamType = StatParam.Utf8string;
                    break;

                default:
                    throw new Exception("Invalid AttrType " + attrType.ToString() + " to StatParam");
            }

            return statParamType;
        }

        static public AttrType MapToAttrType(byte statParamType)
        {
            AttrType attrType = AttrType.None;

            switch (statParamType)
            {
                case StatParam.Null:
                    attrType = AttrType.None;
                    break;

                case StatParam.Int8:
                case StatParam.Int16:
                case StatParam.Int32:
                    attrType = AttrType.Long;
                    break;

                case StatParam.Puid:
                case StatParam.Int64:
                    attrType = AttrType.LongLong;
                    break;

                case StatParam.Float:
                    attrType = AttrType.Double;
                    break;

                case StatParam.Utf8string:
                    attrType = AttrType.String;
                    break;

                default:
                    throw new Exception("Invalid StatParam " + statParamType.ToString() + " to AttrType");
            }

            return attrType;
        }
    }

    public class StatPostProcedure
    {
        public const ushort Replace     = 0x8001;
        public const ushort ReplaceUnit = 0x8002;
        public const ushort Add         = 0x8003;
        public const ushort AddUnit     = 0x8004;
        public const ushort Elo         = 0x8005;
        public const ushort EloUnit     = 0x8006;
        public const ushort If          = 0x8007;
        public const ushort IfUnit      = 0x8008;
        public const ushort Min         = 0x8009;
        public const ushort MinUnit     = 0x800A;
        public const ushort Max         = 0x800B;
        public const ushort MaxUnit     = 0x800C;
        public const ushort MuSigma     = 0x800D;
        public const ushort MuSigmaEx   = 0x800E;
    }

    public class StatPostIfComparisonType
    {
        public const byte Equal             = 1;
        public const byte Greater           = 2;
        public const byte GreaterOrEqual    = 3;
        public const byte Less              = 4;
        public const byte LessOrEqual       = 5;
        public const byte Exist             = 6;
        public const byte NotExist          = 7;
        public const byte NotEqual          = 8;
    }

    public class UnitEnumFlags
    {
        public const uint   SortActivity = 1;
        public const uint   SortRating   = 2;
        //public const uint   NoTags       = 4; // BUGBUG: implement this back someday
    }

    // Attribute types
    public enum AttrType
    {
        None        = 0,
        Long        = 1,
        LongLong    = 2,
        Double      = 3,
        String      = 4
    }

    /// <summary>
    /// StatLbIdParser
    /// </summary>
    /// <remarks>
    /// Leaderboard ID parser helper class
    /// </remarks>
    public class StatLbIdParser
    {
        public const int MaxCompetitionPartitions = 4;
        public const uint PartitionMask           = 0xC0000000;
        public const uint TemplateMask            = 0x3C000000;
        public const uint CompetitionMask         = PartitionMask | TemplateMask;
        public const int  TemplateShift           = 26;
        public const int  PartitionShift          = 30;
        public const uint SkillMask               = 0x02000000;

        public const uint SkillModeMask           = 0x0000ffff;
        public const uint SkillTypeMask           = 0xffff0000;

        public const uint SkillTypeRanked         = 0xffff0000;
        public const uint SkillTypeStandard       = 0xfffe0000;


        static public bool IsCompetition(uint uiLbId)
        {
            return ((uiLbId & CompetitionMask) != 0) && !IsSkill(uiLbId);
        }

        static public bool IsSkill(uint uiLbId)
        {
            return ((uiLbId & SkillMask) != 0);
        }

        static public bool IsRankedSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeRanked);
        }
        static public bool IsStandardSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeStandard);
        }
        static public uint GetGameModeId(uint uiLbId)
        {
            return (uiLbId & SkillModeMask);
        }

        static public byte GetPartition(uint uiLbId)
        {
            return (byte)((uiLbId & PartitionMask) >> PartitionShift);
        }

        static public uint GetTemplateId(uint uiLbId)
        {
            return (uiLbId & TemplateMask) >> TemplateShift;
        }

    }

    #region Stats/Leaderboard V1 (XBOX) Protocol

    /// <summary>
    /// MsgSetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Count of attributes</param>
    /// <param name="Attribs">Attribute data message</param>
    /// <returns>
    /// RepSetDataCanUploadAtt for S_CAN_UPLOAD_ATT
    /// </returns>
    public class MsgSetData
    {
        public uint             _uiTitleId;     // Title Id
        public ulong            _ulUserId;      // User PUID
        public uint             _uiLbId;        // Leaderboard Id
        public uint             _uiAttrCount;   // Attribute count
        public MsgAttribData[]  _attribs;       // Attributes. Number of objects is _uiAttrCount

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _ulUserId       = reader.ReadUInt64();

            if(_ulUserId == 0)
                throw new Exception("_ulUserId cannot be zero.");

            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount cannot be zero.");

            if(_uiAttrCount > ProtocolConstant.MaxAttrPerSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST,
                    "_uiAttrCount ("+_uiAttrCount+") > " + ProtocolConstant.MaxAttrPerSpec);

            _attribs        = new MsgAttribData[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attribs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataCanUploadAtt
    /// </summary>
    /// <param name="AccessToken">Storage access token</param>
    /// <param name="RefCount">Count of objects in Refs</param>
    /// <param name="Refs">Leaderboard/User pairs</param>
    /// <remarks>
    /// Response object with a storage access token that allows an attachment to be uploaded
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataCanUploadAtt
    {
        public WriteFileToken   _accessToken;               // Storage access token
        public ushort                   _usRefCount;        // # of objects in _refs
        public RepSetDataReference[]    _refs;              // Lb/User pairs that will have a reference to this attachment. Size is _usRefCount

        public void WriteTo(BinaryWriter writer)
        {
            _usRefCount = (ushort) _refs.Length;

            _accessToken.WriteTo(writer);
            writer.Write(_usRefCount);
            foreach(RepSetDataReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _accessToken        = new WriteFileToken();
            _accessToken.ReadFrom(reader);
            _usRefCount         = reader.ReadUInt16();
            _refs               = new RepSetDataReference[_usRefCount];
            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new RepSetDataReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_accessToken: " + _accessToken.ToString() +
                "\n_usRefCount=" + _usRefCount);

            for(int ndx=0; ndx < _usRefCount; ndx++)
            {
                str.Append("\n " + ndx + ":" + _refs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataReference
    /// </summary>
    /// <param name="Lb">Leaderboard id</param>
    /// <param name="User">User PUID</param>
    /// <remarks>
    /// Attachment part of RepSetDataCanUploadAtt
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataReference
    {
        public uint     _uiLb;      // Leaderboard Id
        public ulong    _ulUser;    // User PUID

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return string.Format("_uiLb={0} _ulUser=0x{1}", _uiLb, _ulUser);
        }
    }

    /// <summary>
    /// ReqGetData
    /// </summary>
    /// <param name="Messages">Request messages</param>
    /// <returns>RepGetData response</returns>
    /// <remarks>
    /// Reads data from leaderboard server as described in the request messages
    /// </remarks>
    public class ReqGetData
    {
        public MsgGetData[]    _messages;

        public void ReadFrom(BinaryReader reader)
        {
            ArrayList messages = new ArrayList((int)ProtocolConstant.MaxSpecsPerRequest);

            try
            {
                while(true)
                {
                    MsgGetData newMsg = new MsgGetData();
                    newMsg.ReadFrom(reader);

                    if(messages.Count == ProtocolConstant.MaxSpecsPerRequest)
                        throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, XEvent.Id.XSTATSFD_INVALID_REQUEST_1,
                            "Too many specs in request");
                        // BUGBUG: hr=HResult.XONLINE_E_STAT_TOO_MANY_SPECS
                        
                    messages.Add(newMsg);
                }
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            if(messages.Count == 0)
                throw new Exception("Request cannot be empty.");

            _messages = (MsgGetData[]) messages.ToArray(typeof(MsgGetData));
        }

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgGetData msg in _messages)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _messages.Length; ndx++)
            {
                str.Append(_messages[ndx]);
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// MsgGetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Attribute count</param>
    /// <param name="AttrIds">Array of attribute ids (size==AttrCount)</param>
    /// <remarks>
    /// Leaderboard query message.  Specifies title, leaderboard, and attributes to retrieve.
    /// </remarks>
    public class MsgGetData
    {
        public uint     _uiTitleId;     // Title Id
        public ulong    _ulUserId;      // User PUID
        public uint     _uiLbId;        // Leaderboard Id
        public uint     _uiAttrCount;   // Attribute Count
        public ushort[] _attrIds;       // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            try
            {
                _uiTitleId      = reader.ReadUInt32();
            }
            catch (EndOfStreamException)
            {
                //only the first element following a previous peekchar
                throw new PeekCharEndOfStreamException();
            }
            
            _ulUserId       = reader.ReadUInt64();
            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount is zero.");

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_2,
                    "_uiAttrCount (" +_uiAttrCount+" > " + ProtocolConstant.MaxAttrPerSpec);

            _attrIds = new ushort[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attrIds.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepGetData
    public class RepGetData
    {
        public MsgRepGetData[] _reps = null;

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgRepGetData msg in _reps)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _reps.Length; ndx++)
            {
                str.Append(_reps[ndx]);
            }

            return str.ToString();
        }
    }

    // MsgRepGetData
    // GetData reply
    public class MsgRepGetData
    {
        public ulong            _ulUserId;  // User PUID
        public uint             _uiLbId;    // Leaderboard Id
        public MsgAttribData[]  _attribs;   // Attributes

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            foreach(MsgAttribData attribData in _attribs)
            {
                attribData.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _ulUserId   = reader.ReadUInt64();
            _uiLbId     = reader.ReadUInt32();

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgEnumLB
    // Message Enumerate Leaderboard
    public class MsgEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size
        public uint     _uiAttrCount;           // Size of _attrIds
        public ushort[] _attrIds;               // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_3,
                    "Invalid MsgEnumLb. _uiAttrCount("+_uiAttrCount+") > ProtocolConstant.MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerSpec+")");
            }

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_HACK_33,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }

            _attrIds        = new ushort[_uiAttrCount];
            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
            writer.Write(_uiAttrCount);

            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepEnumLB
    // Reply to Enumerate Leaderboard
    public class RepEnumLB
    {
        public uint             _uiLbSize;
        public uint             _uiRepUserCount;
        public uint             _uiAttrPerUser;
        public RepEnumLBUser[]  _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _uiRepUserCount     = reader.ReadUInt32();
            _uiAttrPerUser      = reader.ReadUInt32();

            _users              = new RepEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepEnumLBUser((int)_uiAttrPerUser);
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_uiRepUserCount);
            writer.Write(_uiAttrPerUser);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbSize=" + _uiLbSize+
                "\n_uiRepUserCount=" + _uiRepUserCount+
                "\n_uiAttrPerUser=" + _uiAttrPerUser +
                "\n_users:\n");

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.Append("\n "+ndx+":" + _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepEnumLBUser
    {
        public RepEnumLBUser(int iAttrCount)
        {
            _attribs = new MsgAttribData[iAttrCount];
        }

        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bSizeXName;
        public byte             _bSizeNickname;
        public string           _xName;
        public string           _nickname;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bSizeXName         = reader.ReadByte();
            _bSizeNickname      = reader.ReadByte();

            byte [] arrByte     = reader.ReadBytes(_bSizeXName);
            if (arrByte.Length != (int)_bSizeXName)
                throw new Exception("Error - RepEnumLBUser:: Bytes Read is not equal _bSizeXName");

            _xName              = Encoding.UTF8.GetString(arrByte);
            _nickname           = Encoding.Unicode.GetString(reader.ReadBytes(_bSizeNickname));

            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encXName = Encoding.UTF8.GetBytes(_xName);
            _bSizeXName     = (byte) encXName.Length;

            byte[] encNick  = Encoding.Unicode.GetBytes(_nickname);
            _bSizeNickname  = (byte) encNick.Length;

            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bSizeXName);
            writer.Write(_bSizeNickname);
            writer.Write(encXName);
            writer.Write(encNick);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUser=0x" + _ulUser.ToString("x") +
                "\n_uiRank=" + _uiRank +
                "\n_lRating=" + _lRating +
                "\n_bSizeXName=" + _bSizeXName +
                "\n_bSizeNickname=" + _bSizeNickname +
                "\n_xName=" + _xName +
                "\n_nickname=" + _nickname +
                "\n_attribs=");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgAttribData
    // Attribute with data. Used in several messages.
    public class MsgAttribData
    {
        public ushort   _usAttrId;
        public byte     _bAttrType;
        public object   _value;

        public void ReadFrom(BinaryReader reader)
        {
            _usAttrId   = reader.ReadUInt16();
            _bAttrType  = reader.ReadByte();

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    _value = (object) reader.ReadInt32();
                    break;
                case AttrType.LongLong:
                    _value = (object) reader.ReadInt64();
                    break;
                case AttrType.Double:
                    _value = (object) reader.ReadDouble();
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte bNickSize = reader.ReadByte();
                        _value = (object) Encoding.Unicode.GetString(reader.ReadBytes(bNickSize));
                    }
                    else
                    {
                        ushort usSize = reader.ReadUInt16();
                        _value = (object) Encoding.UTF8.GetString(reader.ReadBytes(usSize));
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_usAttrId);
            writer.Write(_bAttrType);

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    writer.Write((int)_value);
                    break;
                case AttrType.LongLong:
                    writer.Write((long)_value);
                    break;
                case AttrType.Double:
                    writer.Write((double)_value);
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte[] nickbin = Encoding.Unicode.GetBytes((string)_value);
                        writer.Write((byte)nickbin.Length);
                        writer.Write(nickbin);
                    }
                    else
                    {
                        byte[] stringbin = Encoding.UTF8.GetBytes((string)_value);
                        writer.Write((ushort)stringbin.Length);
                        writer.Write(stringbin);
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public override string ToString()
        {
            return string.Format("_usAttrId={0} _bAttrType={1} _value={2}",
                _usAttrId, _bAttrType, (_value != null ? _value : "(null)"));
        }
    }

    // MsgReset
    // Reset message
    public class MsgReset
    {
        public uint titleId;
        public ulong userId;
        public uint leaderBoardType;
        public STF.common.protocol.TeamTickets _teamTickets = null;

        public void ReadFrom(BinaryReader reader)
        {
            titleId         = reader.ReadUInt32();
            userId          = reader.ReadUInt64();
            leaderBoardType = reader.ReadUInt32();

            try
            {
                _teamTickets = new STF.common.protocol.TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //This tells us there were no more data as peekchar would have told us
                //This is different than end of stream while in the middle of deserializing an object
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(titleId);
            writer.Write(userId);
            writer.Write(leaderBoardType);

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            return
                "\ntitleId=0x"+titleId.ToString("x")+
                "\nuserId=0x"+userId.ToString("x")+
                "\nleaderBoardType="+leaderBoardType+
                "\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)");
        }

        public string GetXRL()
        {
            return "/xstats/xstatsreset.ashx";
        }
    }

    // MsgCommitAttachment
    // CommitAttachment message.
    public class MsgCommitAttachment
    {
        public uint     _uiTitleId;
        public uint     _uiAttSize;
        public uint     _uiAttSizeUncomp;
        public ushort   _usSizePathName;
        public ushort   _usRefCount;
        public string   _pathName;
        public MsgCommitAttachmentReference[] _refs;

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encPathName  = Encoding.UTF8.GetBytes(_pathName);
            _usSizePathName     = (ushort) encPathName.Length;
            _usRefCount         = (ushort) _refs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_uiAttSize);
            writer.Write(_uiAttSizeUncomp);
            writer.Write(_usSizePathName);
            writer.Write(_usRefCount);
            writer.Write(encPathName);

            foreach(MsgCommitAttachmentReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiAttSize      = reader.ReadUInt32();
            _uiAttSizeUncomp= reader.ReadUInt32();
            _usSizePathName = reader.ReadUInt16();
            _usRefCount     = reader.ReadUInt16();

            if(_usRefCount > ProtocolConstant.MaxSpecsPerSetDataRequest)
                throw new Exception("_usRefCount("+_usRefCount+")>ProtocolConstant.MaxSpecsPerSetDataRequest("+ProtocolConstant.MaxSpecsPerSetDataRequest+")");

            _pathName       = Encoding.UTF8.GetString(reader.ReadBytes(_usSizePathName));
            _refs           = new MsgCommitAttachmentReference[_usRefCount];

            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new MsgCommitAttachmentReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            return
                " _uiTitleId:0x"+_uiTitleId.ToString("x")+
                " _uiAttSize:"+_uiAttSize+
                " _uiAttSizeUncomp:"+_uiAttSizeUncomp+
                " _usSizePathName:"+_usSizePathName+
                " _usRefCount:"+_usRefCount+
                " _pathName:"+_pathName+
                " _refs:"+MsgCommitAttachmentReference.ToString(_refs);
        }
    }

    // MsgCommitAttachmentReference
    // Attachment reference part of MsgCommitAttachment
    public class MsgCommitAttachmentReference
    {
        public uint     _uiLb;
        public ulong    _ulUser;

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return
                " _uiLb:"+_uiLb+
                " _ulUser:"+_ulUser;
        }

        public static string ToString(IList msgs)
        {
            StringBuilder str = new StringBuilder();
            foreach(MsgCommitAttachmentReference msg in msgs)
            {
                str.Append(msg.ToString());
            }
            return str.ToString();
        }
    }

    // MsgWebEnumLB
    // Message Web Enumerate Leaderboard
    public class MsgWebEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_HACK_34,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }


        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize;
        }
    }

    // RepWebEnumLB
    // Reply to Web Enumerate Leaderboard
    public class RepWebEnumLB
    {
        public uint                 _uiLbSize;
        public ulong                _ulLastResetTime;
        public uint                 _uiRepUserCount;
        public RepWebEnumLBUser[]   _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _ulLastResetTime    = reader.ReadUInt64();
            _uiRepUserCount     = reader.ReadUInt32();

            _users              = new RepWebEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepWebEnumLBUser();
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_ulLastResetTime);
            writer.Write(_uiRepUserCount);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_uiLbSize={0}"+
                "\n_ulLastResetTime={1}"+
                "\n_uiRepUserCount={2}" +
                "\n_users:\n",
                _uiLbSize,
                _ulLastResetTime,
                _uiRepUserCount);

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.AppendFormat("\n {0}:{1}", ndx.ToString(), _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepWebEnumLBUser
    {
        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bAttribCount;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bAttribCount       = reader.ReadByte();

            _attribs = new MsgAttribData[_bAttribCount];
            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bAttribCount);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_ulUser=0x{0}" +
                "\n_uiRank={1}" +
                "\n_lRating={2}" +
                "\n_attribs=",
                _ulUser.ToString("x"),
                _uiRank.ToString(),
                _lRating.ToString());

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // ReqRemoveAtt
    // Remove Attachment request
    public class MsgRemoveAtt
    {
        public ushort       _usSizeAttachPathName = 0;
        public string       _attachPathName       = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usSizeAttachPathName = reader.ReadUInt16();
            _attachPathName = Encoding.UTF8.GetString(reader.ReadBytes(_usSizeAttachPathName));
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encAttachPathName = Encoding.UTF8.GetBytes(_attachPathName);
            _usSizeAttachPathName = (ushort) encAttachPathName.Length;

            writer.Write(_usSizeAttachPathName);
            writer.Write(encAttachPathName);
        }

        public override string ToString()
        {
            return
                "\n_usSizeAttachPathName=" + _usSizeAttachPathName +
                "\n_attachPathName=" + _attachPathName != null ? _attachPathName : "(null)";
        }
    }

    // RepRemoveAtt
    public class RepRemoveAtt
    {
        public ushort   _usPuidCount    = 0;
        public ulong[]  _puids          = null;

        public void ReadFrom(BinaryReader br)
        {
            _usPuidCount = br.ReadUInt16();
            _puids = new ulong[_usPuidCount];

            for(int i=0; i < _puids.Length; i++)
            {
                _puids[i] = br.ReadUInt64();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usPuidCount = (ushort) _puids.Length;

            bw.Write(_usPuidCount);

            for(int i=0; i < _puids.Length; i++)
            {
                bw.Write(_puids[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usPuidCount=" + _usPuidCount +
                "\n_puids=");

            if(_puids != null)
            {
                for(int i=0; i < _puids.Length; i++)
                {
                    str.Append(" 0x"+_puids[i].ToString("x"));
                }
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// ReqStatPost
    /// </summary>
    /// <param name="TitleID">Title ID</param>
    /// <param name="ProcCount">Count of procedures</param>
    /// <param name="Procs">Procedure calls</param>
    /// <param name="TeamTickets">Team Tickets objects</param>
    /// <remarks>
    /// Supports running leaderboard operator procedures as defined in StatPostProcedure
    /// </remarks>
    public class ReqStatPost
    {
        public uint         _uiTitleId   = 0;
        public ushort       _usProcCount = 0;
        public MsgStatPostProcedureCall[] _procs = null;
        public STF.common.protocol.TeamTickets _teamTickets = null;

        public string GetXRL()
        {
            return "/xstats/statpost.ashx";
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _usProcCount    = reader.ReadUInt16();

            if(_usProcCount > ProtocolConstant.MaxProcedureCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, XEvent.Id.XSTATSFD_INVALID_REQUEST_4,
                    "Too many procedures (" + _usProcCount + ")");
            }

            _procs = new MsgStatPostProcedureCall[_usProcCount];
            for(ushort i=0; i < _procs.Length; i++)
            {
                _procs[i] = new MsgStatPostProcedureCall();
                _procs[i].ReadFrom(reader);
            }

            try
            {
                _teamTickets = new STF.common.protocol.TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }
            

            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_LOW, ToString());

        }

        public void WriteTo(BinaryWriter writer)
        {
            _usProcCount = (ushort) _procs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_usProcCount);

            for(ushort i=0; i < _usProcCount; i++)
            {
                _procs[i].WriteTo(writer);
            }

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId="+_uiTitleId+
                "\n_usProcCount="+_usProcCount+
                "\n_procs: ");

            if(_procs != null)
            {
                for(ushort i=0; i < _procs.Length; i++)
                {
                    str.Append(_procs[i].ToString());
                }
            }

            str.Append("\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }


    // MsgStatPostProcedureCall
    public class MsgStatPostProcedureCall
    {
        public ushort       _usProcId = 0;
        public ushort       _usParamCount = 0;
        public MsgStatPostParameter[] _params = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usProcId = reader.ReadUInt16();
            _usParamCount = reader.ReadUInt16();

            if(_usParamCount > ProtocolConstant.MaxStatPostParamCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PARAMETERS, XEvent.Id.XSTATSFD_INVALID_REQUEST_5,
                    "Procedure id: "+_usProcId+" has too many parameters ("+ _usParamCount +")");
            }

            _params = new MsgStatPostParameter[_usParamCount];

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i] = new MsgStatPostParameter();
                _params[i].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _usParamCount = (ushort) _params.Length;

            writer.Write(_usProcId);
            writer.Write(_usParamCount);

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usProcId="+_usProcId+
                "\n_usParamCount="+_usParamCount+
                "\n_params: ");

            if(_params != null)
            {
                for(ushort i=0; i < _params.Length; i++)
                {
                    // BUGBUG: add extra check on _param[i] != null. Repeat this on the rest of the file.
                    str.Append(_params[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgStatPostParameter
    public class MsgStatPostParameter
    {
        public byte         _bParamType = 0;
        public object       _data = null;

        public void ReadFrom(BinaryReader reader)
        {
            _bParamType = reader.ReadByte();

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    reader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) reader.ReadByte(); // BUGBUG: sign?
                    break;
                case StatParam.Int16:
                    _data = (object) reader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) reader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) reader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) reader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = reader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(reader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) reader.ReadUInt64();
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_bParamType);

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    writer.Write((byte)0);
                    break;
                case StatParam.Int8:
                    writer.Write((byte)_data);
                    break;
                case StatParam.Int16:
                    writer.Write((short)Convert.ToInt16(_data));
                    break;
                case StatParam.Int32:
                    writer.Write((int)_data);
                    break;
                case StatParam.Int64:
                    writer.Write((long)_data);
                    break;
                case StatParam.Float:
                    writer.Write((double)_data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string)_data);
                    writer.Write((ushort) encstring.Length);
                    writer.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    writer.Write((ulong)_data);
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public override string ToString()
        {
            return "("+_bParamType+")"+
                (_data == null ? "(null)" : _data.ToString()) + " ";
        }
    }

    // ReqStatUnitGet
    public class ReqStatUnitGet // BUGBUG: name doesn't match with reply's. words inverted.
    {
        public uint     _uiTitleId  = 0;
        public ulong    _ulPuid1    = 0;
        public ulong    _ulPuid2    = 0;
        public ulong    _ulPuid3    = 0;
        public ulong    _ulPuid4    = 0;
        public ushort   _usSpecCount= 0;
        public MsgUnitStatGetSpec[] _specs = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _ulPuid1    = br.ReadUInt64();
            _ulPuid2    = br.ReadUInt64();
            _ulPuid3    = br.ReadUInt64();
            _ulPuid4    = br.ReadUInt64();
            _usSpecCount= br.ReadUInt16();

            if(_usSpecCount > ProtocolConstant.MaxStatUnitGetSpecs)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, XEvent.Id.XSTATSFD_INVALID_REQUEST_6,
                    "_usSpecCount("+_usSpecCount+" > MaxStatUnitGetSpecs("+ProtocolConstant.MaxStatUnitGetSpecs+")");

            _specs = new MsgUnitStatGetSpec[_usSpecCount];
            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpec();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;

            bw.Write(_uiTitleId);
            bw.Write(_ulPuid1);
            bw.Write(_ulPuid2);
            bw.Write(_ulPuid3);
            bw.Write(_ulPuid4);
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+ _uiTitleId.ToString("x")+
                "\n_ulPuid1=0x" +  _ulPuid1.ToString("x")+
                "\n_ulPuid2=0x" +  _ulPuid2.ToString("x")+
                "\n_ulPuid3=0x" +  _ulPuid3.ToString("x")+
                "\n_ulPuid4=0x" +  _ulPuid4.ToString("x")+
                "\n_usSpecCount="+ _usSpecCount +
                "\n_specs:");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpec
    public class MsgUnitStatGetSpec
    {
        public uint         _uiLbId     = 0;
        public ushort       _usNumStats = 0;
        public ushort[]     _statIds    = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId     = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();

            if(_usNumStats > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_7,
                    "_usNumStats("+_usNumStats+" > MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerUnitSpec+")");

            _statIds = new ushort[_usNumStats];

            for(ushort i=0; i < _usNumStats; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _statIds.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "_uiLbId = " + _uiLbId +
                "_usNumStats = " + _usNumStats +
                "_statIds: ");

            if(_statIds != null)
            {
                for(int i=0; i < _statIds.Length; i++)
                {
                    str.Append(" "+i);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitStatGet
    public class RepUnitStatGet
    {
        public ushort                   _usSpecCount = 0;
        public MsgUnitStatGetSpecData[] _specs       = null;

        public void ReadFrom(BinaryReader br)
        {
            _usSpecCount = br.ReadUInt16();
            _specs = new MsgUnitStatGetSpecData[_usSpecCount];

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpecData();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usSpecCount="+_usSpecCount+
                "\n_specs: ");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpecData
    public class MsgUnitStatGetSpecData
    {
        public uint             _uiLbId;
        public ushort           _usNumStats;
        public MsgAttribData[]  _stats;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();
            _stats = new MsgAttribData[_usNumStats];
            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _stats.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbId="+_uiLbId+
                "\n_usNumStats="+_usNumStats+
                "\n_stats:");

            if(_stats != null)
            {
                for(int i=0; i < _stats.Length; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // ReqUnitEnum
    public class ReqUnitEnum
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public uint     _uiFlags        = 0;
        public ulong    _ulPuid         = 0;
        public ushort   _usPageSize     = 0;
        public ushort   _usStatCount    = 0;
        public ushort[] _statIds        = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
            _uiFlags        = br.ReadUInt32();

            if( (_uiFlags & UnitEnumFlags.SortActivity) != 0
                && (_uiFlags & UnitEnumFlags.SortRating) != 0 )
                throw new Exception("Invalid flags. SortActivity and SortRating flags are mutually exclusive.");

            if((_uiFlags & ~(UnitEnumFlags.SortActivity |
                           UnitEnumFlags.SortRating)) != 0)
            {
                throw new Exception("Invalid flags.");
            }

            _ulPuid         = br.ReadUInt64();
            _usPageSize     = br.ReadUInt16();

            if(_usPageSize == 0)
                throw new Exception("Error: _usPageSize is zero");

            _usStatCount    = br.ReadUInt16();

            if(_usStatCount > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_8,
                    "_usStatCount (" + _usStatCount + ") > MaxAttrPerSpec ("+
                    ProtocolConstant.MaxAttrPerUnitSpec + ")");

            _statIds        = new ushort[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usStatCount = (ushort) _statIds.Length;

            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_uiFlags);
            bw.Write(_ulPuid);
            bw.Write(_usPageSize);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+  _uiTitleId.ToString("x")+
                "\n_uiLbId="+       _uiLbId+
                "\n_uiFlags="+      _uiFlags+
                "\n_ulPuid=0x"+     _ulPuid.ToString("x")+
                "\n_usPageSize="+   _usPageSize+
                "\n_usStatCount="+  _usStatCount+
                "\n_statIds: ");

            if(_statIds != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    str.Append(" "+_statIds[i]);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitEnum
    public class RepUnitEnum
    {
        public ushort               _usNumEntries   = 0;
        public MsgUnitEnumEntry[]   _entries        = null;

        public void ReadFrom(BinaryReader br)
        {
            _usNumEntries = br.ReadUInt16();
            _entries = new MsgUnitEnumEntry[_usNumEntries];

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i] = new MsgUnitEnumEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumEntries = (ushort) _entries.Length;
            bw.Write(_usNumEntries);

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usNumEntries=" + _usNumEntries +
                "\n_entries: ");

            if(_entries != null)
            {
                for(ushort i=0; i < _entries.Length; i++)
                {
                    str.Append(_entries[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitEnumEntry
    public class MsgUnitEnumEntry
    {
        public ulong            _puid1          = 0;
        public ulong            _puid2          = 0;
        public ulong            _puid3          = 0;
        public ulong            _puid4          = 0;
        public ushort           _usSizeName1    = 0;
        public string           _name1          = String.Empty;
        public ushort           _usSizeName2    = 0;
        public string           _name2          = String.Empty;
        public ushort           _usSizeName3    = 0;
        public string           _name3          = String.Empty;
        public ushort           _usSizeName4    = 0;
        public string           _name4          = String.Empty;
        public ushort           _usStatCount    = 0;
        public MsgAttribData[]  _stats          = null;

        public void ReadFrom(BinaryReader br)
        {
            _puid1        = br.ReadUInt64();
            _puid2        = br.ReadUInt64();
            _puid3        = br.ReadUInt64();
            _puid4        = br.ReadUInt64();
            _usSizeName1  = br.ReadUInt16();
            _name1        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName1));
            _usSizeName2  = br.ReadUInt16();
            _name2        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName2));
            _usSizeName3  = br.ReadUInt16();
            _name3        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName3));
            _usSizeName4  = br.ReadUInt16();
            _name4        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName4));
            _usStatCount  = br.ReadUInt16();
            _stats        = new MsgAttribData[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] encName1 = Encoding.UTF8.GetBytes(_name1);
            _usSizeName1 = (ushort) encName1.Length;
            byte[] encName2 = Encoding.UTF8.GetBytes(_name2);
            _usSizeName2 = (ushort) encName2.Length;
            byte[] encName3 = Encoding.UTF8.GetBytes(_name3);
            _usSizeName3 = (ushort) encName3.Length;
            byte[] encName4 = Encoding.UTF8.GetBytes(_name4);
            _usSizeName4 = (ushort) encName4.Length;

            bw.Write(_puid1);
            bw.Write(_puid2);
            bw.Write(_puid3);
            bw.Write(_puid4);
            bw.Write(_usSizeName1);
            bw.Write(encName1);
            bw.Write(_usSizeName2);
            bw.Write(encName2);
            bw.Write(_usSizeName3);
            bw.Write(encName3);
            bw.Write(_usSizeName4);
            bw.Write(encName4);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_puid1=0x"+      _puid1.ToString("x")+
                "\n_puid2=0x"+      _puid2.ToString("x")+
                "\n_puid3=0x"+      _puid3.ToString("x")+
                "\n_puid4=0x"+      _puid4.ToString("x")+
                "\n_usSizeName1="+  _usSizeName1+
                "\n_name1="+        _name1+
                "\n_usSizeName2="+  _usSizeName2+
                "\n_name2="+        _name2+
                "\n_usSizeName3="+  _usSizeName3+
                "\n_name3="+        _name3+
                "\n_usSizeName4="+  _usSizeName4+
                "\n_name4="+        _name4+
                "\n_usStatCount="+  _usStatCount+
                "\n_stats: ");

            if(_stats != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    public class ReqCompCreateLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiTemplateId   = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiTemplateId   = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiTemplateId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiTemplateId: "+ _uiTemplateId;
        }
    }

    public class RepCompCreateLb
    {
        public uint     _uiLbId     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiLbId: 0x" + _uiLbId.ToString("x");
        }
    }

    public class ReqCompDeleteLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: "+ _uiLbId;
        }
    }

    public class ReqFindRating
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public long     _lRating        = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _uiLbId     = br.ReadUInt32();
            _lRating    = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: " + _uiLbId+
                "\n_lRating: " + _lRating;
        }
    }

    public class RepFindRating
    {
        public ulong    _ulPuid     = 0;
        public uint     _uiRank     = 0;
        public long     _lRating    = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
            _uiRank = br.ReadUInt32();
            _lRating = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
            bw.Write(_uiRank);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x")+
                "\n_uiRank: "+_uiRank+
                "\n_lRating: "+_lRating;
        }
    }

    public class ReqCertReset
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class ReqCertVerify
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class RepCertVerify
    {
        public ushort               _usEntryCount = 0;
        public MsgCertVerifyEntry[] _entries = null;

        public void ReadFrom(BinaryReader br)
        {
            _usEntryCount = br.ReadUInt16();
            _entries = new MsgCertVerifyEntry[_usEntryCount];
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i] = new MsgCertVerifyEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usEntryCount = (ushort) _entries.Length;
            bw.Write(_usEntryCount);
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usEntryCount:"+_usEntryCount+
                "\n_entries:");

            for(int i=0; i < _entries.Length; i++)
            {
                str.Append((_entries[i] != null ? _entries[i].ToString() : "(null)"));
            }

            return str.ToString();
        }
    }

    public class MsgCertVerifyEntry
    {
        public byte     _bLevel;
        public ushort   _usSizeDescription = 0;
        public string   _description;

        public void ReadFrom(BinaryReader br)
        {
            _bLevel = br.ReadByte();
            _usSizeDescription  = br.ReadUInt16();
            _description = Encoding.UTF8.GetString(br.ReadBytes((int)_usSizeDescription));
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] binDescription = Encoding.UTF8.GetBytes(_description);
            _usSizeDescription = (ushort) binDescription.Length;

            bw.Write(_bLevel);
            bw.Write(_usSizeDescription);
            bw.Write(binDescription);
        }
    }
    #endregion

    #region Stats/Leaderboard V2 (Xenon) Protocol

    /// <summary>
    /// StatsColumn
    /// </summary>
    /// <param name="ColumnId">Stats column id (usually ordinal)</param>
    /// <param name="Type">Stats column datatype</param>
    /// <param name="Data">Stat data value</param>
    /// <remarks>
    /// Data object for holding the contents of a stat column.
    /// </remarks>
    public class StatsColumn : WireData
    {
        public ushort ColumnId;
        public byte Type = 0;
        protected object _data = null;

        public StatsColumn()
        {
        }

        public StatsColumn(ushort ColumnId, byte Type, object Data)
        {
            this.ColumnId = ColumnId;
            this.Type     = Type;
            this._data    = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            ColumnId = binaryReader.ReadUInt16();
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_53,
                                           "Unexpected type: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(ColumnId);
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_54,
                                           "Unexpected type: " + Type.ToString());
            }
        }
    }

    /// <summary>
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="Rating">User rating</param>
    /// <param name="GamerTagLength">Length of gamer tag string</param>
    /// <param name="GamerTag">Gamer tag string</param>
    /// <param name="ColumnCount">Count of columns</param>
    /// <param name="Columns">Stats columns collection</param>
    /// <remarks>
    /// Data object for a stats result row
    /// </remarks>
    public class StatsRow : WireData
    {
        public ulong Puid   = 0;
        public uint  Rank   = 0;
        public ulong Rating = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAM_DATA)]
        public uint GamerTagLength = 0;

        [WireInfo(SizeParam="GamerTagLength")]
        public string GamerTag = null;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public StatsColumn[] Columns = null;

        public StatsRow()
        {
        }

        /// <summary>
        /// StatsRow constructor
        /// </summary>
        /// <param name="puid">User ID for row</param>
        /// <param name="rank">Rank of row</param>
        /// <param name="rating">Rating of row</param>
        /// <param name="gamerTag">GamerTag for row</param>
        /// <param name="columns">Count of columns of data in row</param>
        /// <remarks>
        /// Constructor that sets values for row and allocates an array for column data
        /// </remarks>
        public StatsRow(ulong puid, uint rank, ulong rating, string gamerTag, uint columns)
        {
            Puid        = puid;
            Rank        = rank;
            Rating      = rating;
            GamerTag    = gamerTag;
            ColumnCount = columns;
            Columns     = new StatsColumn[columns];
        }
    }

    /// <summary>
    /// StatsResultSet
    /// </summary>
    /// <param name="ViewId">View id (leaderboard ID)</param>
    /// <param name="RowCount">Stat row count</param>
    /// <param name="Rows">Stat rows collection</param>
    /// <remarks>
    /// Data object for result set of stat query
    /// </remarks
    public class StatsResultSet : WireData
    {
        public ulong ViewId;
        public uint ViewSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ROW_COUNT)]
        public uint RowCount = 0;

        [WireInfo(SizeParam="RowCount")]
        public StatsRow[] Rows = null;
    }

    /// <summary>
    /// StatsSpec
    /// </summary>
    /// <param name="ViewId">View id (leaderboard id)</param>
    /// <param name="ColumnCount">Count of column id's</param>
    /// <param name="ColumnIds">Collection of column id's to query</param>
    /// <remarks>
    /// Data object representing a stats query
    /// </remarks>
    public class StatsSpec : WireData
    {
        public uint ViewId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public ushort[] ColumnIds = null;
    }

    /// <summary>
    /// StatsOperatorParameter
    /// </summary>
    /// <param name="Type">Paramter data type (StatParamType)</param>
    /// <param name="Data">Parameter data</param>
    /// <remarks>
    /// Data object for a stats operator parameter
    /// </remarks>
    public class StatsOperatorParameter : WireData
    {
        public byte Type = 0;
        protected object _data = null;

        public StatsOperatorParameter()
        {
        }

        public StatsOperatorParameter(byte Type, object Data)
        {
            this.Type  = Type;
            this._data = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    binaryReader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_55,
                                           "Unexpected _datatype: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_56,
                                           "Unexpected _datatype: " + Type.ToString());
            }
        }

        public override string ToString(int indent)
        {
            StringBuilder bldr = new StringBuilder();

            bldr.Append("\n" + "".PadLeft(indent));
            bldr.Append("Type=" + Type + "\n");
            bldr.Append("".PadLeft(indent));
            bldr.Append("_data=");

            switch(Type)
            {
                case StatParam.Null:
                    bldr.Append("NULL");
                    break;
                case StatParam.Int8:
                    bldr.Append((Byte) _data);
                    break;
                case StatParam.Int16:
                    bldr.Append((Int16) _data);
                    break;
                case StatParam.Int32:
                    bldr.Append((Int32) _data);
                    break;
                case StatParam.Int64:
                    bldr.Append((Int64) _data);
                    break;
                case StatParam.Float:
                    bldr.Append((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    bldr.Append((UInt16) encstring.Length);
                    bldr.Append(encstring);
                    break;
                }
                case StatParam.Puid:
                    bldr.Append((UInt64) _data);
                    break;
                default:
                    bldr.Append("UNKNOWN!");
                    break;
            }

            return bldr.ToString();
        }
    }

    /// <summary>
    /// StatsOperator
    /// </summary>
    /// <param name="OperatorId">Operator type</param>
    /// <param name="ParameterCount">Count of operator parameters</param>
    /// <param name="Parameters">Collection of parameters</param>
    /// <remarks>
    /// Data object for a stats operator
    /// </remarks>
    public class StatsOperator : WireData
    {
        public ushort OperatorId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAMS)]
        public ushort ParameterCount = 0;

        [WireInfo(SizeParam="ParameterCount")]
        public StatsOperatorParameter[] Parameters = null;

        public StatsOperator()
        {
        }

        public StatsOperator(BinaryReader binaryReader)
        {
            base.ReadStream(binaryReader);
        }
    }

    /// <summary>
    /// StatsPostRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="OperatorCount">Count of operators</param>
    /// <param name="Operators">Collection of operators</param>
    /// <param name="TeamTickets">Collection of team tickets (optional)</param>
    /// <returns>StatsPostResponse</returns>
    /// <remarks>
    /// Batch of stat operator requests that generates StatsPostResponse.
    /// Operators dictate the functionality.
    /// Typical operators include REPLACE, ADD, MIN, MAX
    /// </remarks>
    public class StatsPostRequest : XRLObject2
    {
        public uint TitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_COUNT)]
        public ushort OperatorCount = 0;

        [WireInfo(SizeParam="OperatorCount")]
        public StatsOperator[] Operators = null;

        public TeamTickets TeamTickets = null;

        public override string Xrl
        {
            get { return "/xstats/xstatpostxe.ashx"; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            TitleId       = binaryReader.ReadUInt32();
            OperatorCount = binaryReader.ReadUInt16();

            if (OperatorCount > XOn.XONLINE_MAX_STATS_OP_COUNT)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, XEvent.Id.COMMON_HACK_40,
                    "Operators exceed max allowed (" + OperatorCount + ")");
            }
            ArrayList operators = new ArrayList();
            for (ushort i = 0; i < OperatorCount; i++)
            {
                operators.Add(new StatsOperator(binaryReader));
            }
            Operators = new StatsOperator[OperatorCount];
            operators.CopyTo(Operators);

            // Check to see if there are any team tickets
            try
            {
                
                TeamTickets = new TeamTickets(binaryReader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(TitleId);

            if (OperatorCount == 0 && Operators.Length > 0)
            {
                OperatorCount = (ushort) Operators.Length;
            }

            binaryWriter.Write(OperatorCount);

            foreach (StatsOperator op in Operators)
            {
                op.WriteStream(binaryWriter);
            }

            if (TeamTickets != null)
            {
                TeamTickets.WriteStream(binaryWriter);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\nTitleId=" + TitleId +
                "\nOperatorCount=" + OperatorCount +
                "\nOperators: ");

            if (Operators != null)
            {
                foreach (StatsOperator op in Operators)
                {
                    str.Append(op.ToString());
                }
            }

            str.Append("\nTeamTickets: " + (TeamTickets != null ? TeamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }

    /// <summary>
    /// StatsPostResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response for StatPostRequest.
    /// </remarks>
    public class StatsPostResponse : XRLObject2
    {
        public uint TitleId = 0;

        // TODO: Return array of operation return codes
    }

    /// <summary>
    /// StatsReadRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserCount">Count of users</param>
    /// <param name="Users">Collection of user id's</param>
    /// <param name="SpecCount">Count of query specs</param>
    /// <param name="Specs">Collection of query specs</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Query for users and specific view columns.
    /// Results are generated with one result set per query spec with
    /// each user having a record in the result set.
    /// </remarks>
    public class StatsReadRequest : XRLObject2
    {
        public uint TitleId;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_USER_COUNT)]
        public uint UserCount;

        [WireInfo(SizeParam="UserCount")]
        public ulong[] Users = null;

        // TODO: make the spec count NPDB configurable
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint SpecCount;

        [WireInfo(SizeParam="SpecCount")]
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatread.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByUserRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User id for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified user id and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByUserRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong UserId   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyuser.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByRankRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rank">Rank value for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rank and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRankRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rank     = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyrank.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByRatingRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rating">Rating for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rating and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRatingRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rating   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyrating.ashx"; }
        }
    }

    /// <summary>
    /// StatsReadResponse
    /// </summary>
    /// <param name="ResultsCount">Count of result sets</param>
    /// <param name="Results">Collection of result sets</param>
    /// <remarks>
    /// Response to StatsReadRequest.
    /// Contains collection of result sets for the corresponding query specs.
    /// </remarks>
    public class StatsReadResponse : XRLObject2
    {
        [WireInfo (Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint ResultsCount = 0;

        [WireInfo(SizeParam="ResultsCount")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEnumResponse : XRLObject2
    {
        public ushort StatsResultSetLen = 0;
        [WireInfo(SizeParam="StatsResultSetLen")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEstimateRankRequestStruct:XRLObject2
    {
        public int   m_nLbId = 0;
        public ulong m_ulRating = 0;
    }
    
    public class StatsEstimateRankForRatingsRequest:XRLObject2
    {
        public int  m_nTitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRatingRequestCount = 0;

        [WireInfo(SizeParam="m_uRatingRequestCount")]
        public StatsEstimateRankRequestStruct[] m_arrRatingStruct = null;

        public override string Xrl
        {
            get { return "/xstats/xstatestimaterankforratings.ashx"; }
        }
    }

    public class StatsEstimateRankForRatingsResponse:XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRankForRatingReplyCount = 0;

        [WireInfo(SizeParam="m_uRankForRatingReplyCount")]
        public uint[] m_arruiRankForRating = null;
    }

    #endregion

    #region Achievements Protocol (Xenon)

    /// <summary>
    /// Achievement
    /// </summary>
    /// <param name="AchievementId">Achievement ID</param>
    /// <param name="Achieved">Achieved datetime</param>
    /// <param name="Flags">Flags</param>
    /// <remarks>
    /// Data object for an achievement
    /// </remarks>
    public class Achievement : WireData
    {
        public uint  AchievementId = 0;
        public DateTime Achieved   = XOn.MinDateTime;
        public uint  Sequence      = 0;
        public int   Flags         = 0;
        public byte  Type          = 0;
        public int   Cred          = 0;

        public uint  ImageId       = 0;

        public byte TitleLen       = 0;
        public string Title        = "";

        public byte DescriptionLen = 0;
        public string Description  = "";

        public byte HowToLen       = 0;
        public string HowTo        = "";

        public byte NextIdsLen     = 0;
        public uint[] NextIds      = null;

        public byte ReplaceIdsLen  = 0;
        public uint[] ReplaceIds      = null;


        public Achievement()
        {
        }

        /// <summary>
        /// Achievement
        /// </summary>
        /// <param name="achievementId">Achievement ID</param>
        /// <param name="achieved">Achieved datetime</param>
        /// <param name="flags">Flags</param>
        /// <remarks>
        /// Achievement constructor
        /// </remarks>
        public Achievement(uint achievementId, DateTime achieved, int flags)
        {
            this.AchievementId = achievementId;
            this.Achieved      = achieved;
            this.Flags         = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            uint newFlags = (uint)existingFlags & ~(XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK);
            uint avatarFlag = (uint)MapPlatformTypeFlags(platformType);
            newFlags |= (uint)avatarFlag & XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;
            return (int)newFlags;
        }
        // Function added to map the XPL_* platform flags to the XAVATAR_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn avatar awards
        public static int MapPlatformTypeFlags(int platformType)
        {
            return (int)ProfileDefs.XOnPlatformToXProfilePlatform((uint)platformType) << XOn.XACHIEVEMENT_DETAILS_PLATFORM_SHIFT;
        }

        public static int GetPlatformTypeFromFlags(int flags)
        {
            uint platformFlags = (uint)flags & XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;
            uint platform = (uint)platformFlags >> XOn.XACHIEVEMENT_DETAILS_PLATFORM_SHIFT;
            return (int)ProfileDefs.XProfilePlatformToXOnPlatform(platform);
        }
    }

    /// <summary>
    /// AchievementWriteRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievements</param>
    /// <returns>AchievementWriteResponse</returns>
    /// <remarks>
    /// Request to write a set of achievements to the database for a specific user + title.
    /// </remarks>
    public class SyncAchievementsRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong UserId  = 0;
        public DateTime Version = XOn.MinDateTime;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;

        public override string Xrl
        {
            get { return "/xstats/syncachievements.ashx"; }
        }
    }

    /// <summary>
    /// AchievementWriteResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class SyncAchievementsResponse : XRLObject2
    {
        public DateTime Version = XOn.MinDateTime;
        public ushort TotalAchievements = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort  AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementEnumRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementEmumResponse</returns>
    /// <remarks>
    /// Request to read all achievements for a specific user
    /// </remarks>
    public class AchievementEnumRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAchievements = XOn.XONLINE_MAX_ACHIEVEMENTS;


        public override string Xrl
        {
            get { return "/xstats/xachievementenum.ashx"; }
        }
    }

    /// <summary>
    /// AchievementEnumResponse
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementsCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievement descriptions</param>
    /// <remarks>
    /// Response to AchievementEnumRequest.
    /// </remarks>
    public class AchievementEnumResponse : XRLObject2
    {
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementClearRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementClearResponse</returns>
    /// <remarks>
    /// Request to clear all achievements for a specific user
    /// for the specified title id
    /// </remarks>
    public class AchievementClearRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;

        public override string Xrl
        {
            get { return "/xstats/xachievementclear.ashx"; }
        }
    }

    /// <summary>
    /// AchievementClearResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <returns>Puid</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class AchievementClearResponse : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
    }

    #endregion

    #region Avatar Assets Protocol (Xenon)

    /// <summary>
    /// AvatarAsset
    /// </summary>
    /// <param name="AvatarAssetOrdinal">Avatar Asset Ordinal</param>
    /// <param name="Awarded">Awarded datetime</param>
    /// <param name="Flags">Flags</param>
    /// <remarks>
    /// Data object for an avatar asset
    /// </remarks>
    public class AvatarAsset : WireData
    {
        public uint AvatarAssetOrdinal = 0;
        public DateTime Awarded = XOn.MinDateTime;
        public uint Sequence = 0;
        public int Flags = 0;

        // guid assigned to asset by XLAST
        [WireInfo(ArraySize = 16)]
        public byte[] AvatarAssetId;

        public uint ImageId = 0;

        public byte TitleLen = 0;
        public string Title = "";

        public byte DescriptionLen = 0;
        public string Description = "";

        public byte HowToLen = 0;
        public string HowTo = "";

        public byte BodyTypeMask = 0;
        public uint BodyComponent = 0;
        public uint SubCategory = 0;

        public AvatarAsset()
        {
        }

        /// <summary>
        /// AvatarAsset
        /// </summary>
        /// <param name="avatarAssetOrdinal">Avatar Asset Ordinal</param>
        /// <param name="avatarAssetBodyTypeMask">Avatar Asset Body Type mask</param>
        /// <param name="awarded">Awarded datetime</param>
        /// <param name="flags">Flags</param>
        /// <remarks>
        /// AvatarAsset constructor
        /// </remarks>
        public AvatarAsset(uint avatarAssetOrdinal, byte avatarAssetBodyTypeMask, DateTime awarded, int flags)
        {
            this.AvatarAssetOrdinal = avatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Awarded = awarded;
            this.Flags = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            uint newFlags = (uint)existingFlags & ~(XOn.XAVATAR_DETAILS_PLATFORM_MASK);
            uint avatarFlag = (uint)MapPlatformTypeFlags(platformType);
            newFlags |= (uint)avatarFlag & XOn.XAVATAR_DETAILS_PLATFORM_MASK;
            return (int)newFlags;
        }
        // Function added to map the XPL_* platform flags to the XAVATAR_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn avatar awards
        public static int MapPlatformTypeFlags(int platformType)
        {
            return (int)ProfileDefs.XOnPlatformToXProfilePlatform((uint)platformType) << XOn.XAVATAR_DETAILS_PLATFORM_SHIFT;
        }

        public static int GetPlatformTypeFromFlags(int flags)
        {
            uint platformFlags = (uint)flags & XOn.XAVATAR_DETAILS_PLATFORM_MASK;
            uint platform = (uint)platformFlags >> XOn.XAVATAR_DETAILS_PLATFORM_SHIFT;
            return (int)ProfileDefs.XProfilePlatformToXOnPlatform(platform);
        }
    }

    /// <summary>
    /// SyncAvatarAssetRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AvatarAssetCount">Count of avatar assets</param>
    /// <param name="AvatarAssets">Collection of avatar assets</param>
    /// <returns>SyncAvatarAssetResponse</returns>
    /// <remarks>
    /// Request to write a set of avatar assets to the database for a specific user + title.
    /// </remarks>
    public class SyncAvatarAssetRequest : XRLObject2
    {
        public uint TitleId = 0;
        public ulong UserId = 0;
        public DateTime Version = XOn.MinDateTime;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_AVATAR_ASSETS)]
        public ushort AvatarAssetCount = 0;

        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;

        public override string Xrl
        {
            get { return "/xstats/syncavatarassets.ashx"; }
        }
    }

    /// <summary>
    /// SyncAvatarAssetResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response to a SyncAvatarAssetRequest.
    /// </remarks>
    public class SyncAvatarAssetResponse : XRLObject2
    {
        public DateTime Version = XOn.MinDateTime;
        public uint MoreAvatarAssetPending = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_AVATAR_ASSETS)]
        public ushort AvatarAssetCount = 0;

        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
    }

    /// <summary>
    /// AvatarAssetEnumRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AvatarAssetEnumResponse</returns>
    /// <remarks>
    /// Request to read all avatar assets for a specific user
    /// </remarks>
    public class AvatarAssetEnumRequest : XRLObject2
    {
        public uint TitleId = 0;
        public ulong Puid = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAssets = XOn.XONLINE_MAX_AVATAR_ASSETS;


        public override string Xrl
        {
            get { return "/xstats/xavatarassetenum.ashx"; }
        }
    }

    /// <summary>
    /// AvatarAssetEnumResponse
    /// </summary>
    /// <param name="AvatarAssetsCount">Count of avatar assets</param>
    /// <param name="AvatarAssets">Collection of avatar asset information</param>
    /// <remarks>
    /// Response to AvatarAssetEnumRequest.
    /// </remarks>
    public class AvatarAssetEnumResponse : XRLObject2
    {
        public ushort AvatarAssetsCount = 0;

        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAsset[] AvatarAssets = null;
    }

    /// <summary>
    /// ValidateAvatarManifestRequest
    /// </summary>
    /// <param name="UserId">User PUID</param>
    /// <param name="ValidationFlags">Types of validation requested by client. 0 means default.</param>
    /// <returns>ValidateAvatarManifestResponse</returns>
    /// <remarks>
    /// Request to read all avatar assets for a specific user
    /// </remarks>
    public class ValidateAvatarManifestRequest : XRLObject2
    {
        public ulong UserId = 0;

        // flags that can be set with ValidationFlags
        public const int XAVATAR_VALIDATE_AVATAR_AWARDS = 0x00000001;

        public uint ValidationFlags = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_SETTING_VALUE_BYTES)]
        public ushort AvatarManifestLen = 0;

        [WireInfo(SizeParam = "AvatarManifestLen")]
        public byte[] AvatarManifest = null;

        public override string Xrl
        {
            get { return "/xstats/validateavatarmanifest.ashx"; }
        }
    }

    /// <summary>
    /// ValidateAvatarManifestResponse
    /// </summary>
    /// <param name="ValidationResult">Zero for failure, non-zero for success.</param>
    /// <remarks>
    /// Response to ValidateAvatarManifestRequest.
    /// </remarks>
    public class ValidateAvatarManifestResponse : XRLObject2
    {
        public byte ValidationResult = 0;
    }

    #endregion

    public class ProfileDefs
    {
        public const uint XPROFILE_PERMISSIONS                          = 0x10040000;
        public const uint XPROFILE_GAMER_TYPE                           = 0x10040001;
        public const uint XPROFILE_GAMER_YAXIS_INVERSION                = 0x10040002;
        public const uint XPROFILE_OPTION_CONTROLLER_VIBRATION          = 0x10040003;
        public const uint XPROFILE_TITLE_SPECIFIC1                      = 0x63E83FFF;
        public const uint XPROFILE_TITLE_SPECIFIC2                      = 0x63E83FFE;
        public const uint XPROFILE_TITLE_SPECIFIC3                      = 0x63E83FFD;
        public const uint XPROFILE_GAMERCARD_ZONE                       = 0x10040004;
        public const uint XPROFILE_GAMERCARD_REGION                     = 0x10040005;
        public const uint XPROFILE_GAMERCARD_CRED                       = 0x10040006;
        public const uint XPROFILE_GAMER_PRESENCE_USER_STATE            = 0x10040007;
        public const uint XPROFILE_GAMERCARD_HAS_VISION                 = 0x10040008;
        public const uint XPROFILE_GAMERCARD_REP                        = 0x5004000B;
        public const uint XPROFILE_OPTION_VOICE_MUTED                   = 0x1004000C;
        public const uint XPROFILE_OPTION_VOICE_THRU_SPEAKERS           = 0x1004000D;
        public const uint XPROFILE_OPTION_VOICE_VOLUME                  = 0x1004000E;
        public const uint XPROFILE_GAMERCARD_PICTURE_KEY                = 0x4064000F;
        public const uint XPROFILE_GAMERCARD_PERSONAL_PICTURE           = 0x40640010;
        public const uint XPROFILE_GAMERCARD_MOTTO                      = 0x402C0011;
        public const uint XPROFILE_GAMERCARD_TITLES_PLAYED              = 0x10040012;
        public const uint XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED        = 0x10040013;
        public const uint XPROFILE_GAMER_DIFFICULTY                     = 0x10040015;
        public const uint XPROFILE_GAMER_CONTROL_SENSITIVITY            = 0x10040018;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_FIRST          = 0x1004001d;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_SECOND         = 0x1004001e;
        public const uint XPROFILE_GAMER_ACTION_AUTO_AIM                = 0x10040022;
        public const uint XPROFILE_GAMER_ACTION_AUTO_CENTER             = 0x10040023;
        public const uint XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL        = 0x10040024;
        public const uint XPROFILE_GAMER_RACE_TRANSMISSION              = 0x10040026;
        public const uint XPROFILE_GAMER_RACE_CAMERA_LOCATION           = 0x10040027;
        public const uint XPROFILE_GAMER_RACE_BRAKE_CONTROL             = 0x10040028;
        public const uint XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL       = 0x10040029;
        public const uint XPROFILE_GAMERCARD_TITLE_CRED_EARNED          = 0x10040038;
        public const uint XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED  = 0x10040039;
        public const uint XPROFILE_GAMER_TIER                           = 0x1004003A;
        public const uint XPROFILE_MESSENGER_SIGNUP_STATE               = 0x1004003B;
        public const uint XPROFILE_MESSENGER_AUTO_SIGNIN                = 0x1004003C;
        public const uint XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD           = 0x1004003D;
        public const uint XPROFILE_FRIENDSAPP_SHOW_BUDDIES              = 0x1004003E;
        public const uint XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS         = 0x1004003F;
        public const uint XPROFILE_GAMERCARD_USER_NAME                  = 0x41040040;
        public const uint XPROFILE_GAMERCARD_USER_LOCATION              = 0x40520041;
        public const uint XPROFILE_GAMERCARD_USER_URL                   = 0x41900042;
        public const uint XPROFILE_GAMERCARD_USER_BIO                   = 0x43E80043;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_1              = 0x63E80044;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_2              = 0x63E80045;
        public const uint XPROFILE_GAMERCARD_PARTY_INFO                 = 0x61000046;
        public const uint XPROFILE_TENURE_LEVEL                         = 0x10040047;
        public const uint XPROFILE_TENURE_MILESTONE                     = 0x10040048;
        public const uint XPROFILE_TENURE_NEXT_MILESTONE_DATE           = 0x70080049; // client-only setting 
        public const uint XPROFILE_SUBSCRIPTION_TYPE_LENGTH_IN_MONTHS   = 0x1004004B; // client-only setting
        public const uint XPROFILE_SUBSCRIPTION_PAYMENT_TYPE            = 0x1004004C; // client-only setting
        public const uint XPROFILE_VIDEO_METADATA                       = 0x6020004A;
        public const uint XPROFILE_JUMP_IN_LIST                         = 0x63E80051;

        // Web-only settings
        public const uint WEB_EMAIL_FORMAT                              = 0x10042000;
        public const uint WEB_FLAGS                                     = 0x10042001;
        public const uint WEB_SPAM                                      = 0x10042002;
        public const uint WEB_FAVORITE_GENRE                            = 0x10042003;
        public const uint WEB_FAVORITE_GAME                             = 0x10042004;
        public const uint WEB_FAVORITE_GAME1                            = 0x10042005;
        public const uint WEB_FAVORITE_GAME2                            = 0x10042006;
        public const uint WEB_FAVORITE_GAME3                            = 0x10042007;
        public const uint WEB_FAVORITE_GAME4                            = 0x10042008;
        public const uint WEB_FAVORITE_GAME5                            = 0x10042009;
        public const uint WEB_PLATFORMS_OWNED                           = 0x1004200a;
        public const uint WEB_CONNECTION_SPEED                          = 0x1004200b;
        public const uint WEB_FLASH                                     = 0x1004200c;
        public const uint WEB_VIDEO_PREFERENCE                          = 0x1004200d;

        // Argo/Crux settings
        public const uint XPROFILE_CRUX_MEDIA_PICTURE                   = 0x406403E8;
        public const uint XPROFILE_CRUX_MEDIA_STYLE1                    = 0x100403EA;
        public const uint XPROFILE_CRUX_MEDIA_STYLE2                    = 0x100403EB;
        public const uint XPROFILE_CRUX_MEDIA_STYLE3                    = 0x100403EC;
        public const uint XPROFILE_CRUX_TOP_ALBUM1                      = 0x100403ED;
        public const uint XPROFILE_CRUX_TOP_ALBUM2                      = 0x100403EE;
        public const uint XPROFILE_CRUX_TOP_ALBUM3                      = 0x100403EF;
        public const uint XPROFILE_CRUX_TOP_ALBUM4                      = 0x100403F0;
        public const uint XPROFILE_CRUX_TOP_ALBUM5                      = 0x100403F1;
        public const uint XPROFILE_CRUX_OFFLINE_ID                      = 0x603403F2;
        public const uint XPROFILE_CRUX_BKGD_IMAGE                      = 0x100403F3;
        public const uint XPROFILE_CRUX_LAST_CHANGE_TIME                = 0x700803F4;
        public const uint XPROFILE_CRUX_TOP_MUSIC                       = 0x60A803F5;
        public const uint XPROFILE_CRUX_MEDIA_MOTTO                     = 0x410003F6;
        public const uint XPROFILE_CRUX_TOP_MEDIAID1                    = 0x601003F7;
        public const uint XPROFILE_CRUX_TOP_MEDIAID2                    = 0x601003F8;
        public const uint XPROFILE_CRUX_TOP_MEDIAID3                    = 0x601003F9;
        public const uint XPROFILE_CRUX_BIO                             = 0x43E803FA;
        public const uint XPROFILE_CRUX_BG_SMALL_PUBLIC                 = 0x406403FD;
        public const uint XPROFILE_CRUX_BG_LARGE_PUBLIC                 = 0x406403FE;

        // Bit defines for XPROFILE_GAMER_TYPE
        public const uint XPROFILE_GAMER_TYPE_TEAM                      = 0x00000001;
        public const uint XPROFILE_GAMER_TYPE_CHEATER                   = 0x00000002;
        public const uint XPROFILE_GAMER_TYPE_NXE_TEAM                  = 0x00000004;

        // Service Types
        // (service type flag) = 0x1 << (service type id)
        // service type ids are found in t_service_types
        // 1 = Xbox Live
        // 2 = Zune
        public const uint XPROFILE_SERVICE_TYPE_FLAG_XBOX = 0x2;
        public const uint XPROFILE_SERVICE_TYPE_FLAG_ZUNE = 0x4;


        // Platform conversion stuff
        public const uint XPROFILE_PLATFORM_TYPE_360 = 1;
        public const uint XPROFILE_PLATFORM_TYPE_PC = 2;
        public const uint XPROFILE_PLATFORM_TYPE_MOBILE = 3;
        public const uint XPROFILE_PLATFORM_TYPE_WEB_GAMES = 4;

        public static uint XOnPlatformToXProfilePlatform(uint xop)
        {
            switch (xop)
            {
                case XOn.XPLT_XBOX360:
                    return XPROFILE_PLATFORM_TYPE_360;
                case XOn.XPLT_PC:
                    return XPROFILE_PLATFORM_TYPE_PC;
                case XOn.XPLT_MOBILE:
                    return XPROFILE_PLATFORM_TYPE_MOBILE;
                case XOn.XPLT_WEB_GAMES:
                    return XPROFILE_PLATFORM_TYPE_WEB_GAMES;
                default:
                    return 0;
            }
        }

        public static uint XProfilePlatformToXOnPlatform(uint xpp)
        {
            switch (xpp)
            {
                case XPROFILE_PLATFORM_TYPE_360:
                    return XOn.XPLT_XBOX360;
                case XPROFILE_PLATFORM_TYPE_PC:
                    return XOn.XPLT_PC;
                case XPROFILE_PLATFORM_TYPE_MOBILE:
                    return XOn.XPLT_MOBILE;
                case XPROFILE_PLATFORM_TYPE_WEB_GAMES:
                    return XOn.XPLT_WEB_GAMES;
                default:
                    return 0;
            }
        }
        

        // cache stuff
        public static byte[] BuildCacheKey(uint settingId, uint titleId, ulong userId)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter br = new BinaryWriter(ms);
            br.Write(ProfileDefs.CachePrefix);
            br.Write(titleId);
            br.Write(settingId);
            br.Write(userId);
            return ms.ToArray();
        }
        
        public static byte[] CachePrefix
        {
            get
            {
                return _CachePrefix;
            }
        }
        public static byte[] CacheNoValue
        {
            get 
            {
                return _CacheNoValue;
            }
        }

        private static byte[] _CachePrefix;
        private static byte[] _CacheNoValue;

        static ProfileDefs()
        {
            _CachePrefix = new byte[] {(byte)'P', (byte)'r', (byte)'o', (byte)'f', (byte)'i', (byte)'l', (byte)'e'};
            _CacheNoValue = new byte[] {(byte)'N', (byte)'o', (byte)' ', (byte)'V', (byte)'a', (byte)'l', (byte)'u', (byte)'e'};
        }
    }

    #region Gamer Profile Protocol (Xenon)

    /// <summary>
    /// UserSetting
    /// </summary>
    /// <remarks>
    /// Describes a single setting.  Used in both setting and getting values.
    /// </remarks>
    public class UserSetting : WireData
    {
        public UserSetting() {}
        public UserSetting(ulong userId, uint settingId)
        {
            UserId = userId;
            SettingId = settingId;
        }
        public UserSetting(ulong userId, uint source, uint settingId, byte[] value)
        {
            UserId = userId;
            SettingId = settingId;
            Source = source;
            Value = value;
        }

        public uint Source = XOn.XSOURCE_NO_VALUE;
        public ulong UserId = 0;
        public uint SettingId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_VALUE_BYTES)]
        public ushort ValueLen = 0;

        [WireInfo(SizeParam="ValueLen")]
        public byte[] Value = null;
    }

    /// <summary>
    /// ReadSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="ForUserIdsLen">Count of user id's</param>
    /// <param name="ForUserIds">User ids to read</param>
    /// <param name="SettingsIdsLen">Count of settings</param>
    /// <param name="SettingsIds">Setting ids to read</param>
    /// <remarks>
    /// Retrieves a list of settings for a list of users
    /// </remarks>
    public class ReadSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort ForUserIdsLen;
        [WireInfo(SizeParam="ForUserIdsLen")]
        public ulong[] ForUserIds;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingIdsLen;
        [WireInfo(SizeParam="SettingIdsLen")]
        public uint[] SettingIds;

        public override string Xrl
        {
            get { return "/xstats/readsettings.ashx"; }
        }
     }

    /// <summary>
    /// ReadSettingsResponse
    /// </summary>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to ReadSettingsRequest
    /// </remarks>
    public class ReadSettingsResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT * XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }





    public class UserTitle : WireData
    {
        public UserTitle() {}
        public UserTitle(uint titleId, DateTime lastPlayed, uint sequence, uint creds, ushort achievements)
        {
            TitleId = titleId;
            LastPlayed = lastPlayed;
            Sequence = sequence;
            NumCreds = creds;
            NumAchievements = achievements;
        }


        public uint TitleId = 0;

        [WireInfo(Max=XOn.MAX_TITLE_NAME_LEN)]
        public ushort TitleNameLen = 0;

        [WireInfo(SizeParam="TitleNameLen")]
        public string TitleName = "";

        public DateTime LastPlayed = DateTime.MinValue;
        public uint NumCreds = 0;
        public ushort NumAchievements = 0;
        public ushort TotalAchievements = 0;
        public uint TotalCred = 0;
        public uint Sequence = 0;
        public byte HasExtendedData = 0;
        public byte TitleType = 0;
        public ushort PlatformFlags = 0;

        public void SetPlatformFlag(uint xplatformid, bool value)
        {
            uint xprofileid = ProfileDefs.XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            PlatformFlags &= (ushort)~mask;
            PlatformFlags |= (ushort)(value ? mask : 0);
        }

        public bool HasPlatformFlag(uint xplatformid)
        {
            uint xprofileid = ProfileDefs.XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            return (PlatformFlags & mask) != 0;
        }

        public bool ShouldAppearInUserHistory()
        {
            if (TotalAchievements > 0) return true;  // title has achievements, so it must be public.

            if (HasExtendedData == 0) return true;  // no extended data to base on.  can't do any further filtering.

            // for anything that's made it this far, filter out title type (system, demo, app).
            if (TitleType == XOn.TITLE_TYPE_SYSTEM) return false;
            if (TitleType == XOn.TITLE_TYPE_DEMO) return false;
            if (TitleType == XOn.TITLE_TYPE_APPLICATION) return false;

            // else
            return true;
        }
    }

    public class SyncTitlesRequest : XRLObject2
    {
        public SyncTitlesRequest() {}
        public SyncTitlesRequest(ulong userId, DateTime version)
        {
            UserId = userId;
            Version = version;
        }

        public ulong UserId = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        public DateTime Version = DateTime.MinValue;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;



        public override string Xrl
        {
            get { return "/xstats/synctitles.ashx"; }
        }
    }


    public class SyncTitlesResponse : XRLObject2
    {
        public DateTime Version = DateTime.MinValue;
        public ushort TotalTitles = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;
    }




    public class EnumTitlesRequest : XRLObject2
    {
        public EnumTitlesRequest() {}
        public EnumTitlesRequest(ulong userId, ulong forUserId, ushort startingIndex, ushort maxTitles)
        {
            UserId = userId;
            ForUserId = forUserId;
            StartingIndex = startingIndex;
            MaxTitles = maxTitles;
        }

        public ulong UserId;
        public ulong ForUserId;
        public ushort LocaleId;
        public ushort StartingIndex;
        public ushort MaxTitles;

        public override string Xrl
        {
            get { return "/xstats/enumtitles.ashx"; }
        }


    }

    public class EnumTitlesResponse : XRLObject2
    {
        public ushort TitlesLen;
        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles;
    }



    public class TitleClearRequest : XRLObject2
    {
        public ulong UserId;
        public uint TitleId;

        public override string Xrl
        {
            get { return "/xstats/cleartitle.ashx"; }
        }

    }






    /// <summary>
    /// SyncSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Updates one or more of a single user's profile settings
    /// </remarks>
    public class SyncSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;
        public DateTime Version;
        public ushort StartinIndex;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        public override string Xrl
        {
            get { return "/xstats/syncsettings.ashx"; }
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncSettingsResponse : XRLObject2
    {
        public DateTime Version;
        public ushort TotalSettings;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }




    public class SyncAllRequest : XRLObject2
    {
        public SyncAllRequest() {}
        public SyncAllRequest(ulong userId, uint titleId, ushort localeId, byte[] guid)
        {
            UserId = userId;
            TitleId = titleId;
            LocaleId = localeId;
            Guid = guid;
        }


        public uint TitleId;
        public ulong UserId;
        public ushort LocaleId;

        [WireInfo(ArraySize=16)]
        public byte[] Guid;


        // settings
        //
        